// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateLedgerPermissionsModeOutput {
    /// <p>The name of the ledger.</p>
    pub name: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) for the ledger.</p>
    pub arn: std::option::Option<std::string::String>,
    /// <p>The current permissions mode of the ledger.</p>
    pub permissions_mode: std::option::Option<crate::model::PermissionsMode>,
}
impl UpdateLedgerPermissionsModeOutput {
    /// <p>The name of the ledger.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) for the ledger.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>The current permissions mode of the ledger.</p>
    pub fn permissions_mode(&self) -> std::option::Option<&crate::model::PermissionsMode> {
        self.permissions_mode.as_ref()
    }
}
impl std::fmt::Debug for UpdateLedgerPermissionsModeOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateLedgerPermissionsModeOutput");
        formatter.field("name", &self.name);
        formatter.field("arn", &self.arn);
        formatter.field("permissions_mode", &self.permissions_mode);
        formatter.finish()
    }
}
/// See [`UpdateLedgerPermissionsModeOutput`](crate::output::UpdateLedgerPermissionsModeOutput)
pub mod update_ledger_permissions_mode_output {
    /// A builder for [`UpdateLedgerPermissionsModeOutput`](crate::output::UpdateLedgerPermissionsModeOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) permissions_mode: std::option::Option<crate::model::PermissionsMode>,
    }
    impl Builder {
        /// <p>The name of the ledger.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the ledger.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) for the ledger.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) for the ledger.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>The current permissions mode of the ledger.</p>
        pub fn permissions_mode(mut self, input: crate::model::PermissionsMode) -> Self {
            self.permissions_mode = Some(input);
            self
        }
        /// <p>The current permissions mode of the ledger.</p>
        pub fn set_permissions_mode(
            mut self,
            input: std::option::Option<crate::model::PermissionsMode>,
        ) -> Self {
            self.permissions_mode = input;
            self
        }
        /// Consumes the builder and constructs a [`UpdateLedgerPermissionsModeOutput`](crate::output::UpdateLedgerPermissionsModeOutput)
        pub fn build(self) -> crate::output::UpdateLedgerPermissionsModeOutput {
            crate::output::UpdateLedgerPermissionsModeOutput {
                name: self.name,
                arn: self.arn,
                permissions_mode: self.permissions_mode,
            }
        }
    }
}
impl UpdateLedgerPermissionsModeOutput {
    /// Creates a new builder-style object to manufacture [`UpdateLedgerPermissionsModeOutput`](crate::output::UpdateLedgerPermissionsModeOutput)
    pub fn builder() -> crate::output::update_ledger_permissions_mode_output::Builder {
        crate::output::update_ledger_permissions_mode_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateLedgerOutput {
    /// <p>The name of the ledger.</p>
    pub name: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) for the ledger.</p>
    pub arn: std::option::Option<std::string::String>,
    /// <p>The current status of the ledger.</p>
    pub state: std::option::Option<crate::model::LedgerState>,
    /// <p>The date and time, in epoch time format, when the ledger was created. (Epoch time format
    /// is the number of seconds elapsed since 12:00:00 AM January 1, 1970 UTC.)</p>
    pub creation_date_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The flag that prevents a ledger from being deleted by any user. If not provided on
    /// ledger creation, this feature is enabled (<code>true</code>) by default.</p>
    /// <p>If deletion protection is enabled, you must first disable it before you can delete the
    /// ledger. You can disable it by calling the <code>UpdateLedger</code> operation to set the flag to <code>false</code>.</p>
    pub deletion_protection: std::option::Option<bool>,
    /// <p>Information about the encryption of data at rest in the ledger. This includes the
    /// current status, the KMS key, and when the key became inaccessible (in the case of an
    /// error).</p>
    pub encryption_description: std::option::Option<crate::model::LedgerEncryptionDescription>,
}
impl UpdateLedgerOutput {
    /// <p>The name of the ledger.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) for the ledger.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>The current status of the ledger.</p>
    pub fn state(&self) -> std::option::Option<&crate::model::LedgerState> {
        self.state.as_ref()
    }
    /// <p>The date and time, in epoch time format, when the ledger was created. (Epoch time format
    /// is the number of seconds elapsed since 12:00:00 AM January 1, 1970 UTC.)</p>
    pub fn creation_date_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.creation_date_time.as_ref()
    }
    /// <p>The flag that prevents a ledger from being deleted by any user. If not provided on
    /// ledger creation, this feature is enabled (<code>true</code>) by default.</p>
    /// <p>If deletion protection is enabled, you must first disable it before you can delete the
    /// ledger. You can disable it by calling the <code>UpdateLedger</code> operation to set the flag to <code>false</code>.</p>
    pub fn deletion_protection(&self) -> std::option::Option<bool> {
        self.deletion_protection
    }
    /// <p>Information about the encryption of data at rest in the ledger. This includes the
    /// current status, the KMS key, and when the key became inaccessible (in the case of an
    /// error).</p>
    pub fn encryption_description(
        &self,
    ) -> std::option::Option<&crate::model::LedgerEncryptionDescription> {
        self.encryption_description.as_ref()
    }
}
impl std::fmt::Debug for UpdateLedgerOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateLedgerOutput");
        formatter.field("name", &self.name);
        formatter.field("arn", &self.arn);
        formatter.field("state", &self.state);
        formatter.field("creation_date_time", &self.creation_date_time);
        formatter.field("deletion_protection", &self.deletion_protection);
        formatter.field("encryption_description", &self.encryption_description);
        formatter.finish()
    }
}
/// See [`UpdateLedgerOutput`](crate::output::UpdateLedgerOutput)
pub mod update_ledger_output {
    /// A builder for [`UpdateLedgerOutput`](crate::output::UpdateLedgerOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) state: std::option::Option<crate::model::LedgerState>,
        pub(crate) creation_date_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) deletion_protection: std::option::Option<bool>,
        pub(crate) encryption_description:
            std::option::Option<crate::model::LedgerEncryptionDescription>,
    }
    impl Builder {
        /// <p>The name of the ledger.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the ledger.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) for the ledger.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) for the ledger.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>The current status of the ledger.</p>
        pub fn state(mut self, input: crate::model::LedgerState) -> Self {
            self.state = Some(input);
            self
        }
        /// <p>The current status of the ledger.</p>
        pub fn set_state(mut self, input: std::option::Option<crate::model::LedgerState>) -> Self {
            self.state = input;
            self
        }
        /// <p>The date and time, in epoch time format, when the ledger was created. (Epoch time format
        /// is the number of seconds elapsed since 12:00:00 AM January 1, 1970 UTC.)</p>
        pub fn creation_date_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.creation_date_time = Some(input);
            self
        }
        /// <p>The date and time, in epoch time format, when the ledger was created. (Epoch time format
        /// is the number of seconds elapsed since 12:00:00 AM January 1, 1970 UTC.)</p>
        pub fn set_creation_date_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.creation_date_time = input;
            self
        }
        /// <p>The flag that prevents a ledger from being deleted by any user. If not provided on
        /// ledger creation, this feature is enabled (<code>true</code>) by default.</p>
        /// <p>If deletion protection is enabled, you must first disable it before you can delete the
        /// ledger. You can disable it by calling the <code>UpdateLedger</code> operation to set the flag to <code>false</code>.</p>
        pub fn deletion_protection(mut self, input: bool) -> Self {
            self.deletion_protection = Some(input);
            self
        }
        /// <p>The flag that prevents a ledger from being deleted by any user. If not provided on
        /// ledger creation, this feature is enabled (<code>true</code>) by default.</p>
        /// <p>If deletion protection is enabled, you must first disable it before you can delete the
        /// ledger. You can disable it by calling the <code>UpdateLedger</code> operation to set the flag to <code>false</code>.</p>
        pub fn set_deletion_protection(mut self, input: std::option::Option<bool>) -> Self {
            self.deletion_protection = input;
            self
        }
        /// <p>Information about the encryption of data at rest in the ledger. This includes the
        /// current status, the KMS key, and when the key became inaccessible (in the case of an
        /// error).</p>
        pub fn encryption_description(
            mut self,
            input: crate::model::LedgerEncryptionDescription,
        ) -> Self {
            self.encryption_description = Some(input);
            self
        }
        /// <p>Information about the encryption of data at rest in the ledger. This includes the
        /// current status, the KMS key, and when the key became inaccessible (in the case of an
        /// error).</p>
        pub fn set_encryption_description(
            mut self,
            input: std::option::Option<crate::model::LedgerEncryptionDescription>,
        ) -> Self {
            self.encryption_description = input;
            self
        }
        /// Consumes the builder and constructs a [`UpdateLedgerOutput`](crate::output::UpdateLedgerOutput)
        pub fn build(self) -> crate::output::UpdateLedgerOutput {
            crate::output::UpdateLedgerOutput {
                name: self.name,
                arn: self.arn,
                state: self.state,
                creation_date_time: self.creation_date_time,
                deletion_protection: self.deletion_protection,
                encryption_description: self.encryption_description,
            }
        }
    }
}
impl UpdateLedgerOutput {
    /// Creates a new builder-style object to manufacture [`UpdateLedgerOutput`](crate::output::UpdateLedgerOutput)
    pub fn builder() -> crate::output::update_ledger_output::Builder {
        crate::output::update_ledger_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UntagResourceOutput {}
impl std::fmt::Debug for UntagResourceOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UntagResourceOutput");
        formatter.finish()
    }
}
/// See [`UntagResourceOutput`](crate::output::UntagResourceOutput)
pub mod untag_resource_output {
    /// A builder for [`UntagResourceOutput`](crate::output::UntagResourceOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {}
    impl Builder {
        /// Consumes the builder and constructs a [`UntagResourceOutput`](crate::output::UntagResourceOutput)
        pub fn build(self) -> crate::output::UntagResourceOutput {
            crate::output::UntagResourceOutput {}
        }
    }
}
impl UntagResourceOutput {
    /// Creates a new builder-style object to manufacture [`UntagResourceOutput`](crate::output::UntagResourceOutput)
    pub fn builder() -> crate::output::untag_resource_output::Builder {
        crate::output::untag_resource_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TagResourceOutput {}
impl std::fmt::Debug for TagResourceOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TagResourceOutput");
        formatter.finish()
    }
}
/// See [`TagResourceOutput`](crate::output::TagResourceOutput)
pub mod tag_resource_output {
    /// A builder for [`TagResourceOutput`](crate::output::TagResourceOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {}
    impl Builder {
        /// Consumes the builder and constructs a [`TagResourceOutput`](crate::output::TagResourceOutput)
        pub fn build(self) -> crate::output::TagResourceOutput {
            crate::output::TagResourceOutput {}
        }
    }
}
impl TagResourceOutput {
    /// Creates a new builder-style object to manufacture [`TagResourceOutput`](crate::output::TagResourceOutput)
    pub fn builder() -> crate::output::tag_resource_output::Builder {
        crate::output::tag_resource_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct StreamJournalToKinesisOutput {
    /// <p>The UUID (represented in Base62-encoded text) that QLDB assigns to each QLDB journal
    /// stream.</p>
    pub stream_id: std::option::Option<std::string::String>,
}
impl StreamJournalToKinesisOutput {
    /// <p>The UUID (represented in Base62-encoded text) that QLDB assigns to each QLDB journal
    /// stream.</p>
    pub fn stream_id(&self) -> std::option::Option<&str> {
        self.stream_id.as_deref()
    }
}
impl std::fmt::Debug for StreamJournalToKinesisOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("StreamJournalToKinesisOutput");
        formatter.field("stream_id", &self.stream_id);
        formatter.finish()
    }
}
/// See [`StreamJournalToKinesisOutput`](crate::output::StreamJournalToKinesisOutput)
pub mod stream_journal_to_kinesis_output {
    /// A builder for [`StreamJournalToKinesisOutput`](crate::output::StreamJournalToKinesisOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) stream_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The UUID (represented in Base62-encoded text) that QLDB assigns to each QLDB journal
        /// stream.</p>
        pub fn stream_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.stream_id = Some(input.into());
            self
        }
        /// <p>The UUID (represented in Base62-encoded text) that QLDB assigns to each QLDB journal
        /// stream.</p>
        pub fn set_stream_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.stream_id = input;
            self
        }
        /// Consumes the builder and constructs a [`StreamJournalToKinesisOutput`](crate::output::StreamJournalToKinesisOutput)
        pub fn build(self) -> crate::output::StreamJournalToKinesisOutput {
            crate::output::StreamJournalToKinesisOutput {
                stream_id: self.stream_id,
            }
        }
    }
}
impl StreamJournalToKinesisOutput {
    /// Creates a new builder-style object to manufacture [`StreamJournalToKinesisOutput`](crate::output::StreamJournalToKinesisOutput)
    pub fn builder() -> crate::output::stream_journal_to_kinesis_output::Builder {
        crate::output::stream_journal_to_kinesis_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListTagsForResourceOutput {
    /// <p>The tags that are currently associated with the specified Amazon QLDB resource.</p>
    pub tags: std::option::Option<
        std::collections::HashMap<std::string::String, std::option::Option<std::string::String>>,
    >,
}
impl ListTagsForResourceOutput {
    /// <p>The tags that are currently associated with the specified Amazon QLDB resource.</p>
    pub fn tags(
        &self,
    ) -> std::option::Option<
        &std::collections::HashMap<std::string::String, std::option::Option<std::string::String>>,
    > {
        self.tags.as_ref()
    }
}
impl std::fmt::Debug for ListTagsForResourceOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListTagsForResourceOutput");
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}
/// See [`ListTagsForResourceOutput`](crate::output::ListTagsForResourceOutput)
pub mod list_tags_for_resource_output {
    /// A builder for [`ListTagsForResourceOutput`](crate::output::ListTagsForResourceOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) tags: std::option::Option<
            std::collections::HashMap<
                std::string::String,
                std::option::Option<std::string::String>,
            >,
        >,
    }
    impl Builder {
        /// Adds a key-value pair to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>The tags that are currently associated with the specified Amazon QLDB resource.</p>
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::option::Option<std::string::String>>,
        ) -> Self {
            let mut hash_map = self.tags.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.tags = Some(hash_map);
            self
        }
        /// <p>The tags that are currently associated with the specified Amazon QLDB resource.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<
                    std::string::String,
                    std::option::Option<std::string::String>,
                >,
            >,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`ListTagsForResourceOutput`](crate::output::ListTagsForResourceOutput)
        pub fn build(self) -> crate::output::ListTagsForResourceOutput {
            crate::output::ListTagsForResourceOutput { tags: self.tags }
        }
    }
}
impl ListTagsForResourceOutput {
    /// Creates a new builder-style object to manufacture [`ListTagsForResourceOutput`](crate::output::ListTagsForResourceOutput)
    pub fn builder() -> crate::output::list_tags_for_resource_output::Builder {
        crate::output::list_tags_for_resource_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListLedgersOutput {
    /// <p>The array of ledger summaries that are associated with the current account and
    /// Region.</p>
    pub ledgers: std::option::Option<std::vec::Vec<crate::model::LedgerSummary>>,
    /// <p>A pagination token, indicating whether there are more results available:</p>
    /// <ul>
    /// <li>
    /// <p>If <code>NextToken</code> is empty, then the last page of results has been
    /// processed and there are no more results to be retrieved.</p>
    /// </li>
    /// <li>
    /// <p>If <code>NextToken</code> is <i>not</i> empty, then there are more
    /// results available. To retrieve the next page of results, use the value of
    /// <code>NextToken</code> in a subsequent <code>ListLedgers</code> call.</p>
    /// </li>
    /// </ul>
    pub next_token: std::option::Option<std::string::String>,
}
impl ListLedgersOutput {
    /// <p>The array of ledger summaries that are associated with the current account and
    /// Region.</p>
    pub fn ledgers(&self) -> std::option::Option<&[crate::model::LedgerSummary]> {
        self.ledgers.as_deref()
    }
    /// <p>A pagination token, indicating whether there are more results available:</p>
    /// <ul>
    /// <li>
    /// <p>If <code>NextToken</code> is empty, then the last page of results has been
    /// processed and there are no more results to be retrieved.</p>
    /// </li>
    /// <li>
    /// <p>If <code>NextToken</code> is <i>not</i> empty, then there are more
    /// results available. To retrieve the next page of results, use the value of
    /// <code>NextToken</code> in a subsequent <code>ListLedgers</code> call.</p>
    /// </li>
    /// </ul>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
}
impl std::fmt::Debug for ListLedgersOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListLedgersOutput");
        formatter.field("ledgers", &self.ledgers);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}
/// See [`ListLedgersOutput`](crate::output::ListLedgersOutput)
pub mod list_ledgers_output {
    /// A builder for [`ListLedgersOutput`](crate::output::ListLedgersOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) ledgers: std::option::Option<std::vec::Vec<crate::model::LedgerSummary>>,
        pub(crate) next_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// Appends an item to `ledgers`.
        ///
        /// To override the contents of this collection use [`set_ledgers`](Self::set_ledgers).
        ///
        /// <p>The array of ledger summaries that are associated with the current account and
        /// Region.</p>
        pub fn ledgers(mut self, input: impl Into<crate::model::LedgerSummary>) -> Self {
            let mut v = self.ledgers.unwrap_or_default();
            v.push(input.into());
            self.ledgers = Some(v);
            self
        }
        /// <p>The array of ledger summaries that are associated with the current account and
        /// Region.</p>
        pub fn set_ledgers(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::LedgerSummary>>,
        ) -> Self {
            self.ledgers = input;
            self
        }
        /// <p>A pagination token, indicating whether there are more results available:</p>
        /// <ul>
        /// <li>
        /// <p>If <code>NextToken</code> is empty, then the last page of results has been
        /// processed and there are no more results to be retrieved.</p>
        /// </li>
        /// <li>
        /// <p>If <code>NextToken</code> is <i>not</i> empty, then there are more
        /// results available. To retrieve the next page of results, use the value of
        /// <code>NextToken</code> in a subsequent <code>ListLedgers</code> call.</p>
        /// </li>
        /// </ul>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>A pagination token, indicating whether there are more results available:</p>
        /// <ul>
        /// <li>
        /// <p>If <code>NextToken</code> is empty, then the last page of results has been
        /// processed and there are no more results to be retrieved.</p>
        /// </li>
        /// <li>
        /// <p>If <code>NextToken</code> is <i>not</i> empty, then there are more
        /// results available. To retrieve the next page of results, use the value of
        /// <code>NextToken</code> in a subsequent <code>ListLedgers</code> call.</p>
        /// </li>
        /// </ul>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// Consumes the builder and constructs a [`ListLedgersOutput`](crate::output::ListLedgersOutput)
        pub fn build(self) -> crate::output::ListLedgersOutput {
            crate::output::ListLedgersOutput {
                ledgers: self.ledgers,
                next_token: self.next_token,
            }
        }
    }
}
impl ListLedgersOutput {
    /// Creates a new builder-style object to manufacture [`ListLedgersOutput`](crate::output::ListLedgersOutput)
    pub fn builder() -> crate::output::list_ledgers_output::Builder {
        crate::output::list_ledgers_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListJournalS3ExportsForLedgerOutput {
    /// <p>The array of journal export job descriptions that are associated with the specified
    /// ledger.</p>
    pub journal_s3_exports:
        std::option::Option<std::vec::Vec<crate::model::JournalS3ExportDescription>>,
    /// <ul>
    /// <li>
    /// <p>If <code>NextToken</code> is empty, then the last page of results has been
    /// processed and there are no more results to be retrieved.</p>
    /// </li>
    /// <li>
    /// <p>If <code>NextToken</code> is <i>not</i> empty, then there are more
    /// results available. To retrieve the next page of results, use the value of
    /// <code>NextToken</code> in a subsequent <code>ListJournalS3ExportsForLedger</code>
    /// call.</p>
    /// </li>
    /// </ul>
    pub next_token: std::option::Option<std::string::String>,
}
impl ListJournalS3ExportsForLedgerOutput {
    /// <p>The array of journal export job descriptions that are associated with the specified
    /// ledger.</p>
    pub fn journal_s3_exports(
        &self,
    ) -> std::option::Option<&[crate::model::JournalS3ExportDescription]> {
        self.journal_s3_exports.as_deref()
    }
    /// <ul>
    /// <li>
    /// <p>If <code>NextToken</code> is empty, then the last page of results has been
    /// processed and there are no more results to be retrieved.</p>
    /// </li>
    /// <li>
    /// <p>If <code>NextToken</code> is <i>not</i> empty, then there are more
    /// results available. To retrieve the next page of results, use the value of
    /// <code>NextToken</code> in a subsequent <code>ListJournalS3ExportsForLedger</code>
    /// call.</p>
    /// </li>
    /// </ul>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
}
impl std::fmt::Debug for ListJournalS3ExportsForLedgerOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListJournalS3ExportsForLedgerOutput");
        formatter.field("journal_s3_exports", &self.journal_s3_exports);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}
/// See [`ListJournalS3ExportsForLedgerOutput`](crate::output::ListJournalS3ExportsForLedgerOutput)
pub mod list_journal_s3_exports_for_ledger_output {
    /// A builder for [`ListJournalS3ExportsForLedgerOutput`](crate::output::ListJournalS3ExportsForLedgerOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) journal_s3_exports:
            std::option::Option<std::vec::Vec<crate::model::JournalS3ExportDescription>>,
        pub(crate) next_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// Appends an item to `journal_s3_exports`.
        ///
        /// To override the contents of this collection use [`set_journal_s3_exports`](Self::set_journal_s3_exports).
        ///
        /// <p>The array of journal export job descriptions that are associated with the specified
        /// ledger.</p>
        pub fn journal_s3_exports(
            mut self,
            input: impl Into<crate::model::JournalS3ExportDescription>,
        ) -> Self {
            let mut v = self.journal_s3_exports.unwrap_or_default();
            v.push(input.into());
            self.journal_s3_exports = Some(v);
            self
        }
        /// <p>The array of journal export job descriptions that are associated with the specified
        /// ledger.</p>
        pub fn set_journal_s3_exports(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::JournalS3ExportDescription>>,
        ) -> Self {
            self.journal_s3_exports = input;
            self
        }
        /// <ul>
        /// <li>
        /// <p>If <code>NextToken</code> is empty, then the last page of results has been
        /// processed and there are no more results to be retrieved.</p>
        /// </li>
        /// <li>
        /// <p>If <code>NextToken</code> is <i>not</i> empty, then there are more
        /// results available. To retrieve the next page of results, use the value of
        /// <code>NextToken</code> in a subsequent <code>ListJournalS3ExportsForLedger</code>
        /// call.</p>
        /// </li>
        /// </ul>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <ul>
        /// <li>
        /// <p>If <code>NextToken</code> is empty, then the last page of results has been
        /// processed and there are no more results to be retrieved.</p>
        /// </li>
        /// <li>
        /// <p>If <code>NextToken</code> is <i>not</i> empty, then there are more
        /// results available. To retrieve the next page of results, use the value of
        /// <code>NextToken</code> in a subsequent <code>ListJournalS3ExportsForLedger</code>
        /// call.</p>
        /// </li>
        /// </ul>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// Consumes the builder and constructs a [`ListJournalS3ExportsForLedgerOutput`](crate::output::ListJournalS3ExportsForLedgerOutput)
        pub fn build(self) -> crate::output::ListJournalS3ExportsForLedgerOutput {
            crate::output::ListJournalS3ExportsForLedgerOutput {
                journal_s3_exports: self.journal_s3_exports,
                next_token: self.next_token,
            }
        }
    }
}
impl ListJournalS3ExportsForLedgerOutput {
    /// Creates a new builder-style object to manufacture [`ListJournalS3ExportsForLedgerOutput`](crate::output::ListJournalS3ExportsForLedgerOutput)
    pub fn builder() -> crate::output::list_journal_s3_exports_for_ledger_output::Builder {
        crate::output::list_journal_s3_exports_for_ledger_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListJournalS3ExportsOutput {
    /// <p>The array of journal export job descriptions for all ledgers that are associated with
    /// the current account and Region.</p>
    pub journal_s3_exports:
        std::option::Option<std::vec::Vec<crate::model::JournalS3ExportDescription>>,
    /// <ul>
    /// <li>
    /// <p>If <code>NextToken</code> is empty, then the last page of results has been
    /// processed and there are no more results to be retrieved.</p>
    /// </li>
    /// <li>
    /// <p>If <code>NextToken</code> is <i>not</i> empty, then there are more
    /// results available. To retrieve the next page of results, use the value of
    /// <code>NextToken</code> in a subsequent <code>ListJournalS3Exports</code>
    /// call.</p>
    /// </li>
    /// </ul>
    pub next_token: std::option::Option<std::string::String>,
}
impl ListJournalS3ExportsOutput {
    /// <p>The array of journal export job descriptions for all ledgers that are associated with
    /// the current account and Region.</p>
    pub fn journal_s3_exports(
        &self,
    ) -> std::option::Option<&[crate::model::JournalS3ExportDescription]> {
        self.journal_s3_exports.as_deref()
    }
    /// <ul>
    /// <li>
    /// <p>If <code>NextToken</code> is empty, then the last page of results has been
    /// processed and there are no more results to be retrieved.</p>
    /// </li>
    /// <li>
    /// <p>If <code>NextToken</code> is <i>not</i> empty, then there are more
    /// results available. To retrieve the next page of results, use the value of
    /// <code>NextToken</code> in a subsequent <code>ListJournalS3Exports</code>
    /// call.</p>
    /// </li>
    /// </ul>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
}
impl std::fmt::Debug for ListJournalS3ExportsOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListJournalS3ExportsOutput");
        formatter.field("journal_s3_exports", &self.journal_s3_exports);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}
/// See [`ListJournalS3ExportsOutput`](crate::output::ListJournalS3ExportsOutput)
pub mod list_journal_s3_exports_output {
    /// A builder for [`ListJournalS3ExportsOutput`](crate::output::ListJournalS3ExportsOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) journal_s3_exports:
            std::option::Option<std::vec::Vec<crate::model::JournalS3ExportDescription>>,
        pub(crate) next_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// Appends an item to `journal_s3_exports`.
        ///
        /// To override the contents of this collection use [`set_journal_s3_exports`](Self::set_journal_s3_exports).
        ///
        /// <p>The array of journal export job descriptions for all ledgers that are associated with
        /// the current account and Region.</p>
        pub fn journal_s3_exports(
            mut self,
            input: impl Into<crate::model::JournalS3ExportDescription>,
        ) -> Self {
            let mut v = self.journal_s3_exports.unwrap_or_default();
            v.push(input.into());
            self.journal_s3_exports = Some(v);
            self
        }
        /// <p>The array of journal export job descriptions for all ledgers that are associated with
        /// the current account and Region.</p>
        pub fn set_journal_s3_exports(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::JournalS3ExportDescription>>,
        ) -> Self {
            self.journal_s3_exports = input;
            self
        }
        /// <ul>
        /// <li>
        /// <p>If <code>NextToken</code> is empty, then the last page of results has been
        /// processed and there are no more results to be retrieved.</p>
        /// </li>
        /// <li>
        /// <p>If <code>NextToken</code> is <i>not</i> empty, then there are more
        /// results available. To retrieve the next page of results, use the value of
        /// <code>NextToken</code> in a subsequent <code>ListJournalS3Exports</code>
        /// call.</p>
        /// </li>
        /// </ul>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <ul>
        /// <li>
        /// <p>If <code>NextToken</code> is empty, then the last page of results has been
        /// processed and there are no more results to be retrieved.</p>
        /// </li>
        /// <li>
        /// <p>If <code>NextToken</code> is <i>not</i> empty, then there are more
        /// results available. To retrieve the next page of results, use the value of
        /// <code>NextToken</code> in a subsequent <code>ListJournalS3Exports</code>
        /// call.</p>
        /// </li>
        /// </ul>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// Consumes the builder and constructs a [`ListJournalS3ExportsOutput`](crate::output::ListJournalS3ExportsOutput)
        pub fn build(self) -> crate::output::ListJournalS3ExportsOutput {
            crate::output::ListJournalS3ExportsOutput {
                journal_s3_exports: self.journal_s3_exports,
                next_token: self.next_token,
            }
        }
    }
}
impl ListJournalS3ExportsOutput {
    /// Creates a new builder-style object to manufacture [`ListJournalS3ExportsOutput`](crate::output::ListJournalS3ExportsOutput)
    pub fn builder() -> crate::output::list_journal_s3_exports_output::Builder {
        crate::output::list_journal_s3_exports_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListJournalKinesisStreamsForLedgerOutput {
    /// <p>The array of QLDB journal stream descriptors that are associated with the given
    /// ledger.</p>
    pub streams: std::option::Option<std::vec::Vec<crate::model::JournalKinesisStreamDescription>>,
    /// <ul>
    /// <li>
    /// <p>If <code>NextToken</code> is empty, the last page of results has been processed
    /// and there are no more results to be retrieved.</p>
    /// </li>
    /// <li>
    /// <p>If <code>NextToken</code> is <i>not</i> empty, more results are
    /// available. To retrieve the next page of results, use the value of
    /// <code>NextToken</code> in a subsequent
    /// <code>ListJournalKinesisStreamsForLedger</code> call.</p>
    /// </li>
    /// </ul>
    pub next_token: std::option::Option<std::string::String>,
}
impl ListJournalKinesisStreamsForLedgerOutput {
    /// <p>The array of QLDB journal stream descriptors that are associated with the given
    /// ledger.</p>
    pub fn streams(&self) -> std::option::Option<&[crate::model::JournalKinesisStreamDescription]> {
        self.streams.as_deref()
    }
    /// <ul>
    /// <li>
    /// <p>If <code>NextToken</code> is empty, the last page of results has been processed
    /// and there are no more results to be retrieved.</p>
    /// </li>
    /// <li>
    /// <p>If <code>NextToken</code> is <i>not</i> empty, more results are
    /// available. To retrieve the next page of results, use the value of
    /// <code>NextToken</code> in a subsequent
    /// <code>ListJournalKinesisStreamsForLedger</code> call.</p>
    /// </li>
    /// </ul>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
}
impl std::fmt::Debug for ListJournalKinesisStreamsForLedgerOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListJournalKinesisStreamsForLedgerOutput");
        formatter.field("streams", &self.streams);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}
/// See [`ListJournalKinesisStreamsForLedgerOutput`](crate::output::ListJournalKinesisStreamsForLedgerOutput)
pub mod list_journal_kinesis_streams_for_ledger_output {
    /// A builder for [`ListJournalKinesisStreamsForLedgerOutput`](crate::output::ListJournalKinesisStreamsForLedgerOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) streams:
            std::option::Option<std::vec::Vec<crate::model::JournalKinesisStreamDescription>>,
        pub(crate) next_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// Appends an item to `streams`.
        ///
        /// To override the contents of this collection use [`set_streams`](Self::set_streams).
        ///
        /// <p>The array of QLDB journal stream descriptors that are associated with the given
        /// ledger.</p>
        pub fn streams(
            mut self,
            input: impl Into<crate::model::JournalKinesisStreamDescription>,
        ) -> Self {
            let mut v = self.streams.unwrap_or_default();
            v.push(input.into());
            self.streams = Some(v);
            self
        }
        /// <p>The array of QLDB journal stream descriptors that are associated with the given
        /// ledger.</p>
        pub fn set_streams(
            mut self,
            input: std::option::Option<
                std::vec::Vec<crate::model::JournalKinesisStreamDescription>,
            >,
        ) -> Self {
            self.streams = input;
            self
        }
        /// <ul>
        /// <li>
        /// <p>If <code>NextToken</code> is empty, the last page of results has been processed
        /// and there are no more results to be retrieved.</p>
        /// </li>
        /// <li>
        /// <p>If <code>NextToken</code> is <i>not</i> empty, more results are
        /// available. To retrieve the next page of results, use the value of
        /// <code>NextToken</code> in a subsequent
        /// <code>ListJournalKinesisStreamsForLedger</code> call.</p>
        /// </li>
        /// </ul>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <ul>
        /// <li>
        /// <p>If <code>NextToken</code> is empty, the last page of results has been processed
        /// and there are no more results to be retrieved.</p>
        /// </li>
        /// <li>
        /// <p>If <code>NextToken</code> is <i>not</i> empty, more results are
        /// available. To retrieve the next page of results, use the value of
        /// <code>NextToken</code> in a subsequent
        /// <code>ListJournalKinesisStreamsForLedger</code> call.</p>
        /// </li>
        /// </ul>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// Consumes the builder and constructs a [`ListJournalKinesisStreamsForLedgerOutput`](crate::output::ListJournalKinesisStreamsForLedgerOutput)
        pub fn build(self) -> crate::output::ListJournalKinesisStreamsForLedgerOutput {
            crate::output::ListJournalKinesisStreamsForLedgerOutput {
                streams: self.streams,
                next_token: self.next_token,
            }
        }
    }
}
impl ListJournalKinesisStreamsForLedgerOutput {
    /// Creates a new builder-style object to manufacture [`ListJournalKinesisStreamsForLedgerOutput`](crate::output::ListJournalKinesisStreamsForLedgerOutput)
    pub fn builder() -> crate::output::list_journal_kinesis_streams_for_ledger_output::Builder {
        crate::output::list_journal_kinesis_streams_for_ledger_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetRevisionOutput {
    /// <p>The proof object in Amazon Ion format returned by a <code>GetRevision</code> request. A
    /// proof contains the list of hash values that are required to recalculate the specified
    /// digest using a Merkle tree, starting with the specified document revision.</p>
    pub proof: std::option::Option<crate::model::ValueHolder>,
    /// <p>The document revision data object in Amazon Ion format.</p>
    pub revision: std::option::Option<crate::model::ValueHolder>,
}
impl GetRevisionOutput {
    /// <p>The proof object in Amazon Ion format returned by a <code>GetRevision</code> request. A
    /// proof contains the list of hash values that are required to recalculate the specified
    /// digest using a Merkle tree, starting with the specified document revision.</p>
    pub fn proof(&self) -> std::option::Option<&crate::model::ValueHolder> {
        self.proof.as_ref()
    }
    /// <p>The document revision data object in Amazon Ion format.</p>
    pub fn revision(&self) -> std::option::Option<&crate::model::ValueHolder> {
        self.revision.as_ref()
    }
}
impl std::fmt::Debug for GetRevisionOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetRevisionOutput");
        formatter.field("proof", &"*** Sensitive Data Redacted ***");
        formatter.field("revision", &"*** Sensitive Data Redacted ***");
        formatter.finish()
    }
}
/// See [`GetRevisionOutput`](crate::output::GetRevisionOutput)
pub mod get_revision_output {
    /// A builder for [`GetRevisionOutput`](crate::output::GetRevisionOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) proof: std::option::Option<crate::model::ValueHolder>,
        pub(crate) revision: std::option::Option<crate::model::ValueHolder>,
    }
    impl Builder {
        /// <p>The proof object in Amazon Ion format returned by a <code>GetRevision</code> request. A
        /// proof contains the list of hash values that are required to recalculate the specified
        /// digest using a Merkle tree, starting with the specified document revision.</p>
        pub fn proof(mut self, input: crate::model::ValueHolder) -> Self {
            self.proof = Some(input);
            self
        }
        /// <p>The proof object in Amazon Ion format returned by a <code>GetRevision</code> request. A
        /// proof contains the list of hash values that are required to recalculate the specified
        /// digest using a Merkle tree, starting with the specified document revision.</p>
        pub fn set_proof(mut self, input: std::option::Option<crate::model::ValueHolder>) -> Self {
            self.proof = input;
            self
        }
        /// <p>The document revision data object in Amazon Ion format.</p>
        pub fn revision(mut self, input: crate::model::ValueHolder) -> Self {
            self.revision = Some(input);
            self
        }
        /// <p>The document revision data object in Amazon Ion format.</p>
        pub fn set_revision(
            mut self,
            input: std::option::Option<crate::model::ValueHolder>,
        ) -> Self {
            self.revision = input;
            self
        }
        /// Consumes the builder and constructs a [`GetRevisionOutput`](crate::output::GetRevisionOutput)
        pub fn build(self) -> crate::output::GetRevisionOutput {
            crate::output::GetRevisionOutput {
                proof: self.proof,
                revision: self.revision,
            }
        }
    }
}
impl GetRevisionOutput {
    /// Creates a new builder-style object to manufacture [`GetRevisionOutput`](crate::output::GetRevisionOutput)
    pub fn builder() -> crate::output::get_revision_output::Builder {
        crate::output::get_revision_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetDigestOutput {
    /// <p>The 256-bit hash value representing the digest returned by a <code>GetDigest</code>
    /// request.</p>
    pub digest: std::option::Option<aws_smithy_types::Blob>,
    /// <p>The latest block location covered by the digest that you requested. An address is an
    /// Amazon Ion structure that has two fields: <code>strandId</code> and
    /// <code>sequenceNo</code>.</p>
    pub digest_tip_address: std::option::Option<crate::model::ValueHolder>,
}
impl GetDigestOutput {
    /// <p>The 256-bit hash value representing the digest returned by a <code>GetDigest</code>
    /// request.</p>
    pub fn digest(&self) -> std::option::Option<&aws_smithy_types::Blob> {
        self.digest.as_ref()
    }
    /// <p>The latest block location covered by the digest that you requested. An address is an
    /// Amazon Ion structure that has two fields: <code>strandId</code> and
    /// <code>sequenceNo</code>.</p>
    pub fn digest_tip_address(&self) -> std::option::Option<&crate::model::ValueHolder> {
        self.digest_tip_address.as_ref()
    }
}
impl std::fmt::Debug for GetDigestOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetDigestOutput");
        formatter.field("digest", &self.digest);
        formatter.field("digest_tip_address", &"*** Sensitive Data Redacted ***");
        formatter.finish()
    }
}
/// See [`GetDigestOutput`](crate::output::GetDigestOutput)
pub mod get_digest_output {
    /// A builder for [`GetDigestOutput`](crate::output::GetDigestOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) digest: std::option::Option<aws_smithy_types::Blob>,
        pub(crate) digest_tip_address: std::option::Option<crate::model::ValueHolder>,
    }
    impl Builder {
        /// <p>The 256-bit hash value representing the digest returned by a <code>GetDigest</code>
        /// request.</p>
        pub fn digest(mut self, input: aws_smithy_types::Blob) -> Self {
            self.digest = Some(input);
            self
        }
        /// <p>The 256-bit hash value representing the digest returned by a <code>GetDigest</code>
        /// request.</p>
        pub fn set_digest(mut self, input: std::option::Option<aws_smithy_types::Blob>) -> Self {
            self.digest = input;
            self
        }
        /// <p>The latest block location covered by the digest that you requested. An address is an
        /// Amazon Ion structure that has two fields: <code>strandId</code> and
        /// <code>sequenceNo</code>.</p>
        pub fn digest_tip_address(mut self, input: crate::model::ValueHolder) -> Self {
            self.digest_tip_address = Some(input);
            self
        }
        /// <p>The latest block location covered by the digest that you requested. An address is an
        /// Amazon Ion structure that has two fields: <code>strandId</code> and
        /// <code>sequenceNo</code>.</p>
        pub fn set_digest_tip_address(
            mut self,
            input: std::option::Option<crate::model::ValueHolder>,
        ) -> Self {
            self.digest_tip_address = input;
            self
        }
        /// Consumes the builder and constructs a [`GetDigestOutput`](crate::output::GetDigestOutput)
        pub fn build(self) -> crate::output::GetDigestOutput {
            crate::output::GetDigestOutput {
                digest: self.digest,
                digest_tip_address: self.digest_tip_address,
            }
        }
    }
}
impl GetDigestOutput {
    /// Creates a new builder-style object to manufacture [`GetDigestOutput`](crate::output::GetDigestOutput)
    pub fn builder() -> crate::output::get_digest_output::Builder {
        crate::output::get_digest_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetBlockOutput {
    /// <p>The block data object in Amazon Ion format.</p>
    pub block: std::option::Option<crate::model::ValueHolder>,
    /// <p>The proof object in Amazon Ion format returned by a <code>GetBlock</code> request. A
    /// proof contains the list of hash values required to recalculate the specified digest using a
    /// Merkle tree, starting with the specified block.</p>
    pub proof: std::option::Option<crate::model::ValueHolder>,
}
impl GetBlockOutput {
    /// <p>The block data object in Amazon Ion format.</p>
    pub fn block(&self) -> std::option::Option<&crate::model::ValueHolder> {
        self.block.as_ref()
    }
    /// <p>The proof object in Amazon Ion format returned by a <code>GetBlock</code> request. A
    /// proof contains the list of hash values required to recalculate the specified digest using a
    /// Merkle tree, starting with the specified block.</p>
    pub fn proof(&self) -> std::option::Option<&crate::model::ValueHolder> {
        self.proof.as_ref()
    }
}
impl std::fmt::Debug for GetBlockOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetBlockOutput");
        formatter.field("block", &"*** Sensitive Data Redacted ***");
        formatter.field("proof", &"*** Sensitive Data Redacted ***");
        formatter.finish()
    }
}
/// See [`GetBlockOutput`](crate::output::GetBlockOutput)
pub mod get_block_output {
    /// A builder for [`GetBlockOutput`](crate::output::GetBlockOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) block: std::option::Option<crate::model::ValueHolder>,
        pub(crate) proof: std::option::Option<crate::model::ValueHolder>,
    }
    impl Builder {
        /// <p>The block data object in Amazon Ion format.</p>
        pub fn block(mut self, input: crate::model::ValueHolder) -> Self {
            self.block = Some(input);
            self
        }
        /// <p>The block data object in Amazon Ion format.</p>
        pub fn set_block(mut self, input: std::option::Option<crate::model::ValueHolder>) -> Self {
            self.block = input;
            self
        }
        /// <p>The proof object in Amazon Ion format returned by a <code>GetBlock</code> request. A
        /// proof contains the list of hash values required to recalculate the specified digest using a
        /// Merkle tree, starting with the specified block.</p>
        pub fn proof(mut self, input: crate::model::ValueHolder) -> Self {
            self.proof = Some(input);
            self
        }
        /// <p>The proof object in Amazon Ion format returned by a <code>GetBlock</code> request. A
        /// proof contains the list of hash values required to recalculate the specified digest using a
        /// Merkle tree, starting with the specified block.</p>
        pub fn set_proof(mut self, input: std::option::Option<crate::model::ValueHolder>) -> Self {
            self.proof = input;
            self
        }
        /// Consumes the builder and constructs a [`GetBlockOutput`](crate::output::GetBlockOutput)
        pub fn build(self) -> crate::output::GetBlockOutput {
            crate::output::GetBlockOutput {
                block: self.block,
                proof: self.proof,
            }
        }
    }
}
impl GetBlockOutput {
    /// Creates a new builder-style object to manufacture [`GetBlockOutput`](crate::output::GetBlockOutput)
    pub fn builder() -> crate::output::get_block_output::Builder {
        crate::output::get_block_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ExportJournalToS3Output {
    /// <p>The UUID (represented in Base62-encoded text) that QLDB assigns to each journal export
    /// job.</p>
    /// <p>To describe your export request and check the status of the job, you can use
    /// <code>ExportId</code> to call <code>DescribeJournalS3Export</code>.</p>
    pub export_id: std::option::Option<std::string::String>,
}
impl ExportJournalToS3Output {
    /// <p>The UUID (represented in Base62-encoded text) that QLDB assigns to each journal export
    /// job.</p>
    /// <p>To describe your export request and check the status of the job, you can use
    /// <code>ExportId</code> to call <code>DescribeJournalS3Export</code>.</p>
    pub fn export_id(&self) -> std::option::Option<&str> {
        self.export_id.as_deref()
    }
}
impl std::fmt::Debug for ExportJournalToS3Output {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ExportJournalToS3Output");
        formatter.field("export_id", &self.export_id);
        formatter.finish()
    }
}
/// See [`ExportJournalToS3Output`](crate::output::ExportJournalToS3Output)
pub mod export_journal_to_s3_output {
    /// A builder for [`ExportJournalToS3Output`](crate::output::ExportJournalToS3Output)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) export_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The UUID (represented in Base62-encoded text) that QLDB assigns to each journal export
        /// job.</p>
        /// <p>To describe your export request and check the status of the job, you can use
        /// <code>ExportId</code> to call <code>DescribeJournalS3Export</code>.</p>
        pub fn export_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.export_id = Some(input.into());
            self
        }
        /// <p>The UUID (represented in Base62-encoded text) that QLDB assigns to each journal export
        /// job.</p>
        /// <p>To describe your export request and check the status of the job, you can use
        /// <code>ExportId</code> to call <code>DescribeJournalS3Export</code>.</p>
        pub fn set_export_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.export_id = input;
            self
        }
        /// Consumes the builder and constructs a [`ExportJournalToS3Output`](crate::output::ExportJournalToS3Output)
        pub fn build(self) -> crate::output::ExportJournalToS3Output {
            crate::output::ExportJournalToS3Output {
                export_id: self.export_id,
            }
        }
    }
}
impl ExportJournalToS3Output {
    /// Creates a new builder-style object to manufacture [`ExportJournalToS3Output`](crate::output::ExportJournalToS3Output)
    pub fn builder() -> crate::output::export_journal_to_s3_output::Builder {
        crate::output::export_journal_to_s3_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeLedgerOutput {
    /// <p>The name of the ledger.</p>
    pub name: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) for the ledger.</p>
    pub arn: std::option::Option<std::string::String>,
    /// <p>The current status of the ledger.</p>
    pub state: std::option::Option<crate::model::LedgerState>,
    /// <p>The date and time, in epoch time format, when the ledger was created. (Epoch time format
    /// is the number of seconds elapsed since 12:00:00 AM January 1, 1970 UTC.)</p>
    pub creation_date_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The permissions mode of the ledger.</p>
    pub permissions_mode: std::option::Option<crate::model::PermissionsMode>,
    /// <p>The flag that prevents a ledger from being deleted by any user. If not provided on
    /// ledger creation, this feature is enabled (<code>true</code>) by default.</p>
    /// <p>If deletion protection is enabled, you must first disable it before you can delete the
    /// ledger. You can disable it by calling the <code>UpdateLedger</code> operation to set the flag to <code>false</code>.</p>
    pub deletion_protection: std::option::Option<bool>,
    /// <p>Information about the encryption of data at rest in the ledger. This includes the
    /// current status, the KMS key, and when the key became inaccessible (in the case of an
    /// error).</p>
    pub encryption_description: std::option::Option<crate::model::LedgerEncryptionDescription>,
}
impl DescribeLedgerOutput {
    /// <p>The name of the ledger.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) for the ledger.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>The current status of the ledger.</p>
    pub fn state(&self) -> std::option::Option<&crate::model::LedgerState> {
        self.state.as_ref()
    }
    /// <p>The date and time, in epoch time format, when the ledger was created. (Epoch time format
    /// is the number of seconds elapsed since 12:00:00 AM January 1, 1970 UTC.)</p>
    pub fn creation_date_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.creation_date_time.as_ref()
    }
    /// <p>The permissions mode of the ledger.</p>
    pub fn permissions_mode(&self) -> std::option::Option<&crate::model::PermissionsMode> {
        self.permissions_mode.as_ref()
    }
    /// <p>The flag that prevents a ledger from being deleted by any user. If not provided on
    /// ledger creation, this feature is enabled (<code>true</code>) by default.</p>
    /// <p>If deletion protection is enabled, you must first disable it before you can delete the
    /// ledger. You can disable it by calling the <code>UpdateLedger</code> operation to set the flag to <code>false</code>.</p>
    pub fn deletion_protection(&self) -> std::option::Option<bool> {
        self.deletion_protection
    }
    /// <p>Information about the encryption of data at rest in the ledger. This includes the
    /// current status, the KMS key, and when the key became inaccessible (in the case of an
    /// error).</p>
    pub fn encryption_description(
        &self,
    ) -> std::option::Option<&crate::model::LedgerEncryptionDescription> {
        self.encryption_description.as_ref()
    }
}
impl std::fmt::Debug for DescribeLedgerOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeLedgerOutput");
        formatter.field("name", &self.name);
        formatter.field("arn", &self.arn);
        formatter.field("state", &self.state);
        formatter.field("creation_date_time", &self.creation_date_time);
        formatter.field("permissions_mode", &self.permissions_mode);
        formatter.field("deletion_protection", &self.deletion_protection);
        formatter.field("encryption_description", &self.encryption_description);
        formatter.finish()
    }
}
/// See [`DescribeLedgerOutput`](crate::output::DescribeLedgerOutput)
pub mod describe_ledger_output {
    /// A builder for [`DescribeLedgerOutput`](crate::output::DescribeLedgerOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) state: std::option::Option<crate::model::LedgerState>,
        pub(crate) creation_date_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) permissions_mode: std::option::Option<crate::model::PermissionsMode>,
        pub(crate) deletion_protection: std::option::Option<bool>,
        pub(crate) encryption_description:
            std::option::Option<crate::model::LedgerEncryptionDescription>,
    }
    impl Builder {
        /// <p>The name of the ledger.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the ledger.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) for the ledger.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) for the ledger.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>The current status of the ledger.</p>
        pub fn state(mut self, input: crate::model::LedgerState) -> Self {
            self.state = Some(input);
            self
        }
        /// <p>The current status of the ledger.</p>
        pub fn set_state(mut self, input: std::option::Option<crate::model::LedgerState>) -> Self {
            self.state = input;
            self
        }
        /// <p>The date and time, in epoch time format, when the ledger was created. (Epoch time format
        /// is the number of seconds elapsed since 12:00:00 AM January 1, 1970 UTC.)</p>
        pub fn creation_date_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.creation_date_time = Some(input);
            self
        }
        /// <p>The date and time, in epoch time format, when the ledger was created. (Epoch time format
        /// is the number of seconds elapsed since 12:00:00 AM January 1, 1970 UTC.)</p>
        pub fn set_creation_date_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.creation_date_time = input;
            self
        }
        /// <p>The permissions mode of the ledger.</p>
        pub fn permissions_mode(mut self, input: crate::model::PermissionsMode) -> Self {
            self.permissions_mode = Some(input);
            self
        }
        /// <p>The permissions mode of the ledger.</p>
        pub fn set_permissions_mode(
            mut self,
            input: std::option::Option<crate::model::PermissionsMode>,
        ) -> Self {
            self.permissions_mode = input;
            self
        }
        /// <p>The flag that prevents a ledger from being deleted by any user. If not provided on
        /// ledger creation, this feature is enabled (<code>true</code>) by default.</p>
        /// <p>If deletion protection is enabled, you must first disable it before you can delete the
        /// ledger. You can disable it by calling the <code>UpdateLedger</code> operation to set the flag to <code>false</code>.</p>
        pub fn deletion_protection(mut self, input: bool) -> Self {
            self.deletion_protection = Some(input);
            self
        }
        /// <p>The flag that prevents a ledger from being deleted by any user. If not provided on
        /// ledger creation, this feature is enabled (<code>true</code>) by default.</p>
        /// <p>If deletion protection is enabled, you must first disable it before you can delete the
        /// ledger. You can disable it by calling the <code>UpdateLedger</code> operation to set the flag to <code>false</code>.</p>
        pub fn set_deletion_protection(mut self, input: std::option::Option<bool>) -> Self {
            self.deletion_protection = input;
            self
        }
        /// <p>Information about the encryption of data at rest in the ledger. This includes the
        /// current status, the KMS key, and when the key became inaccessible (in the case of an
        /// error).</p>
        pub fn encryption_description(
            mut self,
            input: crate::model::LedgerEncryptionDescription,
        ) -> Self {
            self.encryption_description = Some(input);
            self
        }
        /// <p>Information about the encryption of data at rest in the ledger. This includes the
        /// current status, the KMS key, and when the key became inaccessible (in the case of an
        /// error).</p>
        pub fn set_encryption_description(
            mut self,
            input: std::option::Option<crate::model::LedgerEncryptionDescription>,
        ) -> Self {
            self.encryption_description = input;
            self
        }
        /// Consumes the builder and constructs a [`DescribeLedgerOutput`](crate::output::DescribeLedgerOutput)
        pub fn build(self) -> crate::output::DescribeLedgerOutput {
            crate::output::DescribeLedgerOutput {
                name: self.name,
                arn: self.arn,
                state: self.state,
                creation_date_time: self.creation_date_time,
                permissions_mode: self.permissions_mode,
                deletion_protection: self.deletion_protection,
                encryption_description: self.encryption_description,
            }
        }
    }
}
impl DescribeLedgerOutput {
    /// Creates a new builder-style object to manufacture [`DescribeLedgerOutput`](crate::output::DescribeLedgerOutput)
    pub fn builder() -> crate::output::describe_ledger_output::Builder {
        crate::output::describe_ledger_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeJournalS3ExportOutput {
    /// <p>Information about the journal export job returned by a
    /// <code>DescribeJournalS3Export</code> request.</p>
    pub export_description: std::option::Option<crate::model::JournalS3ExportDescription>,
}
impl DescribeJournalS3ExportOutput {
    /// <p>Information about the journal export job returned by a
    /// <code>DescribeJournalS3Export</code> request.</p>
    pub fn export_description(
        &self,
    ) -> std::option::Option<&crate::model::JournalS3ExportDescription> {
        self.export_description.as_ref()
    }
}
impl std::fmt::Debug for DescribeJournalS3ExportOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeJournalS3ExportOutput");
        formatter.field("export_description", &self.export_description);
        formatter.finish()
    }
}
/// See [`DescribeJournalS3ExportOutput`](crate::output::DescribeJournalS3ExportOutput)
pub mod describe_journal_s3_export_output {
    /// A builder for [`DescribeJournalS3ExportOutput`](crate::output::DescribeJournalS3ExportOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) export_description:
            std::option::Option<crate::model::JournalS3ExportDescription>,
    }
    impl Builder {
        /// <p>Information about the journal export job returned by a
        /// <code>DescribeJournalS3Export</code> request.</p>
        pub fn export_description(
            mut self,
            input: crate::model::JournalS3ExportDescription,
        ) -> Self {
            self.export_description = Some(input);
            self
        }
        /// <p>Information about the journal export job returned by a
        /// <code>DescribeJournalS3Export</code> request.</p>
        pub fn set_export_description(
            mut self,
            input: std::option::Option<crate::model::JournalS3ExportDescription>,
        ) -> Self {
            self.export_description = input;
            self
        }
        /// Consumes the builder and constructs a [`DescribeJournalS3ExportOutput`](crate::output::DescribeJournalS3ExportOutput)
        pub fn build(self) -> crate::output::DescribeJournalS3ExportOutput {
            crate::output::DescribeJournalS3ExportOutput {
                export_description: self.export_description,
            }
        }
    }
}
impl DescribeJournalS3ExportOutput {
    /// Creates a new builder-style object to manufacture [`DescribeJournalS3ExportOutput`](crate::output::DescribeJournalS3ExportOutput)
    pub fn builder() -> crate::output::describe_journal_s3_export_output::Builder {
        crate::output::describe_journal_s3_export_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeJournalKinesisStreamOutput {
    /// <p>Information about the QLDB journal stream returned by a
    /// <code>DescribeJournalS3Export</code> request.</p>
    pub stream: std::option::Option<crate::model::JournalKinesisStreamDescription>,
}
impl DescribeJournalKinesisStreamOutput {
    /// <p>Information about the QLDB journal stream returned by a
    /// <code>DescribeJournalS3Export</code> request.</p>
    pub fn stream(&self) -> std::option::Option<&crate::model::JournalKinesisStreamDescription> {
        self.stream.as_ref()
    }
}
impl std::fmt::Debug for DescribeJournalKinesisStreamOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeJournalKinesisStreamOutput");
        formatter.field("stream", &self.stream);
        formatter.finish()
    }
}
/// See [`DescribeJournalKinesisStreamOutput`](crate::output::DescribeJournalKinesisStreamOutput)
pub mod describe_journal_kinesis_stream_output {
    /// A builder for [`DescribeJournalKinesisStreamOutput`](crate::output::DescribeJournalKinesisStreamOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) stream: std::option::Option<crate::model::JournalKinesisStreamDescription>,
    }
    impl Builder {
        /// <p>Information about the QLDB journal stream returned by a
        /// <code>DescribeJournalS3Export</code> request.</p>
        pub fn stream(mut self, input: crate::model::JournalKinesisStreamDescription) -> Self {
            self.stream = Some(input);
            self
        }
        /// <p>Information about the QLDB journal stream returned by a
        /// <code>DescribeJournalS3Export</code> request.</p>
        pub fn set_stream(
            mut self,
            input: std::option::Option<crate::model::JournalKinesisStreamDescription>,
        ) -> Self {
            self.stream = input;
            self
        }
        /// Consumes the builder and constructs a [`DescribeJournalKinesisStreamOutput`](crate::output::DescribeJournalKinesisStreamOutput)
        pub fn build(self) -> crate::output::DescribeJournalKinesisStreamOutput {
            crate::output::DescribeJournalKinesisStreamOutput {
                stream: self.stream,
            }
        }
    }
}
impl DescribeJournalKinesisStreamOutput {
    /// Creates a new builder-style object to manufacture [`DescribeJournalKinesisStreamOutput`](crate::output::DescribeJournalKinesisStreamOutput)
    pub fn builder() -> crate::output::describe_journal_kinesis_stream_output::Builder {
        crate::output::describe_journal_kinesis_stream_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteLedgerOutput {}
impl std::fmt::Debug for DeleteLedgerOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteLedgerOutput");
        formatter.finish()
    }
}
/// See [`DeleteLedgerOutput`](crate::output::DeleteLedgerOutput)
pub mod delete_ledger_output {
    /// A builder for [`DeleteLedgerOutput`](crate::output::DeleteLedgerOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {}
    impl Builder {
        /// Consumes the builder and constructs a [`DeleteLedgerOutput`](crate::output::DeleteLedgerOutput)
        pub fn build(self) -> crate::output::DeleteLedgerOutput {
            crate::output::DeleteLedgerOutput {}
        }
    }
}
impl DeleteLedgerOutput {
    /// Creates a new builder-style object to manufacture [`DeleteLedgerOutput`](crate::output::DeleteLedgerOutput)
    pub fn builder() -> crate::output::delete_ledger_output::Builder {
        crate::output::delete_ledger_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateLedgerOutput {
    /// <p>The name of the ledger.</p>
    pub name: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) for the ledger.</p>
    pub arn: std::option::Option<std::string::String>,
    /// <p>The current status of the ledger.</p>
    pub state: std::option::Option<crate::model::LedgerState>,
    /// <p>The date and time, in epoch time format, when the ledger was created. (Epoch time format
    /// is the number of seconds elapsed since 12:00:00 AM January 1, 1970 UTC.)</p>
    pub creation_date_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The permissions mode of the ledger that you created.</p>
    pub permissions_mode: std::option::Option<crate::model::PermissionsMode>,
    /// <p>The flag that prevents a ledger from being deleted by any user. If not provided on
    /// ledger creation, this feature is enabled (<code>true</code>) by default.</p>
    /// <p>If deletion protection is enabled, you must first disable it before you can delete the
    /// ledger. You can disable it by calling the <code>UpdateLedger</code> operation to set the flag to <code>false</code>.</p>
    pub deletion_protection: std::option::Option<bool>,
    /// <p>The ARN of the customer managed KMS key that the ledger uses for encryption at rest. If
    /// this parameter is undefined, the ledger uses an Amazon Web Services owned KMS key for encryption.</p>
    pub kms_key_arn: std::option::Option<std::string::String>,
}
impl CreateLedgerOutput {
    /// <p>The name of the ledger.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) for the ledger.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>The current status of the ledger.</p>
    pub fn state(&self) -> std::option::Option<&crate::model::LedgerState> {
        self.state.as_ref()
    }
    /// <p>The date and time, in epoch time format, when the ledger was created. (Epoch time format
    /// is the number of seconds elapsed since 12:00:00 AM January 1, 1970 UTC.)</p>
    pub fn creation_date_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.creation_date_time.as_ref()
    }
    /// <p>The permissions mode of the ledger that you created.</p>
    pub fn permissions_mode(&self) -> std::option::Option<&crate::model::PermissionsMode> {
        self.permissions_mode.as_ref()
    }
    /// <p>The flag that prevents a ledger from being deleted by any user. If not provided on
    /// ledger creation, this feature is enabled (<code>true</code>) by default.</p>
    /// <p>If deletion protection is enabled, you must first disable it before you can delete the
    /// ledger. You can disable it by calling the <code>UpdateLedger</code> operation to set the flag to <code>false</code>.</p>
    pub fn deletion_protection(&self) -> std::option::Option<bool> {
        self.deletion_protection
    }
    /// <p>The ARN of the customer managed KMS key that the ledger uses for encryption at rest. If
    /// this parameter is undefined, the ledger uses an Amazon Web Services owned KMS key for encryption.</p>
    pub fn kms_key_arn(&self) -> std::option::Option<&str> {
        self.kms_key_arn.as_deref()
    }
}
impl std::fmt::Debug for CreateLedgerOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateLedgerOutput");
        formatter.field("name", &self.name);
        formatter.field("arn", &self.arn);
        formatter.field("state", &self.state);
        formatter.field("creation_date_time", &self.creation_date_time);
        formatter.field("permissions_mode", &self.permissions_mode);
        formatter.field("deletion_protection", &self.deletion_protection);
        formatter.field("kms_key_arn", &self.kms_key_arn);
        formatter.finish()
    }
}
/// See [`CreateLedgerOutput`](crate::output::CreateLedgerOutput)
pub mod create_ledger_output {
    /// A builder for [`CreateLedgerOutput`](crate::output::CreateLedgerOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) state: std::option::Option<crate::model::LedgerState>,
        pub(crate) creation_date_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) permissions_mode: std::option::Option<crate::model::PermissionsMode>,
        pub(crate) deletion_protection: std::option::Option<bool>,
        pub(crate) kms_key_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the ledger.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the ledger.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) for the ledger.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) for the ledger.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>The current status of the ledger.</p>
        pub fn state(mut self, input: crate::model::LedgerState) -> Self {
            self.state = Some(input);
            self
        }
        /// <p>The current status of the ledger.</p>
        pub fn set_state(mut self, input: std::option::Option<crate::model::LedgerState>) -> Self {
            self.state = input;
            self
        }
        /// <p>The date and time, in epoch time format, when the ledger was created. (Epoch time format
        /// is the number of seconds elapsed since 12:00:00 AM January 1, 1970 UTC.)</p>
        pub fn creation_date_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.creation_date_time = Some(input);
            self
        }
        /// <p>The date and time, in epoch time format, when the ledger was created. (Epoch time format
        /// is the number of seconds elapsed since 12:00:00 AM January 1, 1970 UTC.)</p>
        pub fn set_creation_date_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.creation_date_time = input;
            self
        }
        /// <p>The permissions mode of the ledger that you created.</p>
        pub fn permissions_mode(mut self, input: crate::model::PermissionsMode) -> Self {
            self.permissions_mode = Some(input);
            self
        }
        /// <p>The permissions mode of the ledger that you created.</p>
        pub fn set_permissions_mode(
            mut self,
            input: std::option::Option<crate::model::PermissionsMode>,
        ) -> Self {
            self.permissions_mode = input;
            self
        }
        /// <p>The flag that prevents a ledger from being deleted by any user. If not provided on
        /// ledger creation, this feature is enabled (<code>true</code>) by default.</p>
        /// <p>If deletion protection is enabled, you must first disable it before you can delete the
        /// ledger. You can disable it by calling the <code>UpdateLedger</code> operation to set the flag to <code>false</code>.</p>
        pub fn deletion_protection(mut self, input: bool) -> Self {
            self.deletion_protection = Some(input);
            self
        }
        /// <p>The flag that prevents a ledger from being deleted by any user. If not provided on
        /// ledger creation, this feature is enabled (<code>true</code>) by default.</p>
        /// <p>If deletion protection is enabled, you must first disable it before you can delete the
        /// ledger. You can disable it by calling the <code>UpdateLedger</code> operation to set the flag to <code>false</code>.</p>
        pub fn set_deletion_protection(mut self, input: std::option::Option<bool>) -> Self {
            self.deletion_protection = input;
            self
        }
        /// <p>The ARN of the customer managed KMS key that the ledger uses for encryption at rest. If
        /// this parameter is undefined, the ledger uses an Amazon Web Services owned KMS key for encryption.</p>
        pub fn kms_key_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.kms_key_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the customer managed KMS key that the ledger uses for encryption at rest. If
        /// this parameter is undefined, the ledger uses an Amazon Web Services owned KMS key for encryption.</p>
        pub fn set_kms_key_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.kms_key_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`CreateLedgerOutput`](crate::output::CreateLedgerOutput)
        pub fn build(self) -> crate::output::CreateLedgerOutput {
            crate::output::CreateLedgerOutput {
                name: self.name,
                arn: self.arn,
                state: self.state,
                creation_date_time: self.creation_date_time,
                permissions_mode: self.permissions_mode,
                deletion_protection: self.deletion_protection,
                kms_key_arn: self.kms_key_arn,
            }
        }
    }
}
impl CreateLedgerOutput {
    /// Creates a new builder-style object to manufacture [`CreateLedgerOutput`](crate::output::CreateLedgerOutput)
    pub fn builder() -> crate::output::create_ledger_output::Builder {
        crate::output::create_ledger_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CancelJournalKinesisStreamOutput {
    /// <p>The UUID (Base62-encoded text) of the canceled QLDB journal stream.</p>
    pub stream_id: std::option::Option<std::string::String>,
}
impl CancelJournalKinesisStreamOutput {
    /// <p>The UUID (Base62-encoded text) of the canceled QLDB journal stream.</p>
    pub fn stream_id(&self) -> std::option::Option<&str> {
        self.stream_id.as_deref()
    }
}
impl std::fmt::Debug for CancelJournalKinesisStreamOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CancelJournalKinesisStreamOutput");
        formatter.field("stream_id", &self.stream_id);
        formatter.finish()
    }
}
/// See [`CancelJournalKinesisStreamOutput`](crate::output::CancelJournalKinesisStreamOutput)
pub mod cancel_journal_kinesis_stream_output {
    /// A builder for [`CancelJournalKinesisStreamOutput`](crate::output::CancelJournalKinesisStreamOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) stream_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The UUID (Base62-encoded text) of the canceled QLDB journal stream.</p>
        pub fn stream_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.stream_id = Some(input.into());
            self
        }
        /// <p>The UUID (Base62-encoded text) of the canceled QLDB journal stream.</p>
        pub fn set_stream_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.stream_id = input;
            self
        }
        /// Consumes the builder and constructs a [`CancelJournalKinesisStreamOutput`](crate::output::CancelJournalKinesisStreamOutput)
        pub fn build(self) -> crate::output::CancelJournalKinesisStreamOutput {
            crate::output::CancelJournalKinesisStreamOutput {
                stream_id: self.stream_id,
            }
        }
    }
}
impl CancelJournalKinesisStreamOutput {
    /// Creates a new builder-style object to manufacture [`CancelJournalKinesisStreamOutput`](crate::output::CancelJournalKinesisStreamOutput)
    pub fn builder() -> crate::output::cancel_journal_kinesis_stream_output::Builder {
        crate::output::cancel_journal_kinesis_stream_output::Builder::default()
    }
}
