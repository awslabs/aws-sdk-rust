// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
/// <p>Object specifying a channel.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Channel {
    /// <p>Channel ARN.</p>
    pub arn: std::option::Option<std::string::String>,
    /// <p>Channel name.</p>
    pub name: std::option::Option<std::string::String>,
    /// <p>Channel latency mode. Use <code>NORMAL</code> to broadcast and deliver live video up to
    /// Full HD. Use <code>LOW</code> for near-real-time interaction with viewers. Default:
    /// <code>LOW</code>. (Note: In the Amazon IVS console, <code>LOW</code> and <code>NORMAL</code>
    /// correspond to Ultra-low and Standard, respectively.)</p>
    pub latency_mode: std::option::Option<crate::model::ChannelLatencyMode>,
    /// <p>Channel type, which determines the allowable resolution and bitrate. <i>If you
    /// exceed the allowable resolution or bitrate, the stream probably will disconnect
    /// immediately.</i> Default: <code>STANDARD</code>. Valid values:</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>STANDARD</code>: Multiple qualities are generated from the original input, to
    /// automatically give viewers the best experience for their devices and network conditions.
    /// Resolution can be up to 1080p and bitrate can be up to 8.5 Mbps. Audio is transcoded only
    /// for renditions 360p and below; above that, audio is passed through.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>BASIC</code>: Amazon IVS delivers the original input to viewers. The viewer’s
    /// video-quality choice is limited to the original input. Resolution can be up to 480p and
    /// bitrate can be up to 1.5 Mbps.</p>
    /// </li>
    /// </ul>
    pub r#type: std::option::Option<crate::model::ChannelType>,
    /// <p>Recording-configuration ARN. A value other than an empty string indicates that recording
    /// is enabled. Default: "" (empty string, recording is disabled).</p>
    pub recording_configuration_arn: std::option::Option<std::string::String>,
    /// <p>Channel ingest endpoint, part of the definition of an ingest server, used when you set up
    /// streaming software.</p>
    pub ingest_endpoint: std::option::Option<std::string::String>,
    /// <p>Channel playback URL.</p>
    pub playback_url: std::option::Option<std::string::String>,
    /// <p>Whether the channel is private (enabled for playback authorization). Default:
    /// <code>false</code>.</p>
    pub authorized: bool,
    /// <p>Array of 1-50 maps, each of the form <code>string:string (key:value)</code>.</p>
    pub tags:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
}
impl Channel {
    /// <p>Channel ARN.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>Channel name.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>Channel latency mode. Use <code>NORMAL</code> to broadcast and deliver live video up to
    /// Full HD. Use <code>LOW</code> for near-real-time interaction with viewers. Default:
    /// <code>LOW</code>. (Note: In the Amazon IVS console, <code>LOW</code> and <code>NORMAL</code>
    /// correspond to Ultra-low and Standard, respectively.)</p>
    pub fn latency_mode(&self) -> std::option::Option<&crate::model::ChannelLatencyMode> {
        self.latency_mode.as_ref()
    }
    /// <p>Channel type, which determines the allowable resolution and bitrate. <i>If you
    /// exceed the allowable resolution or bitrate, the stream probably will disconnect
    /// immediately.</i> Default: <code>STANDARD</code>. Valid values:</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>STANDARD</code>: Multiple qualities are generated from the original input, to
    /// automatically give viewers the best experience for their devices and network conditions.
    /// Resolution can be up to 1080p and bitrate can be up to 8.5 Mbps. Audio is transcoded only
    /// for renditions 360p and below; above that, audio is passed through.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>BASIC</code>: Amazon IVS delivers the original input to viewers. The viewer’s
    /// video-quality choice is limited to the original input. Resolution can be up to 480p and
    /// bitrate can be up to 1.5 Mbps.</p>
    /// </li>
    /// </ul>
    pub fn r#type(&self) -> std::option::Option<&crate::model::ChannelType> {
        self.r#type.as_ref()
    }
    /// <p>Recording-configuration ARN. A value other than an empty string indicates that recording
    /// is enabled. Default: "" (empty string, recording is disabled).</p>
    pub fn recording_configuration_arn(&self) -> std::option::Option<&str> {
        self.recording_configuration_arn.as_deref()
    }
    /// <p>Channel ingest endpoint, part of the definition of an ingest server, used when you set up
    /// streaming software.</p>
    pub fn ingest_endpoint(&self) -> std::option::Option<&str> {
        self.ingest_endpoint.as_deref()
    }
    /// <p>Channel playback URL.</p>
    pub fn playback_url(&self) -> std::option::Option<&str> {
        self.playback_url.as_deref()
    }
    /// <p>Whether the channel is private (enabled for playback authorization). Default:
    /// <code>false</code>.</p>
    pub fn authorized(&self) -> bool {
        self.authorized
    }
    /// <p>Array of 1-50 maps, each of the form <code>string:string (key:value)</code>.</p>
    pub fn tags(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.tags.as_ref()
    }
}
impl std::fmt::Debug for Channel {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Channel");
        formatter.field("arn", &self.arn);
        formatter.field("name", &self.name);
        formatter.field("latency_mode", &self.latency_mode);
        formatter.field("r#type", &self.r#type);
        formatter.field(
            "recording_configuration_arn",
            &self.recording_configuration_arn,
        );
        formatter.field("ingest_endpoint", &self.ingest_endpoint);
        formatter.field("playback_url", &self.playback_url);
        formatter.field("authorized", &self.authorized);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}
/// See [`Channel`](crate::model::Channel)
pub mod channel {
    /// A builder for [`Channel`](crate::model::Channel)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) latency_mode: std::option::Option<crate::model::ChannelLatencyMode>,
        pub(crate) r#type: std::option::Option<crate::model::ChannelType>,
        pub(crate) recording_configuration_arn: std::option::Option<std::string::String>,
        pub(crate) ingest_endpoint: std::option::Option<std::string::String>,
        pub(crate) playback_url: std::option::Option<std::string::String>,
        pub(crate) authorized: std::option::Option<bool>,
        pub(crate) tags: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
    }
    impl Builder {
        /// <p>Channel ARN.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>Channel ARN.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>Channel name.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>Channel name.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>Channel latency mode. Use <code>NORMAL</code> to broadcast and deliver live video up to
        /// Full HD. Use <code>LOW</code> for near-real-time interaction with viewers. Default:
        /// <code>LOW</code>. (Note: In the Amazon IVS console, <code>LOW</code> and <code>NORMAL</code>
        /// correspond to Ultra-low and Standard, respectively.)</p>
        pub fn latency_mode(mut self, input: crate::model::ChannelLatencyMode) -> Self {
            self.latency_mode = Some(input);
            self
        }
        /// <p>Channel latency mode. Use <code>NORMAL</code> to broadcast and deliver live video up to
        /// Full HD. Use <code>LOW</code> for near-real-time interaction with viewers. Default:
        /// <code>LOW</code>. (Note: In the Amazon IVS console, <code>LOW</code> and <code>NORMAL</code>
        /// correspond to Ultra-low and Standard, respectively.)</p>
        pub fn set_latency_mode(
            mut self,
            input: std::option::Option<crate::model::ChannelLatencyMode>,
        ) -> Self {
            self.latency_mode = input;
            self
        }
        /// <p>Channel type, which determines the allowable resolution and bitrate. <i>If you
        /// exceed the allowable resolution or bitrate, the stream probably will disconnect
        /// immediately.</i> Default: <code>STANDARD</code>. Valid values:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>STANDARD</code>: Multiple qualities are generated from the original input, to
        /// automatically give viewers the best experience for their devices and network conditions.
        /// Resolution can be up to 1080p and bitrate can be up to 8.5 Mbps. Audio is transcoded only
        /// for renditions 360p and below; above that, audio is passed through.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>BASIC</code>: Amazon IVS delivers the original input to viewers. The viewer’s
        /// video-quality choice is limited to the original input. Resolution can be up to 480p and
        /// bitrate can be up to 1.5 Mbps.</p>
        /// </li>
        /// </ul>
        pub fn r#type(mut self, input: crate::model::ChannelType) -> Self {
            self.r#type = Some(input);
            self
        }
        /// <p>Channel type, which determines the allowable resolution and bitrate. <i>If you
        /// exceed the allowable resolution or bitrate, the stream probably will disconnect
        /// immediately.</i> Default: <code>STANDARD</code>. Valid values:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>STANDARD</code>: Multiple qualities are generated from the original input, to
        /// automatically give viewers the best experience for their devices and network conditions.
        /// Resolution can be up to 1080p and bitrate can be up to 8.5 Mbps. Audio is transcoded only
        /// for renditions 360p and below; above that, audio is passed through.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>BASIC</code>: Amazon IVS delivers the original input to viewers. The viewer’s
        /// video-quality choice is limited to the original input. Resolution can be up to 480p and
        /// bitrate can be up to 1.5 Mbps.</p>
        /// </li>
        /// </ul>
        pub fn set_type(mut self, input: std::option::Option<crate::model::ChannelType>) -> Self {
            self.r#type = input;
            self
        }
        /// <p>Recording-configuration ARN. A value other than an empty string indicates that recording
        /// is enabled. Default: "" (empty string, recording is disabled).</p>
        pub fn recording_configuration_arn(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.recording_configuration_arn = Some(input.into());
            self
        }
        /// <p>Recording-configuration ARN. A value other than an empty string indicates that recording
        /// is enabled. Default: "" (empty string, recording is disabled).</p>
        pub fn set_recording_configuration_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.recording_configuration_arn = input;
            self
        }
        /// <p>Channel ingest endpoint, part of the definition of an ingest server, used when you set up
        /// streaming software.</p>
        pub fn ingest_endpoint(mut self, input: impl Into<std::string::String>) -> Self {
            self.ingest_endpoint = Some(input.into());
            self
        }
        /// <p>Channel ingest endpoint, part of the definition of an ingest server, used when you set up
        /// streaming software.</p>
        pub fn set_ingest_endpoint(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.ingest_endpoint = input;
            self
        }
        /// <p>Channel playback URL.</p>
        pub fn playback_url(mut self, input: impl Into<std::string::String>) -> Self {
            self.playback_url = Some(input.into());
            self
        }
        /// <p>Channel playback URL.</p>
        pub fn set_playback_url(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.playback_url = input;
            self
        }
        /// <p>Whether the channel is private (enabled for playback authorization). Default:
        /// <code>false</code>.</p>
        pub fn authorized(mut self, input: bool) -> Self {
            self.authorized = Some(input);
            self
        }
        /// <p>Whether the channel is private (enabled for playback authorization). Default:
        /// <code>false</code>.</p>
        pub fn set_authorized(mut self, input: std::option::Option<bool>) -> Self {
            self.authorized = input;
            self
        }
        /// Adds a key-value pair to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>Array of 1-50 maps, each of the form <code>string:string (key:value)</code>.</p>
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.tags.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.tags = Some(hash_map);
            self
        }
        /// <p>Array of 1-50 maps, each of the form <code>string:string (key:value)</code>.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`Channel`](crate::model::Channel)
        pub fn build(self) -> crate::model::Channel {
            crate::model::Channel {
                arn: self.arn,
                name: self.name,
                latency_mode: self.latency_mode,
                r#type: self.r#type,
                recording_configuration_arn: self.recording_configuration_arn,
                ingest_endpoint: self.ingest_endpoint,
                playback_url: self.playback_url,
                authorized: self.authorized.unwrap_or_default(),
                tags: self.tags,
            }
        }
    }
}
impl Channel {
    /// Creates a new builder-style object to manufacture [`Channel`](crate::model::Channel)
    pub fn builder() -> crate::model::channel::Builder {
        crate::model::channel::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ChannelType {
    #[allow(missing_docs)] // documentation missing in model
    BasicChannelType,
    #[allow(missing_docs)] // documentation missing in model
    StandardChannelType,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for ChannelType {
    fn from(s: &str) -> Self {
        match s {
            "BASIC" => ChannelType::BasicChannelType,
            "STANDARD" => ChannelType::StandardChannelType,
            other => ChannelType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for ChannelType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ChannelType::from(s))
    }
}
impl ChannelType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ChannelType::BasicChannelType => "BASIC",
            ChannelType::StandardChannelType => "STANDARD",
            ChannelType::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["BASIC", "STANDARD"]
    }
}
impl AsRef<str> for ChannelType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ChannelLatencyMode {
    #[allow(missing_docs)] // documentation missing in model
    LowLatency,
    #[allow(missing_docs)] // documentation missing in model
    NormalLatency,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for ChannelLatencyMode {
    fn from(s: &str) -> Self {
        match s {
            "LOW" => ChannelLatencyMode::LowLatency,
            "NORMAL" => ChannelLatencyMode::NormalLatency,
            other => ChannelLatencyMode::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for ChannelLatencyMode {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ChannelLatencyMode::from(s))
    }
}
impl ChannelLatencyMode {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ChannelLatencyMode::LowLatency => "LOW",
            ChannelLatencyMode::NormalLatency => "NORMAL",
            ChannelLatencyMode::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["LOW", "NORMAL"]
    }
}
impl AsRef<str> for ChannelLatencyMode {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Summary information about a stream session.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct StreamSessionSummary {
    /// <p>Unique identifier for a live or previously live stream in the specified channel.</p>
    pub stream_id: std::option::Option<std::string::String>,
    /// <p>UTC ISO-8601 formatted timestamp of when the channel went live.</p>
    pub start_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>UTC ISO-8601 formatted timestamp of when the channel went offline. For live streams, this
    /// is <code>NULL</code>.</p>
    pub end_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>If <code>true</code>, this stream encountered a quota breach or failure.</p>
    pub has_error_event: bool,
}
impl StreamSessionSummary {
    /// <p>Unique identifier for a live or previously live stream in the specified channel.</p>
    pub fn stream_id(&self) -> std::option::Option<&str> {
        self.stream_id.as_deref()
    }
    /// <p>UTC ISO-8601 formatted timestamp of when the channel went live.</p>
    pub fn start_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.start_time.as_ref()
    }
    /// <p>UTC ISO-8601 formatted timestamp of when the channel went offline. For live streams, this
    /// is <code>NULL</code>.</p>
    pub fn end_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.end_time.as_ref()
    }
    /// <p>If <code>true</code>, this stream encountered a quota breach or failure.</p>
    pub fn has_error_event(&self) -> bool {
        self.has_error_event
    }
}
impl std::fmt::Debug for StreamSessionSummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("StreamSessionSummary");
        formatter.field("stream_id", &self.stream_id);
        formatter.field("start_time", &self.start_time);
        formatter.field("end_time", &self.end_time);
        formatter.field("has_error_event", &self.has_error_event);
        formatter.finish()
    }
}
/// See [`StreamSessionSummary`](crate::model::StreamSessionSummary)
pub mod stream_session_summary {
    /// A builder for [`StreamSessionSummary`](crate::model::StreamSessionSummary)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) stream_id: std::option::Option<std::string::String>,
        pub(crate) start_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) end_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) has_error_event: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>Unique identifier for a live or previously live stream in the specified channel.</p>
        pub fn stream_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.stream_id = Some(input.into());
            self
        }
        /// <p>Unique identifier for a live or previously live stream in the specified channel.</p>
        pub fn set_stream_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.stream_id = input;
            self
        }
        /// <p>UTC ISO-8601 formatted timestamp of when the channel went live.</p>
        pub fn start_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.start_time = Some(input);
            self
        }
        /// <p>UTC ISO-8601 formatted timestamp of when the channel went live.</p>
        pub fn set_start_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.start_time = input;
            self
        }
        /// <p>UTC ISO-8601 formatted timestamp of when the channel went offline. For live streams, this
        /// is <code>NULL</code>.</p>
        pub fn end_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.end_time = Some(input);
            self
        }
        /// <p>UTC ISO-8601 formatted timestamp of when the channel went offline. For live streams, this
        /// is <code>NULL</code>.</p>
        pub fn set_end_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.end_time = input;
            self
        }
        /// <p>If <code>true</code>, this stream encountered a quota breach or failure.</p>
        pub fn has_error_event(mut self, input: bool) -> Self {
            self.has_error_event = Some(input);
            self
        }
        /// <p>If <code>true</code>, this stream encountered a quota breach or failure.</p>
        pub fn set_has_error_event(mut self, input: std::option::Option<bool>) -> Self {
            self.has_error_event = input;
            self
        }
        /// Consumes the builder and constructs a [`StreamSessionSummary`](crate::model::StreamSessionSummary)
        pub fn build(self) -> crate::model::StreamSessionSummary {
            crate::model::StreamSessionSummary {
                stream_id: self.stream_id,
                start_time: self.start_time,
                end_time: self.end_time,
                has_error_event: self.has_error_event.unwrap_or_default(),
            }
        }
    }
}
impl StreamSessionSummary {
    /// Creates a new builder-style object to manufacture [`StreamSessionSummary`](crate::model::StreamSessionSummary)
    pub fn builder() -> crate::model::stream_session_summary::Builder {
        crate::model::stream_session_summary::Builder::default()
    }
}

/// <p>Summary information about a stream.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct StreamSummary {
    /// <p>Channel ARN for the stream.</p>
    pub channel_arn: std::option::Option<std::string::String>,
    /// <p>Unique identifier for a live or previously live stream in the specified channel.</p>
    pub stream_id: std::option::Option<std::string::String>,
    /// <p>The stream’s state.</p>
    pub state: std::option::Option<crate::model::StreamState>,
    /// <p>The stream’s health.</p>
    pub health: std::option::Option<crate::model::StreamHealth>,
    /// <p>A count of concurrent views of the stream. Typically, a new view appears in
    /// <code>viewerCount</code> within 15 seconds of when video playback starts and a view is
    /// removed from <code>viewerCount</code> within 1 minute of when video playback ends. A value of
    /// -1 indicates that the request timed out; in this case, retry.</p>
    pub viewer_count: i64,
    /// <p>Time of the stream’s start. This is an ISO 8601 timestamp returned as a string.</p>
    pub start_time: std::option::Option<aws_smithy_types::DateTime>,
}
impl StreamSummary {
    /// <p>Channel ARN for the stream.</p>
    pub fn channel_arn(&self) -> std::option::Option<&str> {
        self.channel_arn.as_deref()
    }
    /// <p>Unique identifier for a live or previously live stream in the specified channel.</p>
    pub fn stream_id(&self) -> std::option::Option<&str> {
        self.stream_id.as_deref()
    }
    /// <p>The stream’s state.</p>
    pub fn state(&self) -> std::option::Option<&crate::model::StreamState> {
        self.state.as_ref()
    }
    /// <p>The stream’s health.</p>
    pub fn health(&self) -> std::option::Option<&crate::model::StreamHealth> {
        self.health.as_ref()
    }
    /// <p>A count of concurrent views of the stream. Typically, a new view appears in
    /// <code>viewerCount</code> within 15 seconds of when video playback starts and a view is
    /// removed from <code>viewerCount</code> within 1 minute of when video playback ends. A value of
    /// -1 indicates that the request timed out; in this case, retry.</p>
    pub fn viewer_count(&self) -> i64 {
        self.viewer_count
    }
    /// <p>Time of the stream’s start. This is an ISO 8601 timestamp returned as a string.</p>
    pub fn start_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.start_time.as_ref()
    }
}
impl std::fmt::Debug for StreamSummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("StreamSummary");
        formatter.field("channel_arn", &self.channel_arn);
        formatter.field("stream_id", &self.stream_id);
        formatter.field("state", &self.state);
        formatter.field("health", &self.health);
        formatter.field("viewer_count", &self.viewer_count);
        formatter.field("start_time", &self.start_time);
        formatter.finish()
    }
}
/// See [`StreamSummary`](crate::model::StreamSummary)
pub mod stream_summary {
    /// A builder for [`StreamSummary`](crate::model::StreamSummary)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) channel_arn: std::option::Option<std::string::String>,
        pub(crate) stream_id: std::option::Option<std::string::String>,
        pub(crate) state: std::option::Option<crate::model::StreamState>,
        pub(crate) health: std::option::Option<crate::model::StreamHealth>,
        pub(crate) viewer_count: std::option::Option<i64>,
        pub(crate) start_time: std::option::Option<aws_smithy_types::DateTime>,
    }
    impl Builder {
        /// <p>Channel ARN for the stream.</p>
        pub fn channel_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.channel_arn = Some(input.into());
            self
        }
        /// <p>Channel ARN for the stream.</p>
        pub fn set_channel_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.channel_arn = input;
            self
        }
        /// <p>Unique identifier for a live or previously live stream in the specified channel.</p>
        pub fn stream_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.stream_id = Some(input.into());
            self
        }
        /// <p>Unique identifier for a live or previously live stream in the specified channel.</p>
        pub fn set_stream_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.stream_id = input;
            self
        }
        /// <p>The stream’s state.</p>
        pub fn state(mut self, input: crate::model::StreamState) -> Self {
            self.state = Some(input);
            self
        }
        /// <p>The stream’s state.</p>
        pub fn set_state(mut self, input: std::option::Option<crate::model::StreamState>) -> Self {
            self.state = input;
            self
        }
        /// <p>The stream’s health.</p>
        pub fn health(mut self, input: crate::model::StreamHealth) -> Self {
            self.health = Some(input);
            self
        }
        /// <p>The stream’s health.</p>
        pub fn set_health(
            mut self,
            input: std::option::Option<crate::model::StreamHealth>,
        ) -> Self {
            self.health = input;
            self
        }
        /// <p>A count of concurrent views of the stream. Typically, a new view appears in
        /// <code>viewerCount</code> within 15 seconds of when video playback starts and a view is
        /// removed from <code>viewerCount</code> within 1 minute of when video playback ends. A value of
        /// -1 indicates that the request timed out; in this case, retry.</p>
        pub fn viewer_count(mut self, input: i64) -> Self {
            self.viewer_count = Some(input);
            self
        }
        /// <p>A count of concurrent views of the stream. Typically, a new view appears in
        /// <code>viewerCount</code> within 15 seconds of when video playback starts and a view is
        /// removed from <code>viewerCount</code> within 1 minute of when video playback ends. A value of
        /// -1 indicates that the request timed out; in this case, retry.</p>
        pub fn set_viewer_count(mut self, input: std::option::Option<i64>) -> Self {
            self.viewer_count = input;
            self
        }
        /// <p>Time of the stream’s start. This is an ISO 8601 timestamp returned as a string.</p>
        pub fn start_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.start_time = Some(input);
            self
        }
        /// <p>Time of the stream’s start. This is an ISO 8601 timestamp returned as a string.</p>
        pub fn set_start_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.start_time = input;
            self
        }
        /// Consumes the builder and constructs a [`StreamSummary`](crate::model::StreamSummary)
        pub fn build(self) -> crate::model::StreamSummary {
            crate::model::StreamSummary {
                channel_arn: self.channel_arn,
                stream_id: self.stream_id,
                state: self.state,
                health: self.health,
                viewer_count: self.viewer_count.unwrap_or_default(),
                start_time: self.start_time,
            }
        }
    }
}
impl StreamSummary {
    /// Creates a new builder-style object to manufacture [`StreamSummary`](crate::model::StreamSummary)
    pub fn builder() -> crate::model::stream_summary::Builder {
        crate::model::stream_summary::Builder::default()
    }
}

/// _Note: `StreamHealth::Unknown` has been renamed to `::UnknownValue`._
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum StreamHealth {
    #[allow(missing_docs)] // documentation missing in model
    StreamHealthy,
    #[allow(missing_docs)] // documentation missing in model
    Starving,
    /// _Note: `::Unknown` has been renamed to `::UnknownValue`._
    UnknownValue,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for StreamHealth {
    fn from(s: &str) -> Self {
        match s {
            "HEALTHY" => StreamHealth::StreamHealthy,
            "STARVING" => StreamHealth::Starving,
            "UNKNOWN" => StreamHealth::UnknownValue,
            other => StreamHealth::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for StreamHealth {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(StreamHealth::from(s))
    }
}
impl StreamHealth {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            StreamHealth::StreamHealthy => "HEALTHY",
            StreamHealth::Starving => "STARVING",
            StreamHealth::UnknownValue => "UNKNOWN",
            StreamHealth::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["HEALTHY", "STARVING", "UNKNOWN"]
    }
}
impl AsRef<str> for StreamHealth {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum StreamState {
    #[allow(missing_docs)] // documentation missing in model
    StreamLive,
    #[allow(missing_docs)] // documentation missing in model
    StreamOffline,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for StreamState {
    fn from(s: &str) -> Self {
        match s {
            "LIVE" => StreamState::StreamLive,
            "OFFLINE" => StreamState::StreamOffline,
            other => StreamState::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for StreamState {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(StreamState::from(s))
    }
}
impl StreamState {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            StreamState::StreamLive => "LIVE",
            StreamState::StreamOffline => "OFFLINE",
            StreamState::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["LIVE", "OFFLINE"]
    }
}
impl AsRef<str> for StreamState {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Object specifying the stream attribute on which to filter.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct StreamFilters {
    /// <p>The stream’s health.</p>
    pub health: std::option::Option<crate::model::StreamHealth>,
}
impl StreamFilters {
    /// <p>The stream’s health.</p>
    pub fn health(&self) -> std::option::Option<&crate::model::StreamHealth> {
        self.health.as_ref()
    }
}
impl std::fmt::Debug for StreamFilters {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("StreamFilters");
        formatter.field("health", &self.health);
        formatter.finish()
    }
}
/// See [`StreamFilters`](crate::model::StreamFilters)
pub mod stream_filters {
    /// A builder for [`StreamFilters`](crate::model::StreamFilters)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) health: std::option::Option<crate::model::StreamHealth>,
    }
    impl Builder {
        /// <p>The stream’s health.</p>
        pub fn health(mut self, input: crate::model::StreamHealth) -> Self {
            self.health = Some(input);
            self
        }
        /// <p>The stream’s health.</p>
        pub fn set_health(
            mut self,
            input: std::option::Option<crate::model::StreamHealth>,
        ) -> Self {
            self.health = input;
            self
        }
        /// Consumes the builder and constructs a [`StreamFilters`](crate::model::StreamFilters)
        pub fn build(self) -> crate::model::StreamFilters {
            crate::model::StreamFilters {
                health: self.health,
            }
        }
    }
}
impl StreamFilters {
    /// Creates a new builder-style object to manufacture [`StreamFilters`](crate::model::StreamFilters)
    pub fn builder() -> crate::model::stream_filters::Builder {
        crate::model::stream_filters::Builder::default()
    }
}

/// <p>Summary information about a stream key.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct StreamKeySummary {
    /// <p>Stream-key ARN.</p>
    pub arn: std::option::Option<std::string::String>,
    /// <p>Channel ARN for the stream.</p>
    pub channel_arn: std::option::Option<std::string::String>,
    /// <p>Array of 1-50 maps, each of the form <code>string:string (key:value)</code>.</p>
    pub tags:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
}
impl StreamKeySummary {
    /// <p>Stream-key ARN.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>Channel ARN for the stream.</p>
    pub fn channel_arn(&self) -> std::option::Option<&str> {
        self.channel_arn.as_deref()
    }
    /// <p>Array of 1-50 maps, each of the form <code>string:string (key:value)</code>.</p>
    pub fn tags(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.tags.as_ref()
    }
}
impl std::fmt::Debug for StreamKeySummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("StreamKeySummary");
        formatter.field("arn", &self.arn);
        formatter.field("channel_arn", &self.channel_arn);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}
/// See [`StreamKeySummary`](crate::model::StreamKeySummary)
pub mod stream_key_summary {
    /// A builder for [`StreamKeySummary`](crate::model::StreamKeySummary)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) channel_arn: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
    }
    impl Builder {
        /// <p>Stream-key ARN.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>Stream-key ARN.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>Channel ARN for the stream.</p>
        pub fn channel_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.channel_arn = Some(input.into());
            self
        }
        /// <p>Channel ARN for the stream.</p>
        pub fn set_channel_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.channel_arn = input;
            self
        }
        /// Adds a key-value pair to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>Array of 1-50 maps, each of the form <code>string:string (key:value)</code>.</p>
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.tags.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.tags = Some(hash_map);
            self
        }
        /// <p>Array of 1-50 maps, each of the form <code>string:string (key:value)</code>.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`StreamKeySummary`](crate::model::StreamKeySummary)
        pub fn build(self) -> crate::model::StreamKeySummary {
            crate::model::StreamKeySummary {
                arn: self.arn,
                channel_arn: self.channel_arn,
                tags: self.tags,
            }
        }
    }
}
impl StreamKeySummary {
    /// Creates a new builder-style object to manufacture [`StreamKeySummary`](crate::model::StreamKeySummary)
    pub fn builder() -> crate::model::stream_key_summary::Builder {
        crate::model::stream_key_summary::Builder::default()
    }
}

/// <p>Summary information about a RecordingConfiguration.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct RecordingConfigurationSummary {
    /// <p>Recording-configuration ARN.</p>
    pub arn: std::option::Option<std::string::String>,
    /// <p>Recording-configuration name. The value does not need to be unique.</p>
    pub name: std::option::Option<std::string::String>,
    /// <p>A complex type that contains information about where recorded video will be stored.</p>
    pub destination_configuration: std::option::Option<crate::model::DestinationConfiguration>,
    /// <p>Indicates the current state of the recording configuration. When the state is
    /// <code>ACTIVE</code>, the configuration is ready for recording a channel stream.</p>
    pub state: std::option::Option<crate::model::RecordingConfigurationState>,
    /// <p>Array of 1-50 maps, each of the form <code>string:string (key:value)</code>.</p>
    pub tags:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
}
impl RecordingConfigurationSummary {
    /// <p>Recording-configuration ARN.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>Recording-configuration name. The value does not need to be unique.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>A complex type that contains information about where recorded video will be stored.</p>
    pub fn destination_configuration(
        &self,
    ) -> std::option::Option<&crate::model::DestinationConfiguration> {
        self.destination_configuration.as_ref()
    }
    /// <p>Indicates the current state of the recording configuration. When the state is
    /// <code>ACTIVE</code>, the configuration is ready for recording a channel stream.</p>
    pub fn state(&self) -> std::option::Option<&crate::model::RecordingConfigurationState> {
        self.state.as_ref()
    }
    /// <p>Array of 1-50 maps, each of the form <code>string:string (key:value)</code>.</p>
    pub fn tags(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.tags.as_ref()
    }
}
impl std::fmt::Debug for RecordingConfigurationSummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("RecordingConfigurationSummary");
        formatter.field("arn", &self.arn);
        formatter.field("name", &self.name);
        formatter.field("destination_configuration", &self.destination_configuration);
        formatter.field("state", &self.state);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}
/// See [`RecordingConfigurationSummary`](crate::model::RecordingConfigurationSummary)
pub mod recording_configuration_summary {
    /// A builder for [`RecordingConfigurationSummary`](crate::model::RecordingConfigurationSummary)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) destination_configuration:
            std::option::Option<crate::model::DestinationConfiguration>,
        pub(crate) state: std::option::Option<crate::model::RecordingConfigurationState>,
        pub(crate) tags: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
    }
    impl Builder {
        /// <p>Recording-configuration ARN.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>Recording-configuration ARN.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>Recording-configuration name. The value does not need to be unique.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>Recording-configuration name. The value does not need to be unique.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>A complex type that contains information about where recorded video will be stored.</p>
        pub fn destination_configuration(
            mut self,
            input: crate::model::DestinationConfiguration,
        ) -> Self {
            self.destination_configuration = Some(input);
            self
        }
        /// <p>A complex type that contains information about where recorded video will be stored.</p>
        pub fn set_destination_configuration(
            mut self,
            input: std::option::Option<crate::model::DestinationConfiguration>,
        ) -> Self {
            self.destination_configuration = input;
            self
        }
        /// <p>Indicates the current state of the recording configuration. When the state is
        /// <code>ACTIVE</code>, the configuration is ready for recording a channel stream.</p>
        pub fn state(mut self, input: crate::model::RecordingConfigurationState) -> Self {
            self.state = Some(input);
            self
        }
        /// <p>Indicates the current state of the recording configuration. When the state is
        /// <code>ACTIVE</code>, the configuration is ready for recording a channel stream.</p>
        pub fn set_state(
            mut self,
            input: std::option::Option<crate::model::RecordingConfigurationState>,
        ) -> Self {
            self.state = input;
            self
        }
        /// Adds a key-value pair to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>Array of 1-50 maps, each of the form <code>string:string (key:value)</code>.</p>
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.tags.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.tags = Some(hash_map);
            self
        }
        /// <p>Array of 1-50 maps, each of the form <code>string:string (key:value)</code>.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`RecordingConfigurationSummary`](crate::model::RecordingConfigurationSummary)
        pub fn build(self) -> crate::model::RecordingConfigurationSummary {
            crate::model::RecordingConfigurationSummary {
                arn: self.arn,
                name: self.name,
                destination_configuration: self.destination_configuration,
                state: self.state,
                tags: self.tags,
            }
        }
    }
}
impl RecordingConfigurationSummary {
    /// Creates a new builder-style object to manufacture [`RecordingConfigurationSummary`](crate::model::RecordingConfigurationSummary)
    pub fn builder() -> crate::model::recording_configuration_summary::Builder {
        crate::model::recording_configuration_summary::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum RecordingConfigurationState {
    #[allow(missing_docs)] // documentation missing in model
    Active,
    #[allow(missing_docs)] // documentation missing in model
    CreateFailed,
    #[allow(missing_docs)] // documentation missing in model
    Creating,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for RecordingConfigurationState {
    fn from(s: &str) -> Self {
        match s {
            "ACTIVE" => RecordingConfigurationState::Active,
            "CREATE_FAILED" => RecordingConfigurationState::CreateFailed,
            "CREATING" => RecordingConfigurationState::Creating,
            other => RecordingConfigurationState::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for RecordingConfigurationState {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(RecordingConfigurationState::from(s))
    }
}
impl RecordingConfigurationState {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            RecordingConfigurationState::Active => "ACTIVE",
            RecordingConfigurationState::CreateFailed => "CREATE_FAILED",
            RecordingConfigurationState::Creating => "CREATING",
            RecordingConfigurationState::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["ACTIVE", "CREATE_FAILED", "CREATING"]
    }
}
impl AsRef<str> for RecordingConfigurationState {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>A complex type that describes a location where recorded videos will be stored. Each member
/// represents a type of destination configuration. For recording, you define one and only one
/// type of destination configuration.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DestinationConfiguration {
    /// <p>An S3 destination configuration where recorded videos will be stored.</p>
    pub s3: std::option::Option<crate::model::S3DestinationConfiguration>,
}
impl DestinationConfiguration {
    /// <p>An S3 destination configuration where recorded videos will be stored.</p>
    pub fn s3(&self) -> std::option::Option<&crate::model::S3DestinationConfiguration> {
        self.s3.as_ref()
    }
}
impl std::fmt::Debug for DestinationConfiguration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DestinationConfiguration");
        formatter.field("s3", &self.s3);
        formatter.finish()
    }
}
/// See [`DestinationConfiguration`](crate::model::DestinationConfiguration)
pub mod destination_configuration {
    /// A builder for [`DestinationConfiguration`](crate::model::DestinationConfiguration)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) s3: std::option::Option<crate::model::S3DestinationConfiguration>,
    }
    impl Builder {
        /// <p>An S3 destination configuration where recorded videos will be stored.</p>
        pub fn s3(mut self, input: crate::model::S3DestinationConfiguration) -> Self {
            self.s3 = Some(input);
            self
        }
        /// <p>An S3 destination configuration where recorded videos will be stored.</p>
        pub fn set_s3(
            mut self,
            input: std::option::Option<crate::model::S3DestinationConfiguration>,
        ) -> Self {
            self.s3 = input;
            self
        }
        /// Consumes the builder and constructs a [`DestinationConfiguration`](crate::model::DestinationConfiguration)
        pub fn build(self) -> crate::model::DestinationConfiguration {
            crate::model::DestinationConfiguration { s3: self.s3 }
        }
    }
}
impl DestinationConfiguration {
    /// Creates a new builder-style object to manufacture [`DestinationConfiguration`](crate::model::DestinationConfiguration)
    pub fn builder() -> crate::model::destination_configuration::Builder {
        crate::model::destination_configuration::Builder::default()
    }
}

/// <p>A complex type that describes an S3 location where recorded videos will be stored.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct S3DestinationConfiguration {
    /// <p>Location (S3 bucket name) where recorded videos will be stored.</p>
    pub bucket_name: std::option::Option<std::string::String>,
}
impl S3DestinationConfiguration {
    /// <p>Location (S3 bucket name) where recorded videos will be stored.</p>
    pub fn bucket_name(&self) -> std::option::Option<&str> {
        self.bucket_name.as_deref()
    }
}
impl std::fmt::Debug for S3DestinationConfiguration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("S3DestinationConfiguration");
        formatter.field("bucket_name", &self.bucket_name);
        formatter.finish()
    }
}
/// See [`S3DestinationConfiguration`](crate::model::S3DestinationConfiguration)
pub mod s3_destination_configuration {
    /// A builder for [`S3DestinationConfiguration`](crate::model::S3DestinationConfiguration)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) bucket_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Location (S3 bucket name) where recorded videos will be stored.</p>
        pub fn bucket_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.bucket_name = Some(input.into());
            self
        }
        /// <p>Location (S3 bucket name) where recorded videos will be stored.</p>
        pub fn set_bucket_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.bucket_name = input;
            self
        }
        /// Consumes the builder and constructs a [`S3DestinationConfiguration`](crate::model::S3DestinationConfiguration)
        pub fn build(self) -> crate::model::S3DestinationConfiguration {
            crate::model::S3DestinationConfiguration {
                bucket_name: self.bucket_name,
            }
        }
    }
}
impl S3DestinationConfiguration {
    /// Creates a new builder-style object to manufacture [`S3DestinationConfiguration`](crate::model::S3DestinationConfiguration)
    pub fn builder() -> crate::model::s3_destination_configuration::Builder {
        crate::model::s3_destination_configuration::Builder::default()
    }
}

/// <p>Summary information about a playback key pair.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PlaybackKeyPairSummary {
    /// <p>Key-pair ARN.</p>
    pub arn: std::option::Option<std::string::String>,
    /// <p>Playback-key-pair name. The value does not need to be unique.</p>
    pub name: std::option::Option<std::string::String>,
    /// <p>Array of 1-50 maps, each of the form <code>string:string (key:value)</code>.</p>
    pub tags:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
}
impl PlaybackKeyPairSummary {
    /// <p>Key-pair ARN.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>Playback-key-pair name. The value does not need to be unique.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>Array of 1-50 maps, each of the form <code>string:string (key:value)</code>.</p>
    pub fn tags(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.tags.as_ref()
    }
}
impl std::fmt::Debug for PlaybackKeyPairSummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PlaybackKeyPairSummary");
        formatter.field("arn", &self.arn);
        formatter.field("name", &self.name);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}
/// See [`PlaybackKeyPairSummary`](crate::model::PlaybackKeyPairSummary)
pub mod playback_key_pair_summary {
    /// A builder for [`PlaybackKeyPairSummary`](crate::model::PlaybackKeyPairSummary)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
    }
    impl Builder {
        /// <p>Key-pair ARN.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>Key-pair ARN.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>Playback-key-pair name. The value does not need to be unique.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>Playback-key-pair name. The value does not need to be unique.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// Adds a key-value pair to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>Array of 1-50 maps, each of the form <code>string:string (key:value)</code>.</p>
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.tags.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.tags = Some(hash_map);
            self
        }
        /// <p>Array of 1-50 maps, each of the form <code>string:string (key:value)</code>.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`PlaybackKeyPairSummary`](crate::model::PlaybackKeyPairSummary)
        pub fn build(self) -> crate::model::PlaybackKeyPairSummary {
            crate::model::PlaybackKeyPairSummary {
                arn: self.arn,
                name: self.name,
                tags: self.tags,
            }
        }
    }
}
impl PlaybackKeyPairSummary {
    /// Creates a new builder-style object to manufacture [`PlaybackKeyPairSummary`](crate::model::PlaybackKeyPairSummary)
    pub fn builder() -> crate::model::playback_key_pair_summary::Builder {
        crate::model::playback_key_pair_summary::Builder::default()
    }
}

/// <p>Summary information about a channel.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ChannelSummary {
    /// <p>Channel ARN.</p>
    pub arn: std::option::Option<std::string::String>,
    /// <p>Channel name.</p>
    pub name: std::option::Option<std::string::String>,
    /// <p>Channel latency mode. Use <code>NORMAL</code> to broadcast and deliver live video up to
    /// Full HD. Use <code>LOW</code> for near-real-time interaction with viewers. Default:
    /// <code>LOW</code>. (Note: In the Amazon IVS console, <code>LOW</code> and <code>NORMAL</code>
    /// correspond to Ultra-low and Standard, respectively.)</p>
    pub latency_mode: std::option::Option<crate::model::ChannelLatencyMode>,
    /// <p>Whether the channel is private (enabled for playback authorization). Default:
    /// <code>false</code>.</p>
    pub authorized: bool,
    /// <p>Recording-configuration ARN. A value other than an empty string indicates that recording
    /// is enabled. Default: "" (empty string, recording is disabled).</p>
    pub recording_configuration_arn: std::option::Option<std::string::String>,
    /// <p>Array of 1-50 maps, each of the form <code>string:string (key:value)</code>.</p>
    pub tags:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
}
impl ChannelSummary {
    /// <p>Channel ARN.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>Channel name.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>Channel latency mode. Use <code>NORMAL</code> to broadcast and deliver live video up to
    /// Full HD. Use <code>LOW</code> for near-real-time interaction with viewers. Default:
    /// <code>LOW</code>. (Note: In the Amazon IVS console, <code>LOW</code> and <code>NORMAL</code>
    /// correspond to Ultra-low and Standard, respectively.)</p>
    pub fn latency_mode(&self) -> std::option::Option<&crate::model::ChannelLatencyMode> {
        self.latency_mode.as_ref()
    }
    /// <p>Whether the channel is private (enabled for playback authorization). Default:
    /// <code>false</code>.</p>
    pub fn authorized(&self) -> bool {
        self.authorized
    }
    /// <p>Recording-configuration ARN. A value other than an empty string indicates that recording
    /// is enabled. Default: "" (empty string, recording is disabled).</p>
    pub fn recording_configuration_arn(&self) -> std::option::Option<&str> {
        self.recording_configuration_arn.as_deref()
    }
    /// <p>Array of 1-50 maps, each of the form <code>string:string (key:value)</code>.</p>
    pub fn tags(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.tags.as_ref()
    }
}
impl std::fmt::Debug for ChannelSummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ChannelSummary");
        formatter.field("arn", &self.arn);
        formatter.field("name", &self.name);
        formatter.field("latency_mode", &self.latency_mode);
        formatter.field("authorized", &self.authorized);
        formatter.field(
            "recording_configuration_arn",
            &self.recording_configuration_arn,
        );
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}
/// See [`ChannelSummary`](crate::model::ChannelSummary)
pub mod channel_summary {
    /// A builder for [`ChannelSummary`](crate::model::ChannelSummary)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) latency_mode: std::option::Option<crate::model::ChannelLatencyMode>,
        pub(crate) authorized: std::option::Option<bool>,
        pub(crate) recording_configuration_arn: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
    }
    impl Builder {
        /// <p>Channel ARN.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>Channel ARN.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>Channel name.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>Channel name.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>Channel latency mode. Use <code>NORMAL</code> to broadcast and deliver live video up to
        /// Full HD. Use <code>LOW</code> for near-real-time interaction with viewers. Default:
        /// <code>LOW</code>. (Note: In the Amazon IVS console, <code>LOW</code> and <code>NORMAL</code>
        /// correspond to Ultra-low and Standard, respectively.)</p>
        pub fn latency_mode(mut self, input: crate::model::ChannelLatencyMode) -> Self {
            self.latency_mode = Some(input);
            self
        }
        /// <p>Channel latency mode. Use <code>NORMAL</code> to broadcast and deliver live video up to
        /// Full HD. Use <code>LOW</code> for near-real-time interaction with viewers. Default:
        /// <code>LOW</code>. (Note: In the Amazon IVS console, <code>LOW</code> and <code>NORMAL</code>
        /// correspond to Ultra-low and Standard, respectively.)</p>
        pub fn set_latency_mode(
            mut self,
            input: std::option::Option<crate::model::ChannelLatencyMode>,
        ) -> Self {
            self.latency_mode = input;
            self
        }
        /// <p>Whether the channel is private (enabled for playback authorization). Default:
        /// <code>false</code>.</p>
        pub fn authorized(mut self, input: bool) -> Self {
            self.authorized = Some(input);
            self
        }
        /// <p>Whether the channel is private (enabled for playback authorization). Default:
        /// <code>false</code>.</p>
        pub fn set_authorized(mut self, input: std::option::Option<bool>) -> Self {
            self.authorized = input;
            self
        }
        /// <p>Recording-configuration ARN. A value other than an empty string indicates that recording
        /// is enabled. Default: "" (empty string, recording is disabled).</p>
        pub fn recording_configuration_arn(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.recording_configuration_arn = Some(input.into());
            self
        }
        /// <p>Recording-configuration ARN. A value other than an empty string indicates that recording
        /// is enabled. Default: "" (empty string, recording is disabled).</p>
        pub fn set_recording_configuration_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.recording_configuration_arn = input;
            self
        }
        /// Adds a key-value pair to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>Array of 1-50 maps, each of the form <code>string:string (key:value)</code>.</p>
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.tags.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.tags = Some(hash_map);
            self
        }
        /// <p>Array of 1-50 maps, each of the form <code>string:string (key:value)</code>.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`ChannelSummary`](crate::model::ChannelSummary)
        pub fn build(self) -> crate::model::ChannelSummary {
            crate::model::ChannelSummary {
                arn: self.arn,
                name: self.name,
                latency_mode: self.latency_mode,
                authorized: self.authorized.unwrap_or_default(),
                recording_configuration_arn: self.recording_configuration_arn,
                tags: self.tags,
            }
        }
    }
}
impl ChannelSummary {
    /// Creates a new builder-style object to manufacture [`ChannelSummary`](crate::model::ChannelSummary)
    pub fn builder() -> crate::model::channel_summary::Builder {
        crate::model::channel_summary::Builder::default()
    }
}

/// <p>A key pair used to sign and validate a playback authorization token.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PlaybackKeyPair {
    /// <p>Key-pair ARN.</p>
    pub arn: std::option::Option<std::string::String>,
    /// <p>Playback-key-pair name. The value does not need to be unique.</p>
    pub name: std::option::Option<std::string::String>,
    /// <p>Key-pair identifier.</p>
    pub fingerprint: std::option::Option<std::string::String>,
    /// <p>Array of 1-50 maps, each of the form <code>string:string (key:value)</code>.</p>
    pub tags:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
}
impl PlaybackKeyPair {
    /// <p>Key-pair ARN.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>Playback-key-pair name. The value does not need to be unique.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>Key-pair identifier.</p>
    pub fn fingerprint(&self) -> std::option::Option<&str> {
        self.fingerprint.as_deref()
    }
    /// <p>Array of 1-50 maps, each of the form <code>string:string (key:value)</code>.</p>
    pub fn tags(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.tags.as_ref()
    }
}
impl std::fmt::Debug for PlaybackKeyPair {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PlaybackKeyPair");
        formatter.field("arn", &self.arn);
        formatter.field("name", &self.name);
        formatter.field("fingerprint", &self.fingerprint);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}
/// See [`PlaybackKeyPair`](crate::model::PlaybackKeyPair)
pub mod playback_key_pair {
    /// A builder for [`PlaybackKeyPair`](crate::model::PlaybackKeyPair)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) fingerprint: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
    }
    impl Builder {
        /// <p>Key-pair ARN.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>Key-pair ARN.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>Playback-key-pair name. The value does not need to be unique.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>Playback-key-pair name. The value does not need to be unique.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>Key-pair identifier.</p>
        pub fn fingerprint(mut self, input: impl Into<std::string::String>) -> Self {
            self.fingerprint = Some(input.into());
            self
        }
        /// <p>Key-pair identifier.</p>
        pub fn set_fingerprint(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.fingerprint = input;
            self
        }
        /// Adds a key-value pair to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>Array of 1-50 maps, each of the form <code>string:string (key:value)</code>.</p>
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.tags.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.tags = Some(hash_map);
            self
        }
        /// <p>Array of 1-50 maps, each of the form <code>string:string (key:value)</code>.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`PlaybackKeyPair`](crate::model::PlaybackKeyPair)
        pub fn build(self) -> crate::model::PlaybackKeyPair {
            crate::model::PlaybackKeyPair {
                arn: self.arn,
                name: self.name,
                fingerprint: self.fingerprint,
                tags: self.tags,
            }
        }
    }
}
impl PlaybackKeyPair {
    /// Creates a new builder-style object to manufacture [`PlaybackKeyPair`](crate::model::PlaybackKeyPair)
    pub fn builder() -> crate::model::playback_key_pair::Builder {
        crate::model::playback_key_pair::Builder::default()
    }
}

/// <p>Object that captures the Amazon IVS configuration that the customer provisioned, the
/// ingest configurations that the broadcaster used, and the most recent Amazon IVS stream events
/// it encountered.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct StreamSession {
    /// <p>Unique identifier for a live or previously live stream in the specified channel.</p>
    pub stream_id: std::option::Option<std::string::String>,
    /// <p>UTC ISO-8601 formatted timestamp of when the channel went live.</p>
    pub start_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>UTC ISO-8601 formatted timestamp of when the channel went offline. For live streams, this
    /// is <code>NULL</code>.</p>
    pub end_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The properties of the channel at the time of going live.</p>
    pub channel: std::option::Option<crate::model::Channel>,
    /// <p>The properties of the incoming RTMP stream for the stream.</p>
    pub ingest_configuration: std::option::Option<crate::model::IngestConfiguration>,
    /// <p>The properties of recording the live stream.</p>
    pub recording_configuration: std::option::Option<crate::model::RecordingConfiguration>,
    /// <p>List of Amazon IVS events that the stream encountered. The list is sorted by most recent
    /// events and contains up to 500 events. For Amazon IVS events, see <a href="https://docs.aws.amazon.com/ivs/latest/userguide/eventbridge.html">Using Amazon EventBridge with Amazon
    /// IVS</a>.</p>
    pub truncated_events: std::option::Option<std::vec::Vec<crate::model::StreamEvent>>,
}
impl StreamSession {
    /// <p>Unique identifier for a live or previously live stream in the specified channel.</p>
    pub fn stream_id(&self) -> std::option::Option<&str> {
        self.stream_id.as_deref()
    }
    /// <p>UTC ISO-8601 formatted timestamp of when the channel went live.</p>
    pub fn start_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.start_time.as_ref()
    }
    /// <p>UTC ISO-8601 formatted timestamp of when the channel went offline. For live streams, this
    /// is <code>NULL</code>.</p>
    pub fn end_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.end_time.as_ref()
    }
    /// <p>The properties of the channel at the time of going live.</p>
    pub fn channel(&self) -> std::option::Option<&crate::model::Channel> {
        self.channel.as_ref()
    }
    /// <p>The properties of the incoming RTMP stream for the stream.</p>
    pub fn ingest_configuration(&self) -> std::option::Option<&crate::model::IngestConfiguration> {
        self.ingest_configuration.as_ref()
    }
    /// <p>The properties of recording the live stream.</p>
    pub fn recording_configuration(
        &self,
    ) -> std::option::Option<&crate::model::RecordingConfiguration> {
        self.recording_configuration.as_ref()
    }
    /// <p>List of Amazon IVS events that the stream encountered. The list is sorted by most recent
    /// events and contains up to 500 events. For Amazon IVS events, see <a href="https://docs.aws.amazon.com/ivs/latest/userguide/eventbridge.html">Using Amazon EventBridge with Amazon
    /// IVS</a>.</p>
    pub fn truncated_events(&self) -> std::option::Option<&[crate::model::StreamEvent]> {
        self.truncated_events.as_deref()
    }
}
impl std::fmt::Debug for StreamSession {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("StreamSession");
        formatter.field("stream_id", &self.stream_id);
        formatter.field("start_time", &self.start_time);
        formatter.field("end_time", &self.end_time);
        formatter.field("channel", &self.channel);
        formatter.field("ingest_configuration", &self.ingest_configuration);
        formatter.field("recording_configuration", &self.recording_configuration);
        formatter.field("truncated_events", &self.truncated_events);
        formatter.finish()
    }
}
/// See [`StreamSession`](crate::model::StreamSession)
pub mod stream_session {
    /// A builder for [`StreamSession`](crate::model::StreamSession)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) stream_id: std::option::Option<std::string::String>,
        pub(crate) start_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) end_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) channel: std::option::Option<crate::model::Channel>,
        pub(crate) ingest_configuration: std::option::Option<crate::model::IngestConfiguration>,
        pub(crate) recording_configuration:
            std::option::Option<crate::model::RecordingConfiguration>,
        pub(crate) truncated_events: std::option::Option<std::vec::Vec<crate::model::StreamEvent>>,
    }
    impl Builder {
        /// <p>Unique identifier for a live or previously live stream in the specified channel.</p>
        pub fn stream_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.stream_id = Some(input.into());
            self
        }
        /// <p>Unique identifier for a live or previously live stream in the specified channel.</p>
        pub fn set_stream_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.stream_id = input;
            self
        }
        /// <p>UTC ISO-8601 formatted timestamp of when the channel went live.</p>
        pub fn start_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.start_time = Some(input);
            self
        }
        /// <p>UTC ISO-8601 formatted timestamp of when the channel went live.</p>
        pub fn set_start_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.start_time = input;
            self
        }
        /// <p>UTC ISO-8601 formatted timestamp of when the channel went offline. For live streams, this
        /// is <code>NULL</code>.</p>
        pub fn end_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.end_time = Some(input);
            self
        }
        /// <p>UTC ISO-8601 formatted timestamp of when the channel went offline. For live streams, this
        /// is <code>NULL</code>.</p>
        pub fn set_end_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.end_time = input;
            self
        }
        /// <p>The properties of the channel at the time of going live.</p>
        pub fn channel(mut self, input: crate::model::Channel) -> Self {
            self.channel = Some(input);
            self
        }
        /// <p>The properties of the channel at the time of going live.</p>
        pub fn set_channel(mut self, input: std::option::Option<crate::model::Channel>) -> Self {
            self.channel = input;
            self
        }
        /// <p>The properties of the incoming RTMP stream for the stream.</p>
        pub fn ingest_configuration(mut self, input: crate::model::IngestConfiguration) -> Self {
            self.ingest_configuration = Some(input);
            self
        }
        /// <p>The properties of the incoming RTMP stream for the stream.</p>
        pub fn set_ingest_configuration(
            mut self,
            input: std::option::Option<crate::model::IngestConfiguration>,
        ) -> Self {
            self.ingest_configuration = input;
            self
        }
        /// <p>The properties of recording the live stream.</p>
        pub fn recording_configuration(
            mut self,
            input: crate::model::RecordingConfiguration,
        ) -> Self {
            self.recording_configuration = Some(input);
            self
        }
        /// <p>The properties of recording the live stream.</p>
        pub fn set_recording_configuration(
            mut self,
            input: std::option::Option<crate::model::RecordingConfiguration>,
        ) -> Self {
            self.recording_configuration = input;
            self
        }
        /// Appends an item to `truncated_events`.
        ///
        /// To override the contents of this collection use [`set_truncated_events`](Self::set_truncated_events).
        ///
        /// <p>List of Amazon IVS events that the stream encountered. The list is sorted by most recent
        /// events and contains up to 500 events. For Amazon IVS events, see <a href="https://docs.aws.amazon.com/ivs/latest/userguide/eventbridge.html">Using Amazon EventBridge with Amazon
        /// IVS</a>.</p>
        pub fn truncated_events(mut self, input: impl Into<crate::model::StreamEvent>) -> Self {
            let mut v = self.truncated_events.unwrap_or_default();
            v.push(input.into());
            self.truncated_events = Some(v);
            self
        }
        /// <p>List of Amazon IVS events that the stream encountered. The list is sorted by most recent
        /// events and contains up to 500 events. For Amazon IVS events, see <a href="https://docs.aws.amazon.com/ivs/latest/userguide/eventbridge.html">Using Amazon EventBridge with Amazon
        /// IVS</a>.</p>
        pub fn set_truncated_events(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::StreamEvent>>,
        ) -> Self {
            self.truncated_events = input;
            self
        }
        /// Consumes the builder and constructs a [`StreamSession`](crate::model::StreamSession)
        pub fn build(self) -> crate::model::StreamSession {
            crate::model::StreamSession {
                stream_id: self.stream_id,
                start_time: self.start_time,
                end_time: self.end_time,
                channel: self.channel,
                ingest_configuration: self.ingest_configuration,
                recording_configuration: self.recording_configuration,
                truncated_events: self.truncated_events,
            }
        }
    }
}
impl StreamSession {
    /// Creates a new builder-style object to manufacture [`StreamSession`](crate::model::StreamSession)
    pub fn builder() -> crate::model::stream_session::Builder {
        crate::model::stream_session::Builder::default()
    }
}

/// <p>Object specifying a stream’s events. For a list of events, see <a href="https://docs.aws.amazon.com/ivs/latest/userguide/eventbridge.html">Using Amazon EventBridge with Amazon
/// IVS</a>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct StreamEvent {
    /// <p>Name that identifies the stream event within a <code>type</code>.</p>
    pub name: std::option::Option<std::string::String>,
    /// <p>Logical group for certain events.</p>
    pub r#type: std::option::Option<std::string::String>,
    /// <p>UTC ISO-8601 formatted timestamp of when the event occurred.</p>
    pub event_time: std::option::Option<aws_smithy_types::DateTime>,
}
impl StreamEvent {
    /// <p>Name that identifies the stream event within a <code>type</code>.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>Logical group for certain events.</p>
    pub fn r#type(&self) -> std::option::Option<&str> {
        self.r#type.as_deref()
    }
    /// <p>UTC ISO-8601 formatted timestamp of when the event occurred.</p>
    pub fn event_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.event_time.as_ref()
    }
}
impl std::fmt::Debug for StreamEvent {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("StreamEvent");
        formatter.field("name", &self.name);
        formatter.field("r#type", &self.r#type);
        formatter.field("event_time", &self.event_time);
        formatter.finish()
    }
}
/// See [`StreamEvent`](crate::model::StreamEvent)
pub mod stream_event {
    /// A builder for [`StreamEvent`](crate::model::StreamEvent)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) r#type: std::option::Option<std::string::String>,
        pub(crate) event_time: std::option::Option<aws_smithy_types::DateTime>,
    }
    impl Builder {
        /// <p>Name that identifies the stream event within a <code>type</code>.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>Name that identifies the stream event within a <code>type</code>.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>Logical group for certain events.</p>
        pub fn r#type(mut self, input: impl Into<std::string::String>) -> Self {
            self.r#type = Some(input.into());
            self
        }
        /// <p>Logical group for certain events.</p>
        pub fn set_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.r#type = input;
            self
        }
        /// <p>UTC ISO-8601 formatted timestamp of when the event occurred.</p>
        pub fn event_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.event_time = Some(input);
            self
        }
        /// <p>UTC ISO-8601 formatted timestamp of when the event occurred.</p>
        pub fn set_event_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.event_time = input;
            self
        }
        /// Consumes the builder and constructs a [`StreamEvent`](crate::model::StreamEvent)
        pub fn build(self) -> crate::model::StreamEvent {
            crate::model::StreamEvent {
                name: self.name,
                r#type: self.r#type,
                event_time: self.event_time,
            }
        }
    }
}
impl StreamEvent {
    /// Creates a new builder-style object to manufacture [`StreamEvent`](crate::model::StreamEvent)
    pub fn builder() -> crate::model::stream_event::Builder {
        crate::model::stream_event::Builder::default()
    }
}

/// <p>An object representing a configuration to record a channel stream.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct RecordingConfiguration {
    /// <p>Recording-configuration ARN.</p>
    pub arn: std::option::Option<std::string::String>,
    /// <p>Recording-configuration name. The value does not need to be unique.</p>
    pub name: std::option::Option<std::string::String>,
    /// <p>A complex type that contains information about where recorded video will be stored.</p>
    pub destination_configuration: std::option::Option<crate::model::DestinationConfiguration>,
    /// <p>Indicates the current state of the recording configuration. When the state is
    /// <code>ACTIVE</code>, the configuration is ready for recording a channel stream.</p>
    pub state: std::option::Option<crate::model::RecordingConfigurationState>,
    /// <p>Array of 1-50 maps, each of the form <code>string:string (key:value)</code>.</p>
    pub tags:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
}
impl RecordingConfiguration {
    /// <p>Recording-configuration ARN.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>Recording-configuration name. The value does not need to be unique.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>A complex type that contains information about where recorded video will be stored.</p>
    pub fn destination_configuration(
        &self,
    ) -> std::option::Option<&crate::model::DestinationConfiguration> {
        self.destination_configuration.as_ref()
    }
    /// <p>Indicates the current state of the recording configuration. When the state is
    /// <code>ACTIVE</code>, the configuration is ready for recording a channel stream.</p>
    pub fn state(&self) -> std::option::Option<&crate::model::RecordingConfigurationState> {
        self.state.as_ref()
    }
    /// <p>Array of 1-50 maps, each of the form <code>string:string (key:value)</code>.</p>
    pub fn tags(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.tags.as_ref()
    }
}
impl std::fmt::Debug for RecordingConfiguration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("RecordingConfiguration");
        formatter.field("arn", &self.arn);
        formatter.field("name", &self.name);
        formatter.field("destination_configuration", &self.destination_configuration);
        formatter.field("state", &self.state);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}
/// See [`RecordingConfiguration`](crate::model::RecordingConfiguration)
pub mod recording_configuration {
    /// A builder for [`RecordingConfiguration`](crate::model::RecordingConfiguration)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) destination_configuration:
            std::option::Option<crate::model::DestinationConfiguration>,
        pub(crate) state: std::option::Option<crate::model::RecordingConfigurationState>,
        pub(crate) tags: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
    }
    impl Builder {
        /// <p>Recording-configuration ARN.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>Recording-configuration ARN.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>Recording-configuration name. The value does not need to be unique.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>Recording-configuration name. The value does not need to be unique.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>A complex type that contains information about where recorded video will be stored.</p>
        pub fn destination_configuration(
            mut self,
            input: crate::model::DestinationConfiguration,
        ) -> Self {
            self.destination_configuration = Some(input);
            self
        }
        /// <p>A complex type that contains information about where recorded video will be stored.</p>
        pub fn set_destination_configuration(
            mut self,
            input: std::option::Option<crate::model::DestinationConfiguration>,
        ) -> Self {
            self.destination_configuration = input;
            self
        }
        /// <p>Indicates the current state of the recording configuration. When the state is
        /// <code>ACTIVE</code>, the configuration is ready for recording a channel stream.</p>
        pub fn state(mut self, input: crate::model::RecordingConfigurationState) -> Self {
            self.state = Some(input);
            self
        }
        /// <p>Indicates the current state of the recording configuration. When the state is
        /// <code>ACTIVE</code>, the configuration is ready for recording a channel stream.</p>
        pub fn set_state(
            mut self,
            input: std::option::Option<crate::model::RecordingConfigurationState>,
        ) -> Self {
            self.state = input;
            self
        }
        /// Adds a key-value pair to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>Array of 1-50 maps, each of the form <code>string:string (key:value)</code>.</p>
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.tags.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.tags = Some(hash_map);
            self
        }
        /// <p>Array of 1-50 maps, each of the form <code>string:string (key:value)</code>.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`RecordingConfiguration`](crate::model::RecordingConfiguration)
        pub fn build(self) -> crate::model::RecordingConfiguration {
            crate::model::RecordingConfiguration {
                arn: self.arn,
                name: self.name,
                destination_configuration: self.destination_configuration,
                state: self.state,
                tags: self.tags,
            }
        }
    }
}
impl RecordingConfiguration {
    /// Creates a new builder-style object to manufacture [`RecordingConfiguration`](crate::model::RecordingConfiguration)
    pub fn builder() -> crate::model::recording_configuration::Builder {
        crate::model::recording_configuration::Builder::default()
    }
}

/// <p>Object specifying the ingest configuration set up by the broadcaster, usually in an
/// encoder.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct IngestConfiguration {
    /// <p>Encoder settings for video.</p>
    pub video: std::option::Option<crate::model::VideoConfiguration>,
    /// <p>Encoder settings for audio.</p>
    pub audio: std::option::Option<crate::model::AudioConfiguration>,
}
impl IngestConfiguration {
    /// <p>Encoder settings for video.</p>
    pub fn video(&self) -> std::option::Option<&crate::model::VideoConfiguration> {
        self.video.as_ref()
    }
    /// <p>Encoder settings for audio.</p>
    pub fn audio(&self) -> std::option::Option<&crate::model::AudioConfiguration> {
        self.audio.as_ref()
    }
}
impl std::fmt::Debug for IngestConfiguration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("IngestConfiguration");
        formatter.field("video", &self.video);
        formatter.field("audio", &self.audio);
        formatter.finish()
    }
}
/// See [`IngestConfiguration`](crate::model::IngestConfiguration)
pub mod ingest_configuration {
    /// A builder for [`IngestConfiguration`](crate::model::IngestConfiguration)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) video: std::option::Option<crate::model::VideoConfiguration>,
        pub(crate) audio: std::option::Option<crate::model::AudioConfiguration>,
    }
    impl Builder {
        /// <p>Encoder settings for video.</p>
        pub fn video(mut self, input: crate::model::VideoConfiguration) -> Self {
            self.video = Some(input);
            self
        }
        /// <p>Encoder settings for video.</p>
        pub fn set_video(
            mut self,
            input: std::option::Option<crate::model::VideoConfiguration>,
        ) -> Self {
            self.video = input;
            self
        }
        /// <p>Encoder settings for audio.</p>
        pub fn audio(mut self, input: crate::model::AudioConfiguration) -> Self {
            self.audio = Some(input);
            self
        }
        /// <p>Encoder settings for audio.</p>
        pub fn set_audio(
            mut self,
            input: std::option::Option<crate::model::AudioConfiguration>,
        ) -> Self {
            self.audio = input;
            self
        }
        /// Consumes the builder and constructs a [`IngestConfiguration`](crate::model::IngestConfiguration)
        pub fn build(self) -> crate::model::IngestConfiguration {
            crate::model::IngestConfiguration {
                video: self.video,
                audio: self.audio,
            }
        }
    }
}
impl IngestConfiguration {
    /// Creates a new builder-style object to manufacture [`IngestConfiguration`](crate::model::IngestConfiguration)
    pub fn builder() -> crate::model::ingest_configuration::Builder {
        crate::model::ingest_configuration::Builder::default()
    }
}

/// <p>Object specifying a stream’s audio configuration.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AudioConfiguration {
    /// <p>Codec used for the audio encoding.</p>
    pub codec: std::option::Option<std::string::String>,
    /// <p>The expected ingest bitrate (bits per second). This is configured in the encoder.</p>
    pub target_bitrate: i64,
    /// <p>Number of audio samples recorded per second.</p>
    pub sample_rate: i64,
    /// <p>Number of audio channels.</p>
    pub channels: i64,
}
impl AudioConfiguration {
    /// <p>Codec used for the audio encoding.</p>
    pub fn codec(&self) -> std::option::Option<&str> {
        self.codec.as_deref()
    }
    /// <p>The expected ingest bitrate (bits per second). This is configured in the encoder.</p>
    pub fn target_bitrate(&self) -> i64 {
        self.target_bitrate
    }
    /// <p>Number of audio samples recorded per second.</p>
    pub fn sample_rate(&self) -> i64 {
        self.sample_rate
    }
    /// <p>Number of audio channels.</p>
    pub fn channels(&self) -> i64 {
        self.channels
    }
}
impl std::fmt::Debug for AudioConfiguration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AudioConfiguration");
        formatter.field("codec", &self.codec);
        formatter.field("target_bitrate", &self.target_bitrate);
        formatter.field("sample_rate", &self.sample_rate);
        formatter.field("channels", &self.channels);
        formatter.finish()
    }
}
/// See [`AudioConfiguration`](crate::model::AudioConfiguration)
pub mod audio_configuration {
    /// A builder for [`AudioConfiguration`](crate::model::AudioConfiguration)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) codec: std::option::Option<std::string::String>,
        pub(crate) target_bitrate: std::option::Option<i64>,
        pub(crate) sample_rate: std::option::Option<i64>,
        pub(crate) channels: std::option::Option<i64>,
    }
    impl Builder {
        /// <p>Codec used for the audio encoding.</p>
        pub fn codec(mut self, input: impl Into<std::string::String>) -> Self {
            self.codec = Some(input.into());
            self
        }
        /// <p>Codec used for the audio encoding.</p>
        pub fn set_codec(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.codec = input;
            self
        }
        /// <p>The expected ingest bitrate (bits per second). This is configured in the encoder.</p>
        pub fn target_bitrate(mut self, input: i64) -> Self {
            self.target_bitrate = Some(input);
            self
        }
        /// <p>The expected ingest bitrate (bits per second). This is configured in the encoder.</p>
        pub fn set_target_bitrate(mut self, input: std::option::Option<i64>) -> Self {
            self.target_bitrate = input;
            self
        }
        /// <p>Number of audio samples recorded per second.</p>
        pub fn sample_rate(mut self, input: i64) -> Self {
            self.sample_rate = Some(input);
            self
        }
        /// <p>Number of audio samples recorded per second.</p>
        pub fn set_sample_rate(mut self, input: std::option::Option<i64>) -> Self {
            self.sample_rate = input;
            self
        }
        /// <p>Number of audio channels.</p>
        pub fn channels(mut self, input: i64) -> Self {
            self.channels = Some(input);
            self
        }
        /// <p>Number of audio channels.</p>
        pub fn set_channels(mut self, input: std::option::Option<i64>) -> Self {
            self.channels = input;
            self
        }
        /// Consumes the builder and constructs a [`AudioConfiguration`](crate::model::AudioConfiguration)
        pub fn build(self) -> crate::model::AudioConfiguration {
            crate::model::AudioConfiguration {
                codec: self.codec,
                target_bitrate: self.target_bitrate.unwrap_or_default(),
                sample_rate: self.sample_rate.unwrap_or_default(),
                channels: self.channels.unwrap_or_default(),
            }
        }
    }
}
impl AudioConfiguration {
    /// Creates a new builder-style object to manufacture [`AudioConfiguration`](crate::model::AudioConfiguration)
    pub fn builder() -> crate::model::audio_configuration::Builder {
        crate::model::audio_configuration::Builder::default()
    }
}

/// <p>Object specifying a stream’s video configuration.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct VideoConfiguration {
    /// <p>Indicates to the decoder the requirements for decoding the stream. For definitions of the
    /// valid values, see the H.264 specification.</p>
    pub avc_profile: std::option::Option<std::string::String>,
    /// <p>Indicates the degree of required decoder performance for a profile. Normally this is set
    /// automatically by the encoder. For details, see the H.264 specification.</p>
    pub avc_level: std::option::Option<std::string::String>,
    /// <p>Codec used for the video encoding.</p>
    pub codec: std::option::Option<std::string::String>,
    /// <p>Software or hardware used to encode the video.</p>
    pub encoder: std::option::Option<std::string::String>,
    /// <p>The expected ingest bitrate (bits per second). This is configured in the encoder.</p>
    pub target_bitrate: i64,
    /// <p>The expected ingest framerate. This is configured in the encoder.</p>
    pub target_framerate: i64,
    /// <p>Video-resolution height in pixels.</p>
    pub video_height: i64,
    /// <p>Video-resolution width in pixels.</p>
    pub video_width: i64,
}
impl VideoConfiguration {
    /// <p>Indicates to the decoder the requirements for decoding the stream. For definitions of the
    /// valid values, see the H.264 specification.</p>
    pub fn avc_profile(&self) -> std::option::Option<&str> {
        self.avc_profile.as_deref()
    }
    /// <p>Indicates the degree of required decoder performance for a profile. Normally this is set
    /// automatically by the encoder. For details, see the H.264 specification.</p>
    pub fn avc_level(&self) -> std::option::Option<&str> {
        self.avc_level.as_deref()
    }
    /// <p>Codec used for the video encoding.</p>
    pub fn codec(&self) -> std::option::Option<&str> {
        self.codec.as_deref()
    }
    /// <p>Software or hardware used to encode the video.</p>
    pub fn encoder(&self) -> std::option::Option<&str> {
        self.encoder.as_deref()
    }
    /// <p>The expected ingest bitrate (bits per second). This is configured in the encoder.</p>
    pub fn target_bitrate(&self) -> i64 {
        self.target_bitrate
    }
    /// <p>The expected ingest framerate. This is configured in the encoder.</p>
    pub fn target_framerate(&self) -> i64 {
        self.target_framerate
    }
    /// <p>Video-resolution height in pixels.</p>
    pub fn video_height(&self) -> i64 {
        self.video_height
    }
    /// <p>Video-resolution width in pixels.</p>
    pub fn video_width(&self) -> i64 {
        self.video_width
    }
}
impl std::fmt::Debug for VideoConfiguration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("VideoConfiguration");
        formatter.field("avc_profile", &self.avc_profile);
        formatter.field("avc_level", &self.avc_level);
        formatter.field("codec", &self.codec);
        formatter.field("encoder", &self.encoder);
        formatter.field("target_bitrate", &self.target_bitrate);
        formatter.field("target_framerate", &self.target_framerate);
        formatter.field("video_height", &self.video_height);
        formatter.field("video_width", &self.video_width);
        formatter.finish()
    }
}
/// See [`VideoConfiguration`](crate::model::VideoConfiguration)
pub mod video_configuration {
    /// A builder for [`VideoConfiguration`](crate::model::VideoConfiguration)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) avc_profile: std::option::Option<std::string::String>,
        pub(crate) avc_level: std::option::Option<std::string::String>,
        pub(crate) codec: std::option::Option<std::string::String>,
        pub(crate) encoder: std::option::Option<std::string::String>,
        pub(crate) target_bitrate: std::option::Option<i64>,
        pub(crate) target_framerate: std::option::Option<i64>,
        pub(crate) video_height: std::option::Option<i64>,
        pub(crate) video_width: std::option::Option<i64>,
    }
    impl Builder {
        /// <p>Indicates to the decoder the requirements for decoding the stream. For definitions of the
        /// valid values, see the H.264 specification.</p>
        pub fn avc_profile(mut self, input: impl Into<std::string::String>) -> Self {
            self.avc_profile = Some(input.into());
            self
        }
        /// <p>Indicates to the decoder the requirements for decoding the stream. For definitions of the
        /// valid values, see the H.264 specification.</p>
        pub fn set_avc_profile(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.avc_profile = input;
            self
        }
        /// <p>Indicates the degree of required decoder performance for a profile. Normally this is set
        /// automatically by the encoder. For details, see the H.264 specification.</p>
        pub fn avc_level(mut self, input: impl Into<std::string::String>) -> Self {
            self.avc_level = Some(input.into());
            self
        }
        /// <p>Indicates the degree of required decoder performance for a profile. Normally this is set
        /// automatically by the encoder. For details, see the H.264 specification.</p>
        pub fn set_avc_level(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.avc_level = input;
            self
        }
        /// <p>Codec used for the video encoding.</p>
        pub fn codec(mut self, input: impl Into<std::string::String>) -> Self {
            self.codec = Some(input.into());
            self
        }
        /// <p>Codec used for the video encoding.</p>
        pub fn set_codec(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.codec = input;
            self
        }
        /// <p>Software or hardware used to encode the video.</p>
        pub fn encoder(mut self, input: impl Into<std::string::String>) -> Self {
            self.encoder = Some(input.into());
            self
        }
        /// <p>Software or hardware used to encode the video.</p>
        pub fn set_encoder(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.encoder = input;
            self
        }
        /// <p>The expected ingest bitrate (bits per second). This is configured in the encoder.</p>
        pub fn target_bitrate(mut self, input: i64) -> Self {
            self.target_bitrate = Some(input);
            self
        }
        /// <p>The expected ingest bitrate (bits per second). This is configured in the encoder.</p>
        pub fn set_target_bitrate(mut self, input: std::option::Option<i64>) -> Self {
            self.target_bitrate = input;
            self
        }
        /// <p>The expected ingest framerate. This is configured in the encoder.</p>
        pub fn target_framerate(mut self, input: i64) -> Self {
            self.target_framerate = Some(input);
            self
        }
        /// <p>The expected ingest framerate. This is configured in the encoder.</p>
        pub fn set_target_framerate(mut self, input: std::option::Option<i64>) -> Self {
            self.target_framerate = input;
            self
        }
        /// <p>Video-resolution height in pixels.</p>
        pub fn video_height(mut self, input: i64) -> Self {
            self.video_height = Some(input);
            self
        }
        /// <p>Video-resolution height in pixels.</p>
        pub fn set_video_height(mut self, input: std::option::Option<i64>) -> Self {
            self.video_height = input;
            self
        }
        /// <p>Video-resolution width in pixels.</p>
        pub fn video_width(mut self, input: i64) -> Self {
            self.video_width = Some(input);
            self
        }
        /// <p>Video-resolution width in pixels.</p>
        pub fn set_video_width(mut self, input: std::option::Option<i64>) -> Self {
            self.video_width = input;
            self
        }
        /// Consumes the builder and constructs a [`VideoConfiguration`](crate::model::VideoConfiguration)
        pub fn build(self) -> crate::model::VideoConfiguration {
            crate::model::VideoConfiguration {
                avc_profile: self.avc_profile,
                avc_level: self.avc_level,
                codec: self.codec,
                encoder: self.encoder,
                target_bitrate: self.target_bitrate.unwrap_or_default(),
                target_framerate: self.target_framerate.unwrap_or_default(),
                video_height: self.video_height.unwrap_or_default(),
                video_width: self.video_width.unwrap_or_default(),
            }
        }
    }
}
impl VideoConfiguration {
    /// Creates a new builder-style object to manufacture [`VideoConfiguration`](crate::model::VideoConfiguration)
    pub fn builder() -> crate::model::video_configuration::Builder {
        crate::model::video_configuration::Builder::default()
    }
}

/// <p>Object specifying a stream key.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct StreamKey {
    /// <p>Stream-key ARN.</p>
    pub arn: std::option::Option<std::string::String>,
    /// <p>Stream-key value.</p>
    pub value: std::option::Option<std::string::String>,
    /// <p>Channel ARN for the stream.</p>
    pub channel_arn: std::option::Option<std::string::String>,
    /// <p>Array of 1-50 maps, each of the form <code>string:string (key:value)</code>.</p>
    pub tags:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
}
impl StreamKey {
    /// <p>Stream-key ARN.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>Stream-key value.</p>
    pub fn value(&self) -> std::option::Option<&str> {
        self.value.as_deref()
    }
    /// <p>Channel ARN for the stream.</p>
    pub fn channel_arn(&self) -> std::option::Option<&str> {
        self.channel_arn.as_deref()
    }
    /// <p>Array of 1-50 maps, each of the form <code>string:string (key:value)</code>.</p>
    pub fn tags(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.tags.as_ref()
    }
}
impl std::fmt::Debug for StreamKey {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("StreamKey");
        formatter.field("arn", &self.arn);
        formatter.field("value", &"*** Sensitive Data Redacted ***");
        formatter.field("channel_arn", &self.channel_arn);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}
/// See [`StreamKey`](crate::model::StreamKey)
pub mod stream_key {
    /// A builder for [`StreamKey`](crate::model::StreamKey)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) value: std::option::Option<std::string::String>,
        pub(crate) channel_arn: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
    }
    impl Builder {
        /// <p>Stream-key ARN.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>Stream-key ARN.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>Stream-key value.</p>
        pub fn value(mut self, input: impl Into<std::string::String>) -> Self {
            self.value = Some(input.into());
            self
        }
        /// <p>Stream-key value.</p>
        pub fn set_value(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.value = input;
            self
        }
        /// <p>Channel ARN for the stream.</p>
        pub fn channel_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.channel_arn = Some(input.into());
            self
        }
        /// <p>Channel ARN for the stream.</p>
        pub fn set_channel_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.channel_arn = input;
            self
        }
        /// Adds a key-value pair to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>Array of 1-50 maps, each of the form <code>string:string (key:value)</code>.</p>
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.tags.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.tags = Some(hash_map);
            self
        }
        /// <p>Array of 1-50 maps, each of the form <code>string:string (key:value)</code>.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`StreamKey`](crate::model::StreamKey)
        pub fn build(self) -> crate::model::StreamKey {
            crate::model::StreamKey {
                arn: self.arn,
                value: self.value,
                channel_arn: self.channel_arn,
                tags: self.tags,
            }
        }
    }
}
impl StreamKey {
    /// Creates a new builder-style object to manufacture [`StreamKey`](crate::model::StreamKey)
    pub fn builder() -> crate::model::stream_key::Builder {
        crate::model::stream_key::Builder::default()
    }
}

/// <p>Specifies a live video stream that has been ingested and distributed.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Stream {
    /// <p>Channel ARN for the stream.</p>
    pub channel_arn: std::option::Option<std::string::String>,
    /// <p>Unique identifier for a live or previously live stream in the specified channel.</p>
    pub stream_id: std::option::Option<std::string::String>,
    /// <p>URL of the master playlist, required by the video player to play the HLS stream.</p>
    pub playback_url: std::option::Option<std::string::String>,
    /// <p>Time of the stream’s start. This is an ISO 8601 timestamp returned as a string.</p>
    pub start_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The stream’s state.</p>
    pub state: std::option::Option<crate::model::StreamState>,
    /// <p>The stream’s health.</p>
    pub health: std::option::Option<crate::model::StreamHealth>,
    /// <p>A count of concurrent views of the stream. Typically, a new view appears in
    /// <code>viewerCount</code> within 15 seconds of when video playback starts and a view is
    /// removed from <code>viewerCount</code> within 1 minute of when video playback ends. A value of
    /// -1 indicates that the request timed out; in this case, retry.</p>
    pub viewer_count: i64,
}
impl Stream {
    /// <p>Channel ARN for the stream.</p>
    pub fn channel_arn(&self) -> std::option::Option<&str> {
        self.channel_arn.as_deref()
    }
    /// <p>Unique identifier for a live or previously live stream in the specified channel.</p>
    pub fn stream_id(&self) -> std::option::Option<&str> {
        self.stream_id.as_deref()
    }
    /// <p>URL of the master playlist, required by the video player to play the HLS stream.</p>
    pub fn playback_url(&self) -> std::option::Option<&str> {
        self.playback_url.as_deref()
    }
    /// <p>Time of the stream’s start. This is an ISO 8601 timestamp returned as a string.</p>
    pub fn start_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.start_time.as_ref()
    }
    /// <p>The stream’s state.</p>
    pub fn state(&self) -> std::option::Option<&crate::model::StreamState> {
        self.state.as_ref()
    }
    /// <p>The stream’s health.</p>
    pub fn health(&self) -> std::option::Option<&crate::model::StreamHealth> {
        self.health.as_ref()
    }
    /// <p>A count of concurrent views of the stream. Typically, a new view appears in
    /// <code>viewerCount</code> within 15 seconds of when video playback starts and a view is
    /// removed from <code>viewerCount</code> within 1 minute of when video playback ends. A value of
    /// -1 indicates that the request timed out; in this case, retry.</p>
    pub fn viewer_count(&self) -> i64 {
        self.viewer_count
    }
}
impl std::fmt::Debug for Stream {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Stream");
        formatter.field("channel_arn", &self.channel_arn);
        formatter.field("stream_id", &self.stream_id);
        formatter.field("playback_url", &self.playback_url);
        formatter.field("start_time", &self.start_time);
        formatter.field("state", &self.state);
        formatter.field("health", &self.health);
        formatter.field("viewer_count", &self.viewer_count);
        formatter.finish()
    }
}
/// See [`Stream`](crate::model::Stream)
pub mod stream {
    /// A builder for [`Stream`](crate::model::Stream)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) channel_arn: std::option::Option<std::string::String>,
        pub(crate) stream_id: std::option::Option<std::string::String>,
        pub(crate) playback_url: std::option::Option<std::string::String>,
        pub(crate) start_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) state: std::option::Option<crate::model::StreamState>,
        pub(crate) health: std::option::Option<crate::model::StreamHealth>,
        pub(crate) viewer_count: std::option::Option<i64>,
    }
    impl Builder {
        /// <p>Channel ARN for the stream.</p>
        pub fn channel_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.channel_arn = Some(input.into());
            self
        }
        /// <p>Channel ARN for the stream.</p>
        pub fn set_channel_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.channel_arn = input;
            self
        }
        /// <p>Unique identifier for a live or previously live stream in the specified channel.</p>
        pub fn stream_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.stream_id = Some(input.into());
            self
        }
        /// <p>Unique identifier for a live or previously live stream in the specified channel.</p>
        pub fn set_stream_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.stream_id = input;
            self
        }
        /// <p>URL of the master playlist, required by the video player to play the HLS stream.</p>
        pub fn playback_url(mut self, input: impl Into<std::string::String>) -> Self {
            self.playback_url = Some(input.into());
            self
        }
        /// <p>URL of the master playlist, required by the video player to play the HLS stream.</p>
        pub fn set_playback_url(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.playback_url = input;
            self
        }
        /// <p>Time of the stream’s start. This is an ISO 8601 timestamp returned as a string.</p>
        pub fn start_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.start_time = Some(input);
            self
        }
        /// <p>Time of the stream’s start. This is an ISO 8601 timestamp returned as a string.</p>
        pub fn set_start_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.start_time = input;
            self
        }
        /// <p>The stream’s state.</p>
        pub fn state(mut self, input: crate::model::StreamState) -> Self {
            self.state = Some(input);
            self
        }
        /// <p>The stream’s state.</p>
        pub fn set_state(mut self, input: std::option::Option<crate::model::StreamState>) -> Self {
            self.state = input;
            self
        }
        /// <p>The stream’s health.</p>
        pub fn health(mut self, input: crate::model::StreamHealth) -> Self {
            self.health = Some(input);
            self
        }
        /// <p>The stream’s health.</p>
        pub fn set_health(
            mut self,
            input: std::option::Option<crate::model::StreamHealth>,
        ) -> Self {
            self.health = input;
            self
        }
        /// <p>A count of concurrent views of the stream. Typically, a new view appears in
        /// <code>viewerCount</code> within 15 seconds of when video playback starts and a view is
        /// removed from <code>viewerCount</code> within 1 minute of when video playback ends. A value of
        /// -1 indicates that the request timed out; in this case, retry.</p>
        pub fn viewer_count(mut self, input: i64) -> Self {
            self.viewer_count = Some(input);
            self
        }
        /// <p>A count of concurrent views of the stream. Typically, a new view appears in
        /// <code>viewerCount</code> within 15 seconds of when video playback starts and a view is
        /// removed from <code>viewerCount</code> within 1 minute of when video playback ends. A value of
        /// -1 indicates that the request timed out; in this case, retry.</p>
        pub fn set_viewer_count(mut self, input: std::option::Option<i64>) -> Self {
            self.viewer_count = input;
            self
        }
        /// Consumes the builder and constructs a [`Stream`](crate::model::Stream)
        pub fn build(self) -> crate::model::Stream {
            crate::model::Stream {
                channel_arn: self.channel_arn,
                stream_id: self.stream_id,
                playback_url: self.playback_url,
                start_time: self.start_time,
                state: self.state,
                health: self.health,
                viewer_count: self.viewer_count.unwrap_or_default(),
            }
        }
    }
}
impl Stream {
    /// Creates a new builder-style object to manufacture [`Stream`](crate::model::Stream)
    pub fn builder() -> crate::model::stream::Builder {
        crate::model::stream::Builder::default()
    }
}

/// <p>Error related to a specific channel, specified by its ARN.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct BatchError {
    /// <p>Channel ARN.</p>
    pub arn: std::option::Option<std::string::String>,
    /// <p>Error code.</p>
    pub code: std::option::Option<std::string::String>,
    /// <p>Error message, determined by the application.</p>
    pub message: std::option::Option<std::string::String>,
}
impl BatchError {
    /// <p>Channel ARN.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>Error code.</p>
    pub fn code(&self) -> std::option::Option<&str> {
        self.code.as_deref()
    }
    /// <p>Error message, determined by the application.</p>
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Debug for BatchError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("BatchError");
        formatter.field("arn", &self.arn);
        formatter.field("code", &self.code);
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
/// See [`BatchError`](crate::model::BatchError)
pub mod batch_error {
    /// A builder for [`BatchError`](crate::model::BatchError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) code: std::option::Option<std::string::String>,
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Channel ARN.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>Channel ARN.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>Error code.</p>
        pub fn code(mut self, input: impl Into<std::string::String>) -> Self {
            self.code = Some(input.into());
            self
        }
        /// <p>Error code.</p>
        pub fn set_code(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.code = input;
            self
        }
        /// <p>Error message, determined by the application.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Error message, determined by the application.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`BatchError`](crate::model::BatchError)
        pub fn build(self) -> crate::model::BatchError {
            crate::model::BatchError {
                arn: self.arn,
                code: self.code,
                message: self.message,
            }
        }
    }
}
impl BatchError {
    /// Creates a new builder-style object to manufacture [`BatchError`](crate::model::BatchError)
    pub fn builder() -> crate::model::batch_error::Builder {
        crate::model::batch_error::Builder::default()
    }
}
