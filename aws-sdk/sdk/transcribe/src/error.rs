// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
/// Error type for the `CreateCallAnalyticsCategory` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateCallAnalyticsCategoryError {
    /// Kind of error that occurred.
    pub kind: CreateCallAnalyticsCategoryErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `CreateCallAnalyticsCategory` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateCallAnalyticsCategoryErrorKind {
    /// <p>Your request didn't pass one or more validation tests. For example, if the entity that you're trying to delete
    /// doesn't exist or if it is in a non-terminal state (for example, it's "in progress"). See the exception <code>Message</code>
    /// field for more information.</p>
    BadRequestException(crate::error::BadRequestException),
    /// <p>There is already a resource with that name.</p>
    ConflictException(crate::error::ConflictException),
    /// <p>There was an internal error. Check the error message and try your request again.</p>
    InternalFailureException(crate::error::InternalFailureException),
    /// <p>Either you have sent too many requests or your input file is too long. Wait before you resend your request, or
    /// use a smaller file and resend the request.</p>
    LimitExceededException(crate::error::LimitExceededException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateCallAnalyticsCategoryError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateCallAnalyticsCategoryErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            CreateCallAnalyticsCategoryErrorKind::ConflictException(_inner) => _inner.fmt(f),
            CreateCallAnalyticsCategoryErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            CreateCallAnalyticsCategoryErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            CreateCallAnalyticsCategoryErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for CreateCallAnalyticsCategoryError {
    fn code(&self) -> Option<&str> {
        CreateCallAnalyticsCategoryError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateCallAnalyticsCategoryError {
    /// Creates a new `CreateCallAnalyticsCategoryError`.
    pub fn new(kind: CreateCallAnalyticsCategoryErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `CreateCallAnalyticsCategoryError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateCallAnalyticsCategoryErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `CreateCallAnalyticsCategoryError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateCallAnalyticsCategoryErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `CreateCallAnalyticsCategoryErrorKind::BadRequestException`.
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateCallAnalyticsCategoryErrorKind::BadRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateCallAnalyticsCategoryErrorKind::ConflictException`.
    pub fn is_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateCallAnalyticsCategoryErrorKind::ConflictException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateCallAnalyticsCategoryErrorKind::InternalFailureException`.
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateCallAnalyticsCategoryErrorKind::InternalFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateCallAnalyticsCategoryErrorKind::LimitExceededException`.
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateCallAnalyticsCategoryErrorKind::LimitExceededException(_)
        )
    }
}
impl std::error::Error for CreateCallAnalyticsCategoryError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateCallAnalyticsCategoryErrorKind::BadRequestException(_inner) => Some(_inner),
            CreateCallAnalyticsCategoryErrorKind::ConflictException(_inner) => Some(_inner),
            CreateCallAnalyticsCategoryErrorKind::InternalFailureException(_inner) => Some(_inner),
            CreateCallAnalyticsCategoryErrorKind::LimitExceededException(_inner) => Some(_inner),
            CreateCallAnalyticsCategoryErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `CreateLanguageModel` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateLanguageModelError {
    /// Kind of error that occurred.
    pub kind: CreateLanguageModelErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `CreateLanguageModel` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateLanguageModelErrorKind {
    /// <p>Your request didn't pass one or more validation tests. For example, if the entity that you're trying to delete
    /// doesn't exist or if it is in a non-terminal state (for example, it's "in progress"). See the exception <code>Message</code>
    /// field for more information.</p>
    BadRequestException(crate::error::BadRequestException),
    /// <p>There is already a resource with that name.</p>
    ConflictException(crate::error::ConflictException),
    /// <p>There was an internal error. Check the error message and try your request again.</p>
    InternalFailureException(crate::error::InternalFailureException),
    /// <p>Either you have sent too many requests or your input file is too long. Wait before you resend your request, or
    /// use a smaller file and resend the request.</p>
    LimitExceededException(crate::error::LimitExceededException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateLanguageModelError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateLanguageModelErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            CreateLanguageModelErrorKind::ConflictException(_inner) => _inner.fmt(f),
            CreateLanguageModelErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            CreateLanguageModelErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            CreateLanguageModelErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for CreateLanguageModelError {
    fn code(&self) -> Option<&str> {
        CreateLanguageModelError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateLanguageModelError {
    /// Creates a new `CreateLanguageModelError`.
    pub fn new(kind: CreateLanguageModelErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `CreateLanguageModelError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateLanguageModelErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `CreateLanguageModelError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateLanguageModelErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `CreateLanguageModelErrorKind::BadRequestException`.
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateLanguageModelErrorKind::BadRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateLanguageModelErrorKind::ConflictException`.
    pub fn is_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateLanguageModelErrorKind::ConflictException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateLanguageModelErrorKind::InternalFailureException`.
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateLanguageModelErrorKind::InternalFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateLanguageModelErrorKind::LimitExceededException`.
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateLanguageModelErrorKind::LimitExceededException(_)
        )
    }
}
impl std::error::Error for CreateLanguageModelError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateLanguageModelErrorKind::BadRequestException(_inner) => Some(_inner),
            CreateLanguageModelErrorKind::ConflictException(_inner) => Some(_inner),
            CreateLanguageModelErrorKind::InternalFailureException(_inner) => Some(_inner),
            CreateLanguageModelErrorKind::LimitExceededException(_inner) => Some(_inner),
            CreateLanguageModelErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `CreateMedicalVocabulary` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateMedicalVocabularyError {
    /// Kind of error that occurred.
    pub kind: CreateMedicalVocabularyErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `CreateMedicalVocabulary` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateMedicalVocabularyErrorKind {
    /// <p>Your request didn't pass one or more validation tests. For example, if the entity that you're trying to delete
    /// doesn't exist or if it is in a non-terminal state (for example, it's "in progress"). See the exception <code>Message</code>
    /// field for more information.</p>
    BadRequestException(crate::error::BadRequestException),
    /// <p>There is already a resource with that name.</p>
    ConflictException(crate::error::ConflictException),
    /// <p>There was an internal error. Check the error message and try your request again.</p>
    InternalFailureException(crate::error::InternalFailureException),
    /// <p>Either you have sent too many requests or your input file is too long. Wait before you resend your request, or
    /// use a smaller file and resend the request.</p>
    LimitExceededException(crate::error::LimitExceededException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateMedicalVocabularyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateMedicalVocabularyErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            CreateMedicalVocabularyErrorKind::ConflictException(_inner) => _inner.fmt(f),
            CreateMedicalVocabularyErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            CreateMedicalVocabularyErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            CreateMedicalVocabularyErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for CreateMedicalVocabularyError {
    fn code(&self) -> Option<&str> {
        CreateMedicalVocabularyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateMedicalVocabularyError {
    /// Creates a new `CreateMedicalVocabularyError`.
    pub fn new(kind: CreateMedicalVocabularyErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `CreateMedicalVocabularyError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateMedicalVocabularyErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `CreateMedicalVocabularyError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateMedicalVocabularyErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `CreateMedicalVocabularyErrorKind::BadRequestException`.
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateMedicalVocabularyErrorKind::BadRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateMedicalVocabularyErrorKind::ConflictException`.
    pub fn is_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateMedicalVocabularyErrorKind::ConflictException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateMedicalVocabularyErrorKind::InternalFailureException`.
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateMedicalVocabularyErrorKind::InternalFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateMedicalVocabularyErrorKind::LimitExceededException`.
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateMedicalVocabularyErrorKind::LimitExceededException(_)
        )
    }
}
impl std::error::Error for CreateMedicalVocabularyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateMedicalVocabularyErrorKind::BadRequestException(_inner) => Some(_inner),
            CreateMedicalVocabularyErrorKind::ConflictException(_inner) => Some(_inner),
            CreateMedicalVocabularyErrorKind::InternalFailureException(_inner) => Some(_inner),
            CreateMedicalVocabularyErrorKind::LimitExceededException(_inner) => Some(_inner),
            CreateMedicalVocabularyErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `CreateVocabulary` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateVocabularyError {
    /// Kind of error that occurred.
    pub kind: CreateVocabularyErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `CreateVocabulary` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateVocabularyErrorKind {
    /// <p>Your request didn't pass one or more validation tests. For example, if the entity that you're trying to delete
    /// doesn't exist or if it is in a non-terminal state (for example, it's "in progress"). See the exception <code>Message</code>
    /// field for more information.</p>
    BadRequestException(crate::error::BadRequestException),
    /// <p>There is already a resource with that name.</p>
    ConflictException(crate::error::ConflictException),
    /// <p>There was an internal error. Check the error message and try your request again.</p>
    InternalFailureException(crate::error::InternalFailureException),
    /// <p>Either you have sent too many requests or your input file is too long. Wait before you resend your request, or
    /// use a smaller file and resend the request.</p>
    LimitExceededException(crate::error::LimitExceededException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateVocabularyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateVocabularyErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            CreateVocabularyErrorKind::ConflictException(_inner) => _inner.fmt(f),
            CreateVocabularyErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            CreateVocabularyErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            CreateVocabularyErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for CreateVocabularyError {
    fn code(&self) -> Option<&str> {
        CreateVocabularyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateVocabularyError {
    /// Creates a new `CreateVocabularyError`.
    pub fn new(kind: CreateVocabularyErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `CreateVocabularyError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateVocabularyErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `CreateVocabularyError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateVocabularyErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `CreateVocabularyErrorKind::BadRequestException`.
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateVocabularyErrorKind::BadRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateVocabularyErrorKind::ConflictException`.
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, CreateVocabularyErrorKind::ConflictException(_))
    }
    /// Returns `true` if the error kind is `CreateVocabularyErrorKind::InternalFailureException`.
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateVocabularyErrorKind::InternalFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateVocabularyErrorKind::LimitExceededException`.
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateVocabularyErrorKind::LimitExceededException(_)
        )
    }
}
impl std::error::Error for CreateVocabularyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateVocabularyErrorKind::BadRequestException(_inner) => Some(_inner),
            CreateVocabularyErrorKind::ConflictException(_inner) => Some(_inner),
            CreateVocabularyErrorKind::InternalFailureException(_inner) => Some(_inner),
            CreateVocabularyErrorKind::LimitExceededException(_inner) => Some(_inner),
            CreateVocabularyErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `CreateVocabularyFilter` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateVocabularyFilterError {
    /// Kind of error that occurred.
    pub kind: CreateVocabularyFilterErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `CreateVocabularyFilter` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateVocabularyFilterErrorKind {
    /// <p>Your request didn't pass one or more validation tests. For example, if the entity that you're trying to delete
    /// doesn't exist or if it is in a non-terminal state (for example, it's "in progress"). See the exception <code>Message</code>
    /// field for more information.</p>
    BadRequestException(crate::error::BadRequestException),
    /// <p>There is already a resource with that name.</p>
    ConflictException(crate::error::ConflictException),
    /// <p>There was an internal error. Check the error message and try your request again.</p>
    InternalFailureException(crate::error::InternalFailureException),
    /// <p>Either you have sent too many requests or your input file is too long. Wait before you resend your request, or
    /// use a smaller file and resend the request.</p>
    LimitExceededException(crate::error::LimitExceededException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateVocabularyFilterError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateVocabularyFilterErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            CreateVocabularyFilterErrorKind::ConflictException(_inner) => _inner.fmt(f),
            CreateVocabularyFilterErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            CreateVocabularyFilterErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            CreateVocabularyFilterErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for CreateVocabularyFilterError {
    fn code(&self) -> Option<&str> {
        CreateVocabularyFilterError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateVocabularyFilterError {
    /// Creates a new `CreateVocabularyFilterError`.
    pub fn new(kind: CreateVocabularyFilterErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `CreateVocabularyFilterError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateVocabularyFilterErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `CreateVocabularyFilterError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateVocabularyFilterErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `CreateVocabularyFilterErrorKind::BadRequestException`.
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateVocabularyFilterErrorKind::BadRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateVocabularyFilterErrorKind::ConflictException`.
    pub fn is_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateVocabularyFilterErrorKind::ConflictException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateVocabularyFilterErrorKind::InternalFailureException`.
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateVocabularyFilterErrorKind::InternalFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateVocabularyFilterErrorKind::LimitExceededException`.
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateVocabularyFilterErrorKind::LimitExceededException(_)
        )
    }
}
impl std::error::Error for CreateVocabularyFilterError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateVocabularyFilterErrorKind::BadRequestException(_inner) => Some(_inner),
            CreateVocabularyFilterErrorKind::ConflictException(_inner) => Some(_inner),
            CreateVocabularyFilterErrorKind::InternalFailureException(_inner) => Some(_inner),
            CreateVocabularyFilterErrorKind::LimitExceededException(_inner) => Some(_inner),
            CreateVocabularyFilterErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `DeleteCallAnalyticsCategory` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteCallAnalyticsCategoryError {
    /// Kind of error that occurred.
    pub kind: DeleteCallAnalyticsCategoryErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `DeleteCallAnalyticsCategory` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteCallAnalyticsCategoryErrorKind {
    /// <p>Your request didn't pass one or more validation tests. For example, if the entity that you're trying to delete
    /// doesn't exist or if it is in a non-terminal state (for example, it's "in progress"). See the exception <code>Message</code>
    /// field for more information.</p>
    BadRequestException(crate::error::BadRequestException),
    /// <p>There was an internal error. Check the error message and try your request again.</p>
    InternalFailureException(crate::error::InternalFailureException),
    /// <p>Either you have sent too many requests or your input file is too long. Wait before you resend your request, or
    /// use a smaller file and resend the request.</p>
    LimitExceededException(crate::error::LimitExceededException),
    /// <p>We can't find the requested resource. Check the name and try your request again.</p>
    NotFoundException(crate::error::NotFoundException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteCallAnalyticsCategoryError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteCallAnalyticsCategoryErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            DeleteCallAnalyticsCategoryErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            DeleteCallAnalyticsCategoryErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            DeleteCallAnalyticsCategoryErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            DeleteCallAnalyticsCategoryErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DeleteCallAnalyticsCategoryError {
    fn code(&self) -> Option<&str> {
        DeleteCallAnalyticsCategoryError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteCallAnalyticsCategoryError {
    /// Creates a new `DeleteCallAnalyticsCategoryError`.
    pub fn new(kind: DeleteCallAnalyticsCategoryErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `DeleteCallAnalyticsCategoryError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteCallAnalyticsCategoryErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `DeleteCallAnalyticsCategoryError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteCallAnalyticsCategoryErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `DeleteCallAnalyticsCategoryErrorKind::BadRequestException`.
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteCallAnalyticsCategoryErrorKind::BadRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteCallAnalyticsCategoryErrorKind::InternalFailureException`.
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteCallAnalyticsCategoryErrorKind::InternalFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteCallAnalyticsCategoryErrorKind::LimitExceededException`.
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteCallAnalyticsCategoryErrorKind::LimitExceededException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteCallAnalyticsCategoryErrorKind::NotFoundException`.
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteCallAnalyticsCategoryErrorKind::NotFoundException(_)
        )
    }
}
impl std::error::Error for DeleteCallAnalyticsCategoryError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteCallAnalyticsCategoryErrorKind::BadRequestException(_inner) => Some(_inner),
            DeleteCallAnalyticsCategoryErrorKind::InternalFailureException(_inner) => Some(_inner),
            DeleteCallAnalyticsCategoryErrorKind::LimitExceededException(_inner) => Some(_inner),
            DeleteCallAnalyticsCategoryErrorKind::NotFoundException(_inner) => Some(_inner),
            DeleteCallAnalyticsCategoryErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `DeleteCallAnalyticsJob` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteCallAnalyticsJobError {
    /// Kind of error that occurred.
    pub kind: DeleteCallAnalyticsJobErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `DeleteCallAnalyticsJob` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteCallAnalyticsJobErrorKind {
    /// <p>Your request didn't pass one or more validation tests. For example, if the entity that you're trying to delete
    /// doesn't exist or if it is in a non-terminal state (for example, it's "in progress"). See the exception <code>Message</code>
    /// field for more information.</p>
    BadRequestException(crate::error::BadRequestException),
    /// <p>There was an internal error. Check the error message and try your request again.</p>
    InternalFailureException(crate::error::InternalFailureException),
    /// <p>Either you have sent too many requests or your input file is too long. Wait before you resend your request, or
    /// use a smaller file and resend the request.</p>
    LimitExceededException(crate::error::LimitExceededException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteCallAnalyticsJobError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteCallAnalyticsJobErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            DeleteCallAnalyticsJobErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            DeleteCallAnalyticsJobErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            DeleteCallAnalyticsJobErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DeleteCallAnalyticsJobError {
    fn code(&self) -> Option<&str> {
        DeleteCallAnalyticsJobError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteCallAnalyticsJobError {
    /// Creates a new `DeleteCallAnalyticsJobError`.
    pub fn new(kind: DeleteCallAnalyticsJobErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `DeleteCallAnalyticsJobError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteCallAnalyticsJobErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `DeleteCallAnalyticsJobError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteCallAnalyticsJobErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `DeleteCallAnalyticsJobErrorKind::BadRequestException`.
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteCallAnalyticsJobErrorKind::BadRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteCallAnalyticsJobErrorKind::InternalFailureException`.
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteCallAnalyticsJobErrorKind::InternalFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteCallAnalyticsJobErrorKind::LimitExceededException`.
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteCallAnalyticsJobErrorKind::LimitExceededException(_)
        )
    }
}
impl std::error::Error for DeleteCallAnalyticsJobError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteCallAnalyticsJobErrorKind::BadRequestException(_inner) => Some(_inner),
            DeleteCallAnalyticsJobErrorKind::InternalFailureException(_inner) => Some(_inner),
            DeleteCallAnalyticsJobErrorKind::LimitExceededException(_inner) => Some(_inner),
            DeleteCallAnalyticsJobErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `DeleteLanguageModel` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteLanguageModelError {
    /// Kind of error that occurred.
    pub kind: DeleteLanguageModelErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `DeleteLanguageModel` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteLanguageModelErrorKind {
    /// <p>Your request didn't pass one or more validation tests. For example, if the entity that you're trying to delete
    /// doesn't exist or if it is in a non-terminal state (for example, it's "in progress"). See the exception <code>Message</code>
    /// field for more information.</p>
    BadRequestException(crate::error::BadRequestException),
    /// <p>There was an internal error. Check the error message and try your request again.</p>
    InternalFailureException(crate::error::InternalFailureException),
    /// <p>Either you have sent too many requests or your input file is too long. Wait before you resend your request, or
    /// use a smaller file and resend the request.</p>
    LimitExceededException(crate::error::LimitExceededException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteLanguageModelError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteLanguageModelErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            DeleteLanguageModelErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            DeleteLanguageModelErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            DeleteLanguageModelErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DeleteLanguageModelError {
    fn code(&self) -> Option<&str> {
        DeleteLanguageModelError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteLanguageModelError {
    /// Creates a new `DeleteLanguageModelError`.
    pub fn new(kind: DeleteLanguageModelErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `DeleteLanguageModelError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteLanguageModelErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `DeleteLanguageModelError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteLanguageModelErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `DeleteLanguageModelErrorKind::BadRequestException`.
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteLanguageModelErrorKind::BadRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteLanguageModelErrorKind::InternalFailureException`.
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteLanguageModelErrorKind::InternalFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteLanguageModelErrorKind::LimitExceededException`.
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteLanguageModelErrorKind::LimitExceededException(_)
        )
    }
}
impl std::error::Error for DeleteLanguageModelError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteLanguageModelErrorKind::BadRequestException(_inner) => Some(_inner),
            DeleteLanguageModelErrorKind::InternalFailureException(_inner) => Some(_inner),
            DeleteLanguageModelErrorKind::LimitExceededException(_inner) => Some(_inner),
            DeleteLanguageModelErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `DeleteMedicalTranscriptionJob` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteMedicalTranscriptionJobError {
    /// Kind of error that occurred.
    pub kind: DeleteMedicalTranscriptionJobErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `DeleteMedicalTranscriptionJob` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteMedicalTranscriptionJobErrorKind {
    /// <p>Your request didn't pass one or more validation tests. For example, if the entity that you're trying to delete
    /// doesn't exist or if it is in a non-terminal state (for example, it's "in progress"). See the exception <code>Message</code>
    /// field for more information.</p>
    BadRequestException(crate::error::BadRequestException),
    /// <p>There was an internal error. Check the error message and try your request again.</p>
    InternalFailureException(crate::error::InternalFailureException),
    /// <p>Either you have sent too many requests or your input file is too long. Wait before you resend your request, or
    /// use a smaller file and resend the request.</p>
    LimitExceededException(crate::error::LimitExceededException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteMedicalTranscriptionJobError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteMedicalTranscriptionJobErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            DeleteMedicalTranscriptionJobErrorKind::InternalFailureException(_inner) => {
                _inner.fmt(f)
            }
            DeleteMedicalTranscriptionJobErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            DeleteMedicalTranscriptionJobErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DeleteMedicalTranscriptionJobError {
    fn code(&self) -> Option<&str> {
        DeleteMedicalTranscriptionJobError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteMedicalTranscriptionJobError {
    /// Creates a new `DeleteMedicalTranscriptionJobError`.
    pub fn new(
        kind: DeleteMedicalTranscriptionJobErrorKind,
        meta: aws_smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    /// Creates the `DeleteMedicalTranscriptionJobError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteMedicalTranscriptionJobErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `DeleteMedicalTranscriptionJobError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteMedicalTranscriptionJobErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `DeleteMedicalTranscriptionJobErrorKind::BadRequestException`.
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteMedicalTranscriptionJobErrorKind::BadRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteMedicalTranscriptionJobErrorKind::InternalFailureException`.
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteMedicalTranscriptionJobErrorKind::InternalFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteMedicalTranscriptionJobErrorKind::LimitExceededException`.
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteMedicalTranscriptionJobErrorKind::LimitExceededException(_)
        )
    }
}
impl std::error::Error for DeleteMedicalTranscriptionJobError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteMedicalTranscriptionJobErrorKind::BadRequestException(_inner) => Some(_inner),
            DeleteMedicalTranscriptionJobErrorKind::InternalFailureException(_inner) => {
                Some(_inner)
            }
            DeleteMedicalTranscriptionJobErrorKind::LimitExceededException(_inner) => Some(_inner),
            DeleteMedicalTranscriptionJobErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `DeleteMedicalVocabulary` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteMedicalVocabularyError {
    /// Kind of error that occurred.
    pub kind: DeleteMedicalVocabularyErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `DeleteMedicalVocabulary` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteMedicalVocabularyErrorKind {
    /// <p>Your request didn't pass one or more validation tests. For example, if the entity that you're trying to delete
    /// doesn't exist or if it is in a non-terminal state (for example, it's "in progress"). See the exception <code>Message</code>
    /// field for more information.</p>
    BadRequestException(crate::error::BadRequestException),
    /// <p>There was an internal error. Check the error message and try your request again.</p>
    InternalFailureException(crate::error::InternalFailureException),
    /// <p>Either you have sent too many requests or your input file is too long. Wait before you resend your request, or
    /// use a smaller file and resend the request.</p>
    LimitExceededException(crate::error::LimitExceededException),
    /// <p>We can't find the requested resource. Check the name and try your request again.</p>
    NotFoundException(crate::error::NotFoundException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteMedicalVocabularyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteMedicalVocabularyErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            DeleteMedicalVocabularyErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            DeleteMedicalVocabularyErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            DeleteMedicalVocabularyErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            DeleteMedicalVocabularyErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DeleteMedicalVocabularyError {
    fn code(&self) -> Option<&str> {
        DeleteMedicalVocabularyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteMedicalVocabularyError {
    /// Creates a new `DeleteMedicalVocabularyError`.
    pub fn new(kind: DeleteMedicalVocabularyErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `DeleteMedicalVocabularyError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteMedicalVocabularyErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `DeleteMedicalVocabularyError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteMedicalVocabularyErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `DeleteMedicalVocabularyErrorKind::BadRequestException`.
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteMedicalVocabularyErrorKind::BadRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteMedicalVocabularyErrorKind::InternalFailureException`.
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteMedicalVocabularyErrorKind::InternalFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteMedicalVocabularyErrorKind::LimitExceededException`.
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteMedicalVocabularyErrorKind::LimitExceededException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteMedicalVocabularyErrorKind::NotFoundException`.
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteMedicalVocabularyErrorKind::NotFoundException(_)
        )
    }
}
impl std::error::Error for DeleteMedicalVocabularyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteMedicalVocabularyErrorKind::BadRequestException(_inner) => Some(_inner),
            DeleteMedicalVocabularyErrorKind::InternalFailureException(_inner) => Some(_inner),
            DeleteMedicalVocabularyErrorKind::LimitExceededException(_inner) => Some(_inner),
            DeleteMedicalVocabularyErrorKind::NotFoundException(_inner) => Some(_inner),
            DeleteMedicalVocabularyErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `DeleteTranscriptionJob` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteTranscriptionJobError {
    /// Kind of error that occurred.
    pub kind: DeleteTranscriptionJobErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `DeleteTranscriptionJob` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteTranscriptionJobErrorKind {
    /// <p>Your request didn't pass one or more validation tests. For example, if the entity that you're trying to delete
    /// doesn't exist or if it is in a non-terminal state (for example, it's "in progress"). See the exception <code>Message</code>
    /// field for more information.</p>
    BadRequestException(crate::error::BadRequestException),
    /// <p>There was an internal error. Check the error message and try your request again.</p>
    InternalFailureException(crate::error::InternalFailureException),
    /// <p>Either you have sent too many requests or your input file is too long. Wait before you resend your request, or
    /// use a smaller file and resend the request.</p>
    LimitExceededException(crate::error::LimitExceededException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteTranscriptionJobError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteTranscriptionJobErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            DeleteTranscriptionJobErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            DeleteTranscriptionJobErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            DeleteTranscriptionJobErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DeleteTranscriptionJobError {
    fn code(&self) -> Option<&str> {
        DeleteTranscriptionJobError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteTranscriptionJobError {
    /// Creates a new `DeleteTranscriptionJobError`.
    pub fn new(kind: DeleteTranscriptionJobErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `DeleteTranscriptionJobError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteTranscriptionJobErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `DeleteTranscriptionJobError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteTranscriptionJobErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `DeleteTranscriptionJobErrorKind::BadRequestException`.
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteTranscriptionJobErrorKind::BadRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteTranscriptionJobErrorKind::InternalFailureException`.
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteTranscriptionJobErrorKind::InternalFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteTranscriptionJobErrorKind::LimitExceededException`.
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteTranscriptionJobErrorKind::LimitExceededException(_)
        )
    }
}
impl std::error::Error for DeleteTranscriptionJobError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteTranscriptionJobErrorKind::BadRequestException(_inner) => Some(_inner),
            DeleteTranscriptionJobErrorKind::InternalFailureException(_inner) => Some(_inner),
            DeleteTranscriptionJobErrorKind::LimitExceededException(_inner) => Some(_inner),
            DeleteTranscriptionJobErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `DeleteVocabulary` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteVocabularyError {
    /// Kind of error that occurred.
    pub kind: DeleteVocabularyErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `DeleteVocabulary` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteVocabularyErrorKind {
    /// <p>Your request didn't pass one or more validation tests. For example, if the entity that you're trying to delete
    /// doesn't exist or if it is in a non-terminal state (for example, it's "in progress"). See the exception <code>Message</code>
    /// field for more information.</p>
    BadRequestException(crate::error::BadRequestException),
    /// <p>There was an internal error. Check the error message and try your request again.</p>
    InternalFailureException(crate::error::InternalFailureException),
    /// <p>Either you have sent too many requests or your input file is too long. Wait before you resend your request, or
    /// use a smaller file and resend the request.</p>
    LimitExceededException(crate::error::LimitExceededException),
    /// <p>We can't find the requested resource. Check the name and try your request again.</p>
    NotFoundException(crate::error::NotFoundException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteVocabularyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteVocabularyErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            DeleteVocabularyErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            DeleteVocabularyErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            DeleteVocabularyErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            DeleteVocabularyErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DeleteVocabularyError {
    fn code(&self) -> Option<&str> {
        DeleteVocabularyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteVocabularyError {
    /// Creates a new `DeleteVocabularyError`.
    pub fn new(kind: DeleteVocabularyErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `DeleteVocabularyError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteVocabularyErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `DeleteVocabularyError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteVocabularyErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `DeleteVocabularyErrorKind::BadRequestException`.
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteVocabularyErrorKind::BadRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteVocabularyErrorKind::InternalFailureException`.
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteVocabularyErrorKind::InternalFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteVocabularyErrorKind::LimitExceededException`.
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteVocabularyErrorKind::LimitExceededException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteVocabularyErrorKind::NotFoundException`.
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, DeleteVocabularyErrorKind::NotFoundException(_))
    }
}
impl std::error::Error for DeleteVocabularyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteVocabularyErrorKind::BadRequestException(_inner) => Some(_inner),
            DeleteVocabularyErrorKind::InternalFailureException(_inner) => Some(_inner),
            DeleteVocabularyErrorKind::LimitExceededException(_inner) => Some(_inner),
            DeleteVocabularyErrorKind::NotFoundException(_inner) => Some(_inner),
            DeleteVocabularyErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `DeleteVocabularyFilter` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteVocabularyFilterError {
    /// Kind of error that occurred.
    pub kind: DeleteVocabularyFilterErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `DeleteVocabularyFilter` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteVocabularyFilterErrorKind {
    /// <p>Your request didn't pass one or more validation tests. For example, if the entity that you're trying to delete
    /// doesn't exist or if it is in a non-terminal state (for example, it's "in progress"). See the exception <code>Message</code>
    /// field for more information.</p>
    BadRequestException(crate::error::BadRequestException),
    /// <p>There was an internal error. Check the error message and try your request again.</p>
    InternalFailureException(crate::error::InternalFailureException),
    /// <p>Either you have sent too many requests or your input file is too long. Wait before you resend your request, or
    /// use a smaller file and resend the request.</p>
    LimitExceededException(crate::error::LimitExceededException),
    /// <p>We can't find the requested resource. Check the name and try your request again.</p>
    NotFoundException(crate::error::NotFoundException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteVocabularyFilterError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteVocabularyFilterErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            DeleteVocabularyFilterErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            DeleteVocabularyFilterErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            DeleteVocabularyFilterErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            DeleteVocabularyFilterErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DeleteVocabularyFilterError {
    fn code(&self) -> Option<&str> {
        DeleteVocabularyFilterError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteVocabularyFilterError {
    /// Creates a new `DeleteVocabularyFilterError`.
    pub fn new(kind: DeleteVocabularyFilterErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `DeleteVocabularyFilterError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteVocabularyFilterErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `DeleteVocabularyFilterError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteVocabularyFilterErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `DeleteVocabularyFilterErrorKind::BadRequestException`.
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteVocabularyFilterErrorKind::BadRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteVocabularyFilterErrorKind::InternalFailureException`.
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteVocabularyFilterErrorKind::InternalFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteVocabularyFilterErrorKind::LimitExceededException`.
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteVocabularyFilterErrorKind::LimitExceededException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteVocabularyFilterErrorKind::NotFoundException`.
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteVocabularyFilterErrorKind::NotFoundException(_)
        )
    }
}
impl std::error::Error for DeleteVocabularyFilterError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteVocabularyFilterErrorKind::BadRequestException(_inner) => Some(_inner),
            DeleteVocabularyFilterErrorKind::InternalFailureException(_inner) => Some(_inner),
            DeleteVocabularyFilterErrorKind::LimitExceededException(_inner) => Some(_inner),
            DeleteVocabularyFilterErrorKind::NotFoundException(_inner) => Some(_inner),
            DeleteVocabularyFilterErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `DescribeLanguageModel` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeLanguageModelError {
    /// Kind of error that occurred.
    pub kind: DescribeLanguageModelErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `DescribeLanguageModel` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeLanguageModelErrorKind {
    /// <p>Your request didn't pass one or more validation tests. For example, if the entity that you're trying to delete
    /// doesn't exist or if it is in a non-terminal state (for example, it's "in progress"). See the exception <code>Message</code>
    /// field for more information.</p>
    BadRequestException(crate::error::BadRequestException),
    /// <p>There was an internal error. Check the error message and try your request again.</p>
    InternalFailureException(crate::error::InternalFailureException),
    /// <p>Either you have sent too many requests or your input file is too long. Wait before you resend your request, or
    /// use a smaller file and resend the request.</p>
    LimitExceededException(crate::error::LimitExceededException),
    /// <p>We can't find the requested resource. Check the name and try your request again.</p>
    NotFoundException(crate::error::NotFoundException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeLanguageModelError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeLanguageModelErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            DescribeLanguageModelErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            DescribeLanguageModelErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            DescribeLanguageModelErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            DescribeLanguageModelErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DescribeLanguageModelError {
    fn code(&self) -> Option<&str> {
        DescribeLanguageModelError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeLanguageModelError {
    /// Creates a new `DescribeLanguageModelError`.
    pub fn new(kind: DescribeLanguageModelErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `DescribeLanguageModelError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeLanguageModelErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `DescribeLanguageModelError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeLanguageModelErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `DescribeLanguageModelErrorKind::BadRequestException`.
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeLanguageModelErrorKind::BadRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `DescribeLanguageModelErrorKind::InternalFailureException`.
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeLanguageModelErrorKind::InternalFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `DescribeLanguageModelErrorKind::LimitExceededException`.
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeLanguageModelErrorKind::LimitExceededException(_)
        )
    }
    /// Returns `true` if the error kind is `DescribeLanguageModelErrorKind::NotFoundException`.
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeLanguageModelErrorKind::NotFoundException(_)
        )
    }
}
impl std::error::Error for DescribeLanguageModelError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeLanguageModelErrorKind::BadRequestException(_inner) => Some(_inner),
            DescribeLanguageModelErrorKind::InternalFailureException(_inner) => Some(_inner),
            DescribeLanguageModelErrorKind::LimitExceededException(_inner) => Some(_inner),
            DescribeLanguageModelErrorKind::NotFoundException(_inner) => Some(_inner),
            DescribeLanguageModelErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `GetCallAnalyticsCategory` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetCallAnalyticsCategoryError {
    /// Kind of error that occurred.
    pub kind: GetCallAnalyticsCategoryErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `GetCallAnalyticsCategory` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetCallAnalyticsCategoryErrorKind {
    /// <p>Your request didn't pass one or more validation tests. For example, if the entity that you're trying to delete
    /// doesn't exist or if it is in a non-terminal state (for example, it's "in progress"). See the exception <code>Message</code>
    /// field for more information.</p>
    BadRequestException(crate::error::BadRequestException),
    /// <p>There was an internal error. Check the error message and try your request again.</p>
    InternalFailureException(crate::error::InternalFailureException),
    /// <p>Either you have sent too many requests or your input file is too long. Wait before you resend your request, or
    /// use a smaller file and resend the request.</p>
    LimitExceededException(crate::error::LimitExceededException),
    /// <p>We can't find the requested resource. Check the name and try your request again.</p>
    NotFoundException(crate::error::NotFoundException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetCallAnalyticsCategoryError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetCallAnalyticsCategoryErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            GetCallAnalyticsCategoryErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            GetCallAnalyticsCategoryErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            GetCallAnalyticsCategoryErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetCallAnalyticsCategoryErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for GetCallAnalyticsCategoryError {
    fn code(&self) -> Option<&str> {
        GetCallAnalyticsCategoryError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetCallAnalyticsCategoryError {
    /// Creates a new `GetCallAnalyticsCategoryError`.
    pub fn new(kind: GetCallAnalyticsCategoryErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `GetCallAnalyticsCategoryError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetCallAnalyticsCategoryErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `GetCallAnalyticsCategoryError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetCallAnalyticsCategoryErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `GetCallAnalyticsCategoryErrorKind::BadRequestException`.
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetCallAnalyticsCategoryErrorKind::BadRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `GetCallAnalyticsCategoryErrorKind::InternalFailureException`.
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetCallAnalyticsCategoryErrorKind::InternalFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `GetCallAnalyticsCategoryErrorKind::LimitExceededException`.
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetCallAnalyticsCategoryErrorKind::LimitExceededException(_)
        )
    }
    /// Returns `true` if the error kind is `GetCallAnalyticsCategoryErrorKind::NotFoundException`.
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetCallAnalyticsCategoryErrorKind::NotFoundException(_)
        )
    }
}
impl std::error::Error for GetCallAnalyticsCategoryError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetCallAnalyticsCategoryErrorKind::BadRequestException(_inner) => Some(_inner),
            GetCallAnalyticsCategoryErrorKind::InternalFailureException(_inner) => Some(_inner),
            GetCallAnalyticsCategoryErrorKind::LimitExceededException(_inner) => Some(_inner),
            GetCallAnalyticsCategoryErrorKind::NotFoundException(_inner) => Some(_inner),
            GetCallAnalyticsCategoryErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `GetCallAnalyticsJob` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetCallAnalyticsJobError {
    /// Kind of error that occurred.
    pub kind: GetCallAnalyticsJobErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `GetCallAnalyticsJob` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetCallAnalyticsJobErrorKind {
    /// <p>Your request didn't pass one or more validation tests. For example, if the entity that you're trying to delete
    /// doesn't exist or if it is in a non-terminal state (for example, it's "in progress"). See the exception <code>Message</code>
    /// field for more information.</p>
    BadRequestException(crate::error::BadRequestException),
    /// <p>There was an internal error. Check the error message and try your request again.</p>
    InternalFailureException(crate::error::InternalFailureException),
    /// <p>Either you have sent too many requests or your input file is too long. Wait before you resend your request, or
    /// use a smaller file and resend the request.</p>
    LimitExceededException(crate::error::LimitExceededException),
    /// <p>We can't find the requested resource. Check the name and try your request again.</p>
    NotFoundException(crate::error::NotFoundException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetCallAnalyticsJobError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetCallAnalyticsJobErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            GetCallAnalyticsJobErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            GetCallAnalyticsJobErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            GetCallAnalyticsJobErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetCallAnalyticsJobErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for GetCallAnalyticsJobError {
    fn code(&self) -> Option<&str> {
        GetCallAnalyticsJobError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetCallAnalyticsJobError {
    /// Creates a new `GetCallAnalyticsJobError`.
    pub fn new(kind: GetCallAnalyticsJobErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `GetCallAnalyticsJobError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetCallAnalyticsJobErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `GetCallAnalyticsJobError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetCallAnalyticsJobErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `GetCallAnalyticsJobErrorKind::BadRequestException`.
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetCallAnalyticsJobErrorKind::BadRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `GetCallAnalyticsJobErrorKind::InternalFailureException`.
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetCallAnalyticsJobErrorKind::InternalFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `GetCallAnalyticsJobErrorKind::LimitExceededException`.
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetCallAnalyticsJobErrorKind::LimitExceededException(_)
        )
    }
    /// Returns `true` if the error kind is `GetCallAnalyticsJobErrorKind::NotFoundException`.
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetCallAnalyticsJobErrorKind::NotFoundException(_)
        )
    }
}
impl std::error::Error for GetCallAnalyticsJobError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetCallAnalyticsJobErrorKind::BadRequestException(_inner) => Some(_inner),
            GetCallAnalyticsJobErrorKind::InternalFailureException(_inner) => Some(_inner),
            GetCallAnalyticsJobErrorKind::LimitExceededException(_inner) => Some(_inner),
            GetCallAnalyticsJobErrorKind::NotFoundException(_inner) => Some(_inner),
            GetCallAnalyticsJobErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `GetMedicalTranscriptionJob` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetMedicalTranscriptionJobError {
    /// Kind of error that occurred.
    pub kind: GetMedicalTranscriptionJobErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `GetMedicalTranscriptionJob` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetMedicalTranscriptionJobErrorKind {
    /// <p>Your request didn't pass one or more validation tests. For example, if the entity that you're trying to delete
    /// doesn't exist or if it is in a non-terminal state (for example, it's "in progress"). See the exception <code>Message</code>
    /// field for more information.</p>
    BadRequestException(crate::error::BadRequestException),
    /// <p>There was an internal error. Check the error message and try your request again.</p>
    InternalFailureException(crate::error::InternalFailureException),
    /// <p>Either you have sent too many requests or your input file is too long. Wait before you resend your request, or
    /// use a smaller file and resend the request.</p>
    LimitExceededException(crate::error::LimitExceededException),
    /// <p>We can't find the requested resource. Check the name and try your request again.</p>
    NotFoundException(crate::error::NotFoundException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetMedicalTranscriptionJobError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetMedicalTranscriptionJobErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            GetMedicalTranscriptionJobErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            GetMedicalTranscriptionJobErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            GetMedicalTranscriptionJobErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetMedicalTranscriptionJobErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for GetMedicalTranscriptionJobError {
    fn code(&self) -> Option<&str> {
        GetMedicalTranscriptionJobError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetMedicalTranscriptionJobError {
    /// Creates a new `GetMedicalTranscriptionJobError`.
    pub fn new(kind: GetMedicalTranscriptionJobErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `GetMedicalTranscriptionJobError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetMedicalTranscriptionJobErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `GetMedicalTranscriptionJobError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetMedicalTranscriptionJobErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `GetMedicalTranscriptionJobErrorKind::BadRequestException`.
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetMedicalTranscriptionJobErrorKind::BadRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `GetMedicalTranscriptionJobErrorKind::InternalFailureException`.
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetMedicalTranscriptionJobErrorKind::InternalFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `GetMedicalTranscriptionJobErrorKind::LimitExceededException`.
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetMedicalTranscriptionJobErrorKind::LimitExceededException(_)
        )
    }
    /// Returns `true` if the error kind is `GetMedicalTranscriptionJobErrorKind::NotFoundException`.
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetMedicalTranscriptionJobErrorKind::NotFoundException(_)
        )
    }
}
impl std::error::Error for GetMedicalTranscriptionJobError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetMedicalTranscriptionJobErrorKind::BadRequestException(_inner) => Some(_inner),
            GetMedicalTranscriptionJobErrorKind::InternalFailureException(_inner) => Some(_inner),
            GetMedicalTranscriptionJobErrorKind::LimitExceededException(_inner) => Some(_inner),
            GetMedicalTranscriptionJobErrorKind::NotFoundException(_inner) => Some(_inner),
            GetMedicalTranscriptionJobErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `GetMedicalVocabulary` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetMedicalVocabularyError {
    /// Kind of error that occurred.
    pub kind: GetMedicalVocabularyErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `GetMedicalVocabulary` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetMedicalVocabularyErrorKind {
    /// <p>Your request didn't pass one or more validation tests. For example, if the entity that you're trying to delete
    /// doesn't exist or if it is in a non-terminal state (for example, it's "in progress"). See the exception <code>Message</code>
    /// field for more information.</p>
    BadRequestException(crate::error::BadRequestException),
    /// <p>There was an internal error. Check the error message and try your request again.</p>
    InternalFailureException(crate::error::InternalFailureException),
    /// <p>Either you have sent too many requests or your input file is too long. Wait before you resend your request, or
    /// use a smaller file and resend the request.</p>
    LimitExceededException(crate::error::LimitExceededException),
    /// <p>We can't find the requested resource. Check the name and try your request again.</p>
    NotFoundException(crate::error::NotFoundException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetMedicalVocabularyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetMedicalVocabularyErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            GetMedicalVocabularyErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            GetMedicalVocabularyErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            GetMedicalVocabularyErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetMedicalVocabularyErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for GetMedicalVocabularyError {
    fn code(&self) -> Option<&str> {
        GetMedicalVocabularyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetMedicalVocabularyError {
    /// Creates a new `GetMedicalVocabularyError`.
    pub fn new(kind: GetMedicalVocabularyErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `GetMedicalVocabularyError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetMedicalVocabularyErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `GetMedicalVocabularyError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetMedicalVocabularyErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `GetMedicalVocabularyErrorKind::BadRequestException`.
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetMedicalVocabularyErrorKind::BadRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `GetMedicalVocabularyErrorKind::InternalFailureException`.
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetMedicalVocabularyErrorKind::InternalFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `GetMedicalVocabularyErrorKind::LimitExceededException`.
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetMedicalVocabularyErrorKind::LimitExceededException(_)
        )
    }
    /// Returns `true` if the error kind is `GetMedicalVocabularyErrorKind::NotFoundException`.
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetMedicalVocabularyErrorKind::NotFoundException(_)
        )
    }
}
impl std::error::Error for GetMedicalVocabularyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetMedicalVocabularyErrorKind::BadRequestException(_inner) => Some(_inner),
            GetMedicalVocabularyErrorKind::InternalFailureException(_inner) => Some(_inner),
            GetMedicalVocabularyErrorKind::LimitExceededException(_inner) => Some(_inner),
            GetMedicalVocabularyErrorKind::NotFoundException(_inner) => Some(_inner),
            GetMedicalVocabularyErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `GetTranscriptionJob` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetTranscriptionJobError {
    /// Kind of error that occurred.
    pub kind: GetTranscriptionJobErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `GetTranscriptionJob` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetTranscriptionJobErrorKind {
    /// <p>Your request didn't pass one or more validation tests. For example, if the entity that you're trying to delete
    /// doesn't exist or if it is in a non-terminal state (for example, it's "in progress"). See the exception <code>Message</code>
    /// field for more information.</p>
    BadRequestException(crate::error::BadRequestException),
    /// <p>There was an internal error. Check the error message and try your request again.</p>
    InternalFailureException(crate::error::InternalFailureException),
    /// <p>Either you have sent too many requests or your input file is too long. Wait before you resend your request, or
    /// use a smaller file and resend the request.</p>
    LimitExceededException(crate::error::LimitExceededException),
    /// <p>We can't find the requested resource. Check the name and try your request again.</p>
    NotFoundException(crate::error::NotFoundException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetTranscriptionJobError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetTranscriptionJobErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            GetTranscriptionJobErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            GetTranscriptionJobErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            GetTranscriptionJobErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetTranscriptionJobErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for GetTranscriptionJobError {
    fn code(&self) -> Option<&str> {
        GetTranscriptionJobError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetTranscriptionJobError {
    /// Creates a new `GetTranscriptionJobError`.
    pub fn new(kind: GetTranscriptionJobErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `GetTranscriptionJobError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetTranscriptionJobErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `GetTranscriptionJobError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetTranscriptionJobErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `GetTranscriptionJobErrorKind::BadRequestException`.
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetTranscriptionJobErrorKind::BadRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `GetTranscriptionJobErrorKind::InternalFailureException`.
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetTranscriptionJobErrorKind::InternalFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `GetTranscriptionJobErrorKind::LimitExceededException`.
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetTranscriptionJobErrorKind::LimitExceededException(_)
        )
    }
    /// Returns `true` if the error kind is `GetTranscriptionJobErrorKind::NotFoundException`.
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetTranscriptionJobErrorKind::NotFoundException(_)
        )
    }
}
impl std::error::Error for GetTranscriptionJobError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetTranscriptionJobErrorKind::BadRequestException(_inner) => Some(_inner),
            GetTranscriptionJobErrorKind::InternalFailureException(_inner) => Some(_inner),
            GetTranscriptionJobErrorKind::LimitExceededException(_inner) => Some(_inner),
            GetTranscriptionJobErrorKind::NotFoundException(_inner) => Some(_inner),
            GetTranscriptionJobErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `GetVocabulary` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetVocabularyError {
    /// Kind of error that occurred.
    pub kind: GetVocabularyErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `GetVocabulary` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetVocabularyErrorKind {
    /// <p>Your request didn't pass one or more validation tests. For example, if the entity that you're trying to delete
    /// doesn't exist or if it is in a non-terminal state (for example, it's "in progress"). See the exception <code>Message</code>
    /// field for more information.</p>
    BadRequestException(crate::error::BadRequestException),
    /// <p>There was an internal error. Check the error message and try your request again.</p>
    InternalFailureException(crate::error::InternalFailureException),
    /// <p>Either you have sent too many requests or your input file is too long. Wait before you resend your request, or
    /// use a smaller file and resend the request.</p>
    LimitExceededException(crate::error::LimitExceededException),
    /// <p>We can't find the requested resource. Check the name and try your request again.</p>
    NotFoundException(crate::error::NotFoundException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetVocabularyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetVocabularyErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            GetVocabularyErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            GetVocabularyErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            GetVocabularyErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetVocabularyErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for GetVocabularyError {
    fn code(&self) -> Option<&str> {
        GetVocabularyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetVocabularyError {
    /// Creates a new `GetVocabularyError`.
    pub fn new(kind: GetVocabularyErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `GetVocabularyError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetVocabularyErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `GetVocabularyError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetVocabularyErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `GetVocabularyErrorKind::BadRequestException`.
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, GetVocabularyErrorKind::BadRequestException(_))
    }
    /// Returns `true` if the error kind is `GetVocabularyErrorKind::InternalFailureException`.
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetVocabularyErrorKind::InternalFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `GetVocabularyErrorKind::LimitExceededException`.
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetVocabularyErrorKind::LimitExceededException(_)
        )
    }
    /// Returns `true` if the error kind is `GetVocabularyErrorKind::NotFoundException`.
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, GetVocabularyErrorKind::NotFoundException(_))
    }
}
impl std::error::Error for GetVocabularyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetVocabularyErrorKind::BadRequestException(_inner) => Some(_inner),
            GetVocabularyErrorKind::InternalFailureException(_inner) => Some(_inner),
            GetVocabularyErrorKind::LimitExceededException(_inner) => Some(_inner),
            GetVocabularyErrorKind::NotFoundException(_inner) => Some(_inner),
            GetVocabularyErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `GetVocabularyFilter` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetVocabularyFilterError {
    /// Kind of error that occurred.
    pub kind: GetVocabularyFilterErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `GetVocabularyFilter` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetVocabularyFilterErrorKind {
    /// <p>Your request didn't pass one or more validation tests. For example, if the entity that you're trying to delete
    /// doesn't exist or if it is in a non-terminal state (for example, it's "in progress"). See the exception <code>Message</code>
    /// field for more information.</p>
    BadRequestException(crate::error::BadRequestException),
    /// <p>There was an internal error. Check the error message and try your request again.</p>
    InternalFailureException(crate::error::InternalFailureException),
    /// <p>Either you have sent too many requests or your input file is too long. Wait before you resend your request, or
    /// use a smaller file and resend the request.</p>
    LimitExceededException(crate::error::LimitExceededException),
    /// <p>We can't find the requested resource. Check the name and try your request again.</p>
    NotFoundException(crate::error::NotFoundException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetVocabularyFilterError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetVocabularyFilterErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            GetVocabularyFilterErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            GetVocabularyFilterErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            GetVocabularyFilterErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetVocabularyFilterErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for GetVocabularyFilterError {
    fn code(&self) -> Option<&str> {
        GetVocabularyFilterError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetVocabularyFilterError {
    /// Creates a new `GetVocabularyFilterError`.
    pub fn new(kind: GetVocabularyFilterErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `GetVocabularyFilterError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetVocabularyFilterErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `GetVocabularyFilterError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetVocabularyFilterErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `GetVocabularyFilterErrorKind::BadRequestException`.
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetVocabularyFilterErrorKind::BadRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `GetVocabularyFilterErrorKind::InternalFailureException`.
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetVocabularyFilterErrorKind::InternalFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `GetVocabularyFilterErrorKind::LimitExceededException`.
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetVocabularyFilterErrorKind::LimitExceededException(_)
        )
    }
    /// Returns `true` if the error kind is `GetVocabularyFilterErrorKind::NotFoundException`.
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetVocabularyFilterErrorKind::NotFoundException(_)
        )
    }
}
impl std::error::Error for GetVocabularyFilterError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetVocabularyFilterErrorKind::BadRequestException(_inner) => Some(_inner),
            GetVocabularyFilterErrorKind::InternalFailureException(_inner) => Some(_inner),
            GetVocabularyFilterErrorKind::LimitExceededException(_inner) => Some(_inner),
            GetVocabularyFilterErrorKind::NotFoundException(_inner) => Some(_inner),
            GetVocabularyFilterErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `ListCallAnalyticsCategories` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListCallAnalyticsCategoriesError {
    /// Kind of error that occurred.
    pub kind: ListCallAnalyticsCategoriesErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `ListCallAnalyticsCategories` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListCallAnalyticsCategoriesErrorKind {
    /// <p>Your request didn't pass one or more validation tests. For example, if the entity that you're trying to delete
    /// doesn't exist or if it is in a non-terminal state (for example, it's "in progress"). See the exception <code>Message</code>
    /// field for more information.</p>
    BadRequestException(crate::error::BadRequestException),
    /// <p>There was an internal error. Check the error message and try your request again.</p>
    InternalFailureException(crate::error::InternalFailureException),
    /// <p>Either you have sent too many requests or your input file is too long. Wait before you resend your request, or
    /// use a smaller file and resend the request.</p>
    LimitExceededException(crate::error::LimitExceededException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListCallAnalyticsCategoriesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListCallAnalyticsCategoriesErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            ListCallAnalyticsCategoriesErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            ListCallAnalyticsCategoriesErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            ListCallAnalyticsCategoriesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ListCallAnalyticsCategoriesError {
    fn code(&self) -> Option<&str> {
        ListCallAnalyticsCategoriesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListCallAnalyticsCategoriesError {
    /// Creates a new `ListCallAnalyticsCategoriesError`.
    pub fn new(kind: ListCallAnalyticsCategoriesErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `ListCallAnalyticsCategoriesError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListCallAnalyticsCategoriesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `ListCallAnalyticsCategoriesError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListCallAnalyticsCategoriesErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `ListCallAnalyticsCategoriesErrorKind::BadRequestException`.
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListCallAnalyticsCategoriesErrorKind::BadRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `ListCallAnalyticsCategoriesErrorKind::InternalFailureException`.
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListCallAnalyticsCategoriesErrorKind::InternalFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `ListCallAnalyticsCategoriesErrorKind::LimitExceededException`.
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListCallAnalyticsCategoriesErrorKind::LimitExceededException(_)
        )
    }
}
impl std::error::Error for ListCallAnalyticsCategoriesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListCallAnalyticsCategoriesErrorKind::BadRequestException(_inner) => Some(_inner),
            ListCallAnalyticsCategoriesErrorKind::InternalFailureException(_inner) => Some(_inner),
            ListCallAnalyticsCategoriesErrorKind::LimitExceededException(_inner) => Some(_inner),
            ListCallAnalyticsCategoriesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `ListCallAnalyticsJobs` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListCallAnalyticsJobsError {
    /// Kind of error that occurred.
    pub kind: ListCallAnalyticsJobsErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `ListCallAnalyticsJobs` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListCallAnalyticsJobsErrorKind {
    /// <p>Your request didn't pass one or more validation tests. For example, if the entity that you're trying to delete
    /// doesn't exist or if it is in a non-terminal state (for example, it's "in progress"). See the exception <code>Message</code>
    /// field for more information.</p>
    BadRequestException(crate::error::BadRequestException),
    /// <p>There was an internal error. Check the error message and try your request again.</p>
    InternalFailureException(crate::error::InternalFailureException),
    /// <p>Either you have sent too many requests or your input file is too long. Wait before you resend your request, or
    /// use a smaller file and resend the request.</p>
    LimitExceededException(crate::error::LimitExceededException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListCallAnalyticsJobsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListCallAnalyticsJobsErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            ListCallAnalyticsJobsErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            ListCallAnalyticsJobsErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            ListCallAnalyticsJobsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ListCallAnalyticsJobsError {
    fn code(&self) -> Option<&str> {
        ListCallAnalyticsJobsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListCallAnalyticsJobsError {
    /// Creates a new `ListCallAnalyticsJobsError`.
    pub fn new(kind: ListCallAnalyticsJobsErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `ListCallAnalyticsJobsError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListCallAnalyticsJobsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `ListCallAnalyticsJobsError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListCallAnalyticsJobsErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `ListCallAnalyticsJobsErrorKind::BadRequestException`.
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListCallAnalyticsJobsErrorKind::BadRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `ListCallAnalyticsJobsErrorKind::InternalFailureException`.
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListCallAnalyticsJobsErrorKind::InternalFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `ListCallAnalyticsJobsErrorKind::LimitExceededException`.
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListCallAnalyticsJobsErrorKind::LimitExceededException(_)
        )
    }
}
impl std::error::Error for ListCallAnalyticsJobsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListCallAnalyticsJobsErrorKind::BadRequestException(_inner) => Some(_inner),
            ListCallAnalyticsJobsErrorKind::InternalFailureException(_inner) => Some(_inner),
            ListCallAnalyticsJobsErrorKind::LimitExceededException(_inner) => Some(_inner),
            ListCallAnalyticsJobsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `ListLanguageModels` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListLanguageModelsError {
    /// Kind of error that occurred.
    pub kind: ListLanguageModelsErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `ListLanguageModels` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListLanguageModelsErrorKind {
    /// <p>Your request didn't pass one or more validation tests. For example, if the entity that you're trying to delete
    /// doesn't exist or if it is in a non-terminal state (for example, it's "in progress"). See the exception <code>Message</code>
    /// field for more information.</p>
    BadRequestException(crate::error::BadRequestException),
    /// <p>There was an internal error. Check the error message and try your request again.</p>
    InternalFailureException(crate::error::InternalFailureException),
    /// <p>Either you have sent too many requests or your input file is too long. Wait before you resend your request, or
    /// use a smaller file and resend the request.</p>
    LimitExceededException(crate::error::LimitExceededException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListLanguageModelsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListLanguageModelsErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            ListLanguageModelsErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            ListLanguageModelsErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            ListLanguageModelsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ListLanguageModelsError {
    fn code(&self) -> Option<&str> {
        ListLanguageModelsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListLanguageModelsError {
    /// Creates a new `ListLanguageModelsError`.
    pub fn new(kind: ListLanguageModelsErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `ListLanguageModelsError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListLanguageModelsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `ListLanguageModelsError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListLanguageModelsErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `ListLanguageModelsErrorKind::BadRequestException`.
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListLanguageModelsErrorKind::BadRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `ListLanguageModelsErrorKind::InternalFailureException`.
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListLanguageModelsErrorKind::InternalFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `ListLanguageModelsErrorKind::LimitExceededException`.
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListLanguageModelsErrorKind::LimitExceededException(_)
        )
    }
}
impl std::error::Error for ListLanguageModelsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListLanguageModelsErrorKind::BadRequestException(_inner) => Some(_inner),
            ListLanguageModelsErrorKind::InternalFailureException(_inner) => Some(_inner),
            ListLanguageModelsErrorKind::LimitExceededException(_inner) => Some(_inner),
            ListLanguageModelsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `ListMedicalTranscriptionJobs` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListMedicalTranscriptionJobsError {
    /// Kind of error that occurred.
    pub kind: ListMedicalTranscriptionJobsErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `ListMedicalTranscriptionJobs` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListMedicalTranscriptionJobsErrorKind {
    /// <p>Your request didn't pass one or more validation tests. For example, if the entity that you're trying to delete
    /// doesn't exist or if it is in a non-terminal state (for example, it's "in progress"). See the exception <code>Message</code>
    /// field for more information.</p>
    BadRequestException(crate::error::BadRequestException),
    /// <p>There was an internal error. Check the error message and try your request again.</p>
    InternalFailureException(crate::error::InternalFailureException),
    /// <p>Either you have sent too many requests or your input file is too long. Wait before you resend your request, or
    /// use a smaller file and resend the request.</p>
    LimitExceededException(crate::error::LimitExceededException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListMedicalTranscriptionJobsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListMedicalTranscriptionJobsErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            ListMedicalTranscriptionJobsErrorKind::InternalFailureException(_inner) => {
                _inner.fmt(f)
            }
            ListMedicalTranscriptionJobsErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            ListMedicalTranscriptionJobsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ListMedicalTranscriptionJobsError {
    fn code(&self) -> Option<&str> {
        ListMedicalTranscriptionJobsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListMedicalTranscriptionJobsError {
    /// Creates a new `ListMedicalTranscriptionJobsError`.
    pub fn new(kind: ListMedicalTranscriptionJobsErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `ListMedicalTranscriptionJobsError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListMedicalTranscriptionJobsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `ListMedicalTranscriptionJobsError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListMedicalTranscriptionJobsErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `ListMedicalTranscriptionJobsErrorKind::BadRequestException`.
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListMedicalTranscriptionJobsErrorKind::BadRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `ListMedicalTranscriptionJobsErrorKind::InternalFailureException`.
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListMedicalTranscriptionJobsErrorKind::InternalFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `ListMedicalTranscriptionJobsErrorKind::LimitExceededException`.
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListMedicalTranscriptionJobsErrorKind::LimitExceededException(_)
        )
    }
}
impl std::error::Error for ListMedicalTranscriptionJobsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListMedicalTranscriptionJobsErrorKind::BadRequestException(_inner) => Some(_inner),
            ListMedicalTranscriptionJobsErrorKind::InternalFailureException(_inner) => Some(_inner),
            ListMedicalTranscriptionJobsErrorKind::LimitExceededException(_inner) => Some(_inner),
            ListMedicalTranscriptionJobsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `ListMedicalVocabularies` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListMedicalVocabulariesError {
    /// Kind of error that occurred.
    pub kind: ListMedicalVocabulariesErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `ListMedicalVocabularies` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListMedicalVocabulariesErrorKind {
    /// <p>Your request didn't pass one or more validation tests. For example, if the entity that you're trying to delete
    /// doesn't exist or if it is in a non-terminal state (for example, it's "in progress"). See the exception <code>Message</code>
    /// field for more information.</p>
    BadRequestException(crate::error::BadRequestException),
    /// <p>There was an internal error. Check the error message and try your request again.</p>
    InternalFailureException(crate::error::InternalFailureException),
    /// <p>Either you have sent too many requests or your input file is too long. Wait before you resend your request, or
    /// use a smaller file and resend the request.</p>
    LimitExceededException(crate::error::LimitExceededException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListMedicalVocabulariesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListMedicalVocabulariesErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            ListMedicalVocabulariesErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            ListMedicalVocabulariesErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            ListMedicalVocabulariesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ListMedicalVocabulariesError {
    fn code(&self) -> Option<&str> {
        ListMedicalVocabulariesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListMedicalVocabulariesError {
    /// Creates a new `ListMedicalVocabulariesError`.
    pub fn new(kind: ListMedicalVocabulariesErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `ListMedicalVocabulariesError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListMedicalVocabulariesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `ListMedicalVocabulariesError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListMedicalVocabulariesErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `ListMedicalVocabulariesErrorKind::BadRequestException`.
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListMedicalVocabulariesErrorKind::BadRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `ListMedicalVocabulariesErrorKind::InternalFailureException`.
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListMedicalVocabulariesErrorKind::InternalFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `ListMedicalVocabulariesErrorKind::LimitExceededException`.
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListMedicalVocabulariesErrorKind::LimitExceededException(_)
        )
    }
}
impl std::error::Error for ListMedicalVocabulariesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListMedicalVocabulariesErrorKind::BadRequestException(_inner) => Some(_inner),
            ListMedicalVocabulariesErrorKind::InternalFailureException(_inner) => Some(_inner),
            ListMedicalVocabulariesErrorKind::LimitExceededException(_inner) => Some(_inner),
            ListMedicalVocabulariesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `ListTagsForResource` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListTagsForResourceError {
    /// Kind of error that occurred.
    pub kind: ListTagsForResourceErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `ListTagsForResource` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListTagsForResourceErrorKind {
    /// <p>Your request didn't pass one or more validation tests. For example, if the entity that you're trying to delete
    /// doesn't exist or if it is in a non-terminal state (for example, it's "in progress"). See the exception <code>Message</code>
    /// field for more information.</p>
    BadRequestException(crate::error::BadRequestException),
    /// <p>There was an internal error. Check the error message and try your request again.</p>
    InternalFailureException(crate::error::InternalFailureException),
    /// <p>Either you have sent too many requests or your input file is too long. Wait before you resend your request, or
    /// use a smaller file and resend the request.</p>
    LimitExceededException(crate::error::LimitExceededException),
    /// <p>We can't find the requested resource. Check the name and try your request again.</p>
    NotFoundException(crate::error::NotFoundException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListTagsForResourceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListTagsForResourceErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            ListTagsForResourceErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            ListTagsForResourceErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            ListTagsForResourceErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            ListTagsForResourceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ListTagsForResourceError {
    fn code(&self) -> Option<&str> {
        ListTagsForResourceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListTagsForResourceError {
    /// Creates a new `ListTagsForResourceError`.
    pub fn new(kind: ListTagsForResourceErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `ListTagsForResourceError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListTagsForResourceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `ListTagsForResourceError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListTagsForResourceErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `ListTagsForResourceErrorKind::BadRequestException`.
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListTagsForResourceErrorKind::BadRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `ListTagsForResourceErrorKind::InternalFailureException`.
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListTagsForResourceErrorKind::InternalFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `ListTagsForResourceErrorKind::LimitExceededException`.
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListTagsForResourceErrorKind::LimitExceededException(_)
        )
    }
    /// Returns `true` if the error kind is `ListTagsForResourceErrorKind::NotFoundException`.
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListTagsForResourceErrorKind::NotFoundException(_)
        )
    }
}
impl std::error::Error for ListTagsForResourceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListTagsForResourceErrorKind::BadRequestException(_inner) => Some(_inner),
            ListTagsForResourceErrorKind::InternalFailureException(_inner) => Some(_inner),
            ListTagsForResourceErrorKind::LimitExceededException(_inner) => Some(_inner),
            ListTagsForResourceErrorKind::NotFoundException(_inner) => Some(_inner),
            ListTagsForResourceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `ListTranscriptionJobs` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListTranscriptionJobsError {
    /// Kind of error that occurred.
    pub kind: ListTranscriptionJobsErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `ListTranscriptionJobs` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListTranscriptionJobsErrorKind {
    /// <p>Your request didn't pass one or more validation tests. For example, if the entity that you're trying to delete
    /// doesn't exist or if it is in a non-terminal state (for example, it's "in progress"). See the exception <code>Message</code>
    /// field for more information.</p>
    BadRequestException(crate::error::BadRequestException),
    /// <p>There was an internal error. Check the error message and try your request again.</p>
    InternalFailureException(crate::error::InternalFailureException),
    /// <p>Either you have sent too many requests or your input file is too long. Wait before you resend your request, or
    /// use a smaller file and resend the request.</p>
    LimitExceededException(crate::error::LimitExceededException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListTranscriptionJobsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListTranscriptionJobsErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            ListTranscriptionJobsErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            ListTranscriptionJobsErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            ListTranscriptionJobsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ListTranscriptionJobsError {
    fn code(&self) -> Option<&str> {
        ListTranscriptionJobsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListTranscriptionJobsError {
    /// Creates a new `ListTranscriptionJobsError`.
    pub fn new(kind: ListTranscriptionJobsErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `ListTranscriptionJobsError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListTranscriptionJobsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `ListTranscriptionJobsError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListTranscriptionJobsErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `ListTranscriptionJobsErrorKind::BadRequestException`.
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListTranscriptionJobsErrorKind::BadRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `ListTranscriptionJobsErrorKind::InternalFailureException`.
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListTranscriptionJobsErrorKind::InternalFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `ListTranscriptionJobsErrorKind::LimitExceededException`.
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListTranscriptionJobsErrorKind::LimitExceededException(_)
        )
    }
}
impl std::error::Error for ListTranscriptionJobsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListTranscriptionJobsErrorKind::BadRequestException(_inner) => Some(_inner),
            ListTranscriptionJobsErrorKind::InternalFailureException(_inner) => Some(_inner),
            ListTranscriptionJobsErrorKind::LimitExceededException(_inner) => Some(_inner),
            ListTranscriptionJobsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `ListVocabularies` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListVocabulariesError {
    /// Kind of error that occurred.
    pub kind: ListVocabulariesErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `ListVocabularies` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListVocabulariesErrorKind {
    /// <p>Your request didn't pass one or more validation tests. For example, if the entity that you're trying to delete
    /// doesn't exist or if it is in a non-terminal state (for example, it's "in progress"). See the exception <code>Message</code>
    /// field for more information.</p>
    BadRequestException(crate::error::BadRequestException),
    /// <p>There was an internal error. Check the error message and try your request again.</p>
    InternalFailureException(crate::error::InternalFailureException),
    /// <p>Either you have sent too many requests or your input file is too long. Wait before you resend your request, or
    /// use a smaller file and resend the request.</p>
    LimitExceededException(crate::error::LimitExceededException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListVocabulariesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListVocabulariesErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            ListVocabulariesErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            ListVocabulariesErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            ListVocabulariesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ListVocabulariesError {
    fn code(&self) -> Option<&str> {
        ListVocabulariesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListVocabulariesError {
    /// Creates a new `ListVocabulariesError`.
    pub fn new(kind: ListVocabulariesErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `ListVocabulariesError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListVocabulariesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `ListVocabulariesError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListVocabulariesErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `ListVocabulariesErrorKind::BadRequestException`.
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListVocabulariesErrorKind::BadRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `ListVocabulariesErrorKind::InternalFailureException`.
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListVocabulariesErrorKind::InternalFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `ListVocabulariesErrorKind::LimitExceededException`.
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListVocabulariesErrorKind::LimitExceededException(_)
        )
    }
}
impl std::error::Error for ListVocabulariesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListVocabulariesErrorKind::BadRequestException(_inner) => Some(_inner),
            ListVocabulariesErrorKind::InternalFailureException(_inner) => Some(_inner),
            ListVocabulariesErrorKind::LimitExceededException(_inner) => Some(_inner),
            ListVocabulariesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `ListVocabularyFilters` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListVocabularyFiltersError {
    /// Kind of error that occurred.
    pub kind: ListVocabularyFiltersErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `ListVocabularyFilters` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListVocabularyFiltersErrorKind {
    /// <p>Your request didn't pass one or more validation tests. For example, if the entity that you're trying to delete
    /// doesn't exist or if it is in a non-terminal state (for example, it's "in progress"). See the exception <code>Message</code>
    /// field for more information.</p>
    BadRequestException(crate::error::BadRequestException),
    /// <p>There was an internal error. Check the error message and try your request again.</p>
    InternalFailureException(crate::error::InternalFailureException),
    /// <p>Either you have sent too many requests or your input file is too long. Wait before you resend your request, or
    /// use a smaller file and resend the request.</p>
    LimitExceededException(crate::error::LimitExceededException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListVocabularyFiltersError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListVocabularyFiltersErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            ListVocabularyFiltersErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            ListVocabularyFiltersErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            ListVocabularyFiltersErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ListVocabularyFiltersError {
    fn code(&self) -> Option<&str> {
        ListVocabularyFiltersError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListVocabularyFiltersError {
    /// Creates a new `ListVocabularyFiltersError`.
    pub fn new(kind: ListVocabularyFiltersErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `ListVocabularyFiltersError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListVocabularyFiltersErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `ListVocabularyFiltersError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListVocabularyFiltersErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `ListVocabularyFiltersErrorKind::BadRequestException`.
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListVocabularyFiltersErrorKind::BadRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `ListVocabularyFiltersErrorKind::InternalFailureException`.
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListVocabularyFiltersErrorKind::InternalFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `ListVocabularyFiltersErrorKind::LimitExceededException`.
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListVocabularyFiltersErrorKind::LimitExceededException(_)
        )
    }
}
impl std::error::Error for ListVocabularyFiltersError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListVocabularyFiltersErrorKind::BadRequestException(_inner) => Some(_inner),
            ListVocabularyFiltersErrorKind::InternalFailureException(_inner) => Some(_inner),
            ListVocabularyFiltersErrorKind::LimitExceededException(_inner) => Some(_inner),
            ListVocabularyFiltersErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `StartCallAnalyticsJob` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct StartCallAnalyticsJobError {
    /// Kind of error that occurred.
    pub kind: StartCallAnalyticsJobErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `StartCallAnalyticsJob` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum StartCallAnalyticsJobErrorKind {
    /// <p>Your request didn't pass one or more validation tests. For example, if the entity that you're trying to delete
    /// doesn't exist or if it is in a non-terminal state (for example, it's "in progress"). See the exception <code>Message</code>
    /// field for more information.</p>
    BadRequestException(crate::error::BadRequestException),
    /// <p>There is already a resource with that name.</p>
    ConflictException(crate::error::ConflictException),
    /// <p>There was an internal error. Check the error message and try your request again.</p>
    InternalFailureException(crate::error::InternalFailureException),
    /// <p>Either you have sent too many requests or your input file is too long. Wait before you resend your request, or
    /// use a smaller file and resend the request.</p>
    LimitExceededException(crate::error::LimitExceededException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for StartCallAnalyticsJobError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            StartCallAnalyticsJobErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            StartCallAnalyticsJobErrorKind::ConflictException(_inner) => _inner.fmt(f),
            StartCallAnalyticsJobErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            StartCallAnalyticsJobErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            StartCallAnalyticsJobErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for StartCallAnalyticsJobError {
    fn code(&self) -> Option<&str> {
        StartCallAnalyticsJobError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl StartCallAnalyticsJobError {
    /// Creates a new `StartCallAnalyticsJobError`.
    pub fn new(kind: StartCallAnalyticsJobErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `StartCallAnalyticsJobError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: StartCallAnalyticsJobErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `StartCallAnalyticsJobError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: StartCallAnalyticsJobErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `StartCallAnalyticsJobErrorKind::BadRequestException`.
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartCallAnalyticsJobErrorKind::BadRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `StartCallAnalyticsJobErrorKind::ConflictException`.
    pub fn is_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartCallAnalyticsJobErrorKind::ConflictException(_)
        )
    }
    /// Returns `true` if the error kind is `StartCallAnalyticsJobErrorKind::InternalFailureException`.
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartCallAnalyticsJobErrorKind::InternalFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `StartCallAnalyticsJobErrorKind::LimitExceededException`.
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartCallAnalyticsJobErrorKind::LimitExceededException(_)
        )
    }
}
impl std::error::Error for StartCallAnalyticsJobError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            StartCallAnalyticsJobErrorKind::BadRequestException(_inner) => Some(_inner),
            StartCallAnalyticsJobErrorKind::ConflictException(_inner) => Some(_inner),
            StartCallAnalyticsJobErrorKind::InternalFailureException(_inner) => Some(_inner),
            StartCallAnalyticsJobErrorKind::LimitExceededException(_inner) => Some(_inner),
            StartCallAnalyticsJobErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `StartMedicalTranscriptionJob` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct StartMedicalTranscriptionJobError {
    /// Kind of error that occurred.
    pub kind: StartMedicalTranscriptionJobErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `StartMedicalTranscriptionJob` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum StartMedicalTranscriptionJobErrorKind {
    /// <p>Your request didn't pass one or more validation tests. For example, if the entity that you're trying to delete
    /// doesn't exist or if it is in a non-terminal state (for example, it's "in progress"). See the exception <code>Message</code>
    /// field for more information.</p>
    BadRequestException(crate::error::BadRequestException),
    /// <p>There is already a resource with that name.</p>
    ConflictException(crate::error::ConflictException),
    /// <p>There was an internal error. Check the error message and try your request again.</p>
    InternalFailureException(crate::error::InternalFailureException),
    /// <p>Either you have sent too many requests or your input file is too long. Wait before you resend your request, or
    /// use a smaller file and resend the request.</p>
    LimitExceededException(crate::error::LimitExceededException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for StartMedicalTranscriptionJobError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            StartMedicalTranscriptionJobErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            StartMedicalTranscriptionJobErrorKind::ConflictException(_inner) => _inner.fmt(f),
            StartMedicalTranscriptionJobErrorKind::InternalFailureException(_inner) => {
                _inner.fmt(f)
            }
            StartMedicalTranscriptionJobErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            StartMedicalTranscriptionJobErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for StartMedicalTranscriptionJobError {
    fn code(&self) -> Option<&str> {
        StartMedicalTranscriptionJobError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl StartMedicalTranscriptionJobError {
    /// Creates a new `StartMedicalTranscriptionJobError`.
    pub fn new(kind: StartMedicalTranscriptionJobErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `StartMedicalTranscriptionJobError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: StartMedicalTranscriptionJobErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `StartMedicalTranscriptionJobError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: StartMedicalTranscriptionJobErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `StartMedicalTranscriptionJobErrorKind::BadRequestException`.
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartMedicalTranscriptionJobErrorKind::BadRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `StartMedicalTranscriptionJobErrorKind::ConflictException`.
    pub fn is_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartMedicalTranscriptionJobErrorKind::ConflictException(_)
        )
    }
    /// Returns `true` if the error kind is `StartMedicalTranscriptionJobErrorKind::InternalFailureException`.
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartMedicalTranscriptionJobErrorKind::InternalFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `StartMedicalTranscriptionJobErrorKind::LimitExceededException`.
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartMedicalTranscriptionJobErrorKind::LimitExceededException(_)
        )
    }
}
impl std::error::Error for StartMedicalTranscriptionJobError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            StartMedicalTranscriptionJobErrorKind::BadRequestException(_inner) => Some(_inner),
            StartMedicalTranscriptionJobErrorKind::ConflictException(_inner) => Some(_inner),
            StartMedicalTranscriptionJobErrorKind::InternalFailureException(_inner) => Some(_inner),
            StartMedicalTranscriptionJobErrorKind::LimitExceededException(_inner) => Some(_inner),
            StartMedicalTranscriptionJobErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `StartTranscriptionJob` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct StartTranscriptionJobError {
    /// Kind of error that occurred.
    pub kind: StartTranscriptionJobErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `StartTranscriptionJob` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum StartTranscriptionJobErrorKind {
    /// <p>Your request didn't pass one or more validation tests. For example, if the entity that you're trying to delete
    /// doesn't exist or if it is in a non-terminal state (for example, it's "in progress"). See the exception <code>Message</code>
    /// field for more information.</p>
    BadRequestException(crate::error::BadRequestException),
    /// <p>There is already a resource with that name.</p>
    ConflictException(crate::error::ConflictException),
    /// <p>There was an internal error. Check the error message and try your request again.</p>
    InternalFailureException(crate::error::InternalFailureException),
    /// <p>Either you have sent too many requests or your input file is too long. Wait before you resend your request, or
    /// use a smaller file and resend the request.</p>
    LimitExceededException(crate::error::LimitExceededException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for StartTranscriptionJobError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            StartTranscriptionJobErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            StartTranscriptionJobErrorKind::ConflictException(_inner) => _inner.fmt(f),
            StartTranscriptionJobErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            StartTranscriptionJobErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            StartTranscriptionJobErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for StartTranscriptionJobError {
    fn code(&self) -> Option<&str> {
        StartTranscriptionJobError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl StartTranscriptionJobError {
    /// Creates a new `StartTranscriptionJobError`.
    pub fn new(kind: StartTranscriptionJobErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `StartTranscriptionJobError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: StartTranscriptionJobErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `StartTranscriptionJobError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: StartTranscriptionJobErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `StartTranscriptionJobErrorKind::BadRequestException`.
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartTranscriptionJobErrorKind::BadRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `StartTranscriptionJobErrorKind::ConflictException`.
    pub fn is_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartTranscriptionJobErrorKind::ConflictException(_)
        )
    }
    /// Returns `true` if the error kind is `StartTranscriptionJobErrorKind::InternalFailureException`.
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartTranscriptionJobErrorKind::InternalFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `StartTranscriptionJobErrorKind::LimitExceededException`.
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartTranscriptionJobErrorKind::LimitExceededException(_)
        )
    }
}
impl std::error::Error for StartTranscriptionJobError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            StartTranscriptionJobErrorKind::BadRequestException(_inner) => Some(_inner),
            StartTranscriptionJobErrorKind::ConflictException(_inner) => Some(_inner),
            StartTranscriptionJobErrorKind::InternalFailureException(_inner) => Some(_inner),
            StartTranscriptionJobErrorKind::LimitExceededException(_inner) => Some(_inner),
            StartTranscriptionJobErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `TagResource` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct TagResourceError {
    /// Kind of error that occurred.
    pub kind: TagResourceErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `TagResource` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum TagResourceErrorKind {
    /// <p>Your request didn't pass one or more validation tests. For example, if the entity that you're trying to delete
    /// doesn't exist or if it is in a non-terminal state (for example, it's "in progress"). See the exception <code>Message</code>
    /// field for more information.</p>
    BadRequestException(crate::error::BadRequestException),
    /// <p>There is already a resource with that name.</p>
    ConflictException(crate::error::ConflictException),
    /// <p>There was an internal error. Check the error message and try your request again.</p>
    InternalFailureException(crate::error::InternalFailureException),
    /// <p>Either you have sent too many requests or your input file is too long. Wait before you resend your request, or
    /// use a smaller file and resend the request.</p>
    LimitExceededException(crate::error::LimitExceededException),
    /// <p>We can't find the requested resource. Check the name and try your request again.</p>
    NotFoundException(crate::error::NotFoundException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for TagResourceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            TagResourceErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            TagResourceErrorKind::ConflictException(_inner) => _inner.fmt(f),
            TagResourceErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            TagResourceErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            TagResourceErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            TagResourceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for TagResourceError {
    fn code(&self) -> Option<&str> {
        TagResourceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl TagResourceError {
    /// Creates a new `TagResourceError`.
    pub fn new(kind: TagResourceErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `TagResourceError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: TagResourceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `TagResourceError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: TagResourceErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `TagResourceErrorKind::BadRequestException`.
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, TagResourceErrorKind::BadRequestException(_))
    }
    /// Returns `true` if the error kind is `TagResourceErrorKind::ConflictException`.
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, TagResourceErrorKind::ConflictException(_))
    }
    /// Returns `true` if the error kind is `TagResourceErrorKind::InternalFailureException`.
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            TagResourceErrorKind::InternalFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `TagResourceErrorKind::LimitExceededException`.
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(&self.kind, TagResourceErrorKind::LimitExceededException(_))
    }
    /// Returns `true` if the error kind is `TagResourceErrorKind::NotFoundException`.
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, TagResourceErrorKind::NotFoundException(_))
    }
}
impl std::error::Error for TagResourceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            TagResourceErrorKind::BadRequestException(_inner) => Some(_inner),
            TagResourceErrorKind::ConflictException(_inner) => Some(_inner),
            TagResourceErrorKind::InternalFailureException(_inner) => Some(_inner),
            TagResourceErrorKind::LimitExceededException(_inner) => Some(_inner),
            TagResourceErrorKind::NotFoundException(_inner) => Some(_inner),
            TagResourceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `UntagResource` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UntagResourceError {
    /// Kind of error that occurred.
    pub kind: UntagResourceErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `UntagResource` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UntagResourceErrorKind {
    /// <p>Your request didn't pass one or more validation tests. For example, if the entity that you're trying to delete
    /// doesn't exist or if it is in a non-terminal state (for example, it's "in progress"). See the exception <code>Message</code>
    /// field for more information.</p>
    BadRequestException(crate::error::BadRequestException),
    /// <p>There is already a resource with that name.</p>
    ConflictException(crate::error::ConflictException),
    /// <p>There was an internal error. Check the error message and try your request again.</p>
    InternalFailureException(crate::error::InternalFailureException),
    /// <p>Either you have sent too many requests or your input file is too long. Wait before you resend your request, or
    /// use a smaller file and resend the request.</p>
    LimitExceededException(crate::error::LimitExceededException),
    /// <p>We can't find the requested resource. Check the name and try your request again.</p>
    NotFoundException(crate::error::NotFoundException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UntagResourceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UntagResourceErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            UntagResourceErrorKind::ConflictException(_inner) => _inner.fmt(f),
            UntagResourceErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            UntagResourceErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            UntagResourceErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            UntagResourceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for UntagResourceError {
    fn code(&self) -> Option<&str> {
        UntagResourceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl UntagResourceError {
    /// Creates a new `UntagResourceError`.
    pub fn new(kind: UntagResourceErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `UntagResourceError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UntagResourceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `UntagResourceError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UntagResourceErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `UntagResourceErrorKind::BadRequestException`.
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, UntagResourceErrorKind::BadRequestException(_))
    }
    /// Returns `true` if the error kind is `UntagResourceErrorKind::ConflictException`.
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, UntagResourceErrorKind::ConflictException(_))
    }
    /// Returns `true` if the error kind is `UntagResourceErrorKind::InternalFailureException`.
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            UntagResourceErrorKind::InternalFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `UntagResourceErrorKind::LimitExceededException`.
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            UntagResourceErrorKind::LimitExceededException(_)
        )
    }
    /// Returns `true` if the error kind is `UntagResourceErrorKind::NotFoundException`.
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, UntagResourceErrorKind::NotFoundException(_))
    }
}
impl std::error::Error for UntagResourceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UntagResourceErrorKind::BadRequestException(_inner) => Some(_inner),
            UntagResourceErrorKind::ConflictException(_inner) => Some(_inner),
            UntagResourceErrorKind::InternalFailureException(_inner) => Some(_inner),
            UntagResourceErrorKind::LimitExceededException(_inner) => Some(_inner),
            UntagResourceErrorKind::NotFoundException(_inner) => Some(_inner),
            UntagResourceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `UpdateCallAnalyticsCategory` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateCallAnalyticsCategoryError {
    /// Kind of error that occurred.
    pub kind: UpdateCallAnalyticsCategoryErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `UpdateCallAnalyticsCategory` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateCallAnalyticsCategoryErrorKind {
    /// <p>Your request didn't pass one or more validation tests. For example, if the entity that you're trying to delete
    /// doesn't exist or if it is in a non-terminal state (for example, it's "in progress"). See the exception <code>Message</code>
    /// field for more information.</p>
    BadRequestException(crate::error::BadRequestException),
    /// <p>There is already a resource with that name.</p>
    ConflictException(crate::error::ConflictException),
    /// <p>There was an internal error. Check the error message and try your request again.</p>
    InternalFailureException(crate::error::InternalFailureException),
    /// <p>Either you have sent too many requests or your input file is too long. Wait before you resend your request, or
    /// use a smaller file and resend the request.</p>
    LimitExceededException(crate::error::LimitExceededException),
    /// <p>We can't find the requested resource. Check the name and try your request again.</p>
    NotFoundException(crate::error::NotFoundException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateCallAnalyticsCategoryError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateCallAnalyticsCategoryErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            UpdateCallAnalyticsCategoryErrorKind::ConflictException(_inner) => _inner.fmt(f),
            UpdateCallAnalyticsCategoryErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            UpdateCallAnalyticsCategoryErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            UpdateCallAnalyticsCategoryErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            UpdateCallAnalyticsCategoryErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for UpdateCallAnalyticsCategoryError {
    fn code(&self) -> Option<&str> {
        UpdateCallAnalyticsCategoryError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateCallAnalyticsCategoryError {
    /// Creates a new `UpdateCallAnalyticsCategoryError`.
    pub fn new(kind: UpdateCallAnalyticsCategoryErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `UpdateCallAnalyticsCategoryError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateCallAnalyticsCategoryErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `UpdateCallAnalyticsCategoryError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateCallAnalyticsCategoryErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `UpdateCallAnalyticsCategoryErrorKind::BadRequestException`.
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateCallAnalyticsCategoryErrorKind::BadRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdateCallAnalyticsCategoryErrorKind::ConflictException`.
    pub fn is_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateCallAnalyticsCategoryErrorKind::ConflictException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdateCallAnalyticsCategoryErrorKind::InternalFailureException`.
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateCallAnalyticsCategoryErrorKind::InternalFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdateCallAnalyticsCategoryErrorKind::LimitExceededException`.
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateCallAnalyticsCategoryErrorKind::LimitExceededException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdateCallAnalyticsCategoryErrorKind::NotFoundException`.
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateCallAnalyticsCategoryErrorKind::NotFoundException(_)
        )
    }
}
impl std::error::Error for UpdateCallAnalyticsCategoryError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateCallAnalyticsCategoryErrorKind::BadRequestException(_inner) => Some(_inner),
            UpdateCallAnalyticsCategoryErrorKind::ConflictException(_inner) => Some(_inner),
            UpdateCallAnalyticsCategoryErrorKind::InternalFailureException(_inner) => Some(_inner),
            UpdateCallAnalyticsCategoryErrorKind::LimitExceededException(_inner) => Some(_inner),
            UpdateCallAnalyticsCategoryErrorKind::NotFoundException(_inner) => Some(_inner),
            UpdateCallAnalyticsCategoryErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `UpdateMedicalVocabulary` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateMedicalVocabularyError {
    /// Kind of error that occurred.
    pub kind: UpdateMedicalVocabularyErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `UpdateMedicalVocabulary` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateMedicalVocabularyErrorKind {
    /// <p>Your request didn't pass one or more validation tests. For example, if the entity that you're trying to delete
    /// doesn't exist or if it is in a non-terminal state (for example, it's "in progress"). See the exception <code>Message</code>
    /// field for more information.</p>
    BadRequestException(crate::error::BadRequestException),
    /// <p>There is already a resource with that name.</p>
    ConflictException(crate::error::ConflictException),
    /// <p>There was an internal error. Check the error message and try your request again.</p>
    InternalFailureException(crate::error::InternalFailureException),
    /// <p>Either you have sent too many requests or your input file is too long. Wait before you resend your request, or
    /// use a smaller file and resend the request.</p>
    LimitExceededException(crate::error::LimitExceededException),
    /// <p>We can't find the requested resource. Check the name and try your request again.</p>
    NotFoundException(crate::error::NotFoundException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateMedicalVocabularyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateMedicalVocabularyErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            UpdateMedicalVocabularyErrorKind::ConflictException(_inner) => _inner.fmt(f),
            UpdateMedicalVocabularyErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            UpdateMedicalVocabularyErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            UpdateMedicalVocabularyErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            UpdateMedicalVocabularyErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for UpdateMedicalVocabularyError {
    fn code(&self) -> Option<&str> {
        UpdateMedicalVocabularyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateMedicalVocabularyError {
    /// Creates a new `UpdateMedicalVocabularyError`.
    pub fn new(kind: UpdateMedicalVocabularyErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `UpdateMedicalVocabularyError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateMedicalVocabularyErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `UpdateMedicalVocabularyError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateMedicalVocabularyErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `UpdateMedicalVocabularyErrorKind::BadRequestException`.
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateMedicalVocabularyErrorKind::BadRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdateMedicalVocabularyErrorKind::ConflictException`.
    pub fn is_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateMedicalVocabularyErrorKind::ConflictException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdateMedicalVocabularyErrorKind::InternalFailureException`.
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateMedicalVocabularyErrorKind::InternalFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdateMedicalVocabularyErrorKind::LimitExceededException`.
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateMedicalVocabularyErrorKind::LimitExceededException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdateMedicalVocabularyErrorKind::NotFoundException`.
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateMedicalVocabularyErrorKind::NotFoundException(_)
        )
    }
}
impl std::error::Error for UpdateMedicalVocabularyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateMedicalVocabularyErrorKind::BadRequestException(_inner) => Some(_inner),
            UpdateMedicalVocabularyErrorKind::ConflictException(_inner) => Some(_inner),
            UpdateMedicalVocabularyErrorKind::InternalFailureException(_inner) => Some(_inner),
            UpdateMedicalVocabularyErrorKind::LimitExceededException(_inner) => Some(_inner),
            UpdateMedicalVocabularyErrorKind::NotFoundException(_inner) => Some(_inner),
            UpdateMedicalVocabularyErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `UpdateVocabulary` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateVocabularyError {
    /// Kind of error that occurred.
    pub kind: UpdateVocabularyErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `UpdateVocabulary` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateVocabularyErrorKind {
    /// <p>Your request didn't pass one or more validation tests. For example, if the entity that you're trying to delete
    /// doesn't exist or if it is in a non-terminal state (for example, it's "in progress"). See the exception <code>Message</code>
    /// field for more information.</p>
    BadRequestException(crate::error::BadRequestException),
    /// <p>There is already a resource with that name.</p>
    ConflictException(crate::error::ConflictException),
    /// <p>There was an internal error. Check the error message and try your request again.</p>
    InternalFailureException(crate::error::InternalFailureException),
    /// <p>Either you have sent too many requests or your input file is too long. Wait before you resend your request, or
    /// use a smaller file and resend the request.</p>
    LimitExceededException(crate::error::LimitExceededException),
    /// <p>We can't find the requested resource. Check the name and try your request again.</p>
    NotFoundException(crate::error::NotFoundException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateVocabularyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateVocabularyErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            UpdateVocabularyErrorKind::ConflictException(_inner) => _inner.fmt(f),
            UpdateVocabularyErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            UpdateVocabularyErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            UpdateVocabularyErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            UpdateVocabularyErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for UpdateVocabularyError {
    fn code(&self) -> Option<&str> {
        UpdateVocabularyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateVocabularyError {
    /// Creates a new `UpdateVocabularyError`.
    pub fn new(kind: UpdateVocabularyErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `UpdateVocabularyError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateVocabularyErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `UpdateVocabularyError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateVocabularyErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `UpdateVocabularyErrorKind::BadRequestException`.
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateVocabularyErrorKind::BadRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdateVocabularyErrorKind::ConflictException`.
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, UpdateVocabularyErrorKind::ConflictException(_))
    }
    /// Returns `true` if the error kind is `UpdateVocabularyErrorKind::InternalFailureException`.
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateVocabularyErrorKind::InternalFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdateVocabularyErrorKind::LimitExceededException`.
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateVocabularyErrorKind::LimitExceededException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdateVocabularyErrorKind::NotFoundException`.
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, UpdateVocabularyErrorKind::NotFoundException(_))
    }
}
impl std::error::Error for UpdateVocabularyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateVocabularyErrorKind::BadRequestException(_inner) => Some(_inner),
            UpdateVocabularyErrorKind::ConflictException(_inner) => Some(_inner),
            UpdateVocabularyErrorKind::InternalFailureException(_inner) => Some(_inner),
            UpdateVocabularyErrorKind::LimitExceededException(_inner) => Some(_inner),
            UpdateVocabularyErrorKind::NotFoundException(_inner) => Some(_inner),
            UpdateVocabularyErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `UpdateVocabularyFilter` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateVocabularyFilterError {
    /// Kind of error that occurred.
    pub kind: UpdateVocabularyFilterErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `UpdateVocabularyFilter` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateVocabularyFilterErrorKind {
    /// <p>Your request didn't pass one or more validation tests. For example, if the entity that you're trying to delete
    /// doesn't exist or if it is in a non-terminal state (for example, it's "in progress"). See the exception <code>Message</code>
    /// field for more information.</p>
    BadRequestException(crate::error::BadRequestException),
    /// <p>There was an internal error. Check the error message and try your request again.</p>
    InternalFailureException(crate::error::InternalFailureException),
    /// <p>Either you have sent too many requests or your input file is too long. Wait before you resend your request, or
    /// use a smaller file and resend the request.</p>
    LimitExceededException(crate::error::LimitExceededException),
    /// <p>We can't find the requested resource. Check the name and try your request again.</p>
    NotFoundException(crate::error::NotFoundException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateVocabularyFilterError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateVocabularyFilterErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            UpdateVocabularyFilterErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            UpdateVocabularyFilterErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            UpdateVocabularyFilterErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            UpdateVocabularyFilterErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for UpdateVocabularyFilterError {
    fn code(&self) -> Option<&str> {
        UpdateVocabularyFilterError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateVocabularyFilterError {
    /// Creates a new `UpdateVocabularyFilterError`.
    pub fn new(kind: UpdateVocabularyFilterErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `UpdateVocabularyFilterError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateVocabularyFilterErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `UpdateVocabularyFilterError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateVocabularyFilterErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `UpdateVocabularyFilterErrorKind::BadRequestException`.
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateVocabularyFilterErrorKind::BadRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdateVocabularyFilterErrorKind::InternalFailureException`.
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateVocabularyFilterErrorKind::InternalFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdateVocabularyFilterErrorKind::LimitExceededException`.
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateVocabularyFilterErrorKind::LimitExceededException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdateVocabularyFilterErrorKind::NotFoundException`.
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateVocabularyFilterErrorKind::NotFoundException(_)
        )
    }
}
impl std::error::Error for UpdateVocabularyFilterError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateVocabularyFilterErrorKind::BadRequestException(_inner) => Some(_inner),
            UpdateVocabularyFilterErrorKind::InternalFailureException(_inner) => Some(_inner),
            UpdateVocabularyFilterErrorKind::LimitExceededException(_inner) => Some(_inner),
            UpdateVocabularyFilterErrorKind::NotFoundException(_inner) => Some(_inner),
            UpdateVocabularyFilterErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// <p>We can't find the requested resource. Check the name and try your request again.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct NotFoundException {
    #[allow(missing_docs)] // documentation missing in model
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for NotFoundException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("NotFoundException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl NotFoundException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for NotFoundException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "NotFoundException")?;
        if let Some(inner_1) = &self.message {
            write!(f, ": {}", inner_1)?;
        }
        Ok(())
    }
}
impl std::error::Error for NotFoundException {}
/// See [`NotFoundException`](crate::error::NotFoundException)
pub mod not_found_exception {
    /// A builder for [`NotFoundException`](crate::error::NotFoundException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`NotFoundException`](crate::error::NotFoundException)
        pub fn build(self) -> crate::error::NotFoundException {
            crate::error::NotFoundException {
                message: self.message,
            }
        }
    }
}
impl NotFoundException {
    /// Creates a new builder-style object to manufacture [`NotFoundException`](crate::error::NotFoundException)
    pub fn builder() -> crate::error::not_found_exception::Builder {
        crate::error::not_found_exception::Builder::default()
    }
}

/// <p>Either you have sent too many requests or your input file is too long. Wait before you resend your request, or
/// use a smaller file and resend the request.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct LimitExceededException {
    #[allow(missing_docs)] // documentation missing in model
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for LimitExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("LimitExceededException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl LimitExceededException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for LimitExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "LimitExceededException")?;
        if let Some(inner_2) = &self.message {
            write!(f, ": {}", inner_2)?;
        }
        Ok(())
    }
}
impl std::error::Error for LimitExceededException {}
/// See [`LimitExceededException`](crate::error::LimitExceededException)
pub mod limit_exceeded_exception {
    /// A builder for [`LimitExceededException`](crate::error::LimitExceededException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`LimitExceededException`](crate::error::LimitExceededException)
        pub fn build(self) -> crate::error::LimitExceededException {
            crate::error::LimitExceededException {
                message: self.message,
            }
        }
    }
}
impl LimitExceededException {
    /// Creates a new builder-style object to manufacture [`LimitExceededException`](crate::error::LimitExceededException)
    pub fn builder() -> crate::error::limit_exceeded_exception::Builder {
        crate::error::limit_exceeded_exception::Builder::default()
    }
}

/// <p>There was an internal error. Check the error message and try your request again.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InternalFailureException {
    #[allow(missing_docs)] // documentation missing in model
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InternalFailureException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InternalFailureException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InternalFailureException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InternalFailureException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InternalFailureException")?;
        if let Some(inner_3) = &self.message {
            write!(f, ": {}", inner_3)?;
        }
        Ok(())
    }
}
impl std::error::Error for InternalFailureException {}
/// See [`InternalFailureException`](crate::error::InternalFailureException)
pub mod internal_failure_exception {
    /// A builder for [`InternalFailureException`](crate::error::InternalFailureException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InternalFailureException`](crate::error::InternalFailureException)
        pub fn build(self) -> crate::error::InternalFailureException {
            crate::error::InternalFailureException {
                message: self.message,
            }
        }
    }
}
impl InternalFailureException {
    /// Creates a new builder-style object to manufacture [`InternalFailureException`](crate::error::InternalFailureException)
    pub fn builder() -> crate::error::internal_failure_exception::Builder {
        crate::error::internal_failure_exception::Builder::default()
    }
}

/// <p>Your request didn't pass one or more validation tests. For example, if the entity that you're trying to delete
/// doesn't exist or if it is in a non-terminal state (for example, it's "in progress"). See the exception <code>Message</code>
/// field for more information.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct BadRequestException {
    #[allow(missing_docs)] // documentation missing in model
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for BadRequestException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("BadRequestException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl BadRequestException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for BadRequestException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "BadRequestException")?;
        if let Some(inner_4) = &self.message {
            write!(f, ": {}", inner_4)?;
        }
        Ok(())
    }
}
impl std::error::Error for BadRequestException {}
/// See [`BadRequestException`](crate::error::BadRequestException)
pub mod bad_request_exception {
    /// A builder for [`BadRequestException`](crate::error::BadRequestException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`BadRequestException`](crate::error::BadRequestException)
        pub fn build(self) -> crate::error::BadRequestException {
            crate::error::BadRequestException {
                message: self.message,
            }
        }
    }
}
impl BadRequestException {
    /// Creates a new builder-style object to manufacture [`BadRequestException`](crate::error::BadRequestException)
    pub fn builder() -> crate::error::bad_request_exception::Builder {
        crate::error::bad_request_exception::Builder::default()
    }
}

/// <p>There is already a resource with that name.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ConflictException {
    #[allow(missing_docs)] // documentation missing in model
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ConflictException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ConflictException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ConflictException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ConflictException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ConflictException")?;
        if let Some(inner_5) = &self.message {
            write!(f, ": {}", inner_5)?;
        }
        Ok(())
    }
}
impl std::error::Error for ConflictException {}
/// See [`ConflictException`](crate::error::ConflictException)
pub mod conflict_exception {
    /// A builder for [`ConflictException`](crate::error::ConflictException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ConflictException`](crate::error::ConflictException)
        pub fn build(self) -> crate::error::ConflictException {
            crate::error::ConflictException {
                message: self.message,
            }
        }
    }
}
impl ConflictException {
    /// Creates a new builder-style object to manufacture [`ConflictException`](crate::error::ConflictException)
    pub fn builder() -> crate::error::conflict_exception::Builder {
        crate::error::conflict_exception::Builder::default()
    }
}
