// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
/// <p>The details of the maintenance configuration for the application.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ApplicationMaintenanceConfigurationDescription {
    /// <p>The start time for the maintenance window.</p>
    pub application_maintenance_window_start_time: std::option::Option<std::string::String>,
    /// <p>The end time for the maintenance window.</p>
    pub application_maintenance_window_end_time: std::option::Option<std::string::String>,
}
impl ApplicationMaintenanceConfigurationDescription {
    /// <p>The start time for the maintenance window.</p>
    pub fn application_maintenance_window_start_time(&self) -> std::option::Option<&str> {
        self.application_maintenance_window_start_time.as_deref()
    }
    /// <p>The end time for the maintenance window.</p>
    pub fn application_maintenance_window_end_time(&self) -> std::option::Option<&str> {
        self.application_maintenance_window_end_time.as_deref()
    }
}
impl std::fmt::Debug for ApplicationMaintenanceConfigurationDescription {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ApplicationMaintenanceConfigurationDescription");
        formatter.field(
            "application_maintenance_window_start_time",
            &self.application_maintenance_window_start_time,
        );
        formatter.field(
            "application_maintenance_window_end_time",
            &self.application_maintenance_window_end_time,
        );
        formatter.finish()
    }
}
/// See [`ApplicationMaintenanceConfigurationDescription`](crate::model::ApplicationMaintenanceConfigurationDescription)
pub mod application_maintenance_configuration_description {
    /// A builder for [`ApplicationMaintenanceConfigurationDescription`](crate::model::ApplicationMaintenanceConfigurationDescription)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) application_maintenance_window_start_time:
            std::option::Option<std::string::String>,
        pub(crate) application_maintenance_window_end_time:
            std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The start time for the maintenance window.</p>
        pub fn application_maintenance_window_start_time(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.application_maintenance_window_start_time = Some(input.into());
            self
        }
        /// <p>The start time for the maintenance window.</p>
        pub fn set_application_maintenance_window_start_time(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.application_maintenance_window_start_time = input;
            self
        }
        /// <p>The end time for the maintenance window.</p>
        pub fn application_maintenance_window_end_time(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.application_maintenance_window_end_time = Some(input.into());
            self
        }
        /// <p>The end time for the maintenance window.</p>
        pub fn set_application_maintenance_window_end_time(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.application_maintenance_window_end_time = input;
            self
        }
        /// Consumes the builder and constructs a [`ApplicationMaintenanceConfigurationDescription`](crate::model::ApplicationMaintenanceConfigurationDescription)
        pub fn build(self) -> crate::model::ApplicationMaintenanceConfigurationDescription {
            crate::model::ApplicationMaintenanceConfigurationDescription {
                application_maintenance_window_start_time: self
                    .application_maintenance_window_start_time,
                application_maintenance_window_end_time: self
                    .application_maintenance_window_end_time,
            }
        }
    }
}
impl ApplicationMaintenanceConfigurationDescription {
    /// Creates a new builder-style object to manufacture [`ApplicationMaintenanceConfigurationDescription`](crate::model::ApplicationMaintenanceConfigurationDescription)
    pub fn builder() -> crate::model::application_maintenance_configuration_description::Builder {
        crate::model::application_maintenance_configuration_description::Builder::default()
    }
}

/// <p>Describes the updated maintenance configuration for the application.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ApplicationMaintenanceConfigurationUpdate {
    /// <p>The updated start time for the maintenance window.</p>
    pub application_maintenance_window_start_time_update: std::option::Option<std::string::String>,
}
impl ApplicationMaintenanceConfigurationUpdate {
    /// <p>The updated start time for the maintenance window.</p>
    pub fn application_maintenance_window_start_time_update(&self) -> std::option::Option<&str> {
        self.application_maintenance_window_start_time_update
            .as_deref()
    }
}
impl std::fmt::Debug for ApplicationMaintenanceConfigurationUpdate {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ApplicationMaintenanceConfigurationUpdate");
        formatter.field(
            "application_maintenance_window_start_time_update",
            &self.application_maintenance_window_start_time_update,
        );
        formatter.finish()
    }
}
/// See [`ApplicationMaintenanceConfigurationUpdate`](crate::model::ApplicationMaintenanceConfigurationUpdate)
pub mod application_maintenance_configuration_update {
    /// A builder for [`ApplicationMaintenanceConfigurationUpdate`](crate::model::ApplicationMaintenanceConfigurationUpdate)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) application_maintenance_window_start_time_update:
            std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The updated start time for the maintenance window.</p>
        pub fn application_maintenance_window_start_time_update(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.application_maintenance_window_start_time_update = Some(input.into());
            self
        }
        /// <p>The updated start time for the maintenance window.</p>
        pub fn set_application_maintenance_window_start_time_update(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.application_maintenance_window_start_time_update = input;
            self
        }
        /// Consumes the builder and constructs a [`ApplicationMaintenanceConfigurationUpdate`](crate::model::ApplicationMaintenanceConfigurationUpdate)
        pub fn build(self) -> crate::model::ApplicationMaintenanceConfigurationUpdate {
            crate::model::ApplicationMaintenanceConfigurationUpdate {
                application_maintenance_window_start_time_update: self
                    .application_maintenance_window_start_time_update,
            }
        }
    }
}
impl ApplicationMaintenanceConfigurationUpdate {
    /// Creates a new builder-style object to manufacture [`ApplicationMaintenanceConfigurationUpdate`](crate::model::ApplicationMaintenanceConfigurationUpdate)
    pub fn builder() -> crate::model::application_maintenance_configuration_update::Builder {
        crate::model::application_maintenance_configuration_update::Builder::default()
    }
}

/// <p>Describes the application, including the application Amazon Resource Name (ARN), status,
/// latest version, and input and output configurations.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ApplicationDetail {
    /// <p>The ARN of the application.</p>
    pub application_arn: std::option::Option<std::string::String>,
    /// <p>The description of the application.</p>
    pub application_description: std::option::Option<std::string::String>,
    /// <p>The name of the application.</p>
    pub application_name: std::option::Option<std::string::String>,
    /// <p>The runtime environment for the application (<code>SQL-1_0</code>, <code>FLINK-1_6</code>, <code>FLINK-1_8</code>, or <code>FLINK-1_11</code>).</p>
    pub runtime_environment: std::option::Option<crate::model::RuntimeEnvironment>,
    /// <p>Specifies the IAM role that the application uses to access external resources.</p>
    pub service_execution_role: std::option::Option<std::string::String>,
    /// <p>The status of the application.</p>
    pub application_status: std::option::Option<crate::model::ApplicationStatus>,
    /// <p>Provides the current application version. Kinesis Data Analytics updates the
    /// <code>ApplicationVersionId</code> each time you update the application.</p>
    pub application_version_id: std::option::Option<i64>,
    /// <p>The current timestamp when the application was created.</p>
    pub create_timestamp: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The current timestamp when the application was last updated.</p>
    pub last_update_timestamp: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>Describes details about the application code and starting parameters for a Kinesis Data Analytics application.</p>
    pub application_configuration_description:
        std::option::Option<crate::model::ApplicationConfigurationDescription>,
    /// <p>Describes the application Amazon CloudWatch logging options.</p>
    pub cloud_watch_logging_option_descriptions:
        std::option::Option<std::vec::Vec<crate::model::CloudWatchLoggingOptionDescription>>,
    /// <p>The details of the maintenance configuration for the application.</p>
    pub application_maintenance_configuration_description:
        std::option::Option<crate::model::ApplicationMaintenanceConfigurationDescription>,
    /// <p>The previous application version before the latest application update. <a>RollbackApplication</a>
    /// reverts the application to this version.</p>
    pub application_version_updated_from: std::option::Option<i64>,
    /// <p>If you reverted the application using <a>RollbackApplication</a>,
    /// the application version when <code>RollbackApplication</code> was called.</p>
    pub application_version_rolled_back_from: std::option::Option<i64>,
    /// <p>A value you use to implement strong concurrency for application updates.</p>
    pub conditional_token: std::option::Option<std::string::String>,
    /// <p>The version to which you want to roll back the application.</p>
    pub application_version_rolled_back_to: std::option::Option<i64>,
    /// <p>To create a Kinesis Data Analytics Studio notebook, you must set the mode to <code>INTERACTIVE</code>. However, for a Kinesis Data Analytics for Apache Flink application, the mode is optional.</p>
    pub application_mode: std::option::Option<crate::model::ApplicationMode>,
}
impl ApplicationDetail {
    /// <p>The ARN of the application.</p>
    pub fn application_arn(&self) -> std::option::Option<&str> {
        self.application_arn.as_deref()
    }
    /// <p>The description of the application.</p>
    pub fn application_description(&self) -> std::option::Option<&str> {
        self.application_description.as_deref()
    }
    /// <p>The name of the application.</p>
    pub fn application_name(&self) -> std::option::Option<&str> {
        self.application_name.as_deref()
    }
    /// <p>The runtime environment for the application (<code>SQL-1_0</code>, <code>FLINK-1_6</code>, <code>FLINK-1_8</code>, or <code>FLINK-1_11</code>).</p>
    pub fn runtime_environment(&self) -> std::option::Option<&crate::model::RuntimeEnvironment> {
        self.runtime_environment.as_ref()
    }
    /// <p>Specifies the IAM role that the application uses to access external resources.</p>
    pub fn service_execution_role(&self) -> std::option::Option<&str> {
        self.service_execution_role.as_deref()
    }
    /// <p>The status of the application.</p>
    pub fn application_status(&self) -> std::option::Option<&crate::model::ApplicationStatus> {
        self.application_status.as_ref()
    }
    /// <p>Provides the current application version. Kinesis Data Analytics updates the
    /// <code>ApplicationVersionId</code> each time you update the application.</p>
    pub fn application_version_id(&self) -> std::option::Option<i64> {
        self.application_version_id
    }
    /// <p>The current timestamp when the application was created.</p>
    pub fn create_timestamp(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.create_timestamp.as_ref()
    }
    /// <p>The current timestamp when the application was last updated.</p>
    pub fn last_update_timestamp(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.last_update_timestamp.as_ref()
    }
    /// <p>Describes details about the application code and starting parameters for a Kinesis Data Analytics application.</p>
    pub fn application_configuration_description(
        &self,
    ) -> std::option::Option<&crate::model::ApplicationConfigurationDescription> {
        self.application_configuration_description.as_ref()
    }
    /// <p>Describes the application Amazon CloudWatch logging options.</p>
    pub fn cloud_watch_logging_option_descriptions(
        &self,
    ) -> std::option::Option<&[crate::model::CloudWatchLoggingOptionDescription]> {
        self.cloud_watch_logging_option_descriptions.as_deref()
    }
    /// <p>The details of the maintenance configuration for the application.</p>
    pub fn application_maintenance_configuration_description(
        &self,
    ) -> std::option::Option<&crate::model::ApplicationMaintenanceConfigurationDescription> {
        self.application_maintenance_configuration_description
            .as_ref()
    }
    /// <p>The previous application version before the latest application update. <a>RollbackApplication</a>
    /// reverts the application to this version.</p>
    pub fn application_version_updated_from(&self) -> std::option::Option<i64> {
        self.application_version_updated_from
    }
    /// <p>If you reverted the application using <a>RollbackApplication</a>,
    /// the application version when <code>RollbackApplication</code> was called.</p>
    pub fn application_version_rolled_back_from(&self) -> std::option::Option<i64> {
        self.application_version_rolled_back_from
    }
    /// <p>A value you use to implement strong concurrency for application updates.</p>
    pub fn conditional_token(&self) -> std::option::Option<&str> {
        self.conditional_token.as_deref()
    }
    /// <p>The version to which you want to roll back the application.</p>
    pub fn application_version_rolled_back_to(&self) -> std::option::Option<i64> {
        self.application_version_rolled_back_to
    }
    /// <p>To create a Kinesis Data Analytics Studio notebook, you must set the mode to <code>INTERACTIVE</code>. However, for a Kinesis Data Analytics for Apache Flink application, the mode is optional.</p>
    pub fn application_mode(&self) -> std::option::Option<&crate::model::ApplicationMode> {
        self.application_mode.as_ref()
    }
}
impl std::fmt::Debug for ApplicationDetail {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ApplicationDetail");
        formatter.field("application_arn", &self.application_arn);
        formatter.field("application_description", &self.application_description);
        formatter.field("application_name", &self.application_name);
        formatter.field("runtime_environment", &self.runtime_environment);
        formatter.field("service_execution_role", &self.service_execution_role);
        formatter.field("application_status", &self.application_status);
        formatter.field("application_version_id", &self.application_version_id);
        formatter.field("create_timestamp", &self.create_timestamp);
        formatter.field("last_update_timestamp", &self.last_update_timestamp);
        formatter.field(
            "application_configuration_description",
            &self.application_configuration_description,
        );
        formatter.field(
            "cloud_watch_logging_option_descriptions",
            &self.cloud_watch_logging_option_descriptions,
        );
        formatter.field(
            "application_maintenance_configuration_description",
            &self.application_maintenance_configuration_description,
        );
        formatter.field(
            "application_version_updated_from",
            &self.application_version_updated_from,
        );
        formatter.field(
            "application_version_rolled_back_from",
            &self.application_version_rolled_back_from,
        );
        formatter.field("conditional_token", &self.conditional_token);
        formatter.field(
            "application_version_rolled_back_to",
            &self.application_version_rolled_back_to,
        );
        formatter.field("application_mode", &self.application_mode);
        formatter.finish()
    }
}
/// See [`ApplicationDetail`](crate::model::ApplicationDetail)
pub mod application_detail {
    /// A builder for [`ApplicationDetail`](crate::model::ApplicationDetail)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) application_arn: std::option::Option<std::string::String>,
        pub(crate) application_description: std::option::Option<std::string::String>,
        pub(crate) application_name: std::option::Option<std::string::String>,
        pub(crate) runtime_environment: std::option::Option<crate::model::RuntimeEnvironment>,
        pub(crate) service_execution_role: std::option::Option<std::string::String>,
        pub(crate) application_status: std::option::Option<crate::model::ApplicationStatus>,
        pub(crate) application_version_id: std::option::Option<i64>,
        pub(crate) create_timestamp: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) last_update_timestamp: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) application_configuration_description:
            std::option::Option<crate::model::ApplicationConfigurationDescription>,
        pub(crate) cloud_watch_logging_option_descriptions:
            std::option::Option<std::vec::Vec<crate::model::CloudWatchLoggingOptionDescription>>,
        pub(crate) application_maintenance_configuration_description:
            std::option::Option<crate::model::ApplicationMaintenanceConfigurationDescription>,
        pub(crate) application_version_updated_from: std::option::Option<i64>,
        pub(crate) application_version_rolled_back_from: std::option::Option<i64>,
        pub(crate) conditional_token: std::option::Option<std::string::String>,
        pub(crate) application_version_rolled_back_to: std::option::Option<i64>,
        pub(crate) application_mode: std::option::Option<crate::model::ApplicationMode>,
    }
    impl Builder {
        /// <p>The ARN of the application.</p>
        pub fn application_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.application_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the application.</p>
        pub fn set_application_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.application_arn = input;
            self
        }
        /// <p>The description of the application.</p>
        pub fn application_description(mut self, input: impl Into<std::string::String>) -> Self {
            self.application_description = Some(input.into());
            self
        }
        /// <p>The description of the application.</p>
        pub fn set_application_description(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.application_description = input;
            self
        }
        /// <p>The name of the application.</p>
        pub fn application_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.application_name = Some(input.into());
            self
        }
        /// <p>The name of the application.</p>
        pub fn set_application_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.application_name = input;
            self
        }
        /// <p>The runtime environment for the application (<code>SQL-1_0</code>, <code>FLINK-1_6</code>, <code>FLINK-1_8</code>, or <code>FLINK-1_11</code>).</p>
        pub fn runtime_environment(mut self, input: crate::model::RuntimeEnvironment) -> Self {
            self.runtime_environment = Some(input);
            self
        }
        /// <p>The runtime environment for the application (<code>SQL-1_0</code>, <code>FLINK-1_6</code>, <code>FLINK-1_8</code>, or <code>FLINK-1_11</code>).</p>
        pub fn set_runtime_environment(
            mut self,
            input: std::option::Option<crate::model::RuntimeEnvironment>,
        ) -> Self {
            self.runtime_environment = input;
            self
        }
        /// <p>Specifies the IAM role that the application uses to access external resources.</p>
        pub fn service_execution_role(mut self, input: impl Into<std::string::String>) -> Self {
            self.service_execution_role = Some(input.into());
            self
        }
        /// <p>Specifies the IAM role that the application uses to access external resources.</p>
        pub fn set_service_execution_role(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.service_execution_role = input;
            self
        }
        /// <p>The status of the application.</p>
        pub fn application_status(mut self, input: crate::model::ApplicationStatus) -> Self {
            self.application_status = Some(input);
            self
        }
        /// <p>The status of the application.</p>
        pub fn set_application_status(
            mut self,
            input: std::option::Option<crate::model::ApplicationStatus>,
        ) -> Self {
            self.application_status = input;
            self
        }
        /// <p>Provides the current application version. Kinesis Data Analytics updates the
        /// <code>ApplicationVersionId</code> each time you update the application.</p>
        pub fn application_version_id(mut self, input: i64) -> Self {
            self.application_version_id = Some(input);
            self
        }
        /// <p>Provides the current application version. Kinesis Data Analytics updates the
        /// <code>ApplicationVersionId</code> each time you update the application.</p>
        pub fn set_application_version_id(mut self, input: std::option::Option<i64>) -> Self {
            self.application_version_id = input;
            self
        }
        /// <p>The current timestamp when the application was created.</p>
        pub fn create_timestamp(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.create_timestamp = Some(input);
            self
        }
        /// <p>The current timestamp when the application was created.</p>
        pub fn set_create_timestamp(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.create_timestamp = input;
            self
        }
        /// <p>The current timestamp when the application was last updated.</p>
        pub fn last_update_timestamp(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.last_update_timestamp = Some(input);
            self
        }
        /// <p>The current timestamp when the application was last updated.</p>
        pub fn set_last_update_timestamp(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.last_update_timestamp = input;
            self
        }
        /// <p>Describes details about the application code and starting parameters for a Kinesis Data Analytics application.</p>
        pub fn application_configuration_description(
            mut self,
            input: crate::model::ApplicationConfigurationDescription,
        ) -> Self {
            self.application_configuration_description = Some(input);
            self
        }
        /// <p>Describes details about the application code and starting parameters for a Kinesis Data Analytics application.</p>
        pub fn set_application_configuration_description(
            mut self,
            input: std::option::Option<crate::model::ApplicationConfigurationDescription>,
        ) -> Self {
            self.application_configuration_description = input;
            self
        }
        /// Appends an item to `cloud_watch_logging_option_descriptions`.
        ///
        /// To override the contents of this collection use [`set_cloud_watch_logging_option_descriptions`](Self::set_cloud_watch_logging_option_descriptions).
        ///
        /// <p>Describes the application Amazon CloudWatch logging options.</p>
        pub fn cloud_watch_logging_option_descriptions(
            mut self,
            input: impl Into<crate::model::CloudWatchLoggingOptionDescription>,
        ) -> Self {
            let mut v = self
                .cloud_watch_logging_option_descriptions
                .unwrap_or_default();
            v.push(input.into());
            self.cloud_watch_logging_option_descriptions = Some(v);
            self
        }
        /// <p>Describes the application Amazon CloudWatch logging options.</p>
        pub fn set_cloud_watch_logging_option_descriptions(
            mut self,
            input: std::option::Option<
                std::vec::Vec<crate::model::CloudWatchLoggingOptionDescription>,
            >,
        ) -> Self {
            self.cloud_watch_logging_option_descriptions = input;
            self
        }
        /// <p>The details of the maintenance configuration for the application.</p>
        pub fn application_maintenance_configuration_description(
            mut self,
            input: crate::model::ApplicationMaintenanceConfigurationDescription,
        ) -> Self {
            self.application_maintenance_configuration_description = Some(input);
            self
        }
        /// <p>The details of the maintenance configuration for the application.</p>
        pub fn set_application_maintenance_configuration_description(
            mut self,
            input: std::option::Option<
                crate::model::ApplicationMaintenanceConfigurationDescription,
            >,
        ) -> Self {
            self.application_maintenance_configuration_description = input;
            self
        }
        /// <p>The previous application version before the latest application update. <a>RollbackApplication</a>
        /// reverts the application to this version.</p>
        pub fn application_version_updated_from(mut self, input: i64) -> Self {
            self.application_version_updated_from = Some(input);
            self
        }
        /// <p>The previous application version before the latest application update. <a>RollbackApplication</a>
        /// reverts the application to this version.</p>
        pub fn set_application_version_updated_from(
            mut self,
            input: std::option::Option<i64>,
        ) -> Self {
            self.application_version_updated_from = input;
            self
        }
        /// <p>If you reverted the application using <a>RollbackApplication</a>,
        /// the application version when <code>RollbackApplication</code> was called.</p>
        pub fn application_version_rolled_back_from(mut self, input: i64) -> Self {
            self.application_version_rolled_back_from = Some(input);
            self
        }
        /// <p>If you reverted the application using <a>RollbackApplication</a>,
        /// the application version when <code>RollbackApplication</code> was called.</p>
        pub fn set_application_version_rolled_back_from(
            mut self,
            input: std::option::Option<i64>,
        ) -> Self {
            self.application_version_rolled_back_from = input;
            self
        }
        /// <p>A value you use to implement strong concurrency for application updates.</p>
        pub fn conditional_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.conditional_token = Some(input.into());
            self
        }
        /// <p>A value you use to implement strong concurrency for application updates.</p>
        pub fn set_conditional_token(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.conditional_token = input;
            self
        }
        /// <p>The version to which you want to roll back the application.</p>
        pub fn application_version_rolled_back_to(mut self, input: i64) -> Self {
            self.application_version_rolled_back_to = Some(input);
            self
        }
        /// <p>The version to which you want to roll back the application.</p>
        pub fn set_application_version_rolled_back_to(
            mut self,
            input: std::option::Option<i64>,
        ) -> Self {
            self.application_version_rolled_back_to = input;
            self
        }
        /// <p>To create a Kinesis Data Analytics Studio notebook, you must set the mode to <code>INTERACTIVE</code>. However, for a Kinesis Data Analytics for Apache Flink application, the mode is optional.</p>
        pub fn application_mode(mut self, input: crate::model::ApplicationMode) -> Self {
            self.application_mode = Some(input);
            self
        }
        /// <p>To create a Kinesis Data Analytics Studio notebook, you must set the mode to <code>INTERACTIVE</code>. However, for a Kinesis Data Analytics for Apache Flink application, the mode is optional.</p>
        pub fn set_application_mode(
            mut self,
            input: std::option::Option<crate::model::ApplicationMode>,
        ) -> Self {
            self.application_mode = input;
            self
        }
        /// Consumes the builder and constructs a [`ApplicationDetail`](crate::model::ApplicationDetail)
        pub fn build(self) -> crate::model::ApplicationDetail {
            crate::model::ApplicationDetail {
                application_arn: self.application_arn,
                application_description: self.application_description,
                application_name: self.application_name,
                runtime_environment: self.runtime_environment,
                service_execution_role: self.service_execution_role,
                application_status: self.application_status,
                application_version_id: self.application_version_id,
                create_timestamp: self.create_timestamp,
                last_update_timestamp: self.last_update_timestamp,
                application_configuration_description: self.application_configuration_description,
                cloud_watch_logging_option_descriptions: self
                    .cloud_watch_logging_option_descriptions,
                application_maintenance_configuration_description: self
                    .application_maintenance_configuration_description,
                application_version_updated_from: self.application_version_updated_from,
                application_version_rolled_back_from: self.application_version_rolled_back_from,
                conditional_token: self.conditional_token,
                application_version_rolled_back_to: self.application_version_rolled_back_to,
                application_mode: self.application_mode,
            }
        }
    }
}
impl ApplicationDetail {
    /// Creates a new builder-style object to manufacture [`ApplicationDetail`](crate::model::ApplicationDetail)
    pub fn builder() -> crate::model::application_detail::Builder {
        crate::model::application_detail::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ApplicationMode {
    #[allow(missing_docs)] // documentation missing in model
    Interactive,
    #[allow(missing_docs)] // documentation missing in model
    Streaming,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for ApplicationMode {
    fn from(s: &str) -> Self {
        match s {
            "INTERACTIVE" => ApplicationMode::Interactive,
            "STREAMING" => ApplicationMode::Streaming,
            other => ApplicationMode::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for ApplicationMode {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ApplicationMode::from(s))
    }
}
impl ApplicationMode {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ApplicationMode::Interactive => "INTERACTIVE",
            ApplicationMode::Streaming => "STREAMING",
            ApplicationMode::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["INTERACTIVE", "STREAMING"]
    }
}
impl AsRef<str> for ApplicationMode {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Describes the Amazon CloudWatch logging option.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CloudWatchLoggingOptionDescription {
    /// <p>The ID of the CloudWatch logging option description.</p>
    pub cloud_watch_logging_option_id: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the CloudWatch log to receive application
    /// messages.</p>
    pub log_stream_arn: std::option::Option<std::string::String>,
    /// <p>The IAM ARN of the role to use to send application messages. </p>
    /// <note>
    /// <p>Provided for backward compatibility. Applications created with the current API version have an
    /// application-level service execution role rather than a resource-level role.</p>
    /// </note>
    pub role_arn: std::option::Option<std::string::String>,
}
impl CloudWatchLoggingOptionDescription {
    /// <p>The ID of the CloudWatch logging option description.</p>
    pub fn cloud_watch_logging_option_id(&self) -> std::option::Option<&str> {
        self.cloud_watch_logging_option_id.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the CloudWatch log to receive application
    /// messages.</p>
    pub fn log_stream_arn(&self) -> std::option::Option<&str> {
        self.log_stream_arn.as_deref()
    }
    /// <p>The IAM ARN of the role to use to send application messages. </p>
    /// <note>
    /// <p>Provided for backward compatibility. Applications created with the current API version have an
    /// application-level service execution role rather than a resource-level role.</p>
    /// </note>
    pub fn role_arn(&self) -> std::option::Option<&str> {
        self.role_arn.as_deref()
    }
}
impl std::fmt::Debug for CloudWatchLoggingOptionDescription {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CloudWatchLoggingOptionDescription");
        formatter.field(
            "cloud_watch_logging_option_id",
            &self.cloud_watch_logging_option_id,
        );
        formatter.field("log_stream_arn", &self.log_stream_arn);
        formatter.field("role_arn", &self.role_arn);
        formatter.finish()
    }
}
/// See [`CloudWatchLoggingOptionDescription`](crate::model::CloudWatchLoggingOptionDescription)
pub mod cloud_watch_logging_option_description {
    /// A builder for [`CloudWatchLoggingOptionDescription`](crate::model::CloudWatchLoggingOptionDescription)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) cloud_watch_logging_option_id: std::option::Option<std::string::String>,
        pub(crate) log_stream_arn: std::option::Option<std::string::String>,
        pub(crate) role_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the CloudWatch logging option description.</p>
        pub fn cloud_watch_logging_option_id(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.cloud_watch_logging_option_id = Some(input.into());
            self
        }
        /// <p>The ID of the CloudWatch logging option description.</p>
        pub fn set_cloud_watch_logging_option_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.cloud_watch_logging_option_id = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the CloudWatch log to receive application
        /// messages.</p>
        pub fn log_stream_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.log_stream_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the CloudWatch log to receive application
        /// messages.</p>
        pub fn set_log_stream_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.log_stream_arn = input;
            self
        }
        /// <p>The IAM ARN of the role to use to send application messages. </p>
        /// <note>
        /// <p>Provided for backward compatibility. Applications created with the current API version have an
        /// application-level service execution role rather than a resource-level role.</p>
        /// </note>
        pub fn role_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.role_arn = Some(input.into());
            self
        }
        /// <p>The IAM ARN of the role to use to send application messages. </p>
        /// <note>
        /// <p>Provided for backward compatibility. Applications created with the current API version have an
        /// application-level service execution role rather than a resource-level role.</p>
        /// </note>
        pub fn set_role_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.role_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`CloudWatchLoggingOptionDescription`](crate::model::CloudWatchLoggingOptionDescription)
        pub fn build(self) -> crate::model::CloudWatchLoggingOptionDescription {
            crate::model::CloudWatchLoggingOptionDescription {
                cloud_watch_logging_option_id: self.cloud_watch_logging_option_id,
                log_stream_arn: self.log_stream_arn,
                role_arn: self.role_arn,
            }
        }
    }
}
impl CloudWatchLoggingOptionDescription {
    /// Creates a new builder-style object to manufacture [`CloudWatchLoggingOptionDescription`](crate::model::CloudWatchLoggingOptionDescription)
    pub fn builder() -> crate::model::cloud_watch_logging_option_description::Builder {
        crate::model::cloud_watch_logging_option_description::Builder::default()
    }
}

/// <p>Describes details about the application code and starting parameters for a Kinesis Data Analytics application.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ApplicationConfigurationDescription {
    /// <p>The details about inputs, outputs, and reference data sources for a SQL-based Kinesis Data Analytics application.</p>
    pub sql_application_configuration_description:
        std::option::Option<crate::model::SqlApplicationConfigurationDescription>,
    /// <p>The details about the application code for a Flink-based Kinesis Data Analytics application.</p>
    pub application_code_configuration_description:
        std::option::Option<crate::model::ApplicationCodeConfigurationDescription>,
    /// <p>The details about the starting properties for a Kinesis Data Analytics application.</p>
    pub run_configuration_description:
        std::option::Option<crate::model::RunConfigurationDescription>,
    /// <p>The details about a Flink-based Kinesis Data Analytics application.</p>
    pub flink_application_configuration_description:
        std::option::Option<crate::model::FlinkApplicationConfigurationDescription>,
    /// <p>Describes execution properties for a Flink-based Kinesis Data Analytics application.</p>
    pub environment_property_descriptions:
        std::option::Option<crate::model::EnvironmentPropertyDescriptions>,
    /// <p>Describes whether snapshots are enabled for a Flink-based Kinesis Data Analytics application.</p>
    pub application_snapshot_configuration_description:
        std::option::Option<crate::model::ApplicationSnapshotConfigurationDescription>,
    /// <p>The array of descriptions of VPC configurations available to the application.</p>
    pub vpc_configuration_descriptions:
        std::option::Option<std::vec::Vec<crate::model::VpcConfigurationDescription>>,
    /// <p>The configuration parameters for a Kinesis Data Analytics Studio notebook.</p>
    pub zeppelin_application_configuration_description:
        std::option::Option<crate::model::ZeppelinApplicationConfigurationDescription>,
}
impl ApplicationConfigurationDescription {
    /// <p>The details about inputs, outputs, and reference data sources for a SQL-based Kinesis Data Analytics application.</p>
    pub fn sql_application_configuration_description(
        &self,
    ) -> std::option::Option<&crate::model::SqlApplicationConfigurationDescription> {
        self.sql_application_configuration_description.as_ref()
    }
    /// <p>The details about the application code for a Flink-based Kinesis Data Analytics application.</p>
    pub fn application_code_configuration_description(
        &self,
    ) -> std::option::Option<&crate::model::ApplicationCodeConfigurationDescription> {
        self.application_code_configuration_description.as_ref()
    }
    /// <p>The details about the starting properties for a Kinesis Data Analytics application.</p>
    pub fn run_configuration_description(
        &self,
    ) -> std::option::Option<&crate::model::RunConfigurationDescription> {
        self.run_configuration_description.as_ref()
    }
    /// <p>The details about a Flink-based Kinesis Data Analytics application.</p>
    pub fn flink_application_configuration_description(
        &self,
    ) -> std::option::Option<&crate::model::FlinkApplicationConfigurationDescription> {
        self.flink_application_configuration_description.as_ref()
    }
    /// <p>Describes execution properties for a Flink-based Kinesis Data Analytics application.</p>
    pub fn environment_property_descriptions(
        &self,
    ) -> std::option::Option<&crate::model::EnvironmentPropertyDescriptions> {
        self.environment_property_descriptions.as_ref()
    }
    /// <p>Describes whether snapshots are enabled for a Flink-based Kinesis Data Analytics application.</p>
    pub fn application_snapshot_configuration_description(
        &self,
    ) -> std::option::Option<&crate::model::ApplicationSnapshotConfigurationDescription> {
        self.application_snapshot_configuration_description.as_ref()
    }
    /// <p>The array of descriptions of VPC configurations available to the application.</p>
    pub fn vpc_configuration_descriptions(
        &self,
    ) -> std::option::Option<&[crate::model::VpcConfigurationDescription]> {
        self.vpc_configuration_descriptions.as_deref()
    }
    /// <p>The configuration parameters for a Kinesis Data Analytics Studio notebook.</p>
    pub fn zeppelin_application_configuration_description(
        &self,
    ) -> std::option::Option<&crate::model::ZeppelinApplicationConfigurationDescription> {
        self.zeppelin_application_configuration_description.as_ref()
    }
}
impl std::fmt::Debug for ApplicationConfigurationDescription {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ApplicationConfigurationDescription");
        formatter.field(
            "sql_application_configuration_description",
            &self.sql_application_configuration_description,
        );
        formatter.field(
            "application_code_configuration_description",
            &self.application_code_configuration_description,
        );
        formatter.field(
            "run_configuration_description",
            &self.run_configuration_description,
        );
        formatter.field(
            "flink_application_configuration_description",
            &self.flink_application_configuration_description,
        );
        formatter.field(
            "environment_property_descriptions",
            &self.environment_property_descriptions,
        );
        formatter.field(
            "application_snapshot_configuration_description",
            &self.application_snapshot_configuration_description,
        );
        formatter.field(
            "vpc_configuration_descriptions",
            &self.vpc_configuration_descriptions,
        );
        formatter.field(
            "zeppelin_application_configuration_description",
            &self.zeppelin_application_configuration_description,
        );
        formatter.finish()
    }
}
/// See [`ApplicationConfigurationDescription`](crate::model::ApplicationConfigurationDescription)
pub mod application_configuration_description {
    /// A builder for [`ApplicationConfigurationDescription`](crate::model::ApplicationConfigurationDescription)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) sql_application_configuration_description:
            std::option::Option<crate::model::SqlApplicationConfigurationDescription>,
        pub(crate) application_code_configuration_description:
            std::option::Option<crate::model::ApplicationCodeConfigurationDescription>,
        pub(crate) run_configuration_description:
            std::option::Option<crate::model::RunConfigurationDescription>,
        pub(crate) flink_application_configuration_description:
            std::option::Option<crate::model::FlinkApplicationConfigurationDescription>,
        pub(crate) environment_property_descriptions:
            std::option::Option<crate::model::EnvironmentPropertyDescriptions>,
        pub(crate) application_snapshot_configuration_description:
            std::option::Option<crate::model::ApplicationSnapshotConfigurationDescription>,
        pub(crate) vpc_configuration_descriptions:
            std::option::Option<std::vec::Vec<crate::model::VpcConfigurationDescription>>,
        pub(crate) zeppelin_application_configuration_description:
            std::option::Option<crate::model::ZeppelinApplicationConfigurationDescription>,
    }
    impl Builder {
        /// <p>The details about inputs, outputs, and reference data sources for a SQL-based Kinesis Data Analytics application.</p>
        pub fn sql_application_configuration_description(
            mut self,
            input: crate::model::SqlApplicationConfigurationDescription,
        ) -> Self {
            self.sql_application_configuration_description = Some(input);
            self
        }
        /// <p>The details about inputs, outputs, and reference data sources for a SQL-based Kinesis Data Analytics application.</p>
        pub fn set_sql_application_configuration_description(
            mut self,
            input: std::option::Option<crate::model::SqlApplicationConfigurationDescription>,
        ) -> Self {
            self.sql_application_configuration_description = input;
            self
        }
        /// <p>The details about the application code for a Flink-based Kinesis Data Analytics application.</p>
        pub fn application_code_configuration_description(
            mut self,
            input: crate::model::ApplicationCodeConfigurationDescription,
        ) -> Self {
            self.application_code_configuration_description = Some(input);
            self
        }
        /// <p>The details about the application code for a Flink-based Kinesis Data Analytics application.</p>
        pub fn set_application_code_configuration_description(
            mut self,
            input: std::option::Option<crate::model::ApplicationCodeConfigurationDescription>,
        ) -> Self {
            self.application_code_configuration_description = input;
            self
        }
        /// <p>The details about the starting properties for a Kinesis Data Analytics application.</p>
        pub fn run_configuration_description(
            mut self,
            input: crate::model::RunConfigurationDescription,
        ) -> Self {
            self.run_configuration_description = Some(input);
            self
        }
        /// <p>The details about the starting properties for a Kinesis Data Analytics application.</p>
        pub fn set_run_configuration_description(
            mut self,
            input: std::option::Option<crate::model::RunConfigurationDescription>,
        ) -> Self {
            self.run_configuration_description = input;
            self
        }
        /// <p>The details about a Flink-based Kinesis Data Analytics application.</p>
        pub fn flink_application_configuration_description(
            mut self,
            input: crate::model::FlinkApplicationConfigurationDescription,
        ) -> Self {
            self.flink_application_configuration_description = Some(input);
            self
        }
        /// <p>The details about a Flink-based Kinesis Data Analytics application.</p>
        pub fn set_flink_application_configuration_description(
            mut self,
            input: std::option::Option<crate::model::FlinkApplicationConfigurationDescription>,
        ) -> Self {
            self.flink_application_configuration_description = input;
            self
        }
        /// <p>Describes execution properties for a Flink-based Kinesis Data Analytics application.</p>
        pub fn environment_property_descriptions(
            mut self,
            input: crate::model::EnvironmentPropertyDescriptions,
        ) -> Self {
            self.environment_property_descriptions = Some(input);
            self
        }
        /// <p>Describes execution properties for a Flink-based Kinesis Data Analytics application.</p>
        pub fn set_environment_property_descriptions(
            mut self,
            input: std::option::Option<crate::model::EnvironmentPropertyDescriptions>,
        ) -> Self {
            self.environment_property_descriptions = input;
            self
        }
        /// <p>Describes whether snapshots are enabled for a Flink-based Kinesis Data Analytics application.</p>
        pub fn application_snapshot_configuration_description(
            mut self,
            input: crate::model::ApplicationSnapshotConfigurationDescription,
        ) -> Self {
            self.application_snapshot_configuration_description = Some(input);
            self
        }
        /// <p>Describes whether snapshots are enabled for a Flink-based Kinesis Data Analytics application.</p>
        pub fn set_application_snapshot_configuration_description(
            mut self,
            input: std::option::Option<crate::model::ApplicationSnapshotConfigurationDescription>,
        ) -> Self {
            self.application_snapshot_configuration_description = input;
            self
        }
        /// Appends an item to `vpc_configuration_descriptions`.
        ///
        /// To override the contents of this collection use [`set_vpc_configuration_descriptions`](Self::set_vpc_configuration_descriptions).
        ///
        /// <p>The array of descriptions of VPC configurations available to the application.</p>
        pub fn vpc_configuration_descriptions(
            mut self,
            input: impl Into<crate::model::VpcConfigurationDescription>,
        ) -> Self {
            let mut v = self.vpc_configuration_descriptions.unwrap_or_default();
            v.push(input.into());
            self.vpc_configuration_descriptions = Some(v);
            self
        }
        /// <p>The array of descriptions of VPC configurations available to the application.</p>
        pub fn set_vpc_configuration_descriptions(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::VpcConfigurationDescription>>,
        ) -> Self {
            self.vpc_configuration_descriptions = input;
            self
        }
        /// <p>The configuration parameters for a Kinesis Data Analytics Studio notebook.</p>
        pub fn zeppelin_application_configuration_description(
            mut self,
            input: crate::model::ZeppelinApplicationConfigurationDescription,
        ) -> Self {
            self.zeppelin_application_configuration_description = Some(input);
            self
        }
        /// <p>The configuration parameters for a Kinesis Data Analytics Studio notebook.</p>
        pub fn set_zeppelin_application_configuration_description(
            mut self,
            input: std::option::Option<crate::model::ZeppelinApplicationConfigurationDescription>,
        ) -> Self {
            self.zeppelin_application_configuration_description = input;
            self
        }
        /// Consumes the builder and constructs a [`ApplicationConfigurationDescription`](crate::model::ApplicationConfigurationDescription)
        pub fn build(self) -> crate::model::ApplicationConfigurationDescription {
            crate::model::ApplicationConfigurationDescription {
                sql_application_configuration_description: self
                    .sql_application_configuration_description,
                application_code_configuration_description: self
                    .application_code_configuration_description,
                run_configuration_description: self.run_configuration_description,
                flink_application_configuration_description: self
                    .flink_application_configuration_description,
                environment_property_descriptions: self.environment_property_descriptions,
                application_snapshot_configuration_description: self
                    .application_snapshot_configuration_description,
                vpc_configuration_descriptions: self.vpc_configuration_descriptions,
                zeppelin_application_configuration_description: self
                    .zeppelin_application_configuration_description,
            }
        }
    }
}
impl ApplicationConfigurationDescription {
    /// Creates a new builder-style object to manufacture [`ApplicationConfigurationDescription`](crate::model::ApplicationConfigurationDescription)
    pub fn builder() -> crate::model::application_configuration_description::Builder {
        crate::model::application_configuration_description::Builder::default()
    }
}

/// <p>The configuration of a Kinesis Data Analytics Studio notebook.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ZeppelinApplicationConfigurationDescription {
    /// <p>The monitoring configuration of a Kinesis Data Analytics Studio notebook.</p>
    pub monitoring_configuration_description:
        std::option::Option<crate::model::ZeppelinMonitoringConfigurationDescription>,
    /// <p>The Amazon Glue Data Catalog that is associated with the Kinesis Data Analytics Studio notebook.</p>
    pub catalog_configuration_description:
        std::option::Option<crate::model::CatalogConfigurationDescription>,
    /// <p>The parameters required to deploy a Kinesis Data Analytics Studio notebook as an application with durable state.</p>
    pub deploy_as_application_configuration_description:
        std::option::Option<crate::model::DeployAsApplicationConfigurationDescription>,
    /// <p>Custom artifacts are dependency JARs and user-defined functions (UDF).</p>
    pub custom_artifacts_configuration_description:
        std::option::Option<std::vec::Vec<crate::model::CustomArtifactConfigurationDescription>>,
}
impl ZeppelinApplicationConfigurationDescription {
    /// <p>The monitoring configuration of a Kinesis Data Analytics Studio notebook.</p>
    pub fn monitoring_configuration_description(
        &self,
    ) -> std::option::Option<&crate::model::ZeppelinMonitoringConfigurationDescription> {
        self.monitoring_configuration_description.as_ref()
    }
    /// <p>The Amazon Glue Data Catalog that is associated with the Kinesis Data Analytics Studio notebook.</p>
    pub fn catalog_configuration_description(
        &self,
    ) -> std::option::Option<&crate::model::CatalogConfigurationDescription> {
        self.catalog_configuration_description.as_ref()
    }
    /// <p>The parameters required to deploy a Kinesis Data Analytics Studio notebook as an application with durable state.</p>
    pub fn deploy_as_application_configuration_description(
        &self,
    ) -> std::option::Option<&crate::model::DeployAsApplicationConfigurationDescription> {
        self.deploy_as_application_configuration_description
            .as_ref()
    }
    /// <p>Custom artifacts are dependency JARs and user-defined functions (UDF).</p>
    pub fn custom_artifacts_configuration_description(
        &self,
    ) -> std::option::Option<&[crate::model::CustomArtifactConfigurationDescription]> {
        self.custom_artifacts_configuration_description.as_deref()
    }
}
impl std::fmt::Debug for ZeppelinApplicationConfigurationDescription {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ZeppelinApplicationConfigurationDescription");
        formatter.field(
            "monitoring_configuration_description",
            &self.monitoring_configuration_description,
        );
        formatter.field(
            "catalog_configuration_description",
            &self.catalog_configuration_description,
        );
        formatter.field(
            "deploy_as_application_configuration_description",
            &self.deploy_as_application_configuration_description,
        );
        formatter.field(
            "custom_artifacts_configuration_description",
            &self.custom_artifacts_configuration_description,
        );
        formatter.finish()
    }
}
/// See [`ZeppelinApplicationConfigurationDescription`](crate::model::ZeppelinApplicationConfigurationDescription)
pub mod zeppelin_application_configuration_description {
    /// A builder for [`ZeppelinApplicationConfigurationDescription`](crate::model::ZeppelinApplicationConfigurationDescription)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) monitoring_configuration_description:
            std::option::Option<crate::model::ZeppelinMonitoringConfigurationDescription>,
        pub(crate) catalog_configuration_description:
            std::option::Option<crate::model::CatalogConfigurationDescription>,
        pub(crate) deploy_as_application_configuration_description:
            std::option::Option<crate::model::DeployAsApplicationConfigurationDescription>,
        pub(crate) custom_artifacts_configuration_description: std::option::Option<
            std::vec::Vec<crate::model::CustomArtifactConfigurationDescription>,
        >,
    }
    impl Builder {
        /// <p>The monitoring configuration of a Kinesis Data Analytics Studio notebook.</p>
        pub fn monitoring_configuration_description(
            mut self,
            input: crate::model::ZeppelinMonitoringConfigurationDescription,
        ) -> Self {
            self.monitoring_configuration_description = Some(input);
            self
        }
        /// <p>The monitoring configuration of a Kinesis Data Analytics Studio notebook.</p>
        pub fn set_monitoring_configuration_description(
            mut self,
            input: std::option::Option<crate::model::ZeppelinMonitoringConfigurationDescription>,
        ) -> Self {
            self.monitoring_configuration_description = input;
            self
        }
        /// <p>The Amazon Glue Data Catalog that is associated with the Kinesis Data Analytics Studio notebook.</p>
        pub fn catalog_configuration_description(
            mut self,
            input: crate::model::CatalogConfigurationDescription,
        ) -> Self {
            self.catalog_configuration_description = Some(input);
            self
        }
        /// <p>The Amazon Glue Data Catalog that is associated with the Kinesis Data Analytics Studio notebook.</p>
        pub fn set_catalog_configuration_description(
            mut self,
            input: std::option::Option<crate::model::CatalogConfigurationDescription>,
        ) -> Self {
            self.catalog_configuration_description = input;
            self
        }
        /// <p>The parameters required to deploy a Kinesis Data Analytics Studio notebook as an application with durable state.</p>
        pub fn deploy_as_application_configuration_description(
            mut self,
            input: crate::model::DeployAsApplicationConfigurationDescription,
        ) -> Self {
            self.deploy_as_application_configuration_description = Some(input);
            self
        }
        /// <p>The parameters required to deploy a Kinesis Data Analytics Studio notebook as an application with durable state.</p>
        pub fn set_deploy_as_application_configuration_description(
            mut self,
            input: std::option::Option<crate::model::DeployAsApplicationConfigurationDescription>,
        ) -> Self {
            self.deploy_as_application_configuration_description = input;
            self
        }
        /// Appends an item to `custom_artifacts_configuration_description`.
        ///
        /// To override the contents of this collection use [`set_custom_artifacts_configuration_description`](Self::set_custom_artifacts_configuration_description).
        ///
        /// <p>Custom artifacts are dependency JARs and user-defined functions (UDF).</p>
        pub fn custom_artifacts_configuration_description(
            mut self,
            input: impl Into<crate::model::CustomArtifactConfigurationDescription>,
        ) -> Self {
            let mut v = self
                .custom_artifacts_configuration_description
                .unwrap_or_default();
            v.push(input.into());
            self.custom_artifacts_configuration_description = Some(v);
            self
        }
        /// <p>Custom artifacts are dependency JARs and user-defined functions (UDF).</p>
        pub fn set_custom_artifacts_configuration_description(
            mut self,
            input: std::option::Option<
                std::vec::Vec<crate::model::CustomArtifactConfigurationDescription>,
            >,
        ) -> Self {
            self.custom_artifacts_configuration_description = input;
            self
        }
        /// Consumes the builder and constructs a [`ZeppelinApplicationConfigurationDescription`](crate::model::ZeppelinApplicationConfigurationDescription)
        pub fn build(self) -> crate::model::ZeppelinApplicationConfigurationDescription {
            crate::model::ZeppelinApplicationConfigurationDescription {
                monitoring_configuration_description: self.monitoring_configuration_description,
                catalog_configuration_description: self.catalog_configuration_description,
                deploy_as_application_configuration_description: self
                    .deploy_as_application_configuration_description,
                custom_artifacts_configuration_description: self
                    .custom_artifacts_configuration_description,
            }
        }
    }
}
impl ZeppelinApplicationConfigurationDescription {
    /// Creates a new builder-style object to manufacture [`ZeppelinApplicationConfigurationDescription`](crate::model::ZeppelinApplicationConfigurationDescription)
    pub fn builder() -> crate::model::zeppelin_application_configuration_description::Builder {
        crate::model::zeppelin_application_configuration_description::Builder::default()
    }
}

/// <p>Specifies a dependency JAR or a JAR of user-defined functions.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CustomArtifactConfigurationDescription {
    /// <p>
    /// <code>UDF</code> stands for user-defined functions. This type of artifact must be in an S3 bucket. A <code>DEPENDENCY_JAR</code> can be in either Maven or an S3 bucket.</p>
    pub artifact_type: std::option::Option<crate::model::ArtifactType>,
    /// <p>For a Kinesis Data Analytics application provides a
    /// description of an Amazon S3 object, including the Amazon Resource Name (ARN) of the S3 bucket,
    /// the name of the Amazon S3 object that contains the data, and the version number of the Amazon
    /// S3 object that contains the data. </p>
    pub s3_content_location_description: std::option::Option<crate::model::S3ContentLocation>,
    /// <p>The parameters that are required to specify a Maven dependency.</p>
    pub maven_reference_description: std::option::Option<crate::model::MavenReference>,
}
impl CustomArtifactConfigurationDescription {
    /// <p>
    /// <code>UDF</code> stands for user-defined functions. This type of artifact must be in an S3 bucket. A <code>DEPENDENCY_JAR</code> can be in either Maven or an S3 bucket.</p>
    pub fn artifact_type(&self) -> std::option::Option<&crate::model::ArtifactType> {
        self.artifact_type.as_ref()
    }
    /// <p>For a Kinesis Data Analytics application provides a
    /// description of an Amazon S3 object, including the Amazon Resource Name (ARN) of the S3 bucket,
    /// the name of the Amazon S3 object that contains the data, and the version number of the Amazon
    /// S3 object that contains the data. </p>
    pub fn s3_content_location_description(
        &self,
    ) -> std::option::Option<&crate::model::S3ContentLocation> {
        self.s3_content_location_description.as_ref()
    }
    /// <p>The parameters that are required to specify a Maven dependency.</p>
    pub fn maven_reference_description(
        &self,
    ) -> std::option::Option<&crate::model::MavenReference> {
        self.maven_reference_description.as_ref()
    }
}
impl std::fmt::Debug for CustomArtifactConfigurationDescription {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CustomArtifactConfigurationDescription");
        formatter.field("artifact_type", &self.artifact_type);
        formatter.field(
            "s3_content_location_description",
            &self.s3_content_location_description,
        );
        formatter.field(
            "maven_reference_description",
            &self.maven_reference_description,
        );
        formatter.finish()
    }
}
/// See [`CustomArtifactConfigurationDescription`](crate::model::CustomArtifactConfigurationDescription)
pub mod custom_artifact_configuration_description {
    /// A builder for [`CustomArtifactConfigurationDescription`](crate::model::CustomArtifactConfigurationDescription)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) artifact_type: std::option::Option<crate::model::ArtifactType>,
        pub(crate) s3_content_location_description:
            std::option::Option<crate::model::S3ContentLocation>,
        pub(crate) maven_reference_description: std::option::Option<crate::model::MavenReference>,
    }
    impl Builder {
        /// <p>
        /// <code>UDF</code> stands for user-defined functions. This type of artifact must be in an S3 bucket. A <code>DEPENDENCY_JAR</code> can be in either Maven or an S3 bucket.</p>
        pub fn artifact_type(mut self, input: crate::model::ArtifactType) -> Self {
            self.artifact_type = Some(input);
            self
        }
        /// <p>
        /// <code>UDF</code> stands for user-defined functions. This type of artifact must be in an S3 bucket. A <code>DEPENDENCY_JAR</code> can be in either Maven or an S3 bucket.</p>
        pub fn set_artifact_type(
            mut self,
            input: std::option::Option<crate::model::ArtifactType>,
        ) -> Self {
            self.artifact_type = input;
            self
        }
        /// <p>For a Kinesis Data Analytics application provides a
        /// description of an Amazon S3 object, including the Amazon Resource Name (ARN) of the S3 bucket,
        /// the name of the Amazon S3 object that contains the data, and the version number of the Amazon
        /// S3 object that contains the data. </p>
        pub fn s3_content_location_description(
            mut self,
            input: crate::model::S3ContentLocation,
        ) -> Self {
            self.s3_content_location_description = Some(input);
            self
        }
        /// <p>For a Kinesis Data Analytics application provides a
        /// description of an Amazon S3 object, including the Amazon Resource Name (ARN) of the S3 bucket,
        /// the name of the Amazon S3 object that contains the data, and the version number of the Amazon
        /// S3 object that contains the data. </p>
        pub fn set_s3_content_location_description(
            mut self,
            input: std::option::Option<crate::model::S3ContentLocation>,
        ) -> Self {
            self.s3_content_location_description = input;
            self
        }
        /// <p>The parameters that are required to specify a Maven dependency.</p>
        pub fn maven_reference_description(mut self, input: crate::model::MavenReference) -> Self {
            self.maven_reference_description = Some(input);
            self
        }
        /// <p>The parameters that are required to specify a Maven dependency.</p>
        pub fn set_maven_reference_description(
            mut self,
            input: std::option::Option<crate::model::MavenReference>,
        ) -> Self {
            self.maven_reference_description = input;
            self
        }
        /// Consumes the builder and constructs a [`CustomArtifactConfigurationDescription`](crate::model::CustomArtifactConfigurationDescription)
        pub fn build(self) -> crate::model::CustomArtifactConfigurationDescription {
            crate::model::CustomArtifactConfigurationDescription {
                artifact_type: self.artifact_type,
                s3_content_location_description: self.s3_content_location_description,
                maven_reference_description: self.maven_reference_description,
            }
        }
    }
}
impl CustomArtifactConfigurationDescription {
    /// Creates a new builder-style object to manufacture [`CustomArtifactConfigurationDescription`](crate::model::CustomArtifactConfigurationDescription)
    pub fn builder() -> crate::model::custom_artifact_configuration_description::Builder {
        crate::model::custom_artifact_configuration_description::Builder::default()
    }
}

/// <p>The information required to specify a Maven reference. You can use Maven references to specify dependency JAR files.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct MavenReference {
    /// <p>The group ID of the Maven reference.</p>
    pub group_id: std::option::Option<std::string::String>,
    /// <p>The artifact ID of the Maven reference.</p>
    pub artifact_id: std::option::Option<std::string::String>,
    /// <p>The version of the Maven reference.</p>
    pub version: std::option::Option<std::string::String>,
}
impl MavenReference {
    /// <p>The group ID of the Maven reference.</p>
    pub fn group_id(&self) -> std::option::Option<&str> {
        self.group_id.as_deref()
    }
    /// <p>The artifact ID of the Maven reference.</p>
    pub fn artifact_id(&self) -> std::option::Option<&str> {
        self.artifact_id.as_deref()
    }
    /// <p>The version of the Maven reference.</p>
    pub fn version(&self) -> std::option::Option<&str> {
        self.version.as_deref()
    }
}
impl std::fmt::Debug for MavenReference {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("MavenReference");
        formatter.field("group_id", &self.group_id);
        formatter.field("artifact_id", &self.artifact_id);
        formatter.field("version", &self.version);
        formatter.finish()
    }
}
/// See [`MavenReference`](crate::model::MavenReference)
pub mod maven_reference {
    /// A builder for [`MavenReference`](crate::model::MavenReference)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) group_id: std::option::Option<std::string::String>,
        pub(crate) artifact_id: std::option::Option<std::string::String>,
        pub(crate) version: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The group ID of the Maven reference.</p>
        pub fn group_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.group_id = Some(input.into());
            self
        }
        /// <p>The group ID of the Maven reference.</p>
        pub fn set_group_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.group_id = input;
            self
        }
        /// <p>The artifact ID of the Maven reference.</p>
        pub fn artifact_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.artifact_id = Some(input.into());
            self
        }
        /// <p>The artifact ID of the Maven reference.</p>
        pub fn set_artifact_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.artifact_id = input;
            self
        }
        /// <p>The version of the Maven reference.</p>
        pub fn version(mut self, input: impl Into<std::string::String>) -> Self {
            self.version = Some(input.into());
            self
        }
        /// <p>The version of the Maven reference.</p>
        pub fn set_version(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.version = input;
            self
        }
        /// Consumes the builder and constructs a [`MavenReference`](crate::model::MavenReference)
        pub fn build(self) -> crate::model::MavenReference {
            crate::model::MavenReference {
                group_id: self.group_id,
                artifact_id: self.artifact_id,
                version: self.version,
            }
        }
    }
}
impl MavenReference {
    /// Creates a new builder-style object to manufacture [`MavenReference`](crate::model::MavenReference)
    pub fn builder() -> crate::model::maven_reference::Builder {
        crate::model::maven_reference::Builder::default()
    }
}

/// <p>For a Kinesis Data Analytics application provides a
/// description of an Amazon S3 object, including the Amazon Resource Name (ARN) of the S3 bucket,
/// the name of the Amazon S3 object that contains the data, and the version number of the Amazon
/// S3 object that contains the data. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct S3ContentLocation {
    /// <p>The Amazon Resource Name (ARN) for the S3 bucket containing the application code.</p>
    pub bucket_arn: std::option::Option<std::string::String>,
    /// <p>The file key for the object containing the application code.</p>
    pub file_key: std::option::Option<std::string::String>,
    /// <p>The version of the object containing the application code.</p>
    pub object_version: std::option::Option<std::string::String>,
}
impl S3ContentLocation {
    /// <p>The Amazon Resource Name (ARN) for the S3 bucket containing the application code.</p>
    pub fn bucket_arn(&self) -> std::option::Option<&str> {
        self.bucket_arn.as_deref()
    }
    /// <p>The file key for the object containing the application code.</p>
    pub fn file_key(&self) -> std::option::Option<&str> {
        self.file_key.as_deref()
    }
    /// <p>The version of the object containing the application code.</p>
    pub fn object_version(&self) -> std::option::Option<&str> {
        self.object_version.as_deref()
    }
}
impl std::fmt::Debug for S3ContentLocation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("S3ContentLocation");
        formatter.field("bucket_arn", &self.bucket_arn);
        formatter.field("file_key", &self.file_key);
        formatter.field("object_version", &self.object_version);
        formatter.finish()
    }
}
/// See [`S3ContentLocation`](crate::model::S3ContentLocation)
pub mod s3_content_location {
    /// A builder for [`S3ContentLocation`](crate::model::S3ContentLocation)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) bucket_arn: std::option::Option<std::string::String>,
        pub(crate) file_key: std::option::Option<std::string::String>,
        pub(crate) object_version: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) for the S3 bucket containing the application code.</p>
        pub fn bucket_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.bucket_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) for the S3 bucket containing the application code.</p>
        pub fn set_bucket_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.bucket_arn = input;
            self
        }
        /// <p>The file key for the object containing the application code.</p>
        pub fn file_key(mut self, input: impl Into<std::string::String>) -> Self {
            self.file_key = Some(input.into());
            self
        }
        /// <p>The file key for the object containing the application code.</p>
        pub fn set_file_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.file_key = input;
            self
        }
        /// <p>The version of the object containing the application code.</p>
        pub fn object_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.object_version = Some(input.into());
            self
        }
        /// <p>The version of the object containing the application code.</p>
        pub fn set_object_version(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.object_version = input;
            self
        }
        /// Consumes the builder and constructs a [`S3ContentLocation`](crate::model::S3ContentLocation)
        pub fn build(self) -> crate::model::S3ContentLocation {
            crate::model::S3ContentLocation {
                bucket_arn: self.bucket_arn,
                file_key: self.file_key,
                object_version: self.object_version,
            }
        }
    }
}
impl S3ContentLocation {
    /// Creates a new builder-style object to manufacture [`S3ContentLocation`](crate::model::S3ContentLocation)
    pub fn builder() -> crate::model::s3_content_location::Builder {
        crate::model::s3_content_location::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ArtifactType {
    #[allow(missing_docs)] // documentation missing in model
    DependencyJar,
    #[allow(missing_docs)] // documentation missing in model
    Udf,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for ArtifactType {
    fn from(s: &str) -> Self {
        match s {
            "DEPENDENCY_JAR" => ArtifactType::DependencyJar,
            "UDF" => ArtifactType::Udf,
            other => ArtifactType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for ArtifactType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ArtifactType::from(s))
    }
}
impl ArtifactType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ArtifactType::DependencyJar => "DEPENDENCY_JAR",
            ArtifactType::Udf => "UDF",
            ArtifactType::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["DEPENDENCY_JAR", "UDF"]
    }
}
impl AsRef<str> for ArtifactType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The configuration information required to deploy an Amazon Data Analytics Studio notebook as an application with durable state.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeployAsApplicationConfigurationDescription {
    /// <p>The location that holds the data required to specify an Amazon Data Analytics application.</p>
    pub s3_content_location_description:
        std::option::Option<crate::model::S3ContentBaseLocationDescription>,
}
impl DeployAsApplicationConfigurationDescription {
    /// <p>The location that holds the data required to specify an Amazon Data Analytics application.</p>
    pub fn s3_content_location_description(
        &self,
    ) -> std::option::Option<&crate::model::S3ContentBaseLocationDescription> {
        self.s3_content_location_description.as_ref()
    }
}
impl std::fmt::Debug for DeployAsApplicationConfigurationDescription {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeployAsApplicationConfigurationDescription");
        formatter.field(
            "s3_content_location_description",
            &self.s3_content_location_description,
        );
        formatter.finish()
    }
}
/// See [`DeployAsApplicationConfigurationDescription`](crate::model::DeployAsApplicationConfigurationDescription)
pub mod deploy_as_application_configuration_description {
    /// A builder for [`DeployAsApplicationConfigurationDescription`](crate::model::DeployAsApplicationConfigurationDescription)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) s3_content_location_description:
            std::option::Option<crate::model::S3ContentBaseLocationDescription>,
    }
    impl Builder {
        /// <p>The location that holds the data required to specify an Amazon Data Analytics application.</p>
        pub fn s3_content_location_description(
            mut self,
            input: crate::model::S3ContentBaseLocationDescription,
        ) -> Self {
            self.s3_content_location_description = Some(input);
            self
        }
        /// <p>The location that holds the data required to specify an Amazon Data Analytics application.</p>
        pub fn set_s3_content_location_description(
            mut self,
            input: std::option::Option<crate::model::S3ContentBaseLocationDescription>,
        ) -> Self {
            self.s3_content_location_description = input;
            self
        }
        /// Consumes the builder and constructs a [`DeployAsApplicationConfigurationDescription`](crate::model::DeployAsApplicationConfigurationDescription)
        pub fn build(self) -> crate::model::DeployAsApplicationConfigurationDescription {
            crate::model::DeployAsApplicationConfigurationDescription {
                s3_content_location_description: self.s3_content_location_description,
            }
        }
    }
}
impl DeployAsApplicationConfigurationDescription {
    /// Creates a new builder-style object to manufacture [`DeployAsApplicationConfigurationDescription`](crate::model::DeployAsApplicationConfigurationDescription)
    pub fn builder() -> crate::model::deploy_as_application_configuration_description::Builder {
        crate::model::deploy_as_application_configuration_description::Builder::default()
    }
}

/// <p>The description of the S3 base location that holds the application.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct S3ContentBaseLocationDescription {
    /// <p>The Amazon Resource Name (ARN) of the S3 bucket.</p>
    pub bucket_arn: std::option::Option<std::string::String>,
    /// <p>The base path for the S3 bucket.</p>
    pub base_path: std::option::Option<std::string::String>,
}
impl S3ContentBaseLocationDescription {
    /// <p>The Amazon Resource Name (ARN) of the S3 bucket.</p>
    pub fn bucket_arn(&self) -> std::option::Option<&str> {
        self.bucket_arn.as_deref()
    }
    /// <p>The base path for the S3 bucket.</p>
    pub fn base_path(&self) -> std::option::Option<&str> {
        self.base_path.as_deref()
    }
}
impl std::fmt::Debug for S3ContentBaseLocationDescription {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("S3ContentBaseLocationDescription");
        formatter.field("bucket_arn", &self.bucket_arn);
        formatter.field("base_path", &self.base_path);
        formatter.finish()
    }
}
/// See [`S3ContentBaseLocationDescription`](crate::model::S3ContentBaseLocationDescription)
pub mod s3_content_base_location_description {
    /// A builder for [`S3ContentBaseLocationDescription`](crate::model::S3ContentBaseLocationDescription)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) bucket_arn: std::option::Option<std::string::String>,
        pub(crate) base_path: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the S3 bucket.</p>
        pub fn bucket_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.bucket_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the S3 bucket.</p>
        pub fn set_bucket_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.bucket_arn = input;
            self
        }
        /// <p>The base path for the S3 bucket.</p>
        pub fn base_path(mut self, input: impl Into<std::string::String>) -> Self {
            self.base_path = Some(input.into());
            self
        }
        /// <p>The base path for the S3 bucket.</p>
        pub fn set_base_path(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.base_path = input;
            self
        }
        /// Consumes the builder and constructs a [`S3ContentBaseLocationDescription`](crate::model::S3ContentBaseLocationDescription)
        pub fn build(self) -> crate::model::S3ContentBaseLocationDescription {
            crate::model::S3ContentBaseLocationDescription {
                bucket_arn: self.bucket_arn,
                base_path: self.base_path,
            }
        }
    }
}
impl S3ContentBaseLocationDescription {
    /// Creates a new builder-style object to manufacture [`S3ContentBaseLocationDescription`](crate::model::S3ContentBaseLocationDescription)
    pub fn builder() -> crate::model::s3_content_base_location_description::Builder {
        crate::model::s3_content_base_location_description::Builder::default()
    }
}

/// <p>The configuration parameters for the default Amazon Glue database. You use this database for Apache Flink SQL queries and table API transforms that you write in a Kinesis Data Analytics Studio notebook.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CatalogConfigurationDescription {
    /// <p>The configuration parameters for the default Amazon Glue database. You use this database for SQL queries that you write in a Kinesis Data Analytics Studio notebook.</p>
    pub glue_data_catalog_configuration_description:
        std::option::Option<crate::model::GlueDataCatalogConfigurationDescription>,
}
impl CatalogConfigurationDescription {
    /// <p>The configuration parameters for the default Amazon Glue database. You use this database for SQL queries that you write in a Kinesis Data Analytics Studio notebook.</p>
    pub fn glue_data_catalog_configuration_description(
        &self,
    ) -> std::option::Option<&crate::model::GlueDataCatalogConfigurationDescription> {
        self.glue_data_catalog_configuration_description.as_ref()
    }
}
impl std::fmt::Debug for CatalogConfigurationDescription {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CatalogConfigurationDescription");
        formatter.field(
            "glue_data_catalog_configuration_description",
            &self.glue_data_catalog_configuration_description,
        );
        formatter.finish()
    }
}
/// See [`CatalogConfigurationDescription`](crate::model::CatalogConfigurationDescription)
pub mod catalog_configuration_description {
    /// A builder for [`CatalogConfigurationDescription`](crate::model::CatalogConfigurationDescription)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) glue_data_catalog_configuration_description:
            std::option::Option<crate::model::GlueDataCatalogConfigurationDescription>,
    }
    impl Builder {
        /// <p>The configuration parameters for the default Amazon Glue database. You use this database for SQL queries that you write in a Kinesis Data Analytics Studio notebook.</p>
        pub fn glue_data_catalog_configuration_description(
            mut self,
            input: crate::model::GlueDataCatalogConfigurationDescription,
        ) -> Self {
            self.glue_data_catalog_configuration_description = Some(input);
            self
        }
        /// <p>The configuration parameters for the default Amazon Glue database. You use this database for SQL queries that you write in a Kinesis Data Analytics Studio notebook.</p>
        pub fn set_glue_data_catalog_configuration_description(
            mut self,
            input: std::option::Option<crate::model::GlueDataCatalogConfigurationDescription>,
        ) -> Self {
            self.glue_data_catalog_configuration_description = input;
            self
        }
        /// Consumes the builder and constructs a [`CatalogConfigurationDescription`](crate::model::CatalogConfigurationDescription)
        pub fn build(self) -> crate::model::CatalogConfigurationDescription {
            crate::model::CatalogConfigurationDescription {
                glue_data_catalog_configuration_description: self
                    .glue_data_catalog_configuration_description,
            }
        }
    }
}
impl CatalogConfigurationDescription {
    /// Creates a new builder-style object to manufacture [`CatalogConfigurationDescription`](crate::model::CatalogConfigurationDescription)
    pub fn builder() -> crate::model::catalog_configuration_description::Builder {
        crate::model::catalog_configuration_description::Builder::default()
    }
}

/// <p>The configuration of the Glue Data Catalog that you use for Apache Flink SQL queries and table API transforms that you write in an application.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GlueDataCatalogConfigurationDescription {
    /// <p>The Amazon Resource Name (ARN) of the database.</p>
    pub database_arn: std::option::Option<std::string::String>,
}
impl GlueDataCatalogConfigurationDescription {
    /// <p>The Amazon Resource Name (ARN) of the database.</p>
    pub fn database_arn(&self) -> std::option::Option<&str> {
        self.database_arn.as_deref()
    }
}
impl std::fmt::Debug for GlueDataCatalogConfigurationDescription {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GlueDataCatalogConfigurationDescription");
        formatter.field("database_arn", &self.database_arn);
        formatter.finish()
    }
}
/// See [`GlueDataCatalogConfigurationDescription`](crate::model::GlueDataCatalogConfigurationDescription)
pub mod glue_data_catalog_configuration_description {
    /// A builder for [`GlueDataCatalogConfigurationDescription`](crate::model::GlueDataCatalogConfigurationDescription)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) database_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the database.</p>
        pub fn database_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.database_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the database.</p>
        pub fn set_database_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.database_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`GlueDataCatalogConfigurationDescription`](crate::model::GlueDataCatalogConfigurationDescription)
        pub fn build(self) -> crate::model::GlueDataCatalogConfigurationDescription {
            crate::model::GlueDataCatalogConfigurationDescription {
                database_arn: self.database_arn,
            }
        }
    }
}
impl GlueDataCatalogConfigurationDescription {
    /// Creates a new builder-style object to manufacture [`GlueDataCatalogConfigurationDescription`](crate::model::GlueDataCatalogConfigurationDescription)
    pub fn builder() -> crate::model::glue_data_catalog_configuration_description::Builder {
        crate::model::glue_data_catalog_configuration_description::Builder::default()
    }
}

/// <p>The monitoring configuration for Apache Zeppelin within a Kinesis Data Analytics Studio notebook.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ZeppelinMonitoringConfigurationDescription {
    /// <p>Describes the verbosity of the CloudWatch Logs for an application.</p>
    pub log_level: std::option::Option<crate::model::LogLevel>,
}
impl ZeppelinMonitoringConfigurationDescription {
    /// <p>Describes the verbosity of the CloudWatch Logs for an application.</p>
    pub fn log_level(&self) -> std::option::Option<&crate::model::LogLevel> {
        self.log_level.as_ref()
    }
}
impl std::fmt::Debug for ZeppelinMonitoringConfigurationDescription {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ZeppelinMonitoringConfigurationDescription");
        formatter.field("log_level", &self.log_level);
        formatter.finish()
    }
}
/// See [`ZeppelinMonitoringConfigurationDescription`](crate::model::ZeppelinMonitoringConfigurationDescription)
pub mod zeppelin_monitoring_configuration_description {
    /// A builder for [`ZeppelinMonitoringConfigurationDescription`](crate::model::ZeppelinMonitoringConfigurationDescription)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) log_level: std::option::Option<crate::model::LogLevel>,
    }
    impl Builder {
        /// <p>Describes the verbosity of the CloudWatch Logs for an application.</p>
        pub fn log_level(mut self, input: crate::model::LogLevel) -> Self {
            self.log_level = Some(input);
            self
        }
        /// <p>Describes the verbosity of the CloudWatch Logs for an application.</p>
        pub fn set_log_level(mut self, input: std::option::Option<crate::model::LogLevel>) -> Self {
            self.log_level = input;
            self
        }
        /// Consumes the builder and constructs a [`ZeppelinMonitoringConfigurationDescription`](crate::model::ZeppelinMonitoringConfigurationDescription)
        pub fn build(self) -> crate::model::ZeppelinMonitoringConfigurationDescription {
            crate::model::ZeppelinMonitoringConfigurationDescription {
                log_level: self.log_level,
            }
        }
    }
}
impl ZeppelinMonitoringConfigurationDescription {
    /// Creates a new builder-style object to manufacture [`ZeppelinMonitoringConfigurationDescription`](crate::model::ZeppelinMonitoringConfigurationDescription)
    pub fn builder() -> crate::model::zeppelin_monitoring_configuration_description::Builder {
        crate::model::zeppelin_monitoring_configuration_description::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum LogLevel {
    #[allow(missing_docs)] // documentation missing in model
    Debug,
    #[allow(missing_docs)] // documentation missing in model
    Error,
    #[allow(missing_docs)] // documentation missing in model
    Info,
    #[allow(missing_docs)] // documentation missing in model
    Warn,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for LogLevel {
    fn from(s: &str) -> Self {
        match s {
            "DEBUG" => LogLevel::Debug,
            "ERROR" => LogLevel::Error,
            "INFO" => LogLevel::Info,
            "WARN" => LogLevel::Warn,
            other => LogLevel::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for LogLevel {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(LogLevel::from(s))
    }
}
impl LogLevel {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            LogLevel::Debug => "DEBUG",
            LogLevel::Error => "ERROR",
            LogLevel::Info => "INFO",
            LogLevel::Warn => "WARN",
            LogLevel::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["DEBUG", "ERROR", "INFO", "WARN"]
    }
}
impl AsRef<str> for LogLevel {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Describes the parameters of a VPC used by the application.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct VpcConfigurationDescription {
    /// <p>The ID of the VPC configuration.</p>
    pub vpc_configuration_id: std::option::Option<std::string::String>,
    /// <p>The ID of the associated VPC.</p>
    pub vpc_id: std::option::Option<std::string::String>,
    /// <p>The array of <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_Subnet.html">Subnet</a>
    /// IDs used by the VPC configuration.</p>
    pub subnet_ids: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The array of <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_SecurityGroup.html">SecurityGroup</a>
    /// IDs used by the VPC configuration.</p>
    pub security_group_ids: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl VpcConfigurationDescription {
    /// <p>The ID of the VPC configuration.</p>
    pub fn vpc_configuration_id(&self) -> std::option::Option<&str> {
        self.vpc_configuration_id.as_deref()
    }
    /// <p>The ID of the associated VPC.</p>
    pub fn vpc_id(&self) -> std::option::Option<&str> {
        self.vpc_id.as_deref()
    }
    /// <p>The array of <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_Subnet.html">Subnet</a>
    /// IDs used by the VPC configuration.</p>
    pub fn subnet_ids(&self) -> std::option::Option<&[std::string::String]> {
        self.subnet_ids.as_deref()
    }
    /// <p>The array of <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_SecurityGroup.html">SecurityGroup</a>
    /// IDs used by the VPC configuration.</p>
    pub fn security_group_ids(&self) -> std::option::Option<&[std::string::String]> {
        self.security_group_ids.as_deref()
    }
}
impl std::fmt::Debug for VpcConfigurationDescription {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("VpcConfigurationDescription");
        formatter.field("vpc_configuration_id", &self.vpc_configuration_id);
        formatter.field("vpc_id", &self.vpc_id);
        formatter.field("subnet_ids", &self.subnet_ids);
        formatter.field("security_group_ids", &self.security_group_ids);
        formatter.finish()
    }
}
/// See [`VpcConfigurationDescription`](crate::model::VpcConfigurationDescription)
pub mod vpc_configuration_description {
    /// A builder for [`VpcConfigurationDescription`](crate::model::VpcConfigurationDescription)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) vpc_configuration_id: std::option::Option<std::string::String>,
        pub(crate) vpc_id: std::option::Option<std::string::String>,
        pub(crate) subnet_ids: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) security_group_ids: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// <p>The ID of the VPC configuration.</p>
        pub fn vpc_configuration_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.vpc_configuration_id = Some(input.into());
            self
        }
        /// <p>The ID of the VPC configuration.</p>
        pub fn set_vpc_configuration_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.vpc_configuration_id = input;
            self
        }
        /// <p>The ID of the associated VPC.</p>
        pub fn vpc_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.vpc_id = Some(input.into());
            self
        }
        /// <p>The ID of the associated VPC.</p>
        pub fn set_vpc_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.vpc_id = input;
            self
        }
        /// Appends an item to `subnet_ids`.
        ///
        /// To override the contents of this collection use [`set_subnet_ids`](Self::set_subnet_ids).
        ///
        /// <p>The array of <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_Subnet.html">Subnet</a>
        /// IDs used by the VPC configuration.</p>
        pub fn subnet_ids(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.subnet_ids.unwrap_or_default();
            v.push(input.into());
            self.subnet_ids = Some(v);
            self
        }
        /// <p>The array of <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_Subnet.html">Subnet</a>
        /// IDs used by the VPC configuration.</p>
        pub fn set_subnet_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.subnet_ids = input;
            self
        }
        /// Appends an item to `security_group_ids`.
        ///
        /// To override the contents of this collection use [`set_security_group_ids`](Self::set_security_group_ids).
        ///
        /// <p>The array of <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_SecurityGroup.html">SecurityGroup</a>
        /// IDs used by the VPC configuration.</p>
        pub fn security_group_ids(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.security_group_ids.unwrap_or_default();
            v.push(input.into());
            self.security_group_ids = Some(v);
            self
        }
        /// <p>The array of <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_SecurityGroup.html">SecurityGroup</a>
        /// IDs used by the VPC configuration.</p>
        pub fn set_security_group_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.security_group_ids = input;
            self
        }
        /// Consumes the builder and constructs a [`VpcConfigurationDescription`](crate::model::VpcConfigurationDescription)
        pub fn build(self) -> crate::model::VpcConfigurationDescription {
            crate::model::VpcConfigurationDescription {
                vpc_configuration_id: self.vpc_configuration_id,
                vpc_id: self.vpc_id,
                subnet_ids: self.subnet_ids,
                security_group_ids: self.security_group_ids,
            }
        }
    }
}
impl VpcConfigurationDescription {
    /// Creates a new builder-style object to manufacture [`VpcConfigurationDescription`](crate::model::VpcConfigurationDescription)
    pub fn builder() -> crate::model::vpc_configuration_description::Builder {
        crate::model::vpc_configuration_description::Builder::default()
    }
}

/// <p>Describes whether snapshots are enabled for a Flink-based Kinesis Data Analytics application.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ApplicationSnapshotConfigurationDescription {
    /// <p>Describes whether snapshots are enabled for a Flink-based Kinesis Data Analytics application.</p>
    pub snapshots_enabled: std::option::Option<bool>,
}
impl ApplicationSnapshotConfigurationDescription {
    /// <p>Describes whether snapshots are enabled for a Flink-based Kinesis Data Analytics application.</p>
    pub fn snapshots_enabled(&self) -> std::option::Option<bool> {
        self.snapshots_enabled
    }
}
impl std::fmt::Debug for ApplicationSnapshotConfigurationDescription {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ApplicationSnapshotConfigurationDescription");
        formatter.field("snapshots_enabled", &self.snapshots_enabled);
        formatter.finish()
    }
}
/// See [`ApplicationSnapshotConfigurationDescription`](crate::model::ApplicationSnapshotConfigurationDescription)
pub mod application_snapshot_configuration_description {
    /// A builder for [`ApplicationSnapshotConfigurationDescription`](crate::model::ApplicationSnapshotConfigurationDescription)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) snapshots_enabled: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>Describes whether snapshots are enabled for a Flink-based Kinesis Data Analytics application.</p>
        pub fn snapshots_enabled(mut self, input: bool) -> Self {
            self.snapshots_enabled = Some(input);
            self
        }
        /// <p>Describes whether snapshots are enabled for a Flink-based Kinesis Data Analytics application.</p>
        pub fn set_snapshots_enabled(mut self, input: std::option::Option<bool>) -> Self {
            self.snapshots_enabled = input;
            self
        }
        /// Consumes the builder and constructs a [`ApplicationSnapshotConfigurationDescription`](crate::model::ApplicationSnapshotConfigurationDescription)
        pub fn build(self) -> crate::model::ApplicationSnapshotConfigurationDescription {
            crate::model::ApplicationSnapshotConfigurationDescription {
                snapshots_enabled: self.snapshots_enabled,
            }
        }
    }
}
impl ApplicationSnapshotConfigurationDescription {
    /// Creates a new builder-style object to manufacture [`ApplicationSnapshotConfigurationDescription`](crate::model::ApplicationSnapshotConfigurationDescription)
    pub fn builder() -> crate::model::application_snapshot_configuration_description::Builder {
        crate::model::application_snapshot_configuration_description::Builder::default()
    }
}

/// <p>Describes the execution properties for an Apache Flink runtime.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct EnvironmentPropertyDescriptions {
    /// <p>Describes the execution property groups.</p>
    pub property_group_descriptions:
        std::option::Option<std::vec::Vec<crate::model::PropertyGroup>>,
}
impl EnvironmentPropertyDescriptions {
    /// <p>Describes the execution property groups.</p>
    pub fn property_group_descriptions(
        &self,
    ) -> std::option::Option<&[crate::model::PropertyGroup]> {
        self.property_group_descriptions.as_deref()
    }
}
impl std::fmt::Debug for EnvironmentPropertyDescriptions {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("EnvironmentPropertyDescriptions");
        formatter.field(
            "property_group_descriptions",
            &self.property_group_descriptions,
        );
        formatter.finish()
    }
}
/// See [`EnvironmentPropertyDescriptions`](crate::model::EnvironmentPropertyDescriptions)
pub mod environment_property_descriptions {
    /// A builder for [`EnvironmentPropertyDescriptions`](crate::model::EnvironmentPropertyDescriptions)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) property_group_descriptions:
            std::option::Option<std::vec::Vec<crate::model::PropertyGroup>>,
    }
    impl Builder {
        /// Appends an item to `property_group_descriptions`.
        ///
        /// To override the contents of this collection use [`set_property_group_descriptions`](Self::set_property_group_descriptions).
        ///
        /// <p>Describes the execution property groups.</p>
        pub fn property_group_descriptions(
            mut self,
            input: impl Into<crate::model::PropertyGroup>,
        ) -> Self {
            let mut v = self.property_group_descriptions.unwrap_or_default();
            v.push(input.into());
            self.property_group_descriptions = Some(v);
            self
        }
        /// <p>Describes the execution property groups.</p>
        pub fn set_property_group_descriptions(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::PropertyGroup>>,
        ) -> Self {
            self.property_group_descriptions = input;
            self
        }
        /// Consumes the builder and constructs a [`EnvironmentPropertyDescriptions`](crate::model::EnvironmentPropertyDescriptions)
        pub fn build(self) -> crate::model::EnvironmentPropertyDescriptions {
            crate::model::EnvironmentPropertyDescriptions {
                property_group_descriptions: self.property_group_descriptions,
            }
        }
    }
}
impl EnvironmentPropertyDescriptions {
    /// Creates a new builder-style object to manufacture [`EnvironmentPropertyDescriptions`](crate::model::EnvironmentPropertyDescriptions)
    pub fn builder() -> crate::model::environment_property_descriptions::Builder {
        crate::model::environment_property_descriptions::Builder::default()
    }
}

/// <p>Property key-value pairs passed into an application.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PropertyGroup {
    /// <p>Describes the key of an application execution property key-value pair.</p>
    pub property_group_id: std::option::Option<std::string::String>,
    /// <p>Describes the value of an application execution property key-value pair.</p>
    pub property_map:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
}
impl PropertyGroup {
    /// <p>Describes the key of an application execution property key-value pair.</p>
    pub fn property_group_id(&self) -> std::option::Option<&str> {
        self.property_group_id.as_deref()
    }
    /// <p>Describes the value of an application execution property key-value pair.</p>
    pub fn property_map(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.property_map.as_ref()
    }
}
impl std::fmt::Debug for PropertyGroup {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PropertyGroup");
        formatter.field("property_group_id", &self.property_group_id);
        formatter.field("property_map", &self.property_map);
        formatter.finish()
    }
}
/// See [`PropertyGroup`](crate::model::PropertyGroup)
pub mod property_group {
    /// A builder for [`PropertyGroup`](crate::model::PropertyGroup)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) property_group_id: std::option::Option<std::string::String>,
        pub(crate) property_map: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
    }
    impl Builder {
        /// <p>Describes the key of an application execution property key-value pair.</p>
        pub fn property_group_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.property_group_id = Some(input.into());
            self
        }
        /// <p>Describes the key of an application execution property key-value pair.</p>
        pub fn set_property_group_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.property_group_id = input;
            self
        }
        /// Adds a key-value pair to `property_map`.
        ///
        /// To override the contents of this collection use [`set_property_map`](Self::set_property_map).
        ///
        /// <p>Describes the value of an application execution property key-value pair.</p>
        pub fn property_map(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.property_map.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.property_map = Some(hash_map);
            self
        }
        /// <p>Describes the value of an application execution property key-value pair.</p>
        pub fn set_property_map(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.property_map = input;
            self
        }
        /// Consumes the builder and constructs a [`PropertyGroup`](crate::model::PropertyGroup)
        pub fn build(self) -> crate::model::PropertyGroup {
            crate::model::PropertyGroup {
                property_group_id: self.property_group_id,
                property_map: self.property_map,
            }
        }
    }
}
impl PropertyGroup {
    /// Creates a new builder-style object to manufacture [`PropertyGroup`](crate::model::PropertyGroup)
    pub fn builder() -> crate::model::property_group::Builder {
        crate::model::property_group::Builder::default()
    }
}

/// <p>Describes configuration parameters for a Flink-based Kinesis Data Analytics application.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct FlinkApplicationConfigurationDescription {
    /// <p>Describes an application's checkpointing configuration. Checkpointing is the process of persisting application state
    /// for fault tolerance.</p>
    pub checkpoint_configuration_description:
        std::option::Option<crate::model::CheckpointConfigurationDescription>,
    /// <p>Describes configuration parameters for Amazon CloudWatch logging for an
    /// application.</p>
    pub monitoring_configuration_description:
        std::option::Option<crate::model::MonitoringConfigurationDescription>,
    /// <p>Describes parameters for how an application executes multiple tasks simultaneously.</p>
    pub parallelism_configuration_description:
        std::option::Option<crate::model::ParallelismConfigurationDescription>,
    /// <p>The job plan for an application. For more information about the job plan, see <a href="https://ci.apache.org/projects/flink/flink-docs-release-1.8/internals/job_scheduling.html">Jobs and Scheduling</a> in the <a href="https://ci.apache.org/projects/flink/flink-docs-release-1.8/">Apache Flink
    /// Documentation</a>. To retrieve the job plan for the application, use the <a>DescribeApplicationRequest$IncludeAdditionalDetails</a> parameter of the <a>DescribeApplication</a> operation.</p>
    pub job_plan_description: std::option::Option<std::string::String>,
}
impl FlinkApplicationConfigurationDescription {
    /// <p>Describes an application's checkpointing configuration. Checkpointing is the process of persisting application state
    /// for fault tolerance.</p>
    pub fn checkpoint_configuration_description(
        &self,
    ) -> std::option::Option<&crate::model::CheckpointConfigurationDescription> {
        self.checkpoint_configuration_description.as_ref()
    }
    /// <p>Describes configuration parameters for Amazon CloudWatch logging for an
    /// application.</p>
    pub fn monitoring_configuration_description(
        &self,
    ) -> std::option::Option<&crate::model::MonitoringConfigurationDescription> {
        self.monitoring_configuration_description.as_ref()
    }
    /// <p>Describes parameters for how an application executes multiple tasks simultaneously.</p>
    pub fn parallelism_configuration_description(
        &self,
    ) -> std::option::Option<&crate::model::ParallelismConfigurationDescription> {
        self.parallelism_configuration_description.as_ref()
    }
    /// <p>The job plan for an application. For more information about the job plan, see <a href="https://ci.apache.org/projects/flink/flink-docs-release-1.8/internals/job_scheduling.html">Jobs and Scheduling</a> in the <a href="https://ci.apache.org/projects/flink/flink-docs-release-1.8/">Apache Flink
    /// Documentation</a>. To retrieve the job plan for the application, use the <a>DescribeApplicationRequest$IncludeAdditionalDetails</a> parameter of the <a>DescribeApplication</a> operation.</p>
    pub fn job_plan_description(&self) -> std::option::Option<&str> {
        self.job_plan_description.as_deref()
    }
}
impl std::fmt::Debug for FlinkApplicationConfigurationDescription {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("FlinkApplicationConfigurationDescription");
        formatter.field(
            "checkpoint_configuration_description",
            &self.checkpoint_configuration_description,
        );
        formatter.field(
            "monitoring_configuration_description",
            &self.monitoring_configuration_description,
        );
        formatter.field(
            "parallelism_configuration_description",
            &self.parallelism_configuration_description,
        );
        formatter.field("job_plan_description", &self.job_plan_description);
        formatter.finish()
    }
}
/// See [`FlinkApplicationConfigurationDescription`](crate::model::FlinkApplicationConfigurationDescription)
pub mod flink_application_configuration_description {
    /// A builder for [`FlinkApplicationConfigurationDescription`](crate::model::FlinkApplicationConfigurationDescription)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) checkpoint_configuration_description:
            std::option::Option<crate::model::CheckpointConfigurationDescription>,
        pub(crate) monitoring_configuration_description:
            std::option::Option<crate::model::MonitoringConfigurationDescription>,
        pub(crate) parallelism_configuration_description:
            std::option::Option<crate::model::ParallelismConfigurationDescription>,
        pub(crate) job_plan_description: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Describes an application's checkpointing configuration. Checkpointing is the process of persisting application state
        /// for fault tolerance.</p>
        pub fn checkpoint_configuration_description(
            mut self,
            input: crate::model::CheckpointConfigurationDescription,
        ) -> Self {
            self.checkpoint_configuration_description = Some(input);
            self
        }
        /// <p>Describes an application's checkpointing configuration. Checkpointing is the process of persisting application state
        /// for fault tolerance.</p>
        pub fn set_checkpoint_configuration_description(
            mut self,
            input: std::option::Option<crate::model::CheckpointConfigurationDescription>,
        ) -> Self {
            self.checkpoint_configuration_description = input;
            self
        }
        /// <p>Describes configuration parameters for Amazon CloudWatch logging for an
        /// application.</p>
        pub fn monitoring_configuration_description(
            mut self,
            input: crate::model::MonitoringConfigurationDescription,
        ) -> Self {
            self.monitoring_configuration_description = Some(input);
            self
        }
        /// <p>Describes configuration parameters for Amazon CloudWatch logging for an
        /// application.</p>
        pub fn set_monitoring_configuration_description(
            mut self,
            input: std::option::Option<crate::model::MonitoringConfigurationDescription>,
        ) -> Self {
            self.monitoring_configuration_description = input;
            self
        }
        /// <p>Describes parameters for how an application executes multiple tasks simultaneously.</p>
        pub fn parallelism_configuration_description(
            mut self,
            input: crate::model::ParallelismConfigurationDescription,
        ) -> Self {
            self.parallelism_configuration_description = Some(input);
            self
        }
        /// <p>Describes parameters for how an application executes multiple tasks simultaneously.</p>
        pub fn set_parallelism_configuration_description(
            mut self,
            input: std::option::Option<crate::model::ParallelismConfigurationDescription>,
        ) -> Self {
            self.parallelism_configuration_description = input;
            self
        }
        /// <p>The job plan for an application. For more information about the job plan, see <a href="https://ci.apache.org/projects/flink/flink-docs-release-1.8/internals/job_scheduling.html">Jobs and Scheduling</a> in the <a href="https://ci.apache.org/projects/flink/flink-docs-release-1.8/">Apache Flink
        /// Documentation</a>. To retrieve the job plan for the application, use the <a>DescribeApplicationRequest$IncludeAdditionalDetails</a> parameter of the <a>DescribeApplication</a> operation.</p>
        pub fn job_plan_description(mut self, input: impl Into<std::string::String>) -> Self {
            self.job_plan_description = Some(input.into());
            self
        }
        /// <p>The job plan for an application. For more information about the job plan, see <a href="https://ci.apache.org/projects/flink/flink-docs-release-1.8/internals/job_scheduling.html">Jobs and Scheduling</a> in the <a href="https://ci.apache.org/projects/flink/flink-docs-release-1.8/">Apache Flink
        /// Documentation</a>. To retrieve the job plan for the application, use the <a>DescribeApplicationRequest$IncludeAdditionalDetails</a> parameter of the <a>DescribeApplication</a> operation.</p>
        pub fn set_job_plan_description(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.job_plan_description = input;
            self
        }
        /// Consumes the builder and constructs a [`FlinkApplicationConfigurationDescription`](crate::model::FlinkApplicationConfigurationDescription)
        pub fn build(self) -> crate::model::FlinkApplicationConfigurationDescription {
            crate::model::FlinkApplicationConfigurationDescription {
                checkpoint_configuration_description: self.checkpoint_configuration_description,
                monitoring_configuration_description: self.monitoring_configuration_description,
                parallelism_configuration_description: self.parallelism_configuration_description,
                job_plan_description: self.job_plan_description,
            }
        }
    }
}
impl FlinkApplicationConfigurationDescription {
    /// Creates a new builder-style object to manufacture [`FlinkApplicationConfigurationDescription`](crate::model::FlinkApplicationConfigurationDescription)
    pub fn builder() -> crate::model::flink_application_configuration_description::Builder {
        crate::model::flink_application_configuration_description::Builder::default()
    }
}

/// <p>Describes parameters for how a Flink-based Kinesis Data Analytics application
/// executes multiple tasks simultaneously.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ParallelismConfigurationDescription {
    /// <p>Describes whether the application uses the default parallelism for the Kinesis Data Analytics service. </p>
    pub configuration_type: std::option::Option<crate::model::ConfigurationType>,
    /// <p>Describes the initial number of parallel tasks that a Flink-based Kinesis Data Analytics application can perform.
    /// If <code>AutoScalingEnabled</code> is set to True, then Kinesis Data Analytics can increase the <code>CurrentParallelism</code> value in response to application
    /// load. The service can increase <code>CurrentParallelism</code> up to the maximum parallelism, which is <code>ParalellismPerKPU</code> times the maximum KPUs for the application.
    /// The maximum KPUs for an application is 32 by default, and can be increased by requesting a limit increase. If application load is reduced, the service can
    /// reduce the <code>CurrentParallelism</code> value down to the <code>Parallelism</code> setting.</p>
    pub parallelism: std::option::Option<i32>,
    /// <p>Describes the number of parallel tasks that a Flink-based Kinesis Data Analytics application can perform per
    /// Kinesis Processing Unit (KPU) used by the application.</p>
    pub parallelism_per_kpu: std::option::Option<i32>,
    /// <p>Describes the current number of parallel tasks that a Flink-based Kinesis Data Analytics application can perform.
    /// If <code>AutoScalingEnabled</code> is set to True, Kinesis Data Analytics can increase this value in response to application
    /// load. The service can increase this value up to the maximum parallelism, which is <code>ParalellismPerKPU</code> times the maximum KPUs for the application.
    /// The maximum KPUs for an application is 32 by default, and can be increased by requesting a limit increase. If application load is reduced, the service can reduce
    /// the <code>CurrentParallelism</code> value down to the <code>Parallelism</code> setting.</p>
    pub current_parallelism: std::option::Option<i32>,
    /// <p>Describes whether the Kinesis Data Analytics service can increase the parallelism of the application in response to increased throughput.</p>
    pub auto_scaling_enabled: std::option::Option<bool>,
}
impl ParallelismConfigurationDescription {
    /// <p>Describes whether the application uses the default parallelism for the Kinesis Data Analytics service. </p>
    pub fn configuration_type(&self) -> std::option::Option<&crate::model::ConfigurationType> {
        self.configuration_type.as_ref()
    }
    /// <p>Describes the initial number of parallel tasks that a Flink-based Kinesis Data Analytics application can perform.
    /// If <code>AutoScalingEnabled</code> is set to True, then Kinesis Data Analytics can increase the <code>CurrentParallelism</code> value in response to application
    /// load. The service can increase <code>CurrentParallelism</code> up to the maximum parallelism, which is <code>ParalellismPerKPU</code> times the maximum KPUs for the application.
    /// The maximum KPUs for an application is 32 by default, and can be increased by requesting a limit increase. If application load is reduced, the service can
    /// reduce the <code>CurrentParallelism</code> value down to the <code>Parallelism</code> setting.</p>
    pub fn parallelism(&self) -> std::option::Option<i32> {
        self.parallelism
    }
    /// <p>Describes the number of parallel tasks that a Flink-based Kinesis Data Analytics application can perform per
    /// Kinesis Processing Unit (KPU) used by the application.</p>
    pub fn parallelism_per_kpu(&self) -> std::option::Option<i32> {
        self.parallelism_per_kpu
    }
    /// <p>Describes the current number of parallel tasks that a Flink-based Kinesis Data Analytics application can perform.
    /// If <code>AutoScalingEnabled</code> is set to True, Kinesis Data Analytics can increase this value in response to application
    /// load. The service can increase this value up to the maximum parallelism, which is <code>ParalellismPerKPU</code> times the maximum KPUs for the application.
    /// The maximum KPUs for an application is 32 by default, and can be increased by requesting a limit increase. If application load is reduced, the service can reduce
    /// the <code>CurrentParallelism</code> value down to the <code>Parallelism</code> setting.</p>
    pub fn current_parallelism(&self) -> std::option::Option<i32> {
        self.current_parallelism
    }
    /// <p>Describes whether the Kinesis Data Analytics service can increase the parallelism of the application in response to increased throughput.</p>
    pub fn auto_scaling_enabled(&self) -> std::option::Option<bool> {
        self.auto_scaling_enabled
    }
}
impl std::fmt::Debug for ParallelismConfigurationDescription {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ParallelismConfigurationDescription");
        formatter.field("configuration_type", &self.configuration_type);
        formatter.field("parallelism", &self.parallelism);
        formatter.field("parallelism_per_kpu", &self.parallelism_per_kpu);
        formatter.field("current_parallelism", &self.current_parallelism);
        formatter.field("auto_scaling_enabled", &self.auto_scaling_enabled);
        formatter.finish()
    }
}
/// See [`ParallelismConfigurationDescription`](crate::model::ParallelismConfigurationDescription)
pub mod parallelism_configuration_description {
    /// A builder for [`ParallelismConfigurationDescription`](crate::model::ParallelismConfigurationDescription)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) configuration_type: std::option::Option<crate::model::ConfigurationType>,
        pub(crate) parallelism: std::option::Option<i32>,
        pub(crate) parallelism_per_kpu: std::option::Option<i32>,
        pub(crate) current_parallelism: std::option::Option<i32>,
        pub(crate) auto_scaling_enabled: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>Describes whether the application uses the default parallelism for the Kinesis Data Analytics service. </p>
        pub fn configuration_type(mut self, input: crate::model::ConfigurationType) -> Self {
            self.configuration_type = Some(input);
            self
        }
        /// <p>Describes whether the application uses the default parallelism for the Kinesis Data Analytics service. </p>
        pub fn set_configuration_type(
            mut self,
            input: std::option::Option<crate::model::ConfigurationType>,
        ) -> Self {
            self.configuration_type = input;
            self
        }
        /// <p>Describes the initial number of parallel tasks that a Flink-based Kinesis Data Analytics application can perform.
        /// If <code>AutoScalingEnabled</code> is set to True, then Kinesis Data Analytics can increase the <code>CurrentParallelism</code> value in response to application
        /// load. The service can increase <code>CurrentParallelism</code> up to the maximum parallelism, which is <code>ParalellismPerKPU</code> times the maximum KPUs for the application.
        /// The maximum KPUs for an application is 32 by default, and can be increased by requesting a limit increase. If application load is reduced, the service can
        /// reduce the <code>CurrentParallelism</code> value down to the <code>Parallelism</code> setting.</p>
        pub fn parallelism(mut self, input: i32) -> Self {
            self.parallelism = Some(input);
            self
        }
        /// <p>Describes the initial number of parallel tasks that a Flink-based Kinesis Data Analytics application can perform.
        /// If <code>AutoScalingEnabled</code> is set to True, then Kinesis Data Analytics can increase the <code>CurrentParallelism</code> value in response to application
        /// load. The service can increase <code>CurrentParallelism</code> up to the maximum parallelism, which is <code>ParalellismPerKPU</code> times the maximum KPUs for the application.
        /// The maximum KPUs for an application is 32 by default, and can be increased by requesting a limit increase. If application load is reduced, the service can
        /// reduce the <code>CurrentParallelism</code> value down to the <code>Parallelism</code> setting.</p>
        pub fn set_parallelism(mut self, input: std::option::Option<i32>) -> Self {
            self.parallelism = input;
            self
        }
        /// <p>Describes the number of parallel tasks that a Flink-based Kinesis Data Analytics application can perform per
        /// Kinesis Processing Unit (KPU) used by the application.</p>
        pub fn parallelism_per_kpu(mut self, input: i32) -> Self {
            self.parallelism_per_kpu = Some(input);
            self
        }
        /// <p>Describes the number of parallel tasks that a Flink-based Kinesis Data Analytics application can perform per
        /// Kinesis Processing Unit (KPU) used by the application.</p>
        pub fn set_parallelism_per_kpu(mut self, input: std::option::Option<i32>) -> Self {
            self.parallelism_per_kpu = input;
            self
        }
        /// <p>Describes the current number of parallel tasks that a Flink-based Kinesis Data Analytics application can perform.
        /// If <code>AutoScalingEnabled</code> is set to True, Kinesis Data Analytics can increase this value in response to application
        /// load. The service can increase this value up to the maximum parallelism, which is <code>ParalellismPerKPU</code> times the maximum KPUs for the application.
        /// The maximum KPUs for an application is 32 by default, and can be increased by requesting a limit increase. If application load is reduced, the service can reduce
        /// the <code>CurrentParallelism</code> value down to the <code>Parallelism</code> setting.</p>
        pub fn current_parallelism(mut self, input: i32) -> Self {
            self.current_parallelism = Some(input);
            self
        }
        /// <p>Describes the current number of parallel tasks that a Flink-based Kinesis Data Analytics application can perform.
        /// If <code>AutoScalingEnabled</code> is set to True, Kinesis Data Analytics can increase this value in response to application
        /// load. The service can increase this value up to the maximum parallelism, which is <code>ParalellismPerKPU</code> times the maximum KPUs for the application.
        /// The maximum KPUs for an application is 32 by default, and can be increased by requesting a limit increase. If application load is reduced, the service can reduce
        /// the <code>CurrentParallelism</code> value down to the <code>Parallelism</code> setting.</p>
        pub fn set_current_parallelism(mut self, input: std::option::Option<i32>) -> Self {
            self.current_parallelism = input;
            self
        }
        /// <p>Describes whether the Kinesis Data Analytics service can increase the parallelism of the application in response to increased throughput.</p>
        pub fn auto_scaling_enabled(mut self, input: bool) -> Self {
            self.auto_scaling_enabled = Some(input);
            self
        }
        /// <p>Describes whether the Kinesis Data Analytics service can increase the parallelism of the application in response to increased throughput.</p>
        pub fn set_auto_scaling_enabled(mut self, input: std::option::Option<bool>) -> Self {
            self.auto_scaling_enabled = input;
            self
        }
        /// Consumes the builder and constructs a [`ParallelismConfigurationDescription`](crate::model::ParallelismConfigurationDescription)
        pub fn build(self) -> crate::model::ParallelismConfigurationDescription {
            crate::model::ParallelismConfigurationDescription {
                configuration_type: self.configuration_type,
                parallelism: self.parallelism,
                parallelism_per_kpu: self.parallelism_per_kpu,
                current_parallelism: self.current_parallelism,
                auto_scaling_enabled: self.auto_scaling_enabled,
            }
        }
    }
}
impl ParallelismConfigurationDescription {
    /// Creates a new builder-style object to manufacture [`ParallelismConfigurationDescription`](crate::model::ParallelismConfigurationDescription)
    pub fn builder() -> crate::model::parallelism_configuration_description::Builder {
        crate::model::parallelism_configuration_description::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ConfigurationType {
    #[allow(missing_docs)] // documentation missing in model
    Custom,
    #[allow(missing_docs)] // documentation missing in model
    Default,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for ConfigurationType {
    fn from(s: &str) -> Self {
        match s {
            "CUSTOM" => ConfigurationType::Custom,
            "DEFAULT" => ConfigurationType::Default,
            other => ConfigurationType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for ConfigurationType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ConfigurationType::from(s))
    }
}
impl ConfigurationType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ConfigurationType::Custom => "CUSTOM",
            ConfigurationType::Default => "DEFAULT",
            ConfigurationType::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["CUSTOM", "DEFAULT"]
    }
}
impl AsRef<str> for ConfigurationType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Describes configuration parameters for CloudWatch logging for an application.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct MonitoringConfigurationDescription {
    /// <p>Describes whether to use the default CloudWatch logging configuration for an application.</p>
    pub configuration_type: std::option::Option<crate::model::ConfigurationType>,
    /// <p>Describes the granularity of the CloudWatch Logs for an application.</p>
    pub metrics_level: std::option::Option<crate::model::MetricsLevel>,
    /// <p>Describes the verbosity of the CloudWatch Logs for an application.</p>
    pub log_level: std::option::Option<crate::model::LogLevel>,
}
impl MonitoringConfigurationDescription {
    /// <p>Describes whether to use the default CloudWatch logging configuration for an application.</p>
    pub fn configuration_type(&self) -> std::option::Option<&crate::model::ConfigurationType> {
        self.configuration_type.as_ref()
    }
    /// <p>Describes the granularity of the CloudWatch Logs for an application.</p>
    pub fn metrics_level(&self) -> std::option::Option<&crate::model::MetricsLevel> {
        self.metrics_level.as_ref()
    }
    /// <p>Describes the verbosity of the CloudWatch Logs for an application.</p>
    pub fn log_level(&self) -> std::option::Option<&crate::model::LogLevel> {
        self.log_level.as_ref()
    }
}
impl std::fmt::Debug for MonitoringConfigurationDescription {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("MonitoringConfigurationDescription");
        formatter.field("configuration_type", &self.configuration_type);
        formatter.field("metrics_level", &self.metrics_level);
        formatter.field("log_level", &self.log_level);
        formatter.finish()
    }
}
/// See [`MonitoringConfigurationDescription`](crate::model::MonitoringConfigurationDescription)
pub mod monitoring_configuration_description {
    /// A builder for [`MonitoringConfigurationDescription`](crate::model::MonitoringConfigurationDescription)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) configuration_type: std::option::Option<crate::model::ConfigurationType>,
        pub(crate) metrics_level: std::option::Option<crate::model::MetricsLevel>,
        pub(crate) log_level: std::option::Option<crate::model::LogLevel>,
    }
    impl Builder {
        /// <p>Describes whether to use the default CloudWatch logging configuration for an application.</p>
        pub fn configuration_type(mut self, input: crate::model::ConfigurationType) -> Self {
            self.configuration_type = Some(input);
            self
        }
        /// <p>Describes whether to use the default CloudWatch logging configuration for an application.</p>
        pub fn set_configuration_type(
            mut self,
            input: std::option::Option<crate::model::ConfigurationType>,
        ) -> Self {
            self.configuration_type = input;
            self
        }
        /// <p>Describes the granularity of the CloudWatch Logs for an application.</p>
        pub fn metrics_level(mut self, input: crate::model::MetricsLevel) -> Self {
            self.metrics_level = Some(input);
            self
        }
        /// <p>Describes the granularity of the CloudWatch Logs for an application.</p>
        pub fn set_metrics_level(
            mut self,
            input: std::option::Option<crate::model::MetricsLevel>,
        ) -> Self {
            self.metrics_level = input;
            self
        }
        /// <p>Describes the verbosity of the CloudWatch Logs for an application.</p>
        pub fn log_level(mut self, input: crate::model::LogLevel) -> Self {
            self.log_level = Some(input);
            self
        }
        /// <p>Describes the verbosity of the CloudWatch Logs for an application.</p>
        pub fn set_log_level(mut self, input: std::option::Option<crate::model::LogLevel>) -> Self {
            self.log_level = input;
            self
        }
        /// Consumes the builder and constructs a [`MonitoringConfigurationDescription`](crate::model::MonitoringConfigurationDescription)
        pub fn build(self) -> crate::model::MonitoringConfigurationDescription {
            crate::model::MonitoringConfigurationDescription {
                configuration_type: self.configuration_type,
                metrics_level: self.metrics_level,
                log_level: self.log_level,
            }
        }
    }
}
impl MonitoringConfigurationDescription {
    /// Creates a new builder-style object to manufacture [`MonitoringConfigurationDescription`](crate::model::MonitoringConfigurationDescription)
    pub fn builder() -> crate::model::monitoring_configuration_description::Builder {
        crate::model::monitoring_configuration_description::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum MetricsLevel {
    #[allow(missing_docs)] // documentation missing in model
    Application,
    #[allow(missing_docs)] // documentation missing in model
    Operator,
    #[allow(missing_docs)] // documentation missing in model
    Parallelism,
    #[allow(missing_docs)] // documentation missing in model
    Task,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for MetricsLevel {
    fn from(s: &str) -> Self {
        match s {
            "APPLICATION" => MetricsLevel::Application,
            "OPERATOR" => MetricsLevel::Operator,
            "PARALLELISM" => MetricsLevel::Parallelism,
            "TASK" => MetricsLevel::Task,
            other => MetricsLevel::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for MetricsLevel {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(MetricsLevel::from(s))
    }
}
impl MetricsLevel {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            MetricsLevel::Application => "APPLICATION",
            MetricsLevel::Operator => "OPERATOR",
            MetricsLevel::Parallelism => "PARALLELISM",
            MetricsLevel::Task => "TASK",
            MetricsLevel::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["APPLICATION", "OPERATOR", "PARALLELISM", "TASK"]
    }
}
impl AsRef<str> for MetricsLevel {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Describes checkpointing parameters for a Flink-based Kinesis Data Analytics application.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CheckpointConfigurationDescription {
    /// <p>Describes whether the application uses the default checkpointing behavior in Kinesis Data Analytics. </p>
    /// <note>
    /// <p>If this value is set to <code>DEFAULT</code>, the application will use the following values,
    /// even if they are set to other values using APIs or
    /// application code:</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <b>CheckpointingEnabled:</b> true</p>
    /// </li>
    /// <li>
    /// <p>
    /// <b>CheckpointInterval:</b> 60000</p>
    /// </li>
    /// <li>
    /// <p>
    /// <b>MinPauseBetweenCheckpoints:</b> 5000</p>
    /// </li>
    /// </ul>
    /// </note>
    pub configuration_type: std::option::Option<crate::model::ConfigurationType>,
    /// <p>Describes whether checkpointing is enabled for a Flink-based Kinesis Data Analytics application.</p>
    /// <note>
    /// <p>If <code>CheckpointConfiguration.ConfigurationType</code> is <code>DEFAULT</code>,
    /// the application will use a <code>CheckpointingEnabled</code> value of <code>true</code>, even if this value is set to
    /// another value using this API or in application code.</p>
    /// </note>
    pub checkpointing_enabled: std::option::Option<bool>,
    /// <p>Describes the interval in milliseconds between checkpoint operations. </p>
    /// <note>
    /// <p>If <code>CheckpointConfiguration.ConfigurationType</code> is <code>DEFAULT</code>,
    /// the application will use a <code>CheckpointInterval</code> value of 60000, even if this value is set to another value
    /// using this API or in application code.</p>
    /// </note>
    pub checkpoint_interval: std::option::Option<i64>,
    /// <p>Describes the minimum time in milliseconds after a checkpoint operation completes that a new checkpoint operation
    /// can start. </p>
    /// <note>
    /// <p>If <code>CheckpointConfiguration.ConfigurationType</code> is <code>DEFAULT</code>,
    /// the application will use a <code>MinPauseBetweenCheckpoints</code> value of 5000, even if this value is set using this
    /// API or in application code.</p>
    /// </note>
    pub min_pause_between_checkpoints: std::option::Option<i64>,
}
impl CheckpointConfigurationDescription {
    /// <p>Describes whether the application uses the default checkpointing behavior in Kinesis Data Analytics. </p>
    /// <note>
    /// <p>If this value is set to <code>DEFAULT</code>, the application will use the following values,
    /// even if they are set to other values using APIs or
    /// application code:</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <b>CheckpointingEnabled:</b> true</p>
    /// </li>
    /// <li>
    /// <p>
    /// <b>CheckpointInterval:</b> 60000</p>
    /// </li>
    /// <li>
    /// <p>
    /// <b>MinPauseBetweenCheckpoints:</b> 5000</p>
    /// </li>
    /// </ul>
    /// </note>
    pub fn configuration_type(&self) -> std::option::Option<&crate::model::ConfigurationType> {
        self.configuration_type.as_ref()
    }
    /// <p>Describes whether checkpointing is enabled for a Flink-based Kinesis Data Analytics application.</p>
    /// <note>
    /// <p>If <code>CheckpointConfiguration.ConfigurationType</code> is <code>DEFAULT</code>,
    /// the application will use a <code>CheckpointingEnabled</code> value of <code>true</code>, even if this value is set to
    /// another value using this API or in application code.</p>
    /// </note>
    pub fn checkpointing_enabled(&self) -> std::option::Option<bool> {
        self.checkpointing_enabled
    }
    /// <p>Describes the interval in milliseconds between checkpoint operations. </p>
    /// <note>
    /// <p>If <code>CheckpointConfiguration.ConfigurationType</code> is <code>DEFAULT</code>,
    /// the application will use a <code>CheckpointInterval</code> value of 60000, even if this value is set to another value
    /// using this API or in application code.</p>
    /// </note>
    pub fn checkpoint_interval(&self) -> std::option::Option<i64> {
        self.checkpoint_interval
    }
    /// <p>Describes the minimum time in milliseconds after a checkpoint operation completes that a new checkpoint operation
    /// can start. </p>
    /// <note>
    /// <p>If <code>CheckpointConfiguration.ConfigurationType</code> is <code>DEFAULT</code>,
    /// the application will use a <code>MinPauseBetweenCheckpoints</code> value of 5000, even if this value is set using this
    /// API or in application code.</p>
    /// </note>
    pub fn min_pause_between_checkpoints(&self) -> std::option::Option<i64> {
        self.min_pause_between_checkpoints
    }
}
impl std::fmt::Debug for CheckpointConfigurationDescription {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CheckpointConfigurationDescription");
        formatter.field("configuration_type", &self.configuration_type);
        formatter.field("checkpointing_enabled", &self.checkpointing_enabled);
        formatter.field("checkpoint_interval", &self.checkpoint_interval);
        formatter.field(
            "min_pause_between_checkpoints",
            &self.min_pause_between_checkpoints,
        );
        formatter.finish()
    }
}
/// See [`CheckpointConfigurationDescription`](crate::model::CheckpointConfigurationDescription)
pub mod checkpoint_configuration_description {
    /// A builder for [`CheckpointConfigurationDescription`](crate::model::CheckpointConfigurationDescription)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) configuration_type: std::option::Option<crate::model::ConfigurationType>,
        pub(crate) checkpointing_enabled: std::option::Option<bool>,
        pub(crate) checkpoint_interval: std::option::Option<i64>,
        pub(crate) min_pause_between_checkpoints: std::option::Option<i64>,
    }
    impl Builder {
        /// <p>Describes whether the application uses the default checkpointing behavior in Kinesis Data Analytics. </p>
        /// <note>
        /// <p>If this value is set to <code>DEFAULT</code>, the application will use the following values,
        /// even if they are set to other values using APIs or
        /// application code:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <b>CheckpointingEnabled:</b> true</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>CheckpointInterval:</b> 60000</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>MinPauseBetweenCheckpoints:</b> 5000</p>
        /// </li>
        /// </ul>
        /// </note>
        pub fn configuration_type(mut self, input: crate::model::ConfigurationType) -> Self {
            self.configuration_type = Some(input);
            self
        }
        /// <p>Describes whether the application uses the default checkpointing behavior in Kinesis Data Analytics. </p>
        /// <note>
        /// <p>If this value is set to <code>DEFAULT</code>, the application will use the following values,
        /// even if they are set to other values using APIs or
        /// application code:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <b>CheckpointingEnabled:</b> true</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>CheckpointInterval:</b> 60000</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>MinPauseBetweenCheckpoints:</b> 5000</p>
        /// </li>
        /// </ul>
        /// </note>
        pub fn set_configuration_type(
            mut self,
            input: std::option::Option<crate::model::ConfigurationType>,
        ) -> Self {
            self.configuration_type = input;
            self
        }
        /// <p>Describes whether checkpointing is enabled for a Flink-based Kinesis Data Analytics application.</p>
        /// <note>
        /// <p>If <code>CheckpointConfiguration.ConfigurationType</code> is <code>DEFAULT</code>,
        /// the application will use a <code>CheckpointingEnabled</code> value of <code>true</code>, even if this value is set to
        /// another value using this API or in application code.</p>
        /// </note>
        pub fn checkpointing_enabled(mut self, input: bool) -> Self {
            self.checkpointing_enabled = Some(input);
            self
        }
        /// <p>Describes whether checkpointing is enabled for a Flink-based Kinesis Data Analytics application.</p>
        /// <note>
        /// <p>If <code>CheckpointConfiguration.ConfigurationType</code> is <code>DEFAULT</code>,
        /// the application will use a <code>CheckpointingEnabled</code> value of <code>true</code>, even if this value is set to
        /// another value using this API or in application code.</p>
        /// </note>
        pub fn set_checkpointing_enabled(mut self, input: std::option::Option<bool>) -> Self {
            self.checkpointing_enabled = input;
            self
        }
        /// <p>Describes the interval in milliseconds between checkpoint operations. </p>
        /// <note>
        /// <p>If <code>CheckpointConfiguration.ConfigurationType</code> is <code>DEFAULT</code>,
        /// the application will use a <code>CheckpointInterval</code> value of 60000, even if this value is set to another value
        /// using this API or in application code.</p>
        /// </note>
        pub fn checkpoint_interval(mut self, input: i64) -> Self {
            self.checkpoint_interval = Some(input);
            self
        }
        /// <p>Describes the interval in milliseconds between checkpoint operations. </p>
        /// <note>
        /// <p>If <code>CheckpointConfiguration.ConfigurationType</code> is <code>DEFAULT</code>,
        /// the application will use a <code>CheckpointInterval</code> value of 60000, even if this value is set to another value
        /// using this API or in application code.</p>
        /// </note>
        pub fn set_checkpoint_interval(mut self, input: std::option::Option<i64>) -> Self {
            self.checkpoint_interval = input;
            self
        }
        /// <p>Describes the minimum time in milliseconds after a checkpoint operation completes that a new checkpoint operation
        /// can start. </p>
        /// <note>
        /// <p>If <code>CheckpointConfiguration.ConfigurationType</code> is <code>DEFAULT</code>,
        /// the application will use a <code>MinPauseBetweenCheckpoints</code> value of 5000, even if this value is set using this
        /// API or in application code.</p>
        /// </note>
        pub fn min_pause_between_checkpoints(mut self, input: i64) -> Self {
            self.min_pause_between_checkpoints = Some(input);
            self
        }
        /// <p>Describes the minimum time in milliseconds after a checkpoint operation completes that a new checkpoint operation
        /// can start. </p>
        /// <note>
        /// <p>If <code>CheckpointConfiguration.ConfigurationType</code> is <code>DEFAULT</code>,
        /// the application will use a <code>MinPauseBetweenCheckpoints</code> value of 5000, even if this value is set using this
        /// API or in application code.</p>
        /// </note>
        pub fn set_min_pause_between_checkpoints(
            mut self,
            input: std::option::Option<i64>,
        ) -> Self {
            self.min_pause_between_checkpoints = input;
            self
        }
        /// Consumes the builder and constructs a [`CheckpointConfigurationDescription`](crate::model::CheckpointConfigurationDescription)
        pub fn build(self) -> crate::model::CheckpointConfigurationDescription {
            crate::model::CheckpointConfigurationDescription {
                configuration_type: self.configuration_type,
                checkpointing_enabled: self.checkpointing_enabled,
                checkpoint_interval: self.checkpoint_interval,
                min_pause_between_checkpoints: self.min_pause_between_checkpoints,
            }
        }
    }
}
impl CheckpointConfigurationDescription {
    /// Creates a new builder-style object to manufacture [`CheckpointConfigurationDescription`](crate::model::CheckpointConfigurationDescription)
    pub fn builder() -> crate::model::checkpoint_configuration_description::Builder {
        crate::model::checkpoint_configuration_description::Builder::default()
    }
}

/// <p>Describes the starting properties for a Kinesis Data Analytics application.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct RunConfigurationDescription {
    /// <p>Describes the restore behavior of a restarting application.</p>
    pub application_restore_configuration_description:
        std::option::Option<crate::model::ApplicationRestoreConfiguration>,
    /// <p>Describes the starting parameters for a Flink-based Kinesis Data Analytics application.</p>
    pub flink_run_configuration_description:
        std::option::Option<crate::model::FlinkRunConfiguration>,
}
impl RunConfigurationDescription {
    /// <p>Describes the restore behavior of a restarting application.</p>
    pub fn application_restore_configuration_description(
        &self,
    ) -> std::option::Option<&crate::model::ApplicationRestoreConfiguration> {
        self.application_restore_configuration_description.as_ref()
    }
    /// <p>Describes the starting parameters for a Flink-based Kinesis Data Analytics application.</p>
    pub fn flink_run_configuration_description(
        &self,
    ) -> std::option::Option<&crate::model::FlinkRunConfiguration> {
        self.flink_run_configuration_description.as_ref()
    }
}
impl std::fmt::Debug for RunConfigurationDescription {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("RunConfigurationDescription");
        formatter.field(
            "application_restore_configuration_description",
            &self.application_restore_configuration_description,
        );
        formatter.field(
            "flink_run_configuration_description",
            &self.flink_run_configuration_description,
        );
        formatter.finish()
    }
}
/// See [`RunConfigurationDescription`](crate::model::RunConfigurationDescription)
pub mod run_configuration_description {
    /// A builder for [`RunConfigurationDescription`](crate::model::RunConfigurationDescription)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) application_restore_configuration_description:
            std::option::Option<crate::model::ApplicationRestoreConfiguration>,
        pub(crate) flink_run_configuration_description:
            std::option::Option<crate::model::FlinkRunConfiguration>,
    }
    impl Builder {
        /// <p>Describes the restore behavior of a restarting application.</p>
        pub fn application_restore_configuration_description(
            mut self,
            input: crate::model::ApplicationRestoreConfiguration,
        ) -> Self {
            self.application_restore_configuration_description = Some(input);
            self
        }
        /// <p>Describes the restore behavior of a restarting application.</p>
        pub fn set_application_restore_configuration_description(
            mut self,
            input: std::option::Option<crate::model::ApplicationRestoreConfiguration>,
        ) -> Self {
            self.application_restore_configuration_description = input;
            self
        }
        /// <p>Describes the starting parameters for a Flink-based Kinesis Data Analytics application.</p>
        pub fn flink_run_configuration_description(
            mut self,
            input: crate::model::FlinkRunConfiguration,
        ) -> Self {
            self.flink_run_configuration_description = Some(input);
            self
        }
        /// <p>Describes the starting parameters for a Flink-based Kinesis Data Analytics application.</p>
        pub fn set_flink_run_configuration_description(
            mut self,
            input: std::option::Option<crate::model::FlinkRunConfiguration>,
        ) -> Self {
            self.flink_run_configuration_description = input;
            self
        }
        /// Consumes the builder and constructs a [`RunConfigurationDescription`](crate::model::RunConfigurationDescription)
        pub fn build(self) -> crate::model::RunConfigurationDescription {
            crate::model::RunConfigurationDescription {
                application_restore_configuration_description: self
                    .application_restore_configuration_description,
                flink_run_configuration_description: self.flink_run_configuration_description,
            }
        }
    }
}
impl RunConfigurationDescription {
    /// Creates a new builder-style object to manufacture [`RunConfigurationDescription`](crate::model::RunConfigurationDescription)
    pub fn builder() -> crate::model::run_configuration_description::Builder {
        crate::model::run_configuration_description::Builder::default()
    }
}

/// <p>Describes the starting parameters for a Flink-based Kinesis Data Analytics application.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct FlinkRunConfiguration {
    /// <p>When restoring from a snapshot, specifies whether the runtime is allowed to skip a state that cannot
    /// be mapped to the new program.
    /// This will happen if the program is updated between snapshots to remove stateful parameters, and
    /// state data in the snapshot no longer
    /// corresponds to valid application data. For more information, see
    /// <a href="https://ci.apache.org/projects/flink/flink-docs-release-1.8/ops/state/savepoints.html#allowing-non-restored-state">
    /// Allowing Non-Restored State</a> in the <a href="https://ci.apache.org/projects/flink/flink-docs-release-1.8/">Apache Flink
    /// documentation</a>.</p>
    /// <note>
    /// <p>This value defaults to <code>false</code>. If you update your application without
    /// specifying this parameter, <code>AllowNonRestoredState</code> will be set to <code>false</code>,
    /// even if it was previously set to <code>true</code>.</p>
    /// </note>
    pub allow_non_restored_state: std::option::Option<bool>,
}
impl FlinkRunConfiguration {
    /// <p>When restoring from a snapshot, specifies whether the runtime is allowed to skip a state that cannot
    /// be mapped to the new program.
    /// This will happen if the program is updated between snapshots to remove stateful parameters, and
    /// state data in the snapshot no longer
    /// corresponds to valid application data. For more information, see
    /// <a href="https://ci.apache.org/projects/flink/flink-docs-release-1.8/ops/state/savepoints.html#allowing-non-restored-state">
    /// Allowing Non-Restored State</a> in the <a href="https://ci.apache.org/projects/flink/flink-docs-release-1.8/">Apache Flink
    /// documentation</a>.</p>
    /// <note>
    /// <p>This value defaults to <code>false</code>. If you update your application without
    /// specifying this parameter, <code>AllowNonRestoredState</code> will be set to <code>false</code>,
    /// even if it was previously set to <code>true</code>.</p>
    /// </note>
    pub fn allow_non_restored_state(&self) -> std::option::Option<bool> {
        self.allow_non_restored_state
    }
}
impl std::fmt::Debug for FlinkRunConfiguration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("FlinkRunConfiguration");
        formatter.field("allow_non_restored_state", &self.allow_non_restored_state);
        formatter.finish()
    }
}
/// See [`FlinkRunConfiguration`](crate::model::FlinkRunConfiguration)
pub mod flink_run_configuration {
    /// A builder for [`FlinkRunConfiguration`](crate::model::FlinkRunConfiguration)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) allow_non_restored_state: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>When restoring from a snapshot, specifies whether the runtime is allowed to skip a state that cannot
        /// be mapped to the new program.
        /// This will happen if the program is updated between snapshots to remove stateful parameters, and
        /// state data in the snapshot no longer
        /// corresponds to valid application data. For more information, see
        /// <a href="https://ci.apache.org/projects/flink/flink-docs-release-1.8/ops/state/savepoints.html#allowing-non-restored-state">
        /// Allowing Non-Restored State</a> in the <a href="https://ci.apache.org/projects/flink/flink-docs-release-1.8/">Apache Flink
        /// documentation</a>.</p>
        /// <note>
        /// <p>This value defaults to <code>false</code>. If you update your application without
        /// specifying this parameter, <code>AllowNonRestoredState</code> will be set to <code>false</code>,
        /// even if it was previously set to <code>true</code>.</p>
        /// </note>
        pub fn allow_non_restored_state(mut self, input: bool) -> Self {
            self.allow_non_restored_state = Some(input);
            self
        }
        /// <p>When restoring from a snapshot, specifies whether the runtime is allowed to skip a state that cannot
        /// be mapped to the new program.
        /// This will happen if the program is updated between snapshots to remove stateful parameters, and
        /// state data in the snapshot no longer
        /// corresponds to valid application data. For more information, see
        /// <a href="https://ci.apache.org/projects/flink/flink-docs-release-1.8/ops/state/savepoints.html#allowing-non-restored-state">
        /// Allowing Non-Restored State</a> in the <a href="https://ci.apache.org/projects/flink/flink-docs-release-1.8/">Apache Flink
        /// documentation</a>.</p>
        /// <note>
        /// <p>This value defaults to <code>false</code>. If you update your application without
        /// specifying this parameter, <code>AllowNonRestoredState</code> will be set to <code>false</code>,
        /// even if it was previously set to <code>true</code>.</p>
        /// </note>
        pub fn set_allow_non_restored_state(mut self, input: std::option::Option<bool>) -> Self {
            self.allow_non_restored_state = input;
            self
        }
        /// Consumes the builder and constructs a [`FlinkRunConfiguration`](crate::model::FlinkRunConfiguration)
        pub fn build(self) -> crate::model::FlinkRunConfiguration {
            crate::model::FlinkRunConfiguration {
                allow_non_restored_state: self.allow_non_restored_state,
            }
        }
    }
}
impl FlinkRunConfiguration {
    /// Creates a new builder-style object to manufacture [`FlinkRunConfiguration`](crate::model::FlinkRunConfiguration)
    pub fn builder() -> crate::model::flink_run_configuration::Builder {
        crate::model::flink_run_configuration::Builder::default()
    }
}

/// <p>Specifies the method and snapshot to use when restarting an application using previously saved application state.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ApplicationRestoreConfiguration {
    /// <p>Specifies how the application should be restored.</p>
    pub application_restore_type: std::option::Option<crate::model::ApplicationRestoreType>,
    /// <p>The identifier of an existing snapshot of application state to use to restart an application.
    /// The application uses this value if <code>RESTORE_FROM_CUSTOM_SNAPSHOT</code> is specified for the
    /// <code>ApplicationRestoreType</code>.</p>
    pub snapshot_name: std::option::Option<std::string::String>,
}
impl ApplicationRestoreConfiguration {
    /// <p>Specifies how the application should be restored.</p>
    pub fn application_restore_type(
        &self,
    ) -> std::option::Option<&crate::model::ApplicationRestoreType> {
        self.application_restore_type.as_ref()
    }
    /// <p>The identifier of an existing snapshot of application state to use to restart an application.
    /// The application uses this value if <code>RESTORE_FROM_CUSTOM_SNAPSHOT</code> is specified for the
    /// <code>ApplicationRestoreType</code>.</p>
    pub fn snapshot_name(&self) -> std::option::Option<&str> {
        self.snapshot_name.as_deref()
    }
}
impl std::fmt::Debug for ApplicationRestoreConfiguration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ApplicationRestoreConfiguration");
        formatter.field("application_restore_type", &self.application_restore_type);
        formatter.field("snapshot_name", &self.snapshot_name);
        formatter.finish()
    }
}
/// See [`ApplicationRestoreConfiguration`](crate::model::ApplicationRestoreConfiguration)
pub mod application_restore_configuration {
    /// A builder for [`ApplicationRestoreConfiguration`](crate::model::ApplicationRestoreConfiguration)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) application_restore_type:
            std::option::Option<crate::model::ApplicationRestoreType>,
        pub(crate) snapshot_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Specifies how the application should be restored.</p>
        pub fn application_restore_type(
            mut self,
            input: crate::model::ApplicationRestoreType,
        ) -> Self {
            self.application_restore_type = Some(input);
            self
        }
        /// <p>Specifies how the application should be restored.</p>
        pub fn set_application_restore_type(
            mut self,
            input: std::option::Option<crate::model::ApplicationRestoreType>,
        ) -> Self {
            self.application_restore_type = input;
            self
        }
        /// <p>The identifier of an existing snapshot of application state to use to restart an application.
        /// The application uses this value if <code>RESTORE_FROM_CUSTOM_SNAPSHOT</code> is specified for the
        /// <code>ApplicationRestoreType</code>.</p>
        pub fn snapshot_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.snapshot_name = Some(input.into());
            self
        }
        /// <p>The identifier of an existing snapshot of application state to use to restart an application.
        /// The application uses this value if <code>RESTORE_FROM_CUSTOM_SNAPSHOT</code> is specified for the
        /// <code>ApplicationRestoreType</code>.</p>
        pub fn set_snapshot_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.snapshot_name = input;
            self
        }
        /// Consumes the builder and constructs a [`ApplicationRestoreConfiguration`](crate::model::ApplicationRestoreConfiguration)
        pub fn build(self) -> crate::model::ApplicationRestoreConfiguration {
            crate::model::ApplicationRestoreConfiguration {
                application_restore_type: self.application_restore_type,
                snapshot_name: self.snapshot_name,
            }
        }
    }
}
impl ApplicationRestoreConfiguration {
    /// Creates a new builder-style object to manufacture [`ApplicationRestoreConfiguration`](crate::model::ApplicationRestoreConfiguration)
    pub fn builder() -> crate::model::application_restore_configuration::Builder {
        crate::model::application_restore_configuration::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ApplicationRestoreType {
    #[allow(missing_docs)] // documentation missing in model
    RestoreFromCustomSnapshot,
    #[allow(missing_docs)] // documentation missing in model
    RestoreFromLatestSnapshot,
    #[allow(missing_docs)] // documentation missing in model
    SkipRestoreFromSnapshot,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for ApplicationRestoreType {
    fn from(s: &str) -> Self {
        match s {
            "RESTORE_FROM_CUSTOM_SNAPSHOT" => ApplicationRestoreType::RestoreFromCustomSnapshot,
            "RESTORE_FROM_LATEST_SNAPSHOT" => ApplicationRestoreType::RestoreFromLatestSnapshot,
            "SKIP_RESTORE_FROM_SNAPSHOT" => ApplicationRestoreType::SkipRestoreFromSnapshot,
            other => ApplicationRestoreType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for ApplicationRestoreType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ApplicationRestoreType::from(s))
    }
}
impl ApplicationRestoreType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ApplicationRestoreType::RestoreFromCustomSnapshot => "RESTORE_FROM_CUSTOM_SNAPSHOT",
            ApplicationRestoreType::RestoreFromLatestSnapshot => "RESTORE_FROM_LATEST_SNAPSHOT",
            ApplicationRestoreType::SkipRestoreFromSnapshot => "SKIP_RESTORE_FROM_SNAPSHOT",
            ApplicationRestoreType::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &[
            "RESTORE_FROM_CUSTOM_SNAPSHOT",
            "RESTORE_FROM_LATEST_SNAPSHOT",
            "SKIP_RESTORE_FROM_SNAPSHOT",
        ]
    }
}
impl AsRef<str> for ApplicationRestoreType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Describes code configuration for an application.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ApplicationCodeConfigurationDescription {
    /// <p>Specifies whether the code content is in text or zip format.</p>
    pub code_content_type: std::option::Option<crate::model::CodeContentType>,
    /// <p>Describes details about the location and format of the application code.</p>
    pub code_content_description: std::option::Option<crate::model::CodeContentDescription>,
}
impl ApplicationCodeConfigurationDescription {
    /// <p>Specifies whether the code content is in text or zip format.</p>
    pub fn code_content_type(&self) -> std::option::Option<&crate::model::CodeContentType> {
        self.code_content_type.as_ref()
    }
    /// <p>Describes details about the location and format of the application code.</p>
    pub fn code_content_description(
        &self,
    ) -> std::option::Option<&crate::model::CodeContentDescription> {
        self.code_content_description.as_ref()
    }
}
impl std::fmt::Debug for ApplicationCodeConfigurationDescription {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ApplicationCodeConfigurationDescription");
        formatter.field("code_content_type", &self.code_content_type);
        formatter.field("code_content_description", &self.code_content_description);
        formatter.finish()
    }
}
/// See [`ApplicationCodeConfigurationDescription`](crate::model::ApplicationCodeConfigurationDescription)
pub mod application_code_configuration_description {
    /// A builder for [`ApplicationCodeConfigurationDescription`](crate::model::ApplicationCodeConfigurationDescription)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) code_content_type: std::option::Option<crate::model::CodeContentType>,
        pub(crate) code_content_description:
            std::option::Option<crate::model::CodeContentDescription>,
    }
    impl Builder {
        /// <p>Specifies whether the code content is in text or zip format.</p>
        pub fn code_content_type(mut self, input: crate::model::CodeContentType) -> Self {
            self.code_content_type = Some(input);
            self
        }
        /// <p>Specifies whether the code content is in text or zip format.</p>
        pub fn set_code_content_type(
            mut self,
            input: std::option::Option<crate::model::CodeContentType>,
        ) -> Self {
            self.code_content_type = input;
            self
        }
        /// <p>Describes details about the location and format of the application code.</p>
        pub fn code_content_description(
            mut self,
            input: crate::model::CodeContentDescription,
        ) -> Self {
            self.code_content_description = Some(input);
            self
        }
        /// <p>Describes details about the location and format of the application code.</p>
        pub fn set_code_content_description(
            mut self,
            input: std::option::Option<crate::model::CodeContentDescription>,
        ) -> Self {
            self.code_content_description = input;
            self
        }
        /// Consumes the builder and constructs a [`ApplicationCodeConfigurationDescription`](crate::model::ApplicationCodeConfigurationDescription)
        pub fn build(self) -> crate::model::ApplicationCodeConfigurationDescription {
            crate::model::ApplicationCodeConfigurationDescription {
                code_content_type: self.code_content_type,
                code_content_description: self.code_content_description,
            }
        }
    }
}
impl ApplicationCodeConfigurationDescription {
    /// Creates a new builder-style object to manufacture [`ApplicationCodeConfigurationDescription`](crate::model::ApplicationCodeConfigurationDescription)
    pub fn builder() -> crate::model::application_code_configuration_description::Builder {
        crate::model::application_code_configuration_description::Builder::default()
    }
}

/// <p>Describes details about the code of a Kinesis Data Analytics application.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CodeContentDescription {
    /// <p>The text-format code</p>
    pub text_content: std::option::Option<std::string::String>,
    /// <p>The checksum that can be used to validate zip-format code.</p>
    pub code_md5: std::option::Option<std::string::String>,
    /// <p>The size in bytes of the application code. Can be used to validate zip-format code.</p>
    pub code_size: std::option::Option<i64>,
    /// <p>The S3 bucket Amazon Resource Name (ARN), file key, and object version of the application
    /// code stored in Amazon S3.</p>
    pub s3_application_code_location_description:
        std::option::Option<crate::model::S3ApplicationCodeLocationDescription>,
}
impl CodeContentDescription {
    /// <p>The text-format code</p>
    pub fn text_content(&self) -> std::option::Option<&str> {
        self.text_content.as_deref()
    }
    /// <p>The checksum that can be used to validate zip-format code.</p>
    pub fn code_md5(&self) -> std::option::Option<&str> {
        self.code_md5.as_deref()
    }
    /// <p>The size in bytes of the application code. Can be used to validate zip-format code.</p>
    pub fn code_size(&self) -> std::option::Option<i64> {
        self.code_size
    }
    /// <p>The S3 bucket Amazon Resource Name (ARN), file key, and object version of the application
    /// code stored in Amazon S3.</p>
    pub fn s3_application_code_location_description(
        &self,
    ) -> std::option::Option<&crate::model::S3ApplicationCodeLocationDescription> {
        self.s3_application_code_location_description.as_ref()
    }
}
impl std::fmt::Debug for CodeContentDescription {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CodeContentDescription");
        formatter.field("text_content", &self.text_content);
        formatter.field("code_md5", &self.code_md5);
        formatter.field("code_size", &self.code_size);
        formatter.field(
            "s3_application_code_location_description",
            &self.s3_application_code_location_description,
        );
        formatter.finish()
    }
}
/// See [`CodeContentDescription`](crate::model::CodeContentDescription)
pub mod code_content_description {
    /// A builder for [`CodeContentDescription`](crate::model::CodeContentDescription)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) text_content: std::option::Option<std::string::String>,
        pub(crate) code_md5: std::option::Option<std::string::String>,
        pub(crate) code_size: std::option::Option<i64>,
        pub(crate) s3_application_code_location_description:
            std::option::Option<crate::model::S3ApplicationCodeLocationDescription>,
    }
    impl Builder {
        /// <p>The text-format code</p>
        pub fn text_content(mut self, input: impl Into<std::string::String>) -> Self {
            self.text_content = Some(input.into());
            self
        }
        /// <p>The text-format code</p>
        pub fn set_text_content(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.text_content = input;
            self
        }
        /// <p>The checksum that can be used to validate zip-format code.</p>
        pub fn code_md5(mut self, input: impl Into<std::string::String>) -> Self {
            self.code_md5 = Some(input.into());
            self
        }
        /// <p>The checksum that can be used to validate zip-format code.</p>
        pub fn set_code_md5(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.code_md5 = input;
            self
        }
        /// <p>The size in bytes of the application code. Can be used to validate zip-format code.</p>
        pub fn code_size(mut self, input: i64) -> Self {
            self.code_size = Some(input);
            self
        }
        /// <p>The size in bytes of the application code. Can be used to validate zip-format code.</p>
        pub fn set_code_size(mut self, input: std::option::Option<i64>) -> Self {
            self.code_size = input;
            self
        }
        /// <p>The S3 bucket Amazon Resource Name (ARN), file key, and object version of the application
        /// code stored in Amazon S3.</p>
        pub fn s3_application_code_location_description(
            mut self,
            input: crate::model::S3ApplicationCodeLocationDescription,
        ) -> Self {
            self.s3_application_code_location_description = Some(input);
            self
        }
        /// <p>The S3 bucket Amazon Resource Name (ARN), file key, and object version of the application
        /// code stored in Amazon S3.</p>
        pub fn set_s3_application_code_location_description(
            mut self,
            input: std::option::Option<crate::model::S3ApplicationCodeLocationDescription>,
        ) -> Self {
            self.s3_application_code_location_description = input;
            self
        }
        /// Consumes the builder and constructs a [`CodeContentDescription`](crate::model::CodeContentDescription)
        pub fn build(self) -> crate::model::CodeContentDescription {
            crate::model::CodeContentDescription {
                text_content: self.text_content,
                code_md5: self.code_md5,
                code_size: self.code_size,
                s3_application_code_location_description: self
                    .s3_application_code_location_description,
            }
        }
    }
}
impl CodeContentDescription {
    /// Creates a new builder-style object to manufacture [`CodeContentDescription`](crate::model::CodeContentDescription)
    pub fn builder() -> crate::model::code_content_description::Builder {
        crate::model::code_content_description::Builder::default()
    }
}

/// <p>Describes the location of an application's code stored in an S3 bucket.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct S3ApplicationCodeLocationDescription {
    /// <p>The Amazon Resource Name (ARN) for the S3 bucket containing the application code.</p>
    pub bucket_arn: std::option::Option<std::string::String>,
    /// <p>The file key for the object containing the application code.</p>
    pub file_key: std::option::Option<std::string::String>,
    /// <p>The version of the object containing the application code.</p>
    pub object_version: std::option::Option<std::string::String>,
}
impl S3ApplicationCodeLocationDescription {
    /// <p>The Amazon Resource Name (ARN) for the S3 bucket containing the application code.</p>
    pub fn bucket_arn(&self) -> std::option::Option<&str> {
        self.bucket_arn.as_deref()
    }
    /// <p>The file key for the object containing the application code.</p>
    pub fn file_key(&self) -> std::option::Option<&str> {
        self.file_key.as_deref()
    }
    /// <p>The version of the object containing the application code.</p>
    pub fn object_version(&self) -> std::option::Option<&str> {
        self.object_version.as_deref()
    }
}
impl std::fmt::Debug for S3ApplicationCodeLocationDescription {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("S3ApplicationCodeLocationDescription");
        formatter.field("bucket_arn", &self.bucket_arn);
        formatter.field("file_key", &self.file_key);
        formatter.field("object_version", &self.object_version);
        formatter.finish()
    }
}
/// See [`S3ApplicationCodeLocationDescription`](crate::model::S3ApplicationCodeLocationDescription)
pub mod s3_application_code_location_description {
    /// A builder for [`S3ApplicationCodeLocationDescription`](crate::model::S3ApplicationCodeLocationDescription)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) bucket_arn: std::option::Option<std::string::String>,
        pub(crate) file_key: std::option::Option<std::string::String>,
        pub(crate) object_version: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) for the S3 bucket containing the application code.</p>
        pub fn bucket_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.bucket_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) for the S3 bucket containing the application code.</p>
        pub fn set_bucket_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.bucket_arn = input;
            self
        }
        /// <p>The file key for the object containing the application code.</p>
        pub fn file_key(mut self, input: impl Into<std::string::String>) -> Self {
            self.file_key = Some(input.into());
            self
        }
        /// <p>The file key for the object containing the application code.</p>
        pub fn set_file_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.file_key = input;
            self
        }
        /// <p>The version of the object containing the application code.</p>
        pub fn object_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.object_version = Some(input.into());
            self
        }
        /// <p>The version of the object containing the application code.</p>
        pub fn set_object_version(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.object_version = input;
            self
        }
        /// Consumes the builder and constructs a [`S3ApplicationCodeLocationDescription`](crate::model::S3ApplicationCodeLocationDescription)
        pub fn build(self) -> crate::model::S3ApplicationCodeLocationDescription {
            crate::model::S3ApplicationCodeLocationDescription {
                bucket_arn: self.bucket_arn,
                file_key: self.file_key,
                object_version: self.object_version,
            }
        }
    }
}
impl S3ApplicationCodeLocationDescription {
    /// Creates a new builder-style object to manufacture [`S3ApplicationCodeLocationDescription`](crate::model::S3ApplicationCodeLocationDescription)
    pub fn builder() -> crate::model::s3_application_code_location_description::Builder {
        crate::model::s3_application_code_location_description::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum CodeContentType {
    #[allow(missing_docs)] // documentation missing in model
    Plaintext,
    #[allow(missing_docs)] // documentation missing in model
    Zipfile,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for CodeContentType {
    fn from(s: &str) -> Self {
        match s {
            "PLAINTEXT" => CodeContentType::Plaintext,
            "ZIPFILE" => CodeContentType::Zipfile,
            other => CodeContentType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for CodeContentType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(CodeContentType::from(s))
    }
}
impl CodeContentType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            CodeContentType::Plaintext => "PLAINTEXT",
            CodeContentType::Zipfile => "ZIPFILE",
            CodeContentType::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["PLAINTEXT", "ZIPFILE"]
    }
}
impl AsRef<str> for CodeContentType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Describes the inputs, outputs, and reference data sources for a SQL-based Kinesis Data Analytics application.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SqlApplicationConfigurationDescription {
    /// <p>The array of <a>InputDescription</a> objects describing the input streams used
    /// by the application.</p>
    pub input_descriptions: std::option::Option<std::vec::Vec<crate::model::InputDescription>>,
    /// <p>The array of <a>OutputDescription</a> objects describing the destination
    /// streams used by the application.</p>
    pub output_descriptions: std::option::Option<std::vec::Vec<crate::model::OutputDescription>>,
    /// <p>The array of <a>ReferenceDataSourceDescription</a> objects describing the
    /// reference data sources used by the application.</p>
    pub reference_data_source_descriptions:
        std::option::Option<std::vec::Vec<crate::model::ReferenceDataSourceDescription>>,
}
impl SqlApplicationConfigurationDescription {
    /// <p>The array of <a>InputDescription</a> objects describing the input streams used
    /// by the application.</p>
    pub fn input_descriptions(&self) -> std::option::Option<&[crate::model::InputDescription]> {
        self.input_descriptions.as_deref()
    }
    /// <p>The array of <a>OutputDescription</a> objects describing the destination
    /// streams used by the application.</p>
    pub fn output_descriptions(&self) -> std::option::Option<&[crate::model::OutputDescription]> {
        self.output_descriptions.as_deref()
    }
    /// <p>The array of <a>ReferenceDataSourceDescription</a> objects describing the
    /// reference data sources used by the application.</p>
    pub fn reference_data_source_descriptions(
        &self,
    ) -> std::option::Option<&[crate::model::ReferenceDataSourceDescription]> {
        self.reference_data_source_descriptions.as_deref()
    }
}
impl std::fmt::Debug for SqlApplicationConfigurationDescription {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SqlApplicationConfigurationDescription");
        formatter.field("input_descriptions", &self.input_descriptions);
        formatter.field("output_descriptions", &self.output_descriptions);
        formatter.field(
            "reference_data_source_descriptions",
            &self.reference_data_source_descriptions,
        );
        formatter.finish()
    }
}
/// See [`SqlApplicationConfigurationDescription`](crate::model::SqlApplicationConfigurationDescription)
pub mod sql_application_configuration_description {
    /// A builder for [`SqlApplicationConfigurationDescription`](crate::model::SqlApplicationConfigurationDescription)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) input_descriptions:
            std::option::Option<std::vec::Vec<crate::model::InputDescription>>,
        pub(crate) output_descriptions:
            std::option::Option<std::vec::Vec<crate::model::OutputDescription>>,
        pub(crate) reference_data_source_descriptions:
            std::option::Option<std::vec::Vec<crate::model::ReferenceDataSourceDescription>>,
    }
    impl Builder {
        /// Appends an item to `input_descriptions`.
        ///
        /// To override the contents of this collection use [`set_input_descriptions`](Self::set_input_descriptions).
        ///
        /// <p>The array of <a>InputDescription</a> objects describing the input streams used
        /// by the application.</p>
        pub fn input_descriptions(
            mut self,
            input: impl Into<crate::model::InputDescription>,
        ) -> Self {
            let mut v = self.input_descriptions.unwrap_or_default();
            v.push(input.into());
            self.input_descriptions = Some(v);
            self
        }
        /// <p>The array of <a>InputDescription</a> objects describing the input streams used
        /// by the application.</p>
        pub fn set_input_descriptions(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::InputDescription>>,
        ) -> Self {
            self.input_descriptions = input;
            self
        }
        /// Appends an item to `output_descriptions`.
        ///
        /// To override the contents of this collection use [`set_output_descriptions`](Self::set_output_descriptions).
        ///
        /// <p>The array of <a>OutputDescription</a> objects describing the destination
        /// streams used by the application.</p>
        pub fn output_descriptions(
            mut self,
            input: impl Into<crate::model::OutputDescription>,
        ) -> Self {
            let mut v = self.output_descriptions.unwrap_or_default();
            v.push(input.into());
            self.output_descriptions = Some(v);
            self
        }
        /// <p>The array of <a>OutputDescription</a> objects describing the destination
        /// streams used by the application.</p>
        pub fn set_output_descriptions(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::OutputDescription>>,
        ) -> Self {
            self.output_descriptions = input;
            self
        }
        /// Appends an item to `reference_data_source_descriptions`.
        ///
        /// To override the contents of this collection use [`set_reference_data_source_descriptions`](Self::set_reference_data_source_descriptions).
        ///
        /// <p>The array of <a>ReferenceDataSourceDescription</a> objects describing the
        /// reference data sources used by the application.</p>
        pub fn reference_data_source_descriptions(
            mut self,
            input: impl Into<crate::model::ReferenceDataSourceDescription>,
        ) -> Self {
            let mut v = self.reference_data_source_descriptions.unwrap_or_default();
            v.push(input.into());
            self.reference_data_source_descriptions = Some(v);
            self
        }
        /// <p>The array of <a>ReferenceDataSourceDescription</a> objects describing the
        /// reference data sources used by the application.</p>
        pub fn set_reference_data_source_descriptions(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ReferenceDataSourceDescription>>,
        ) -> Self {
            self.reference_data_source_descriptions = input;
            self
        }
        /// Consumes the builder and constructs a [`SqlApplicationConfigurationDescription`](crate::model::SqlApplicationConfigurationDescription)
        pub fn build(self) -> crate::model::SqlApplicationConfigurationDescription {
            crate::model::SqlApplicationConfigurationDescription {
                input_descriptions: self.input_descriptions,
                output_descriptions: self.output_descriptions,
                reference_data_source_descriptions: self.reference_data_source_descriptions,
            }
        }
    }
}
impl SqlApplicationConfigurationDescription {
    /// Creates a new builder-style object to manufacture [`SqlApplicationConfigurationDescription`](crate::model::SqlApplicationConfigurationDescription)
    pub fn builder() -> crate::model::sql_application_configuration_description::Builder {
        crate::model::sql_application_configuration_description::Builder::default()
    }
}

/// <p>For a SQL-based Kinesis Data Analytics application, describes the reference data
/// source configured for an application.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ReferenceDataSourceDescription {
    /// <p>The ID of the reference data source. This is the ID that Kinesis Data Analytics assigns
    /// when you add the reference data source to your application using the <a>CreateApplication</a> or <a>UpdateApplication</a> operation.</p>
    pub reference_id: std::option::Option<std::string::String>,
    /// <p>The in-application table name created by the specific reference data source configuration.</p>
    pub table_name: std::option::Option<std::string::String>,
    /// <p>Provides the Amazon S3 bucket name, the object key name that contains the reference data. </p>
    pub s3_reference_data_source_description:
        std::option::Option<crate::model::S3ReferenceDataSourceDescription>,
    /// <p>Describes the format of the data in the streaming source, and how each data element maps to corresponding columns created in the in-application stream.</p>
    pub reference_schema: std::option::Option<crate::model::SourceSchema>,
}
impl ReferenceDataSourceDescription {
    /// <p>The ID of the reference data source. This is the ID that Kinesis Data Analytics assigns
    /// when you add the reference data source to your application using the <a>CreateApplication</a> or <a>UpdateApplication</a> operation.</p>
    pub fn reference_id(&self) -> std::option::Option<&str> {
        self.reference_id.as_deref()
    }
    /// <p>The in-application table name created by the specific reference data source configuration.</p>
    pub fn table_name(&self) -> std::option::Option<&str> {
        self.table_name.as_deref()
    }
    /// <p>Provides the Amazon S3 bucket name, the object key name that contains the reference data. </p>
    pub fn s3_reference_data_source_description(
        &self,
    ) -> std::option::Option<&crate::model::S3ReferenceDataSourceDescription> {
        self.s3_reference_data_source_description.as_ref()
    }
    /// <p>Describes the format of the data in the streaming source, and how each data element maps to corresponding columns created in the in-application stream.</p>
    pub fn reference_schema(&self) -> std::option::Option<&crate::model::SourceSchema> {
        self.reference_schema.as_ref()
    }
}
impl std::fmt::Debug for ReferenceDataSourceDescription {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ReferenceDataSourceDescription");
        formatter.field("reference_id", &self.reference_id);
        formatter.field("table_name", &self.table_name);
        formatter.field(
            "s3_reference_data_source_description",
            &self.s3_reference_data_source_description,
        );
        formatter.field("reference_schema", &self.reference_schema);
        formatter.finish()
    }
}
/// See [`ReferenceDataSourceDescription`](crate::model::ReferenceDataSourceDescription)
pub mod reference_data_source_description {
    /// A builder for [`ReferenceDataSourceDescription`](crate::model::ReferenceDataSourceDescription)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) reference_id: std::option::Option<std::string::String>,
        pub(crate) table_name: std::option::Option<std::string::String>,
        pub(crate) s3_reference_data_source_description:
            std::option::Option<crate::model::S3ReferenceDataSourceDescription>,
        pub(crate) reference_schema: std::option::Option<crate::model::SourceSchema>,
    }
    impl Builder {
        /// <p>The ID of the reference data source. This is the ID that Kinesis Data Analytics assigns
        /// when you add the reference data source to your application using the <a>CreateApplication</a> or <a>UpdateApplication</a> operation.</p>
        pub fn reference_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.reference_id = Some(input.into());
            self
        }
        /// <p>The ID of the reference data source. This is the ID that Kinesis Data Analytics assigns
        /// when you add the reference data source to your application using the <a>CreateApplication</a> or <a>UpdateApplication</a> operation.</p>
        pub fn set_reference_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.reference_id = input;
            self
        }
        /// <p>The in-application table name created by the specific reference data source configuration.</p>
        pub fn table_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.table_name = Some(input.into());
            self
        }
        /// <p>The in-application table name created by the specific reference data source configuration.</p>
        pub fn set_table_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.table_name = input;
            self
        }
        /// <p>Provides the Amazon S3 bucket name, the object key name that contains the reference data. </p>
        pub fn s3_reference_data_source_description(
            mut self,
            input: crate::model::S3ReferenceDataSourceDescription,
        ) -> Self {
            self.s3_reference_data_source_description = Some(input);
            self
        }
        /// <p>Provides the Amazon S3 bucket name, the object key name that contains the reference data. </p>
        pub fn set_s3_reference_data_source_description(
            mut self,
            input: std::option::Option<crate::model::S3ReferenceDataSourceDescription>,
        ) -> Self {
            self.s3_reference_data_source_description = input;
            self
        }
        /// <p>Describes the format of the data in the streaming source, and how each data element maps to corresponding columns created in the in-application stream.</p>
        pub fn reference_schema(mut self, input: crate::model::SourceSchema) -> Self {
            self.reference_schema = Some(input);
            self
        }
        /// <p>Describes the format of the data in the streaming source, and how each data element maps to corresponding columns created in the in-application stream.</p>
        pub fn set_reference_schema(
            mut self,
            input: std::option::Option<crate::model::SourceSchema>,
        ) -> Self {
            self.reference_schema = input;
            self
        }
        /// Consumes the builder and constructs a [`ReferenceDataSourceDescription`](crate::model::ReferenceDataSourceDescription)
        pub fn build(self) -> crate::model::ReferenceDataSourceDescription {
            crate::model::ReferenceDataSourceDescription {
                reference_id: self.reference_id,
                table_name: self.table_name,
                s3_reference_data_source_description: self.s3_reference_data_source_description,
                reference_schema: self.reference_schema,
            }
        }
    }
}
impl ReferenceDataSourceDescription {
    /// Creates a new builder-style object to manufacture [`ReferenceDataSourceDescription`](crate::model::ReferenceDataSourceDescription)
    pub fn builder() -> crate::model::reference_data_source_description::Builder {
        crate::model::reference_data_source_description::Builder::default()
    }
}

/// <p>For a SQL-based Kinesis Data Analytics application, describes the format of the
/// data in the streaming source, and how each data element maps to corresponding columns created
/// in the in-application stream. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SourceSchema {
    /// <p>Specifies the format of the records on the streaming source.</p>
    pub record_format: std::option::Option<crate::model::RecordFormat>,
    /// <p>Specifies the encoding of the records in the streaming source. For example, UTF-8.</p>
    pub record_encoding: std::option::Option<std::string::String>,
    /// <p>A list of <code>RecordColumn</code> objects. </p>
    pub record_columns: std::option::Option<std::vec::Vec<crate::model::RecordColumn>>,
}
impl SourceSchema {
    /// <p>Specifies the format of the records on the streaming source.</p>
    pub fn record_format(&self) -> std::option::Option<&crate::model::RecordFormat> {
        self.record_format.as_ref()
    }
    /// <p>Specifies the encoding of the records in the streaming source. For example, UTF-8.</p>
    pub fn record_encoding(&self) -> std::option::Option<&str> {
        self.record_encoding.as_deref()
    }
    /// <p>A list of <code>RecordColumn</code> objects. </p>
    pub fn record_columns(&self) -> std::option::Option<&[crate::model::RecordColumn]> {
        self.record_columns.as_deref()
    }
}
impl std::fmt::Debug for SourceSchema {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SourceSchema");
        formatter.field("record_format", &self.record_format);
        formatter.field("record_encoding", &self.record_encoding);
        formatter.field("record_columns", &self.record_columns);
        formatter.finish()
    }
}
/// See [`SourceSchema`](crate::model::SourceSchema)
pub mod source_schema {
    /// A builder for [`SourceSchema`](crate::model::SourceSchema)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) record_format: std::option::Option<crate::model::RecordFormat>,
        pub(crate) record_encoding: std::option::Option<std::string::String>,
        pub(crate) record_columns: std::option::Option<std::vec::Vec<crate::model::RecordColumn>>,
    }
    impl Builder {
        /// <p>Specifies the format of the records on the streaming source.</p>
        pub fn record_format(mut self, input: crate::model::RecordFormat) -> Self {
            self.record_format = Some(input);
            self
        }
        /// <p>Specifies the format of the records on the streaming source.</p>
        pub fn set_record_format(
            mut self,
            input: std::option::Option<crate::model::RecordFormat>,
        ) -> Self {
            self.record_format = input;
            self
        }
        /// <p>Specifies the encoding of the records in the streaming source. For example, UTF-8.</p>
        pub fn record_encoding(mut self, input: impl Into<std::string::String>) -> Self {
            self.record_encoding = Some(input.into());
            self
        }
        /// <p>Specifies the encoding of the records in the streaming source. For example, UTF-8.</p>
        pub fn set_record_encoding(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.record_encoding = input;
            self
        }
        /// Appends an item to `record_columns`.
        ///
        /// To override the contents of this collection use [`set_record_columns`](Self::set_record_columns).
        ///
        /// <p>A list of <code>RecordColumn</code> objects. </p>
        pub fn record_columns(mut self, input: impl Into<crate::model::RecordColumn>) -> Self {
            let mut v = self.record_columns.unwrap_or_default();
            v.push(input.into());
            self.record_columns = Some(v);
            self
        }
        /// <p>A list of <code>RecordColumn</code> objects. </p>
        pub fn set_record_columns(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::RecordColumn>>,
        ) -> Self {
            self.record_columns = input;
            self
        }
        /// Consumes the builder and constructs a [`SourceSchema`](crate::model::SourceSchema)
        pub fn build(self) -> crate::model::SourceSchema {
            crate::model::SourceSchema {
                record_format: self.record_format,
                record_encoding: self.record_encoding,
                record_columns: self.record_columns,
            }
        }
    }
}
impl SourceSchema {
    /// Creates a new builder-style object to manufacture [`SourceSchema`](crate::model::SourceSchema)
    pub fn builder() -> crate::model::source_schema::Builder {
        crate::model::source_schema::Builder::default()
    }
}

/// <p>For a SQL-based Kinesis Data Analytics application, describes the mapping of each
/// data element in the streaming source to the corresponding column in the in-application
/// stream.</p>
/// <p>Also used to describe the format of the reference data source.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct RecordColumn {
    /// <p>The name of the column that is created in the in-application input stream or reference
    /// table.</p>
    pub name: std::option::Option<std::string::String>,
    /// <p>A reference to the data element in the streaming input or the reference data
    /// source.</p>
    pub mapping: std::option::Option<std::string::String>,
    /// <p>The type of column created in the in-application input stream or reference table.</p>
    pub sql_type: std::option::Option<std::string::String>,
}
impl RecordColumn {
    /// <p>The name of the column that is created in the in-application input stream or reference
    /// table.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>A reference to the data element in the streaming input or the reference data
    /// source.</p>
    pub fn mapping(&self) -> std::option::Option<&str> {
        self.mapping.as_deref()
    }
    /// <p>The type of column created in the in-application input stream or reference table.</p>
    pub fn sql_type(&self) -> std::option::Option<&str> {
        self.sql_type.as_deref()
    }
}
impl std::fmt::Debug for RecordColumn {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("RecordColumn");
        formatter.field("name", &self.name);
        formatter.field("mapping", &self.mapping);
        formatter.field("sql_type", &self.sql_type);
        formatter.finish()
    }
}
/// See [`RecordColumn`](crate::model::RecordColumn)
pub mod record_column {
    /// A builder for [`RecordColumn`](crate::model::RecordColumn)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) mapping: std::option::Option<std::string::String>,
        pub(crate) sql_type: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the column that is created in the in-application input stream or reference
        /// table.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the column that is created in the in-application input stream or reference
        /// table.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>A reference to the data element in the streaming input or the reference data
        /// source.</p>
        pub fn mapping(mut self, input: impl Into<std::string::String>) -> Self {
            self.mapping = Some(input.into());
            self
        }
        /// <p>A reference to the data element in the streaming input or the reference data
        /// source.</p>
        pub fn set_mapping(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.mapping = input;
            self
        }
        /// <p>The type of column created in the in-application input stream or reference table.</p>
        pub fn sql_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.sql_type = Some(input.into());
            self
        }
        /// <p>The type of column created in the in-application input stream or reference table.</p>
        pub fn set_sql_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.sql_type = input;
            self
        }
        /// Consumes the builder and constructs a [`RecordColumn`](crate::model::RecordColumn)
        pub fn build(self) -> crate::model::RecordColumn {
            crate::model::RecordColumn {
                name: self.name,
                mapping: self.mapping,
                sql_type: self.sql_type,
            }
        }
    }
}
impl RecordColumn {
    /// Creates a new builder-style object to manufacture [`RecordColumn`](crate::model::RecordColumn)
    pub fn builder() -> crate::model::record_column::Builder {
        crate::model::record_column::Builder::default()
    }
}

/// <p> For a SQL-based Kinesis Data Analytics application, describes the record format
/// and relevant mapping information that should be applied to schematize the records on the
/// stream. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct RecordFormat {
    /// <p>The type of record format.</p>
    pub record_format_type: std::option::Option<crate::model::RecordFormatType>,
    /// <p>When you configure application input at the time of creating or updating an application,
    /// provides additional mapping information specific to the record format (such as JSON, CSV, or
    /// record fields delimited by some delimiter) on the streaming source.</p>
    pub mapping_parameters: std::option::Option<crate::model::MappingParameters>,
}
impl RecordFormat {
    /// <p>The type of record format.</p>
    pub fn record_format_type(&self) -> std::option::Option<&crate::model::RecordFormatType> {
        self.record_format_type.as_ref()
    }
    /// <p>When you configure application input at the time of creating or updating an application,
    /// provides additional mapping information specific to the record format (such as JSON, CSV, or
    /// record fields delimited by some delimiter) on the streaming source.</p>
    pub fn mapping_parameters(&self) -> std::option::Option<&crate::model::MappingParameters> {
        self.mapping_parameters.as_ref()
    }
}
impl std::fmt::Debug for RecordFormat {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("RecordFormat");
        formatter.field("record_format_type", &self.record_format_type);
        formatter.field("mapping_parameters", &self.mapping_parameters);
        formatter.finish()
    }
}
/// See [`RecordFormat`](crate::model::RecordFormat)
pub mod record_format {
    /// A builder for [`RecordFormat`](crate::model::RecordFormat)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) record_format_type: std::option::Option<crate::model::RecordFormatType>,
        pub(crate) mapping_parameters: std::option::Option<crate::model::MappingParameters>,
    }
    impl Builder {
        /// <p>The type of record format.</p>
        pub fn record_format_type(mut self, input: crate::model::RecordFormatType) -> Self {
            self.record_format_type = Some(input);
            self
        }
        /// <p>The type of record format.</p>
        pub fn set_record_format_type(
            mut self,
            input: std::option::Option<crate::model::RecordFormatType>,
        ) -> Self {
            self.record_format_type = input;
            self
        }
        /// <p>When you configure application input at the time of creating or updating an application,
        /// provides additional mapping information specific to the record format (such as JSON, CSV, or
        /// record fields delimited by some delimiter) on the streaming source.</p>
        pub fn mapping_parameters(mut self, input: crate::model::MappingParameters) -> Self {
            self.mapping_parameters = Some(input);
            self
        }
        /// <p>When you configure application input at the time of creating or updating an application,
        /// provides additional mapping information specific to the record format (such as JSON, CSV, or
        /// record fields delimited by some delimiter) on the streaming source.</p>
        pub fn set_mapping_parameters(
            mut self,
            input: std::option::Option<crate::model::MappingParameters>,
        ) -> Self {
            self.mapping_parameters = input;
            self
        }
        /// Consumes the builder and constructs a [`RecordFormat`](crate::model::RecordFormat)
        pub fn build(self) -> crate::model::RecordFormat {
            crate::model::RecordFormat {
                record_format_type: self.record_format_type,
                mapping_parameters: self.mapping_parameters,
            }
        }
    }
}
impl RecordFormat {
    /// Creates a new builder-style object to manufacture [`RecordFormat`](crate::model::RecordFormat)
    pub fn builder() -> crate::model::record_format::Builder {
        crate::model::record_format::Builder::default()
    }
}

/// <p>When you configure a SQL-based Kinesis Data Analytics application's input at the
/// time of creating or updating an application, provides additional mapping information specific
/// to the record format (such as JSON, CSV, or record fields delimited by some delimiter) on the
/// streaming source.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct MappingParameters {
    /// <p>Provides additional mapping information when JSON is the record format on the streaming source.</p>
    pub json_mapping_parameters: std::option::Option<crate::model::JsonMappingParameters>,
    /// <p>Provides additional mapping information when the record format uses delimiters
    /// (for example, CSV).</p>
    pub csv_mapping_parameters: std::option::Option<crate::model::CsvMappingParameters>,
}
impl MappingParameters {
    /// <p>Provides additional mapping information when JSON is the record format on the streaming source.</p>
    pub fn json_mapping_parameters(
        &self,
    ) -> std::option::Option<&crate::model::JsonMappingParameters> {
        self.json_mapping_parameters.as_ref()
    }
    /// <p>Provides additional mapping information when the record format uses delimiters
    /// (for example, CSV).</p>
    pub fn csv_mapping_parameters(
        &self,
    ) -> std::option::Option<&crate::model::CsvMappingParameters> {
        self.csv_mapping_parameters.as_ref()
    }
}
impl std::fmt::Debug for MappingParameters {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("MappingParameters");
        formatter.field("json_mapping_parameters", &self.json_mapping_parameters);
        formatter.field("csv_mapping_parameters", &self.csv_mapping_parameters);
        formatter.finish()
    }
}
/// See [`MappingParameters`](crate::model::MappingParameters)
pub mod mapping_parameters {
    /// A builder for [`MappingParameters`](crate::model::MappingParameters)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) json_mapping_parameters:
            std::option::Option<crate::model::JsonMappingParameters>,
        pub(crate) csv_mapping_parameters: std::option::Option<crate::model::CsvMappingParameters>,
    }
    impl Builder {
        /// <p>Provides additional mapping information when JSON is the record format on the streaming source.</p>
        pub fn json_mapping_parameters(
            mut self,
            input: crate::model::JsonMappingParameters,
        ) -> Self {
            self.json_mapping_parameters = Some(input);
            self
        }
        /// <p>Provides additional mapping information when JSON is the record format on the streaming source.</p>
        pub fn set_json_mapping_parameters(
            mut self,
            input: std::option::Option<crate::model::JsonMappingParameters>,
        ) -> Self {
            self.json_mapping_parameters = input;
            self
        }
        /// <p>Provides additional mapping information when the record format uses delimiters
        /// (for example, CSV).</p>
        pub fn csv_mapping_parameters(mut self, input: crate::model::CsvMappingParameters) -> Self {
            self.csv_mapping_parameters = Some(input);
            self
        }
        /// <p>Provides additional mapping information when the record format uses delimiters
        /// (for example, CSV).</p>
        pub fn set_csv_mapping_parameters(
            mut self,
            input: std::option::Option<crate::model::CsvMappingParameters>,
        ) -> Self {
            self.csv_mapping_parameters = input;
            self
        }
        /// Consumes the builder and constructs a [`MappingParameters`](crate::model::MappingParameters)
        pub fn build(self) -> crate::model::MappingParameters {
            crate::model::MappingParameters {
                json_mapping_parameters: self.json_mapping_parameters,
                csv_mapping_parameters: self.csv_mapping_parameters,
            }
        }
    }
}
impl MappingParameters {
    /// Creates a new builder-style object to manufacture [`MappingParameters`](crate::model::MappingParameters)
    pub fn builder() -> crate::model::mapping_parameters::Builder {
        crate::model::mapping_parameters::Builder::default()
    }
}

/// <p>For a SQL-based Kinesis Data Analytics application, provides additional mapping information when the record
/// format uses delimiters, such as CSV. For example, the following sample records use CSV format,
/// where the records use the <i>'\n'</i> as the row delimiter and a comma (",") as
/// the column delimiter: </p>
///
/// <p>
/// <code>"name1", "address1"</code>
/// </p>
/// <p>
/// <code>"name2", "address2"</code>
/// </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CsvMappingParameters {
    /// <p>The row delimiter. For example, in a CSV format, <i>'\n'</i> is the typical
    /// row delimiter.</p>
    pub record_row_delimiter: std::option::Option<std::string::String>,
    /// <p>The column delimiter. For example, in a CSV format, a comma (",") is the typical column
    /// delimiter.</p>
    pub record_column_delimiter: std::option::Option<std::string::String>,
}
impl CsvMappingParameters {
    /// <p>The row delimiter. For example, in a CSV format, <i>'\n'</i> is the typical
    /// row delimiter.</p>
    pub fn record_row_delimiter(&self) -> std::option::Option<&str> {
        self.record_row_delimiter.as_deref()
    }
    /// <p>The column delimiter. For example, in a CSV format, a comma (",") is the typical column
    /// delimiter.</p>
    pub fn record_column_delimiter(&self) -> std::option::Option<&str> {
        self.record_column_delimiter.as_deref()
    }
}
impl std::fmt::Debug for CsvMappingParameters {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CsvMappingParameters");
        formatter.field("record_row_delimiter", &self.record_row_delimiter);
        formatter.field("record_column_delimiter", &self.record_column_delimiter);
        formatter.finish()
    }
}
/// See [`CsvMappingParameters`](crate::model::CsvMappingParameters)
pub mod csv_mapping_parameters {
    /// A builder for [`CsvMappingParameters`](crate::model::CsvMappingParameters)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) record_row_delimiter: std::option::Option<std::string::String>,
        pub(crate) record_column_delimiter: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The row delimiter. For example, in a CSV format, <i>'\n'</i> is the typical
        /// row delimiter.</p>
        pub fn record_row_delimiter(mut self, input: impl Into<std::string::String>) -> Self {
            self.record_row_delimiter = Some(input.into());
            self
        }
        /// <p>The row delimiter. For example, in a CSV format, <i>'\n'</i> is the typical
        /// row delimiter.</p>
        pub fn set_record_row_delimiter(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.record_row_delimiter = input;
            self
        }
        /// <p>The column delimiter. For example, in a CSV format, a comma (",") is the typical column
        /// delimiter.</p>
        pub fn record_column_delimiter(mut self, input: impl Into<std::string::String>) -> Self {
            self.record_column_delimiter = Some(input.into());
            self
        }
        /// <p>The column delimiter. For example, in a CSV format, a comma (",") is the typical column
        /// delimiter.</p>
        pub fn set_record_column_delimiter(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.record_column_delimiter = input;
            self
        }
        /// Consumes the builder and constructs a [`CsvMappingParameters`](crate::model::CsvMappingParameters)
        pub fn build(self) -> crate::model::CsvMappingParameters {
            crate::model::CsvMappingParameters {
                record_row_delimiter: self.record_row_delimiter,
                record_column_delimiter: self.record_column_delimiter,
            }
        }
    }
}
impl CsvMappingParameters {
    /// Creates a new builder-style object to manufacture [`CsvMappingParameters`](crate::model::CsvMappingParameters)
    pub fn builder() -> crate::model::csv_mapping_parameters::Builder {
        crate::model::csv_mapping_parameters::Builder::default()
    }
}

/// <p>For a SQL-based Kinesis Data Analytics application, provides additional mapping
/// information when JSON is the record format on the streaming source.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct JsonMappingParameters {
    /// <p>The path to the top-level parent that contains the records.</p>
    pub record_row_path: std::option::Option<std::string::String>,
}
impl JsonMappingParameters {
    /// <p>The path to the top-level parent that contains the records.</p>
    pub fn record_row_path(&self) -> std::option::Option<&str> {
        self.record_row_path.as_deref()
    }
}
impl std::fmt::Debug for JsonMappingParameters {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("JsonMappingParameters");
        formatter.field("record_row_path", &self.record_row_path);
        formatter.finish()
    }
}
/// See [`JsonMappingParameters`](crate::model::JsonMappingParameters)
pub mod json_mapping_parameters {
    /// A builder for [`JsonMappingParameters`](crate::model::JsonMappingParameters)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) record_row_path: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The path to the top-level parent that contains the records.</p>
        pub fn record_row_path(mut self, input: impl Into<std::string::String>) -> Self {
            self.record_row_path = Some(input.into());
            self
        }
        /// <p>The path to the top-level parent that contains the records.</p>
        pub fn set_record_row_path(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.record_row_path = input;
            self
        }
        /// Consumes the builder and constructs a [`JsonMappingParameters`](crate::model::JsonMappingParameters)
        pub fn build(self) -> crate::model::JsonMappingParameters {
            crate::model::JsonMappingParameters {
                record_row_path: self.record_row_path,
            }
        }
    }
}
impl JsonMappingParameters {
    /// Creates a new builder-style object to manufacture [`JsonMappingParameters`](crate::model::JsonMappingParameters)
    pub fn builder() -> crate::model::json_mapping_parameters::Builder {
        crate::model::json_mapping_parameters::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum RecordFormatType {
    #[allow(missing_docs)] // documentation missing in model
    Csv,
    #[allow(missing_docs)] // documentation missing in model
    Json,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for RecordFormatType {
    fn from(s: &str) -> Self {
        match s {
            "CSV" => RecordFormatType::Csv,
            "JSON" => RecordFormatType::Json,
            other => RecordFormatType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for RecordFormatType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(RecordFormatType::from(s))
    }
}
impl RecordFormatType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            RecordFormatType::Csv => "CSV",
            RecordFormatType::Json => "JSON",
            RecordFormatType::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["CSV", "JSON"]
    }
}
impl AsRef<str> for RecordFormatType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>For a SQL-based Kinesis Data Analytics application, provides the bucket name and
/// object key name that stores the reference data.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct S3ReferenceDataSourceDescription {
    /// <p>The Amazon Resource Name (ARN) of the S3 bucket.</p>
    pub bucket_arn: std::option::Option<std::string::String>,
    /// <p>Amazon S3 object key name.</p>
    pub file_key: std::option::Option<std::string::String>,
    /// <p>The ARN of the IAM role that Kinesis Data Analytics can assume to read the Amazon S3
    /// object on your behalf to populate the in-application reference table. </p>
    /// <note>
    /// <p>Provided for backward compatibility. Applications that are created with the current API
    /// version have an application-level service execution role rather than a resource-level
    /// role.</p>
    /// </note>
    pub reference_role_arn: std::option::Option<std::string::String>,
}
impl S3ReferenceDataSourceDescription {
    /// <p>The Amazon Resource Name (ARN) of the S3 bucket.</p>
    pub fn bucket_arn(&self) -> std::option::Option<&str> {
        self.bucket_arn.as_deref()
    }
    /// <p>Amazon S3 object key name.</p>
    pub fn file_key(&self) -> std::option::Option<&str> {
        self.file_key.as_deref()
    }
    /// <p>The ARN of the IAM role that Kinesis Data Analytics can assume to read the Amazon S3
    /// object on your behalf to populate the in-application reference table. </p>
    /// <note>
    /// <p>Provided for backward compatibility. Applications that are created with the current API
    /// version have an application-level service execution role rather than a resource-level
    /// role.</p>
    /// </note>
    pub fn reference_role_arn(&self) -> std::option::Option<&str> {
        self.reference_role_arn.as_deref()
    }
}
impl std::fmt::Debug for S3ReferenceDataSourceDescription {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("S3ReferenceDataSourceDescription");
        formatter.field("bucket_arn", &self.bucket_arn);
        formatter.field("file_key", &self.file_key);
        formatter.field("reference_role_arn", &self.reference_role_arn);
        formatter.finish()
    }
}
/// See [`S3ReferenceDataSourceDescription`](crate::model::S3ReferenceDataSourceDescription)
pub mod s3_reference_data_source_description {
    /// A builder for [`S3ReferenceDataSourceDescription`](crate::model::S3ReferenceDataSourceDescription)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) bucket_arn: std::option::Option<std::string::String>,
        pub(crate) file_key: std::option::Option<std::string::String>,
        pub(crate) reference_role_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the S3 bucket.</p>
        pub fn bucket_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.bucket_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the S3 bucket.</p>
        pub fn set_bucket_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.bucket_arn = input;
            self
        }
        /// <p>Amazon S3 object key name.</p>
        pub fn file_key(mut self, input: impl Into<std::string::String>) -> Self {
            self.file_key = Some(input.into());
            self
        }
        /// <p>Amazon S3 object key name.</p>
        pub fn set_file_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.file_key = input;
            self
        }
        /// <p>The ARN of the IAM role that Kinesis Data Analytics can assume to read the Amazon S3
        /// object on your behalf to populate the in-application reference table. </p>
        /// <note>
        /// <p>Provided for backward compatibility. Applications that are created with the current API
        /// version have an application-level service execution role rather than a resource-level
        /// role.</p>
        /// </note>
        pub fn reference_role_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.reference_role_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the IAM role that Kinesis Data Analytics can assume to read the Amazon S3
        /// object on your behalf to populate the in-application reference table. </p>
        /// <note>
        /// <p>Provided for backward compatibility. Applications that are created with the current API
        /// version have an application-level service execution role rather than a resource-level
        /// role.</p>
        /// </note>
        pub fn set_reference_role_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.reference_role_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`S3ReferenceDataSourceDescription`](crate::model::S3ReferenceDataSourceDescription)
        pub fn build(self) -> crate::model::S3ReferenceDataSourceDescription {
            crate::model::S3ReferenceDataSourceDescription {
                bucket_arn: self.bucket_arn,
                file_key: self.file_key,
                reference_role_arn: self.reference_role_arn,
            }
        }
    }
}
impl S3ReferenceDataSourceDescription {
    /// Creates a new builder-style object to manufacture [`S3ReferenceDataSourceDescription`](crate::model::S3ReferenceDataSourceDescription)
    pub fn builder() -> crate::model::s3_reference_data_source_description::Builder {
        crate::model::s3_reference_data_source_description::Builder::default()
    }
}

/// <p>For a SQL-based Kinesis Data Analytics application, describes the application
/// output configuration, which includes the in-application stream name and the destination where
/// the stream data is written. The destination can be a Kinesis data stream or a Kinesis Data
/// Firehose delivery stream. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct OutputDescription {
    /// <p>A unique identifier for the output configuration.</p>
    pub output_id: std::option::Option<std::string::String>,
    /// <p>The name of the in-application stream that is configured as output.</p>
    pub name: std::option::Option<std::string::String>,
    /// <p>Describes the Kinesis data stream that is configured as the destination where output is
    /// written.</p>
    pub kinesis_streams_output_description:
        std::option::Option<crate::model::KinesisStreamsOutputDescription>,
    /// <p>Describes the Kinesis Data Firehose delivery stream that is configured as the destination
    /// where output is written.</p>
    pub kinesis_firehose_output_description:
        std::option::Option<crate::model::KinesisFirehoseOutputDescription>,
    /// <p>Describes the Lambda function that is configured as the destination where output is
    /// written.</p>
    pub lambda_output_description: std::option::Option<crate::model::LambdaOutputDescription>,
    /// <p>The data format used for writing data to the destination.</p>
    pub destination_schema: std::option::Option<crate::model::DestinationSchema>,
}
impl OutputDescription {
    /// <p>A unique identifier for the output configuration.</p>
    pub fn output_id(&self) -> std::option::Option<&str> {
        self.output_id.as_deref()
    }
    /// <p>The name of the in-application stream that is configured as output.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>Describes the Kinesis data stream that is configured as the destination where output is
    /// written.</p>
    pub fn kinesis_streams_output_description(
        &self,
    ) -> std::option::Option<&crate::model::KinesisStreamsOutputDescription> {
        self.kinesis_streams_output_description.as_ref()
    }
    /// <p>Describes the Kinesis Data Firehose delivery stream that is configured as the destination
    /// where output is written.</p>
    pub fn kinesis_firehose_output_description(
        &self,
    ) -> std::option::Option<&crate::model::KinesisFirehoseOutputDescription> {
        self.kinesis_firehose_output_description.as_ref()
    }
    /// <p>Describes the Lambda function that is configured as the destination where output is
    /// written.</p>
    pub fn lambda_output_description(
        &self,
    ) -> std::option::Option<&crate::model::LambdaOutputDescription> {
        self.lambda_output_description.as_ref()
    }
    /// <p>The data format used for writing data to the destination.</p>
    pub fn destination_schema(&self) -> std::option::Option<&crate::model::DestinationSchema> {
        self.destination_schema.as_ref()
    }
}
impl std::fmt::Debug for OutputDescription {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("OutputDescription");
        formatter.field("output_id", &self.output_id);
        formatter.field("name", &self.name);
        formatter.field(
            "kinesis_streams_output_description",
            &self.kinesis_streams_output_description,
        );
        formatter.field(
            "kinesis_firehose_output_description",
            &self.kinesis_firehose_output_description,
        );
        formatter.field("lambda_output_description", &self.lambda_output_description);
        formatter.field("destination_schema", &self.destination_schema);
        formatter.finish()
    }
}
/// See [`OutputDescription`](crate::model::OutputDescription)
pub mod output_description {
    /// A builder for [`OutputDescription`](crate::model::OutputDescription)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) output_id: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) kinesis_streams_output_description:
            std::option::Option<crate::model::KinesisStreamsOutputDescription>,
        pub(crate) kinesis_firehose_output_description:
            std::option::Option<crate::model::KinesisFirehoseOutputDescription>,
        pub(crate) lambda_output_description:
            std::option::Option<crate::model::LambdaOutputDescription>,
        pub(crate) destination_schema: std::option::Option<crate::model::DestinationSchema>,
    }
    impl Builder {
        /// <p>A unique identifier for the output configuration.</p>
        pub fn output_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.output_id = Some(input.into());
            self
        }
        /// <p>A unique identifier for the output configuration.</p>
        pub fn set_output_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.output_id = input;
            self
        }
        /// <p>The name of the in-application stream that is configured as output.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the in-application stream that is configured as output.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>Describes the Kinesis data stream that is configured as the destination where output is
        /// written.</p>
        pub fn kinesis_streams_output_description(
            mut self,
            input: crate::model::KinesisStreamsOutputDescription,
        ) -> Self {
            self.kinesis_streams_output_description = Some(input);
            self
        }
        /// <p>Describes the Kinesis data stream that is configured as the destination where output is
        /// written.</p>
        pub fn set_kinesis_streams_output_description(
            mut self,
            input: std::option::Option<crate::model::KinesisStreamsOutputDescription>,
        ) -> Self {
            self.kinesis_streams_output_description = input;
            self
        }
        /// <p>Describes the Kinesis Data Firehose delivery stream that is configured as the destination
        /// where output is written.</p>
        pub fn kinesis_firehose_output_description(
            mut self,
            input: crate::model::KinesisFirehoseOutputDescription,
        ) -> Self {
            self.kinesis_firehose_output_description = Some(input);
            self
        }
        /// <p>Describes the Kinesis Data Firehose delivery stream that is configured as the destination
        /// where output is written.</p>
        pub fn set_kinesis_firehose_output_description(
            mut self,
            input: std::option::Option<crate::model::KinesisFirehoseOutputDescription>,
        ) -> Self {
            self.kinesis_firehose_output_description = input;
            self
        }
        /// <p>Describes the Lambda function that is configured as the destination where output is
        /// written.</p>
        pub fn lambda_output_description(
            mut self,
            input: crate::model::LambdaOutputDescription,
        ) -> Self {
            self.lambda_output_description = Some(input);
            self
        }
        /// <p>Describes the Lambda function that is configured as the destination where output is
        /// written.</p>
        pub fn set_lambda_output_description(
            mut self,
            input: std::option::Option<crate::model::LambdaOutputDescription>,
        ) -> Self {
            self.lambda_output_description = input;
            self
        }
        /// <p>The data format used for writing data to the destination.</p>
        pub fn destination_schema(mut self, input: crate::model::DestinationSchema) -> Self {
            self.destination_schema = Some(input);
            self
        }
        /// <p>The data format used for writing data to the destination.</p>
        pub fn set_destination_schema(
            mut self,
            input: std::option::Option<crate::model::DestinationSchema>,
        ) -> Self {
            self.destination_schema = input;
            self
        }
        /// Consumes the builder and constructs a [`OutputDescription`](crate::model::OutputDescription)
        pub fn build(self) -> crate::model::OutputDescription {
            crate::model::OutputDescription {
                output_id: self.output_id,
                name: self.name,
                kinesis_streams_output_description: self.kinesis_streams_output_description,
                kinesis_firehose_output_description: self.kinesis_firehose_output_description,
                lambda_output_description: self.lambda_output_description,
                destination_schema: self.destination_schema,
            }
        }
    }
}
impl OutputDescription {
    /// Creates a new builder-style object to manufacture [`OutputDescription`](crate::model::OutputDescription)
    pub fn builder() -> crate::model::output_description::Builder {
        crate::model::output_description::Builder::default()
    }
}

/// <p>Describes the data format when records are written to the destination in a SQL-based Kinesis Data Analytics application. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DestinationSchema {
    /// <p>Specifies the format of the records on the output stream.</p>
    pub record_format_type: std::option::Option<crate::model::RecordFormatType>,
}
impl DestinationSchema {
    /// <p>Specifies the format of the records on the output stream.</p>
    pub fn record_format_type(&self) -> std::option::Option<&crate::model::RecordFormatType> {
        self.record_format_type.as_ref()
    }
}
impl std::fmt::Debug for DestinationSchema {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DestinationSchema");
        formatter.field("record_format_type", &self.record_format_type);
        formatter.finish()
    }
}
/// See [`DestinationSchema`](crate::model::DestinationSchema)
pub mod destination_schema {
    /// A builder for [`DestinationSchema`](crate::model::DestinationSchema)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) record_format_type: std::option::Option<crate::model::RecordFormatType>,
    }
    impl Builder {
        /// <p>Specifies the format of the records on the output stream.</p>
        pub fn record_format_type(mut self, input: crate::model::RecordFormatType) -> Self {
            self.record_format_type = Some(input);
            self
        }
        /// <p>Specifies the format of the records on the output stream.</p>
        pub fn set_record_format_type(
            mut self,
            input: std::option::Option<crate::model::RecordFormatType>,
        ) -> Self {
            self.record_format_type = input;
            self
        }
        /// Consumes the builder and constructs a [`DestinationSchema`](crate::model::DestinationSchema)
        pub fn build(self) -> crate::model::DestinationSchema {
            crate::model::DestinationSchema {
                record_format_type: self.record_format_type,
            }
        }
    }
}
impl DestinationSchema {
    /// Creates a new builder-style object to manufacture [`DestinationSchema`](crate::model::DestinationSchema)
    pub fn builder() -> crate::model::destination_schema::Builder {
        crate::model::destination_schema::Builder::default()
    }
}

/// <p>For a SQL-based Kinesis Data Analytics application's output, describes the Amazon
/// Lambda function that is configured as its destination. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct LambdaOutputDescription {
    /// <p>The Amazon Resource Name (ARN) of the destination Lambda function.</p>
    pub resource_arn: std::option::Option<std::string::String>,
    /// <p>The ARN of the IAM role that Kinesis Data Analytics can assume to write to the destination
    /// function.</p>
    /// <note>
    /// <p>Provided for backward compatibility. Applications that are created with the current API
    /// version have an application-level service execution role rather than a resource-level
    /// role.</p>
    /// </note>
    pub role_arn: std::option::Option<std::string::String>,
}
impl LambdaOutputDescription {
    /// <p>The Amazon Resource Name (ARN) of the destination Lambda function.</p>
    pub fn resource_arn(&self) -> std::option::Option<&str> {
        self.resource_arn.as_deref()
    }
    /// <p>The ARN of the IAM role that Kinesis Data Analytics can assume to write to the destination
    /// function.</p>
    /// <note>
    /// <p>Provided for backward compatibility. Applications that are created with the current API
    /// version have an application-level service execution role rather than a resource-level
    /// role.</p>
    /// </note>
    pub fn role_arn(&self) -> std::option::Option<&str> {
        self.role_arn.as_deref()
    }
}
impl std::fmt::Debug for LambdaOutputDescription {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("LambdaOutputDescription");
        formatter.field("resource_arn", &self.resource_arn);
        formatter.field("role_arn", &self.role_arn);
        formatter.finish()
    }
}
/// See [`LambdaOutputDescription`](crate::model::LambdaOutputDescription)
pub mod lambda_output_description {
    /// A builder for [`LambdaOutputDescription`](crate::model::LambdaOutputDescription)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) resource_arn: std::option::Option<std::string::String>,
        pub(crate) role_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the destination Lambda function.</p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the destination Lambda function.</p>
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.resource_arn = input;
            self
        }
        /// <p>The ARN of the IAM role that Kinesis Data Analytics can assume to write to the destination
        /// function.</p>
        /// <note>
        /// <p>Provided for backward compatibility. Applications that are created with the current API
        /// version have an application-level service execution role rather than a resource-level
        /// role.</p>
        /// </note>
        pub fn role_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.role_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the IAM role that Kinesis Data Analytics can assume to write to the destination
        /// function.</p>
        /// <note>
        /// <p>Provided for backward compatibility. Applications that are created with the current API
        /// version have an application-level service execution role rather than a resource-level
        /// role.</p>
        /// </note>
        pub fn set_role_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.role_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`LambdaOutputDescription`](crate::model::LambdaOutputDescription)
        pub fn build(self) -> crate::model::LambdaOutputDescription {
            crate::model::LambdaOutputDescription {
                resource_arn: self.resource_arn,
                role_arn: self.role_arn,
            }
        }
    }
}
impl LambdaOutputDescription {
    /// Creates a new builder-style object to manufacture [`LambdaOutputDescription`](crate::model::LambdaOutputDescription)
    pub fn builder() -> crate::model::lambda_output_description::Builder {
        crate::model::lambda_output_description::Builder::default()
    }
}

/// <p>For a SQL-based Kinesis Data Analytics application's output, describes the Kinesis
/// Data Firehose delivery stream that is configured as its destination.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct KinesisFirehoseOutputDescription {
    /// <p>The Amazon Resource Name (ARN) of the delivery stream.</p>
    pub resource_arn: std::option::Option<std::string::String>,
    /// <p>The ARN of the IAM role that Kinesis Data Analytics can assume to access the
    /// stream.</p>
    /// <note>
    /// <p>Provided for backward compatibility. Applications that are created with the current API
    /// version have an application-level service execution role rather than a resource-level
    /// role.</p>
    /// </note>
    pub role_arn: std::option::Option<std::string::String>,
}
impl KinesisFirehoseOutputDescription {
    /// <p>The Amazon Resource Name (ARN) of the delivery stream.</p>
    pub fn resource_arn(&self) -> std::option::Option<&str> {
        self.resource_arn.as_deref()
    }
    /// <p>The ARN of the IAM role that Kinesis Data Analytics can assume to access the
    /// stream.</p>
    /// <note>
    /// <p>Provided for backward compatibility. Applications that are created with the current API
    /// version have an application-level service execution role rather than a resource-level
    /// role.</p>
    /// </note>
    pub fn role_arn(&self) -> std::option::Option<&str> {
        self.role_arn.as_deref()
    }
}
impl std::fmt::Debug for KinesisFirehoseOutputDescription {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("KinesisFirehoseOutputDescription");
        formatter.field("resource_arn", &self.resource_arn);
        formatter.field("role_arn", &self.role_arn);
        formatter.finish()
    }
}
/// See [`KinesisFirehoseOutputDescription`](crate::model::KinesisFirehoseOutputDescription)
pub mod kinesis_firehose_output_description {
    /// A builder for [`KinesisFirehoseOutputDescription`](crate::model::KinesisFirehoseOutputDescription)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) resource_arn: std::option::Option<std::string::String>,
        pub(crate) role_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the delivery stream.</p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the delivery stream.</p>
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.resource_arn = input;
            self
        }
        /// <p>The ARN of the IAM role that Kinesis Data Analytics can assume to access the
        /// stream.</p>
        /// <note>
        /// <p>Provided for backward compatibility. Applications that are created with the current API
        /// version have an application-level service execution role rather than a resource-level
        /// role.</p>
        /// </note>
        pub fn role_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.role_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the IAM role that Kinesis Data Analytics can assume to access the
        /// stream.</p>
        /// <note>
        /// <p>Provided for backward compatibility. Applications that are created with the current API
        /// version have an application-level service execution role rather than a resource-level
        /// role.</p>
        /// </note>
        pub fn set_role_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.role_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`KinesisFirehoseOutputDescription`](crate::model::KinesisFirehoseOutputDescription)
        pub fn build(self) -> crate::model::KinesisFirehoseOutputDescription {
            crate::model::KinesisFirehoseOutputDescription {
                resource_arn: self.resource_arn,
                role_arn: self.role_arn,
            }
        }
    }
}
impl KinesisFirehoseOutputDescription {
    /// Creates a new builder-style object to manufacture [`KinesisFirehoseOutputDescription`](crate::model::KinesisFirehoseOutputDescription)
    pub fn builder() -> crate::model::kinesis_firehose_output_description::Builder {
        crate::model::kinesis_firehose_output_description::Builder::default()
    }
}

/// <p>For an SQL-based Kinesis Data Analytics application's output, describes the Kinesis
/// data stream that is configured as its destination. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct KinesisStreamsOutputDescription {
    /// <p>The Amazon Resource Name (ARN) of the Kinesis data stream.</p>
    pub resource_arn: std::option::Option<std::string::String>,
    /// <p>The ARN of the IAM role that Kinesis Data Analytics can assume to access the
    /// stream.</p>
    /// <note>
    /// <p>Provided for backward compatibility. Applications that are created with the current API
    /// version have an application-level service execution role rather than a resource-level
    /// role.</p>
    /// </note>
    pub role_arn: std::option::Option<std::string::String>,
}
impl KinesisStreamsOutputDescription {
    /// <p>The Amazon Resource Name (ARN) of the Kinesis data stream.</p>
    pub fn resource_arn(&self) -> std::option::Option<&str> {
        self.resource_arn.as_deref()
    }
    /// <p>The ARN of the IAM role that Kinesis Data Analytics can assume to access the
    /// stream.</p>
    /// <note>
    /// <p>Provided for backward compatibility. Applications that are created with the current API
    /// version have an application-level service execution role rather than a resource-level
    /// role.</p>
    /// </note>
    pub fn role_arn(&self) -> std::option::Option<&str> {
        self.role_arn.as_deref()
    }
}
impl std::fmt::Debug for KinesisStreamsOutputDescription {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("KinesisStreamsOutputDescription");
        formatter.field("resource_arn", &self.resource_arn);
        formatter.field("role_arn", &self.role_arn);
        formatter.finish()
    }
}
/// See [`KinesisStreamsOutputDescription`](crate::model::KinesisStreamsOutputDescription)
pub mod kinesis_streams_output_description {
    /// A builder for [`KinesisStreamsOutputDescription`](crate::model::KinesisStreamsOutputDescription)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) resource_arn: std::option::Option<std::string::String>,
        pub(crate) role_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the Kinesis data stream.</p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the Kinesis data stream.</p>
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.resource_arn = input;
            self
        }
        /// <p>The ARN of the IAM role that Kinesis Data Analytics can assume to access the
        /// stream.</p>
        /// <note>
        /// <p>Provided for backward compatibility. Applications that are created with the current API
        /// version have an application-level service execution role rather than a resource-level
        /// role.</p>
        /// </note>
        pub fn role_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.role_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the IAM role that Kinesis Data Analytics can assume to access the
        /// stream.</p>
        /// <note>
        /// <p>Provided for backward compatibility. Applications that are created with the current API
        /// version have an application-level service execution role rather than a resource-level
        /// role.</p>
        /// </note>
        pub fn set_role_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.role_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`KinesisStreamsOutputDescription`](crate::model::KinesisStreamsOutputDescription)
        pub fn build(self) -> crate::model::KinesisStreamsOutputDescription {
            crate::model::KinesisStreamsOutputDescription {
                resource_arn: self.resource_arn,
                role_arn: self.role_arn,
            }
        }
    }
}
impl KinesisStreamsOutputDescription {
    /// Creates a new builder-style object to manufacture [`KinesisStreamsOutputDescription`](crate::model::KinesisStreamsOutputDescription)
    pub fn builder() -> crate::model::kinesis_streams_output_description::Builder {
        crate::model::kinesis_streams_output_description::Builder::default()
    }
}

/// <p>Describes the application input configuration for a SQL-based Kinesis Data Analytics application. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InputDescription {
    /// <p>The input ID that is associated with the application input. This is the ID that Kinesis Data Analytics assigns to each input
    /// configuration that you add to your application. </p>
    pub input_id: std::option::Option<std::string::String>,
    /// <p>The in-application name prefix.</p>
    pub name_prefix: std::option::Option<std::string::String>,
    /// <p>Returns the in-application stream names that are mapped to the stream source. </p>
    pub in_app_stream_names: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The description of the preprocessor that executes on records in this input before the application's code is run. </p>
    pub input_processing_configuration_description:
        std::option::Option<crate::model::InputProcessingConfigurationDescription>,
    /// <p>If a Kinesis data stream is configured as a streaming source, provides the Kinesis data
    /// stream's Amazon Resource Name (ARN). </p>
    pub kinesis_streams_input_description:
        std::option::Option<crate::model::KinesisStreamsInputDescription>,
    /// <p>If a Kinesis Data Firehose delivery stream is configured as a streaming source, provides the delivery stream's ARN. </p>
    pub kinesis_firehose_input_description:
        std::option::Option<crate::model::KinesisFirehoseInputDescription>,
    /// <p>Describes the format of the data in the streaming source, and how each data element maps to corresponding columns
    /// in the in-application stream that is being created. </p>
    pub input_schema: std::option::Option<crate::model::SourceSchema>,
    /// <p>Describes the configured parallelism (number of in-application streams mapped to the streaming source). </p>
    pub input_parallelism: std::option::Option<crate::model::InputParallelism>,
    /// <p>The point at which the application is configured to read from the input stream.</p>
    pub input_starting_position_configuration:
        std::option::Option<crate::model::InputStartingPositionConfiguration>,
}
impl InputDescription {
    /// <p>The input ID that is associated with the application input. This is the ID that Kinesis Data Analytics assigns to each input
    /// configuration that you add to your application. </p>
    pub fn input_id(&self) -> std::option::Option<&str> {
        self.input_id.as_deref()
    }
    /// <p>The in-application name prefix.</p>
    pub fn name_prefix(&self) -> std::option::Option<&str> {
        self.name_prefix.as_deref()
    }
    /// <p>Returns the in-application stream names that are mapped to the stream source. </p>
    pub fn in_app_stream_names(&self) -> std::option::Option<&[std::string::String]> {
        self.in_app_stream_names.as_deref()
    }
    /// <p>The description of the preprocessor that executes on records in this input before the application's code is run. </p>
    pub fn input_processing_configuration_description(
        &self,
    ) -> std::option::Option<&crate::model::InputProcessingConfigurationDescription> {
        self.input_processing_configuration_description.as_ref()
    }
    /// <p>If a Kinesis data stream is configured as a streaming source, provides the Kinesis data
    /// stream's Amazon Resource Name (ARN). </p>
    pub fn kinesis_streams_input_description(
        &self,
    ) -> std::option::Option<&crate::model::KinesisStreamsInputDescription> {
        self.kinesis_streams_input_description.as_ref()
    }
    /// <p>If a Kinesis Data Firehose delivery stream is configured as a streaming source, provides the delivery stream's ARN. </p>
    pub fn kinesis_firehose_input_description(
        &self,
    ) -> std::option::Option<&crate::model::KinesisFirehoseInputDescription> {
        self.kinesis_firehose_input_description.as_ref()
    }
    /// <p>Describes the format of the data in the streaming source, and how each data element maps to corresponding columns
    /// in the in-application stream that is being created. </p>
    pub fn input_schema(&self) -> std::option::Option<&crate::model::SourceSchema> {
        self.input_schema.as_ref()
    }
    /// <p>Describes the configured parallelism (number of in-application streams mapped to the streaming source). </p>
    pub fn input_parallelism(&self) -> std::option::Option<&crate::model::InputParallelism> {
        self.input_parallelism.as_ref()
    }
    /// <p>The point at which the application is configured to read from the input stream.</p>
    pub fn input_starting_position_configuration(
        &self,
    ) -> std::option::Option<&crate::model::InputStartingPositionConfiguration> {
        self.input_starting_position_configuration.as_ref()
    }
}
impl std::fmt::Debug for InputDescription {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InputDescription");
        formatter.field("input_id", &self.input_id);
        formatter.field("name_prefix", &self.name_prefix);
        formatter.field("in_app_stream_names", &self.in_app_stream_names);
        formatter.field(
            "input_processing_configuration_description",
            &self.input_processing_configuration_description,
        );
        formatter.field(
            "kinesis_streams_input_description",
            &self.kinesis_streams_input_description,
        );
        formatter.field(
            "kinesis_firehose_input_description",
            &self.kinesis_firehose_input_description,
        );
        formatter.field("input_schema", &self.input_schema);
        formatter.field("input_parallelism", &self.input_parallelism);
        formatter.field(
            "input_starting_position_configuration",
            &self.input_starting_position_configuration,
        );
        formatter.finish()
    }
}
/// See [`InputDescription`](crate::model::InputDescription)
pub mod input_description {
    /// A builder for [`InputDescription`](crate::model::InputDescription)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) input_id: std::option::Option<std::string::String>,
        pub(crate) name_prefix: std::option::Option<std::string::String>,
        pub(crate) in_app_stream_names: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) input_processing_configuration_description:
            std::option::Option<crate::model::InputProcessingConfigurationDescription>,
        pub(crate) kinesis_streams_input_description:
            std::option::Option<crate::model::KinesisStreamsInputDescription>,
        pub(crate) kinesis_firehose_input_description:
            std::option::Option<crate::model::KinesisFirehoseInputDescription>,
        pub(crate) input_schema: std::option::Option<crate::model::SourceSchema>,
        pub(crate) input_parallelism: std::option::Option<crate::model::InputParallelism>,
        pub(crate) input_starting_position_configuration:
            std::option::Option<crate::model::InputStartingPositionConfiguration>,
    }
    impl Builder {
        /// <p>The input ID that is associated with the application input. This is the ID that Kinesis Data Analytics assigns to each input
        /// configuration that you add to your application. </p>
        pub fn input_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.input_id = Some(input.into());
            self
        }
        /// <p>The input ID that is associated with the application input. This is the ID that Kinesis Data Analytics assigns to each input
        /// configuration that you add to your application. </p>
        pub fn set_input_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.input_id = input;
            self
        }
        /// <p>The in-application name prefix.</p>
        pub fn name_prefix(mut self, input: impl Into<std::string::String>) -> Self {
            self.name_prefix = Some(input.into());
            self
        }
        /// <p>The in-application name prefix.</p>
        pub fn set_name_prefix(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name_prefix = input;
            self
        }
        /// Appends an item to `in_app_stream_names`.
        ///
        /// To override the contents of this collection use [`set_in_app_stream_names`](Self::set_in_app_stream_names).
        ///
        /// <p>Returns the in-application stream names that are mapped to the stream source. </p>
        pub fn in_app_stream_names(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.in_app_stream_names.unwrap_or_default();
            v.push(input.into());
            self.in_app_stream_names = Some(v);
            self
        }
        /// <p>Returns the in-application stream names that are mapped to the stream source. </p>
        pub fn set_in_app_stream_names(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.in_app_stream_names = input;
            self
        }
        /// <p>The description of the preprocessor that executes on records in this input before the application's code is run. </p>
        pub fn input_processing_configuration_description(
            mut self,
            input: crate::model::InputProcessingConfigurationDescription,
        ) -> Self {
            self.input_processing_configuration_description = Some(input);
            self
        }
        /// <p>The description of the preprocessor that executes on records in this input before the application's code is run. </p>
        pub fn set_input_processing_configuration_description(
            mut self,
            input: std::option::Option<crate::model::InputProcessingConfigurationDescription>,
        ) -> Self {
            self.input_processing_configuration_description = input;
            self
        }
        /// <p>If a Kinesis data stream is configured as a streaming source, provides the Kinesis data
        /// stream's Amazon Resource Name (ARN). </p>
        pub fn kinesis_streams_input_description(
            mut self,
            input: crate::model::KinesisStreamsInputDescription,
        ) -> Self {
            self.kinesis_streams_input_description = Some(input);
            self
        }
        /// <p>If a Kinesis data stream is configured as a streaming source, provides the Kinesis data
        /// stream's Amazon Resource Name (ARN). </p>
        pub fn set_kinesis_streams_input_description(
            mut self,
            input: std::option::Option<crate::model::KinesisStreamsInputDescription>,
        ) -> Self {
            self.kinesis_streams_input_description = input;
            self
        }
        /// <p>If a Kinesis Data Firehose delivery stream is configured as a streaming source, provides the delivery stream's ARN. </p>
        pub fn kinesis_firehose_input_description(
            mut self,
            input: crate::model::KinesisFirehoseInputDescription,
        ) -> Self {
            self.kinesis_firehose_input_description = Some(input);
            self
        }
        /// <p>If a Kinesis Data Firehose delivery stream is configured as a streaming source, provides the delivery stream's ARN. </p>
        pub fn set_kinesis_firehose_input_description(
            mut self,
            input: std::option::Option<crate::model::KinesisFirehoseInputDescription>,
        ) -> Self {
            self.kinesis_firehose_input_description = input;
            self
        }
        /// <p>Describes the format of the data in the streaming source, and how each data element maps to corresponding columns
        /// in the in-application stream that is being created. </p>
        pub fn input_schema(mut self, input: crate::model::SourceSchema) -> Self {
            self.input_schema = Some(input);
            self
        }
        /// <p>Describes the format of the data in the streaming source, and how each data element maps to corresponding columns
        /// in the in-application stream that is being created. </p>
        pub fn set_input_schema(
            mut self,
            input: std::option::Option<crate::model::SourceSchema>,
        ) -> Self {
            self.input_schema = input;
            self
        }
        /// <p>Describes the configured parallelism (number of in-application streams mapped to the streaming source). </p>
        pub fn input_parallelism(mut self, input: crate::model::InputParallelism) -> Self {
            self.input_parallelism = Some(input);
            self
        }
        /// <p>Describes the configured parallelism (number of in-application streams mapped to the streaming source). </p>
        pub fn set_input_parallelism(
            mut self,
            input: std::option::Option<crate::model::InputParallelism>,
        ) -> Self {
            self.input_parallelism = input;
            self
        }
        /// <p>The point at which the application is configured to read from the input stream.</p>
        pub fn input_starting_position_configuration(
            mut self,
            input: crate::model::InputStartingPositionConfiguration,
        ) -> Self {
            self.input_starting_position_configuration = Some(input);
            self
        }
        /// <p>The point at which the application is configured to read from the input stream.</p>
        pub fn set_input_starting_position_configuration(
            mut self,
            input: std::option::Option<crate::model::InputStartingPositionConfiguration>,
        ) -> Self {
            self.input_starting_position_configuration = input;
            self
        }
        /// Consumes the builder and constructs a [`InputDescription`](crate::model::InputDescription)
        pub fn build(self) -> crate::model::InputDescription {
            crate::model::InputDescription {
                input_id: self.input_id,
                name_prefix: self.name_prefix,
                in_app_stream_names: self.in_app_stream_names,
                input_processing_configuration_description: self
                    .input_processing_configuration_description,
                kinesis_streams_input_description: self.kinesis_streams_input_description,
                kinesis_firehose_input_description: self.kinesis_firehose_input_description,
                input_schema: self.input_schema,
                input_parallelism: self.input_parallelism,
                input_starting_position_configuration: self.input_starting_position_configuration,
            }
        }
    }
}
impl InputDescription {
    /// Creates a new builder-style object to manufacture [`InputDescription`](crate::model::InputDescription)
    pub fn builder() -> crate::model::input_description::Builder {
        crate::model::input_description::Builder::default()
    }
}

/// <p>Describes the point at which the application reads from
/// the streaming source.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InputStartingPositionConfiguration {
    /// <p>The starting position on the stream.</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>NOW</code> - Start reading just after the most recent record in the stream, and
    /// start at the request timestamp that the customer issued.</p>
    ///
    ///
    /// </li>
    /// <li>
    /// <p>
    /// <code>TRIM_HORIZON</code> - Start reading at the last untrimmed record in the stream,
    /// which is the oldest record available in the stream. This option is not available
    /// for an Amazon Kinesis Data Firehose delivery stream.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>LAST_STOPPED_POINT</code> - Resume reading from where the application last stopped reading.</p>
    /// </li>
    /// </ul>
    pub input_starting_position: std::option::Option<crate::model::InputStartingPosition>,
}
impl InputStartingPositionConfiguration {
    /// <p>The starting position on the stream.</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>NOW</code> - Start reading just after the most recent record in the stream, and
    /// start at the request timestamp that the customer issued.</p>
    ///
    ///
    /// </li>
    /// <li>
    /// <p>
    /// <code>TRIM_HORIZON</code> - Start reading at the last untrimmed record in the stream,
    /// which is the oldest record available in the stream. This option is not available
    /// for an Amazon Kinesis Data Firehose delivery stream.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>LAST_STOPPED_POINT</code> - Resume reading from where the application last stopped reading.</p>
    /// </li>
    /// </ul>
    pub fn input_starting_position(
        &self,
    ) -> std::option::Option<&crate::model::InputStartingPosition> {
        self.input_starting_position.as_ref()
    }
}
impl std::fmt::Debug for InputStartingPositionConfiguration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InputStartingPositionConfiguration");
        formatter.field("input_starting_position", &self.input_starting_position);
        formatter.finish()
    }
}
/// See [`InputStartingPositionConfiguration`](crate::model::InputStartingPositionConfiguration)
pub mod input_starting_position_configuration {
    /// A builder for [`InputStartingPositionConfiguration`](crate::model::InputStartingPositionConfiguration)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) input_starting_position:
            std::option::Option<crate::model::InputStartingPosition>,
    }
    impl Builder {
        /// <p>The starting position on the stream.</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>NOW</code> - Start reading just after the most recent record in the stream, and
        /// start at the request timestamp that the customer issued.</p>
        ///
        ///
        /// </li>
        /// <li>
        /// <p>
        /// <code>TRIM_HORIZON</code> - Start reading at the last untrimmed record in the stream,
        /// which is the oldest record available in the stream. This option is not available
        /// for an Amazon Kinesis Data Firehose delivery stream.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>LAST_STOPPED_POINT</code> - Resume reading from where the application last stopped reading.</p>
        /// </li>
        /// </ul>
        pub fn input_starting_position(
            mut self,
            input: crate::model::InputStartingPosition,
        ) -> Self {
            self.input_starting_position = Some(input);
            self
        }
        /// <p>The starting position on the stream.</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>NOW</code> - Start reading just after the most recent record in the stream, and
        /// start at the request timestamp that the customer issued.</p>
        ///
        ///
        /// </li>
        /// <li>
        /// <p>
        /// <code>TRIM_HORIZON</code> - Start reading at the last untrimmed record in the stream,
        /// which is the oldest record available in the stream. This option is not available
        /// for an Amazon Kinesis Data Firehose delivery stream.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>LAST_STOPPED_POINT</code> - Resume reading from where the application last stopped reading.</p>
        /// </li>
        /// </ul>
        pub fn set_input_starting_position(
            mut self,
            input: std::option::Option<crate::model::InputStartingPosition>,
        ) -> Self {
            self.input_starting_position = input;
            self
        }
        /// Consumes the builder and constructs a [`InputStartingPositionConfiguration`](crate::model::InputStartingPositionConfiguration)
        pub fn build(self) -> crate::model::InputStartingPositionConfiguration {
            crate::model::InputStartingPositionConfiguration {
                input_starting_position: self.input_starting_position,
            }
        }
    }
}
impl InputStartingPositionConfiguration {
    /// Creates a new builder-style object to manufacture [`InputStartingPositionConfiguration`](crate::model::InputStartingPositionConfiguration)
    pub fn builder() -> crate::model::input_starting_position_configuration::Builder {
        crate::model::input_starting_position_configuration::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum InputStartingPosition {
    #[allow(missing_docs)] // documentation missing in model
    LastStoppedPoint,
    #[allow(missing_docs)] // documentation missing in model
    Now,
    #[allow(missing_docs)] // documentation missing in model
    TrimHorizon,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for InputStartingPosition {
    fn from(s: &str) -> Self {
        match s {
            "LAST_STOPPED_POINT" => InputStartingPosition::LastStoppedPoint,
            "NOW" => InputStartingPosition::Now,
            "TRIM_HORIZON" => InputStartingPosition::TrimHorizon,
            other => InputStartingPosition::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for InputStartingPosition {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(InputStartingPosition::from(s))
    }
}
impl InputStartingPosition {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            InputStartingPosition::LastStoppedPoint => "LAST_STOPPED_POINT",
            InputStartingPosition::Now => "NOW",
            InputStartingPosition::TrimHorizon => "TRIM_HORIZON",
            InputStartingPosition::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["LAST_STOPPED_POINT", "NOW", "TRIM_HORIZON"]
    }
}
impl AsRef<str> for InputStartingPosition {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>For a SQL-based Kinesis Data Analytics application, describes the number of
/// in-application streams to create for a given streaming source. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InputParallelism {
    /// <p>The number of in-application streams to create.</p>
    pub count: std::option::Option<i32>,
}
impl InputParallelism {
    /// <p>The number of in-application streams to create.</p>
    pub fn count(&self) -> std::option::Option<i32> {
        self.count
    }
}
impl std::fmt::Debug for InputParallelism {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InputParallelism");
        formatter.field("count", &self.count);
        formatter.finish()
    }
}
/// See [`InputParallelism`](crate::model::InputParallelism)
pub mod input_parallelism {
    /// A builder for [`InputParallelism`](crate::model::InputParallelism)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) count: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The number of in-application streams to create.</p>
        pub fn count(mut self, input: i32) -> Self {
            self.count = Some(input);
            self
        }
        /// <p>The number of in-application streams to create.</p>
        pub fn set_count(mut self, input: std::option::Option<i32>) -> Self {
            self.count = input;
            self
        }
        /// Consumes the builder and constructs a [`InputParallelism`](crate::model::InputParallelism)
        pub fn build(self) -> crate::model::InputParallelism {
            crate::model::InputParallelism { count: self.count }
        }
    }
}
impl InputParallelism {
    /// Creates a new builder-style object to manufacture [`InputParallelism`](crate::model::InputParallelism)
    pub fn builder() -> crate::model::input_parallelism::Builder {
        crate::model::input_parallelism::Builder::default()
    }
}

/// <p>Describes the Amazon Kinesis Data Firehose delivery stream that is configured as the streaming source
/// in the application input configuration. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct KinesisFirehoseInputDescription {
    /// <p>The Amazon Resource Name (ARN) of the delivery stream.</p>
    pub resource_arn: std::option::Option<std::string::String>,
    /// <p>The ARN of the IAM role that Kinesis Data Analytics assumes to access the stream.</p>
    /// <note>
    /// <p>Provided for backward compatibility. Applications that are created with the current API
    /// version have an application-level service execution role rather than a resource-level
    /// role.</p>
    /// </note>
    pub role_arn: std::option::Option<std::string::String>,
}
impl KinesisFirehoseInputDescription {
    /// <p>The Amazon Resource Name (ARN) of the delivery stream.</p>
    pub fn resource_arn(&self) -> std::option::Option<&str> {
        self.resource_arn.as_deref()
    }
    /// <p>The ARN of the IAM role that Kinesis Data Analytics assumes to access the stream.</p>
    /// <note>
    /// <p>Provided for backward compatibility. Applications that are created with the current API
    /// version have an application-level service execution role rather than a resource-level
    /// role.</p>
    /// </note>
    pub fn role_arn(&self) -> std::option::Option<&str> {
        self.role_arn.as_deref()
    }
}
impl std::fmt::Debug for KinesisFirehoseInputDescription {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("KinesisFirehoseInputDescription");
        formatter.field("resource_arn", &self.resource_arn);
        formatter.field("role_arn", &self.role_arn);
        formatter.finish()
    }
}
/// See [`KinesisFirehoseInputDescription`](crate::model::KinesisFirehoseInputDescription)
pub mod kinesis_firehose_input_description {
    /// A builder for [`KinesisFirehoseInputDescription`](crate::model::KinesisFirehoseInputDescription)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) resource_arn: std::option::Option<std::string::String>,
        pub(crate) role_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the delivery stream.</p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the delivery stream.</p>
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.resource_arn = input;
            self
        }
        /// <p>The ARN of the IAM role that Kinesis Data Analytics assumes to access the stream.</p>
        /// <note>
        /// <p>Provided for backward compatibility. Applications that are created with the current API
        /// version have an application-level service execution role rather than a resource-level
        /// role.</p>
        /// </note>
        pub fn role_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.role_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the IAM role that Kinesis Data Analytics assumes to access the stream.</p>
        /// <note>
        /// <p>Provided for backward compatibility. Applications that are created with the current API
        /// version have an application-level service execution role rather than a resource-level
        /// role.</p>
        /// </note>
        pub fn set_role_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.role_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`KinesisFirehoseInputDescription`](crate::model::KinesisFirehoseInputDescription)
        pub fn build(self) -> crate::model::KinesisFirehoseInputDescription {
            crate::model::KinesisFirehoseInputDescription {
                resource_arn: self.resource_arn,
                role_arn: self.role_arn,
            }
        }
    }
}
impl KinesisFirehoseInputDescription {
    /// Creates a new builder-style object to manufacture [`KinesisFirehoseInputDescription`](crate::model::KinesisFirehoseInputDescription)
    pub fn builder() -> crate::model::kinesis_firehose_input_description::Builder {
        crate::model::kinesis_firehose_input_description::Builder::default()
    }
}

/// <p>For a SQL-based Kinesis Data Analytics application, describes the Kinesis data
/// stream that is configured as the streaming source in the application input configuration. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct KinesisStreamsInputDescription {
    /// <p>The Amazon Resource Name (ARN) of the Kinesis data stream.</p>
    pub resource_arn: std::option::Option<std::string::String>,
    /// <p>The ARN of the IAM role that Kinesis Data Analytics can assume to access the
    /// stream.</p>
    /// <note>
    /// <p>Provided for backward compatibility. Applications that are created with the current API
    /// version have an application-level service execution role rather than a resource-level
    /// role.</p>
    /// </note>
    pub role_arn: std::option::Option<std::string::String>,
}
impl KinesisStreamsInputDescription {
    /// <p>The Amazon Resource Name (ARN) of the Kinesis data stream.</p>
    pub fn resource_arn(&self) -> std::option::Option<&str> {
        self.resource_arn.as_deref()
    }
    /// <p>The ARN of the IAM role that Kinesis Data Analytics can assume to access the
    /// stream.</p>
    /// <note>
    /// <p>Provided for backward compatibility. Applications that are created with the current API
    /// version have an application-level service execution role rather than a resource-level
    /// role.</p>
    /// </note>
    pub fn role_arn(&self) -> std::option::Option<&str> {
        self.role_arn.as_deref()
    }
}
impl std::fmt::Debug for KinesisStreamsInputDescription {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("KinesisStreamsInputDescription");
        formatter.field("resource_arn", &self.resource_arn);
        formatter.field("role_arn", &self.role_arn);
        formatter.finish()
    }
}
/// See [`KinesisStreamsInputDescription`](crate::model::KinesisStreamsInputDescription)
pub mod kinesis_streams_input_description {
    /// A builder for [`KinesisStreamsInputDescription`](crate::model::KinesisStreamsInputDescription)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) resource_arn: std::option::Option<std::string::String>,
        pub(crate) role_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the Kinesis data stream.</p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the Kinesis data stream.</p>
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.resource_arn = input;
            self
        }
        /// <p>The ARN of the IAM role that Kinesis Data Analytics can assume to access the
        /// stream.</p>
        /// <note>
        /// <p>Provided for backward compatibility. Applications that are created with the current API
        /// version have an application-level service execution role rather than a resource-level
        /// role.</p>
        /// </note>
        pub fn role_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.role_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the IAM role that Kinesis Data Analytics can assume to access the
        /// stream.</p>
        /// <note>
        /// <p>Provided for backward compatibility. Applications that are created with the current API
        /// version have an application-level service execution role rather than a resource-level
        /// role.</p>
        /// </note>
        pub fn set_role_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.role_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`KinesisStreamsInputDescription`](crate::model::KinesisStreamsInputDescription)
        pub fn build(self) -> crate::model::KinesisStreamsInputDescription {
            crate::model::KinesisStreamsInputDescription {
                resource_arn: self.resource_arn,
                role_arn: self.role_arn,
            }
        }
    }
}
impl KinesisStreamsInputDescription {
    /// Creates a new builder-style object to manufacture [`KinesisStreamsInputDescription`](crate::model::KinesisStreamsInputDescription)
    pub fn builder() -> crate::model::kinesis_streams_input_description::Builder {
        crate::model::kinesis_streams_input_description::Builder::default()
    }
}

/// <p>For a SQL-based Kinesis Data Analytics application, provides the configuration
/// information about an input processor. Currently, the only input processor available is <a href="https://docs.aws.amazon.com/lambda/">Amazon Lambda</a>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InputProcessingConfigurationDescription {
    /// <p>Provides configuration information about the associated <a>InputLambdaProcessorDescription</a>
    /// </p>
    pub input_lambda_processor_description:
        std::option::Option<crate::model::InputLambdaProcessorDescription>,
}
impl InputProcessingConfigurationDescription {
    /// <p>Provides configuration information about the associated <a>InputLambdaProcessorDescription</a>
    /// </p>
    pub fn input_lambda_processor_description(
        &self,
    ) -> std::option::Option<&crate::model::InputLambdaProcessorDescription> {
        self.input_lambda_processor_description.as_ref()
    }
}
impl std::fmt::Debug for InputProcessingConfigurationDescription {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InputProcessingConfigurationDescription");
        formatter.field(
            "input_lambda_processor_description",
            &self.input_lambda_processor_description,
        );
        formatter.finish()
    }
}
/// See [`InputProcessingConfigurationDescription`](crate::model::InputProcessingConfigurationDescription)
pub mod input_processing_configuration_description {
    /// A builder for [`InputProcessingConfigurationDescription`](crate::model::InputProcessingConfigurationDescription)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) input_lambda_processor_description:
            std::option::Option<crate::model::InputLambdaProcessorDescription>,
    }
    impl Builder {
        /// <p>Provides configuration information about the associated <a>InputLambdaProcessorDescription</a>
        /// </p>
        pub fn input_lambda_processor_description(
            mut self,
            input: crate::model::InputLambdaProcessorDescription,
        ) -> Self {
            self.input_lambda_processor_description = Some(input);
            self
        }
        /// <p>Provides configuration information about the associated <a>InputLambdaProcessorDescription</a>
        /// </p>
        pub fn set_input_lambda_processor_description(
            mut self,
            input: std::option::Option<crate::model::InputLambdaProcessorDescription>,
        ) -> Self {
            self.input_lambda_processor_description = input;
            self
        }
        /// Consumes the builder and constructs a [`InputProcessingConfigurationDescription`](crate::model::InputProcessingConfigurationDescription)
        pub fn build(self) -> crate::model::InputProcessingConfigurationDescription {
            crate::model::InputProcessingConfigurationDescription {
                input_lambda_processor_description: self.input_lambda_processor_description,
            }
        }
    }
}
impl InputProcessingConfigurationDescription {
    /// Creates a new builder-style object to manufacture [`InputProcessingConfigurationDescription`](crate::model::InputProcessingConfigurationDescription)
    pub fn builder() -> crate::model::input_processing_configuration_description::Builder {
        crate::model::input_processing_configuration_description::Builder::default()
    }
}

/// <p>For a SQL-based Kinesis Data Analytics application, an object that contains the
/// Amazon Resource Name (ARN) of the Amazon Lambda function that is used to preprocess records in
/// the stream.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InputLambdaProcessorDescription {
    /// <p>The ARN of the Amazon Lambda function that is used to preprocess the records in the
    /// stream.</p>
    /// <note>
    /// <p>To specify an earlier version of the Lambda function than the latest, include the Lambda function version in the Lambda function ARN. For more information about Lambda ARNs, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html#arn-syntax-lambda">Example ARNs: Amazon Lambda</a>
    /// </p>
    /// </note>
    pub resource_arn: std::option::Option<std::string::String>,
    /// <p>The ARN of the IAM role that is used to access the Amazon Lambda function.</p>
    /// <note>
    /// <p>Provided for backward compatibility. Applications that are created with the current API
    /// version have an application-level service execution role rather than a resource-level
    /// role.</p>
    /// </note>
    pub role_arn: std::option::Option<std::string::String>,
}
impl InputLambdaProcessorDescription {
    /// <p>The ARN of the Amazon Lambda function that is used to preprocess the records in the
    /// stream.</p>
    /// <note>
    /// <p>To specify an earlier version of the Lambda function than the latest, include the Lambda function version in the Lambda function ARN. For more information about Lambda ARNs, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html#arn-syntax-lambda">Example ARNs: Amazon Lambda</a>
    /// </p>
    /// </note>
    pub fn resource_arn(&self) -> std::option::Option<&str> {
        self.resource_arn.as_deref()
    }
    /// <p>The ARN of the IAM role that is used to access the Amazon Lambda function.</p>
    /// <note>
    /// <p>Provided for backward compatibility. Applications that are created with the current API
    /// version have an application-level service execution role rather than a resource-level
    /// role.</p>
    /// </note>
    pub fn role_arn(&self) -> std::option::Option<&str> {
        self.role_arn.as_deref()
    }
}
impl std::fmt::Debug for InputLambdaProcessorDescription {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InputLambdaProcessorDescription");
        formatter.field("resource_arn", &self.resource_arn);
        formatter.field("role_arn", &self.role_arn);
        formatter.finish()
    }
}
/// See [`InputLambdaProcessorDescription`](crate::model::InputLambdaProcessorDescription)
pub mod input_lambda_processor_description {
    /// A builder for [`InputLambdaProcessorDescription`](crate::model::InputLambdaProcessorDescription)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) resource_arn: std::option::Option<std::string::String>,
        pub(crate) role_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ARN of the Amazon Lambda function that is used to preprocess the records in the
        /// stream.</p>
        /// <note>
        /// <p>To specify an earlier version of the Lambda function than the latest, include the Lambda function version in the Lambda function ARN. For more information about Lambda ARNs, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html#arn-syntax-lambda">Example ARNs: Amazon Lambda</a>
        /// </p>
        /// </note>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the Amazon Lambda function that is used to preprocess the records in the
        /// stream.</p>
        /// <note>
        /// <p>To specify an earlier version of the Lambda function than the latest, include the Lambda function version in the Lambda function ARN. For more information about Lambda ARNs, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html#arn-syntax-lambda">Example ARNs: Amazon Lambda</a>
        /// </p>
        /// </note>
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.resource_arn = input;
            self
        }
        /// <p>The ARN of the IAM role that is used to access the Amazon Lambda function.</p>
        /// <note>
        /// <p>Provided for backward compatibility. Applications that are created with the current API
        /// version have an application-level service execution role rather than a resource-level
        /// role.</p>
        /// </note>
        pub fn role_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.role_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the IAM role that is used to access the Amazon Lambda function.</p>
        /// <note>
        /// <p>Provided for backward compatibility. Applications that are created with the current API
        /// version have an application-level service execution role rather than a resource-level
        /// role.</p>
        /// </note>
        pub fn set_role_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.role_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`InputLambdaProcessorDescription`](crate::model::InputLambdaProcessorDescription)
        pub fn build(self) -> crate::model::InputLambdaProcessorDescription {
            crate::model::InputLambdaProcessorDescription {
                resource_arn: self.resource_arn,
                role_arn: self.role_arn,
            }
        }
    }
}
impl InputLambdaProcessorDescription {
    /// Creates a new builder-style object to manufacture [`InputLambdaProcessorDescription`](crate::model::InputLambdaProcessorDescription)
    pub fn builder() -> crate::model::input_lambda_processor_description::Builder {
        crate::model::input_lambda_processor_description::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ApplicationStatus {
    #[allow(missing_docs)] // documentation missing in model
    Autoscaling,
    #[allow(missing_docs)] // documentation missing in model
    Deleting,
    #[allow(missing_docs)] // documentation missing in model
    ForceStopping,
    #[allow(missing_docs)] // documentation missing in model
    Maintenance,
    #[allow(missing_docs)] // documentation missing in model
    Ready,
    #[allow(missing_docs)] // documentation missing in model
    RolledBack,
    #[allow(missing_docs)] // documentation missing in model
    RollingBack,
    #[allow(missing_docs)] // documentation missing in model
    Running,
    #[allow(missing_docs)] // documentation missing in model
    Starting,
    #[allow(missing_docs)] // documentation missing in model
    Stopping,
    #[allow(missing_docs)] // documentation missing in model
    Updating,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for ApplicationStatus {
    fn from(s: &str) -> Self {
        match s {
            "AUTOSCALING" => ApplicationStatus::Autoscaling,
            "DELETING" => ApplicationStatus::Deleting,
            "FORCE_STOPPING" => ApplicationStatus::ForceStopping,
            "MAINTENANCE" => ApplicationStatus::Maintenance,
            "READY" => ApplicationStatus::Ready,
            "ROLLED_BACK" => ApplicationStatus::RolledBack,
            "ROLLING_BACK" => ApplicationStatus::RollingBack,
            "RUNNING" => ApplicationStatus::Running,
            "STARTING" => ApplicationStatus::Starting,
            "STOPPING" => ApplicationStatus::Stopping,
            "UPDATING" => ApplicationStatus::Updating,
            other => ApplicationStatus::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for ApplicationStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ApplicationStatus::from(s))
    }
}
impl ApplicationStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ApplicationStatus::Autoscaling => "AUTOSCALING",
            ApplicationStatus::Deleting => "DELETING",
            ApplicationStatus::ForceStopping => "FORCE_STOPPING",
            ApplicationStatus::Maintenance => "MAINTENANCE",
            ApplicationStatus::Ready => "READY",
            ApplicationStatus::RolledBack => "ROLLED_BACK",
            ApplicationStatus::RollingBack => "ROLLING_BACK",
            ApplicationStatus::Running => "RUNNING",
            ApplicationStatus::Starting => "STARTING",
            ApplicationStatus::Stopping => "STOPPING",
            ApplicationStatus::Updating => "UPDATING",
            ApplicationStatus::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &[
            "AUTOSCALING",
            "DELETING",
            "FORCE_STOPPING",
            "MAINTENANCE",
            "READY",
            "ROLLED_BACK",
            "ROLLING_BACK",
            "RUNNING",
            "STARTING",
            "STOPPING",
            "UPDATING",
        ]
    }
}
impl AsRef<str> for ApplicationStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum RuntimeEnvironment {
    #[allow(missing_docs)] // documentation missing in model
    Flink111,
    #[allow(missing_docs)] // documentation missing in model
    Flink113,
    #[allow(missing_docs)] // documentation missing in model
    Flink16,
    #[allow(missing_docs)] // documentation missing in model
    Flink18,
    #[allow(missing_docs)] // documentation missing in model
    Sql10,
    #[allow(missing_docs)] // documentation missing in model
    ZeppelinFlink10,
    #[allow(missing_docs)] // documentation missing in model
    ZeppelinFlink20,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for RuntimeEnvironment {
    fn from(s: &str) -> Self {
        match s {
            "FLINK-1_11" => RuntimeEnvironment::Flink111,
            "FLINK-1_13" => RuntimeEnvironment::Flink113,
            "FLINK-1_6" => RuntimeEnvironment::Flink16,
            "FLINK-1_8" => RuntimeEnvironment::Flink18,
            "SQL-1_0" => RuntimeEnvironment::Sql10,
            "ZEPPELIN-FLINK-1_0" => RuntimeEnvironment::ZeppelinFlink10,
            "ZEPPELIN-FLINK-2_0" => RuntimeEnvironment::ZeppelinFlink20,
            other => RuntimeEnvironment::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for RuntimeEnvironment {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(RuntimeEnvironment::from(s))
    }
}
impl RuntimeEnvironment {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            RuntimeEnvironment::Flink111 => "FLINK-1_11",
            RuntimeEnvironment::Flink113 => "FLINK-1_13",
            RuntimeEnvironment::Flink16 => "FLINK-1_6",
            RuntimeEnvironment::Flink18 => "FLINK-1_8",
            RuntimeEnvironment::Sql10 => "SQL-1_0",
            RuntimeEnvironment::ZeppelinFlink10 => "ZEPPELIN-FLINK-1_0",
            RuntimeEnvironment::ZeppelinFlink20 => "ZEPPELIN-FLINK-2_0",
            RuntimeEnvironment::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &[
            "FLINK-1_11",
            "FLINK-1_13",
            "FLINK-1_6",
            "FLINK-1_8",
            "SQL-1_0",
            "ZEPPELIN-FLINK-1_0",
            "ZEPPELIN-FLINK-2_0",
        ]
    }
}
impl AsRef<str> for RuntimeEnvironment {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Describes the Amazon CloudWatch logging option updates.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CloudWatchLoggingOptionUpdate {
    /// <p>The ID of the CloudWatch logging option to update</p>
    pub cloud_watch_logging_option_id: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the CloudWatch log to receive application
    /// messages.</p>
    pub log_stream_arn_update: std::option::Option<std::string::String>,
}
impl CloudWatchLoggingOptionUpdate {
    /// <p>The ID of the CloudWatch logging option to update</p>
    pub fn cloud_watch_logging_option_id(&self) -> std::option::Option<&str> {
        self.cloud_watch_logging_option_id.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the CloudWatch log to receive application
    /// messages.</p>
    pub fn log_stream_arn_update(&self) -> std::option::Option<&str> {
        self.log_stream_arn_update.as_deref()
    }
}
impl std::fmt::Debug for CloudWatchLoggingOptionUpdate {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CloudWatchLoggingOptionUpdate");
        formatter.field(
            "cloud_watch_logging_option_id",
            &self.cloud_watch_logging_option_id,
        );
        formatter.field("log_stream_arn_update", &self.log_stream_arn_update);
        formatter.finish()
    }
}
/// See [`CloudWatchLoggingOptionUpdate`](crate::model::CloudWatchLoggingOptionUpdate)
pub mod cloud_watch_logging_option_update {
    /// A builder for [`CloudWatchLoggingOptionUpdate`](crate::model::CloudWatchLoggingOptionUpdate)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) cloud_watch_logging_option_id: std::option::Option<std::string::String>,
        pub(crate) log_stream_arn_update: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the CloudWatch logging option to update</p>
        pub fn cloud_watch_logging_option_id(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.cloud_watch_logging_option_id = Some(input.into());
            self
        }
        /// <p>The ID of the CloudWatch logging option to update</p>
        pub fn set_cloud_watch_logging_option_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.cloud_watch_logging_option_id = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the CloudWatch log to receive application
        /// messages.</p>
        pub fn log_stream_arn_update(mut self, input: impl Into<std::string::String>) -> Self {
            self.log_stream_arn_update = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the CloudWatch log to receive application
        /// messages.</p>
        pub fn set_log_stream_arn_update(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.log_stream_arn_update = input;
            self
        }
        /// Consumes the builder and constructs a [`CloudWatchLoggingOptionUpdate`](crate::model::CloudWatchLoggingOptionUpdate)
        pub fn build(self) -> crate::model::CloudWatchLoggingOptionUpdate {
            crate::model::CloudWatchLoggingOptionUpdate {
                cloud_watch_logging_option_id: self.cloud_watch_logging_option_id,
                log_stream_arn_update: self.log_stream_arn_update,
            }
        }
    }
}
impl CloudWatchLoggingOptionUpdate {
    /// Creates a new builder-style object to manufacture [`CloudWatchLoggingOptionUpdate`](crate::model::CloudWatchLoggingOptionUpdate)
    pub fn builder() -> crate::model::cloud_watch_logging_option_update::Builder {
        crate::model::cloud_watch_logging_option_update::Builder::default()
    }
}

/// <p>Describes the updates to the starting parameters for a Kinesis Data Analytics application.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct RunConfigurationUpdate {
    /// <p>Describes the starting parameters for a Flink-based Kinesis Data Analytics application.</p>
    pub flink_run_configuration: std::option::Option<crate::model::FlinkRunConfiguration>,
    /// <p>Describes updates to the restore behavior of a restarting application.</p>
    pub application_restore_configuration:
        std::option::Option<crate::model::ApplicationRestoreConfiguration>,
}
impl RunConfigurationUpdate {
    /// <p>Describes the starting parameters for a Flink-based Kinesis Data Analytics application.</p>
    pub fn flink_run_configuration(
        &self,
    ) -> std::option::Option<&crate::model::FlinkRunConfiguration> {
        self.flink_run_configuration.as_ref()
    }
    /// <p>Describes updates to the restore behavior of a restarting application.</p>
    pub fn application_restore_configuration(
        &self,
    ) -> std::option::Option<&crate::model::ApplicationRestoreConfiguration> {
        self.application_restore_configuration.as_ref()
    }
}
impl std::fmt::Debug for RunConfigurationUpdate {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("RunConfigurationUpdate");
        formatter.field("flink_run_configuration", &self.flink_run_configuration);
        formatter.field(
            "application_restore_configuration",
            &self.application_restore_configuration,
        );
        formatter.finish()
    }
}
/// See [`RunConfigurationUpdate`](crate::model::RunConfigurationUpdate)
pub mod run_configuration_update {
    /// A builder for [`RunConfigurationUpdate`](crate::model::RunConfigurationUpdate)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) flink_run_configuration:
            std::option::Option<crate::model::FlinkRunConfiguration>,
        pub(crate) application_restore_configuration:
            std::option::Option<crate::model::ApplicationRestoreConfiguration>,
    }
    impl Builder {
        /// <p>Describes the starting parameters for a Flink-based Kinesis Data Analytics application.</p>
        pub fn flink_run_configuration(
            mut self,
            input: crate::model::FlinkRunConfiguration,
        ) -> Self {
            self.flink_run_configuration = Some(input);
            self
        }
        /// <p>Describes the starting parameters for a Flink-based Kinesis Data Analytics application.</p>
        pub fn set_flink_run_configuration(
            mut self,
            input: std::option::Option<crate::model::FlinkRunConfiguration>,
        ) -> Self {
            self.flink_run_configuration = input;
            self
        }
        /// <p>Describes updates to the restore behavior of a restarting application.</p>
        pub fn application_restore_configuration(
            mut self,
            input: crate::model::ApplicationRestoreConfiguration,
        ) -> Self {
            self.application_restore_configuration = Some(input);
            self
        }
        /// <p>Describes updates to the restore behavior of a restarting application.</p>
        pub fn set_application_restore_configuration(
            mut self,
            input: std::option::Option<crate::model::ApplicationRestoreConfiguration>,
        ) -> Self {
            self.application_restore_configuration = input;
            self
        }
        /// Consumes the builder and constructs a [`RunConfigurationUpdate`](crate::model::RunConfigurationUpdate)
        pub fn build(self) -> crate::model::RunConfigurationUpdate {
            crate::model::RunConfigurationUpdate {
                flink_run_configuration: self.flink_run_configuration,
                application_restore_configuration: self.application_restore_configuration,
            }
        }
    }
}
impl RunConfigurationUpdate {
    /// Creates a new builder-style object to manufacture [`RunConfigurationUpdate`](crate::model::RunConfigurationUpdate)
    pub fn builder() -> crate::model::run_configuration_update::Builder {
        crate::model::run_configuration_update::Builder::default()
    }
}

/// <p>Describes updates to an application's configuration.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ApplicationConfigurationUpdate {
    /// <p>Describes updates to a SQL-based Kinesis Data Analytics application's
    /// configuration.</p>
    pub sql_application_configuration_update:
        std::option::Option<crate::model::SqlApplicationConfigurationUpdate>,
    /// <p>Describes updates to an application's code
    /// configuration.</p>
    pub application_code_configuration_update:
        std::option::Option<crate::model::ApplicationCodeConfigurationUpdate>,
    /// <p>Describes updates to a Flink-based Kinesis Data Analytics application's configuration.</p>
    pub flink_application_configuration_update:
        std::option::Option<crate::model::FlinkApplicationConfigurationUpdate>,
    /// <p>Describes updates to the environment properties for a Flink-based Kinesis Data Analytics application.</p>
    pub environment_property_updates: std::option::Option<crate::model::EnvironmentPropertyUpdates>,
    /// <p>Describes whether snapshots are enabled for a Flink-based Kinesis Data Analytics application.</p>
    pub application_snapshot_configuration_update:
        std::option::Option<crate::model::ApplicationSnapshotConfigurationUpdate>,
    /// <p>Updates to the array of descriptions of VPC configurations available to the application.</p>
    pub vpc_configuration_updates:
        std::option::Option<std::vec::Vec<crate::model::VpcConfigurationUpdate>>,
    /// <p>Updates to the configuration of a Kinesis Data Analytics Studio notebook.</p>
    pub zeppelin_application_configuration_update:
        std::option::Option<crate::model::ZeppelinApplicationConfigurationUpdate>,
}
impl ApplicationConfigurationUpdate {
    /// <p>Describes updates to a SQL-based Kinesis Data Analytics application's
    /// configuration.</p>
    pub fn sql_application_configuration_update(
        &self,
    ) -> std::option::Option<&crate::model::SqlApplicationConfigurationUpdate> {
        self.sql_application_configuration_update.as_ref()
    }
    /// <p>Describes updates to an application's code
    /// configuration.</p>
    pub fn application_code_configuration_update(
        &self,
    ) -> std::option::Option<&crate::model::ApplicationCodeConfigurationUpdate> {
        self.application_code_configuration_update.as_ref()
    }
    /// <p>Describes updates to a Flink-based Kinesis Data Analytics application's configuration.</p>
    pub fn flink_application_configuration_update(
        &self,
    ) -> std::option::Option<&crate::model::FlinkApplicationConfigurationUpdate> {
        self.flink_application_configuration_update.as_ref()
    }
    /// <p>Describes updates to the environment properties for a Flink-based Kinesis Data Analytics application.</p>
    pub fn environment_property_updates(
        &self,
    ) -> std::option::Option<&crate::model::EnvironmentPropertyUpdates> {
        self.environment_property_updates.as_ref()
    }
    /// <p>Describes whether snapshots are enabled for a Flink-based Kinesis Data Analytics application.</p>
    pub fn application_snapshot_configuration_update(
        &self,
    ) -> std::option::Option<&crate::model::ApplicationSnapshotConfigurationUpdate> {
        self.application_snapshot_configuration_update.as_ref()
    }
    /// <p>Updates to the array of descriptions of VPC configurations available to the application.</p>
    pub fn vpc_configuration_updates(
        &self,
    ) -> std::option::Option<&[crate::model::VpcConfigurationUpdate]> {
        self.vpc_configuration_updates.as_deref()
    }
    /// <p>Updates to the configuration of a Kinesis Data Analytics Studio notebook.</p>
    pub fn zeppelin_application_configuration_update(
        &self,
    ) -> std::option::Option<&crate::model::ZeppelinApplicationConfigurationUpdate> {
        self.zeppelin_application_configuration_update.as_ref()
    }
}
impl std::fmt::Debug for ApplicationConfigurationUpdate {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ApplicationConfigurationUpdate");
        formatter.field(
            "sql_application_configuration_update",
            &self.sql_application_configuration_update,
        );
        formatter.field(
            "application_code_configuration_update",
            &self.application_code_configuration_update,
        );
        formatter.field(
            "flink_application_configuration_update",
            &self.flink_application_configuration_update,
        );
        formatter.field(
            "environment_property_updates",
            &self.environment_property_updates,
        );
        formatter.field(
            "application_snapshot_configuration_update",
            &self.application_snapshot_configuration_update,
        );
        formatter.field("vpc_configuration_updates", &self.vpc_configuration_updates);
        formatter.field(
            "zeppelin_application_configuration_update",
            &self.zeppelin_application_configuration_update,
        );
        formatter.finish()
    }
}
/// See [`ApplicationConfigurationUpdate`](crate::model::ApplicationConfigurationUpdate)
pub mod application_configuration_update {
    /// A builder for [`ApplicationConfigurationUpdate`](crate::model::ApplicationConfigurationUpdate)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) sql_application_configuration_update:
            std::option::Option<crate::model::SqlApplicationConfigurationUpdate>,
        pub(crate) application_code_configuration_update:
            std::option::Option<crate::model::ApplicationCodeConfigurationUpdate>,
        pub(crate) flink_application_configuration_update:
            std::option::Option<crate::model::FlinkApplicationConfigurationUpdate>,
        pub(crate) environment_property_updates:
            std::option::Option<crate::model::EnvironmentPropertyUpdates>,
        pub(crate) application_snapshot_configuration_update:
            std::option::Option<crate::model::ApplicationSnapshotConfigurationUpdate>,
        pub(crate) vpc_configuration_updates:
            std::option::Option<std::vec::Vec<crate::model::VpcConfigurationUpdate>>,
        pub(crate) zeppelin_application_configuration_update:
            std::option::Option<crate::model::ZeppelinApplicationConfigurationUpdate>,
    }
    impl Builder {
        /// <p>Describes updates to a SQL-based Kinesis Data Analytics application's
        /// configuration.</p>
        pub fn sql_application_configuration_update(
            mut self,
            input: crate::model::SqlApplicationConfigurationUpdate,
        ) -> Self {
            self.sql_application_configuration_update = Some(input);
            self
        }
        /// <p>Describes updates to a SQL-based Kinesis Data Analytics application's
        /// configuration.</p>
        pub fn set_sql_application_configuration_update(
            mut self,
            input: std::option::Option<crate::model::SqlApplicationConfigurationUpdate>,
        ) -> Self {
            self.sql_application_configuration_update = input;
            self
        }
        /// <p>Describes updates to an application's code
        /// configuration.</p>
        pub fn application_code_configuration_update(
            mut self,
            input: crate::model::ApplicationCodeConfigurationUpdate,
        ) -> Self {
            self.application_code_configuration_update = Some(input);
            self
        }
        /// <p>Describes updates to an application's code
        /// configuration.</p>
        pub fn set_application_code_configuration_update(
            mut self,
            input: std::option::Option<crate::model::ApplicationCodeConfigurationUpdate>,
        ) -> Self {
            self.application_code_configuration_update = input;
            self
        }
        /// <p>Describes updates to a Flink-based Kinesis Data Analytics application's configuration.</p>
        pub fn flink_application_configuration_update(
            mut self,
            input: crate::model::FlinkApplicationConfigurationUpdate,
        ) -> Self {
            self.flink_application_configuration_update = Some(input);
            self
        }
        /// <p>Describes updates to a Flink-based Kinesis Data Analytics application's configuration.</p>
        pub fn set_flink_application_configuration_update(
            mut self,
            input: std::option::Option<crate::model::FlinkApplicationConfigurationUpdate>,
        ) -> Self {
            self.flink_application_configuration_update = input;
            self
        }
        /// <p>Describes updates to the environment properties for a Flink-based Kinesis Data Analytics application.</p>
        pub fn environment_property_updates(
            mut self,
            input: crate::model::EnvironmentPropertyUpdates,
        ) -> Self {
            self.environment_property_updates = Some(input);
            self
        }
        /// <p>Describes updates to the environment properties for a Flink-based Kinesis Data Analytics application.</p>
        pub fn set_environment_property_updates(
            mut self,
            input: std::option::Option<crate::model::EnvironmentPropertyUpdates>,
        ) -> Self {
            self.environment_property_updates = input;
            self
        }
        /// <p>Describes whether snapshots are enabled for a Flink-based Kinesis Data Analytics application.</p>
        pub fn application_snapshot_configuration_update(
            mut self,
            input: crate::model::ApplicationSnapshotConfigurationUpdate,
        ) -> Self {
            self.application_snapshot_configuration_update = Some(input);
            self
        }
        /// <p>Describes whether snapshots are enabled for a Flink-based Kinesis Data Analytics application.</p>
        pub fn set_application_snapshot_configuration_update(
            mut self,
            input: std::option::Option<crate::model::ApplicationSnapshotConfigurationUpdate>,
        ) -> Self {
            self.application_snapshot_configuration_update = input;
            self
        }
        /// Appends an item to `vpc_configuration_updates`.
        ///
        /// To override the contents of this collection use [`set_vpc_configuration_updates`](Self::set_vpc_configuration_updates).
        ///
        /// <p>Updates to the array of descriptions of VPC configurations available to the application.</p>
        pub fn vpc_configuration_updates(
            mut self,
            input: impl Into<crate::model::VpcConfigurationUpdate>,
        ) -> Self {
            let mut v = self.vpc_configuration_updates.unwrap_or_default();
            v.push(input.into());
            self.vpc_configuration_updates = Some(v);
            self
        }
        /// <p>Updates to the array of descriptions of VPC configurations available to the application.</p>
        pub fn set_vpc_configuration_updates(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::VpcConfigurationUpdate>>,
        ) -> Self {
            self.vpc_configuration_updates = input;
            self
        }
        /// <p>Updates to the configuration of a Kinesis Data Analytics Studio notebook.</p>
        pub fn zeppelin_application_configuration_update(
            mut self,
            input: crate::model::ZeppelinApplicationConfigurationUpdate,
        ) -> Self {
            self.zeppelin_application_configuration_update = Some(input);
            self
        }
        /// <p>Updates to the configuration of a Kinesis Data Analytics Studio notebook.</p>
        pub fn set_zeppelin_application_configuration_update(
            mut self,
            input: std::option::Option<crate::model::ZeppelinApplicationConfigurationUpdate>,
        ) -> Self {
            self.zeppelin_application_configuration_update = input;
            self
        }
        /// Consumes the builder and constructs a [`ApplicationConfigurationUpdate`](crate::model::ApplicationConfigurationUpdate)
        pub fn build(self) -> crate::model::ApplicationConfigurationUpdate {
            crate::model::ApplicationConfigurationUpdate {
                sql_application_configuration_update: self.sql_application_configuration_update,
                application_code_configuration_update: self.application_code_configuration_update,
                flink_application_configuration_update: self.flink_application_configuration_update,
                environment_property_updates: self.environment_property_updates,
                application_snapshot_configuration_update: self
                    .application_snapshot_configuration_update,
                vpc_configuration_updates: self.vpc_configuration_updates,
                zeppelin_application_configuration_update: self
                    .zeppelin_application_configuration_update,
            }
        }
    }
}
impl ApplicationConfigurationUpdate {
    /// Creates a new builder-style object to manufacture [`ApplicationConfigurationUpdate`](crate::model::ApplicationConfigurationUpdate)
    pub fn builder() -> crate::model::application_configuration_update::Builder {
        crate::model::application_configuration_update::Builder::default()
    }
}

/// <p>Updates to the configuration of Kinesis Data Analytics Studio notebook.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ZeppelinApplicationConfigurationUpdate {
    /// <p>Updates to the monitoring configuration of a Kinesis Data Analytics Studio notebook.</p>
    pub monitoring_configuration_update:
        std::option::Option<crate::model::ZeppelinMonitoringConfigurationUpdate>,
    /// <p>Updates to the configuration of the Amazon Glue Data Catalog that is associated with the Kinesis Data Analytics Studio notebook.</p>
    pub catalog_configuration_update: std::option::Option<crate::model::CatalogConfigurationUpdate>,
    /// <p>Updates to the configuration information required to deploy an Amazon Data Analytics Studio notebook as an application with durable state.</p>
    pub deploy_as_application_configuration_update:
        std::option::Option<crate::model::DeployAsApplicationConfigurationUpdate>,
    /// <p>Updates to the customer artifacts. Custom artifacts are dependency JAR files and user-defined functions (UDF).</p>
    pub custom_artifacts_configuration_update:
        std::option::Option<std::vec::Vec<crate::model::CustomArtifactConfiguration>>,
}
impl ZeppelinApplicationConfigurationUpdate {
    /// <p>Updates to the monitoring configuration of a Kinesis Data Analytics Studio notebook.</p>
    pub fn monitoring_configuration_update(
        &self,
    ) -> std::option::Option<&crate::model::ZeppelinMonitoringConfigurationUpdate> {
        self.monitoring_configuration_update.as_ref()
    }
    /// <p>Updates to the configuration of the Amazon Glue Data Catalog that is associated with the Kinesis Data Analytics Studio notebook.</p>
    pub fn catalog_configuration_update(
        &self,
    ) -> std::option::Option<&crate::model::CatalogConfigurationUpdate> {
        self.catalog_configuration_update.as_ref()
    }
    /// <p>Updates to the configuration information required to deploy an Amazon Data Analytics Studio notebook as an application with durable state.</p>
    pub fn deploy_as_application_configuration_update(
        &self,
    ) -> std::option::Option<&crate::model::DeployAsApplicationConfigurationUpdate> {
        self.deploy_as_application_configuration_update.as_ref()
    }
    /// <p>Updates to the customer artifacts. Custom artifacts are dependency JAR files and user-defined functions (UDF).</p>
    pub fn custom_artifacts_configuration_update(
        &self,
    ) -> std::option::Option<&[crate::model::CustomArtifactConfiguration]> {
        self.custom_artifacts_configuration_update.as_deref()
    }
}
impl std::fmt::Debug for ZeppelinApplicationConfigurationUpdate {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ZeppelinApplicationConfigurationUpdate");
        formatter.field(
            "monitoring_configuration_update",
            &self.monitoring_configuration_update,
        );
        formatter.field(
            "catalog_configuration_update",
            &self.catalog_configuration_update,
        );
        formatter.field(
            "deploy_as_application_configuration_update",
            &self.deploy_as_application_configuration_update,
        );
        formatter.field(
            "custom_artifacts_configuration_update",
            &self.custom_artifacts_configuration_update,
        );
        formatter.finish()
    }
}
/// See [`ZeppelinApplicationConfigurationUpdate`](crate::model::ZeppelinApplicationConfigurationUpdate)
pub mod zeppelin_application_configuration_update {
    /// A builder for [`ZeppelinApplicationConfigurationUpdate`](crate::model::ZeppelinApplicationConfigurationUpdate)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) monitoring_configuration_update:
            std::option::Option<crate::model::ZeppelinMonitoringConfigurationUpdate>,
        pub(crate) catalog_configuration_update:
            std::option::Option<crate::model::CatalogConfigurationUpdate>,
        pub(crate) deploy_as_application_configuration_update:
            std::option::Option<crate::model::DeployAsApplicationConfigurationUpdate>,
        pub(crate) custom_artifacts_configuration_update:
            std::option::Option<std::vec::Vec<crate::model::CustomArtifactConfiguration>>,
    }
    impl Builder {
        /// <p>Updates to the monitoring configuration of a Kinesis Data Analytics Studio notebook.</p>
        pub fn monitoring_configuration_update(
            mut self,
            input: crate::model::ZeppelinMonitoringConfigurationUpdate,
        ) -> Self {
            self.monitoring_configuration_update = Some(input);
            self
        }
        /// <p>Updates to the monitoring configuration of a Kinesis Data Analytics Studio notebook.</p>
        pub fn set_monitoring_configuration_update(
            mut self,
            input: std::option::Option<crate::model::ZeppelinMonitoringConfigurationUpdate>,
        ) -> Self {
            self.monitoring_configuration_update = input;
            self
        }
        /// <p>Updates to the configuration of the Amazon Glue Data Catalog that is associated with the Kinesis Data Analytics Studio notebook.</p>
        pub fn catalog_configuration_update(
            mut self,
            input: crate::model::CatalogConfigurationUpdate,
        ) -> Self {
            self.catalog_configuration_update = Some(input);
            self
        }
        /// <p>Updates to the configuration of the Amazon Glue Data Catalog that is associated with the Kinesis Data Analytics Studio notebook.</p>
        pub fn set_catalog_configuration_update(
            mut self,
            input: std::option::Option<crate::model::CatalogConfigurationUpdate>,
        ) -> Self {
            self.catalog_configuration_update = input;
            self
        }
        /// <p>Updates to the configuration information required to deploy an Amazon Data Analytics Studio notebook as an application with durable state.</p>
        pub fn deploy_as_application_configuration_update(
            mut self,
            input: crate::model::DeployAsApplicationConfigurationUpdate,
        ) -> Self {
            self.deploy_as_application_configuration_update = Some(input);
            self
        }
        /// <p>Updates to the configuration information required to deploy an Amazon Data Analytics Studio notebook as an application with durable state.</p>
        pub fn set_deploy_as_application_configuration_update(
            mut self,
            input: std::option::Option<crate::model::DeployAsApplicationConfigurationUpdate>,
        ) -> Self {
            self.deploy_as_application_configuration_update = input;
            self
        }
        /// Appends an item to `custom_artifacts_configuration_update`.
        ///
        /// To override the contents of this collection use [`set_custom_artifacts_configuration_update`](Self::set_custom_artifacts_configuration_update).
        ///
        /// <p>Updates to the customer artifacts. Custom artifacts are dependency JAR files and user-defined functions (UDF).</p>
        pub fn custom_artifacts_configuration_update(
            mut self,
            input: impl Into<crate::model::CustomArtifactConfiguration>,
        ) -> Self {
            let mut v = self
                .custom_artifacts_configuration_update
                .unwrap_or_default();
            v.push(input.into());
            self.custom_artifacts_configuration_update = Some(v);
            self
        }
        /// <p>Updates to the customer artifacts. Custom artifacts are dependency JAR files and user-defined functions (UDF).</p>
        pub fn set_custom_artifacts_configuration_update(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::CustomArtifactConfiguration>>,
        ) -> Self {
            self.custom_artifacts_configuration_update = input;
            self
        }
        /// Consumes the builder and constructs a [`ZeppelinApplicationConfigurationUpdate`](crate::model::ZeppelinApplicationConfigurationUpdate)
        pub fn build(self) -> crate::model::ZeppelinApplicationConfigurationUpdate {
            crate::model::ZeppelinApplicationConfigurationUpdate {
                monitoring_configuration_update: self.monitoring_configuration_update,
                catalog_configuration_update: self.catalog_configuration_update,
                deploy_as_application_configuration_update: self
                    .deploy_as_application_configuration_update,
                custom_artifacts_configuration_update: self.custom_artifacts_configuration_update,
            }
        }
    }
}
impl ZeppelinApplicationConfigurationUpdate {
    /// Creates a new builder-style object to manufacture [`ZeppelinApplicationConfigurationUpdate`](crate::model::ZeppelinApplicationConfigurationUpdate)
    pub fn builder() -> crate::model::zeppelin_application_configuration_update::Builder {
        crate::model::zeppelin_application_configuration_update::Builder::default()
    }
}

/// <p>Specifies dependency JARs, as well as JAR files that contain user-defined functions (UDF).</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CustomArtifactConfiguration {
    /// <p>
    /// <code>UDF</code> stands for user-defined functions. This type of artifact must be in an S3 bucket. A <code>DEPENDENCY_JAR</code> can be in either Maven or an S3 bucket.</p>
    pub artifact_type: std::option::Option<crate::model::ArtifactType>,
    /// <p>For a Kinesis Data Analytics application provides a
    /// description of an Amazon S3 object, including the Amazon Resource Name (ARN) of the S3 bucket,
    /// the name of the Amazon S3 object that contains the data, and the version number of the Amazon
    /// S3 object that contains the data. </p>
    pub s3_content_location: std::option::Option<crate::model::S3ContentLocation>,
    /// <p>The parameters required to fully specify a Maven reference.</p>
    pub maven_reference: std::option::Option<crate::model::MavenReference>,
}
impl CustomArtifactConfiguration {
    /// <p>
    /// <code>UDF</code> stands for user-defined functions. This type of artifact must be in an S3 bucket. A <code>DEPENDENCY_JAR</code> can be in either Maven or an S3 bucket.</p>
    pub fn artifact_type(&self) -> std::option::Option<&crate::model::ArtifactType> {
        self.artifact_type.as_ref()
    }
    /// <p>For a Kinesis Data Analytics application provides a
    /// description of an Amazon S3 object, including the Amazon Resource Name (ARN) of the S3 bucket,
    /// the name of the Amazon S3 object that contains the data, and the version number of the Amazon
    /// S3 object that contains the data. </p>
    pub fn s3_content_location(&self) -> std::option::Option<&crate::model::S3ContentLocation> {
        self.s3_content_location.as_ref()
    }
    /// <p>The parameters required to fully specify a Maven reference.</p>
    pub fn maven_reference(&self) -> std::option::Option<&crate::model::MavenReference> {
        self.maven_reference.as_ref()
    }
}
impl std::fmt::Debug for CustomArtifactConfiguration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CustomArtifactConfiguration");
        formatter.field("artifact_type", &self.artifact_type);
        formatter.field("s3_content_location", &self.s3_content_location);
        formatter.field("maven_reference", &self.maven_reference);
        formatter.finish()
    }
}
/// See [`CustomArtifactConfiguration`](crate::model::CustomArtifactConfiguration)
pub mod custom_artifact_configuration {
    /// A builder for [`CustomArtifactConfiguration`](crate::model::CustomArtifactConfiguration)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) artifact_type: std::option::Option<crate::model::ArtifactType>,
        pub(crate) s3_content_location: std::option::Option<crate::model::S3ContentLocation>,
        pub(crate) maven_reference: std::option::Option<crate::model::MavenReference>,
    }
    impl Builder {
        /// <p>
        /// <code>UDF</code> stands for user-defined functions. This type of artifact must be in an S3 bucket. A <code>DEPENDENCY_JAR</code> can be in either Maven or an S3 bucket.</p>
        pub fn artifact_type(mut self, input: crate::model::ArtifactType) -> Self {
            self.artifact_type = Some(input);
            self
        }
        /// <p>
        /// <code>UDF</code> stands for user-defined functions. This type of artifact must be in an S3 bucket. A <code>DEPENDENCY_JAR</code> can be in either Maven or an S3 bucket.</p>
        pub fn set_artifact_type(
            mut self,
            input: std::option::Option<crate::model::ArtifactType>,
        ) -> Self {
            self.artifact_type = input;
            self
        }
        /// <p>For a Kinesis Data Analytics application provides a
        /// description of an Amazon S3 object, including the Amazon Resource Name (ARN) of the S3 bucket,
        /// the name of the Amazon S3 object that contains the data, and the version number of the Amazon
        /// S3 object that contains the data. </p>
        pub fn s3_content_location(mut self, input: crate::model::S3ContentLocation) -> Self {
            self.s3_content_location = Some(input);
            self
        }
        /// <p>For a Kinesis Data Analytics application provides a
        /// description of an Amazon S3 object, including the Amazon Resource Name (ARN) of the S3 bucket,
        /// the name of the Amazon S3 object that contains the data, and the version number of the Amazon
        /// S3 object that contains the data. </p>
        pub fn set_s3_content_location(
            mut self,
            input: std::option::Option<crate::model::S3ContentLocation>,
        ) -> Self {
            self.s3_content_location = input;
            self
        }
        /// <p>The parameters required to fully specify a Maven reference.</p>
        pub fn maven_reference(mut self, input: crate::model::MavenReference) -> Self {
            self.maven_reference = Some(input);
            self
        }
        /// <p>The parameters required to fully specify a Maven reference.</p>
        pub fn set_maven_reference(
            mut self,
            input: std::option::Option<crate::model::MavenReference>,
        ) -> Self {
            self.maven_reference = input;
            self
        }
        /// Consumes the builder and constructs a [`CustomArtifactConfiguration`](crate::model::CustomArtifactConfiguration)
        pub fn build(self) -> crate::model::CustomArtifactConfiguration {
            crate::model::CustomArtifactConfiguration {
                artifact_type: self.artifact_type,
                s3_content_location: self.s3_content_location,
                maven_reference: self.maven_reference,
            }
        }
    }
}
impl CustomArtifactConfiguration {
    /// Creates a new builder-style object to manufacture [`CustomArtifactConfiguration`](crate::model::CustomArtifactConfiguration)
    pub fn builder() -> crate::model::custom_artifact_configuration::Builder {
        crate::model::custom_artifact_configuration::Builder::default()
    }
}

/// <p>Updates to the configuration information required to deploy an Amazon Data Analytics Studio notebook as an application with durable state.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeployAsApplicationConfigurationUpdate {
    /// <p>Updates to the location that holds the data required to specify an Amazon Data Analytics application.</p>
    pub s3_content_location_update: std::option::Option<crate::model::S3ContentBaseLocationUpdate>,
}
impl DeployAsApplicationConfigurationUpdate {
    /// <p>Updates to the location that holds the data required to specify an Amazon Data Analytics application.</p>
    pub fn s3_content_location_update(
        &self,
    ) -> std::option::Option<&crate::model::S3ContentBaseLocationUpdate> {
        self.s3_content_location_update.as_ref()
    }
}
impl std::fmt::Debug for DeployAsApplicationConfigurationUpdate {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeployAsApplicationConfigurationUpdate");
        formatter.field(
            "s3_content_location_update",
            &self.s3_content_location_update,
        );
        formatter.finish()
    }
}
/// See [`DeployAsApplicationConfigurationUpdate`](crate::model::DeployAsApplicationConfigurationUpdate)
pub mod deploy_as_application_configuration_update {
    /// A builder for [`DeployAsApplicationConfigurationUpdate`](crate::model::DeployAsApplicationConfigurationUpdate)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) s3_content_location_update:
            std::option::Option<crate::model::S3ContentBaseLocationUpdate>,
    }
    impl Builder {
        /// <p>Updates to the location that holds the data required to specify an Amazon Data Analytics application.</p>
        pub fn s3_content_location_update(
            mut self,
            input: crate::model::S3ContentBaseLocationUpdate,
        ) -> Self {
            self.s3_content_location_update = Some(input);
            self
        }
        /// <p>Updates to the location that holds the data required to specify an Amazon Data Analytics application.</p>
        pub fn set_s3_content_location_update(
            mut self,
            input: std::option::Option<crate::model::S3ContentBaseLocationUpdate>,
        ) -> Self {
            self.s3_content_location_update = input;
            self
        }
        /// Consumes the builder and constructs a [`DeployAsApplicationConfigurationUpdate`](crate::model::DeployAsApplicationConfigurationUpdate)
        pub fn build(self) -> crate::model::DeployAsApplicationConfigurationUpdate {
            crate::model::DeployAsApplicationConfigurationUpdate {
                s3_content_location_update: self.s3_content_location_update,
            }
        }
    }
}
impl DeployAsApplicationConfigurationUpdate {
    /// Creates a new builder-style object to manufacture [`DeployAsApplicationConfigurationUpdate`](crate::model::DeployAsApplicationConfigurationUpdate)
    pub fn builder() -> crate::model::deploy_as_application_configuration_update::Builder {
        crate::model::deploy_as_application_configuration_update::Builder::default()
    }
}

/// <p>The information required to update the S3 base location that holds the application.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct S3ContentBaseLocationUpdate {
    /// <p>The updated Amazon Resource Name (ARN) of the S3 bucket.</p>
    pub bucket_arn_update: std::option::Option<std::string::String>,
    /// <p>The updated S3 bucket path.</p>
    pub base_path_update: std::option::Option<std::string::String>,
}
impl S3ContentBaseLocationUpdate {
    /// <p>The updated Amazon Resource Name (ARN) of the S3 bucket.</p>
    pub fn bucket_arn_update(&self) -> std::option::Option<&str> {
        self.bucket_arn_update.as_deref()
    }
    /// <p>The updated S3 bucket path.</p>
    pub fn base_path_update(&self) -> std::option::Option<&str> {
        self.base_path_update.as_deref()
    }
}
impl std::fmt::Debug for S3ContentBaseLocationUpdate {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("S3ContentBaseLocationUpdate");
        formatter.field("bucket_arn_update", &self.bucket_arn_update);
        formatter.field("base_path_update", &self.base_path_update);
        formatter.finish()
    }
}
/// See [`S3ContentBaseLocationUpdate`](crate::model::S3ContentBaseLocationUpdate)
pub mod s3_content_base_location_update {
    /// A builder for [`S3ContentBaseLocationUpdate`](crate::model::S3ContentBaseLocationUpdate)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) bucket_arn_update: std::option::Option<std::string::String>,
        pub(crate) base_path_update: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The updated Amazon Resource Name (ARN) of the S3 bucket.</p>
        pub fn bucket_arn_update(mut self, input: impl Into<std::string::String>) -> Self {
            self.bucket_arn_update = Some(input.into());
            self
        }
        /// <p>The updated Amazon Resource Name (ARN) of the S3 bucket.</p>
        pub fn set_bucket_arn_update(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.bucket_arn_update = input;
            self
        }
        /// <p>The updated S3 bucket path.</p>
        pub fn base_path_update(mut self, input: impl Into<std::string::String>) -> Self {
            self.base_path_update = Some(input.into());
            self
        }
        /// <p>The updated S3 bucket path.</p>
        pub fn set_base_path_update(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.base_path_update = input;
            self
        }
        /// Consumes the builder and constructs a [`S3ContentBaseLocationUpdate`](crate::model::S3ContentBaseLocationUpdate)
        pub fn build(self) -> crate::model::S3ContentBaseLocationUpdate {
            crate::model::S3ContentBaseLocationUpdate {
                bucket_arn_update: self.bucket_arn_update,
                base_path_update: self.base_path_update,
            }
        }
    }
}
impl S3ContentBaseLocationUpdate {
    /// Creates a new builder-style object to manufacture [`S3ContentBaseLocationUpdate`](crate::model::S3ContentBaseLocationUpdate)
    pub fn builder() -> crate::model::s3_content_base_location_update::Builder {
        crate::model::s3_content_base_location_update::Builder::default()
    }
}

/// <p>Updates to the configuration parameters for the default Amazon Glue database. You use this database for SQL queries that you write in a Kinesis Data Analytics Studio notebook.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CatalogConfigurationUpdate {
    /// <p>Updates to the configuration parameters for the default Amazon Glue database. You use this database for SQL queries that you write in a Kinesis Data Analytics Studio notebook.</p>
    pub glue_data_catalog_configuration_update:
        std::option::Option<crate::model::GlueDataCatalogConfigurationUpdate>,
}
impl CatalogConfigurationUpdate {
    /// <p>Updates to the configuration parameters for the default Amazon Glue database. You use this database for SQL queries that you write in a Kinesis Data Analytics Studio notebook.</p>
    pub fn glue_data_catalog_configuration_update(
        &self,
    ) -> std::option::Option<&crate::model::GlueDataCatalogConfigurationUpdate> {
        self.glue_data_catalog_configuration_update.as_ref()
    }
}
impl std::fmt::Debug for CatalogConfigurationUpdate {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CatalogConfigurationUpdate");
        formatter.field(
            "glue_data_catalog_configuration_update",
            &self.glue_data_catalog_configuration_update,
        );
        formatter.finish()
    }
}
/// See [`CatalogConfigurationUpdate`](crate::model::CatalogConfigurationUpdate)
pub mod catalog_configuration_update {
    /// A builder for [`CatalogConfigurationUpdate`](crate::model::CatalogConfigurationUpdate)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) glue_data_catalog_configuration_update:
            std::option::Option<crate::model::GlueDataCatalogConfigurationUpdate>,
    }
    impl Builder {
        /// <p>Updates to the configuration parameters for the default Amazon Glue database. You use this database for SQL queries that you write in a Kinesis Data Analytics Studio notebook.</p>
        pub fn glue_data_catalog_configuration_update(
            mut self,
            input: crate::model::GlueDataCatalogConfigurationUpdate,
        ) -> Self {
            self.glue_data_catalog_configuration_update = Some(input);
            self
        }
        /// <p>Updates to the configuration parameters for the default Amazon Glue database. You use this database for SQL queries that you write in a Kinesis Data Analytics Studio notebook.</p>
        pub fn set_glue_data_catalog_configuration_update(
            mut self,
            input: std::option::Option<crate::model::GlueDataCatalogConfigurationUpdate>,
        ) -> Self {
            self.glue_data_catalog_configuration_update = input;
            self
        }
        /// Consumes the builder and constructs a [`CatalogConfigurationUpdate`](crate::model::CatalogConfigurationUpdate)
        pub fn build(self) -> crate::model::CatalogConfigurationUpdate {
            crate::model::CatalogConfigurationUpdate {
                glue_data_catalog_configuration_update: self.glue_data_catalog_configuration_update,
            }
        }
    }
}
impl CatalogConfigurationUpdate {
    /// Creates a new builder-style object to manufacture [`CatalogConfigurationUpdate`](crate::model::CatalogConfigurationUpdate)
    pub fn builder() -> crate::model::catalog_configuration_update::Builder {
        crate::model::catalog_configuration_update::Builder::default()
    }
}

/// <p>Updates to the configuration of the Glue Data Catalog that you use for SQL queries that you write in a Kinesis Data Analytics Studio notebook.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GlueDataCatalogConfigurationUpdate {
    /// <p>The updated Amazon Resource Name (ARN) of the database.</p>
    pub database_arn_update: std::option::Option<std::string::String>,
}
impl GlueDataCatalogConfigurationUpdate {
    /// <p>The updated Amazon Resource Name (ARN) of the database.</p>
    pub fn database_arn_update(&self) -> std::option::Option<&str> {
        self.database_arn_update.as_deref()
    }
}
impl std::fmt::Debug for GlueDataCatalogConfigurationUpdate {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GlueDataCatalogConfigurationUpdate");
        formatter.field("database_arn_update", &self.database_arn_update);
        formatter.finish()
    }
}
/// See [`GlueDataCatalogConfigurationUpdate`](crate::model::GlueDataCatalogConfigurationUpdate)
pub mod glue_data_catalog_configuration_update {
    /// A builder for [`GlueDataCatalogConfigurationUpdate`](crate::model::GlueDataCatalogConfigurationUpdate)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) database_arn_update: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The updated Amazon Resource Name (ARN) of the database.</p>
        pub fn database_arn_update(mut self, input: impl Into<std::string::String>) -> Self {
            self.database_arn_update = Some(input.into());
            self
        }
        /// <p>The updated Amazon Resource Name (ARN) of the database.</p>
        pub fn set_database_arn_update(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.database_arn_update = input;
            self
        }
        /// Consumes the builder and constructs a [`GlueDataCatalogConfigurationUpdate`](crate::model::GlueDataCatalogConfigurationUpdate)
        pub fn build(self) -> crate::model::GlueDataCatalogConfigurationUpdate {
            crate::model::GlueDataCatalogConfigurationUpdate {
                database_arn_update: self.database_arn_update,
            }
        }
    }
}
impl GlueDataCatalogConfigurationUpdate {
    /// Creates a new builder-style object to manufacture [`GlueDataCatalogConfigurationUpdate`](crate::model::GlueDataCatalogConfigurationUpdate)
    pub fn builder() -> crate::model::glue_data_catalog_configuration_update::Builder {
        crate::model::glue_data_catalog_configuration_update::Builder::default()
    }
}

/// <p>Updates to the monitoring configuration for Apache Zeppelin within a Kinesis Data Analytics Studio notebook.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ZeppelinMonitoringConfigurationUpdate {
    /// <p>Updates to the logging level for Apache Zeppelin within a Kinesis Data Analytics Studio notebook.</p>
    pub log_level_update: std::option::Option<crate::model::LogLevel>,
}
impl ZeppelinMonitoringConfigurationUpdate {
    /// <p>Updates to the logging level for Apache Zeppelin within a Kinesis Data Analytics Studio notebook.</p>
    pub fn log_level_update(&self) -> std::option::Option<&crate::model::LogLevel> {
        self.log_level_update.as_ref()
    }
}
impl std::fmt::Debug for ZeppelinMonitoringConfigurationUpdate {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ZeppelinMonitoringConfigurationUpdate");
        formatter.field("log_level_update", &self.log_level_update);
        formatter.finish()
    }
}
/// See [`ZeppelinMonitoringConfigurationUpdate`](crate::model::ZeppelinMonitoringConfigurationUpdate)
pub mod zeppelin_monitoring_configuration_update {
    /// A builder for [`ZeppelinMonitoringConfigurationUpdate`](crate::model::ZeppelinMonitoringConfigurationUpdate)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) log_level_update: std::option::Option<crate::model::LogLevel>,
    }
    impl Builder {
        /// <p>Updates to the logging level for Apache Zeppelin within a Kinesis Data Analytics Studio notebook.</p>
        pub fn log_level_update(mut self, input: crate::model::LogLevel) -> Self {
            self.log_level_update = Some(input);
            self
        }
        /// <p>Updates to the logging level for Apache Zeppelin within a Kinesis Data Analytics Studio notebook.</p>
        pub fn set_log_level_update(
            mut self,
            input: std::option::Option<crate::model::LogLevel>,
        ) -> Self {
            self.log_level_update = input;
            self
        }
        /// Consumes the builder and constructs a [`ZeppelinMonitoringConfigurationUpdate`](crate::model::ZeppelinMonitoringConfigurationUpdate)
        pub fn build(self) -> crate::model::ZeppelinMonitoringConfigurationUpdate {
            crate::model::ZeppelinMonitoringConfigurationUpdate {
                log_level_update: self.log_level_update,
            }
        }
    }
}
impl ZeppelinMonitoringConfigurationUpdate {
    /// Creates a new builder-style object to manufacture [`ZeppelinMonitoringConfigurationUpdate`](crate::model::ZeppelinMonitoringConfigurationUpdate)
    pub fn builder() -> crate::model::zeppelin_monitoring_configuration_update::Builder {
        crate::model::zeppelin_monitoring_configuration_update::Builder::default()
    }
}

/// <p>Describes updates to the VPC configuration used by the application.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct VpcConfigurationUpdate {
    /// <p>Describes an update to the ID of the VPC configuration.</p>
    pub vpc_configuration_id: std::option::Option<std::string::String>,
    /// <p>Describes updates to the array of <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_Subnet.html">Subnet</a>
    /// IDs
    /// used by the VPC configuration.</p>
    pub subnet_id_updates: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>Describes updates to the array of
    /// <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_SecurityGroup.html">SecurityGroup</a> IDs used by the VPC configuration.</p>
    pub security_group_id_updates: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl VpcConfigurationUpdate {
    /// <p>Describes an update to the ID of the VPC configuration.</p>
    pub fn vpc_configuration_id(&self) -> std::option::Option<&str> {
        self.vpc_configuration_id.as_deref()
    }
    /// <p>Describes updates to the array of <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_Subnet.html">Subnet</a>
    /// IDs
    /// used by the VPC configuration.</p>
    pub fn subnet_id_updates(&self) -> std::option::Option<&[std::string::String]> {
        self.subnet_id_updates.as_deref()
    }
    /// <p>Describes updates to the array of
    /// <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_SecurityGroup.html">SecurityGroup</a> IDs used by the VPC configuration.</p>
    pub fn security_group_id_updates(&self) -> std::option::Option<&[std::string::String]> {
        self.security_group_id_updates.as_deref()
    }
}
impl std::fmt::Debug for VpcConfigurationUpdate {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("VpcConfigurationUpdate");
        formatter.field("vpc_configuration_id", &self.vpc_configuration_id);
        formatter.field("subnet_id_updates", &self.subnet_id_updates);
        formatter.field("security_group_id_updates", &self.security_group_id_updates);
        formatter.finish()
    }
}
/// See [`VpcConfigurationUpdate`](crate::model::VpcConfigurationUpdate)
pub mod vpc_configuration_update {
    /// A builder for [`VpcConfigurationUpdate`](crate::model::VpcConfigurationUpdate)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) vpc_configuration_id: std::option::Option<std::string::String>,
        pub(crate) subnet_id_updates: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) security_group_id_updates:
            std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// <p>Describes an update to the ID of the VPC configuration.</p>
        pub fn vpc_configuration_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.vpc_configuration_id = Some(input.into());
            self
        }
        /// <p>Describes an update to the ID of the VPC configuration.</p>
        pub fn set_vpc_configuration_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.vpc_configuration_id = input;
            self
        }
        /// Appends an item to `subnet_id_updates`.
        ///
        /// To override the contents of this collection use [`set_subnet_id_updates`](Self::set_subnet_id_updates).
        ///
        /// <p>Describes updates to the array of <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_Subnet.html">Subnet</a>
        /// IDs
        /// used by the VPC configuration.</p>
        pub fn subnet_id_updates(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.subnet_id_updates.unwrap_or_default();
            v.push(input.into());
            self.subnet_id_updates = Some(v);
            self
        }
        /// <p>Describes updates to the array of <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_Subnet.html">Subnet</a>
        /// IDs
        /// used by the VPC configuration.</p>
        pub fn set_subnet_id_updates(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.subnet_id_updates = input;
            self
        }
        /// Appends an item to `security_group_id_updates`.
        ///
        /// To override the contents of this collection use [`set_security_group_id_updates`](Self::set_security_group_id_updates).
        ///
        /// <p>Describes updates to the array of
        /// <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_SecurityGroup.html">SecurityGroup</a> IDs used by the VPC configuration.</p>
        pub fn security_group_id_updates(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.security_group_id_updates.unwrap_or_default();
            v.push(input.into());
            self.security_group_id_updates = Some(v);
            self
        }
        /// <p>Describes updates to the array of
        /// <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_SecurityGroup.html">SecurityGroup</a> IDs used by the VPC configuration.</p>
        pub fn set_security_group_id_updates(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.security_group_id_updates = input;
            self
        }
        /// Consumes the builder and constructs a [`VpcConfigurationUpdate`](crate::model::VpcConfigurationUpdate)
        pub fn build(self) -> crate::model::VpcConfigurationUpdate {
            crate::model::VpcConfigurationUpdate {
                vpc_configuration_id: self.vpc_configuration_id,
                subnet_id_updates: self.subnet_id_updates,
                security_group_id_updates: self.security_group_id_updates,
            }
        }
    }
}
impl VpcConfigurationUpdate {
    /// Creates a new builder-style object to manufacture [`VpcConfigurationUpdate`](crate::model::VpcConfigurationUpdate)
    pub fn builder() -> crate::model::vpc_configuration_update::Builder {
        crate::model::vpc_configuration_update::Builder::default()
    }
}

/// <p>Describes updates to whether snapshots are enabled for a Flink-based Kinesis Data Analytics application.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ApplicationSnapshotConfigurationUpdate {
    /// <p>Describes updates to whether snapshots are enabled for an application.</p>
    pub snapshots_enabled_update: std::option::Option<bool>,
}
impl ApplicationSnapshotConfigurationUpdate {
    /// <p>Describes updates to whether snapshots are enabled for an application.</p>
    pub fn snapshots_enabled_update(&self) -> std::option::Option<bool> {
        self.snapshots_enabled_update
    }
}
impl std::fmt::Debug for ApplicationSnapshotConfigurationUpdate {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ApplicationSnapshotConfigurationUpdate");
        formatter.field("snapshots_enabled_update", &self.snapshots_enabled_update);
        formatter.finish()
    }
}
/// See [`ApplicationSnapshotConfigurationUpdate`](crate::model::ApplicationSnapshotConfigurationUpdate)
pub mod application_snapshot_configuration_update {
    /// A builder for [`ApplicationSnapshotConfigurationUpdate`](crate::model::ApplicationSnapshotConfigurationUpdate)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) snapshots_enabled_update: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>Describes updates to whether snapshots are enabled for an application.</p>
        pub fn snapshots_enabled_update(mut self, input: bool) -> Self {
            self.snapshots_enabled_update = Some(input);
            self
        }
        /// <p>Describes updates to whether snapshots are enabled for an application.</p>
        pub fn set_snapshots_enabled_update(mut self, input: std::option::Option<bool>) -> Self {
            self.snapshots_enabled_update = input;
            self
        }
        /// Consumes the builder and constructs a [`ApplicationSnapshotConfigurationUpdate`](crate::model::ApplicationSnapshotConfigurationUpdate)
        pub fn build(self) -> crate::model::ApplicationSnapshotConfigurationUpdate {
            crate::model::ApplicationSnapshotConfigurationUpdate {
                snapshots_enabled_update: self.snapshots_enabled_update,
            }
        }
    }
}
impl ApplicationSnapshotConfigurationUpdate {
    /// Creates a new builder-style object to manufacture [`ApplicationSnapshotConfigurationUpdate`](crate::model::ApplicationSnapshotConfigurationUpdate)
    pub fn builder() -> crate::model::application_snapshot_configuration_update::Builder {
        crate::model::application_snapshot_configuration_update::Builder::default()
    }
}

/// <p>Describes updates to the execution property groups for a Flink-based Kinesis Data Analytics application or a Studio notebook.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct EnvironmentPropertyUpdates {
    /// <p>Describes updates to the execution property groups.</p>
    pub property_groups: std::option::Option<std::vec::Vec<crate::model::PropertyGroup>>,
}
impl EnvironmentPropertyUpdates {
    /// <p>Describes updates to the execution property groups.</p>
    pub fn property_groups(&self) -> std::option::Option<&[crate::model::PropertyGroup]> {
        self.property_groups.as_deref()
    }
}
impl std::fmt::Debug for EnvironmentPropertyUpdates {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("EnvironmentPropertyUpdates");
        formatter.field("property_groups", &self.property_groups);
        formatter.finish()
    }
}
/// See [`EnvironmentPropertyUpdates`](crate::model::EnvironmentPropertyUpdates)
pub mod environment_property_updates {
    /// A builder for [`EnvironmentPropertyUpdates`](crate::model::EnvironmentPropertyUpdates)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) property_groups: std::option::Option<std::vec::Vec<crate::model::PropertyGroup>>,
    }
    impl Builder {
        /// Appends an item to `property_groups`.
        ///
        /// To override the contents of this collection use [`set_property_groups`](Self::set_property_groups).
        ///
        /// <p>Describes updates to the execution property groups.</p>
        pub fn property_groups(mut self, input: impl Into<crate::model::PropertyGroup>) -> Self {
            let mut v = self.property_groups.unwrap_or_default();
            v.push(input.into());
            self.property_groups = Some(v);
            self
        }
        /// <p>Describes updates to the execution property groups.</p>
        pub fn set_property_groups(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::PropertyGroup>>,
        ) -> Self {
            self.property_groups = input;
            self
        }
        /// Consumes the builder and constructs a [`EnvironmentPropertyUpdates`](crate::model::EnvironmentPropertyUpdates)
        pub fn build(self) -> crate::model::EnvironmentPropertyUpdates {
            crate::model::EnvironmentPropertyUpdates {
                property_groups: self.property_groups,
            }
        }
    }
}
impl EnvironmentPropertyUpdates {
    /// Creates a new builder-style object to manufacture [`EnvironmentPropertyUpdates`](crate::model::EnvironmentPropertyUpdates)
    pub fn builder() -> crate::model::environment_property_updates::Builder {
        crate::model::environment_property_updates::Builder::default()
    }
}

/// <p>Describes updates to the configuration parameters for a Flink-based Kinesis Data Analytics application.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct FlinkApplicationConfigurationUpdate {
    /// <p>Describes updates to an application's checkpointing configuration. Checkpointing is the process of persisting
    /// application state for fault tolerance.</p>
    pub checkpoint_configuration_update:
        std::option::Option<crate::model::CheckpointConfigurationUpdate>,
    /// <p>Describes updates to the configuration parameters for Amazon CloudWatch logging for an
    /// application.</p>
    pub monitoring_configuration_update:
        std::option::Option<crate::model::MonitoringConfigurationUpdate>,
    /// <p>Describes updates to the parameters for how an application executes multiple tasks simultaneously.</p>
    pub parallelism_configuration_update:
        std::option::Option<crate::model::ParallelismConfigurationUpdate>,
}
impl FlinkApplicationConfigurationUpdate {
    /// <p>Describes updates to an application's checkpointing configuration. Checkpointing is the process of persisting
    /// application state for fault tolerance.</p>
    pub fn checkpoint_configuration_update(
        &self,
    ) -> std::option::Option<&crate::model::CheckpointConfigurationUpdate> {
        self.checkpoint_configuration_update.as_ref()
    }
    /// <p>Describes updates to the configuration parameters for Amazon CloudWatch logging for an
    /// application.</p>
    pub fn monitoring_configuration_update(
        &self,
    ) -> std::option::Option<&crate::model::MonitoringConfigurationUpdate> {
        self.monitoring_configuration_update.as_ref()
    }
    /// <p>Describes updates to the parameters for how an application executes multiple tasks simultaneously.</p>
    pub fn parallelism_configuration_update(
        &self,
    ) -> std::option::Option<&crate::model::ParallelismConfigurationUpdate> {
        self.parallelism_configuration_update.as_ref()
    }
}
impl std::fmt::Debug for FlinkApplicationConfigurationUpdate {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("FlinkApplicationConfigurationUpdate");
        formatter.field(
            "checkpoint_configuration_update",
            &self.checkpoint_configuration_update,
        );
        formatter.field(
            "monitoring_configuration_update",
            &self.monitoring_configuration_update,
        );
        formatter.field(
            "parallelism_configuration_update",
            &self.parallelism_configuration_update,
        );
        formatter.finish()
    }
}
/// See [`FlinkApplicationConfigurationUpdate`](crate::model::FlinkApplicationConfigurationUpdate)
pub mod flink_application_configuration_update {
    /// A builder for [`FlinkApplicationConfigurationUpdate`](crate::model::FlinkApplicationConfigurationUpdate)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) checkpoint_configuration_update:
            std::option::Option<crate::model::CheckpointConfigurationUpdate>,
        pub(crate) monitoring_configuration_update:
            std::option::Option<crate::model::MonitoringConfigurationUpdate>,
        pub(crate) parallelism_configuration_update:
            std::option::Option<crate::model::ParallelismConfigurationUpdate>,
    }
    impl Builder {
        /// <p>Describes updates to an application's checkpointing configuration. Checkpointing is the process of persisting
        /// application state for fault tolerance.</p>
        pub fn checkpoint_configuration_update(
            mut self,
            input: crate::model::CheckpointConfigurationUpdate,
        ) -> Self {
            self.checkpoint_configuration_update = Some(input);
            self
        }
        /// <p>Describes updates to an application's checkpointing configuration. Checkpointing is the process of persisting
        /// application state for fault tolerance.</p>
        pub fn set_checkpoint_configuration_update(
            mut self,
            input: std::option::Option<crate::model::CheckpointConfigurationUpdate>,
        ) -> Self {
            self.checkpoint_configuration_update = input;
            self
        }
        /// <p>Describes updates to the configuration parameters for Amazon CloudWatch logging for an
        /// application.</p>
        pub fn monitoring_configuration_update(
            mut self,
            input: crate::model::MonitoringConfigurationUpdate,
        ) -> Self {
            self.monitoring_configuration_update = Some(input);
            self
        }
        /// <p>Describes updates to the configuration parameters for Amazon CloudWatch logging for an
        /// application.</p>
        pub fn set_monitoring_configuration_update(
            mut self,
            input: std::option::Option<crate::model::MonitoringConfigurationUpdate>,
        ) -> Self {
            self.monitoring_configuration_update = input;
            self
        }
        /// <p>Describes updates to the parameters for how an application executes multiple tasks simultaneously.</p>
        pub fn parallelism_configuration_update(
            mut self,
            input: crate::model::ParallelismConfigurationUpdate,
        ) -> Self {
            self.parallelism_configuration_update = Some(input);
            self
        }
        /// <p>Describes updates to the parameters for how an application executes multiple tasks simultaneously.</p>
        pub fn set_parallelism_configuration_update(
            mut self,
            input: std::option::Option<crate::model::ParallelismConfigurationUpdate>,
        ) -> Self {
            self.parallelism_configuration_update = input;
            self
        }
        /// Consumes the builder and constructs a [`FlinkApplicationConfigurationUpdate`](crate::model::FlinkApplicationConfigurationUpdate)
        pub fn build(self) -> crate::model::FlinkApplicationConfigurationUpdate {
            crate::model::FlinkApplicationConfigurationUpdate {
                checkpoint_configuration_update: self.checkpoint_configuration_update,
                monitoring_configuration_update: self.monitoring_configuration_update,
                parallelism_configuration_update: self.parallelism_configuration_update,
            }
        }
    }
}
impl FlinkApplicationConfigurationUpdate {
    /// Creates a new builder-style object to manufacture [`FlinkApplicationConfigurationUpdate`](crate::model::FlinkApplicationConfigurationUpdate)
    pub fn builder() -> crate::model::flink_application_configuration_update::Builder {
        crate::model::flink_application_configuration_update::Builder::default()
    }
}

/// <p>Describes updates to parameters for how an application executes multiple tasks simultaneously.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ParallelismConfigurationUpdate {
    /// <p>Describes updates to whether the application uses the default parallelism for the Kinesis Data Analytics service, or if a custom parallelism is used.
    /// You must set this property to <code>CUSTOM</code>
    /// in order to change your application's <code>AutoScalingEnabled</code>, <code>Parallelism</code>, or <code>ParallelismPerKPU</code> properties.</p>
    pub configuration_type_update: std::option::Option<crate::model::ConfigurationType>,
    /// <p>Describes updates to the initial number of parallel tasks an application can perform. If <code>AutoScalingEnabled</code> is set to True, then
    /// Kinesis Data Analytics can increase the <code>CurrentParallelism</code> value in response to application
    /// load. The service can increase <code>CurrentParallelism</code> up to the maximum parallelism, which is <code>ParalellismPerKPU</code> times the maximum KPUs for the application.
    /// The maximum KPUs for an application is 32 by default, and can be increased by requesting a limit increase. If application load is reduced, the service will
    /// reduce <code>CurrentParallelism</code> down to the <code>Parallelism</code> setting.</p>
    pub parallelism_update: std::option::Option<i32>,
    /// <p>Describes updates to the number of parallel tasks an application can perform per Kinesis Processing Unit (KPU) used by the application.</p>
    pub parallelism_per_kpu_update: std::option::Option<i32>,
    /// <p>Describes updates to whether the Kinesis Data Analytics service can increase the parallelism of a Flink-based Kinesis Data Analytics application in response to increased throughput.</p>
    pub auto_scaling_enabled_update: std::option::Option<bool>,
}
impl ParallelismConfigurationUpdate {
    /// <p>Describes updates to whether the application uses the default parallelism for the Kinesis Data Analytics service, or if a custom parallelism is used.
    /// You must set this property to <code>CUSTOM</code>
    /// in order to change your application's <code>AutoScalingEnabled</code>, <code>Parallelism</code>, or <code>ParallelismPerKPU</code> properties.</p>
    pub fn configuration_type_update(
        &self,
    ) -> std::option::Option<&crate::model::ConfigurationType> {
        self.configuration_type_update.as_ref()
    }
    /// <p>Describes updates to the initial number of parallel tasks an application can perform. If <code>AutoScalingEnabled</code> is set to True, then
    /// Kinesis Data Analytics can increase the <code>CurrentParallelism</code> value in response to application
    /// load. The service can increase <code>CurrentParallelism</code> up to the maximum parallelism, which is <code>ParalellismPerKPU</code> times the maximum KPUs for the application.
    /// The maximum KPUs for an application is 32 by default, and can be increased by requesting a limit increase. If application load is reduced, the service will
    /// reduce <code>CurrentParallelism</code> down to the <code>Parallelism</code> setting.</p>
    pub fn parallelism_update(&self) -> std::option::Option<i32> {
        self.parallelism_update
    }
    /// <p>Describes updates to the number of parallel tasks an application can perform per Kinesis Processing Unit (KPU) used by the application.</p>
    pub fn parallelism_per_kpu_update(&self) -> std::option::Option<i32> {
        self.parallelism_per_kpu_update
    }
    /// <p>Describes updates to whether the Kinesis Data Analytics service can increase the parallelism of a Flink-based Kinesis Data Analytics application in response to increased throughput.</p>
    pub fn auto_scaling_enabled_update(&self) -> std::option::Option<bool> {
        self.auto_scaling_enabled_update
    }
}
impl std::fmt::Debug for ParallelismConfigurationUpdate {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ParallelismConfigurationUpdate");
        formatter.field("configuration_type_update", &self.configuration_type_update);
        formatter.field("parallelism_update", &self.parallelism_update);
        formatter.field(
            "parallelism_per_kpu_update",
            &self.parallelism_per_kpu_update,
        );
        formatter.field(
            "auto_scaling_enabled_update",
            &self.auto_scaling_enabled_update,
        );
        formatter.finish()
    }
}
/// See [`ParallelismConfigurationUpdate`](crate::model::ParallelismConfigurationUpdate)
pub mod parallelism_configuration_update {
    /// A builder for [`ParallelismConfigurationUpdate`](crate::model::ParallelismConfigurationUpdate)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) configuration_type_update: std::option::Option<crate::model::ConfigurationType>,
        pub(crate) parallelism_update: std::option::Option<i32>,
        pub(crate) parallelism_per_kpu_update: std::option::Option<i32>,
        pub(crate) auto_scaling_enabled_update: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>Describes updates to whether the application uses the default parallelism for the Kinesis Data Analytics service, or if a custom parallelism is used.
        /// You must set this property to <code>CUSTOM</code>
        /// in order to change your application's <code>AutoScalingEnabled</code>, <code>Parallelism</code>, or <code>ParallelismPerKPU</code> properties.</p>
        pub fn configuration_type_update(mut self, input: crate::model::ConfigurationType) -> Self {
            self.configuration_type_update = Some(input);
            self
        }
        /// <p>Describes updates to whether the application uses the default parallelism for the Kinesis Data Analytics service, or if a custom parallelism is used.
        /// You must set this property to <code>CUSTOM</code>
        /// in order to change your application's <code>AutoScalingEnabled</code>, <code>Parallelism</code>, or <code>ParallelismPerKPU</code> properties.</p>
        pub fn set_configuration_type_update(
            mut self,
            input: std::option::Option<crate::model::ConfigurationType>,
        ) -> Self {
            self.configuration_type_update = input;
            self
        }
        /// <p>Describes updates to the initial number of parallel tasks an application can perform. If <code>AutoScalingEnabled</code> is set to True, then
        /// Kinesis Data Analytics can increase the <code>CurrentParallelism</code> value in response to application
        /// load. The service can increase <code>CurrentParallelism</code> up to the maximum parallelism, which is <code>ParalellismPerKPU</code> times the maximum KPUs for the application.
        /// The maximum KPUs for an application is 32 by default, and can be increased by requesting a limit increase. If application load is reduced, the service will
        /// reduce <code>CurrentParallelism</code> down to the <code>Parallelism</code> setting.</p>
        pub fn parallelism_update(mut self, input: i32) -> Self {
            self.parallelism_update = Some(input);
            self
        }
        /// <p>Describes updates to the initial number of parallel tasks an application can perform. If <code>AutoScalingEnabled</code> is set to True, then
        /// Kinesis Data Analytics can increase the <code>CurrentParallelism</code> value in response to application
        /// load. The service can increase <code>CurrentParallelism</code> up to the maximum parallelism, which is <code>ParalellismPerKPU</code> times the maximum KPUs for the application.
        /// The maximum KPUs for an application is 32 by default, and can be increased by requesting a limit increase. If application load is reduced, the service will
        /// reduce <code>CurrentParallelism</code> down to the <code>Parallelism</code> setting.</p>
        pub fn set_parallelism_update(mut self, input: std::option::Option<i32>) -> Self {
            self.parallelism_update = input;
            self
        }
        /// <p>Describes updates to the number of parallel tasks an application can perform per Kinesis Processing Unit (KPU) used by the application.</p>
        pub fn parallelism_per_kpu_update(mut self, input: i32) -> Self {
            self.parallelism_per_kpu_update = Some(input);
            self
        }
        /// <p>Describes updates to the number of parallel tasks an application can perform per Kinesis Processing Unit (KPU) used by the application.</p>
        pub fn set_parallelism_per_kpu_update(mut self, input: std::option::Option<i32>) -> Self {
            self.parallelism_per_kpu_update = input;
            self
        }
        /// <p>Describes updates to whether the Kinesis Data Analytics service can increase the parallelism of a Flink-based Kinesis Data Analytics application in response to increased throughput.</p>
        pub fn auto_scaling_enabled_update(mut self, input: bool) -> Self {
            self.auto_scaling_enabled_update = Some(input);
            self
        }
        /// <p>Describes updates to whether the Kinesis Data Analytics service can increase the parallelism of a Flink-based Kinesis Data Analytics application in response to increased throughput.</p>
        pub fn set_auto_scaling_enabled_update(mut self, input: std::option::Option<bool>) -> Self {
            self.auto_scaling_enabled_update = input;
            self
        }
        /// Consumes the builder and constructs a [`ParallelismConfigurationUpdate`](crate::model::ParallelismConfigurationUpdate)
        pub fn build(self) -> crate::model::ParallelismConfigurationUpdate {
            crate::model::ParallelismConfigurationUpdate {
                configuration_type_update: self.configuration_type_update,
                parallelism_update: self.parallelism_update,
                parallelism_per_kpu_update: self.parallelism_per_kpu_update,
                auto_scaling_enabled_update: self.auto_scaling_enabled_update,
            }
        }
    }
}
impl ParallelismConfigurationUpdate {
    /// Creates a new builder-style object to manufacture [`ParallelismConfigurationUpdate`](crate::model::ParallelismConfigurationUpdate)
    pub fn builder() -> crate::model::parallelism_configuration_update::Builder {
        crate::model::parallelism_configuration_update::Builder::default()
    }
}

/// <p>Describes updates to configuration parameters for Amazon CloudWatch logging for an application.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct MonitoringConfigurationUpdate {
    /// <p>Describes updates to whether to use the default CloudWatch logging configuration for
    /// an application. You must set this property to <code>CUSTOM</code> in order to set the <code>LogLevel</code> or
    /// <code>MetricsLevel</code> parameters.</p>
    pub configuration_type_update: std::option::Option<crate::model::ConfigurationType>,
    /// <p>Describes updates to the granularity of the CloudWatch Logs for an application. The <code>Parallelism</code>
    /// level is not recommended for applications with a Parallelism over 64 due to excessive costs.</p>
    pub metrics_level_update: std::option::Option<crate::model::MetricsLevel>,
    /// <p>Describes updates to the verbosity of the CloudWatch Logs for an application.</p>
    pub log_level_update: std::option::Option<crate::model::LogLevel>,
}
impl MonitoringConfigurationUpdate {
    /// <p>Describes updates to whether to use the default CloudWatch logging configuration for
    /// an application. You must set this property to <code>CUSTOM</code> in order to set the <code>LogLevel</code> or
    /// <code>MetricsLevel</code> parameters.</p>
    pub fn configuration_type_update(
        &self,
    ) -> std::option::Option<&crate::model::ConfigurationType> {
        self.configuration_type_update.as_ref()
    }
    /// <p>Describes updates to the granularity of the CloudWatch Logs for an application. The <code>Parallelism</code>
    /// level is not recommended for applications with a Parallelism over 64 due to excessive costs.</p>
    pub fn metrics_level_update(&self) -> std::option::Option<&crate::model::MetricsLevel> {
        self.metrics_level_update.as_ref()
    }
    /// <p>Describes updates to the verbosity of the CloudWatch Logs for an application.</p>
    pub fn log_level_update(&self) -> std::option::Option<&crate::model::LogLevel> {
        self.log_level_update.as_ref()
    }
}
impl std::fmt::Debug for MonitoringConfigurationUpdate {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("MonitoringConfigurationUpdate");
        formatter.field("configuration_type_update", &self.configuration_type_update);
        formatter.field("metrics_level_update", &self.metrics_level_update);
        formatter.field("log_level_update", &self.log_level_update);
        formatter.finish()
    }
}
/// See [`MonitoringConfigurationUpdate`](crate::model::MonitoringConfigurationUpdate)
pub mod monitoring_configuration_update {
    /// A builder for [`MonitoringConfigurationUpdate`](crate::model::MonitoringConfigurationUpdate)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) configuration_type_update: std::option::Option<crate::model::ConfigurationType>,
        pub(crate) metrics_level_update: std::option::Option<crate::model::MetricsLevel>,
        pub(crate) log_level_update: std::option::Option<crate::model::LogLevel>,
    }
    impl Builder {
        /// <p>Describes updates to whether to use the default CloudWatch logging configuration for
        /// an application. You must set this property to <code>CUSTOM</code> in order to set the <code>LogLevel</code> or
        /// <code>MetricsLevel</code> parameters.</p>
        pub fn configuration_type_update(mut self, input: crate::model::ConfigurationType) -> Self {
            self.configuration_type_update = Some(input);
            self
        }
        /// <p>Describes updates to whether to use the default CloudWatch logging configuration for
        /// an application. You must set this property to <code>CUSTOM</code> in order to set the <code>LogLevel</code> or
        /// <code>MetricsLevel</code> parameters.</p>
        pub fn set_configuration_type_update(
            mut self,
            input: std::option::Option<crate::model::ConfigurationType>,
        ) -> Self {
            self.configuration_type_update = input;
            self
        }
        /// <p>Describes updates to the granularity of the CloudWatch Logs for an application. The <code>Parallelism</code>
        /// level is not recommended for applications with a Parallelism over 64 due to excessive costs.</p>
        pub fn metrics_level_update(mut self, input: crate::model::MetricsLevel) -> Self {
            self.metrics_level_update = Some(input);
            self
        }
        /// <p>Describes updates to the granularity of the CloudWatch Logs for an application. The <code>Parallelism</code>
        /// level is not recommended for applications with a Parallelism over 64 due to excessive costs.</p>
        pub fn set_metrics_level_update(
            mut self,
            input: std::option::Option<crate::model::MetricsLevel>,
        ) -> Self {
            self.metrics_level_update = input;
            self
        }
        /// <p>Describes updates to the verbosity of the CloudWatch Logs for an application.</p>
        pub fn log_level_update(mut self, input: crate::model::LogLevel) -> Self {
            self.log_level_update = Some(input);
            self
        }
        /// <p>Describes updates to the verbosity of the CloudWatch Logs for an application.</p>
        pub fn set_log_level_update(
            mut self,
            input: std::option::Option<crate::model::LogLevel>,
        ) -> Self {
            self.log_level_update = input;
            self
        }
        /// Consumes the builder and constructs a [`MonitoringConfigurationUpdate`](crate::model::MonitoringConfigurationUpdate)
        pub fn build(self) -> crate::model::MonitoringConfigurationUpdate {
            crate::model::MonitoringConfigurationUpdate {
                configuration_type_update: self.configuration_type_update,
                metrics_level_update: self.metrics_level_update,
                log_level_update: self.log_level_update,
            }
        }
    }
}
impl MonitoringConfigurationUpdate {
    /// Creates a new builder-style object to manufacture [`MonitoringConfigurationUpdate`](crate::model::MonitoringConfigurationUpdate)
    pub fn builder() -> crate::model::monitoring_configuration_update::Builder {
        crate::model::monitoring_configuration_update::Builder::default()
    }
}

/// <p>Describes updates to the checkpointing parameters for a Flink-based Kinesis Data Analytics application.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CheckpointConfigurationUpdate {
    /// <p>Describes updates to whether the application uses the default checkpointing behavior of
    /// Kinesis Data Analytics. You must set this property to <code>CUSTOM</code> in order to set the
    /// <code>CheckpointingEnabled</code>, <code>CheckpointInterval</code>, or <code>MinPauseBetweenCheckpoints</code> parameters.
    /// </p>
    /// <note>
    /// <p>If this value is set to <code>DEFAULT</code>, the application will use the following values, even if they are
    /// set to other values using APIs or
    /// application code:</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <b>CheckpointingEnabled:</b> true</p>
    /// </li>
    /// <li>
    /// <p>
    /// <b>CheckpointInterval:</b> 60000</p>
    /// </li>
    /// <li>
    /// <p>
    /// <b>MinPauseBetweenCheckpoints:</b> 5000</p>
    /// </li>
    /// </ul>
    /// </note>
    pub configuration_type_update: std::option::Option<crate::model::ConfigurationType>,
    /// <p>Describes updates to whether checkpointing is enabled for an application.</p>
    /// <note>
    /// <p>If <code>CheckpointConfiguration.ConfigurationType</code> is <code>DEFAULT</code>,
    /// the application will use a <code>CheckpointingEnabled</code> value of <code>true</code>, even if this value is set to
    /// another value using this API or in application code.</p>
    /// </note>
    pub checkpointing_enabled_update: std::option::Option<bool>,
    /// <p>Describes updates to the interval in milliseconds between checkpoint operations.</p>
    /// <note>
    /// <p>If <code>CheckpointConfiguration.ConfigurationType</code> is <code>DEFAULT</code>,
    /// the application will use a <code>CheckpointInterval</code> value of 60000, even if this value is set to another value
    /// using this API or in application code.</p>
    /// </note>
    pub checkpoint_interval_update: std::option::Option<i64>,
    /// <p>Describes updates to the minimum time in milliseconds after a checkpoint operation completes that a new checkpoint operation
    /// can start.</p>
    /// <note>
    /// <p>If <code>CheckpointConfiguration.ConfigurationType</code> is <code>DEFAULT</code>,
    /// the application will use a <code>MinPauseBetweenCheckpoints</code> value of 5000, even if this value is set using this API or
    /// in application code.</p>
    /// </note>
    pub min_pause_between_checkpoints_update: std::option::Option<i64>,
}
impl CheckpointConfigurationUpdate {
    /// <p>Describes updates to whether the application uses the default checkpointing behavior of
    /// Kinesis Data Analytics. You must set this property to <code>CUSTOM</code> in order to set the
    /// <code>CheckpointingEnabled</code>, <code>CheckpointInterval</code>, or <code>MinPauseBetweenCheckpoints</code> parameters.
    /// </p>
    /// <note>
    /// <p>If this value is set to <code>DEFAULT</code>, the application will use the following values, even if they are
    /// set to other values using APIs or
    /// application code:</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <b>CheckpointingEnabled:</b> true</p>
    /// </li>
    /// <li>
    /// <p>
    /// <b>CheckpointInterval:</b> 60000</p>
    /// </li>
    /// <li>
    /// <p>
    /// <b>MinPauseBetweenCheckpoints:</b> 5000</p>
    /// </li>
    /// </ul>
    /// </note>
    pub fn configuration_type_update(
        &self,
    ) -> std::option::Option<&crate::model::ConfigurationType> {
        self.configuration_type_update.as_ref()
    }
    /// <p>Describes updates to whether checkpointing is enabled for an application.</p>
    /// <note>
    /// <p>If <code>CheckpointConfiguration.ConfigurationType</code> is <code>DEFAULT</code>,
    /// the application will use a <code>CheckpointingEnabled</code> value of <code>true</code>, even if this value is set to
    /// another value using this API or in application code.</p>
    /// </note>
    pub fn checkpointing_enabled_update(&self) -> std::option::Option<bool> {
        self.checkpointing_enabled_update
    }
    /// <p>Describes updates to the interval in milliseconds between checkpoint operations.</p>
    /// <note>
    /// <p>If <code>CheckpointConfiguration.ConfigurationType</code> is <code>DEFAULT</code>,
    /// the application will use a <code>CheckpointInterval</code> value of 60000, even if this value is set to another value
    /// using this API or in application code.</p>
    /// </note>
    pub fn checkpoint_interval_update(&self) -> std::option::Option<i64> {
        self.checkpoint_interval_update
    }
    /// <p>Describes updates to the minimum time in milliseconds after a checkpoint operation completes that a new checkpoint operation
    /// can start.</p>
    /// <note>
    /// <p>If <code>CheckpointConfiguration.ConfigurationType</code> is <code>DEFAULT</code>,
    /// the application will use a <code>MinPauseBetweenCheckpoints</code> value of 5000, even if this value is set using this API or
    /// in application code.</p>
    /// </note>
    pub fn min_pause_between_checkpoints_update(&self) -> std::option::Option<i64> {
        self.min_pause_between_checkpoints_update
    }
}
impl std::fmt::Debug for CheckpointConfigurationUpdate {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CheckpointConfigurationUpdate");
        formatter.field("configuration_type_update", &self.configuration_type_update);
        formatter.field(
            "checkpointing_enabled_update",
            &self.checkpointing_enabled_update,
        );
        formatter.field(
            "checkpoint_interval_update",
            &self.checkpoint_interval_update,
        );
        formatter.field(
            "min_pause_between_checkpoints_update",
            &self.min_pause_between_checkpoints_update,
        );
        formatter.finish()
    }
}
/// See [`CheckpointConfigurationUpdate`](crate::model::CheckpointConfigurationUpdate)
pub mod checkpoint_configuration_update {
    /// A builder for [`CheckpointConfigurationUpdate`](crate::model::CheckpointConfigurationUpdate)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) configuration_type_update: std::option::Option<crate::model::ConfigurationType>,
        pub(crate) checkpointing_enabled_update: std::option::Option<bool>,
        pub(crate) checkpoint_interval_update: std::option::Option<i64>,
        pub(crate) min_pause_between_checkpoints_update: std::option::Option<i64>,
    }
    impl Builder {
        /// <p>Describes updates to whether the application uses the default checkpointing behavior of
        /// Kinesis Data Analytics. You must set this property to <code>CUSTOM</code> in order to set the
        /// <code>CheckpointingEnabled</code>, <code>CheckpointInterval</code>, or <code>MinPauseBetweenCheckpoints</code> parameters.
        /// </p>
        /// <note>
        /// <p>If this value is set to <code>DEFAULT</code>, the application will use the following values, even if they are
        /// set to other values using APIs or
        /// application code:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <b>CheckpointingEnabled:</b> true</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>CheckpointInterval:</b> 60000</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>MinPauseBetweenCheckpoints:</b> 5000</p>
        /// </li>
        /// </ul>
        /// </note>
        pub fn configuration_type_update(mut self, input: crate::model::ConfigurationType) -> Self {
            self.configuration_type_update = Some(input);
            self
        }
        /// <p>Describes updates to whether the application uses the default checkpointing behavior of
        /// Kinesis Data Analytics. You must set this property to <code>CUSTOM</code> in order to set the
        /// <code>CheckpointingEnabled</code>, <code>CheckpointInterval</code>, or <code>MinPauseBetweenCheckpoints</code> parameters.
        /// </p>
        /// <note>
        /// <p>If this value is set to <code>DEFAULT</code>, the application will use the following values, even if they are
        /// set to other values using APIs or
        /// application code:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <b>CheckpointingEnabled:</b> true</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>CheckpointInterval:</b> 60000</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>MinPauseBetweenCheckpoints:</b> 5000</p>
        /// </li>
        /// </ul>
        /// </note>
        pub fn set_configuration_type_update(
            mut self,
            input: std::option::Option<crate::model::ConfigurationType>,
        ) -> Self {
            self.configuration_type_update = input;
            self
        }
        /// <p>Describes updates to whether checkpointing is enabled for an application.</p>
        /// <note>
        /// <p>If <code>CheckpointConfiguration.ConfigurationType</code> is <code>DEFAULT</code>,
        /// the application will use a <code>CheckpointingEnabled</code> value of <code>true</code>, even if this value is set to
        /// another value using this API or in application code.</p>
        /// </note>
        pub fn checkpointing_enabled_update(mut self, input: bool) -> Self {
            self.checkpointing_enabled_update = Some(input);
            self
        }
        /// <p>Describes updates to whether checkpointing is enabled for an application.</p>
        /// <note>
        /// <p>If <code>CheckpointConfiguration.ConfigurationType</code> is <code>DEFAULT</code>,
        /// the application will use a <code>CheckpointingEnabled</code> value of <code>true</code>, even if this value is set to
        /// another value using this API or in application code.</p>
        /// </note>
        pub fn set_checkpointing_enabled_update(
            mut self,
            input: std::option::Option<bool>,
        ) -> Self {
            self.checkpointing_enabled_update = input;
            self
        }
        /// <p>Describes updates to the interval in milliseconds between checkpoint operations.</p>
        /// <note>
        /// <p>If <code>CheckpointConfiguration.ConfigurationType</code> is <code>DEFAULT</code>,
        /// the application will use a <code>CheckpointInterval</code> value of 60000, even if this value is set to another value
        /// using this API or in application code.</p>
        /// </note>
        pub fn checkpoint_interval_update(mut self, input: i64) -> Self {
            self.checkpoint_interval_update = Some(input);
            self
        }
        /// <p>Describes updates to the interval in milliseconds between checkpoint operations.</p>
        /// <note>
        /// <p>If <code>CheckpointConfiguration.ConfigurationType</code> is <code>DEFAULT</code>,
        /// the application will use a <code>CheckpointInterval</code> value of 60000, even if this value is set to another value
        /// using this API or in application code.</p>
        /// </note>
        pub fn set_checkpoint_interval_update(mut self, input: std::option::Option<i64>) -> Self {
            self.checkpoint_interval_update = input;
            self
        }
        /// <p>Describes updates to the minimum time in milliseconds after a checkpoint operation completes that a new checkpoint operation
        /// can start.</p>
        /// <note>
        /// <p>If <code>CheckpointConfiguration.ConfigurationType</code> is <code>DEFAULT</code>,
        /// the application will use a <code>MinPauseBetweenCheckpoints</code> value of 5000, even if this value is set using this API or
        /// in application code.</p>
        /// </note>
        pub fn min_pause_between_checkpoints_update(mut self, input: i64) -> Self {
            self.min_pause_between_checkpoints_update = Some(input);
            self
        }
        /// <p>Describes updates to the minimum time in milliseconds after a checkpoint operation completes that a new checkpoint operation
        /// can start.</p>
        /// <note>
        /// <p>If <code>CheckpointConfiguration.ConfigurationType</code> is <code>DEFAULT</code>,
        /// the application will use a <code>MinPauseBetweenCheckpoints</code> value of 5000, even if this value is set using this API or
        /// in application code.</p>
        /// </note>
        pub fn set_min_pause_between_checkpoints_update(
            mut self,
            input: std::option::Option<i64>,
        ) -> Self {
            self.min_pause_between_checkpoints_update = input;
            self
        }
        /// Consumes the builder and constructs a [`CheckpointConfigurationUpdate`](crate::model::CheckpointConfigurationUpdate)
        pub fn build(self) -> crate::model::CheckpointConfigurationUpdate {
            crate::model::CheckpointConfigurationUpdate {
                configuration_type_update: self.configuration_type_update,
                checkpointing_enabled_update: self.checkpointing_enabled_update,
                checkpoint_interval_update: self.checkpoint_interval_update,
                min_pause_between_checkpoints_update: self.min_pause_between_checkpoints_update,
            }
        }
    }
}
impl CheckpointConfigurationUpdate {
    /// Creates a new builder-style object to manufacture [`CheckpointConfigurationUpdate`](crate::model::CheckpointConfigurationUpdate)
    pub fn builder() -> crate::model::checkpoint_configuration_update::Builder {
        crate::model::checkpoint_configuration_update::Builder::default()
    }
}

/// <p>Describes code configuration updates for an application. This is supported for a Flink-based Kinesis Data Analytics application or a SQL-based Kinesis Data Analytics application.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ApplicationCodeConfigurationUpdate {
    /// <p>Describes updates to the code content type.</p>
    pub code_content_type_update: std::option::Option<crate::model::CodeContentType>,
    /// <p>Describes updates to the code content of an application.</p>
    pub code_content_update: std::option::Option<crate::model::CodeContentUpdate>,
}
impl ApplicationCodeConfigurationUpdate {
    /// <p>Describes updates to the code content type.</p>
    pub fn code_content_type_update(&self) -> std::option::Option<&crate::model::CodeContentType> {
        self.code_content_type_update.as_ref()
    }
    /// <p>Describes updates to the code content of an application.</p>
    pub fn code_content_update(&self) -> std::option::Option<&crate::model::CodeContentUpdate> {
        self.code_content_update.as_ref()
    }
}
impl std::fmt::Debug for ApplicationCodeConfigurationUpdate {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ApplicationCodeConfigurationUpdate");
        formatter.field("code_content_type_update", &self.code_content_type_update);
        formatter.field("code_content_update", &self.code_content_update);
        formatter.finish()
    }
}
/// See [`ApplicationCodeConfigurationUpdate`](crate::model::ApplicationCodeConfigurationUpdate)
pub mod application_code_configuration_update {
    /// A builder for [`ApplicationCodeConfigurationUpdate`](crate::model::ApplicationCodeConfigurationUpdate)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) code_content_type_update: std::option::Option<crate::model::CodeContentType>,
        pub(crate) code_content_update: std::option::Option<crate::model::CodeContentUpdate>,
    }
    impl Builder {
        /// <p>Describes updates to the code content type.</p>
        pub fn code_content_type_update(mut self, input: crate::model::CodeContentType) -> Self {
            self.code_content_type_update = Some(input);
            self
        }
        /// <p>Describes updates to the code content type.</p>
        pub fn set_code_content_type_update(
            mut self,
            input: std::option::Option<crate::model::CodeContentType>,
        ) -> Self {
            self.code_content_type_update = input;
            self
        }
        /// <p>Describes updates to the code content of an application.</p>
        pub fn code_content_update(mut self, input: crate::model::CodeContentUpdate) -> Self {
            self.code_content_update = Some(input);
            self
        }
        /// <p>Describes updates to the code content of an application.</p>
        pub fn set_code_content_update(
            mut self,
            input: std::option::Option<crate::model::CodeContentUpdate>,
        ) -> Self {
            self.code_content_update = input;
            self
        }
        /// Consumes the builder and constructs a [`ApplicationCodeConfigurationUpdate`](crate::model::ApplicationCodeConfigurationUpdate)
        pub fn build(self) -> crate::model::ApplicationCodeConfigurationUpdate {
            crate::model::ApplicationCodeConfigurationUpdate {
                code_content_type_update: self.code_content_type_update,
                code_content_update: self.code_content_update,
            }
        }
    }
}
impl ApplicationCodeConfigurationUpdate {
    /// Creates a new builder-style object to manufacture [`ApplicationCodeConfigurationUpdate`](crate::model::ApplicationCodeConfigurationUpdate)
    pub fn builder() -> crate::model::application_code_configuration_update::Builder {
        crate::model::application_code_configuration_update::Builder::default()
    }
}

/// <p>Describes an update to the code of an application. Not supported for Apache Zeppelin.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CodeContentUpdate {
    /// <p>Describes an update to the text code for an application.</p>
    pub text_content_update: std::option::Option<std::string::String>,
    /// <p>Describes an update to the zipped code for an application.</p>
    pub zip_file_content_update: std::option::Option<aws_smithy_types::Blob>,
    /// <p>Describes an update to the location of code for an application.</p>
    pub s3_content_location_update: std::option::Option<crate::model::S3ContentLocationUpdate>,
}
impl CodeContentUpdate {
    /// <p>Describes an update to the text code for an application.</p>
    pub fn text_content_update(&self) -> std::option::Option<&str> {
        self.text_content_update.as_deref()
    }
    /// <p>Describes an update to the zipped code for an application.</p>
    pub fn zip_file_content_update(&self) -> std::option::Option<&aws_smithy_types::Blob> {
        self.zip_file_content_update.as_ref()
    }
    /// <p>Describes an update to the location of code for an application.</p>
    pub fn s3_content_location_update(
        &self,
    ) -> std::option::Option<&crate::model::S3ContentLocationUpdate> {
        self.s3_content_location_update.as_ref()
    }
}
impl std::fmt::Debug for CodeContentUpdate {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CodeContentUpdate");
        formatter.field("text_content_update", &self.text_content_update);
        formatter.field("zip_file_content_update", &self.zip_file_content_update);
        formatter.field(
            "s3_content_location_update",
            &self.s3_content_location_update,
        );
        formatter.finish()
    }
}
/// See [`CodeContentUpdate`](crate::model::CodeContentUpdate)
pub mod code_content_update {
    /// A builder for [`CodeContentUpdate`](crate::model::CodeContentUpdate)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) text_content_update: std::option::Option<std::string::String>,
        pub(crate) zip_file_content_update: std::option::Option<aws_smithy_types::Blob>,
        pub(crate) s3_content_location_update:
            std::option::Option<crate::model::S3ContentLocationUpdate>,
    }
    impl Builder {
        /// <p>Describes an update to the text code for an application.</p>
        pub fn text_content_update(mut self, input: impl Into<std::string::String>) -> Self {
            self.text_content_update = Some(input.into());
            self
        }
        /// <p>Describes an update to the text code for an application.</p>
        pub fn set_text_content_update(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.text_content_update = input;
            self
        }
        /// <p>Describes an update to the zipped code for an application.</p>
        pub fn zip_file_content_update(mut self, input: aws_smithy_types::Blob) -> Self {
            self.zip_file_content_update = Some(input);
            self
        }
        /// <p>Describes an update to the zipped code for an application.</p>
        pub fn set_zip_file_content_update(
            mut self,
            input: std::option::Option<aws_smithy_types::Blob>,
        ) -> Self {
            self.zip_file_content_update = input;
            self
        }
        /// <p>Describes an update to the location of code for an application.</p>
        pub fn s3_content_location_update(
            mut self,
            input: crate::model::S3ContentLocationUpdate,
        ) -> Self {
            self.s3_content_location_update = Some(input);
            self
        }
        /// <p>Describes an update to the location of code for an application.</p>
        pub fn set_s3_content_location_update(
            mut self,
            input: std::option::Option<crate::model::S3ContentLocationUpdate>,
        ) -> Self {
            self.s3_content_location_update = input;
            self
        }
        /// Consumes the builder and constructs a [`CodeContentUpdate`](crate::model::CodeContentUpdate)
        pub fn build(self) -> crate::model::CodeContentUpdate {
            crate::model::CodeContentUpdate {
                text_content_update: self.text_content_update,
                zip_file_content_update: self.zip_file_content_update,
                s3_content_location_update: self.s3_content_location_update,
            }
        }
    }
}
impl CodeContentUpdate {
    /// Creates a new builder-style object to manufacture [`CodeContentUpdate`](crate::model::CodeContentUpdate)
    pub fn builder() -> crate::model::code_content_update::Builder {
        crate::model::code_content_update::Builder::default()
    }
}

/// <p>Describes an update for the Amazon S3 code content location for an application.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct S3ContentLocationUpdate {
    /// <p>The new Amazon Resource Name (ARN) for the S3 bucket containing the application code.</p>
    pub bucket_arn_update: std::option::Option<std::string::String>,
    /// <p>The new file key for the object containing the application code.</p>
    pub file_key_update: std::option::Option<std::string::String>,
    /// <p>The new version of the object containing the application code.</p>
    pub object_version_update: std::option::Option<std::string::String>,
}
impl S3ContentLocationUpdate {
    /// <p>The new Amazon Resource Name (ARN) for the S3 bucket containing the application code.</p>
    pub fn bucket_arn_update(&self) -> std::option::Option<&str> {
        self.bucket_arn_update.as_deref()
    }
    /// <p>The new file key for the object containing the application code.</p>
    pub fn file_key_update(&self) -> std::option::Option<&str> {
        self.file_key_update.as_deref()
    }
    /// <p>The new version of the object containing the application code.</p>
    pub fn object_version_update(&self) -> std::option::Option<&str> {
        self.object_version_update.as_deref()
    }
}
impl std::fmt::Debug for S3ContentLocationUpdate {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("S3ContentLocationUpdate");
        formatter.field("bucket_arn_update", &self.bucket_arn_update);
        formatter.field("file_key_update", &self.file_key_update);
        formatter.field("object_version_update", &self.object_version_update);
        formatter.finish()
    }
}
/// See [`S3ContentLocationUpdate`](crate::model::S3ContentLocationUpdate)
pub mod s3_content_location_update {
    /// A builder for [`S3ContentLocationUpdate`](crate::model::S3ContentLocationUpdate)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) bucket_arn_update: std::option::Option<std::string::String>,
        pub(crate) file_key_update: std::option::Option<std::string::String>,
        pub(crate) object_version_update: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The new Amazon Resource Name (ARN) for the S3 bucket containing the application code.</p>
        pub fn bucket_arn_update(mut self, input: impl Into<std::string::String>) -> Self {
            self.bucket_arn_update = Some(input.into());
            self
        }
        /// <p>The new Amazon Resource Name (ARN) for the S3 bucket containing the application code.</p>
        pub fn set_bucket_arn_update(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.bucket_arn_update = input;
            self
        }
        /// <p>The new file key for the object containing the application code.</p>
        pub fn file_key_update(mut self, input: impl Into<std::string::String>) -> Self {
            self.file_key_update = Some(input.into());
            self
        }
        /// <p>The new file key for the object containing the application code.</p>
        pub fn set_file_key_update(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.file_key_update = input;
            self
        }
        /// <p>The new version of the object containing the application code.</p>
        pub fn object_version_update(mut self, input: impl Into<std::string::String>) -> Self {
            self.object_version_update = Some(input.into());
            self
        }
        /// <p>The new version of the object containing the application code.</p>
        pub fn set_object_version_update(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.object_version_update = input;
            self
        }
        /// Consumes the builder and constructs a [`S3ContentLocationUpdate`](crate::model::S3ContentLocationUpdate)
        pub fn build(self) -> crate::model::S3ContentLocationUpdate {
            crate::model::S3ContentLocationUpdate {
                bucket_arn_update: self.bucket_arn_update,
                file_key_update: self.file_key_update,
                object_version_update: self.object_version_update,
            }
        }
    }
}
impl S3ContentLocationUpdate {
    /// Creates a new builder-style object to manufacture [`S3ContentLocationUpdate`](crate::model::S3ContentLocationUpdate)
    pub fn builder() -> crate::model::s3_content_location_update::Builder {
        crate::model::s3_content_location_update::Builder::default()
    }
}

/// <p>Describes updates to the input streams, destination streams, and reference data sources
/// for a SQL-based Kinesis Data Analytics application.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SqlApplicationConfigurationUpdate {
    /// <p>The array of <a>InputUpdate</a> objects describing the new input streams used
    /// by the application.</p>
    pub input_updates: std::option::Option<std::vec::Vec<crate::model::InputUpdate>>,
    /// <p>The array of <a>OutputUpdate</a> objects describing the new destination streams
    /// used by the application.</p>
    pub output_updates: std::option::Option<std::vec::Vec<crate::model::OutputUpdate>>,
    /// <p>The array of <a>ReferenceDataSourceUpdate</a> objects describing the new
    /// reference data sources used by the application.</p>
    pub reference_data_source_updates:
        std::option::Option<std::vec::Vec<crate::model::ReferenceDataSourceUpdate>>,
}
impl SqlApplicationConfigurationUpdate {
    /// <p>The array of <a>InputUpdate</a> objects describing the new input streams used
    /// by the application.</p>
    pub fn input_updates(&self) -> std::option::Option<&[crate::model::InputUpdate]> {
        self.input_updates.as_deref()
    }
    /// <p>The array of <a>OutputUpdate</a> objects describing the new destination streams
    /// used by the application.</p>
    pub fn output_updates(&self) -> std::option::Option<&[crate::model::OutputUpdate]> {
        self.output_updates.as_deref()
    }
    /// <p>The array of <a>ReferenceDataSourceUpdate</a> objects describing the new
    /// reference data sources used by the application.</p>
    pub fn reference_data_source_updates(
        &self,
    ) -> std::option::Option<&[crate::model::ReferenceDataSourceUpdate]> {
        self.reference_data_source_updates.as_deref()
    }
}
impl std::fmt::Debug for SqlApplicationConfigurationUpdate {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SqlApplicationConfigurationUpdate");
        formatter.field("input_updates", &self.input_updates);
        formatter.field("output_updates", &self.output_updates);
        formatter.field(
            "reference_data_source_updates",
            &self.reference_data_source_updates,
        );
        formatter.finish()
    }
}
/// See [`SqlApplicationConfigurationUpdate`](crate::model::SqlApplicationConfigurationUpdate)
pub mod sql_application_configuration_update {
    /// A builder for [`SqlApplicationConfigurationUpdate`](crate::model::SqlApplicationConfigurationUpdate)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) input_updates: std::option::Option<std::vec::Vec<crate::model::InputUpdate>>,
        pub(crate) output_updates: std::option::Option<std::vec::Vec<crate::model::OutputUpdate>>,
        pub(crate) reference_data_source_updates:
            std::option::Option<std::vec::Vec<crate::model::ReferenceDataSourceUpdate>>,
    }
    impl Builder {
        /// Appends an item to `input_updates`.
        ///
        /// To override the contents of this collection use [`set_input_updates`](Self::set_input_updates).
        ///
        /// <p>The array of <a>InputUpdate</a> objects describing the new input streams used
        /// by the application.</p>
        pub fn input_updates(mut self, input: impl Into<crate::model::InputUpdate>) -> Self {
            let mut v = self.input_updates.unwrap_or_default();
            v.push(input.into());
            self.input_updates = Some(v);
            self
        }
        /// <p>The array of <a>InputUpdate</a> objects describing the new input streams used
        /// by the application.</p>
        pub fn set_input_updates(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::InputUpdate>>,
        ) -> Self {
            self.input_updates = input;
            self
        }
        /// Appends an item to `output_updates`.
        ///
        /// To override the contents of this collection use [`set_output_updates`](Self::set_output_updates).
        ///
        /// <p>The array of <a>OutputUpdate</a> objects describing the new destination streams
        /// used by the application.</p>
        pub fn output_updates(mut self, input: impl Into<crate::model::OutputUpdate>) -> Self {
            let mut v = self.output_updates.unwrap_or_default();
            v.push(input.into());
            self.output_updates = Some(v);
            self
        }
        /// <p>The array of <a>OutputUpdate</a> objects describing the new destination streams
        /// used by the application.</p>
        pub fn set_output_updates(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::OutputUpdate>>,
        ) -> Self {
            self.output_updates = input;
            self
        }
        /// Appends an item to `reference_data_source_updates`.
        ///
        /// To override the contents of this collection use [`set_reference_data_source_updates`](Self::set_reference_data_source_updates).
        ///
        /// <p>The array of <a>ReferenceDataSourceUpdate</a> objects describing the new
        /// reference data sources used by the application.</p>
        pub fn reference_data_source_updates(
            mut self,
            input: impl Into<crate::model::ReferenceDataSourceUpdate>,
        ) -> Self {
            let mut v = self.reference_data_source_updates.unwrap_or_default();
            v.push(input.into());
            self.reference_data_source_updates = Some(v);
            self
        }
        /// <p>The array of <a>ReferenceDataSourceUpdate</a> objects describing the new
        /// reference data sources used by the application.</p>
        pub fn set_reference_data_source_updates(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ReferenceDataSourceUpdate>>,
        ) -> Self {
            self.reference_data_source_updates = input;
            self
        }
        /// Consumes the builder and constructs a [`SqlApplicationConfigurationUpdate`](crate::model::SqlApplicationConfigurationUpdate)
        pub fn build(self) -> crate::model::SqlApplicationConfigurationUpdate {
            crate::model::SqlApplicationConfigurationUpdate {
                input_updates: self.input_updates,
                output_updates: self.output_updates,
                reference_data_source_updates: self.reference_data_source_updates,
            }
        }
    }
}
impl SqlApplicationConfigurationUpdate {
    /// Creates a new builder-style object to manufacture [`SqlApplicationConfigurationUpdate`](crate::model::SqlApplicationConfigurationUpdate)
    pub fn builder() -> crate::model::sql_application_configuration_update::Builder {
        crate::model::sql_application_configuration_update::Builder::default()
    }
}

/// <p>When you update a reference data source configuration for a
/// SQL-based Kinesis Data Analytics application, this object provides all the updated values
/// (such as the source bucket name and object key name), the in-application table name that is created,
/// and updated mapping information that maps the data in the Amazon S3 object to the in-application
/// reference table that is created.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ReferenceDataSourceUpdate {
    /// <p>The ID of the reference data source that is being updated. You can use the <a>DescribeApplication</a> operation to get this value.</p>
    pub reference_id: std::option::Option<std::string::String>,
    /// <p>The in-application table name that is created by this update.</p>
    pub table_name_update: std::option::Option<std::string::String>,
    /// <p>Describes the S3 bucket name, object key name, and IAM role that Kinesis Data Analytics can assume to read the
    /// Amazon S3 object on your behalf and populate the in-application reference table.</p>
    pub s3_reference_data_source_update:
        std::option::Option<crate::model::S3ReferenceDataSourceUpdate>,
    /// <p>Describes the format of the data in the streaming source, and how each data element maps to
    /// corresponding columns created in the in-application stream. </p>
    pub reference_schema_update: std::option::Option<crate::model::SourceSchema>,
}
impl ReferenceDataSourceUpdate {
    /// <p>The ID of the reference data source that is being updated. You can use the <a>DescribeApplication</a> operation to get this value.</p>
    pub fn reference_id(&self) -> std::option::Option<&str> {
        self.reference_id.as_deref()
    }
    /// <p>The in-application table name that is created by this update.</p>
    pub fn table_name_update(&self) -> std::option::Option<&str> {
        self.table_name_update.as_deref()
    }
    /// <p>Describes the S3 bucket name, object key name, and IAM role that Kinesis Data Analytics can assume to read the
    /// Amazon S3 object on your behalf and populate the in-application reference table.</p>
    pub fn s3_reference_data_source_update(
        &self,
    ) -> std::option::Option<&crate::model::S3ReferenceDataSourceUpdate> {
        self.s3_reference_data_source_update.as_ref()
    }
    /// <p>Describes the format of the data in the streaming source, and how each data element maps to
    /// corresponding columns created in the in-application stream. </p>
    pub fn reference_schema_update(&self) -> std::option::Option<&crate::model::SourceSchema> {
        self.reference_schema_update.as_ref()
    }
}
impl std::fmt::Debug for ReferenceDataSourceUpdate {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ReferenceDataSourceUpdate");
        formatter.field("reference_id", &self.reference_id);
        formatter.field("table_name_update", &self.table_name_update);
        formatter.field(
            "s3_reference_data_source_update",
            &self.s3_reference_data_source_update,
        );
        formatter.field("reference_schema_update", &self.reference_schema_update);
        formatter.finish()
    }
}
/// See [`ReferenceDataSourceUpdate`](crate::model::ReferenceDataSourceUpdate)
pub mod reference_data_source_update {
    /// A builder for [`ReferenceDataSourceUpdate`](crate::model::ReferenceDataSourceUpdate)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) reference_id: std::option::Option<std::string::String>,
        pub(crate) table_name_update: std::option::Option<std::string::String>,
        pub(crate) s3_reference_data_source_update:
            std::option::Option<crate::model::S3ReferenceDataSourceUpdate>,
        pub(crate) reference_schema_update: std::option::Option<crate::model::SourceSchema>,
    }
    impl Builder {
        /// <p>The ID of the reference data source that is being updated. You can use the <a>DescribeApplication</a> operation to get this value.</p>
        pub fn reference_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.reference_id = Some(input.into());
            self
        }
        /// <p>The ID of the reference data source that is being updated. You can use the <a>DescribeApplication</a> operation to get this value.</p>
        pub fn set_reference_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.reference_id = input;
            self
        }
        /// <p>The in-application table name that is created by this update.</p>
        pub fn table_name_update(mut self, input: impl Into<std::string::String>) -> Self {
            self.table_name_update = Some(input.into());
            self
        }
        /// <p>The in-application table name that is created by this update.</p>
        pub fn set_table_name_update(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.table_name_update = input;
            self
        }
        /// <p>Describes the S3 bucket name, object key name, and IAM role that Kinesis Data Analytics can assume to read the
        /// Amazon S3 object on your behalf and populate the in-application reference table.</p>
        pub fn s3_reference_data_source_update(
            mut self,
            input: crate::model::S3ReferenceDataSourceUpdate,
        ) -> Self {
            self.s3_reference_data_source_update = Some(input);
            self
        }
        /// <p>Describes the S3 bucket name, object key name, and IAM role that Kinesis Data Analytics can assume to read the
        /// Amazon S3 object on your behalf and populate the in-application reference table.</p>
        pub fn set_s3_reference_data_source_update(
            mut self,
            input: std::option::Option<crate::model::S3ReferenceDataSourceUpdate>,
        ) -> Self {
            self.s3_reference_data_source_update = input;
            self
        }
        /// <p>Describes the format of the data in the streaming source, and how each data element maps to
        /// corresponding columns created in the in-application stream. </p>
        pub fn reference_schema_update(mut self, input: crate::model::SourceSchema) -> Self {
            self.reference_schema_update = Some(input);
            self
        }
        /// <p>Describes the format of the data in the streaming source, and how each data element maps to
        /// corresponding columns created in the in-application stream. </p>
        pub fn set_reference_schema_update(
            mut self,
            input: std::option::Option<crate::model::SourceSchema>,
        ) -> Self {
            self.reference_schema_update = input;
            self
        }
        /// Consumes the builder and constructs a [`ReferenceDataSourceUpdate`](crate::model::ReferenceDataSourceUpdate)
        pub fn build(self) -> crate::model::ReferenceDataSourceUpdate {
            crate::model::ReferenceDataSourceUpdate {
                reference_id: self.reference_id,
                table_name_update: self.table_name_update,
                s3_reference_data_source_update: self.s3_reference_data_source_update,
                reference_schema_update: self.reference_schema_update,
            }
        }
    }
}
impl ReferenceDataSourceUpdate {
    /// Creates a new builder-style object to manufacture [`ReferenceDataSourceUpdate`](crate::model::ReferenceDataSourceUpdate)
    pub fn builder() -> crate::model::reference_data_source_update::Builder {
        crate::model::reference_data_source_update::Builder::default()
    }
}

/// <p>For a SQL-based Kinesis Data Analytics application, describes the Amazon S3 bucket
/// name and object key name for an in-application reference table. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct S3ReferenceDataSourceUpdate {
    /// <p>The Amazon Resource Name (ARN) of the S3 bucket.</p>
    pub bucket_arn_update: std::option::Option<std::string::String>,
    /// <p>The object key name.</p>
    pub file_key_update: std::option::Option<std::string::String>,
}
impl S3ReferenceDataSourceUpdate {
    /// <p>The Amazon Resource Name (ARN) of the S3 bucket.</p>
    pub fn bucket_arn_update(&self) -> std::option::Option<&str> {
        self.bucket_arn_update.as_deref()
    }
    /// <p>The object key name.</p>
    pub fn file_key_update(&self) -> std::option::Option<&str> {
        self.file_key_update.as_deref()
    }
}
impl std::fmt::Debug for S3ReferenceDataSourceUpdate {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("S3ReferenceDataSourceUpdate");
        formatter.field("bucket_arn_update", &self.bucket_arn_update);
        formatter.field("file_key_update", &self.file_key_update);
        formatter.finish()
    }
}
/// See [`S3ReferenceDataSourceUpdate`](crate::model::S3ReferenceDataSourceUpdate)
pub mod s3_reference_data_source_update {
    /// A builder for [`S3ReferenceDataSourceUpdate`](crate::model::S3ReferenceDataSourceUpdate)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) bucket_arn_update: std::option::Option<std::string::String>,
        pub(crate) file_key_update: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the S3 bucket.</p>
        pub fn bucket_arn_update(mut self, input: impl Into<std::string::String>) -> Self {
            self.bucket_arn_update = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the S3 bucket.</p>
        pub fn set_bucket_arn_update(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.bucket_arn_update = input;
            self
        }
        /// <p>The object key name.</p>
        pub fn file_key_update(mut self, input: impl Into<std::string::String>) -> Self {
            self.file_key_update = Some(input.into());
            self
        }
        /// <p>The object key name.</p>
        pub fn set_file_key_update(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.file_key_update = input;
            self
        }
        /// Consumes the builder and constructs a [`S3ReferenceDataSourceUpdate`](crate::model::S3ReferenceDataSourceUpdate)
        pub fn build(self) -> crate::model::S3ReferenceDataSourceUpdate {
            crate::model::S3ReferenceDataSourceUpdate {
                bucket_arn_update: self.bucket_arn_update,
                file_key_update: self.file_key_update,
            }
        }
    }
}
impl S3ReferenceDataSourceUpdate {
    /// Creates a new builder-style object to manufacture [`S3ReferenceDataSourceUpdate`](crate::model::S3ReferenceDataSourceUpdate)
    pub fn builder() -> crate::model::s3_reference_data_source_update::Builder {
        crate::model::s3_reference_data_source_update::Builder::default()
    }
}

/// <p> For a SQL-based Kinesis Data Analytics application, describes updates to the
/// output configuration identified by the <code>OutputId</code>. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct OutputUpdate {
    /// <p>Identifies the specific output configuration that you want to update.</p>
    pub output_id: std::option::Option<std::string::String>,
    /// <p>If you want to specify a different in-application stream
    /// for this output configuration, use this field to
    /// specify the new in-application stream name.</p>
    pub name_update: std::option::Option<std::string::String>,
    /// <p>Describes a Kinesis data stream as the destination for the output.</p>
    pub kinesis_streams_output_update:
        std::option::Option<crate::model::KinesisStreamsOutputUpdate>,
    /// <p>Describes a Kinesis Data Firehose delivery stream as the destination for the
    /// output.</p>
    pub kinesis_firehose_output_update:
        std::option::Option<crate::model::KinesisFirehoseOutputUpdate>,
    /// <p>Describes an Amazon Lambda function as the destination for the output.</p>
    pub lambda_output_update: std::option::Option<crate::model::LambdaOutputUpdate>,
    /// <p>Describes the data format when records are written to the destination.
    /// </p>
    pub destination_schema_update: std::option::Option<crate::model::DestinationSchema>,
}
impl OutputUpdate {
    /// <p>Identifies the specific output configuration that you want to update.</p>
    pub fn output_id(&self) -> std::option::Option<&str> {
        self.output_id.as_deref()
    }
    /// <p>If you want to specify a different in-application stream
    /// for this output configuration, use this field to
    /// specify the new in-application stream name.</p>
    pub fn name_update(&self) -> std::option::Option<&str> {
        self.name_update.as_deref()
    }
    /// <p>Describes a Kinesis data stream as the destination for the output.</p>
    pub fn kinesis_streams_output_update(
        &self,
    ) -> std::option::Option<&crate::model::KinesisStreamsOutputUpdate> {
        self.kinesis_streams_output_update.as_ref()
    }
    /// <p>Describes a Kinesis Data Firehose delivery stream as the destination for the
    /// output.</p>
    pub fn kinesis_firehose_output_update(
        &self,
    ) -> std::option::Option<&crate::model::KinesisFirehoseOutputUpdate> {
        self.kinesis_firehose_output_update.as_ref()
    }
    /// <p>Describes an Amazon Lambda function as the destination for the output.</p>
    pub fn lambda_output_update(&self) -> std::option::Option<&crate::model::LambdaOutputUpdate> {
        self.lambda_output_update.as_ref()
    }
    /// <p>Describes the data format when records are written to the destination.
    /// </p>
    pub fn destination_schema_update(
        &self,
    ) -> std::option::Option<&crate::model::DestinationSchema> {
        self.destination_schema_update.as_ref()
    }
}
impl std::fmt::Debug for OutputUpdate {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("OutputUpdate");
        formatter.field("output_id", &self.output_id);
        formatter.field("name_update", &self.name_update);
        formatter.field(
            "kinesis_streams_output_update",
            &self.kinesis_streams_output_update,
        );
        formatter.field(
            "kinesis_firehose_output_update",
            &self.kinesis_firehose_output_update,
        );
        formatter.field("lambda_output_update", &self.lambda_output_update);
        formatter.field("destination_schema_update", &self.destination_schema_update);
        formatter.finish()
    }
}
/// See [`OutputUpdate`](crate::model::OutputUpdate)
pub mod output_update {
    /// A builder for [`OutputUpdate`](crate::model::OutputUpdate)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) output_id: std::option::Option<std::string::String>,
        pub(crate) name_update: std::option::Option<std::string::String>,
        pub(crate) kinesis_streams_output_update:
            std::option::Option<crate::model::KinesisStreamsOutputUpdate>,
        pub(crate) kinesis_firehose_output_update:
            std::option::Option<crate::model::KinesisFirehoseOutputUpdate>,
        pub(crate) lambda_output_update: std::option::Option<crate::model::LambdaOutputUpdate>,
        pub(crate) destination_schema_update: std::option::Option<crate::model::DestinationSchema>,
    }
    impl Builder {
        /// <p>Identifies the specific output configuration that you want to update.</p>
        pub fn output_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.output_id = Some(input.into());
            self
        }
        /// <p>Identifies the specific output configuration that you want to update.</p>
        pub fn set_output_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.output_id = input;
            self
        }
        /// <p>If you want to specify a different in-application stream
        /// for this output configuration, use this field to
        /// specify the new in-application stream name.</p>
        pub fn name_update(mut self, input: impl Into<std::string::String>) -> Self {
            self.name_update = Some(input.into());
            self
        }
        /// <p>If you want to specify a different in-application stream
        /// for this output configuration, use this field to
        /// specify the new in-application stream name.</p>
        pub fn set_name_update(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name_update = input;
            self
        }
        /// <p>Describes a Kinesis data stream as the destination for the output.</p>
        pub fn kinesis_streams_output_update(
            mut self,
            input: crate::model::KinesisStreamsOutputUpdate,
        ) -> Self {
            self.kinesis_streams_output_update = Some(input);
            self
        }
        /// <p>Describes a Kinesis data stream as the destination for the output.</p>
        pub fn set_kinesis_streams_output_update(
            mut self,
            input: std::option::Option<crate::model::KinesisStreamsOutputUpdate>,
        ) -> Self {
            self.kinesis_streams_output_update = input;
            self
        }
        /// <p>Describes a Kinesis Data Firehose delivery stream as the destination for the
        /// output.</p>
        pub fn kinesis_firehose_output_update(
            mut self,
            input: crate::model::KinesisFirehoseOutputUpdate,
        ) -> Self {
            self.kinesis_firehose_output_update = Some(input);
            self
        }
        /// <p>Describes a Kinesis Data Firehose delivery stream as the destination for the
        /// output.</p>
        pub fn set_kinesis_firehose_output_update(
            mut self,
            input: std::option::Option<crate::model::KinesisFirehoseOutputUpdate>,
        ) -> Self {
            self.kinesis_firehose_output_update = input;
            self
        }
        /// <p>Describes an Amazon Lambda function as the destination for the output.</p>
        pub fn lambda_output_update(mut self, input: crate::model::LambdaOutputUpdate) -> Self {
            self.lambda_output_update = Some(input);
            self
        }
        /// <p>Describes an Amazon Lambda function as the destination for the output.</p>
        pub fn set_lambda_output_update(
            mut self,
            input: std::option::Option<crate::model::LambdaOutputUpdate>,
        ) -> Self {
            self.lambda_output_update = input;
            self
        }
        /// <p>Describes the data format when records are written to the destination.
        /// </p>
        pub fn destination_schema_update(mut self, input: crate::model::DestinationSchema) -> Self {
            self.destination_schema_update = Some(input);
            self
        }
        /// <p>Describes the data format when records are written to the destination.
        /// </p>
        pub fn set_destination_schema_update(
            mut self,
            input: std::option::Option<crate::model::DestinationSchema>,
        ) -> Self {
            self.destination_schema_update = input;
            self
        }
        /// Consumes the builder and constructs a [`OutputUpdate`](crate::model::OutputUpdate)
        pub fn build(self) -> crate::model::OutputUpdate {
            crate::model::OutputUpdate {
                output_id: self.output_id,
                name_update: self.name_update,
                kinesis_streams_output_update: self.kinesis_streams_output_update,
                kinesis_firehose_output_update: self.kinesis_firehose_output_update,
                lambda_output_update: self.lambda_output_update,
                destination_schema_update: self.destination_schema_update,
            }
        }
    }
}
impl OutputUpdate {
    /// Creates a new builder-style object to manufacture [`OutputUpdate`](crate::model::OutputUpdate)
    pub fn builder() -> crate::model::output_update::Builder {
        crate::model::output_update::Builder::default()
    }
}

/// <p>When you update an SQL-based Kinesis Data Analytics application's output
/// configuration using the <a>UpdateApplication</a> operation, provides information
/// about an Amazon Lambda function that is configured as the destination.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct LambdaOutputUpdate {
    /// <p>The Amazon Resource Name (ARN) of the destination Amazon Lambda function.</p>
    /// <note>
    /// <p>To specify an earlier version of the Lambda function than the latest, include the Lambda function version in the Lambda function ARN. For more information about Lambda ARNs, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html#arn-syntax-lambda">Example ARNs: Amazon Lambda</a>
    /// </p>
    /// </note>
    pub resource_arn_update: std::option::Option<std::string::String>,
}
impl LambdaOutputUpdate {
    /// <p>The Amazon Resource Name (ARN) of the destination Amazon Lambda function.</p>
    /// <note>
    /// <p>To specify an earlier version of the Lambda function than the latest, include the Lambda function version in the Lambda function ARN. For more information about Lambda ARNs, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html#arn-syntax-lambda">Example ARNs: Amazon Lambda</a>
    /// </p>
    /// </note>
    pub fn resource_arn_update(&self) -> std::option::Option<&str> {
        self.resource_arn_update.as_deref()
    }
}
impl std::fmt::Debug for LambdaOutputUpdate {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("LambdaOutputUpdate");
        formatter.field("resource_arn_update", &self.resource_arn_update);
        formatter.finish()
    }
}
/// See [`LambdaOutputUpdate`](crate::model::LambdaOutputUpdate)
pub mod lambda_output_update {
    /// A builder for [`LambdaOutputUpdate`](crate::model::LambdaOutputUpdate)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) resource_arn_update: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the destination Amazon Lambda function.</p>
        /// <note>
        /// <p>To specify an earlier version of the Lambda function than the latest, include the Lambda function version in the Lambda function ARN. For more information about Lambda ARNs, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html#arn-syntax-lambda">Example ARNs: Amazon Lambda</a>
        /// </p>
        /// </note>
        pub fn resource_arn_update(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_arn_update = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the destination Amazon Lambda function.</p>
        /// <note>
        /// <p>To specify an earlier version of the Lambda function than the latest, include the Lambda function version in the Lambda function ARN. For more information about Lambda ARNs, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html#arn-syntax-lambda">Example ARNs: Amazon Lambda</a>
        /// </p>
        /// </note>
        pub fn set_resource_arn_update(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.resource_arn_update = input;
            self
        }
        /// Consumes the builder and constructs a [`LambdaOutputUpdate`](crate::model::LambdaOutputUpdate)
        pub fn build(self) -> crate::model::LambdaOutputUpdate {
            crate::model::LambdaOutputUpdate {
                resource_arn_update: self.resource_arn_update,
            }
        }
    }
}
impl LambdaOutputUpdate {
    /// Creates a new builder-style object to manufacture [`LambdaOutputUpdate`](crate::model::LambdaOutputUpdate)
    pub fn builder() -> crate::model::lambda_output_update::Builder {
        crate::model::lambda_output_update::Builder::default()
    }
}

/// <p>For a SQL-based Kinesis Data Analytics application, when updating an output
/// configuration using the <a>UpdateApplication</a> operation, provides information
/// about a Kinesis Data Firehose delivery stream that is configured as the destination.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct KinesisFirehoseOutputUpdate {
    /// <p>The Amazon Resource Name (ARN) of the delivery stream to write to. </p>
    pub resource_arn_update: std::option::Option<std::string::String>,
}
impl KinesisFirehoseOutputUpdate {
    /// <p>The Amazon Resource Name (ARN) of the delivery stream to write to. </p>
    pub fn resource_arn_update(&self) -> std::option::Option<&str> {
        self.resource_arn_update.as_deref()
    }
}
impl std::fmt::Debug for KinesisFirehoseOutputUpdate {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("KinesisFirehoseOutputUpdate");
        formatter.field("resource_arn_update", &self.resource_arn_update);
        formatter.finish()
    }
}
/// See [`KinesisFirehoseOutputUpdate`](crate::model::KinesisFirehoseOutputUpdate)
pub mod kinesis_firehose_output_update {
    /// A builder for [`KinesisFirehoseOutputUpdate`](crate::model::KinesisFirehoseOutputUpdate)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) resource_arn_update: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the delivery stream to write to. </p>
        pub fn resource_arn_update(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_arn_update = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the delivery stream to write to. </p>
        pub fn set_resource_arn_update(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.resource_arn_update = input;
            self
        }
        /// Consumes the builder and constructs a [`KinesisFirehoseOutputUpdate`](crate::model::KinesisFirehoseOutputUpdate)
        pub fn build(self) -> crate::model::KinesisFirehoseOutputUpdate {
            crate::model::KinesisFirehoseOutputUpdate {
                resource_arn_update: self.resource_arn_update,
            }
        }
    }
}
impl KinesisFirehoseOutputUpdate {
    /// Creates a new builder-style object to manufacture [`KinesisFirehoseOutputUpdate`](crate::model::KinesisFirehoseOutputUpdate)
    pub fn builder() -> crate::model::kinesis_firehose_output_update::Builder {
        crate::model::kinesis_firehose_output_update::Builder::default()
    }
}

/// <p>When you update a SQL-based Kinesis Data Analytics application's output
/// configuration using the <a>UpdateApplication</a> operation, provides information
/// about a Kinesis data stream that is configured as the destination.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct KinesisStreamsOutputUpdate {
    /// <p>The Amazon Resource Name (ARN) of the Kinesis data stream where you want to write the
    /// output.</p>
    pub resource_arn_update: std::option::Option<std::string::String>,
}
impl KinesisStreamsOutputUpdate {
    /// <p>The Amazon Resource Name (ARN) of the Kinesis data stream where you want to write the
    /// output.</p>
    pub fn resource_arn_update(&self) -> std::option::Option<&str> {
        self.resource_arn_update.as_deref()
    }
}
impl std::fmt::Debug for KinesisStreamsOutputUpdate {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("KinesisStreamsOutputUpdate");
        formatter.field("resource_arn_update", &self.resource_arn_update);
        formatter.finish()
    }
}
/// See [`KinesisStreamsOutputUpdate`](crate::model::KinesisStreamsOutputUpdate)
pub mod kinesis_streams_output_update {
    /// A builder for [`KinesisStreamsOutputUpdate`](crate::model::KinesisStreamsOutputUpdate)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) resource_arn_update: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the Kinesis data stream where you want to write the
        /// output.</p>
        pub fn resource_arn_update(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_arn_update = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the Kinesis data stream where you want to write the
        /// output.</p>
        pub fn set_resource_arn_update(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.resource_arn_update = input;
            self
        }
        /// Consumes the builder and constructs a [`KinesisStreamsOutputUpdate`](crate::model::KinesisStreamsOutputUpdate)
        pub fn build(self) -> crate::model::KinesisStreamsOutputUpdate {
            crate::model::KinesisStreamsOutputUpdate {
                resource_arn_update: self.resource_arn_update,
            }
        }
    }
}
impl KinesisStreamsOutputUpdate {
    /// Creates a new builder-style object to manufacture [`KinesisStreamsOutputUpdate`](crate::model::KinesisStreamsOutputUpdate)
    pub fn builder() -> crate::model::kinesis_streams_output_update::Builder {
        crate::model::kinesis_streams_output_update::Builder::default()
    }
}

/// <p>For a SQL-based Kinesis Data Analytics application, describes updates to a
/// specific input configuration (identified by the <code>InputId</code> of an application). </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InputUpdate {
    /// <p>The input ID of the application input to be updated.</p>
    pub input_id: std::option::Option<std::string::String>,
    /// <p>The name prefix for in-application streams that Kinesis Data Analytics creates for the
    /// specific streaming source.</p>
    pub name_prefix_update: std::option::Option<std::string::String>,
    /// <p>Describes updates to an <a>InputProcessingConfiguration</a>.</p>
    pub input_processing_configuration_update:
        std::option::Option<crate::model::InputProcessingConfigurationUpdate>,
    /// <p>If a Kinesis data stream is the streaming source to be updated, provides an
    /// updated stream Amazon Resource Name (ARN).</p>
    pub kinesis_streams_input_update: std::option::Option<crate::model::KinesisStreamsInputUpdate>,
    /// <p>If a Kinesis Data Firehose delivery stream is the streaming source to be
    /// updated, provides an updated stream ARN.</p>
    pub kinesis_firehose_input_update:
        std::option::Option<crate::model::KinesisFirehoseInputUpdate>,
    /// <p>Describes the data format on the streaming source, and
    /// how record elements on the streaming source map to columns of the in-application stream that is created.</p>
    pub input_schema_update: std::option::Option<crate::model::InputSchemaUpdate>,
    /// <p>Describes the parallelism updates (the number of in-application streams Kinesis Data Analytics creates for the specific streaming source).</p>
    pub input_parallelism_update: std::option::Option<crate::model::InputParallelismUpdate>,
}
impl InputUpdate {
    /// <p>The input ID of the application input to be updated.</p>
    pub fn input_id(&self) -> std::option::Option<&str> {
        self.input_id.as_deref()
    }
    /// <p>The name prefix for in-application streams that Kinesis Data Analytics creates for the
    /// specific streaming source.</p>
    pub fn name_prefix_update(&self) -> std::option::Option<&str> {
        self.name_prefix_update.as_deref()
    }
    /// <p>Describes updates to an <a>InputProcessingConfiguration</a>.</p>
    pub fn input_processing_configuration_update(
        &self,
    ) -> std::option::Option<&crate::model::InputProcessingConfigurationUpdate> {
        self.input_processing_configuration_update.as_ref()
    }
    /// <p>If a Kinesis data stream is the streaming source to be updated, provides an
    /// updated stream Amazon Resource Name (ARN).</p>
    pub fn kinesis_streams_input_update(
        &self,
    ) -> std::option::Option<&crate::model::KinesisStreamsInputUpdate> {
        self.kinesis_streams_input_update.as_ref()
    }
    /// <p>If a Kinesis Data Firehose delivery stream is the streaming source to be
    /// updated, provides an updated stream ARN.</p>
    pub fn kinesis_firehose_input_update(
        &self,
    ) -> std::option::Option<&crate::model::KinesisFirehoseInputUpdate> {
        self.kinesis_firehose_input_update.as_ref()
    }
    /// <p>Describes the data format on the streaming source, and
    /// how record elements on the streaming source map to columns of the in-application stream that is created.</p>
    pub fn input_schema_update(&self) -> std::option::Option<&crate::model::InputSchemaUpdate> {
        self.input_schema_update.as_ref()
    }
    /// <p>Describes the parallelism updates (the number of in-application streams Kinesis Data Analytics creates for the specific streaming source).</p>
    pub fn input_parallelism_update(
        &self,
    ) -> std::option::Option<&crate::model::InputParallelismUpdate> {
        self.input_parallelism_update.as_ref()
    }
}
impl std::fmt::Debug for InputUpdate {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InputUpdate");
        formatter.field("input_id", &self.input_id);
        formatter.field("name_prefix_update", &self.name_prefix_update);
        formatter.field(
            "input_processing_configuration_update",
            &self.input_processing_configuration_update,
        );
        formatter.field(
            "kinesis_streams_input_update",
            &self.kinesis_streams_input_update,
        );
        formatter.field(
            "kinesis_firehose_input_update",
            &self.kinesis_firehose_input_update,
        );
        formatter.field("input_schema_update", &self.input_schema_update);
        formatter.field("input_parallelism_update", &self.input_parallelism_update);
        formatter.finish()
    }
}
/// See [`InputUpdate`](crate::model::InputUpdate)
pub mod input_update {
    /// A builder for [`InputUpdate`](crate::model::InputUpdate)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) input_id: std::option::Option<std::string::String>,
        pub(crate) name_prefix_update: std::option::Option<std::string::String>,
        pub(crate) input_processing_configuration_update:
            std::option::Option<crate::model::InputProcessingConfigurationUpdate>,
        pub(crate) kinesis_streams_input_update:
            std::option::Option<crate::model::KinesisStreamsInputUpdate>,
        pub(crate) kinesis_firehose_input_update:
            std::option::Option<crate::model::KinesisFirehoseInputUpdate>,
        pub(crate) input_schema_update: std::option::Option<crate::model::InputSchemaUpdate>,
        pub(crate) input_parallelism_update:
            std::option::Option<crate::model::InputParallelismUpdate>,
    }
    impl Builder {
        /// <p>The input ID of the application input to be updated.</p>
        pub fn input_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.input_id = Some(input.into());
            self
        }
        /// <p>The input ID of the application input to be updated.</p>
        pub fn set_input_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.input_id = input;
            self
        }
        /// <p>The name prefix for in-application streams that Kinesis Data Analytics creates for the
        /// specific streaming source.</p>
        pub fn name_prefix_update(mut self, input: impl Into<std::string::String>) -> Self {
            self.name_prefix_update = Some(input.into());
            self
        }
        /// <p>The name prefix for in-application streams that Kinesis Data Analytics creates for the
        /// specific streaming source.</p>
        pub fn set_name_prefix_update(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.name_prefix_update = input;
            self
        }
        /// <p>Describes updates to an <a>InputProcessingConfiguration</a>.</p>
        pub fn input_processing_configuration_update(
            mut self,
            input: crate::model::InputProcessingConfigurationUpdate,
        ) -> Self {
            self.input_processing_configuration_update = Some(input);
            self
        }
        /// <p>Describes updates to an <a>InputProcessingConfiguration</a>.</p>
        pub fn set_input_processing_configuration_update(
            mut self,
            input: std::option::Option<crate::model::InputProcessingConfigurationUpdate>,
        ) -> Self {
            self.input_processing_configuration_update = input;
            self
        }
        /// <p>If a Kinesis data stream is the streaming source to be updated, provides an
        /// updated stream Amazon Resource Name (ARN).</p>
        pub fn kinesis_streams_input_update(
            mut self,
            input: crate::model::KinesisStreamsInputUpdate,
        ) -> Self {
            self.kinesis_streams_input_update = Some(input);
            self
        }
        /// <p>If a Kinesis data stream is the streaming source to be updated, provides an
        /// updated stream Amazon Resource Name (ARN).</p>
        pub fn set_kinesis_streams_input_update(
            mut self,
            input: std::option::Option<crate::model::KinesisStreamsInputUpdate>,
        ) -> Self {
            self.kinesis_streams_input_update = input;
            self
        }
        /// <p>If a Kinesis Data Firehose delivery stream is the streaming source to be
        /// updated, provides an updated stream ARN.</p>
        pub fn kinesis_firehose_input_update(
            mut self,
            input: crate::model::KinesisFirehoseInputUpdate,
        ) -> Self {
            self.kinesis_firehose_input_update = Some(input);
            self
        }
        /// <p>If a Kinesis Data Firehose delivery stream is the streaming source to be
        /// updated, provides an updated stream ARN.</p>
        pub fn set_kinesis_firehose_input_update(
            mut self,
            input: std::option::Option<crate::model::KinesisFirehoseInputUpdate>,
        ) -> Self {
            self.kinesis_firehose_input_update = input;
            self
        }
        /// <p>Describes the data format on the streaming source, and
        /// how record elements on the streaming source map to columns of the in-application stream that is created.</p>
        pub fn input_schema_update(mut self, input: crate::model::InputSchemaUpdate) -> Self {
            self.input_schema_update = Some(input);
            self
        }
        /// <p>Describes the data format on the streaming source, and
        /// how record elements on the streaming source map to columns of the in-application stream that is created.</p>
        pub fn set_input_schema_update(
            mut self,
            input: std::option::Option<crate::model::InputSchemaUpdate>,
        ) -> Self {
            self.input_schema_update = input;
            self
        }
        /// <p>Describes the parallelism updates (the number of in-application streams Kinesis Data Analytics creates for the specific streaming source).</p>
        pub fn input_parallelism_update(
            mut self,
            input: crate::model::InputParallelismUpdate,
        ) -> Self {
            self.input_parallelism_update = Some(input);
            self
        }
        /// <p>Describes the parallelism updates (the number of in-application streams Kinesis Data Analytics creates for the specific streaming source).</p>
        pub fn set_input_parallelism_update(
            mut self,
            input: std::option::Option<crate::model::InputParallelismUpdate>,
        ) -> Self {
            self.input_parallelism_update = input;
            self
        }
        /// Consumes the builder and constructs a [`InputUpdate`](crate::model::InputUpdate)
        pub fn build(self) -> crate::model::InputUpdate {
            crate::model::InputUpdate {
                input_id: self.input_id,
                name_prefix_update: self.name_prefix_update,
                input_processing_configuration_update: self.input_processing_configuration_update,
                kinesis_streams_input_update: self.kinesis_streams_input_update,
                kinesis_firehose_input_update: self.kinesis_firehose_input_update,
                input_schema_update: self.input_schema_update,
                input_parallelism_update: self.input_parallelism_update,
            }
        }
    }
}
impl InputUpdate {
    /// Creates a new builder-style object to manufacture [`InputUpdate`](crate::model::InputUpdate)
    pub fn builder() -> crate::model::input_update::Builder {
        crate::model::input_update::Builder::default()
    }
}

/// <p>For a SQL-based Kinesis Data Analytics application, provides updates to the
/// parallelism count.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InputParallelismUpdate {
    /// <p>The number of in-application streams to create for the specified streaming source.</p>
    pub count_update: std::option::Option<i32>,
}
impl InputParallelismUpdate {
    /// <p>The number of in-application streams to create for the specified streaming source.</p>
    pub fn count_update(&self) -> std::option::Option<i32> {
        self.count_update
    }
}
impl std::fmt::Debug for InputParallelismUpdate {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InputParallelismUpdate");
        formatter.field("count_update", &self.count_update);
        formatter.finish()
    }
}
/// See [`InputParallelismUpdate`](crate::model::InputParallelismUpdate)
pub mod input_parallelism_update {
    /// A builder for [`InputParallelismUpdate`](crate::model::InputParallelismUpdate)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) count_update: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The number of in-application streams to create for the specified streaming source.</p>
        pub fn count_update(mut self, input: i32) -> Self {
            self.count_update = Some(input);
            self
        }
        /// <p>The number of in-application streams to create for the specified streaming source.</p>
        pub fn set_count_update(mut self, input: std::option::Option<i32>) -> Self {
            self.count_update = input;
            self
        }
        /// Consumes the builder and constructs a [`InputParallelismUpdate`](crate::model::InputParallelismUpdate)
        pub fn build(self) -> crate::model::InputParallelismUpdate {
            crate::model::InputParallelismUpdate {
                count_update: self.count_update,
            }
        }
    }
}
impl InputParallelismUpdate {
    /// Creates a new builder-style object to manufacture [`InputParallelismUpdate`](crate::model::InputParallelismUpdate)
    pub fn builder() -> crate::model::input_parallelism_update::Builder {
        crate::model::input_parallelism_update::Builder::default()
    }
}

/// <p>Describes updates for an SQL-based Kinesis Data Analytics application's input
/// schema.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InputSchemaUpdate {
    /// <p>Specifies the format of the records on the streaming source.</p>
    pub record_format_update: std::option::Option<crate::model::RecordFormat>,
    /// <p>Specifies the encoding of the records in the streaming source; for example, UTF-8.</p>
    pub record_encoding_update: std::option::Option<std::string::String>,
    /// <p>A list of <code>RecordColumn</code> objects. Each object describes the mapping
    /// of the streaming source element to the corresponding column in the in-application stream.</p>
    pub record_column_updates: std::option::Option<std::vec::Vec<crate::model::RecordColumn>>,
}
impl InputSchemaUpdate {
    /// <p>Specifies the format of the records on the streaming source.</p>
    pub fn record_format_update(&self) -> std::option::Option<&crate::model::RecordFormat> {
        self.record_format_update.as_ref()
    }
    /// <p>Specifies the encoding of the records in the streaming source; for example, UTF-8.</p>
    pub fn record_encoding_update(&self) -> std::option::Option<&str> {
        self.record_encoding_update.as_deref()
    }
    /// <p>A list of <code>RecordColumn</code> objects. Each object describes the mapping
    /// of the streaming source element to the corresponding column in the in-application stream.</p>
    pub fn record_column_updates(&self) -> std::option::Option<&[crate::model::RecordColumn]> {
        self.record_column_updates.as_deref()
    }
}
impl std::fmt::Debug for InputSchemaUpdate {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InputSchemaUpdate");
        formatter.field("record_format_update", &self.record_format_update);
        formatter.field("record_encoding_update", &self.record_encoding_update);
        formatter.field("record_column_updates", &self.record_column_updates);
        formatter.finish()
    }
}
/// See [`InputSchemaUpdate`](crate::model::InputSchemaUpdate)
pub mod input_schema_update {
    /// A builder for [`InputSchemaUpdate`](crate::model::InputSchemaUpdate)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) record_format_update: std::option::Option<crate::model::RecordFormat>,
        pub(crate) record_encoding_update: std::option::Option<std::string::String>,
        pub(crate) record_column_updates:
            std::option::Option<std::vec::Vec<crate::model::RecordColumn>>,
    }
    impl Builder {
        /// <p>Specifies the format of the records on the streaming source.</p>
        pub fn record_format_update(mut self, input: crate::model::RecordFormat) -> Self {
            self.record_format_update = Some(input);
            self
        }
        /// <p>Specifies the format of the records on the streaming source.</p>
        pub fn set_record_format_update(
            mut self,
            input: std::option::Option<crate::model::RecordFormat>,
        ) -> Self {
            self.record_format_update = input;
            self
        }
        /// <p>Specifies the encoding of the records in the streaming source; for example, UTF-8.</p>
        pub fn record_encoding_update(mut self, input: impl Into<std::string::String>) -> Self {
            self.record_encoding_update = Some(input.into());
            self
        }
        /// <p>Specifies the encoding of the records in the streaming source; for example, UTF-8.</p>
        pub fn set_record_encoding_update(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.record_encoding_update = input;
            self
        }
        /// Appends an item to `record_column_updates`.
        ///
        /// To override the contents of this collection use [`set_record_column_updates`](Self::set_record_column_updates).
        ///
        /// <p>A list of <code>RecordColumn</code> objects. Each object describes the mapping
        /// of the streaming source element to the corresponding column in the in-application stream.</p>
        pub fn record_column_updates(
            mut self,
            input: impl Into<crate::model::RecordColumn>,
        ) -> Self {
            let mut v = self.record_column_updates.unwrap_or_default();
            v.push(input.into());
            self.record_column_updates = Some(v);
            self
        }
        /// <p>A list of <code>RecordColumn</code> objects. Each object describes the mapping
        /// of the streaming source element to the corresponding column in the in-application stream.</p>
        pub fn set_record_column_updates(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::RecordColumn>>,
        ) -> Self {
            self.record_column_updates = input;
            self
        }
        /// Consumes the builder and constructs a [`InputSchemaUpdate`](crate::model::InputSchemaUpdate)
        pub fn build(self) -> crate::model::InputSchemaUpdate {
            crate::model::InputSchemaUpdate {
                record_format_update: self.record_format_update,
                record_encoding_update: self.record_encoding_update,
                record_column_updates: self.record_column_updates,
            }
        }
    }
}
impl InputSchemaUpdate {
    /// Creates a new builder-style object to manufacture [`InputSchemaUpdate`](crate::model::InputSchemaUpdate)
    pub fn builder() -> crate::model::input_schema_update::Builder {
        crate::model::input_schema_update::Builder::default()
    }
}

/// <p>For a SQL-based Kinesis Data Analytics application, when updating application
/// input configuration, provides information about a Kinesis Data Firehose delivery stream as the
/// streaming source.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct KinesisFirehoseInputUpdate {
    /// <p>The Amazon Resource Name (ARN) of the input delivery stream to read.</p>
    pub resource_arn_update: std::option::Option<std::string::String>,
}
impl KinesisFirehoseInputUpdate {
    /// <p>The Amazon Resource Name (ARN) of the input delivery stream to read.</p>
    pub fn resource_arn_update(&self) -> std::option::Option<&str> {
        self.resource_arn_update.as_deref()
    }
}
impl std::fmt::Debug for KinesisFirehoseInputUpdate {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("KinesisFirehoseInputUpdate");
        formatter.field("resource_arn_update", &self.resource_arn_update);
        formatter.finish()
    }
}
/// See [`KinesisFirehoseInputUpdate`](crate::model::KinesisFirehoseInputUpdate)
pub mod kinesis_firehose_input_update {
    /// A builder for [`KinesisFirehoseInputUpdate`](crate::model::KinesisFirehoseInputUpdate)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) resource_arn_update: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the input delivery stream to read.</p>
        pub fn resource_arn_update(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_arn_update = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the input delivery stream to read.</p>
        pub fn set_resource_arn_update(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.resource_arn_update = input;
            self
        }
        /// Consumes the builder and constructs a [`KinesisFirehoseInputUpdate`](crate::model::KinesisFirehoseInputUpdate)
        pub fn build(self) -> crate::model::KinesisFirehoseInputUpdate {
            crate::model::KinesisFirehoseInputUpdate {
                resource_arn_update: self.resource_arn_update,
            }
        }
    }
}
impl KinesisFirehoseInputUpdate {
    /// Creates a new builder-style object to manufacture [`KinesisFirehoseInputUpdate`](crate::model::KinesisFirehoseInputUpdate)
    pub fn builder() -> crate::model::kinesis_firehose_input_update::Builder {
        crate::model::kinesis_firehose_input_update::Builder::default()
    }
}

/// <p>When you update the input configuration for a SQL-based Kinesis Data Analytics application, provides information about a
/// Kinesis stream as the streaming
/// source.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct KinesisStreamsInputUpdate {
    /// <p>The Amazon Resource Name (ARN) of the input Kinesis data stream to read.</p>
    pub resource_arn_update: std::option::Option<std::string::String>,
}
impl KinesisStreamsInputUpdate {
    /// <p>The Amazon Resource Name (ARN) of the input Kinesis data stream to read.</p>
    pub fn resource_arn_update(&self) -> std::option::Option<&str> {
        self.resource_arn_update.as_deref()
    }
}
impl std::fmt::Debug for KinesisStreamsInputUpdate {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("KinesisStreamsInputUpdate");
        formatter.field("resource_arn_update", &self.resource_arn_update);
        formatter.finish()
    }
}
/// See [`KinesisStreamsInputUpdate`](crate::model::KinesisStreamsInputUpdate)
pub mod kinesis_streams_input_update {
    /// A builder for [`KinesisStreamsInputUpdate`](crate::model::KinesisStreamsInputUpdate)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) resource_arn_update: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the input Kinesis data stream to read.</p>
        pub fn resource_arn_update(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_arn_update = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the input Kinesis data stream to read.</p>
        pub fn set_resource_arn_update(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.resource_arn_update = input;
            self
        }
        /// Consumes the builder and constructs a [`KinesisStreamsInputUpdate`](crate::model::KinesisStreamsInputUpdate)
        pub fn build(self) -> crate::model::KinesisStreamsInputUpdate {
            crate::model::KinesisStreamsInputUpdate {
                resource_arn_update: self.resource_arn_update,
            }
        }
    }
}
impl KinesisStreamsInputUpdate {
    /// Creates a new builder-style object to manufacture [`KinesisStreamsInputUpdate`](crate::model::KinesisStreamsInputUpdate)
    pub fn builder() -> crate::model::kinesis_streams_input_update::Builder {
        crate::model::kinesis_streams_input_update::Builder::default()
    }
}

/// <p>For a SQL-based Kinesis Data Analytics application, describes updates to an <a>InputProcessingConfiguration</a>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InputProcessingConfigurationUpdate {
    /// <p>Provides update information for an <a>InputLambdaProcessor</a>.</p>
    pub input_lambda_processor_update:
        std::option::Option<crate::model::InputLambdaProcessorUpdate>,
}
impl InputProcessingConfigurationUpdate {
    /// <p>Provides update information for an <a>InputLambdaProcessor</a>.</p>
    pub fn input_lambda_processor_update(
        &self,
    ) -> std::option::Option<&crate::model::InputLambdaProcessorUpdate> {
        self.input_lambda_processor_update.as_ref()
    }
}
impl std::fmt::Debug for InputProcessingConfigurationUpdate {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InputProcessingConfigurationUpdate");
        formatter.field(
            "input_lambda_processor_update",
            &self.input_lambda_processor_update,
        );
        formatter.finish()
    }
}
/// See [`InputProcessingConfigurationUpdate`](crate::model::InputProcessingConfigurationUpdate)
pub mod input_processing_configuration_update {
    /// A builder for [`InputProcessingConfigurationUpdate`](crate::model::InputProcessingConfigurationUpdate)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) input_lambda_processor_update:
            std::option::Option<crate::model::InputLambdaProcessorUpdate>,
    }
    impl Builder {
        /// <p>Provides update information for an <a>InputLambdaProcessor</a>.</p>
        pub fn input_lambda_processor_update(
            mut self,
            input: crate::model::InputLambdaProcessorUpdate,
        ) -> Self {
            self.input_lambda_processor_update = Some(input);
            self
        }
        /// <p>Provides update information for an <a>InputLambdaProcessor</a>.</p>
        pub fn set_input_lambda_processor_update(
            mut self,
            input: std::option::Option<crate::model::InputLambdaProcessorUpdate>,
        ) -> Self {
            self.input_lambda_processor_update = input;
            self
        }
        /// Consumes the builder and constructs a [`InputProcessingConfigurationUpdate`](crate::model::InputProcessingConfigurationUpdate)
        pub fn build(self) -> crate::model::InputProcessingConfigurationUpdate {
            crate::model::InputProcessingConfigurationUpdate {
                input_lambda_processor_update: self.input_lambda_processor_update,
            }
        }
    }
}
impl InputProcessingConfigurationUpdate {
    /// Creates a new builder-style object to manufacture [`InputProcessingConfigurationUpdate`](crate::model::InputProcessingConfigurationUpdate)
    pub fn builder() -> crate::model::input_processing_configuration_update::Builder {
        crate::model::input_processing_configuration_update::Builder::default()
    }
}

/// <p>For a SQL-based Kinesis Data Analytics application, represents an update to the
/// <a>InputLambdaProcessor</a> that is used to preprocess the records in the
/// stream.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InputLambdaProcessorUpdate {
    /// <p>The Amazon Resource Name (ARN) of the new Amazon Lambda function that is used to preprocess
    /// the records in the stream.</p>
    /// <note>
    /// <p>To specify an earlier version of the Lambda function than the latest, include the Lambda function version in the Lambda function ARN. For more information about Lambda ARNs, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html#arn-syntax-lambda">Example ARNs: Amazon Lambda</a>
    /// </p>
    /// </note>
    pub resource_arn_update: std::option::Option<std::string::String>,
}
impl InputLambdaProcessorUpdate {
    /// <p>The Amazon Resource Name (ARN) of the new Amazon Lambda function that is used to preprocess
    /// the records in the stream.</p>
    /// <note>
    /// <p>To specify an earlier version of the Lambda function than the latest, include the Lambda function version in the Lambda function ARN. For more information about Lambda ARNs, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html#arn-syntax-lambda">Example ARNs: Amazon Lambda</a>
    /// </p>
    /// </note>
    pub fn resource_arn_update(&self) -> std::option::Option<&str> {
        self.resource_arn_update.as_deref()
    }
}
impl std::fmt::Debug for InputLambdaProcessorUpdate {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InputLambdaProcessorUpdate");
        formatter.field("resource_arn_update", &self.resource_arn_update);
        formatter.finish()
    }
}
/// See [`InputLambdaProcessorUpdate`](crate::model::InputLambdaProcessorUpdate)
pub mod input_lambda_processor_update {
    /// A builder for [`InputLambdaProcessorUpdate`](crate::model::InputLambdaProcessorUpdate)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) resource_arn_update: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the new Amazon Lambda function that is used to preprocess
        /// the records in the stream.</p>
        /// <note>
        /// <p>To specify an earlier version of the Lambda function than the latest, include the Lambda function version in the Lambda function ARN. For more information about Lambda ARNs, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html#arn-syntax-lambda">Example ARNs: Amazon Lambda</a>
        /// </p>
        /// </note>
        pub fn resource_arn_update(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_arn_update = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the new Amazon Lambda function that is used to preprocess
        /// the records in the stream.</p>
        /// <note>
        /// <p>To specify an earlier version of the Lambda function than the latest, include the Lambda function version in the Lambda function ARN. For more information about Lambda ARNs, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html#arn-syntax-lambda">Example ARNs: Amazon Lambda</a>
        /// </p>
        /// </note>
        pub fn set_resource_arn_update(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.resource_arn_update = input;
            self
        }
        /// Consumes the builder and constructs a [`InputLambdaProcessorUpdate`](crate::model::InputLambdaProcessorUpdate)
        pub fn build(self) -> crate::model::InputLambdaProcessorUpdate {
            crate::model::InputLambdaProcessorUpdate {
                resource_arn_update: self.resource_arn_update,
            }
        }
    }
}
impl InputLambdaProcessorUpdate {
    /// Creates a new builder-style object to manufacture [`InputLambdaProcessorUpdate`](crate::model::InputLambdaProcessorUpdate)
    pub fn builder() -> crate::model::input_lambda_processor_update::Builder {
        crate::model::input_lambda_processor_update::Builder::default()
    }
}

/// <p>A key-value pair (the value is optional) that you can define and assign to Amazon resources.
/// If you specify a tag that already exists, the tag value is replaced with the value that you
/// specify in the request. Note that
/// the maximum number of application tags includes system tags. The maximum number of user-defined
/// application tags is 50.
/// For more information, see
/// <a href="https://docs.aws.amazon.com/kinesisanalytics/latest/java/how-tagging.html">Using Tagging</a>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Tag {
    /// <p>The key of the key-value tag.</p>
    pub key: std::option::Option<std::string::String>,
    /// <p>The value of the key-value tag. The value is optional.</p>
    pub value: std::option::Option<std::string::String>,
}
impl Tag {
    /// <p>The key of the key-value tag.</p>
    pub fn key(&self) -> std::option::Option<&str> {
        self.key.as_deref()
    }
    /// <p>The value of the key-value tag. The value is optional.</p>
    pub fn value(&self) -> std::option::Option<&str> {
        self.value.as_deref()
    }
}
impl std::fmt::Debug for Tag {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Tag");
        formatter.field("key", &self.key);
        formatter.field("value", &self.value);
        formatter.finish()
    }
}
/// See [`Tag`](crate::model::Tag)
pub mod tag {
    /// A builder for [`Tag`](crate::model::Tag)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) key: std::option::Option<std::string::String>,
        pub(crate) value: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The key of the key-value tag.</p>
        pub fn key(mut self, input: impl Into<std::string::String>) -> Self {
            self.key = Some(input.into());
            self
        }
        /// <p>The key of the key-value tag.</p>
        pub fn set_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.key = input;
            self
        }
        /// <p>The value of the key-value tag. The value is optional.</p>
        pub fn value(mut self, input: impl Into<std::string::String>) -> Self {
            self.value = Some(input.into());
            self
        }
        /// <p>The value of the key-value tag. The value is optional.</p>
        pub fn set_value(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.value = input;
            self
        }
        /// Consumes the builder and constructs a [`Tag`](crate::model::Tag)
        pub fn build(self) -> crate::model::Tag {
            crate::model::Tag {
                key: self.key,
                value: self.value,
            }
        }
    }
}
impl Tag {
    /// Creates a new builder-style object to manufacture [`Tag`](crate::model::Tag)
    pub fn builder() -> crate::model::tag::Builder {
        crate::model::tag::Builder::default()
    }
}

/// <p>Describes the starting parameters for an Kinesis Data Analytics application.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct RunConfiguration {
    /// <p>Describes the starting parameters for a Flink-based Kinesis Data Analytics application.</p>
    pub flink_run_configuration: std::option::Option<crate::model::FlinkRunConfiguration>,
    /// <p>Describes the starting parameters for a SQL-based Kinesis Data Analytics application
    /// application.</p>
    pub sql_run_configurations:
        std::option::Option<std::vec::Vec<crate::model::SqlRunConfiguration>>,
    /// <p>Describes the restore behavior of a restarting application.</p>
    pub application_restore_configuration:
        std::option::Option<crate::model::ApplicationRestoreConfiguration>,
}
impl RunConfiguration {
    /// <p>Describes the starting parameters for a Flink-based Kinesis Data Analytics application.</p>
    pub fn flink_run_configuration(
        &self,
    ) -> std::option::Option<&crate::model::FlinkRunConfiguration> {
        self.flink_run_configuration.as_ref()
    }
    /// <p>Describes the starting parameters for a SQL-based Kinesis Data Analytics application
    /// application.</p>
    pub fn sql_run_configurations(
        &self,
    ) -> std::option::Option<&[crate::model::SqlRunConfiguration]> {
        self.sql_run_configurations.as_deref()
    }
    /// <p>Describes the restore behavior of a restarting application.</p>
    pub fn application_restore_configuration(
        &self,
    ) -> std::option::Option<&crate::model::ApplicationRestoreConfiguration> {
        self.application_restore_configuration.as_ref()
    }
}
impl std::fmt::Debug for RunConfiguration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("RunConfiguration");
        formatter.field("flink_run_configuration", &self.flink_run_configuration);
        formatter.field("sql_run_configurations", &self.sql_run_configurations);
        formatter.field(
            "application_restore_configuration",
            &self.application_restore_configuration,
        );
        formatter.finish()
    }
}
/// See [`RunConfiguration`](crate::model::RunConfiguration)
pub mod run_configuration {
    /// A builder for [`RunConfiguration`](crate::model::RunConfiguration)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) flink_run_configuration:
            std::option::Option<crate::model::FlinkRunConfiguration>,
        pub(crate) sql_run_configurations:
            std::option::Option<std::vec::Vec<crate::model::SqlRunConfiguration>>,
        pub(crate) application_restore_configuration:
            std::option::Option<crate::model::ApplicationRestoreConfiguration>,
    }
    impl Builder {
        /// <p>Describes the starting parameters for a Flink-based Kinesis Data Analytics application.</p>
        pub fn flink_run_configuration(
            mut self,
            input: crate::model::FlinkRunConfiguration,
        ) -> Self {
            self.flink_run_configuration = Some(input);
            self
        }
        /// <p>Describes the starting parameters for a Flink-based Kinesis Data Analytics application.</p>
        pub fn set_flink_run_configuration(
            mut self,
            input: std::option::Option<crate::model::FlinkRunConfiguration>,
        ) -> Self {
            self.flink_run_configuration = input;
            self
        }
        /// Appends an item to `sql_run_configurations`.
        ///
        /// To override the contents of this collection use [`set_sql_run_configurations`](Self::set_sql_run_configurations).
        ///
        /// <p>Describes the starting parameters for a SQL-based Kinesis Data Analytics application
        /// application.</p>
        pub fn sql_run_configurations(
            mut self,
            input: impl Into<crate::model::SqlRunConfiguration>,
        ) -> Self {
            let mut v = self.sql_run_configurations.unwrap_or_default();
            v.push(input.into());
            self.sql_run_configurations = Some(v);
            self
        }
        /// <p>Describes the starting parameters for a SQL-based Kinesis Data Analytics application
        /// application.</p>
        pub fn set_sql_run_configurations(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::SqlRunConfiguration>>,
        ) -> Self {
            self.sql_run_configurations = input;
            self
        }
        /// <p>Describes the restore behavior of a restarting application.</p>
        pub fn application_restore_configuration(
            mut self,
            input: crate::model::ApplicationRestoreConfiguration,
        ) -> Self {
            self.application_restore_configuration = Some(input);
            self
        }
        /// <p>Describes the restore behavior of a restarting application.</p>
        pub fn set_application_restore_configuration(
            mut self,
            input: std::option::Option<crate::model::ApplicationRestoreConfiguration>,
        ) -> Self {
            self.application_restore_configuration = input;
            self
        }
        /// Consumes the builder and constructs a [`RunConfiguration`](crate::model::RunConfiguration)
        pub fn build(self) -> crate::model::RunConfiguration {
            crate::model::RunConfiguration {
                flink_run_configuration: self.flink_run_configuration,
                sql_run_configurations: self.sql_run_configurations,
                application_restore_configuration: self.application_restore_configuration,
            }
        }
    }
}
impl RunConfiguration {
    /// Creates a new builder-style object to manufacture [`RunConfiguration`](crate::model::RunConfiguration)
    pub fn builder() -> crate::model::run_configuration::Builder {
        crate::model::run_configuration::Builder::default()
    }
}

/// <p>Describes the starting parameters for a SQL-based Kinesis Data Analytics application.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SqlRunConfiguration {
    /// <p>The input source ID. You can get this ID by calling the <a>DescribeApplication</a> operation. </p>
    pub input_id: std::option::Option<std::string::String>,
    /// <p>The point at which you want the application to start processing records from the streaming
    /// source. </p>
    pub input_starting_position_configuration:
        std::option::Option<crate::model::InputStartingPositionConfiguration>,
}
impl SqlRunConfiguration {
    /// <p>The input source ID. You can get this ID by calling the <a>DescribeApplication</a> operation. </p>
    pub fn input_id(&self) -> std::option::Option<&str> {
        self.input_id.as_deref()
    }
    /// <p>The point at which you want the application to start processing records from the streaming
    /// source. </p>
    pub fn input_starting_position_configuration(
        &self,
    ) -> std::option::Option<&crate::model::InputStartingPositionConfiguration> {
        self.input_starting_position_configuration.as_ref()
    }
}
impl std::fmt::Debug for SqlRunConfiguration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SqlRunConfiguration");
        formatter.field("input_id", &self.input_id);
        formatter.field(
            "input_starting_position_configuration",
            &self.input_starting_position_configuration,
        );
        formatter.finish()
    }
}
/// See [`SqlRunConfiguration`](crate::model::SqlRunConfiguration)
pub mod sql_run_configuration {
    /// A builder for [`SqlRunConfiguration`](crate::model::SqlRunConfiguration)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) input_id: std::option::Option<std::string::String>,
        pub(crate) input_starting_position_configuration:
            std::option::Option<crate::model::InputStartingPositionConfiguration>,
    }
    impl Builder {
        /// <p>The input source ID. You can get this ID by calling the <a>DescribeApplication</a> operation. </p>
        pub fn input_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.input_id = Some(input.into());
            self
        }
        /// <p>The input source ID. You can get this ID by calling the <a>DescribeApplication</a> operation. </p>
        pub fn set_input_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.input_id = input;
            self
        }
        /// <p>The point at which you want the application to start processing records from the streaming
        /// source. </p>
        pub fn input_starting_position_configuration(
            mut self,
            input: crate::model::InputStartingPositionConfiguration,
        ) -> Self {
            self.input_starting_position_configuration = Some(input);
            self
        }
        /// <p>The point at which you want the application to start processing records from the streaming
        /// source. </p>
        pub fn set_input_starting_position_configuration(
            mut self,
            input: std::option::Option<crate::model::InputStartingPositionConfiguration>,
        ) -> Self {
            self.input_starting_position_configuration = input;
            self
        }
        /// Consumes the builder and constructs a [`SqlRunConfiguration`](crate::model::SqlRunConfiguration)
        pub fn build(self) -> crate::model::SqlRunConfiguration {
            crate::model::SqlRunConfiguration {
                input_id: self.input_id,
                input_starting_position_configuration: self.input_starting_position_configuration,
            }
        }
    }
}
impl SqlRunConfiguration {
    /// Creates a new builder-style object to manufacture [`SqlRunConfiguration`](crate::model::SqlRunConfiguration)
    pub fn builder() -> crate::model::sql_run_configuration::Builder {
        crate::model::sql_run_configuration::Builder::default()
    }
}

/// <p>The summary of the application version.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ApplicationVersionSummary {
    /// <p>The ID of the application version. Kinesis Data Analytics updates the <code>ApplicationVersionId</code> each time you update the application.</p>
    pub application_version_id: std::option::Option<i64>,
    /// <p>The status of the application.</p>
    pub application_status: std::option::Option<crate::model::ApplicationStatus>,
}
impl ApplicationVersionSummary {
    /// <p>The ID of the application version. Kinesis Data Analytics updates the <code>ApplicationVersionId</code> each time you update the application.</p>
    pub fn application_version_id(&self) -> std::option::Option<i64> {
        self.application_version_id
    }
    /// <p>The status of the application.</p>
    pub fn application_status(&self) -> std::option::Option<&crate::model::ApplicationStatus> {
        self.application_status.as_ref()
    }
}
impl std::fmt::Debug for ApplicationVersionSummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ApplicationVersionSummary");
        formatter.field("application_version_id", &self.application_version_id);
        formatter.field("application_status", &self.application_status);
        formatter.finish()
    }
}
/// See [`ApplicationVersionSummary`](crate::model::ApplicationVersionSummary)
pub mod application_version_summary {
    /// A builder for [`ApplicationVersionSummary`](crate::model::ApplicationVersionSummary)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) application_version_id: std::option::Option<i64>,
        pub(crate) application_status: std::option::Option<crate::model::ApplicationStatus>,
    }
    impl Builder {
        /// <p>The ID of the application version. Kinesis Data Analytics updates the <code>ApplicationVersionId</code> each time you update the application.</p>
        pub fn application_version_id(mut self, input: i64) -> Self {
            self.application_version_id = Some(input);
            self
        }
        /// <p>The ID of the application version. Kinesis Data Analytics updates the <code>ApplicationVersionId</code> each time you update the application.</p>
        pub fn set_application_version_id(mut self, input: std::option::Option<i64>) -> Self {
            self.application_version_id = input;
            self
        }
        /// <p>The status of the application.</p>
        pub fn application_status(mut self, input: crate::model::ApplicationStatus) -> Self {
            self.application_status = Some(input);
            self
        }
        /// <p>The status of the application.</p>
        pub fn set_application_status(
            mut self,
            input: std::option::Option<crate::model::ApplicationStatus>,
        ) -> Self {
            self.application_status = input;
            self
        }
        /// Consumes the builder and constructs a [`ApplicationVersionSummary`](crate::model::ApplicationVersionSummary)
        pub fn build(self) -> crate::model::ApplicationVersionSummary {
            crate::model::ApplicationVersionSummary {
                application_version_id: self.application_version_id,
                application_status: self.application_status,
            }
        }
    }
}
impl ApplicationVersionSummary {
    /// Creates a new builder-style object to manufacture [`ApplicationVersionSummary`](crate::model::ApplicationVersionSummary)
    pub fn builder() -> crate::model::application_version_summary::Builder {
        crate::model::application_version_summary::Builder::default()
    }
}

/// <p>Provides details about a snapshot of application state.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SnapshotDetails {
    /// <p>The identifier for the application snapshot.</p>
    pub snapshot_name: std::option::Option<std::string::String>,
    /// <p>The status of the application snapshot.</p>
    pub snapshot_status: std::option::Option<crate::model::SnapshotStatus>,
    /// <p>The current application version ID when the snapshot was created.</p>
    pub application_version_id: std::option::Option<i64>,
    /// <p>The timestamp of the application snapshot.</p>
    pub snapshot_creation_timestamp: std::option::Option<aws_smithy_types::DateTime>,
}
impl SnapshotDetails {
    /// <p>The identifier for the application snapshot.</p>
    pub fn snapshot_name(&self) -> std::option::Option<&str> {
        self.snapshot_name.as_deref()
    }
    /// <p>The status of the application snapshot.</p>
    pub fn snapshot_status(&self) -> std::option::Option<&crate::model::SnapshotStatus> {
        self.snapshot_status.as_ref()
    }
    /// <p>The current application version ID when the snapshot was created.</p>
    pub fn application_version_id(&self) -> std::option::Option<i64> {
        self.application_version_id
    }
    /// <p>The timestamp of the application snapshot.</p>
    pub fn snapshot_creation_timestamp(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.snapshot_creation_timestamp.as_ref()
    }
}
impl std::fmt::Debug for SnapshotDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SnapshotDetails");
        formatter.field("snapshot_name", &self.snapshot_name);
        formatter.field("snapshot_status", &self.snapshot_status);
        formatter.field("application_version_id", &self.application_version_id);
        formatter.field(
            "snapshot_creation_timestamp",
            &self.snapshot_creation_timestamp,
        );
        formatter.finish()
    }
}
/// See [`SnapshotDetails`](crate::model::SnapshotDetails)
pub mod snapshot_details {
    /// A builder for [`SnapshotDetails`](crate::model::SnapshotDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) snapshot_name: std::option::Option<std::string::String>,
        pub(crate) snapshot_status: std::option::Option<crate::model::SnapshotStatus>,
        pub(crate) application_version_id: std::option::Option<i64>,
        pub(crate) snapshot_creation_timestamp: std::option::Option<aws_smithy_types::DateTime>,
    }
    impl Builder {
        /// <p>The identifier for the application snapshot.</p>
        pub fn snapshot_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.snapshot_name = Some(input.into());
            self
        }
        /// <p>The identifier for the application snapshot.</p>
        pub fn set_snapshot_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.snapshot_name = input;
            self
        }
        /// <p>The status of the application snapshot.</p>
        pub fn snapshot_status(mut self, input: crate::model::SnapshotStatus) -> Self {
            self.snapshot_status = Some(input);
            self
        }
        /// <p>The status of the application snapshot.</p>
        pub fn set_snapshot_status(
            mut self,
            input: std::option::Option<crate::model::SnapshotStatus>,
        ) -> Self {
            self.snapshot_status = input;
            self
        }
        /// <p>The current application version ID when the snapshot was created.</p>
        pub fn application_version_id(mut self, input: i64) -> Self {
            self.application_version_id = Some(input);
            self
        }
        /// <p>The current application version ID when the snapshot was created.</p>
        pub fn set_application_version_id(mut self, input: std::option::Option<i64>) -> Self {
            self.application_version_id = input;
            self
        }
        /// <p>The timestamp of the application snapshot.</p>
        pub fn snapshot_creation_timestamp(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.snapshot_creation_timestamp = Some(input);
            self
        }
        /// <p>The timestamp of the application snapshot.</p>
        pub fn set_snapshot_creation_timestamp(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.snapshot_creation_timestamp = input;
            self
        }
        /// Consumes the builder and constructs a [`SnapshotDetails`](crate::model::SnapshotDetails)
        pub fn build(self) -> crate::model::SnapshotDetails {
            crate::model::SnapshotDetails {
                snapshot_name: self.snapshot_name,
                snapshot_status: self.snapshot_status,
                application_version_id: self.application_version_id,
                snapshot_creation_timestamp: self.snapshot_creation_timestamp,
            }
        }
    }
}
impl SnapshotDetails {
    /// Creates a new builder-style object to manufacture [`SnapshotDetails`](crate::model::SnapshotDetails)
    pub fn builder() -> crate::model::snapshot_details::Builder {
        crate::model::snapshot_details::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum SnapshotStatus {
    #[allow(missing_docs)] // documentation missing in model
    Creating,
    #[allow(missing_docs)] // documentation missing in model
    Deleting,
    #[allow(missing_docs)] // documentation missing in model
    Failed,
    #[allow(missing_docs)] // documentation missing in model
    Ready,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for SnapshotStatus {
    fn from(s: &str) -> Self {
        match s {
            "CREATING" => SnapshotStatus::Creating,
            "DELETING" => SnapshotStatus::Deleting,
            "FAILED" => SnapshotStatus::Failed,
            "READY" => SnapshotStatus::Ready,
            other => SnapshotStatus::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for SnapshotStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(SnapshotStatus::from(s))
    }
}
impl SnapshotStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            SnapshotStatus::Creating => "CREATING",
            SnapshotStatus::Deleting => "DELETING",
            SnapshotStatus::Failed => "FAILED",
            SnapshotStatus::Ready => "READY",
            SnapshotStatus::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["CREATING", "DELETING", "FAILED", "READY"]
    }
}
impl AsRef<str> for SnapshotStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Provides application summary information, including the application Amazon Resource Name (ARN), name, and status.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ApplicationSummary {
    /// <p>The name of the application.</p>
    pub application_name: std::option::Option<std::string::String>,
    /// <p>The ARN of the application.</p>
    pub application_arn: std::option::Option<std::string::String>,
    /// <p>The status of the application.</p>
    pub application_status: std::option::Option<crate::model::ApplicationStatus>,
    /// <p>Provides the current application version.</p>
    pub application_version_id: std::option::Option<i64>,
    /// <p>The runtime environment for the application.</p>
    pub runtime_environment: std::option::Option<crate::model::RuntimeEnvironment>,
    /// <p>For a Kinesis Data Analytics for Apache Flink application, the mode is <code>STREAMING</code>. For a Kinesis Data Analytics Studio notebook, it is <code>INTERACTIVE</code>.</p>
    pub application_mode: std::option::Option<crate::model::ApplicationMode>,
}
impl ApplicationSummary {
    /// <p>The name of the application.</p>
    pub fn application_name(&self) -> std::option::Option<&str> {
        self.application_name.as_deref()
    }
    /// <p>The ARN of the application.</p>
    pub fn application_arn(&self) -> std::option::Option<&str> {
        self.application_arn.as_deref()
    }
    /// <p>The status of the application.</p>
    pub fn application_status(&self) -> std::option::Option<&crate::model::ApplicationStatus> {
        self.application_status.as_ref()
    }
    /// <p>Provides the current application version.</p>
    pub fn application_version_id(&self) -> std::option::Option<i64> {
        self.application_version_id
    }
    /// <p>The runtime environment for the application.</p>
    pub fn runtime_environment(&self) -> std::option::Option<&crate::model::RuntimeEnvironment> {
        self.runtime_environment.as_ref()
    }
    /// <p>For a Kinesis Data Analytics for Apache Flink application, the mode is <code>STREAMING</code>. For a Kinesis Data Analytics Studio notebook, it is <code>INTERACTIVE</code>.</p>
    pub fn application_mode(&self) -> std::option::Option<&crate::model::ApplicationMode> {
        self.application_mode.as_ref()
    }
}
impl std::fmt::Debug for ApplicationSummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ApplicationSummary");
        formatter.field("application_name", &self.application_name);
        formatter.field("application_arn", &self.application_arn);
        formatter.field("application_status", &self.application_status);
        formatter.field("application_version_id", &self.application_version_id);
        formatter.field("runtime_environment", &self.runtime_environment);
        formatter.field("application_mode", &self.application_mode);
        formatter.finish()
    }
}
/// See [`ApplicationSummary`](crate::model::ApplicationSummary)
pub mod application_summary {
    /// A builder for [`ApplicationSummary`](crate::model::ApplicationSummary)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) application_name: std::option::Option<std::string::String>,
        pub(crate) application_arn: std::option::Option<std::string::String>,
        pub(crate) application_status: std::option::Option<crate::model::ApplicationStatus>,
        pub(crate) application_version_id: std::option::Option<i64>,
        pub(crate) runtime_environment: std::option::Option<crate::model::RuntimeEnvironment>,
        pub(crate) application_mode: std::option::Option<crate::model::ApplicationMode>,
    }
    impl Builder {
        /// <p>The name of the application.</p>
        pub fn application_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.application_name = Some(input.into());
            self
        }
        /// <p>The name of the application.</p>
        pub fn set_application_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.application_name = input;
            self
        }
        /// <p>The ARN of the application.</p>
        pub fn application_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.application_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the application.</p>
        pub fn set_application_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.application_arn = input;
            self
        }
        /// <p>The status of the application.</p>
        pub fn application_status(mut self, input: crate::model::ApplicationStatus) -> Self {
            self.application_status = Some(input);
            self
        }
        /// <p>The status of the application.</p>
        pub fn set_application_status(
            mut self,
            input: std::option::Option<crate::model::ApplicationStatus>,
        ) -> Self {
            self.application_status = input;
            self
        }
        /// <p>Provides the current application version.</p>
        pub fn application_version_id(mut self, input: i64) -> Self {
            self.application_version_id = Some(input);
            self
        }
        /// <p>Provides the current application version.</p>
        pub fn set_application_version_id(mut self, input: std::option::Option<i64>) -> Self {
            self.application_version_id = input;
            self
        }
        /// <p>The runtime environment for the application.</p>
        pub fn runtime_environment(mut self, input: crate::model::RuntimeEnvironment) -> Self {
            self.runtime_environment = Some(input);
            self
        }
        /// <p>The runtime environment for the application.</p>
        pub fn set_runtime_environment(
            mut self,
            input: std::option::Option<crate::model::RuntimeEnvironment>,
        ) -> Self {
            self.runtime_environment = input;
            self
        }
        /// <p>For a Kinesis Data Analytics for Apache Flink application, the mode is <code>STREAMING</code>. For a Kinesis Data Analytics Studio notebook, it is <code>INTERACTIVE</code>.</p>
        pub fn application_mode(mut self, input: crate::model::ApplicationMode) -> Self {
            self.application_mode = Some(input);
            self
        }
        /// <p>For a Kinesis Data Analytics for Apache Flink application, the mode is <code>STREAMING</code>. For a Kinesis Data Analytics Studio notebook, it is <code>INTERACTIVE</code>.</p>
        pub fn set_application_mode(
            mut self,
            input: std::option::Option<crate::model::ApplicationMode>,
        ) -> Self {
            self.application_mode = input;
            self
        }
        /// Consumes the builder and constructs a [`ApplicationSummary`](crate::model::ApplicationSummary)
        pub fn build(self) -> crate::model::ApplicationSummary {
            crate::model::ApplicationSummary {
                application_name: self.application_name,
                application_arn: self.application_arn,
                application_status: self.application_status,
                application_version_id: self.application_version_id,
                runtime_environment: self.runtime_environment,
                application_mode: self.application_mode,
            }
        }
    }
}
impl ApplicationSummary {
    /// Creates a new builder-style object to manufacture [`ApplicationSummary`](crate::model::ApplicationSummary)
    pub fn builder() -> crate::model::application_summary::Builder {
        crate::model::application_summary::Builder::default()
    }
}

/// <p>For a SQL-based Kinesis Data Analytics application, describes a processor that is
/// used to preprocess the records in the stream before being processed by your application code.
/// Currently, the only input processor available is <a href="https://docs.aws.amazon.com/lambda/">Amazon Lambda</a>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InputProcessingConfiguration {
    /// <p>The <a>InputLambdaProcessor</a> that is used to preprocess the records
    /// in the stream before being processed by your application code.</p>
    pub input_lambda_processor: std::option::Option<crate::model::InputLambdaProcessor>,
}
impl InputProcessingConfiguration {
    /// <p>The <a>InputLambdaProcessor</a> that is used to preprocess the records
    /// in the stream before being processed by your application code.</p>
    pub fn input_lambda_processor(
        &self,
    ) -> std::option::Option<&crate::model::InputLambdaProcessor> {
        self.input_lambda_processor.as_ref()
    }
}
impl std::fmt::Debug for InputProcessingConfiguration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InputProcessingConfiguration");
        formatter.field("input_lambda_processor", &self.input_lambda_processor);
        formatter.finish()
    }
}
/// See [`InputProcessingConfiguration`](crate::model::InputProcessingConfiguration)
pub mod input_processing_configuration {
    /// A builder for [`InputProcessingConfiguration`](crate::model::InputProcessingConfiguration)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) input_lambda_processor: std::option::Option<crate::model::InputLambdaProcessor>,
    }
    impl Builder {
        /// <p>The <a>InputLambdaProcessor</a> that is used to preprocess the records
        /// in the stream before being processed by your application code.</p>
        pub fn input_lambda_processor(mut self, input: crate::model::InputLambdaProcessor) -> Self {
            self.input_lambda_processor = Some(input);
            self
        }
        /// <p>The <a>InputLambdaProcessor</a> that is used to preprocess the records
        /// in the stream before being processed by your application code.</p>
        pub fn set_input_lambda_processor(
            mut self,
            input: std::option::Option<crate::model::InputLambdaProcessor>,
        ) -> Self {
            self.input_lambda_processor = input;
            self
        }
        /// Consumes the builder and constructs a [`InputProcessingConfiguration`](crate::model::InputProcessingConfiguration)
        pub fn build(self) -> crate::model::InputProcessingConfiguration {
            crate::model::InputProcessingConfiguration {
                input_lambda_processor: self.input_lambda_processor,
            }
        }
    }
}
impl InputProcessingConfiguration {
    /// Creates a new builder-style object to manufacture [`InputProcessingConfiguration`](crate::model::InputProcessingConfiguration)
    pub fn builder() -> crate::model::input_processing_configuration::Builder {
        crate::model::input_processing_configuration::Builder::default()
    }
}

/// <p>An object that contains the Amazon Resource Name (ARN) of the Amazon Lambda function that is
/// used to preprocess records in the stream in a SQL-based Kinesis Data Analytics application. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InputLambdaProcessor {
    /// <p>The ARN of the Amazon Lambda function that operates on records in the stream.</p>
    /// <note>
    /// <p>To specify an earlier version of the Lambda function than the latest, include the Lambda function version in the Lambda function ARN. For more information about Lambda ARNs, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html#arn-syntax-lambda">Example ARNs: Amazon Lambda</a>
    /// </p>
    /// </note>
    pub resource_arn: std::option::Option<std::string::String>,
}
impl InputLambdaProcessor {
    /// <p>The ARN of the Amazon Lambda function that operates on records in the stream.</p>
    /// <note>
    /// <p>To specify an earlier version of the Lambda function than the latest, include the Lambda function version in the Lambda function ARN. For more information about Lambda ARNs, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html#arn-syntax-lambda">Example ARNs: Amazon Lambda</a>
    /// </p>
    /// </note>
    pub fn resource_arn(&self) -> std::option::Option<&str> {
        self.resource_arn.as_deref()
    }
}
impl std::fmt::Debug for InputLambdaProcessor {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InputLambdaProcessor");
        formatter.field("resource_arn", &self.resource_arn);
        formatter.finish()
    }
}
/// See [`InputLambdaProcessor`](crate::model::InputLambdaProcessor)
pub mod input_lambda_processor {
    /// A builder for [`InputLambdaProcessor`](crate::model::InputLambdaProcessor)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) resource_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ARN of the Amazon Lambda function that operates on records in the stream.</p>
        /// <note>
        /// <p>To specify an earlier version of the Lambda function than the latest, include the Lambda function version in the Lambda function ARN. For more information about Lambda ARNs, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html#arn-syntax-lambda">Example ARNs: Amazon Lambda</a>
        /// </p>
        /// </note>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the Amazon Lambda function that operates on records in the stream.</p>
        /// <note>
        /// <p>To specify an earlier version of the Lambda function than the latest, include the Lambda function version in the Lambda function ARN. For more information about Lambda ARNs, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html#arn-syntax-lambda">Example ARNs: Amazon Lambda</a>
        /// </p>
        /// </note>
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.resource_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`InputLambdaProcessor`](crate::model::InputLambdaProcessor)
        pub fn build(self) -> crate::model::InputLambdaProcessor {
            crate::model::InputLambdaProcessor {
                resource_arn: self.resource_arn,
            }
        }
    }
}
impl InputLambdaProcessor {
    /// Creates a new builder-style object to manufacture [`InputLambdaProcessor`](crate::model::InputLambdaProcessor)
    pub fn builder() -> crate::model::input_lambda_processor::Builder {
        crate::model::input_lambda_processor::Builder::default()
    }
}

/// <p>For a SQL-based Kinesis Data Analytics application, provides a description of an
/// Amazon S3 data source, including the Amazon Resource Name (ARN) of the S3 bucket and the name
/// of the Amazon S3 object that contains the data.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct S3Configuration {
    /// <p>The ARN of the S3 bucket that contains the data.</p>
    pub bucket_arn: std::option::Option<std::string::String>,
    /// <p>The name of the object that contains the data.</p>
    pub file_key: std::option::Option<std::string::String>,
}
impl S3Configuration {
    /// <p>The ARN of the S3 bucket that contains the data.</p>
    pub fn bucket_arn(&self) -> std::option::Option<&str> {
        self.bucket_arn.as_deref()
    }
    /// <p>The name of the object that contains the data.</p>
    pub fn file_key(&self) -> std::option::Option<&str> {
        self.file_key.as_deref()
    }
}
impl std::fmt::Debug for S3Configuration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("S3Configuration");
        formatter.field("bucket_arn", &self.bucket_arn);
        formatter.field("file_key", &self.file_key);
        formatter.finish()
    }
}
/// See [`S3Configuration`](crate::model::S3Configuration)
pub mod s3_configuration {
    /// A builder for [`S3Configuration`](crate::model::S3Configuration)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) bucket_arn: std::option::Option<std::string::String>,
        pub(crate) file_key: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ARN of the S3 bucket that contains the data.</p>
        pub fn bucket_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.bucket_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the S3 bucket that contains the data.</p>
        pub fn set_bucket_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.bucket_arn = input;
            self
        }
        /// <p>The name of the object that contains the data.</p>
        pub fn file_key(mut self, input: impl Into<std::string::String>) -> Self {
            self.file_key = Some(input.into());
            self
        }
        /// <p>The name of the object that contains the data.</p>
        pub fn set_file_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.file_key = input;
            self
        }
        /// Consumes the builder and constructs a [`S3Configuration`](crate::model::S3Configuration)
        pub fn build(self) -> crate::model::S3Configuration {
            crate::model::S3Configuration {
                bucket_arn: self.bucket_arn,
                file_key: self.file_key,
            }
        }
    }
}
impl S3Configuration {
    /// Creates a new builder-style object to manufacture [`S3Configuration`](crate::model::S3Configuration)
    pub fn builder() -> crate::model::s3_configuration::Builder {
        crate::model::s3_configuration::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum UrlType {
    #[allow(missing_docs)] // documentation missing in model
    FlinkDashboardUrl,
    #[allow(missing_docs)] // documentation missing in model
    ZeppelinUiUrl,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for UrlType {
    fn from(s: &str) -> Self {
        match s {
            "FLINK_DASHBOARD_URL" => UrlType::FlinkDashboardUrl,
            "ZEPPELIN_UI_URL" => UrlType::ZeppelinUiUrl,
            other => UrlType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for UrlType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(UrlType::from(s))
    }
}
impl UrlType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            UrlType::FlinkDashboardUrl => "FLINK_DASHBOARD_URL",
            UrlType::ZeppelinUiUrl => "ZEPPELIN_UI_URL",
            UrlType::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["FLINK_DASHBOARD_URL", "ZEPPELIN_UI_URL"]
    }
}
impl AsRef<str> for UrlType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Provides a description of Amazon CloudWatch logging options, including the log stream
/// Amazon Resource Name (ARN). </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CloudWatchLoggingOption {
    /// <p>The ARN of the CloudWatch log to receive application messages.</p>
    pub log_stream_arn: std::option::Option<std::string::String>,
}
impl CloudWatchLoggingOption {
    /// <p>The ARN of the CloudWatch log to receive application messages.</p>
    pub fn log_stream_arn(&self) -> std::option::Option<&str> {
        self.log_stream_arn.as_deref()
    }
}
impl std::fmt::Debug for CloudWatchLoggingOption {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CloudWatchLoggingOption");
        formatter.field("log_stream_arn", &self.log_stream_arn);
        formatter.finish()
    }
}
/// See [`CloudWatchLoggingOption`](crate::model::CloudWatchLoggingOption)
pub mod cloud_watch_logging_option {
    /// A builder for [`CloudWatchLoggingOption`](crate::model::CloudWatchLoggingOption)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) log_stream_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ARN of the CloudWatch log to receive application messages.</p>
        pub fn log_stream_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.log_stream_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the CloudWatch log to receive application messages.</p>
        pub fn set_log_stream_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.log_stream_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`CloudWatchLoggingOption`](crate::model::CloudWatchLoggingOption)
        pub fn build(self) -> crate::model::CloudWatchLoggingOption {
            crate::model::CloudWatchLoggingOption {
                log_stream_arn: self.log_stream_arn,
            }
        }
    }
}
impl CloudWatchLoggingOption {
    /// Creates a new builder-style object to manufacture [`CloudWatchLoggingOption`](crate::model::CloudWatchLoggingOption)
    pub fn builder() -> crate::model::cloud_watch_logging_option::Builder {
        crate::model::cloud_watch_logging_option::Builder::default()
    }
}

/// <p>Specifies the creation parameters for a Kinesis Data Analytics application.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ApplicationConfiguration {
    /// <p>The creation and update parameters for a SQL-based Kinesis Data Analytics application.</p>
    pub sql_application_configuration:
        std::option::Option<crate::model::SqlApplicationConfiguration>,
    /// <p>The creation and update parameters for a Flink-based Kinesis Data Analytics application.</p>
    pub flink_application_configuration:
        std::option::Option<crate::model::FlinkApplicationConfiguration>,
    /// <p>Describes execution properties for a Flink-based Kinesis Data Analytics application.</p>
    pub environment_properties: std::option::Option<crate::model::EnvironmentProperties>,
    /// <p>The code location and type parameters for a Flink-based Kinesis Data Analytics application.</p>
    pub application_code_configuration:
        std::option::Option<crate::model::ApplicationCodeConfiguration>,
    /// <p>Describes whether snapshots are enabled for a Flink-based Kinesis Data Analytics application.</p>
    pub application_snapshot_configuration:
        std::option::Option<crate::model::ApplicationSnapshotConfiguration>,
    /// <p>The array of descriptions of VPC configurations available to the application.</p>
    pub vpc_configurations: std::option::Option<std::vec::Vec<crate::model::VpcConfiguration>>,
    /// <p>The configuration parameters for a Kinesis Data Analytics Studio notebook.</p>
    pub zeppelin_application_configuration:
        std::option::Option<crate::model::ZeppelinApplicationConfiguration>,
}
impl ApplicationConfiguration {
    /// <p>The creation and update parameters for a SQL-based Kinesis Data Analytics application.</p>
    pub fn sql_application_configuration(
        &self,
    ) -> std::option::Option<&crate::model::SqlApplicationConfiguration> {
        self.sql_application_configuration.as_ref()
    }
    /// <p>The creation and update parameters for a Flink-based Kinesis Data Analytics application.</p>
    pub fn flink_application_configuration(
        &self,
    ) -> std::option::Option<&crate::model::FlinkApplicationConfiguration> {
        self.flink_application_configuration.as_ref()
    }
    /// <p>Describes execution properties for a Flink-based Kinesis Data Analytics application.</p>
    pub fn environment_properties(
        &self,
    ) -> std::option::Option<&crate::model::EnvironmentProperties> {
        self.environment_properties.as_ref()
    }
    /// <p>The code location and type parameters for a Flink-based Kinesis Data Analytics application.</p>
    pub fn application_code_configuration(
        &self,
    ) -> std::option::Option<&crate::model::ApplicationCodeConfiguration> {
        self.application_code_configuration.as_ref()
    }
    /// <p>Describes whether snapshots are enabled for a Flink-based Kinesis Data Analytics application.</p>
    pub fn application_snapshot_configuration(
        &self,
    ) -> std::option::Option<&crate::model::ApplicationSnapshotConfiguration> {
        self.application_snapshot_configuration.as_ref()
    }
    /// <p>The array of descriptions of VPC configurations available to the application.</p>
    pub fn vpc_configurations(&self) -> std::option::Option<&[crate::model::VpcConfiguration]> {
        self.vpc_configurations.as_deref()
    }
    /// <p>The configuration parameters for a Kinesis Data Analytics Studio notebook.</p>
    pub fn zeppelin_application_configuration(
        &self,
    ) -> std::option::Option<&crate::model::ZeppelinApplicationConfiguration> {
        self.zeppelin_application_configuration.as_ref()
    }
}
impl std::fmt::Debug for ApplicationConfiguration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ApplicationConfiguration");
        formatter.field(
            "sql_application_configuration",
            &self.sql_application_configuration,
        );
        formatter.field(
            "flink_application_configuration",
            &self.flink_application_configuration,
        );
        formatter.field("environment_properties", &self.environment_properties);
        formatter.field(
            "application_code_configuration",
            &self.application_code_configuration,
        );
        formatter.field(
            "application_snapshot_configuration",
            &self.application_snapshot_configuration,
        );
        formatter.field("vpc_configurations", &self.vpc_configurations);
        formatter.field(
            "zeppelin_application_configuration",
            &self.zeppelin_application_configuration,
        );
        formatter.finish()
    }
}
/// See [`ApplicationConfiguration`](crate::model::ApplicationConfiguration)
pub mod application_configuration {
    /// A builder for [`ApplicationConfiguration`](crate::model::ApplicationConfiguration)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) sql_application_configuration:
            std::option::Option<crate::model::SqlApplicationConfiguration>,
        pub(crate) flink_application_configuration:
            std::option::Option<crate::model::FlinkApplicationConfiguration>,
        pub(crate) environment_properties: std::option::Option<crate::model::EnvironmentProperties>,
        pub(crate) application_code_configuration:
            std::option::Option<crate::model::ApplicationCodeConfiguration>,
        pub(crate) application_snapshot_configuration:
            std::option::Option<crate::model::ApplicationSnapshotConfiguration>,
        pub(crate) vpc_configurations:
            std::option::Option<std::vec::Vec<crate::model::VpcConfiguration>>,
        pub(crate) zeppelin_application_configuration:
            std::option::Option<crate::model::ZeppelinApplicationConfiguration>,
    }
    impl Builder {
        /// <p>The creation and update parameters for a SQL-based Kinesis Data Analytics application.</p>
        pub fn sql_application_configuration(
            mut self,
            input: crate::model::SqlApplicationConfiguration,
        ) -> Self {
            self.sql_application_configuration = Some(input);
            self
        }
        /// <p>The creation and update parameters for a SQL-based Kinesis Data Analytics application.</p>
        pub fn set_sql_application_configuration(
            mut self,
            input: std::option::Option<crate::model::SqlApplicationConfiguration>,
        ) -> Self {
            self.sql_application_configuration = input;
            self
        }
        /// <p>The creation and update parameters for a Flink-based Kinesis Data Analytics application.</p>
        pub fn flink_application_configuration(
            mut self,
            input: crate::model::FlinkApplicationConfiguration,
        ) -> Self {
            self.flink_application_configuration = Some(input);
            self
        }
        /// <p>The creation and update parameters for a Flink-based Kinesis Data Analytics application.</p>
        pub fn set_flink_application_configuration(
            mut self,
            input: std::option::Option<crate::model::FlinkApplicationConfiguration>,
        ) -> Self {
            self.flink_application_configuration = input;
            self
        }
        /// <p>Describes execution properties for a Flink-based Kinesis Data Analytics application.</p>
        pub fn environment_properties(
            mut self,
            input: crate::model::EnvironmentProperties,
        ) -> Self {
            self.environment_properties = Some(input);
            self
        }
        /// <p>Describes execution properties for a Flink-based Kinesis Data Analytics application.</p>
        pub fn set_environment_properties(
            mut self,
            input: std::option::Option<crate::model::EnvironmentProperties>,
        ) -> Self {
            self.environment_properties = input;
            self
        }
        /// <p>The code location and type parameters for a Flink-based Kinesis Data Analytics application.</p>
        pub fn application_code_configuration(
            mut self,
            input: crate::model::ApplicationCodeConfiguration,
        ) -> Self {
            self.application_code_configuration = Some(input);
            self
        }
        /// <p>The code location and type parameters for a Flink-based Kinesis Data Analytics application.</p>
        pub fn set_application_code_configuration(
            mut self,
            input: std::option::Option<crate::model::ApplicationCodeConfiguration>,
        ) -> Self {
            self.application_code_configuration = input;
            self
        }
        /// <p>Describes whether snapshots are enabled for a Flink-based Kinesis Data Analytics application.</p>
        pub fn application_snapshot_configuration(
            mut self,
            input: crate::model::ApplicationSnapshotConfiguration,
        ) -> Self {
            self.application_snapshot_configuration = Some(input);
            self
        }
        /// <p>Describes whether snapshots are enabled for a Flink-based Kinesis Data Analytics application.</p>
        pub fn set_application_snapshot_configuration(
            mut self,
            input: std::option::Option<crate::model::ApplicationSnapshotConfiguration>,
        ) -> Self {
            self.application_snapshot_configuration = input;
            self
        }
        /// Appends an item to `vpc_configurations`.
        ///
        /// To override the contents of this collection use [`set_vpc_configurations`](Self::set_vpc_configurations).
        ///
        /// <p>The array of descriptions of VPC configurations available to the application.</p>
        pub fn vpc_configurations(
            mut self,
            input: impl Into<crate::model::VpcConfiguration>,
        ) -> Self {
            let mut v = self.vpc_configurations.unwrap_or_default();
            v.push(input.into());
            self.vpc_configurations = Some(v);
            self
        }
        /// <p>The array of descriptions of VPC configurations available to the application.</p>
        pub fn set_vpc_configurations(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::VpcConfiguration>>,
        ) -> Self {
            self.vpc_configurations = input;
            self
        }
        /// <p>The configuration parameters for a Kinesis Data Analytics Studio notebook.</p>
        pub fn zeppelin_application_configuration(
            mut self,
            input: crate::model::ZeppelinApplicationConfiguration,
        ) -> Self {
            self.zeppelin_application_configuration = Some(input);
            self
        }
        /// <p>The configuration parameters for a Kinesis Data Analytics Studio notebook.</p>
        pub fn set_zeppelin_application_configuration(
            mut self,
            input: std::option::Option<crate::model::ZeppelinApplicationConfiguration>,
        ) -> Self {
            self.zeppelin_application_configuration = input;
            self
        }
        /// Consumes the builder and constructs a [`ApplicationConfiguration`](crate::model::ApplicationConfiguration)
        pub fn build(self) -> crate::model::ApplicationConfiguration {
            crate::model::ApplicationConfiguration {
                sql_application_configuration: self.sql_application_configuration,
                flink_application_configuration: self.flink_application_configuration,
                environment_properties: self.environment_properties,
                application_code_configuration: self.application_code_configuration,
                application_snapshot_configuration: self.application_snapshot_configuration,
                vpc_configurations: self.vpc_configurations,
                zeppelin_application_configuration: self.zeppelin_application_configuration,
            }
        }
    }
}
impl ApplicationConfiguration {
    /// Creates a new builder-style object to manufacture [`ApplicationConfiguration`](crate::model::ApplicationConfiguration)
    pub fn builder() -> crate::model::application_configuration::Builder {
        crate::model::application_configuration::Builder::default()
    }
}

/// <p>The configuration of a Kinesis Data Analytics Studio notebook.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ZeppelinApplicationConfiguration {
    /// <p>The monitoring configuration of a Kinesis Data Analytics Studio notebook.</p>
    pub monitoring_configuration:
        std::option::Option<crate::model::ZeppelinMonitoringConfiguration>,
    /// <p>The Amazon Glue Data Catalog that you use in queries in a Kinesis Data Analytics Studio notebook.</p>
    pub catalog_configuration: std::option::Option<crate::model::CatalogConfiguration>,
    /// <p>The information required to deploy a Kinesis Data Analytics Studio notebook as an application with durable state.</p>
    pub deploy_as_application_configuration:
        std::option::Option<crate::model::DeployAsApplicationConfiguration>,
    /// <p>Custom artifacts are dependency JARs and user-defined functions (UDF).</p>
    pub custom_artifacts_configuration:
        std::option::Option<std::vec::Vec<crate::model::CustomArtifactConfiguration>>,
}
impl ZeppelinApplicationConfiguration {
    /// <p>The monitoring configuration of a Kinesis Data Analytics Studio notebook.</p>
    pub fn monitoring_configuration(
        &self,
    ) -> std::option::Option<&crate::model::ZeppelinMonitoringConfiguration> {
        self.monitoring_configuration.as_ref()
    }
    /// <p>The Amazon Glue Data Catalog that you use in queries in a Kinesis Data Analytics Studio notebook.</p>
    pub fn catalog_configuration(
        &self,
    ) -> std::option::Option<&crate::model::CatalogConfiguration> {
        self.catalog_configuration.as_ref()
    }
    /// <p>The information required to deploy a Kinesis Data Analytics Studio notebook as an application with durable state.</p>
    pub fn deploy_as_application_configuration(
        &self,
    ) -> std::option::Option<&crate::model::DeployAsApplicationConfiguration> {
        self.deploy_as_application_configuration.as_ref()
    }
    /// <p>Custom artifacts are dependency JARs and user-defined functions (UDF).</p>
    pub fn custom_artifacts_configuration(
        &self,
    ) -> std::option::Option<&[crate::model::CustomArtifactConfiguration]> {
        self.custom_artifacts_configuration.as_deref()
    }
}
impl std::fmt::Debug for ZeppelinApplicationConfiguration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ZeppelinApplicationConfiguration");
        formatter.field("monitoring_configuration", &self.monitoring_configuration);
        formatter.field("catalog_configuration", &self.catalog_configuration);
        formatter.field(
            "deploy_as_application_configuration",
            &self.deploy_as_application_configuration,
        );
        formatter.field(
            "custom_artifacts_configuration",
            &self.custom_artifacts_configuration,
        );
        formatter.finish()
    }
}
/// See [`ZeppelinApplicationConfiguration`](crate::model::ZeppelinApplicationConfiguration)
pub mod zeppelin_application_configuration {
    /// A builder for [`ZeppelinApplicationConfiguration`](crate::model::ZeppelinApplicationConfiguration)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) monitoring_configuration:
            std::option::Option<crate::model::ZeppelinMonitoringConfiguration>,
        pub(crate) catalog_configuration: std::option::Option<crate::model::CatalogConfiguration>,
        pub(crate) deploy_as_application_configuration:
            std::option::Option<crate::model::DeployAsApplicationConfiguration>,
        pub(crate) custom_artifacts_configuration:
            std::option::Option<std::vec::Vec<crate::model::CustomArtifactConfiguration>>,
    }
    impl Builder {
        /// <p>The monitoring configuration of a Kinesis Data Analytics Studio notebook.</p>
        pub fn monitoring_configuration(
            mut self,
            input: crate::model::ZeppelinMonitoringConfiguration,
        ) -> Self {
            self.monitoring_configuration = Some(input);
            self
        }
        /// <p>The monitoring configuration of a Kinesis Data Analytics Studio notebook.</p>
        pub fn set_monitoring_configuration(
            mut self,
            input: std::option::Option<crate::model::ZeppelinMonitoringConfiguration>,
        ) -> Self {
            self.monitoring_configuration = input;
            self
        }
        /// <p>The Amazon Glue Data Catalog that you use in queries in a Kinesis Data Analytics Studio notebook.</p>
        pub fn catalog_configuration(mut self, input: crate::model::CatalogConfiguration) -> Self {
            self.catalog_configuration = Some(input);
            self
        }
        /// <p>The Amazon Glue Data Catalog that you use in queries in a Kinesis Data Analytics Studio notebook.</p>
        pub fn set_catalog_configuration(
            mut self,
            input: std::option::Option<crate::model::CatalogConfiguration>,
        ) -> Self {
            self.catalog_configuration = input;
            self
        }
        /// <p>The information required to deploy a Kinesis Data Analytics Studio notebook as an application with durable state.</p>
        pub fn deploy_as_application_configuration(
            mut self,
            input: crate::model::DeployAsApplicationConfiguration,
        ) -> Self {
            self.deploy_as_application_configuration = Some(input);
            self
        }
        /// <p>The information required to deploy a Kinesis Data Analytics Studio notebook as an application with durable state.</p>
        pub fn set_deploy_as_application_configuration(
            mut self,
            input: std::option::Option<crate::model::DeployAsApplicationConfiguration>,
        ) -> Self {
            self.deploy_as_application_configuration = input;
            self
        }
        /// Appends an item to `custom_artifacts_configuration`.
        ///
        /// To override the contents of this collection use [`set_custom_artifacts_configuration`](Self::set_custom_artifacts_configuration).
        ///
        /// <p>Custom artifacts are dependency JARs and user-defined functions (UDF).</p>
        pub fn custom_artifacts_configuration(
            mut self,
            input: impl Into<crate::model::CustomArtifactConfiguration>,
        ) -> Self {
            let mut v = self.custom_artifacts_configuration.unwrap_or_default();
            v.push(input.into());
            self.custom_artifacts_configuration = Some(v);
            self
        }
        /// <p>Custom artifacts are dependency JARs and user-defined functions (UDF).</p>
        pub fn set_custom_artifacts_configuration(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::CustomArtifactConfiguration>>,
        ) -> Self {
            self.custom_artifacts_configuration = input;
            self
        }
        /// Consumes the builder and constructs a [`ZeppelinApplicationConfiguration`](crate::model::ZeppelinApplicationConfiguration)
        pub fn build(self) -> crate::model::ZeppelinApplicationConfiguration {
            crate::model::ZeppelinApplicationConfiguration {
                monitoring_configuration: self.monitoring_configuration,
                catalog_configuration: self.catalog_configuration,
                deploy_as_application_configuration: self.deploy_as_application_configuration,
                custom_artifacts_configuration: self.custom_artifacts_configuration,
            }
        }
    }
}
impl ZeppelinApplicationConfiguration {
    /// Creates a new builder-style object to manufacture [`ZeppelinApplicationConfiguration`](crate::model::ZeppelinApplicationConfiguration)
    pub fn builder() -> crate::model::zeppelin_application_configuration::Builder {
        crate::model::zeppelin_application_configuration::Builder::default()
    }
}

/// <p>The information required to deploy a Kinesis Data Analytics Studio notebook as an application with durable state.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeployAsApplicationConfiguration {
    /// <p>The description of an Amazon S3 object that contains the Amazon Data Analytics application, including the Amazon Resource Name (ARN) of the S3 bucket, the name of the Amazon S3 object that contains the data, and the version number of the Amazon S3 object that contains the data.    
    /// </p>
    pub s3_content_location: std::option::Option<crate::model::S3ContentBaseLocation>,
}
impl DeployAsApplicationConfiguration {
    /// <p>The description of an Amazon S3 object that contains the Amazon Data Analytics application, including the Amazon Resource Name (ARN) of the S3 bucket, the name of the Amazon S3 object that contains the data, and the version number of the Amazon S3 object that contains the data.    
    /// </p>
    pub fn s3_content_location(&self) -> std::option::Option<&crate::model::S3ContentBaseLocation> {
        self.s3_content_location.as_ref()
    }
}
impl std::fmt::Debug for DeployAsApplicationConfiguration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeployAsApplicationConfiguration");
        formatter.field("s3_content_location", &self.s3_content_location);
        formatter.finish()
    }
}
/// See [`DeployAsApplicationConfiguration`](crate::model::DeployAsApplicationConfiguration)
pub mod deploy_as_application_configuration {
    /// A builder for [`DeployAsApplicationConfiguration`](crate::model::DeployAsApplicationConfiguration)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) s3_content_location: std::option::Option<crate::model::S3ContentBaseLocation>,
    }
    impl Builder {
        /// <p>The description of an Amazon S3 object that contains the Amazon Data Analytics application, including the Amazon Resource Name (ARN) of the S3 bucket, the name of the Amazon S3 object that contains the data, and the version number of the Amazon S3 object that contains the data.    
        /// </p>
        pub fn s3_content_location(mut self, input: crate::model::S3ContentBaseLocation) -> Self {
            self.s3_content_location = Some(input);
            self
        }
        /// <p>The description of an Amazon S3 object that contains the Amazon Data Analytics application, including the Amazon Resource Name (ARN) of the S3 bucket, the name of the Amazon S3 object that contains the data, and the version number of the Amazon S3 object that contains the data.    
        /// </p>
        pub fn set_s3_content_location(
            mut self,
            input: std::option::Option<crate::model::S3ContentBaseLocation>,
        ) -> Self {
            self.s3_content_location = input;
            self
        }
        /// Consumes the builder and constructs a [`DeployAsApplicationConfiguration`](crate::model::DeployAsApplicationConfiguration)
        pub fn build(self) -> crate::model::DeployAsApplicationConfiguration {
            crate::model::DeployAsApplicationConfiguration {
                s3_content_location: self.s3_content_location,
            }
        }
    }
}
impl DeployAsApplicationConfiguration {
    /// Creates a new builder-style object to manufacture [`DeployAsApplicationConfiguration`](crate::model::DeployAsApplicationConfiguration)
    pub fn builder() -> crate::model::deploy_as_application_configuration::Builder {
        crate::model::deploy_as_application_configuration::Builder::default()
    }
}

/// <p>The S3 bucket that holds the application information.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct S3ContentBaseLocation {
    /// <p>The Amazon Resource Name (ARN) of the S3 bucket.</p>
    pub bucket_arn: std::option::Option<std::string::String>,
    /// <p>The base path for the S3 bucket.</p>
    pub base_path: std::option::Option<std::string::String>,
}
impl S3ContentBaseLocation {
    /// <p>The Amazon Resource Name (ARN) of the S3 bucket.</p>
    pub fn bucket_arn(&self) -> std::option::Option<&str> {
        self.bucket_arn.as_deref()
    }
    /// <p>The base path for the S3 bucket.</p>
    pub fn base_path(&self) -> std::option::Option<&str> {
        self.base_path.as_deref()
    }
}
impl std::fmt::Debug for S3ContentBaseLocation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("S3ContentBaseLocation");
        formatter.field("bucket_arn", &self.bucket_arn);
        formatter.field("base_path", &self.base_path);
        formatter.finish()
    }
}
/// See [`S3ContentBaseLocation`](crate::model::S3ContentBaseLocation)
pub mod s3_content_base_location {
    /// A builder for [`S3ContentBaseLocation`](crate::model::S3ContentBaseLocation)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) bucket_arn: std::option::Option<std::string::String>,
        pub(crate) base_path: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the S3 bucket.</p>
        pub fn bucket_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.bucket_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the S3 bucket.</p>
        pub fn set_bucket_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.bucket_arn = input;
            self
        }
        /// <p>The base path for the S3 bucket.</p>
        pub fn base_path(mut self, input: impl Into<std::string::String>) -> Self {
            self.base_path = Some(input.into());
            self
        }
        /// <p>The base path for the S3 bucket.</p>
        pub fn set_base_path(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.base_path = input;
            self
        }
        /// Consumes the builder and constructs a [`S3ContentBaseLocation`](crate::model::S3ContentBaseLocation)
        pub fn build(self) -> crate::model::S3ContentBaseLocation {
            crate::model::S3ContentBaseLocation {
                bucket_arn: self.bucket_arn,
                base_path: self.base_path,
            }
        }
    }
}
impl S3ContentBaseLocation {
    /// Creates a new builder-style object to manufacture [`S3ContentBaseLocation`](crate::model::S3ContentBaseLocation)
    pub fn builder() -> crate::model::s3_content_base_location::Builder {
        crate::model::s3_content_base_location::Builder::default()
    }
}

/// <p>The configuration parameters for the default Amazon Glue database. You use this database for SQL queries that you write in a Kinesis Data Analytics Studio notebook.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CatalogConfiguration {
    /// <p>The configuration parameters for the default Amazon Glue database. You use this database for Apache Flink SQL queries and table API transforms that you write in a Kinesis Data Analytics Studio notebook.</p>
    pub glue_data_catalog_configuration:
        std::option::Option<crate::model::GlueDataCatalogConfiguration>,
}
impl CatalogConfiguration {
    /// <p>The configuration parameters for the default Amazon Glue database. You use this database for Apache Flink SQL queries and table API transforms that you write in a Kinesis Data Analytics Studio notebook.</p>
    pub fn glue_data_catalog_configuration(
        &self,
    ) -> std::option::Option<&crate::model::GlueDataCatalogConfiguration> {
        self.glue_data_catalog_configuration.as_ref()
    }
}
impl std::fmt::Debug for CatalogConfiguration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CatalogConfiguration");
        formatter.field(
            "glue_data_catalog_configuration",
            &self.glue_data_catalog_configuration,
        );
        formatter.finish()
    }
}
/// See [`CatalogConfiguration`](crate::model::CatalogConfiguration)
pub mod catalog_configuration {
    /// A builder for [`CatalogConfiguration`](crate::model::CatalogConfiguration)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) glue_data_catalog_configuration:
            std::option::Option<crate::model::GlueDataCatalogConfiguration>,
    }
    impl Builder {
        /// <p>The configuration parameters for the default Amazon Glue database. You use this database for Apache Flink SQL queries and table API transforms that you write in a Kinesis Data Analytics Studio notebook.</p>
        pub fn glue_data_catalog_configuration(
            mut self,
            input: crate::model::GlueDataCatalogConfiguration,
        ) -> Self {
            self.glue_data_catalog_configuration = Some(input);
            self
        }
        /// <p>The configuration parameters for the default Amazon Glue database. You use this database for Apache Flink SQL queries and table API transforms that you write in a Kinesis Data Analytics Studio notebook.</p>
        pub fn set_glue_data_catalog_configuration(
            mut self,
            input: std::option::Option<crate::model::GlueDataCatalogConfiguration>,
        ) -> Self {
            self.glue_data_catalog_configuration = input;
            self
        }
        /// Consumes the builder and constructs a [`CatalogConfiguration`](crate::model::CatalogConfiguration)
        pub fn build(self) -> crate::model::CatalogConfiguration {
            crate::model::CatalogConfiguration {
                glue_data_catalog_configuration: self.glue_data_catalog_configuration,
            }
        }
    }
}
impl CatalogConfiguration {
    /// Creates a new builder-style object to manufacture [`CatalogConfiguration`](crate::model::CatalogConfiguration)
    pub fn builder() -> crate::model::catalog_configuration::Builder {
        crate::model::catalog_configuration::Builder::default()
    }
}

/// <p>The configuration of the Glue Data Catalog that you use for Apache Flink SQL queries and table API transforms that you write in an application.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GlueDataCatalogConfiguration {
    /// <p>The Amazon Resource Name (ARN) of the database.</p>
    pub database_arn: std::option::Option<std::string::String>,
}
impl GlueDataCatalogConfiguration {
    /// <p>The Amazon Resource Name (ARN) of the database.</p>
    pub fn database_arn(&self) -> std::option::Option<&str> {
        self.database_arn.as_deref()
    }
}
impl std::fmt::Debug for GlueDataCatalogConfiguration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GlueDataCatalogConfiguration");
        formatter.field("database_arn", &self.database_arn);
        formatter.finish()
    }
}
/// See [`GlueDataCatalogConfiguration`](crate::model::GlueDataCatalogConfiguration)
pub mod glue_data_catalog_configuration {
    /// A builder for [`GlueDataCatalogConfiguration`](crate::model::GlueDataCatalogConfiguration)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) database_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the database.</p>
        pub fn database_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.database_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the database.</p>
        pub fn set_database_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.database_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`GlueDataCatalogConfiguration`](crate::model::GlueDataCatalogConfiguration)
        pub fn build(self) -> crate::model::GlueDataCatalogConfiguration {
            crate::model::GlueDataCatalogConfiguration {
                database_arn: self.database_arn,
            }
        }
    }
}
impl GlueDataCatalogConfiguration {
    /// Creates a new builder-style object to manufacture [`GlueDataCatalogConfiguration`](crate::model::GlueDataCatalogConfiguration)
    pub fn builder() -> crate::model::glue_data_catalog_configuration::Builder {
        crate::model::glue_data_catalog_configuration::Builder::default()
    }
}

/// <p>Describes configuration parameters for Amazon CloudWatch logging for a Kinesis Data Analytics Studio notebook. For more information about CloudWatch logging, see <a href="https://docs.aws.amazon.com/kinesisanalytics/latest/java/monitoring-overview.html">Monitoring</a>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ZeppelinMonitoringConfiguration {
    /// <p>The verbosity of the CloudWatch Logs for an application.</p>
    pub log_level: std::option::Option<crate::model::LogLevel>,
}
impl ZeppelinMonitoringConfiguration {
    /// <p>The verbosity of the CloudWatch Logs for an application.</p>
    pub fn log_level(&self) -> std::option::Option<&crate::model::LogLevel> {
        self.log_level.as_ref()
    }
}
impl std::fmt::Debug for ZeppelinMonitoringConfiguration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ZeppelinMonitoringConfiguration");
        formatter.field("log_level", &self.log_level);
        formatter.finish()
    }
}
/// See [`ZeppelinMonitoringConfiguration`](crate::model::ZeppelinMonitoringConfiguration)
pub mod zeppelin_monitoring_configuration {
    /// A builder for [`ZeppelinMonitoringConfiguration`](crate::model::ZeppelinMonitoringConfiguration)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) log_level: std::option::Option<crate::model::LogLevel>,
    }
    impl Builder {
        /// <p>The verbosity of the CloudWatch Logs for an application.</p>
        pub fn log_level(mut self, input: crate::model::LogLevel) -> Self {
            self.log_level = Some(input);
            self
        }
        /// <p>The verbosity of the CloudWatch Logs for an application.</p>
        pub fn set_log_level(mut self, input: std::option::Option<crate::model::LogLevel>) -> Self {
            self.log_level = input;
            self
        }
        /// Consumes the builder and constructs a [`ZeppelinMonitoringConfiguration`](crate::model::ZeppelinMonitoringConfiguration)
        pub fn build(self) -> crate::model::ZeppelinMonitoringConfiguration {
            crate::model::ZeppelinMonitoringConfiguration {
                log_level: self.log_level,
            }
        }
    }
}
impl ZeppelinMonitoringConfiguration {
    /// Creates a new builder-style object to manufacture [`ZeppelinMonitoringConfiguration`](crate::model::ZeppelinMonitoringConfiguration)
    pub fn builder() -> crate::model::zeppelin_monitoring_configuration::Builder {
        crate::model::zeppelin_monitoring_configuration::Builder::default()
    }
}

/// <p>Describes the parameters of a VPC used by the application.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct VpcConfiguration {
    /// <p>The array of <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_Subnet.html">Subnet</a> IDs
    /// used by the VPC configuration.</p>
    pub subnet_ids: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The array of <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_SecurityGroup.html">SecurityGroup</a>
    /// IDs used by the VPC configuration.</p>
    pub security_group_ids: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl VpcConfiguration {
    /// <p>The array of <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_Subnet.html">Subnet</a> IDs
    /// used by the VPC configuration.</p>
    pub fn subnet_ids(&self) -> std::option::Option<&[std::string::String]> {
        self.subnet_ids.as_deref()
    }
    /// <p>The array of <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_SecurityGroup.html">SecurityGroup</a>
    /// IDs used by the VPC configuration.</p>
    pub fn security_group_ids(&self) -> std::option::Option<&[std::string::String]> {
        self.security_group_ids.as_deref()
    }
}
impl std::fmt::Debug for VpcConfiguration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("VpcConfiguration");
        formatter.field("subnet_ids", &self.subnet_ids);
        formatter.field("security_group_ids", &self.security_group_ids);
        formatter.finish()
    }
}
/// See [`VpcConfiguration`](crate::model::VpcConfiguration)
pub mod vpc_configuration {
    /// A builder for [`VpcConfiguration`](crate::model::VpcConfiguration)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) subnet_ids: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) security_group_ids: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// Appends an item to `subnet_ids`.
        ///
        /// To override the contents of this collection use [`set_subnet_ids`](Self::set_subnet_ids).
        ///
        /// <p>The array of <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_Subnet.html">Subnet</a> IDs
        /// used by the VPC configuration.</p>
        pub fn subnet_ids(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.subnet_ids.unwrap_or_default();
            v.push(input.into());
            self.subnet_ids = Some(v);
            self
        }
        /// <p>The array of <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_Subnet.html">Subnet</a> IDs
        /// used by the VPC configuration.</p>
        pub fn set_subnet_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.subnet_ids = input;
            self
        }
        /// Appends an item to `security_group_ids`.
        ///
        /// To override the contents of this collection use [`set_security_group_ids`](Self::set_security_group_ids).
        ///
        /// <p>The array of <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_SecurityGroup.html">SecurityGroup</a>
        /// IDs used by the VPC configuration.</p>
        pub fn security_group_ids(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.security_group_ids.unwrap_or_default();
            v.push(input.into());
            self.security_group_ids = Some(v);
            self
        }
        /// <p>The array of <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_SecurityGroup.html">SecurityGroup</a>
        /// IDs used by the VPC configuration.</p>
        pub fn set_security_group_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.security_group_ids = input;
            self
        }
        /// Consumes the builder and constructs a [`VpcConfiguration`](crate::model::VpcConfiguration)
        pub fn build(self) -> crate::model::VpcConfiguration {
            crate::model::VpcConfiguration {
                subnet_ids: self.subnet_ids,
                security_group_ids: self.security_group_ids,
            }
        }
    }
}
impl VpcConfiguration {
    /// Creates a new builder-style object to manufacture [`VpcConfiguration`](crate::model::VpcConfiguration)
    pub fn builder() -> crate::model::vpc_configuration::Builder {
        crate::model::vpc_configuration::Builder::default()
    }
}

/// <p>Describes whether snapshots are enabled for a Flink-based Kinesis Data Analytics application.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ApplicationSnapshotConfiguration {
    /// <p>Describes whether snapshots are enabled for a Flink-based Kinesis Data Analytics application.</p>
    pub snapshots_enabled: std::option::Option<bool>,
}
impl ApplicationSnapshotConfiguration {
    /// <p>Describes whether snapshots are enabled for a Flink-based Kinesis Data Analytics application.</p>
    pub fn snapshots_enabled(&self) -> std::option::Option<bool> {
        self.snapshots_enabled
    }
}
impl std::fmt::Debug for ApplicationSnapshotConfiguration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ApplicationSnapshotConfiguration");
        formatter.field("snapshots_enabled", &self.snapshots_enabled);
        formatter.finish()
    }
}
/// See [`ApplicationSnapshotConfiguration`](crate::model::ApplicationSnapshotConfiguration)
pub mod application_snapshot_configuration {
    /// A builder for [`ApplicationSnapshotConfiguration`](crate::model::ApplicationSnapshotConfiguration)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) snapshots_enabled: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>Describes whether snapshots are enabled for a Flink-based Kinesis Data Analytics application.</p>
        pub fn snapshots_enabled(mut self, input: bool) -> Self {
            self.snapshots_enabled = Some(input);
            self
        }
        /// <p>Describes whether snapshots are enabled for a Flink-based Kinesis Data Analytics application.</p>
        pub fn set_snapshots_enabled(mut self, input: std::option::Option<bool>) -> Self {
            self.snapshots_enabled = input;
            self
        }
        /// Consumes the builder and constructs a [`ApplicationSnapshotConfiguration`](crate::model::ApplicationSnapshotConfiguration)
        pub fn build(self) -> crate::model::ApplicationSnapshotConfiguration {
            crate::model::ApplicationSnapshotConfiguration {
                snapshots_enabled: self.snapshots_enabled,
            }
        }
    }
}
impl ApplicationSnapshotConfiguration {
    /// Creates a new builder-style object to manufacture [`ApplicationSnapshotConfiguration`](crate::model::ApplicationSnapshotConfiguration)
    pub fn builder() -> crate::model::application_snapshot_configuration::Builder {
        crate::model::application_snapshot_configuration::Builder::default()
    }
}

/// <p>Describes code configuration for an application.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ApplicationCodeConfiguration {
    /// <p>The location and type of the application code.</p>
    pub code_content: std::option::Option<crate::model::CodeContent>,
    /// <p>Specifies whether the code content is in text or zip format.</p>
    pub code_content_type: std::option::Option<crate::model::CodeContentType>,
}
impl ApplicationCodeConfiguration {
    /// <p>The location and type of the application code.</p>
    pub fn code_content(&self) -> std::option::Option<&crate::model::CodeContent> {
        self.code_content.as_ref()
    }
    /// <p>Specifies whether the code content is in text or zip format.</p>
    pub fn code_content_type(&self) -> std::option::Option<&crate::model::CodeContentType> {
        self.code_content_type.as_ref()
    }
}
impl std::fmt::Debug for ApplicationCodeConfiguration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ApplicationCodeConfiguration");
        formatter.field("code_content", &self.code_content);
        formatter.field("code_content_type", &self.code_content_type);
        formatter.finish()
    }
}
/// See [`ApplicationCodeConfiguration`](crate::model::ApplicationCodeConfiguration)
pub mod application_code_configuration {
    /// A builder for [`ApplicationCodeConfiguration`](crate::model::ApplicationCodeConfiguration)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) code_content: std::option::Option<crate::model::CodeContent>,
        pub(crate) code_content_type: std::option::Option<crate::model::CodeContentType>,
    }
    impl Builder {
        /// <p>The location and type of the application code.</p>
        pub fn code_content(mut self, input: crate::model::CodeContent) -> Self {
            self.code_content = Some(input);
            self
        }
        /// <p>The location and type of the application code.</p>
        pub fn set_code_content(
            mut self,
            input: std::option::Option<crate::model::CodeContent>,
        ) -> Self {
            self.code_content = input;
            self
        }
        /// <p>Specifies whether the code content is in text or zip format.</p>
        pub fn code_content_type(mut self, input: crate::model::CodeContentType) -> Self {
            self.code_content_type = Some(input);
            self
        }
        /// <p>Specifies whether the code content is in text or zip format.</p>
        pub fn set_code_content_type(
            mut self,
            input: std::option::Option<crate::model::CodeContentType>,
        ) -> Self {
            self.code_content_type = input;
            self
        }
        /// Consumes the builder and constructs a [`ApplicationCodeConfiguration`](crate::model::ApplicationCodeConfiguration)
        pub fn build(self) -> crate::model::ApplicationCodeConfiguration {
            crate::model::ApplicationCodeConfiguration {
                code_content: self.code_content,
                code_content_type: self.code_content_type,
            }
        }
    }
}
impl ApplicationCodeConfiguration {
    /// Creates a new builder-style object to manufacture [`ApplicationCodeConfiguration`](crate::model::ApplicationCodeConfiguration)
    pub fn builder() -> crate::model::application_code_configuration::Builder {
        crate::model::application_code_configuration::Builder::default()
    }
}

/// <p>Specifies either the application code, or the location of the application code, for a
/// Flink-based Kinesis Data Analytics application. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CodeContent {
    /// <p>The text-format code for a Flink-based Kinesis Data Analytics application.</p>
    pub text_content: std::option::Option<std::string::String>,
    /// <p>The zip-format code for a Flink-based Kinesis Data Analytics application.</p>
    pub zip_file_content: std::option::Option<aws_smithy_types::Blob>,
    /// <p>Information about the Amazon S3 bucket that contains the application code.</p>
    pub s3_content_location: std::option::Option<crate::model::S3ContentLocation>,
}
impl CodeContent {
    /// <p>The text-format code for a Flink-based Kinesis Data Analytics application.</p>
    pub fn text_content(&self) -> std::option::Option<&str> {
        self.text_content.as_deref()
    }
    /// <p>The zip-format code for a Flink-based Kinesis Data Analytics application.</p>
    pub fn zip_file_content(&self) -> std::option::Option<&aws_smithy_types::Blob> {
        self.zip_file_content.as_ref()
    }
    /// <p>Information about the Amazon S3 bucket that contains the application code.</p>
    pub fn s3_content_location(&self) -> std::option::Option<&crate::model::S3ContentLocation> {
        self.s3_content_location.as_ref()
    }
}
impl std::fmt::Debug for CodeContent {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CodeContent");
        formatter.field("text_content", &self.text_content);
        formatter.field("zip_file_content", &self.zip_file_content);
        formatter.field("s3_content_location", &self.s3_content_location);
        formatter.finish()
    }
}
/// See [`CodeContent`](crate::model::CodeContent)
pub mod code_content {
    /// A builder for [`CodeContent`](crate::model::CodeContent)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) text_content: std::option::Option<std::string::String>,
        pub(crate) zip_file_content: std::option::Option<aws_smithy_types::Blob>,
        pub(crate) s3_content_location: std::option::Option<crate::model::S3ContentLocation>,
    }
    impl Builder {
        /// <p>The text-format code for a Flink-based Kinesis Data Analytics application.</p>
        pub fn text_content(mut self, input: impl Into<std::string::String>) -> Self {
            self.text_content = Some(input.into());
            self
        }
        /// <p>The text-format code for a Flink-based Kinesis Data Analytics application.</p>
        pub fn set_text_content(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.text_content = input;
            self
        }
        /// <p>The zip-format code for a Flink-based Kinesis Data Analytics application.</p>
        pub fn zip_file_content(mut self, input: aws_smithy_types::Blob) -> Self {
            self.zip_file_content = Some(input);
            self
        }
        /// <p>The zip-format code for a Flink-based Kinesis Data Analytics application.</p>
        pub fn set_zip_file_content(
            mut self,
            input: std::option::Option<aws_smithy_types::Blob>,
        ) -> Self {
            self.zip_file_content = input;
            self
        }
        /// <p>Information about the Amazon S3 bucket that contains the application code.</p>
        pub fn s3_content_location(mut self, input: crate::model::S3ContentLocation) -> Self {
            self.s3_content_location = Some(input);
            self
        }
        /// <p>Information about the Amazon S3 bucket that contains the application code.</p>
        pub fn set_s3_content_location(
            mut self,
            input: std::option::Option<crate::model::S3ContentLocation>,
        ) -> Self {
            self.s3_content_location = input;
            self
        }
        /// Consumes the builder and constructs a [`CodeContent`](crate::model::CodeContent)
        pub fn build(self) -> crate::model::CodeContent {
            crate::model::CodeContent {
                text_content: self.text_content,
                zip_file_content: self.zip_file_content,
                s3_content_location: self.s3_content_location,
            }
        }
    }
}
impl CodeContent {
    /// Creates a new builder-style object to manufacture [`CodeContent`](crate::model::CodeContent)
    pub fn builder() -> crate::model::code_content::Builder {
        crate::model::code_content::Builder::default()
    }
}

/// <p>Describes execution properties for a Flink-based Kinesis Data Analytics application.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct EnvironmentProperties {
    /// <p>Describes the execution property groups.</p>
    pub property_groups: std::option::Option<std::vec::Vec<crate::model::PropertyGroup>>,
}
impl EnvironmentProperties {
    /// <p>Describes the execution property groups.</p>
    pub fn property_groups(&self) -> std::option::Option<&[crate::model::PropertyGroup]> {
        self.property_groups.as_deref()
    }
}
impl std::fmt::Debug for EnvironmentProperties {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("EnvironmentProperties");
        formatter.field("property_groups", &self.property_groups);
        formatter.finish()
    }
}
/// See [`EnvironmentProperties`](crate::model::EnvironmentProperties)
pub mod environment_properties {
    /// A builder for [`EnvironmentProperties`](crate::model::EnvironmentProperties)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) property_groups: std::option::Option<std::vec::Vec<crate::model::PropertyGroup>>,
    }
    impl Builder {
        /// Appends an item to `property_groups`.
        ///
        /// To override the contents of this collection use [`set_property_groups`](Self::set_property_groups).
        ///
        /// <p>Describes the execution property groups.</p>
        pub fn property_groups(mut self, input: impl Into<crate::model::PropertyGroup>) -> Self {
            let mut v = self.property_groups.unwrap_or_default();
            v.push(input.into());
            self.property_groups = Some(v);
            self
        }
        /// <p>Describes the execution property groups.</p>
        pub fn set_property_groups(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::PropertyGroup>>,
        ) -> Self {
            self.property_groups = input;
            self
        }
        /// Consumes the builder and constructs a [`EnvironmentProperties`](crate::model::EnvironmentProperties)
        pub fn build(self) -> crate::model::EnvironmentProperties {
            crate::model::EnvironmentProperties {
                property_groups: self.property_groups,
            }
        }
    }
}
impl EnvironmentProperties {
    /// Creates a new builder-style object to manufacture [`EnvironmentProperties`](crate::model::EnvironmentProperties)
    pub fn builder() -> crate::model::environment_properties::Builder {
        crate::model::environment_properties::Builder::default()
    }
}

/// <p>Describes configuration parameters for a Flink-based Kinesis Data Analytics application or a Studio notebook.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct FlinkApplicationConfiguration {
    /// <p>Describes an application's checkpointing configuration. Checkpointing is the
    /// process of persisting application state for fault tolerance.
    /// For more information, see
    /// <a href="https://ci.apache.org/projects/flink/flink-docs-release-1.8/concepts/programming-model.html#checkpoints-for-fault-tolerance">
    /// Checkpoints for Fault Tolerance</a> in the
    /// <a href="https://ci.apache.org/projects/flink/flink-docs-release-1.8/">Apache Flink Documentation</a>. </p>
    pub checkpoint_configuration: std::option::Option<crate::model::CheckpointConfiguration>,
    /// <p>Describes configuration parameters for Amazon CloudWatch logging for an
    /// application.</p>
    pub monitoring_configuration: std::option::Option<crate::model::MonitoringConfiguration>,
    /// <p>Describes parameters for how an application executes multiple tasks simultaneously.</p>
    pub parallelism_configuration: std::option::Option<crate::model::ParallelismConfiguration>,
}
impl FlinkApplicationConfiguration {
    /// <p>Describes an application's checkpointing configuration. Checkpointing is the
    /// process of persisting application state for fault tolerance.
    /// For more information, see
    /// <a href="https://ci.apache.org/projects/flink/flink-docs-release-1.8/concepts/programming-model.html#checkpoints-for-fault-tolerance">
    /// Checkpoints for Fault Tolerance</a> in the
    /// <a href="https://ci.apache.org/projects/flink/flink-docs-release-1.8/">Apache Flink Documentation</a>. </p>
    pub fn checkpoint_configuration(
        &self,
    ) -> std::option::Option<&crate::model::CheckpointConfiguration> {
        self.checkpoint_configuration.as_ref()
    }
    /// <p>Describes configuration parameters for Amazon CloudWatch logging for an
    /// application.</p>
    pub fn monitoring_configuration(
        &self,
    ) -> std::option::Option<&crate::model::MonitoringConfiguration> {
        self.monitoring_configuration.as_ref()
    }
    /// <p>Describes parameters for how an application executes multiple tasks simultaneously.</p>
    pub fn parallelism_configuration(
        &self,
    ) -> std::option::Option<&crate::model::ParallelismConfiguration> {
        self.parallelism_configuration.as_ref()
    }
}
impl std::fmt::Debug for FlinkApplicationConfiguration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("FlinkApplicationConfiguration");
        formatter.field("checkpoint_configuration", &self.checkpoint_configuration);
        formatter.field("monitoring_configuration", &self.monitoring_configuration);
        formatter.field("parallelism_configuration", &self.parallelism_configuration);
        formatter.finish()
    }
}
/// See [`FlinkApplicationConfiguration`](crate::model::FlinkApplicationConfiguration)
pub mod flink_application_configuration {
    /// A builder for [`FlinkApplicationConfiguration`](crate::model::FlinkApplicationConfiguration)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) checkpoint_configuration:
            std::option::Option<crate::model::CheckpointConfiguration>,
        pub(crate) monitoring_configuration:
            std::option::Option<crate::model::MonitoringConfiguration>,
        pub(crate) parallelism_configuration:
            std::option::Option<crate::model::ParallelismConfiguration>,
    }
    impl Builder {
        /// <p>Describes an application's checkpointing configuration. Checkpointing is the
        /// process of persisting application state for fault tolerance.
        /// For more information, see
        /// <a href="https://ci.apache.org/projects/flink/flink-docs-release-1.8/concepts/programming-model.html#checkpoints-for-fault-tolerance">
        /// Checkpoints for Fault Tolerance</a> in the
        /// <a href="https://ci.apache.org/projects/flink/flink-docs-release-1.8/">Apache Flink Documentation</a>. </p>
        pub fn checkpoint_configuration(
            mut self,
            input: crate::model::CheckpointConfiguration,
        ) -> Self {
            self.checkpoint_configuration = Some(input);
            self
        }
        /// <p>Describes an application's checkpointing configuration. Checkpointing is the
        /// process of persisting application state for fault tolerance.
        /// For more information, see
        /// <a href="https://ci.apache.org/projects/flink/flink-docs-release-1.8/concepts/programming-model.html#checkpoints-for-fault-tolerance">
        /// Checkpoints for Fault Tolerance</a> in the
        /// <a href="https://ci.apache.org/projects/flink/flink-docs-release-1.8/">Apache Flink Documentation</a>. </p>
        pub fn set_checkpoint_configuration(
            mut self,
            input: std::option::Option<crate::model::CheckpointConfiguration>,
        ) -> Self {
            self.checkpoint_configuration = input;
            self
        }
        /// <p>Describes configuration parameters for Amazon CloudWatch logging for an
        /// application.</p>
        pub fn monitoring_configuration(
            mut self,
            input: crate::model::MonitoringConfiguration,
        ) -> Self {
            self.monitoring_configuration = Some(input);
            self
        }
        /// <p>Describes configuration parameters for Amazon CloudWatch logging for an
        /// application.</p>
        pub fn set_monitoring_configuration(
            mut self,
            input: std::option::Option<crate::model::MonitoringConfiguration>,
        ) -> Self {
            self.monitoring_configuration = input;
            self
        }
        /// <p>Describes parameters for how an application executes multiple tasks simultaneously.</p>
        pub fn parallelism_configuration(
            mut self,
            input: crate::model::ParallelismConfiguration,
        ) -> Self {
            self.parallelism_configuration = Some(input);
            self
        }
        /// <p>Describes parameters for how an application executes multiple tasks simultaneously.</p>
        pub fn set_parallelism_configuration(
            mut self,
            input: std::option::Option<crate::model::ParallelismConfiguration>,
        ) -> Self {
            self.parallelism_configuration = input;
            self
        }
        /// Consumes the builder and constructs a [`FlinkApplicationConfiguration`](crate::model::FlinkApplicationConfiguration)
        pub fn build(self) -> crate::model::FlinkApplicationConfiguration {
            crate::model::FlinkApplicationConfiguration {
                checkpoint_configuration: self.checkpoint_configuration,
                monitoring_configuration: self.monitoring_configuration,
                parallelism_configuration: self.parallelism_configuration,
            }
        }
    }
}
impl FlinkApplicationConfiguration {
    /// Creates a new builder-style object to manufacture [`FlinkApplicationConfiguration`](crate::model::FlinkApplicationConfiguration)
    pub fn builder() -> crate::model::flink_application_configuration::Builder {
        crate::model::flink_application_configuration::Builder::default()
    }
}

/// <p>Describes parameters for how a Flink-based Kinesis Data Analytics application
/// executes multiple tasks simultaneously. For more information about parallelism,
/// see <a href="https://ci.apache.org/projects/flink/flink-docs-release-1.8/dev/parallel.html">Parallel Execution</a> in the <a href="https://ci.apache.org/projects/flink/flink-docs-release-1.8/">Apache Flink
/// Documentation</a>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ParallelismConfiguration {
    /// <p>Describes whether the application uses the default parallelism for the Kinesis Data Analytics service. You must set this property to <code>CUSTOM</code>
    /// in order to change your application's <code>AutoScalingEnabled</code>, <code>Parallelism</code>, or <code>ParallelismPerKPU</code> properties.</p>
    pub configuration_type: std::option::Option<crate::model::ConfigurationType>,
    /// <p>Describes the initial number of parallel tasks that a Flink-based Kinesis Data Analytics application can perform. If <code>AutoScalingEnabled</code>
    /// is set to True, Kinesis Data Analytics increases the <code>CurrentParallelism</code> value in response to application
    /// load. The service can increase the <code>CurrentParallelism</code> value up to the maximum parallelism, which is
    /// <code>ParalellismPerKPU</code> times the maximum KPUs for the application.
    /// The maximum KPUs for an application is 32 by default, and can be increased by requesting a limit increase. If
    /// application load is reduced, the service can
    /// reduce the <code>CurrentParallelism</code> value down to the <code>Parallelism</code> setting.</p>
    pub parallelism: std::option::Option<i32>,
    /// <p>Describes the number of parallel tasks that a Flink-based Kinesis Data Analytics application can perform per Kinesis Processing Unit
    /// (KPU) used by the application. For more
    /// information about KPUs, see <a href="http://aws.amazon.com/kinesis/data-analytics/pricing/">Amazon Kinesis Data Analytics Pricing</a>.</p>
    pub parallelism_per_kpu: std::option::Option<i32>,
    /// <p>Describes whether the Kinesis Data Analytics service can increase the parallelism of the application in response to increased throughput.</p>
    pub auto_scaling_enabled: std::option::Option<bool>,
}
impl ParallelismConfiguration {
    /// <p>Describes whether the application uses the default parallelism for the Kinesis Data Analytics service. You must set this property to <code>CUSTOM</code>
    /// in order to change your application's <code>AutoScalingEnabled</code>, <code>Parallelism</code>, or <code>ParallelismPerKPU</code> properties.</p>
    pub fn configuration_type(&self) -> std::option::Option<&crate::model::ConfigurationType> {
        self.configuration_type.as_ref()
    }
    /// <p>Describes the initial number of parallel tasks that a Flink-based Kinesis Data Analytics application can perform. If <code>AutoScalingEnabled</code>
    /// is set to True, Kinesis Data Analytics increases the <code>CurrentParallelism</code> value in response to application
    /// load. The service can increase the <code>CurrentParallelism</code> value up to the maximum parallelism, which is
    /// <code>ParalellismPerKPU</code> times the maximum KPUs for the application.
    /// The maximum KPUs for an application is 32 by default, and can be increased by requesting a limit increase. If
    /// application load is reduced, the service can
    /// reduce the <code>CurrentParallelism</code> value down to the <code>Parallelism</code> setting.</p>
    pub fn parallelism(&self) -> std::option::Option<i32> {
        self.parallelism
    }
    /// <p>Describes the number of parallel tasks that a Flink-based Kinesis Data Analytics application can perform per Kinesis Processing Unit
    /// (KPU) used by the application. For more
    /// information about KPUs, see <a href="http://aws.amazon.com/kinesis/data-analytics/pricing/">Amazon Kinesis Data Analytics Pricing</a>.</p>
    pub fn parallelism_per_kpu(&self) -> std::option::Option<i32> {
        self.parallelism_per_kpu
    }
    /// <p>Describes whether the Kinesis Data Analytics service can increase the parallelism of the application in response to increased throughput.</p>
    pub fn auto_scaling_enabled(&self) -> std::option::Option<bool> {
        self.auto_scaling_enabled
    }
}
impl std::fmt::Debug for ParallelismConfiguration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ParallelismConfiguration");
        formatter.field("configuration_type", &self.configuration_type);
        formatter.field("parallelism", &self.parallelism);
        formatter.field("parallelism_per_kpu", &self.parallelism_per_kpu);
        formatter.field("auto_scaling_enabled", &self.auto_scaling_enabled);
        formatter.finish()
    }
}
/// See [`ParallelismConfiguration`](crate::model::ParallelismConfiguration)
pub mod parallelism_configuration {
    /// A builder for [`ParallelismConfiguration`](crate::model::ParallelismConfiguration)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) configuration_type: std::option::Option<crate::model::ConfigurationType>,
        pub(crate) parallelism: std::option::Option<i32>,
        pub(crate) parallelism_per_kpu: std::option::Option<i32>,
        pub(crate) auto_scaling_enabled: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>Describes whether the application uses the default parallelism for the Kinesis Data Analytics service. You must set this property to <code>CUSTOM</code>
        /// in order to change your application's <code>AutoScalingEnabled</code>, <code>Parallelism</code>, or <code>ParallelismPerKPU</code> properties.</p>
        pub fn configuration_type(mut self, input: crate::model::ConfigurationType) -> Self {
            self.configuration_type = Some(input);
            self
        }
        /// <p>Describes whether the application uses the default parallelism for the Kinesis Data Analytics service. You must set this property to <code>CUSTOM</code>
        /// in order to change your application's <code>AutoScalingEnabled</code>, <code>Parallelism</code>, or <code>ParallelismPerKPU</code> properties.</p>
        pub fn set_configuration_type(
            mut self,
            input: std::option::Option<crate::model::ConfigurationType>,
        ) -> Self {
            self.configuration_type = input;
            self
        }
        /// <p>Describes the initial number of parallel tasks that a Flink-based Kinesis Data Analytics application can perform. If <code>AutoScalingEnabled</code>
        /// is set to True, Kinesis Data Analytics increases the <code>CurrentParallelism</code> value in response to application
        /// load. The service can increase the <code>CurrentParallelism</code> value up to the maximum parallelism, which is
        /// <code>ParalellismPerKPU</code> times the maximum KPUs for the application.
        /// The maximum KPUs for an application is 32 by default, and can be increased by requesting a limit increase. If
        /// application load is reduced, the service can
        /// reduce the <code>CurrentParallelism</code> value down to the <code>Parallelism</code> setting.</p>
        pub fn parallelism(mut self, input: i32) -> Self {
            self.parallelism = Some(input);
            self
        }
        /// <p>Describes the initial number of parallel tasks that a Flink-based Kinesis Data Analytics application can perform. If <code>AutoScalingEnabled</code>
        /// is set to True, Kinesis Data Analytics increases the <code>CurrentParallelism</code> value in response to application
        /// load. The service can increase the <code>CurrentParallelism</code> value up to the maximum parallelism, which is
        /// <code>ParalellismPerKPU</code> times the maximum KPUs for the application.
        /// The maximum KPUs for an application is 32 by default, and can be increased by requesting a limit increase. If
        /// application load is reduced, the service can
        /// reduce the <code>CurrentParallelism</code> value down to the <code>Parallelism</code> setting.</p>
        pub fn set_parallelism(mut self, input: std::option::Option<i32>) -> Self {
            self.parallelism = input;
            self
        }
        /// <p>Describes the number of parallel tasks that a Flink-based Kinesis Data Analytics application can perform per Kinesis Processing Unit
        /// (KPU) used by the application. For more
        /// information about KPUs, see <a href="http://aws.amazon.com/kinesis/data-analytics/pricing/">Amazon Kinesis Data Analytics Pricing</a>.</p>
        pub fn parallelism_per_kpu(mut self, input: i32) -> Self {
            self.parallelism_per_kpu = Some(input);
            self
        }
        /// <p>Describes the number of parallel tasks that a Flink-based Kinesis Data Analytics application can perform per Kinesis Processing Unit
        /// (KPU) used by the application. For more
        /// information about KPUs, see <a href="http://aws.amazon.com/kinesis/data-analytics/pricing/">Amazon Kinesis Data Analytics Pricing</a>.</p>
        pub fn set_parallelism_per_kpu(mut self, input: std::option::Option<i32>) -> Self {
            self.parallelism_per_kpu = input;
            self
        }
        /// <p>Describes whether the Kinesis Data Analytics service can increase the parallelism of the application in response to increased throughput.</p>
        pub fn auto_scaling_enabled(mut self, input: bool) -> Self {
            self.auto_scaling_enabled = Some(input);
            self
        }
        /// <p>Describes whether the Kinesis Data Analytics service can increase the parallelism of the application in response to increased throughput.</p>
        pub fn set_auto_scaling_enabled(mut self, input: std::option::Option<bool>) -> Self {
            self.auto_scaling_enabled = input;
            self
        }
        /// Consumes the builder and constructs a [`ParallelismConfiguration`](crate::model::ParallelismConfiguration)
        pub fn build(self) -> crate::model::ParallelismConfiguration {
            crate::model::ParallelismConfiguration {
                configuration_type: self.configuration_type,
                parallelism: self.parallelism,
                parallelism_per_kpu: self.parallelism_per_kpu,
                auto_scaling_enabled: self.auto_scaling_enabled,
            }
        }
    }
}
impl ParallelismConfiguration {
    /// Creates a new builder-style object to manufacture [`ParallelismConfiguration`](crate::model::ParallelismConfiguration)
    pub fn builder() -> crate::model::parallelism_configuration::Builder {
        crate::model::parallelism_configuration::Builder::default()
    }
}

/// <p>Describes configuration parameters for Amazon CloudWatch logging for an application. For more information about CloudWatch logging, see <a href="https://docs.aws.amazon.com/kinesisanalytics/latest/java/monitoring-overview.html">Monitoring</a>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct MonitoringConfiguration {
    /// <p>Describes whether to use the default CloudWatch logging configuration for an application.
    /// You must set this property to <code>CUSTOM</code> in order to set the <code>LogLevel</code> or
    /// <code>MetricsLevel</code> parameters.</p>
    pub configuration_type: std::option::Option<crate::model::ConfigurationType>,
    /// <p>Describes the granularity of the CloudWatch Logs for an application. The <code>Parallelism</code>
    /// level is not recommended for applications with a Parallelism over 64 due to excessive costs.</p>
    pub metrics_level: std::option::Option<crate::model::MetricsLevel>,
    /// <p>Describes the verbosity of the CloudWatch Logs for an application.</p>
    pub log_level: std::option::Option<crate::model::LogLevel>,
}
impl MonitoringConfiguration {
    /// <p>Describes whether to use the default CloudWatch logging configuration for an application.
    /// You must set this property to <code>CUSTOM</code> in order to set the <code>LogLevel</code> or
    /// <code>MetricsLevel</code> parameters.</p>
    pub fn configuration_type(&self) -> std::option::Option<&crate::model::ConfigurationType> {
        self.configuration_type.as_ref()
    }
    /// <p>Describes the granularity of the CloudWatch Logs for an application. The <code>Parallelism</code>
    /// level is not recommended for applications with a Parallelism over 64 due to excessive costs.</p>
    pub fn metrics_level(&self) -> std::option::Option<&crate::model::MetricsLevel> {
        self.metrics_level.as_ref()
    }
    /// <p>Describes the verbosity of the CloudWatch Logs for an application.</p>
    pub fn log_level(&self) -> std::option::Option<&crate::model::LogLevel> {
        self.log_level.as_ref()
    }
}
impl std::fmt::Debug for MonitoringConfiguration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("MonitoringConfiguration");
        formatter.field("configuration_type", &self.configuration_type);
        formatter.field("metrics_level", &self.metrics_level);
        formatter.field("log_level", &self.log_level);
        formatter.finish()
    }
}
/// See [`MonitoringConfiguration`](crate::model::MonitoringConfiguration)
pub mod monitoring_configuration {
    /// A builder for [`MonitoringConfiguration`](crate::model::MonitoringConfiguration)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) configuration_type: std::option::Option<crate::model::ConfigurationType>,
        pub(crate) metrics_level: std::option::Option<crate::model::MetricsLevel>,
        pub(crate) log_level: std::option::Option<crate::model::LogLevel>,
    }
    impl Builder {
        /// <p>Describes whether to use the default CloudWatch logging configuration for an application.
        /// You must set this property to <code>CUSTOM</code> in order to set the <code>LogLevel</code> or
        /// <code>MetricsLevel</code> parameters.</p>
        pub fn configuration_type(mut self, input: crate::model::ConfigurationType) -> Self {
            self.configuration_type = Some(input);
            self
        }
        /// <p>Describes whether to use the default CloudWatch logging configuration for an application.
        /// You must set this property to <code>CUSTOM</code> in order to set the <code>LogLevel</code> or
        /// <code>MetricsLevel</code> parameters.</p>
        pub fn set_configuration_type(
            mut self,
            input: std::option::Option<crate::model::ConfigurationType>,
        ) -> Self {
            self.configuration_type = input;
            self
        }
        /// <p>Describes the granularity of the CloudWatch Logs for an application. The <code>Parallelism</code>
        /// level is not recommended for applications with a Parallelism over 64 due to excessive costs.</p>
        pub fn metrics_level(mut self, input: crate::model::MetricsLevel) -> Self {
            self.metrics_level = Some(input);
            self
        }
        /// <p>Describes the granularity of the CloudWatch Logs for an application. The <code>Parallelism</code>
        /// level is not recommended for applications with a Parallelism over 64 due to excessive costs.</p>
        pub fn set_metrics_level(
            mut self,
            input: std::option::Option<crate::model::MetricsLevel>,
        ) -> Self {
            self.metrics_level = input;
            self
        }
        /// <p>Describes the verbosity of the CloudWatch Logs for an application.</p>
        pub fn log_level(mut self, input: crate::model::LogLevel) -> Self {
            self.log_level = Some(input);
            self
        }
        /// <p>Describes the verbosity of the CloudWatch Logs for an application.</p>
        pub fn set_log_level(mut self, input: std::option::Option<crate::model::LogLevel>) -> Self {
            self.log_level = input;
            self
        }
        /// Consumes the builder and constructs a [`MonitoringConfiguration`](crate::model::MonitoringConfiguration)
        pub fn build(self) -> crate::model::MonitoringConfiguration {
            crate::model::MonitoringConfiguration {
                configuration_type: self.configuration_type,
                metrics_level: self.metrics_level,
                log_level: self.log_level,
            }
        }
    }
}
impl MonitoringConfiguration {
    /// Creates a new builder-style object to manufacture [`MonitoringConfiguration`](crate::model::MonitoringConfiguration)
    pub fn builder() -> crate::model::monitoring_configuration::Builder {
        crate::model::monitoring_configuration::Builder::default()
    }
}

/// <p>Describes an application's checkpointing configuration. Checkpointing is the process of persisting application state for fault
/// tolerance.
/// For more information, see
/// <a href="https://ci.apache.org/projects/flink/flink-docs-release-1.8/concepts/programming-model.html#checkpoints-for-fault-tolerance">
/// Checkpoints for Fault Tolerance</a> in the
/// <a href="https://ci.apache.org/projects/flink/flink-docs-release-1.8/">Apache Flink Documentation</a>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CheckpointConfiguration {
    /// <p>Describes whether the application uses Kinesis Data Analytics' default checkpointing behavior.
    /// You must set this property to <code>CUSTOM</code> in order to set the
    /// <code>CheckpointingEnabled</code>, <code>CheckpointInterval</code>, or <code>MinPauseBetweenCheckpoints</code> parameters.</p>
    /// <note>
    /// <p>If this value is set to <code>DEFAULT</code>, the application will use the following values, even if they are set to other values using APIs or
    /// application code:</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <b>CheckpointingEnabled:</b> true</p>
    /// </li>
    /// <li>
    /// <p>
    /// <b>CheckpointInterval:</b> 60000</p>
    /// </li>
    /// <li>
    /// <p>
    /// <b>MinPauseBetweenCheckpoints:</b> 5000</p>
    /// </li>
    /// </ul>
    /// </note>
    pub configuration_type: std::option::Option<crate::model::ConfigurationType>,
    /// <p>Describes whether checkpointing is enabled for a Flink-based Kinesis Data Analytics application.</p>
    /// <note>
    /// <p>If <code>CheckpointConfiguration.ConfigurationType</code> is <code>DEFAULT</code>,
    /// the application will use a <code>CheckpointingEnabled</code> value of <code>true</code>, even if this value
    /// is set to another value using this API or in application code.</p>
    /// </note>
    pub checkpointing_enabled: std::option::Option<bool>,
    /// <p>Describes the interval in milliseconds between checkpoint operations. </p>
    /// <note>
    /// <p>If <code>CheckpointConfiguration.ConfigurationType</code> is <code>DEFAULT</code>,
    /// the application will use a <code>CheckpointInterval</code> value of 60000, even if this value is set
    /// to another value using this API or in application code.</p>
    /// </note>
    pub checkpoint_interval: std::option::Option<i64>,
    /// <p>Describes the minimum time in milliseconds after a checkpoint operation completes that a
    /// new checkpoint operation can start. If a checkpoint operation takes longer than the
    /// <code>CheckpointInterval</code>, the application otherwise performs continual checkpoint
    /// operations. For more information, see <a href="https://ci.apache.org/projects/flink/flink-docs-release-1.8/ops/state/large_state_tuning.html#tuning-checkpointing"> Tuning Checkpointing</a> in the <a href="https://ci.apache.org/projects/flink/flink-docs-release-1.8/">Apache Flink
    /// Documentation</a>.</p>
    /// <note>
    /// <p>If <code>CheckpointConfiguration.ConfigurationType</code> is <code>DEFAULT</code>,
    /// the application will use a <code>MinPauseBetweenCheckpoints</code> value of 5000, even if this value is set using this
    /// API or in application code.</p>
    /// </note>
    pub min_pause_between_checkpoints: std::option::Option<i64>,
}
impl CheckpointConfiguration {
    /// <p>Describes whether the application uses Kinesis Data Analytics' default checkpointing behavior.
    /// You must set this property to <code>CUSTOM</code> in order to set the
    /// <code>CheckpointingEnabled</code>, <code>CheckpointInterval</code>, or <code>MinPauseBetweenCheckpoints</code> parameters.</p>
    /// <note>
    /// <p>If this value is set to <code>DEFAULT</code>, the application will use the following values, even if they are set to other values using APIs or
    /// application code:</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <b>CheckpointingEnabled:</b> true</p>
    /// </li>
    /// <li>
    /// <p>
    /// <b>CheckpointInterval:</b> 60000</p>
    /// </li>
    /// <li>
    /// <p>
    /// <b>MinPauseBetweenCheckpoints:</b> 5000</p>
    /// </li>
    /// </ul>
    /// </note>
    pub fn configuration_type(&self) -> std::option::Option<&crate::model::ConfigurationType> {
        self.configuration_type.as_ref()
    }
    /// <p>Describes whether checkpointing is enabled for a Flink-based Kinesis Data Analytics application.</p>
    /// <note>
    /// <p>If <code>CheckpointConfiguration.ConfigurationType</code> is <code>DEFAULT</code>,
    /// the application will use a <code>CheckpointingEnabled</code> value of <code>true</code>, even if this value
    /// is set to another value using this API or in application code.</p>
    /// </note>
    pub fn checkpointing_enabled(&self) -> std::option::Option<bool> {
        self.checkpointing_enabled
    }
    /// <p>Describes the interval in milliseconds between checkpoint operations. </p>
    /// <note>
    /// <p>If <code>CheckpointConfiguration.ConfigurationType</code> is <code>DEFAULT</code>,
    /// the application will use a <code>CheckpointInterval</code> value of 60000, even if this value is set
    /// to another value using this API or in application code.</p>
    /// </note>
    pub fn checkpoint_interval(&self) -> std::option::Option<i64> {
        self.checkpoint_interval
    }
    /// <p>Describes the minimum time in milliseconds after a checkpoint operation completes that a
    /// new checkpoint operation can start. If a checkpoint operation takes longer than the
    /// <code>CheckpointInterval</code>, the application otherwise performs continual checkpoint
    /// operations. For more information, see <a href="https://ci.apache.org/projects/flink/flink-docs-release-1.8/ops/state/large_state_tuning.html#tuning-checkpointing"> Tuning Checkpointing</a> in the <a href="https://ci.apache.org/projects/flink/flink-docs-release-1.8/">Apache Flink
    /// Documentation</a>.</p>
    /// <note>
    /// <p>If <code>CheckpointConfiguration.ConfigurationType</code> is <code>DEFAULT</code>,
    /// the application will use a <code>MinPauseBetweenCheckpoints</code> value of 5000, even if this value is set using this
    /// API or in application code.</p>
    /// </note>
    pub fn min_pause_between_checkpoints(&self) -> std::option::Option<i64> {
        self.min_pause_between_checkpoints
    }
}
impl std::fmt::Debug for CheckpointConfiguration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CheckpointConfiguration");
        formatter.field("configuration_type", &self.configuration_type);
        formatter.field("checkpointing_enabled", &self.checkpointing_enabled);
        formatter.field("checkpoint_interval", &self.checkpoint_interval);
        formatter.field(
            "min_pause_between_checkpoints",
            &self.min_pause_between_checkpoints,
        );
        formatter.finish()
    }
}
/// See [`CheckpointConfiguration`](crate::model::CheckpointConfiguration)
pub mod checkpoint_configuration {
    /// A builder for [`CheckpointConfiguration`](crate::model::CheckpointConfiguration)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) configuration_type: std::option::Option<crate::model::ConfigurationType>,
        pub(crate) checkpointing_enabled: std::option::Option<bool>,
        pub(crate) checkpoint_interval: std::option::Option<i64>,
        pub(crate) min_pause_between_checkpoints: std::option::Option<i64>,
    }
    impl Builder {
        /// <p>Describes whether the application uses Kinesis Data Analytics' default checkpointing behavior.
        /// You must set this property to <code>CUSTOM</code> in order to set the
        /// <code>CheckpointingEnabled</code>, <code>CheckpointInterval</code>, or <code>MinPauseBetweenCheckpoints</code> parameters.</p>
        /// <note>
        /// <p>If this value is set to <code>DEFAULT</code>, the application will use the following values, even if they are set to other values using APIs or
        /// application code:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <b>CheckpointingEnabled:</b> true</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>CheckpointInterval:</b> 60000</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>MinPauseBetweenCheckpoints:</b> 5000</p>
        /// </li>
        /// </ul>
        /// </note>
        pub fn configuration_type(mut self, input: crate::model::ConfigurationType) -> Self {
            self.configuration_type = Some(input);
            self
        }
        /// <p>Describes whether the application uses Kinesis Data Analytics' default checkpointing behavior.
        /// You must set this property to <code>CUSTOM</code> in order to set the
        /// <code>CheckpointingEnabled</code>, <code>CheckpointInterval</code>, or <code>MinPauseBetweenCheckpoints</code> parameters.</p>
        /// <note>
        /// <p>If this value is set to <code>DEFAULT</code>, the application will use the following values, even if they are set to other values using APIs or
        /// application code:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <b>CheckpointingEnabled:</b> true</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>CheckpointInterval:</b> 60000</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>MinPauseBetweenCheckpoints:</b> 5000</p>
        /// </li>
        /// </ul>
        /// </note>
        pub fn set_configuration_type(
            mut self,
            input: std::option::Option<crate::model::ConfigurationType>,
        ) -> Self {
            self.configuration_type = input;
            self
        }
        /// <p>Describes whether checkpointing is enabled for a Flink-based Kinesis Data Analytics application.</p>
        /// <note>
        /// <p>If <code>CheckpointConfiguration.ConfigurationType</code> is <code>DEFAULT</code>,
        /// the application will use a <code>CheckpointingEnabled</code> value of <code>true</code>, even if this value
        /// is set to another value using this API or in application code.</p>
        /// </note>
        pub fn checkpointing_enabled(mut self, input: bool) -> Self {
            self.checkpointing_enabled = Some(input);
            self
        }
        /// <p>Describes whether checkpointing is enabled for a Flink-based Kinesis Data Analytics application.</p>
        /// <note>
        /// <p>If <code>CheckpointConfiguration.ConfigurationType</code> is <code>DEFAULT</code>,
        /// the application will use a <code>CheckpointingEnabled</code> value of <code>true</code>, even if this value
        /// is set to another value using this API or in application code.</p>
        /// </note>
        pub fn set_checkpointing_enabled(mut self, input: std::option::Option<bool>) -> Self {
            self.checkpointing_enabled = input;
            self
        }
        /// <p>Describes the interval in milliseconds between checkpoint operations. </p>
        /// <note>
        /// <p>If <code>CheckpointConfiguration.ConfigurationType</code> is <code>DEFAULT</code>,
        /// the application will use a <code>CheckpointInterval</code> value of 60000, even if this value is set
        /// to another value using this API or in application code.</p>
        /// </note>
        pub fn checkpoint_interval(mut self, input: i64) -> Self {
            self.checkpoint_interval = Some(input);
            self
        }
        /// <p>Describes the interval in milliseconds between checkpoint operations. </p>
        /// <note>
        /// <p>If <code>CheckpointConfiguration.ConfigurationType</code> is <code>DEFAULT</code>,
        /// the application will use a <code>CheckpointInterval</code> value of 60000, even if this value is set
        /// to another value using this API or in application code.</p>
        /// </note>
        pub fn set_checkpoint_interval(mut self, input: std::option::Option<i64>) -> Self {
            self.checkpoint_interval = input;
            self
        }
        /// <p>Describes the minimum time in milliseconds after a checkpoint operation completes that a
        /// new checkpoint operation can start. If a checkpoint operation takes longer than the
        /// <code>CheckpointInterval</code>, the application otherwise performs continual checkpoint
        /// operations. For more information, see <a href="https://ci.apache.org/projects/flink/flink-docs-release-1.8/ops/state/large_state_tuning.html#tuning-checkpointing"> Tuning Checkpointing</a> in the <a href="https://ci.apache.org/projects/flink/flink-docs-release-1.8/">Apache Flink
        /// Documentation</a>.</p>
        /// <note>
        /// <p>If <code>CheckpointConfiguration.ConfigurationType</code> is <code>DEFAULT</code>,
        /// the application will use a <code>MinPauseBetweenCheckpoints</code> value of 5000, even if this value is set using this
        /// API or in application code.</p>
        /// </note>
        pub fn min_pause_between_checkpoints(mut self, input: i64) -> Self {
            self.min_pause_between_checkpoints = Some(input);
            self
        }
        /// <p>Describes the minimum time in milliseconds after a checkpoint operation completes that a
        /// new checkpoint operation can start. If a checkpoint operation takes longer than the
        /// <code>CheckpointInterval</code>, the application otherwise performs continual checkpoint
        /// operations. For more information, see <a href="https://ci.apache.org/projects/flink/flink-docs-release-1.8/ops/state/large_state_tuning.html#tuning-checkpointing"> Tuning Checkpointing</a> in the <a href="https://ci.apache.org/projects/flink/flink-docs-release-1.8/">Apache Flink
        /// Documentation</a>.</p>
        /// <note>
        /// <p>If <code>CheckpointConfiguration.ConfigurationType</code> is <code>DEFAULT</code>,
        /// the application will use a <code>MinPauseBetweenCheckpoints</code> value of 5000, even if this value is set using this
        /// API or in application code.</p>
        /// </note>
        pub fn set_min_pause_between_checkpoints(
            mut self,
            input: std::option::Option<i64>,
        ) -> Self {
            self.min_pause_between_checkpoints = input;
            self
        }
        /// Consumes the builder and constructs a [`CheckpointConfiguration`](crate::model::CheckpointConfiguration)
        pub fn build(self) -> crate::model::CheckpointConfiguration {
            crate::model::CheckpointConfiguration {
                configuration_type: self.configuration_type,
                checkpointing_enabled: self.checkpointing_enabled,
                checkpoint_interval: self.checkpoint_interval,
                min_pause_between_checkpoints: self.min_pause_between_checkpoints,
            }
        }
    }
}
impl CheckpointConfiguration {
    /// Creates a new builder-style object to manufacture [`CheckpointConfiguration`](crate::model::CheckpointConfiguration)
    pub fn builder() -> crate::model::checkpoint_configuration::Builder {
        crate::model::checkpoint_configuration::Builder::default()
    }
}

/// <p>Describes the inputs, outputs, and reference data sources for a SQL-based Kinesis Data Analytics application.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SqlApplicationConfiguration {
    /// <p>The array of <a>Input</a> objects describing the input streams used by the
    /// application.</p>
    pub inputs: std::option::Option<std::vec::Vec<crate::model::Input>>,
    /// <p>The array of <a>Output</a> objects describing the destination streams used by
    /// the application.</p>
    pub outputs: std::option::Option<std::vec::Vec<crate::model::Output>>,
    /// <p>The array of <a>ReferenceDataSource</a> objects describing the reference data
    /// sources used by the application.</p>
    pub reference_data_sources:
        std::option::Option<std::vec::Vec<crate::model::ReferenceDataSource>>,
}
impl SqlApplicationConfiguration {
    /// <p>The array of <a>Input</a> objects describing the input streams used by the
    /// application.</p>
    pub fn inputs(&self) -> std::option::Option<&[crate::model::Input]> {
        self.inputs.as_deref()
    }
    /// <p>The array of <a>Output</a> objects describing the destination streams used by
    /// the application.</p>
    pub fn outputs(&self) -> std::option::Option<&[crate::model::Output]> {
        self.outputs.as_deref()
    }
    /// <p>The array of <a>ReferenceDataSource</a> objects describing the reference data
    /// sources used by the application.</p>
    pub fn reference_data_sources(
        &self,
    ) -> std::option::Option<&[crate::model::ReferenceDataSource]> {
        self.reference_data_sources.as_deref()
    }
}
impl std::fmt::Debug for SqlApplicationConfiguration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SqlApplicationConfiguration");
        formatter.field("inputs", &self.inputs);
        formatter.field("outputs", &self.outputs);
        formatter.field("reference_data_sources", &self.reference_data_sources);
        formatter.finish()
    }
}
/// See [`SqlApplicationConfiguration`](crate::model::SqlApplicationConfiguration)
pub mod sql_application_configuration {
    /// A builder for [`SqlApplicationConfiguration`](crate::model::SqlApplicationConfiguration)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) inputs: std::option::Option<std::vec::Vec<crate::model::Input>>,
        pub(crate) outputs: std::option::Option<std::vec::Vec<crate::model::Output>>,
        pub(crate) reference_data_sources:
            std::option::Option<std::vec::Vec<crate::model::ReferenceDataSource>>,
    }
    impl Builder {
        /// Appends an item to `inputs`.
        ///
        /// To override the contents of this collection use [`set_inputs`](Self::set_inputs).
        ///
        /// <p>The array of <a>Input</a> objects describing the input streams used by the
        /// application.</p>
        pub fn inputs(mut self, input: impl Into<crate::model::Input>) -> Self {
            let mut v = self.inputs.unwrap_or_default();
            v.push(input.into());
            self.inputs = Some(v);
            self
        }
        /// <p>The array of <a>Input</a> objects describing the input streams used by the
        /// application.</p>
        pub fn set_inputs(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Input>>,
        ) -> Self {
            self.inputs = input;
            self
        }
        /// Appends an item to `outputs`.
        ///
        /// To override the contents of this collection use [`set_outputs`](Self::set_outputs).
        ///
        /// <p>The array of <a>Output</a> objects describing the destination streams used by
        /// the application.</p>
        pub fn outputs(mut self, input: impl Into<crate::model::Output>) -> Self {
            let mut v = self.outputs.unwrap_or_default();
            v.push(input.into());
            self.outputs = Some(v);
            self
        }
        /// <p>The array of <a>Output</a> objects describing the destination streams used by
        /// the application.</p>
        pub fn set_outputs(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Output>>,
        ) -> Self {
            self.outputs = input;
            self
        }
        /// Appends an item to `reference_data_sources`.
        ///
        /// To override the contents of this collection use [`set_reference_data_sources`](Self::set_reference_data_sources).
        ///
        /// <p>The array of <a>ReferenceDataSource</a> objects describing the reference data
        /// sources used by the application.</p>
        pub fn reference_data_sources(
            mut self,
            input: impl Into<crate::model::ReferenceDataSource>,
        ) -> Self {
            let mut v = self.reference_data_sources.unwrap_or_default();
            v.push(input.into());
            self.reference_data_sources = Some(v);
            self
        }
        /// <p>The array of <a>ReferenceDataSource</a> objects describing the reference data
        /// sources used by the application.</p>
        pub fn set_reference_data_sources(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ReferenceDataSource>>,
        ) -> Self {
            self.reference_data_sources = input;
            self
        }
        /// Consumes the builder and constructs a [`SqlApplicationConfiguration`](crate::model::SqlApplicationConfiguration)
        pub fn build(self) -> crate::model::SqlApplicationConfiguration {
            crate::model::SqlApplicationConfiguration {
                inputs: self.inputs,
                outputs: self.outputs,
                reference_data_sources: self.reference_data_sources,
            }
        }
    }
}
impl SqlApplicationConfiguration {
    /// Creates a new builder-style object to manufacture [`SqlApplicationConfiguration`](crate::model::SqlApplicationConfiguration)
    pub fn builder() -> crate::model::sql_application_configuration::Builder {
        crate::model::sql_application_configuration::Builder::default()
    }
}

/// <p>For a SQL-based Kinesis Data Analytics application, describes the reference data
/// source by providing the source information (Amazon S3 bucket name and object key name), the
/// resulting in-application table name that is created, and the necessary schema to map the data
/// elements in the Amazon S3 object to the in-application table.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ReferenceDataSource {
    /// <p>The name of the in-application table to create.</p>
    pub table_name: std::option::Option<std::string::String>,
    /// <p>Identifies the S3 bucket and object that contains the reference data.
    ///
    /// A Kinesis Data Analytics application loads reference data only once. If the data changes, you call the <a>UpdateApplication</a> operation to trigger reloading of data into your application. </p>
    pub s3_reference_data_source: std::option::Option<crate::model::S3ReferenceDataSource>,
    /// <p>Describes the format of the data in the streaming source, and how each data element maps to corresponding columns created in the in-application stream.</p>
    pub reference_schema: std::option::Option<crate::model::SourceSchema>,
}
impl ReferenceDataSource {
    /// <p>The name of the in-application table to create.</p>
    pub fn table_name(&self) -> std::option::Option<&str> {
        self.table_name.as_deref()
    }
    /// <p>Identifies the S3 bucket and object that contains the reference data.
    ///
    /// A Kinesis Data Analytics application loads reference data only once. If the data changes, you call the <a>UpdateApplication</a> operation to trigger reloading of data into your application. </p>
    pub fn s3_reference_data_source(
        &self,
    ) -> std::option::Option<&crate::model::S3ReferenceDataSource> {
        self.s3_reference_data_source.as_ref()
    }
    /// <p>Describes the format of the data in the streaming source, and how each data element maps to corresponding columns created in the in-application stream.</p>
    pub fn reference_schema(&self) -> std::option::Option<&crate::model::SourceSchema> {
        self.reference_schema.as_ref()
    }
}
impl std::fmt::Debug for ReferenceDataSource {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ReferenceDataSource");
        formatter.field("table_name", &self.table_name);
        formatter.field("s3_reference_data_source", &self.s3_reference_data_source);
        formatter.field("reference_schema", &self.reference_schema);
        formatter.finish()
    }
}
/// See [`ReferenceDataSource`](crate::model::ReferenceDataSource)
pub mod reference_data_source {
    /// A builder for [`ReferenceDataSource`](crate::model::ReferenceDataSource)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) table_name: std::option::Option<std::string::String>,
        pub(crate) s3_reference_data_source:
            std::option::Option<crate::model::S3ReferenceDataSource>,
        pub(crate) reference_schema: std::option::Option<crate::model::SourceSchema>,
    }
    impl Builder {
        /// <p>The name of the in-application table to create.</p>
        pub fn table_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.table_name = Some(input.into());
            self
        }
        /// <p>The name of the in-application table to create.</p>
        pub fn set_table_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.table_name = input;
            self
        }
        /// <p>Identifies the S3 bucket and object that contains the reference data.
        ///
        /// A Kinesis Data Analytics application loads reference data only once. If the data changes, you call the <a>UpdateApplication</a> operation to trigger reloading of data into your application. </p>
        pub fn s3_reference_data_source(
            mut self,
            input: crate::model::S3ReferenceDataSource,
        ) -> Self {
            self.s3_reference_data_source = Some(input);
            self
        }
        /// <p>Identifies the S3 bucket and object that contains the reference data.
        ///
        /// A Kinesis Data Analytics application loads reference data only once. If the data changes, you call the <a>UpdateApplication</a> operation to trigger reloading of data into your application. </p>
        pub fn set_s3_reference_data_source(
            mut self,
            input: std::option::Option<crate::model::S3ReferenceDataSource>,
        ) -> Self {
            self.s3_reference_data_source = input;
            self
        }
        /// <p>Describes the format of the data in the streaming source, and how each data element maps to corresponding columns created in the in-application stream.</p>
        pub fn reference_schema(mut self, input: crate::model::SourceSchema) -> Self {
            self.reference_schema = Some(input);
            self
        }
        /// <p>Describes the format of the data in the streaming source, and how each data element maps to corresponding columns created in the in-application stream.</p>
        pub fn set_reference_schema(
            mut self,
            input: std::option::Option<crate::model::SourceSchema>,
        ) -> Self {
            self.reference_schema = input;
            self
        }
        /// Consumes the builder and constructs a [`ReferenceDataSource`](crate::model::ReferenceDataSource)
        pub fn build(self) -> crate::model::ReferenceDataSource {
            crate::model::ReferenceDataSource {
                table_name: self.table_name,
                s3_reference_data_source: self.s3_reference_data_source,
                reference_schema: self.reference_schema,
            }
        }
    }
}
impl ReferenceDataSource {
    /// Creates a new builder-style object to manufacture [`ReferenceDataSource`](crate::model::ReferenceDataSource)
    pub fn builder() -> crate::model::reference_data_source::Builder {
        crate::model::reference_data_source::Builder::default()
    }
}

/// <p>For a SQL-based Kinesis Data Analytics application, identifies the Amazon S3
/// bucket and object that contains the reference data.</p>
///
/// <p>A Kinesis Data Analytics application loads reference data only once. If the data changes, you call the <a>UpdateApplication</a>
/// operation to trigger reloading of data into your application. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct S3ReferenceDataSource {
    /// <p>The Amazon Resource Name (ARN) of the S3 bucket.</p>
    pub bucket_arn: std::option::Option<std::string::String>,
    /// <p>The object key name containing the reference data.</p>
    pub file_key: std::option::Option<std::string::String>,
}
impl S3ReferenceDataSource {
    /// <p>The Amazon Resource Name (ARN) of the S3 bucket.</p>
    pub fn bucket_arn(&self) -> std::option::Option<&str> {
        self.bucket_arn.as_deref()
    }
    /// <p>The object key name containing the reference data.</p>
    pub fn file_key(&self) -> std::option::Option<&str> {
        self.file_key.as_deref()
    }
}
impl std::fmt::Debug for S3ReferenceDataSource {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("S3ReferenceDataSource");
        formatter.field("bucket_arn", &self.bucket_arn);
        formatter.field("file_key", &self.file_key);
        formatter.finish()
    }
}
/// See [`S3ReferenceDataSource`](crate::model::S3ReferenceDataSource)
pub mod s3_reference_data_source {
    /// A builder for [`S3ReferenceDataSource`](crate::model::S3ReferenceDataSource)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) bucket_arn: std::option::Option<std::string::String>,
        pub(crate) file_key: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the S3 bucket.</p>
        pub fn bucket_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.bucket_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the S3 bucket.</p>
        pub fn set_bucket_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.bucket_arn = input;
            self
        }
        /// <p>The object key name containing the reference data.</p>
        pub fn file_key(mut self, input: impl Into<std::string::String>) -> Self {
            self.file_key = Some(input.into());
            self
        }
        /// <p>The object key name containing the reference data.</p>
        pub fn set_file_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.file_key = input;
            self
        }
        /// Consumes the builder and constructs a [`S3ReferenceDataSource`](crate::model::S3ReferenceDataSource)
        pub fn build(self) -> crate::model::S3ReferenceDataSource {
            crate::model::S3ReferenceDataSource {
                bucket_arn: self.bucket_arn,
                file_key: self.file_key,
            }
        }
    }
}
impl S3ReferenceDataSource {
    /// Creates a new builder-style object to manufacture [`S3ReferenceDataSource`](crate::model::S3ReferenceDataSource)
    pub fn builder() -> crate::model::s3_reference_data_source::Builder {
        crate::model::s3_reference_data_source::Builder::default()
    }
}

/// <p> Describes a SQL-based Kinesis Data Analytics application's output configuration,
/// in which you identify an in-application stream and a destination where you want the
/// in-application stream data to be written. The destination can be a Kinesis data stream or a
/// Kinesis Data Firehose delivery stream. </p>
///
/// <p></p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Output {
    /// <p>The name of the in-application stream.</p>
    pub name: std::option::Option<std::string::String>,
    /// <p>Identifies a Kinesis data stream
    /// as the destination.</p>
    pub kinesis_streams_output: std::option::Option<crate::model::KinesisStreamsOutput>,
    /// <p>Identifies a Kinesis Data Firehose delivery stream as the destination.</p>
    pub kinesis_firehose_output: std::option::Option<crate::model::KinesisFirehoseOutput>,
    /// <p>Identifies an Amazon Lambda function as the destination.</p>
    pub lambda_output: std::option::Option<crate::model::LambdaOutput>,
    /// <p>Describes the data format when records are written to the destination.
    /// </p>
    pub destination_schema: std::option::Option<crate::model::DestinationSchema>,
}
impl Output {
    /// <p>The name of the in-application stream.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>Identifies a Kinesis data stream
    /// as the destination.</p>
    pub fn kinesis_streams_output(
        &self,
    ) -> std::option::Option<&crate::model::KinesisStreamsOutput> {
        self.kinesis_streams_output.as_ref()
    }
    /// <p>Identifies a Kinesis Data Firehose delivery stream as the destination.</p>
    pub fn kinesis_firehose_output(
        &self,
    ) -> std::option::Option<&crate::model::KinesisFirehoseOutput> {
        self.kinesis_firehose_output.as_ref()
    }
    /// <p>Identifies an Amazon Lambda function as the destination.</p>
    pub fn lambda_output(&self) -> std::option::Option<&crate::model::LambdaOutput> {
        self.lambda_output.as_ref()
    }
    /// <p>Describes the data format when records are written to the destination.
    /// </p>
    pub fn destination_schema(&self) -> std::option::Option<&crate::model::DestinationSchema> {
        self.destination_schema.as_ref()
    }
}
impl std::fmt::Debug for Output {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Output");
        formatter.field("name", &self.name);
        formatter.field("kinesis_streams_output", &self.kinesis_streams_output);
        formatter.field("kinesis_firehose_output", &self.kinesis_firehose_output);
        formatter.field("lambda_output", &self.lambda_output);
        formatter.field("destination_schema", &self.destination_schema);
        formatter.finish()
    }
}
/// See [`Output`](crate::model::Output)
pub mod output {
    /// A builder for [`Output`](crate::model::Output)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) kinesis_streams_output: std::option::Option<crate::model::KinesisStreamsOutput>,
        pub(crate) kinesis_firehose_output:
            std::option::Option<crate::model::KinesisFirehoseOutput>,
        pub(crate) lambda_output: std::option::Option<crate::model::LambdaOutput>,
        pub(crate) destination_schema: std::option::Option<crate::model::DestinationSchema>,
    }
    impl Builder {
        /// <p>The name of the in-application stream.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the in-application stream.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>Identifies a Kinesis data stream
        /// as the destination.</p>
        pub fn kinesis_streams_output(mut self, input: crate::model::KinesisStreamsOutput) -> Self {
            self.kinesis_streams_output = Some(input);
            self
        }
        /// <p>Identifies a Kinesis data stream
        /// as the destination.</p>
        pub fn set_kinesis_streams_output(
            mut self,
            input: std::option::Option<crate::model::KinesisStreamsOutput>,
        ) -> Self {
            self.kinesis_streams_output = input;
            self
        }
        /// <p>Identifies a Kinesis Data Firehose delivery stream as the destination.</p>
        pub fn kinesis_firehose_output(
            mut self,
            input: crate::model::KinesisFirehoseOutput,
        ) -> Self {
            self.kinesis_firehose_output = Some(input);
            self
        }
        /// <p>Identifies a Kinesis Data Firehose delivery stream as the destination.</p>
        pub fn set_kinesis_firehose_output(
            mut self,
            input: std::option::Option<crate::model::KinesisFirehoseOutput>,
        ) -> Self {
            self.kinesis_firehose_output = input;
            self
        }
        /// <p>Identifies an Amazon Lambda function as the destination.</p>
        pub fn lambda_output(mut self, input: crate::model::LambdaOutput) -> Self {
            self.lambda_output = Some(input);
            self
        }
        /// <p>Identifies an Amazon Lambda function as the destination.</p>
        pub fn set_lambda_output(
            mut self,
            input: std::option::Option<crate::model::LambdaOutput>,
        ) -> Self {
            self.lambda_output = input;
            self
        }
        /// <p>Describes the data format when records are written to the destination.
        /// </p>
        pub fn destination_schema(mut self, input: crate::model::DestinationSchema) -> Self {
            self.destination_schema = Some(input);
            self
        }
        /// <p>Describes the data format when records are written to the destination.
        /// </p>
        pub fn set_destination_schema(
            mut self,
            input: std::option::Option<crate::model::DestinationSchema>,
        ) -> Self {
            self.destination_schema = input;
            self
        }
        /// Consumes the builder and constructs a [`Output`](crate::model::Output)
        pub fn build(self) -> crate::model::Output {
            crate::model::Output {
                name: self.name,
                kinesis_streams_output: self.kinesis_streams_output,
                kinesis_firehose_output: self.kinesis_firehose_output,
                lambda_output: self.lambda_output,
                destination_schema: self.destination_schema,
            }
        }
    }
}
impl Output {
    /// Creates a new builder-style object to manufacture [`Output`](crate::model::Output)
    pub fn builder() -> crate::model::output::Builder {
        crate::model::output::Builder::default()
    }
}

/// <p>When you configure a SQL-based Kinesis Data Analytics application's output,
/// identifies an Amazon Lambda function as the destination. You provide the function Amazon Resource
/// Name (ARN) of the Lambda function. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct LambdaOutput {
    /// <p>The Amazon Resource Name (ARN) of the destination Lambda function to write to.</p>
    /// <note>
    /// <p>To specify an earlier version of the Lambda function than the latest, include the Lambda function version in the Lambda function ARN. For more information about Lambda ARNs, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html#arn-syntax-lambda">Example ARNs: Amazon Lambda</a>
    /// </p>
    /// </note>
    pub resource_arn: std::option::Option<std::string::String>,
}
impl LambdaOutput {
    /// <p>The Amazon Resource Name (ARN) of the destination Lambda function to write to.</p>
    /// <note>
    /// <p>To specify an earlier version of the Lambda function than the latest, include the Lambda function version in the Lambda function ARN. For more information about Lambda ARNs, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html#arn-syntax-lambda">Example ARNs: Amazon Lambda</a>
    /// </p>
    /// </note>
    pub fn resource_arn(&self) -> std::option::Option<&str> {
        self.resource_arn.as_deref()
    }
}
impl std::fmt::Debug for LambdaOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("LambdaOutput");
        formatter.field("resource_arn", &self.resource_arn);
        formatter.finish()
    }
}
/// See [`LambdaOutput`](crate::model::LambdaOutput)
pub mod lambda_output {
    /// A builder for [`LambdaOutput`](crate::model::LambdaOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) resource_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the destination Lambda function to write to.</p>
        /// <note>
        /// <p>To specify an earlier version of the Lambda function than the latest, include the Lambda function version in the Lambda function ARN. For more information about Lambda ARNs, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html#arn-syntax-lambda">Example ARNs: Amazon Lambda</a>
        /// </p>
        /// </note>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the destination Lambda function to write to.</p>
        /// <note>
        /// <p>To specify an earlier version of the Lambda function than the latest, include the Lambda function version in the Lambda function ARN. For more information about Lambda ARNs, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html#arn-syntax-lambda">Example ARNs: Amazon Lambda</a>
        /// </p>
        /// </note>
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.resource_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`LambdaOutput`](crate::model::LambdaOutput)
        pub fn build(self) -> crate::model::LambdaOutput {
            crate::model::LambdaOutput {
                resource_arn: self.resource_arn,
            }
        }
    }
}
impl LambdaOutput {
    /// Creates a new builder-style object to manufacture [`LambdaOutput`](crate::model::LambdaOutput)
    pub fn builder() -> crate::model::lambda_output::Builder {
        crate::model::lambda_output::Builder::default()
    }
}

/// <p>For a SQL-based Kinesis Data Analytics application, when configuring application
/// output, identifies a Kinesis Data Firehose delivery stream as the destination. You provide the
/// stream Amazon Resource Name (ARN) of the delivery stream. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct KinesisFirehoseOutput {
    /// <p>The ARN of the destination delivery stream to write to.</p>
    pub resource_arn: std::option::Option<std::string::String>,
}
impl KinesisFirehoseOutput {
    /// <p>The ARN of the destination delivery stream to write to.</p>
    pub fn resource_arn(&self) -> std::option::Option<&str> {
        self.resource_arn.as_deref()
    }
}
impl std::fmt::Debug for KinesisFirehoseOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("KinesisFirehoseOutput");
        formatter.field("resource_arn", &self.resource_arn);
        formatter.finish()
    }
}
/// See [`KinesisFirehoseOutput`](crate::model::KinesisFirehoseOutput)
pub mod kinesis_firehose_output {
    /// A builder for [`KinesisFirehoseOutput`](crate::model::KinesisFirehoseOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) resource_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ARN of the destination delivery stream to write to.</p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the destination delivery stream to write to.</p>
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.resource_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`KinesisFirehoseOutput`](crate::model::KinesisFirehoseOutput)
        pub fn build(self) -> crate::model::KinesisFirehoseOutput {
            crate::model::KinesisFirehoseOutput {
                resource_arn: self.resource_arn,
            }
        }
    }
}
impl KinesisFirehoseOutput {
    /// Creates a new builder-style object to manufacture [`KinesisFirehoseOutput`](crate::model::KinesisFirehoseOutput)
    pub fn builder() -> crate::model::kinesis_firehose_output::Builder {
        crate::model::kinesis_firehose_output::Builder::default()
    }
}

/// <p>When you configure a SQL-based Kinesis Data Analytics application's output,
/// identifies a Kinesis data stream as the destination. You provide the stream Amazon Resource
/// Name (ARN). </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct KinesisStreamsOutput {
    /// <p>The ARN of the destination Kinesis data stream to write to.</p>
    pub resource_arn: std::option::Option<std::string::String>,
}
impl KinesisStreamsOutput {
    /// <p>The ARN of the destination Kinesis data stream to write to.</p>
    pub fn resource_arn(&self) -> std::option::Option<&str> {
        self.resource_arn.as_deref()
    }
}
impl std::fmt::Debug for KinesisStreamsOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("KinesisStreamsOutput");
        formatter.field("resource_arn", &self.resource_arn);
        formatter.finish()
    }
}
/// See [`KinesisStreamsOutput`](crate::model::KinesisStreamsOutput)
pub mod kinesis_streams_output {
    /// A builder for [`KinesisStreamsOutput`](crate::model::KinesisStreamsOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) resource_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ARN of the destination Kinesis data stream to write to.</p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the destination Kinesis data stream to write to.</p>
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.resource_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`KinesisStreamsOutput`](crate::model::KinesisStreamsOutput)
        pub fn build(self) -> crate::model::KinesisStreamsOutput {
            crate::model::KinesisStreamsOutput {
                resource_arn: self.resource_arn,
            }
        }
    }
}
impl KinesisStreamsOutput {
    /// Creates a new builder-style object to manufacture [`KinesisStreamsOutput`](crate::model::KinesisStreamsOutput)
    pub fn builder() -> crate::model::kinesis_streams_output::Builder {
        crate::model::kinesis_streams_output::Builder::default()
    }
}

/// <p>When you configure the application input for a SQL-based Kinesis Data Analytics application, you specify the streaming source, the in-application stream
/// name that is created,
/// and the mapping between the two. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Input {
    /// <p>The name prefix to use when creating an in-application stream. Suppose that you specify a
    /// prefix "<code>MyInApplicationStream</code>." Kinesis Data Analytics then creates one or more
    /// (as per the <code>InputParallelism</code> count you specified) in-application streams with the
    /// names "<code>MyInApplicationStream_001</code>," "<code>MyInApplicationStream_002</code>," and
    /// so on. </p>
    pub name_prefix: std::option::Option<std::string::String>,
    /// <p>The <a>InputProcessingConfiguration</a> for the input. An input processor transforms records as they are received
    /// from the stream, before the application's SQL code executes. Currently, the only input processing configuration available is
    /// <a>InputLambdaProcessor</a>. </p>
    pub input_processing_configuration:
        std::option::Option<crate::model::InputProcessingConfiguration>,
    /// <p>If the streaming source is an Amazon Kinesis data stream, identifies the stream's Amazon Resource Name (ARN). </p>
    pub kinesis_streams_input: std::option::Option<crate::model::KinesisStreamsInput>,
    /// <p>If the streaming source is an Amazon Kinesis Data Firehose delivery stream, identifies the delivery stream's ARN.</p>
    pub kinesis_firehose_input: std::option::Option<crate::model::KinesisFirehoseInput>,
    /// <p>Describes the number of in-application streams to create. </p>
    pub input_parallelism: std::option::Option<crate::model::InputParallelism>,
    /// <p>Describes the format of the data in the streaming source, and how each data element maps
    /// to corresponding columns in the in-application stream that is being created.</p>
    /// <p>Also used to describe the format of the reference data source.</p>
    pub input_schema: std::option::Option<crate::model::SourceSchema>,
}
impl Input {
    /// <p>The name prefix to use when creating an in-application stream. Suppose that you specify a
    /// prefix "<code>MyInApplicationStream</code>." Kinesis Data Analytics then creates one or more
    /// (as per the <code>InputParallelism</code> count you specified) in-application streams with the
    /// names "<code>MyInApplicationStream_001</code>," "<code>MyInApplicationStream_002</code>," and
    /// so on. </p>
    pub fn name_prefix(&self) -> std::option::Option<&str> {
        self.name_prefix.as_deref()
    }
    /// <p>The <a>InputProcessingConfiguration</a> for the input. An input processor transforms records as they are received
    /// from the stream, before the application's SQL code executes. Currently, the only input processing configuration available is
    /// <a>InputLambdaProcessor</a>. </p>
    pub fn input_processing_configuration(
        &self,
    ) -> std::option::Option<&crate::model::InputProcessingConfiguration> {
        self.input_processing_configuration.as_ref()
    }
    /// <p>If the streaming source is an Amazon Kinesis data stream, identifies the stream's Amazon Resource Name (ARN). </p>
    pub fn kinesis_streams_input(&self) -> std::option::Option<&crate::model::KinesisStreamsInput> {
        self.kinesis_streams_input.as_ref()
    }
    /// <p>If the streaming source is an Amazon Kinesis Data Firehose delivery stream, identifies the delivery stream's ARN.</p>
    pub fn kinesis_firehose_input(
        &self,
    ) -> std::option::Option<&crate::model::KinesisFirehoseInput> {
        self.kinesis_firehose_input.as_ref()
    }
    /// <p>Describes the number of in-application streams to create. </p>
    pub fn input_parallelism(&self) -> std::option::Option<&crate::model::InputParallelism> {
        self.input_parallelism.as_ref()
    }
    /// <p>Describes the format of the data in the streaming source, and how each data element maps
    /// to corresponding columns in the in-application stream that is being created.</p>
    /// <p>Also used to describe the format of the reference data source.</p>
    pub fn input_schema(&self) -> std::option::Option<&crate::model::SourceSchema> {
        self.input_schema.as_ref()
    }
}
impl std::fmt::Debug for Input {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Input");
        formatter.field("name_prefix", &self.name_prefix);
        formatter.field(
            "input_processing_configuration",
            &self.input_processing_configuration,
        );
        formatter.field("kinesis_streams_input", &self.kinesis_streams_input);
        formatter.field("kinesis_firehose_input", &self.kinesis_firehose_input);
        formatter.field("input_parallelism", &self.input_parallelism);
        formatter.field("input_schema", &self.input_schema);
        formatter.finish()
    }
}
/// See [`Input`](crate::model::Input)
pub mod input {
    /// A builder for [`Input`](crate::model::Input)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name_prefix: std::option::Option<std::string::String>,
        pub(crate) input_processing_configuration:
            std::option::Option<crate::model::InputProcessingConfiguration>,
        pub(crate) kinesis_streams_input: std::option::Option<crate::model::KinesisStreamsInput>,
        pub(crate) kinesis_firehose_input: std::option::Option<crate::model::KinesisFirehoseInput>,
        pub(crate) input_parallelism: std::option::Option<crate::model::InputParallelism>,
        pub(crate) input_schema: std::option::Option<crate::model::SourceSchema>,
    }
    impl Builder {
        /// <p>The name prefix to use when creating an in-application stream. Suppose that you specify a
        /// prefix "<code>MyInApplicationStream</code>." Kinesis Data Analytics then creates one or more
        /// (as per the <code>InputParallelism</code> count you specified) in-application streams with the
        /// names "<code>MyInApplicationStream_001</code>," "<code>MyInApplicationStream_002</code>," and
        /// so on. </p>
        pub fn name_prefix(mut self, input: impl Into<std::string::String>) -> Self {
            self.name_prefix = Some(input.into());
            self
        }
        /// <p>The name prefix to use when creating an in-application stream. Suppose that you specify a
        /// prefix "<code>MyInApplicationStream</code>." Kinesis Data Analytics then creates one or more
        /// (as per the <code>InputParallelism</code> count you specified) in-application streams with the
        /// names "<code>MyInApplicationStream_001</code>," "<code>MyInApplicationStream_002</code>," and
        /// so on. </p>
        pub fn set_name_prefix(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name_prefix = input;
            self
        }
        /// <p>The <a>InputProcessingConfiguration</a> for the input. An input processor transforms records as they are received
        /// from the stream, before the application's SQL code executes. Currently, the only input processing configuration available is
        /// <a>InputLambdaProcessor</a>. </p>
        pub fn input_processing_configuration(
            mut self,
            input: crate::model::InputProcessingConfiguration,
        ) -> Self {
            self.input_processing_configuration = Some(input);
            self
        }
        /// <p>The <a>InputProcessingConfiguration</a> for the input. An input processor transforms records as they are received
        /// from the stream, before the application's SQL code executes. Currently, the only input processing configuration available is
        /// <a>InputLambdaProcessor</a>. </p>
        pub fn set_input_processing_configuration(
            mut self,
            input: std::option::Option<crate::model::InputProcessingConfiguration>,
        ) -> Self {
            self.input_processing_configuration = input;
            self
        }
        /// <p>If the streaming source is an Amazon Kinesis data stream, identifies the stream's Amazon Resource Name (ARN). </p>
        pub fn kinesis_streams_input(mut self, input: crate::model::KinesisStreamsInput) -> Self {
            self.kinesis_streams_input = Some(input);
            self
        }
        /// <p>If the streaming source is an Amazon Kinesis data stream, identifies the stream's Amazon Resource Name (ARN). </p>
        pub fn set_kinesis_streams_input(
            mut self,
            input: std::option::Option<crate::model::KinesisStreamsInput>,
        ) -> Self {
            self.kinesis_streams_input = input;
            self
        }
        /// <p>If the streaming source is an Amazon Kinesis Data Firehose delivery stream, identifies the delivery stream's ARN.</p>
        pub fn kinesis_firehose_input(mut self, input: crate::model::KinesisFirehoseInput) -> Self {
            self.kinesis_firehose_input = Some(input);
            self
        }
        /// <p>If the streaming source is an Amazon Kinesis Data Firehose delivery stream, identifies the delivery stream's ARN.</p>
        pub fn set_kinesis_firehose_input(
            mut self,
            input: std::option::Option<crate::model::KinesisFirehoseInput>,
        ) -> Self {
            self.kinesis_firehose_input = input;
            self
        }
        /// <p>Describes the number of in-application streams to create. </p>
        pub fn input_parallelism(mut self, input: crate::model::InputParallelism) -> Self {
            self.input_parallelism = Some(input);
            self
        }
        /// <p>Describes the number of in-application streams to create. </p>
        pub fn set_input_parallelism(
            mut self,
            input: std::option::Option<crate::model::InputParallelism>,
        ) -> Self {
            self.input_parallelism = input;
            self
        }
        /// <p>Describes the format of the data in the streaming source, and how each data element maps
        /// to corresponding columns in the in-application stream that is being created.</p>
        /// <p>Also used to describe the format of the reference data source.</p>
        pub fn input_schema(mut self, input: crate::model::SourceSchema) -> Self {
            self.input_schema = Some(input);
            self
        }
        /// <p>Describes the format of the data in the streaming source, and how each data element maps
        /// to corresponding columns in the in-application stream that is being created.</p>
        /// <p>Also used to describe the format of the reference data source.</p>
        pub fn set_input_schema(
            mut self,
            input: std::option::Option<crate::model::SourceSchema>,
        ) -> Self {
            self.input_schema = input;
            self
        }
        /// Consumes the builder and constructs a [`Input`](crate::model::Input)
        pub fn build(self) -> crate::model::Input {
            crate::model::Input {
                name_prefix: self.name_prefix,
                input_processing_configuration: self.input_processing_configuration,
                kinesis_streams_input: self.kinesis_streams_input,
                kinesis_firehose_input: self.kinesis_firehose_input,
                input_parallelism: self.input_parallelism,
                input_schema: self.input_schema,
            }
        }
    }
}
impl Input {
    /// Creates a new builder-style object to manufacture [`Input`](crate::model::Input)
    pub fn builder() -> crate::model::input::Builder {
        crate::model::input::Builder::default()
    }
}

/// <p>For a SQL-based Kinesis Data Analytics application, identifies a Kinesis Data
/// Firehose delivery stream as the streaming source. You provide the delivery stream's Amazon
/// Resource Name (ARN).</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct KinesisFirehoseInput {
    /// <p>The Amazon Resource Name (ARN) of the delivery stream.</p>
    pub resource_arn: std::option::Option<std::string::String>,
}
impl KinesisFirehoseInput {
    /// <p>The Amazon Resource Name (ARN) of the delivery stream.</p>
    pub fn resource_arn(&self) -> std::option::Option<&str> {
        self.resource_arn.as_deref()
    }
}
impl std::fmt::Debug for KinesisFirehoseInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("KinesisFirehoseInput");
        formatter.field("resource_arn", &self.resource_arn);
        formatter.finish()
    }
}
/// See [`KinesisFirehoseInput`](crate::model::KinesisFirehoseInput)
pub mod kinesis_firehose_input {
    /// A builder for [`KinesisFirehoseInput`](crate::model::KinesisFirehoseInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) resource_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the delivery stream.</p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the delivery stream.</p>
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.resource_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`KinesisFirehoseInput`](crate::model::KinesisFirehoseInput)
        pub fn build(self) -> crate::model::KinesisFirehoseInput {
            crate::model::KinesisFirehoseInput {
                resource_arn: self.resource_arn,
            }
        }
    }
}
impl KinesisFirehoseInput {
    /// Creates a new builder-style object to manufacture [`KinesisFirehoseInput`](crate::model::KinesisFirehoseInput)
    pub fn builder() -> crate::model::kinesis_firehose_input::Builder {
        crate::model::kinesis_firehose_input::Builder::default()
    }
}

/// <p> Identifies a Kinesis data stream as the streaming source. You provide the
/// stream's Amazon Resource Name (ARN).</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct KinesisStreamsInput {
    /// <p>The ARN of the input Kinesis data stream to read.</p>
    pub resource_arn: std::option::Option<std::string::String>,
}
impl KinesisStreamsInput {
    /// <p>The ARN of the input Kinesis data stream to read.</p>
    pub fn resource_arn(&self) -> std::option::Option<&str> {
        self.resource_arn.as_deref()
    }
}
impl std::fmt::Debug for KinesisStreamsInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("KinesisStreamsInput");
        formatter.field("resource_arn", &self.resource_arn);
        formatter.finish()
    }
}
/// See [`KinesisStreamsInput`](crate::model::KinesisStreamsInput)
pub mod kinesis_streams_input {
    /// A builder for [`KinesisStreamsInput`](crate::model::KinesisStreamsInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) resource_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ARN of the input Kinesis data stream to read.</p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the input Kinesis data stream to read.</p>
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.resource_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`KinesisStreamsInput`](crate::model::KinesisStreamsInput)
        pub fn build(self) -> crate::model::KinesisStreamsInput {
            crate::model::KinesisStreamsInput {
                resource_arn: self.resource_arn,
            }
        }
    }
}
impl KinesisStreamsInput {
    /// Creates a new builder-style object to manufacture [`KinesisStreamsInput`](crate::model::KinesisStreamsInput)
    pub fn builder() -> crate::model::kinesis_streams_input::Builder {
        crate::model::kinesis_streams_input::Builder::default()
    }
}
