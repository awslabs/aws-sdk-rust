// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[allow(clippy::unnecessary_wraps)]
pub fn parse_batch_get_aggregate_resource_config_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::BatchGetAggregateResourceConfigOutput,
    crate::error::BatchGetAggregateResourceConfigError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::BatchGetAggregateResourceConfigError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::BatchGetAggregateResourceConfigError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "NoSuchConfigurationAggregatorException" => crate::error::BatchGetAggregateResourceConfigError { meta: generic, kind: crate::error::BatchGetAggregateResourceConfigErrorKind::NoSuchConfigurationAggregatorException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::no_such_configuration_aggregator_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_no_such_configuration_aggregator_exception_json_err(response.body().as_ref(), output).map_err(crate::error::BatchGetAggregateResourceConfigError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ValidationException" => crate::error::BatchGetAggregateResourceConfigError { meta: generic, kind: crate::error::BatchGetAggregateResourceConfigErrorKind::ValidationException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::validation_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_validation_exception_json_err(response.body().as_ref(), output).map_err(crate::error::BatchGetAggregateResourceConfigError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::BatchGetAggregateResourceConfigError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_batch_get_aggregate_resource_config_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::BatchGetAggregateResourceConfigOutput,
    crate::error::BatchGetAggregateResourceConfigError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::batch_get_aggregate_resource_config_output::Builder::default();
        let _ = response;
        output =
            crate::json_deser::deser_operation_crate_operation_batch_get_aggregate_resource_config(
                response.body().as_ref(),
                output,
            )
            .map_err(crate::error::BatchGetAggregateResourceConfigError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_batch_get_resource_config_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::BatchGetResourceConfigOutput,
    crate::error::BatchGetResourceConfigError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::BatchGetResourceConfigError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::BatchGetResourceConfigError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "NoAvailableConfigurationRecorderException" => crate::error::BatchGetResourceConfigError { meta: generic, kind: crate::error::BatchGetResourceConfigErrorKind::NoAvailableConfigurationRecorderException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::no_available_configuration_recorder_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_no_available_configuration_recorder_exception_json_err(response.body().as_ref(), output).map_err(crate::error::BatchGetResourceConfigError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ValidationException" => crate::error::BatchGetResourceConfigError { meta: generic, kind: crate::error::BatchGetResourceConfigErrorKind::ValidationException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::validation_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_validation_exception_json_err(response.body().as_ref(), output).map_err(crate::error::BatchGetResourceConfigError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::BatchGetResourceConfigError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_batch_get_resource_config_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::BatchGetResourceConfigOutput,
    crate::error::BatchGetResourceConfigError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::batch_get_resource_config_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_batch_get_resource_config(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::BatchGetResourceConfigError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_aggregation_authorization_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteAggregationAuthorizationOutput,
    crate::error::DeleteAggregationAuthorizationError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::DeleteAggregationAuthorizationError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DeleteAggregationAuthorizationError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InvalidParameterValueException" => crate::error::DeleteAggregationAuthorizationError { meta: generic, kind: crate::error::DeleteAggregationAuthorizationErrorKind::InvalidParameterValueException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_parameter_value_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_parameter_value_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteAggregationAuthorizationError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::DeleteAggregationAuthorizationError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_aggregation_authorization_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteAggregationAuthorizationOutput,
    crate::error::DeleteAggregationAuthorizationError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_aggregation_authorization_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_config_rule_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteConfigRuleOutput, crate::error::DeleteConfigRuleError>
{
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::DeleteConfigRuleError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DeleteConfigRuleError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "NoSuchConfigRuleException" => crate::error::DeleteConfigRuleError {
            meta: generic,
            kind: crate::error::DeleteConfigRuleErrorKind::NoSuchConfigRuleException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::no_such_config_rule_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_no_such_config_rule_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteConfigRuleError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ResourceInUseException" => crate::error::DeleteConfigRuleError {
            meta: generic,
            kind: crate::error::DeleteConfigRuleErrorKind::ResourceInUseException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::resource_in_use_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_resource_in_use_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteConfigRuleError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::DeleteConfigRuleError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_config_rule_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteConfigRuleOutput, crate::error::DeleteConfigRuleError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_config_rule_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_configuration_aggregator_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteConfigurationAggregatorOutput,
    crate::error::DeleteConfigurationAggregatorError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::DeleteConfigurationAggregatorError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DeleteConfigurationAggregatorError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "NoSuchConfigurationAggregatorException" => crate::error::DeleteConfigurationAggregatorError { meta: generic, kind: crate::error::DeleteConfigurationAggregatorErrorKind::NoSuchConfigurationAggregatorException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::no_such_configuration_aggregator_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_no_such_configuration_aggregator_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteConfigurationAggregatorError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::DeleteConfigurationAggregatorError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_configuration_aggregator_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteConfigurationAggregatorOutput,
    crate::error::DeleteConfigurationAggregatorError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_configuration_aggregator_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_configuration_recorder_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteConfigurationRecorderOutput,
    crate::error::DeleteConfigurationRecorderError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::DeleteConfigurationRecorderError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DeleteConfigurationRecorderError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "NoSuchConfigurationRecorderException" => crate::error::DeleteConfigurationRecorderError { meta: generic, kind: crate::error::DeleteConfigurationRecorderErrorKind::NoSuchConfigurationRecorderException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::no_such_configuration_recorder_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_no_such_configuration_recorder_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteConfigurationRecorderError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::DeleteConfigurationRecorderError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_configuration_recorder_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteConfigurationRecorderOutput,
    crate::error::DeleteConfigurationRecorderError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_configuration_recorder_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_conformance_pack_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteConformancePackOutput,
    crate::error::DeleteConformancePackError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::DeleteConformancePackError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DeleteConformancePackError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "NoSuchConformancePackException" => crate::error::DeleteConformancePackError {
            meta: generic,
            kind: crate::error::DeleteConformancePackErrorKind::NoSuchConformancePackException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::no_such_conformance_pack_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_no_such_conformance_pack_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteConformancePackError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ResourceInUseException" => crate::error::DeleteConformancePackError {
            meta: generic,
            kind: crate::error::DeleteConformancePackErrorKind::ResourceInUseException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::resource_in_use_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_resource_in_use_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteConformancePackError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::DeleteConformancePackError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_conformance_pack_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteConformancePackOutput,
    crate::error::DeleteConformancePackError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_conformance_pack_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_delivery_channel_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteDeliveryChannelOutput,
    crate::error::DeleteDeliveryChannelError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::DeleteDeliveryChannelError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DeleteDeliveryChannelError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "LastDeliveryChannelDeleteFailedException" => crate::error::DeleteDeliveryChannelError { meta: generic, kind: crate::error::DeleteDeliveryChannelErrorKind::LastDeliveryChannelDeleteFailedException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::last_delivery_channel_delete_failed_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_last_delivery_channel_delete_failed_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteDeliveryChannelError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "NoSuchDeliveryChannelException" => crate::error::DeleteDeliveryChannelError { meta: generic, kind: crate::error::DeleteDeliveryChannelErrorKind::NoSuchDeliveryChannelException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::no_such_delivery_channel_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_no_such_delivery_channel_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteDeliveryChannelError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::DeleteDeliveryChannelError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_delivery_channel_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteDeliveryChannelOutput,
    crate::error::DeleteDeliveryChannelError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_delivery_channel_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_evaluation_results_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteEvaluationResultsOutput,
    crate::error::DeleteEvaluationResultsError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::DeleteEvaluationResultsError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DeleteEvaluationResultsError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "NoSuchConfigRuleException" => crate::error::DeleteEvaluationResultsError {
            meta: generic,
            kind: crate::error::DeleteEvaluationResultsErrorKind::NoSuchConfigRuleException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::no_such_config_rule_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_no_such_config_rule_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteEvaluationResultsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ResourceInUseException" => crate::error::DeleteEvaluationResultsError {
            meta: generic,
            kind: crate::error::DeleteEvaluationResultsErrorKind::ResourceInUseException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::resource_in_use_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_resource_in_use_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteEvaluationResultsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::DeleteEvaluationResultsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_evaluation_results_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteEvaluationResultsOutput,
    crate::error::DeleteEvaluationResultsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_evaluation_results_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_organization_config_rule_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteOrganizationConfigRuleOutput,
    crate::error::DeleteOrganizationConfigRuleError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::DeleteOrganizationConfigRuleError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DeleteOrganizationConfigRuleError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "NoSuchOrganizationConfigRuleException" => crate::error::DeleteOrganizationConfigRuleError { meta: generic, kind: crate::error::DeleteOrganizationConfigRuleErrorKind::NoSuchOrganizationConfigRuleException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::no_such_organization_config_rule_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_no_such_organization_config_rule_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteOrganizationConfigRuleError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "OrganizationAccessDeniedException" => crate::error::DeleteOrganizationConfigRuleError { meta: generic, kind: crate::error::DeleteOrganizationConfigRuleErrorKind::OrganizationAccessDeniedException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::organization_access_denied_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_organization_access_denied_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteOrganizationConfigRuleError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ResourceInUseException" => crate::error::DeleteOrganizationConfigRuleError { meta: generic, kind: crate::error::DeleteOrganizationConfigRuleErrorKind::ResourceInUseException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::resource_in_use_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_resource_in_use_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteOrganizationConfigRuleError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::DeleteOrganizationConfigRuleError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_organization_config_rule_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteOrganizationConfigRuleOutput,
    crate::error::DeleteOrganizationConfigRuleError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_organization_config_rule_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_organization_conformance_pack_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteOrganizationConformancePackOutput,
    crate::error::DeleteOrganizationConformancePackError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::DeleteOrganizationConformancePackError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DeleteOrganizationConformancePackError::unhandled(generic))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "NoSuchOrganizationConformancePackException" => crate::error::DeleteOrganizationConformancePackError { meta: generic, kind: crate::error::DeleteOrganizationConformancePackErrorKind::NoSuchOrganizationConformancePackException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::no_such_organization_conformance_pack_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_no_such_organization_conformance_pack_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteOrganizationConformancePackError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "OrganizationAccessDeniedException" => crate::error::DeleteOrganizationConformancePackError { meta: generic, kind: crate::error::DeleteOrganizationConformancePackErrorKind::OrganizationAccessDeniedException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::organization_access_denied_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_organization_access_denied_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteOrganizationConformancePackError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ResourceInUseException" => crate::error::DeleteOrganizationConformancePackError { meta: generic, kind: crate::error::DeleteOrganizationConformancePackErrorKind::ResourceInUseException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::resource_in_use_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_resource_in_use_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteOrganizationConformancePackError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::DeleteOrganizationConformancePackError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_organization_conformance_pack_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteOrganizationConformancePackOutput,
    crate::error::DeleteOrganizationConformancePackError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::delete_organization_conformance_pack_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_pending_aggregation_request_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeletePendingAggregationRequestOutput,
    crate::error::DeletePendingAggregationRequestError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::DeletePendingAggregationRequestError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DeletePendingAggregationRequestError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InvalidParameterValueException" => crate::error::DeletePendingAggregationRequestError { meta: generic, kind: crate::error::DeletePendingAggregationRequestErrorKind::InvalidParameterValueException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_parameter_value_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_parameter_value_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeletePendingAggregationRequestError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::DeletePendingAggregationRequestError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_pending_aggregation_request_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeletePendingAggregationRequestOutput,
    crate::error::DeletePendingAggregationRequestError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::delete_pending_aggregation_request_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_remediation_configuration_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteRemediationConfigurationOutput,
    crate::error::DeleteRemediationConfigurationError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::DeleteRemediationConfigurationError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DeleteRemediationConfigurationError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InsufficientPermissionsException" => crate::error::DeleteRemediationConfigurationError { meta: generic, kind: crate::error::DeleteRemediationConfigurationErrorKind::InsufficientPermissionsException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::insufficient_permissions_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_insufficient_permissions_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteRemediationConfigurationError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidParameterValueException" => crate::error::DeleteRemediationConfigurationError { meta: generic, kind: crate::error::DeleteRemediationConfigurationErrorKind::InvalidParameterValueException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_parameter_value_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_parameter_value_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteRemediationConfigurationError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "NoSuchRemediationConfigurationException" => crate::error::DeleteRemediationConfigurationError { meta: generic, kind: crate::error::DeleteRemediationConfigurationErrorKind::NoSuchRemediationConfigurationException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::no_such_remediation_configuration_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_no_such_remediation_configuration_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteRemediationConfigurationError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "RemediationInProgressException" => crate::error::DeleteRemediationConfigurationError { meta: generic, kind: crate::error::DeleteRemediationConfigurationErrorKind::RemediationInProgressException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::remediation_in_progress_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_remediation_in_progress_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteRemediationConfigurationError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::DeleteRemediationConfigurationError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_remediation_configuration_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteRemediationConfigurationOutput,
    crate::error::DeleteRemediationConfigurationError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_remediation_configuration_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_remediation_exceptions_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteRemediationExceptionsOutput,
    crate::error::DeleteRemediationExceptionsError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::DeleteRemediationExceptionsError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DeleteRemediationExceptionsError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "NoSuchRemediationExceptionException" => crate::error::DeleteRemediationExceptionsError { meta: generic, kind: crate::error::DeleteRemediationExceptionsErrorKind::NoSuchRemediationExceptionException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::no_such_remediation_exception_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_no_such_remediation_exception_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteRemediationExceptionsError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::DeleteRemediationExceptionsError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_remediation_exceptions_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteRemediationExceptionsOutput,
    crate::error::DeleteRemediationExceptionsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_remediation_exceptions_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_delete_remediation_exceptions(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DeleteRemediationExceptionsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_resource_config_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteResourceConfigOutput,
    crate::error::DeleteResourceConfigError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::DeleteResourceConfigError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DeleteResourceConfigError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "NoRunningConfigurationRecorderException" => crate::error::DeleteResourceConfigError {
            meta: generic,
            kind:
                crate::error::DeleteResourceConfigErrorKind::NoRunningConfigurationRecorderException(
                    {
                        #[allow(unused_mut)]
                        let mut tmp = {
                            #[allow(unused_mut)]let mut output = crate::error::no_running_configuration_recorder_exception::Builder::default();
                            let _ = response;
                            output = crate::json_deser::deser_structure_crate_error_no_running_configuration_recorder_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteResourceConfigError::unhandled)?;
                            output.build()
                        };
                        if (&tmp.message).is_none() {
                            tmp.message = _error_message;
                        }
                        tmp
                    },
                ),
        },
        "ValidationException" => crate::error::DeleteResourceConfigError {
            meta: generic,
            kind: crate::error::DeleteResourceConfigErrorKind::ValidationException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::validation_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_validation_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteResourceConfigError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::DeleteResourceConfigError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_resource_config_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteResourceConfigOutput,
    crate::error::DeleteResourceConfigError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_resource_config_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_retention_configuration_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteRetentionConfigurationOutput,
    crate::error::DeleteRetentionConfigurationError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::DeleteRetentionConfigurationError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DeleteRetentionConfigurationError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InvalidParameterValueException" => crate::error::DeleteRetentionConfigurationError { meta: generic, kind: crate::error::DeleteRetentionConfigurationErrorKind::InvalidParameterValueException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_parameter_value_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_parameter_value_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteRetentionConfigurationError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "NoSuchRetentionConfigurationException" => crate::error::DeleteRetentionConfigurationError { meta: generic, kind: crate::error::DeleteRetentionConfigurationErrorKind::NoSuchRetentionConfigurationException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::no_such_retention_configuration_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_no_such_retention_configuration_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteRetentionConfigurationError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::DeleteRetentionConfigurationError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_retention_configuration_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteRetentionConfigurationOutput,
    crate::error::DeleteRetentionConfigurationError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_retention_configuration_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_stored_query_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteStoredQueryOutput, crate::error::DeleteStoredQueryError>
{
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::DeleteStoredQueryError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DeleteStoredQueryError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ResourceNotFoundException" => crate::error::DeleteStoredQueryError {
            meta: generic,
            kind: crate::error::DeleteStoredQueryErrorKind::ResourceNotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::resource_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_resource_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteStoredQueryError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ValidationException" => crate::error::DeleteStoredQueryError {
            meta: generic,
            kind: crate::error::DeleteStoredQueryErrorKind::ValidationException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::validation_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_validation_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteStoredQueryError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::DeleteStoredQueryError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_stored_query_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteStoredQueryOutput, crate::error::DeleteStoredQueryError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_stored_query_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_deliver_config_snapshot_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeliverConfigSnapshotOutput,
    crate::error::DeliverConfigSnapshotError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::DeliverConfigSnapshotError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DeliverConfigSnapshotError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "NoAvailableConfigurationRecorderException" => crate::error::DeliverConfigSnapshotError { meta: generic, kind: crate::error::DeliverConfigSnapshotErrorKind::NoAvailableConfigurationRecorderException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::no_available_configuration_recorder_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_no_available_configuration_recorder_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeliverConfigSnapshotError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "NoRunningConfigurationRecorderException" => crate::error::DeliverConfigSnapshotError { meta: generic, kind: crate::error::DeliverConfigSnapshotErrorKind::NoRunningConfigurationRecorderException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::no_running_configuration_recorder_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_no_running_configuration_recorder_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeliverConfigSnapshotError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "NoSuchDeliveryChannelException" => crate::error::DeliverConfigSnapshotError { meta: generic, kind: crate::error::DeliverConfigSnapshotErrorKind::NoSuchDeliveryChannelException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::no_such_delivery_channel_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_no_such_delivery_channel_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeliverConfigSnapshotError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::DeliverConfigSnapshotError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_deliver_config_snapshot_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeliverConfigSnapshotOutput,
    crate::error::DeliverConfigSnapshotError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::deliver_config_snapshot_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_deliver_config_snapshot(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DeliverConfigSnapshotError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_aggregate_compliance_by_config_rules_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeAggregateComplianceByConfigRulesOutput,
    crate::error::DescribeAggregateComplianceByConfigRulesError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::DescribeAggregateComplianceByConfigRulesError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(
                crate::error::DescribeAggregateComplianceByConfigRulesError::unhandled(generic),
            )
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InvalidLimitException" => crate::error::DescribeAggregateComplianceByConfigRulesError { meta: generic, kind: crate::error::DescribeAggregateComplianceByConfigRulesErrorKind::InvalidLimitException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_limit_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_limit_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeAggregateComplianceByConfigRulesError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidNextTokenException" => crate::error::DescribeAggregateComplianceByConfigRulesError { meta: generic, kind: crate::error::DescribeAggregateComplianceByConfigRulesErrorKind::InvalidNextTokenException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_next_token_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_next_token_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeAggregateComplianceByConfigRulesError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "NoSuchConfigurationAggregatorException" => crate::error::DescribeAggregateComplianceByConfigRulesError { meta: generic, kind: crate::error::DescribeAggregateComplianceByConfigRulesErrorKind::NoSuchConfigurationAggregatorException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::no_such_configuration_aggregator_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_no_such_configuration_aggregator_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeAggregateComplianceByConfigRulesError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ValidationException" => crate::error::DescribeAggregateComplianceByConfigRulesError { meta: generic, kind: crate::error::DescribeAggregateComplianceByConfigRulesErrorKind::ValidationException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::validation_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_validation_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeAggregateComplianceByConfigRulesError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::DescribeAggregateComplianceByConfigRulesError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_aggregate_compliance_by_config_rules_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeAggregateComplianceByConfigRulesOutput,
    crate::error::DescribeAggregateComplianceByConfigRulesError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::describe_aggregate_compliance_by_config_rules_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_describe_aggregate_compliance_by_config_rules(response.body().as_ref(), output).map_err(crate::error::DescribeAggregateComplianceByConfigRulesError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_aggregate_compliance_by_conformance_packs_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeAggregateComplianceByConformancePacksOutput,
    crate::error::DescribeAggregateComplianceByConformancePacksError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::DescribeAggregateComplianceByConformancePacksError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(
                crate::error::DescribeAggregateComplianceByConformancePacksError::unhandled(
                    generic,
                ),
            )
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InvalidLimitException" => crate::error::DescribeAggregateComplianceByConformancePacksError { meta: generic, kind: crate::error::DescribeAggregateComplianceByConformancePacksErrorKind::InvalidLimitException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_limit_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_limit_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeAggregateComplianceByConformancePacksError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidNextTokenException" => crate::error::DescribeAggregateComplianceByConformancePacksError { meta: generic, kind: crate::error::DescribeAggregateComplianceByConformancePacksErrorKind::InvalidNextTokenException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_next_token_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_next_token_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeAggregateComplianceByConformancePacksError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "NoSuchConfigurationAggregatorException" => crate::error::DescribeAggregateComplianceByConformancePacksError { meta: generic, kind: crate::error::DescribeAggregateComplianceByConformancePacksErrorKind::NoSuchConfigurationAggregatorException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::no_such_configuration_aggregator_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_no_such_configuration_aggregator_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeAggregateComplianceByConformancePacksError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ValidationException" => crate::error::DescribeAggregateComplianceByConformancePacksError { meta: generic, kind: crate::error::DescribeAggregateComplianceByConformancePacksErrorKind::ValidationException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::validation_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_validation_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeAggregateComplianceByConformancePacksError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::DescribeAggregateComplianceByConformancePacksError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_aggregate_compliance_by_conformance_packs_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeAggregateComplianceByConformancePacksOutput,
    crate::error::DescribeAggregateComplianceByConformancePacksError,
> {
    Ok({
        #[allow(unused_mut)]let mut output = crate::output::describe_aggregate_compliance_by_conformance_packs_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_describe_aggregate_compliance_by_conformance_packs(response.body().as_ref(), output).map_err(crate::error::DescribeAggregateComplianceByConformancePacksError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_aggregation_authorizations_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeAggregationAuthorizationsOutput,
    crate::error::DescribeAggregationAuthorizationsError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::DescribeAggregationAuthorizationsError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DescribeAggregationAuthorizationsError::unhandled(generic))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InvalidLimitException" => crate::error::DescribeAggregationAuthorizationsError { meta: generic, kind: crate::error::DescribeAggregationAuthorizationsErrorKind::InvalidLimitException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_limit_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_limit_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeAggregationAuthorizationsError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidNextTokenException" => crate::error::DescribeAggregationAuthorizationsError { meta: generic, kind: crate::error::DescribeAggregationAuthorizationsErrorKind::InvalidNextTokenException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_next_token_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_next_token_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeAggregationAuthorizationsError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidParameterValueException" => crate::error::DescribeAggregationAuthorizationsError { meta: generic, kind: crate::error::DescribeAggregationAuthorizationsErrorKind::InvalidParameterValueException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_parameter_value_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_parameter_value_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeAggregationAuthorizationsError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::DescribeAggregationAuthorizationsError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_aggregation_authorizations_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeAggregationAuthorizationsOutput,
    crate::error::DescribeAggregationAuthorizationsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::describe_aggregation_authorizations_output::Builder::default();
        let _ = response;
        output =
            crate::json_deser::deser_operation_crate_operation_describe_aggregation_authorizations(
                response.body().as_ref(),
                output,
            )
            .map_err(crate::error::DescribeAggregationAuthorizationsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_compliance_by_config_rule_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeComplianceByConfigRuleOutput,
    crate::error::DescribeComplianceByConfigRuleError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::DescribeComplianceByConfigRuleError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DescribeComplianceByConfigRuleError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InvalidNextTokenException" => crate::error::DescribeComplianceByConfigRuleError { meta: generic, kind: crate::error::DescribeComplianceByConfigRuleErrorKind::InvalidNextTokenException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_next_token_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_next_token_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeComplianceByConfigRuleError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidParameterValueException" => crate::error::DescribeComplianceByConfigRuleError { meta: generic, kind: crate::error::DescribeComplianceByConfigRuleErrorKind::InvalidParameterValueException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_parameter_value_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_parameter_value_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeComplianceByConfigRuleError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "NoSuchConfigRuleException" => crate::error::DescribeComplianceByConfigRuleError { meta: generic, kind: crate::error::DescribeComplianceByConfigRuleErrorKind::NoSuchConfigRuleException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::no_such_config_rule_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_no_such_config_rule_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeComplianceByConfigRuleError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::DescribeComplianceByConfigRuleError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_compliance_by_config_rule_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeComplianceByConfigRuleOutput,
    crate::error::DescribeComplianceByConfigRuleError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::describe_compliance_by_config_rule_output::Builder::default();
        let _ = response;
        output =
            crate::json_deser::deser_operation_crate_operation_describe_compliance_by_config_rule(
                response.body().as_ref(),
                output,
            )
            .map_err(crate::error::DescribeComplianceByConfigRuleError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_compliance_by_resource_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeComplianceByResourceOutput,
    crate::error::DescribeComplianceByResourceError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::DescribeComplianceByResourceError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DescribeComplianceByResourceError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InvalidNextTokenException" => crate::error::DescribeComplianceByResourceError {
            meta: generic,
            kind: crate::error::DescribeComplianceByResourceErrorKind::InvalidNextTokenException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_next_token_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_next_token_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeComplianceByResourceError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidParameterValueException" => crate::error::DescribeComplianceByResourceError {
            meta: generic,
            kind:
                crate::error::DescribeComplianceByResourceErrorKind::InvalidParameterValueException(
                    {
                        #[allow(unused_mut)]
                        let mut tmp = {
                            #[allow(unused_mut)]
                            let mut output =
                                crate::error::invalid_parameter_value_exception::Builder::default();
                            let _ = response;
                            output = crate::json_deser::deser_structure_crate_error_invalid_parameter_value_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeComplianceByResourceError::unhandled)?;
                            output.build()
                        };
                        if (&tmp.message).is_none() {
                            tmp.message = _error_message;
                        }
                        tmp
                    },
                ),
        },
        _ => crate::error::DescribeComplianceByResourceError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_compliance_by_resource_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeComplianceByResourceOutput,
    crate::error::DescribeComplianceByResourceError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_compliance_by_resource_output::Builder::default();
        let _ = response;
        output =
            crate::json_deser::deser_operation_crate_operation_describe_compliance_by_resource(
                response.body().as_ref(),
                output,
            )
            .map_err(crate::error::DescribeComplianceByResourceError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_config_rule_evaluation_status_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeConfigRuleEvaluationStatusOutput,
    crate::error::DescribeConfigRuleEvaluationStatusError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::DescribeConfigRuleEvaluationStatusError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DescribeConfigRuleEvaluationStatusError::unhandled(generic))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InvalidNextTokenException" => crate::error::DescribeConfigRuleEvaluationStatusError { meta: generic, kind: crate::error::DescribeConfigRuleEvaluationStatusErrorKind::InvalidNextTokenException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_next_token_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_next_token_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeConfigRuleEvaluationStatusError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidParameterValueException" => crate::error::DescribeConfigRuleEvaluationStatusError { meta: generic, kind: crate::error::DescribeConfigRuleEvaluationStatusErrorKind::InvalidParameterValueException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_parameter_value_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_parameter_value_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeConfigRuleEvaluationStatusError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "NoSuchConfigRuleException" => crate::error::DescribeConfigRuleEvaluationStatusError { meta: generic, kind: crate::error::DescribeConfigRuleEvaluationStatusErrorKind::NoSuchConfigRuleException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::no_such_config_rule_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_no_such_config_rule_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeConfigRuleEvaluationStatusError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::DescribeConfigRuleEvaluationStatusError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_config_rule_evaluation_status_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeConfigRuleEvaluationStatusOutput,
    crate::error::DescribeConfigRuleEvaluationStatusError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::describe_config_rule_evaluation_status_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_describe_config_rule_evaluation_status(response.body().as_ref(), output).map_err(crate::error::DescribeConfigRuleEvaluationStatusError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_config_rules_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeConfigRulesOutput,
    crate::error::DescribeConfigRulesError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::DescribeConfigRulesError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DescribeConfigRulesError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InvalidNextTokenException" => crate::error::DescribeConfigRulesError {
            meta: generic,
            kind: crate::error::DescribeConfigRulesErrorKind::InvalidNextTokenException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_next_token_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_next_token_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeConfigRulesError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "NoSuchConfigRuleException" => crate::error::DescribeConfigRulesError {
            meta: generic,
            kind: crate::error::DescribeConfigRulesErrorKind::NoSuchConfigRuleException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::no_such_config_rule_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_no_such_config_rule_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeConfigRulesError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::DescribeConfigRulesError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_config_rules_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeConfigRulesOutput,
    crate::error::DescribeConfigRulesError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_config_rules_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_describe_config_rules(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeConfigRulesError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_configuration_aggregators_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeConfigurationAggregatorsOutput,
    crate::error::DescribeConfigurationAggregatorsError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::DescribeConfigurationAggregatorsError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DescribeConfigurationAggregatorsError::unhandled(generic))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InvalidLimitException" => crate::error::DescribeConfigurationAggregatorsError { meta: generic, kind: crate::error::DescribeConfigurationAggregatorsErrorKind::InvalidLimitException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_limit_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_limit_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeConfigurationAggregatorsError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidNextTokenException" => crate::error::DescribeConfigurationAggregatorsError { meta: generic, kind: crate::error::DescribeConfigurationAggregatorsErrorKind::InvalidNextTokenException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_next_token_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_next_token_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeConfigurationAggregatorsError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidParameterValueException" => crate::error::DescribeConfigurationAggregatorsError { meta: generic, kind: crate::error::DescribeConfigurationAggregatorsErrorKind::InvalidParameterValueException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_parameter_value_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_parameter_value_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeConfigurationAggregatorsError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "NoSuchConfigurationAggregatorException" => crate::error::DescribeConfigurationAggregatorsError { meta: generic, kind: crate::error::DescribeConfigurationAggregatorsErrorKind::NoSuchConfigurationAggregatorException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::no_such_configuration_aggregator_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_no_such_configuration_aggregator_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeConfigurationAggregatorsError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::DescribeConfigurationAggregatorsError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_configuration_aggregators_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeConfigurationAggregatorsOutput,
    crate::error::DescribeConfigurationAggregatorsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::describe_configuration_aggregators_output::Builder::default();
        let _ = response;
        output =
            crate::json_deser::deser_operation_crate_operation_describe_configuration_aggregators(
                response.body().as_ref(),
                output,
            )
            .map_err(crate::error::DescribeConfigurationAggregatorsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_configuration_aggregator_sources_status_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeConfigurationAggregatorSourcesStatusOutput,
    crate::error::DescribeConfigurationAggregatorSourcesStatusError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::DescribeConfigurationAggregatorSourcesStatusError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(
                crate::error::DescribeConfigurationAggregatorSourcesStatusError::unhandled(generic),
            )
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InvalidLimitException" => crate::error::DescribeConfigurationAggregatorSourcesStatusError { meta: generic, kind: crate::error::DescribeConfigurationAggregatorSourcesStatusErrorKind::InvalidLimitException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_limit_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_limit_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeConfigurationAggregatorSourcesStatusError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidNextTokenException" => crate::error::DescribeConfigurationAggregatorSourcesStatusError { meta: generic, kind: crate::error::DescribeConfigurationAggregatorSourcesStatusErrorKind::InvalidNextTokenException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_next_token_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_next_token_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeConfigurationAggregatorSourcesStatusError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidParameterValueException" => crate::error::DescribeConfigurationAggregatorSourcesStatusError { meta: generic, kind: crate::error::DescribeConfigurationAggregatorSourcesStatusErrorKind::InvalidParameterValueException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_parameter_value_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_parameter_value_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeConfigurationAggregatorSourcesStatusError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "NoSuchConfigurationAggregatorException" => crate::error::DescribeConfigurationAggregatorSourcesStatusError { meta: generic, kind: crate::error::DescribeConfigurationAggregatorSourcesStatusErrorKind::NoSuchConfigurationAggregatorException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::no_such_configuration_aggregator_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_no_such_configuration_aggregator_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeConfigurationAggregatorSourcesStatusError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::DescribeConfigurationAggregatorSourcesStatusError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_configuration_aggregator_sources_status_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeConfigurationAggregatorSourcesStatusOutput,
    crate::error::DescribeConfigurationAggregatorSourcesStatusError,
> {
    Ok({
        #[allow(unused_mut)]let mut output = crate::output::describe_configuration_aggregator_sources_status_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_describe_configuration_aggregator_sources_status(response.body().as_ref(), output).map_err(crate::error::DescribeConfigurationAggregatorSourcesStatusError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_configuration_recorders_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeConfigurationRecordersOutput,
    crate::error::DescribeConfigurationRecordersError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::DescribeConfigurationRecordersError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DescribeConfigurationRecordersError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "NoSuchConfigurationRecorderException" => crate::error::DescribeConfigurationRecordersError { meta: generic, kind: crate::error::DescribeConfigurationRecordersErrorKind::NoSuchConfigurationRecorderException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::no_such_configuration_recorder_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_no_such_configuration_recorder_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeConfigurationRecordersError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::DescribeConfigurationRecordersError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_configuration_recorders_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeConfigurationRecordersOutput,
    crate::error::DescribeConfigurationRecordersError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_configuration_recorders_output::Builder::default();
        let _ = response;
        output =
            crate::json_deser::deser_operation_crate_operation_describe_configuration_recorders(
                response.body().as_ref(),
                output,
            )
            .map_err(crate::error::DescribeConfigurationRecordersError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_configuration_recorder_status_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeConfigurationRecorderStatusOutput,
    crate::error::DescribeConfigurationRecorderStatusError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::DescribeConfigurationRecorderStatusError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DescribeConfigurationRecorderStatusError::unhandled(generic))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "NoSuchConfigurationRecorderException" => crate::error::DescribeConfigurationRecorderStatusError { meta: generic, kind: crate::error::DescribeConfigurationRecorderStatusErrorKind::NoSuchConfigurationRecorderException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::no_such_configuration_recorder_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_no_such_configuration_recorder_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeConfigurationRecorderStatusError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::DescribeConfigurationRecorderStatusError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_configuration_recorder_status_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeConfigurationRecorderStatusOutput,
    crate::error::DescribeConfigurationRecorderStatusError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::describe_configuration_recorder_status_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_describe_configuration_recorder_status(response.body().as_ref(), output).map_err(crate::error::DescribeConfigurationRecorderStatusError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_conformance_pack_compliance_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeConformancePackComplianceOutput,
    crate::error::DescribeConformancePackComplianceError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::DescribeConformancePackComplianceError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DescribeConformancePackComplianceError::unhandled(generic))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InvalidLimitException" => crate::error::DescribeConformancePackComplianceError { meta: generic, kind: crate::error::DescribeConformancePackComplianceErrorKind::InvalidLimitException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_limit_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_limit_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeConformancePackComplianceError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidNextTokenException" => crate::error::DescribeConformancePackComplianceError { meta: generic, kind: crate::error::DescribeConformancePackComplianceErrorKind::InvalidNextTokenException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_next_token_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_next_token_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeConformancePackComplianceError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidParameterValueException" => crate::error::DescribeConformancePackComplianceError { meta: generic, kind: crate::error::DescribeConformancePackComplianceErrorKind::InvalidParameterValueException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_parameter_value_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_parameter_value_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeConformancePackComplianceError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "NoSuchConfigRuleInConformancePackException" => crate::error::DescribeConformancePackComplianceError { meta: generic, kind: crate::error::DescribeConformancePackComplianceErrorKind::NoSuchConfigRuleInConformancePackException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::no_such_config_rule_in_conformance_pack_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_no_such_config_rule_in_conformance_pack_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeConformancePackComplianceError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "NoSuchConformancePackException" => crate::error::DescribeConformancePackComplianceError { meta: generic, kind: crate::error::DescribeConformancePackComplianceErrorKind::NoSuchConformancePackException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::no_such_conformance_pack_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_no_such_conformance_pack_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeConformancePackComplianceError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::DescribeConformancePackComplianceError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_conformance_pack_compliance_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeConformancePackComplianceOutput,
    crate::error::DescribeConformancePackComplianceError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::describe_conformance_pack_compliance_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_describe_conformance_pack_compliance(response.body().as_ref(), output).map_err(crate::error::DescribeConformancePackComplianceError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_conformance_packs_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeConformancePacksOutput,
    crate::error::DescribeConformancePacksError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::DescribeConformancePacksError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DescribeConformancePacksError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InvalidLimitException" => crate::error::DescribeConformancePacksError {
            meta: generic,
            kind: crate::error::DescribeConformancePacksErrorKind::InvalidLimitException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_limit_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_limit_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeConformancePacksError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidNextTokenException" => crate::error::DescribeConformancePacksError {
            meta: generic,
            kind: crate::error::DescribeConformancePacksErrorKind::InvalidNextTokenException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_next_token_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_next_token_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeConformancePacksError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidParameterValueException" => crate::error::DescribeConformancePacksError {
            meta: generic,
            kind: crate::error::DescribeConformancePacksErrorKind::InvalidParameterValueException(
                {
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::invalid_parameter_value_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_crate_error_invalid_parameter_value_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeConformancePacksError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                },
            ),
        },
        "NoSuchConformancePackException" => crate::error::DescribeConformancePacksError {
            meta: generic,
            kind: crate::error::DescribeConformancePacksErrorKind::NoSuchConformancePackException(
                {
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::no_such_conformance_pack_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_crate_error_no_such_conformance_pack_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeConformancePacksError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                },
            ),
        },
        _ => crate::error::DescribeConformancePacksError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_conformance_packs_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeConformancePacksOutput,
    crate::error::DescribeConformancePacksError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_conformance_packs_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_describe_conformance_packs(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeConformancePacksError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_conformance_pack_status_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeConformancePackStatusOutput,
    crate::error::DescribeConformancePackStatusError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::DescribeConformancePackStatusError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DescribeConformancePackStatusError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InvalidLimitException" => crate::error::DescribeConformancePackStatusError {
            meta: generic,
            kind: crate::error::DescribeConformancePackStatusErrorKind::InvalidLimitException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_limit_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_limit_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeConformancePackStatusError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidNextTokenException" => crate::error::DescribeConformancePackStatusError {
            meta: generic,
            kind: crate::error::DescribeConformancePackStatusErrorKind::InvalidNextTokenException(
                {
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::invalid_next_token_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_crate_error_invalid_next_token_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeConformancePackStatusError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                },
            ),
        },
        "InvalidParameterValueException" => crate::error::DescribeConformancePackStatusError {
            meta: generic,
            kind:
                crate::error::DescribeConformancePackStatusErrorKind::InvalidParameterValueException(
                    {
                        #[allow(unused_mut)]
                        let mut tmp = {
                            #[allow(unused_mut)]
                            let mut output =
                                crate::error::invalid_parameter_value_exception::Builder::default();
                            let _ = response;
                            output = crate::json_deser::deser_structure_crate_error_invalid_parameter_value_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeConformancePackStatusError::unhandled)?;
                            output.build()
                        };
                        if (&tmp.message).is_none() {
                            tmp.message = _error_message;
                        }
                        tmp
                    },
                ),
        },
        _ => crate::error::DescribeConformancePackStatusError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_conformance_pack_status_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeConformancePackStatusOutput,
    crate::error::DescribeConformancePackStatusError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_conformance_pack_status_output::Builder::default();
        let _ = response;
        output =
            crate::json_deser::deser_operation_crate_operation_describe_conformance_pack_status(
                response.body().as_ref(),
                output,
            )
            .map_err(crate::error::DescribeConformancePackStatusError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_delivery_channels_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeDeliveryChannelsOutput,
    crate::error::DescribeDeliveryChannelsError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::DescribeDeliveryChannelsError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DescribeDeliveryChannelsError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "NoSuchDeliveryChannelException" => crate::error::DescribeDeliveryChannelsError {
            meta: generic,
            kind: crate::error::DescribeDeliveryChannelsErrorKind::NoSuchDeliveryChannelException(
                {
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::no_such_delivery_channel_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_crate_error_no_such_delivery_channel_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeDeliveryChannelsError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                },
            ),
        },
        _ => crate::error::DescribeDeliveryChannelsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_delivery_channels_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeDeliveryChannelsOutput,
    crate::error::DescribeDeliveryChannelsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_delivery_channels_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_describe_delivery_channels(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeDeliveryChannelsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_delivery_channel_status_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeDeliveryChannelStatusOutput,
    crate::error::DescribeDeliveryChannelStatusError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::DescribeDeliveryChannelStatusError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DescribeDeliveryChannelStatusError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "NoSuchDeliveryChannelException" => crate::error::DescribeDeliveryChannelStatusError {
            meta: generic,
            kind:
                crate::error::DescribeDeliveryChannelStatusErrorKind::NoSuchDeliveryChannelException(
                    {
                        #[allow(unused_mut)]
                        let mut tmp = {
                            #[allow(unused_mut)]
                            let mut output =
                                crate::error::no_such_delivery_channel_exception::Builder::default(
                                );
                            let _ = response;
                            output = crate::json_deser::deser_structure_crate_error_no_such_delivery_channel_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeDeliveryChannelStatusError::unhandled)?;
                            output.build()
                        };
                        if (&tmp.message).is_none() {
                            tmp.message = _error_message;
                        }
                        tmp
                    },
                ),
        },
        _ => crate::error::DescribeDeliveryChannelStatusError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_delivery_channel_status_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeDeliveryChannelStatusOutput,
    crate::error::DescribeDeliveryChannelStatusError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_delivery_channel_status_output::Builder::default();
        let _ = response;
        output =
            crate::json_deser::deser_operation_crate_operation_describe_delivery_channel_status(
                response.body().as_ref(),
                output,
            )
            .map_err(crate::error::DescribeDeliveryChannelStatusError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_organization_config_rules_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeOrganizationConfigRulesOutput,
    crate::error::DescribeOrganizationConfigRulesError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::DescribeOrganizationConfigRulesError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DescribeOrganizationConfigRulesError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InvalidLimitException" => crate::error::DescribeOrganizationConfigRulesError { meta: generic, kind: crate::error::DescribeOrganizationConfigRulesErrorKind::InvalidLimitException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_limit_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_limit_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeOrganizationConfigRulesError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidNextTokenException" => crate::error::DescribeOrganizationConfigRulesError { meta: generic, kind: crate::error::DescribeOrganizationConfigRulesErrorKind::InvalidNextTokenException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_next_token_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_next_token_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeOrganizationConfigRulesError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "NoSuchOrganizationConfigRuleException" => crate::error::DescribeOrganizationConfigRulesError { meta: generic, kind: crate::error::DescribeOrganizationConfigRulesErrorKind::NoSuchOrganizationConfigRuleException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::no_such_organization_config_rule_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_no_such_organization_config_rule_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeOrganizationConfigRulesError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "OrganizationAccessDeniedException" => crate::error::DescribeOrganizationConfigRulesError { meta: generic, kind: crate::error::DescribeOrganizationConfigRulesErrorKind::OrganizationAccessDeniedException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::organization_access_denied_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_organization_access_denied_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeOrganizationConfigRulesError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::DescribeOrganizationConfigRulesError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_organization_config_rules_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeOrganizationConfigRulesOutput,
    crate::error::DescribeOrganizationConfigRulesError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::describe_organization_config_rules_output::Builder::default();
        let _ = response;
        output =
            crate::json_deser::deser_operation_crate_operation_describe_organization_config_rules(
                response.body().as_ref(),
                output,
            )
            .map_err(crate::error::DescribeOrganizationConfigRulesError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_organization_config_rule_statuses_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeOrganizationConfigRuleStatusesOutput,
    crate::error::DescribeOrganizationConfigRuleStatusesError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::DescribeOrganizationConfigRuleStatusesError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(
                crate::error::DescribeOrganizationConfigRuleStatusesError::unhandled(generic),
            )
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InvalidLimitException" => crate::error::DescribeOrganizationConfigRuleStatusesError { meta: generic, kind: crate::error::DescribeOrganizationConfigRuleStatusesErrorKind::InvalidLimitException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_limit_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_limit_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeOrganizationConfigRuleStatusesError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidNextTokenException" => crate::error::DescribeOrganizationConfigRuleStatusesError { meta: generic, kind: crate::error::DescribeOrganizationConfigRuleStatusesErrorKind::InvalidNextTokenException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_next_token_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_next_token_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeOrganizationConfigRuleStatusesError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "NoSuchOrganizationConfigRuleException" => crate::error::DescribeOrganizationConfigRuleStatusesError { meta: generic, kind: crate::error::DescribeOrganizationConfigRuleStatusesErrorKind::NoSuchOrganizationConfigRuleException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::no_such_organization_config_rule_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_no_such_organization_config_rule_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeOrganizationConfigRuleStatusesError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "OrganizationAccessDeniedException" => crate::error::DescribeOrganizationConfigRuleStatusesError { meta: generic, kind: crate::error::DescribeOrganizationConfigRuleStatusesErrorKind::OrganizationAccessDeniedException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::organization_access_denied_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_organization_access_denied_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeOrganizationConfigRuleStatusesError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::DescribeOrganizationConfigRuleStatusesError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_organization_config_rule_statuses_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeOrganizationConfigRuleStatusesOutput,
    crate::error::DescribeOrganizationConfigRuleStatusesError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::describe_organization_config_rule_statuses_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_describe_organization_config_rule_statuses(response.body().as_ref(), output).map_err(crate::error::DescribeOrganizationConfigRuleStatusesError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_organization_conformance_packs_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeOrganizationConformancePacksOutput,
    crate::error::DescribeOrganizationConformancePacksError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::DescribeOrganizationConformancePacksError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DescribeOrganizationConformancePacksError::unhandled(generic))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InvalidLimitException" => crate::error::DescribeOrganizationConformancePacksError { meta: generic, kind: crate::error::DescribeOrganizationConformancePacksErrorKind::InvalidLimitException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_limit_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_limit_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeOrganizationConformancePacksError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidNextTokenException" => crate::error::DescribeOrganizationConformancePacksError { meta: generic, kind: crate::error::DescribeOrganizationConformancePacksErrorKind::InvalidNextTokenException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_next_token_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_next_token_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeOrganizationConformancePacksError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "NoSuchOrganizationConformancePackException" => crate::error::DescribeOrganizationConformancePacksError { meta: generic, kind: crate::error::DescribeOrganizationConformancePacksErrorKind::NoSuchOrganizationConformancePackException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::no_such_organization_conformance_pack_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_no_such_organization_conformance_pack_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeOrganizationConformancePacksError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "OrganizationAccessDeniedException" => crate::error::DescribeOrganizationConformancePacksError { meta: generic, kind: crate::error::DescribeOrganizationConformancePacksErrorKind::OrganizationAccessDeniedException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::organization_access_denied_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_organization_access_denied_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeOrganizationConformancePacksError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::DescribeOrganizationConformancePacksError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_organization_conformance_packs_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeOrganizationConformancePacksOutput,
    crate::error::DescribeOrganizationConformancePacksError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::describe_organization_conformance_packs_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_describe_organization_conformance_packs(response.body().as_ref(), output).map_err(crate::error::DescribeOrganizationConformancePacksError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_organization_conformance_pack_statuses_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeOrganizationConformancePackStatusesOutput,
    crate::error::DescribeOrganizationConformancePackStatusesError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::DescribeOrganizationConformancePackStatusesError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(
                crate::error::DescribeOrganizationConformancePackStatusesError::unhandled(generic),
            )
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InvalidLimitException" => crate::error::DescribeOrganizationConformancePackStatusesError { meta: generic, kind: crate::error::DescribeOrganizationConformancePackStatusesErrorKind::InvalidLimitException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_limit_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_limit_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeOrganizationConformancePackStatusesError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidNextTokenException" => crate::error::DescribeOrganizationConformancePackStatusesError { meta: generic, kind: crate::error::DescribeOrganizationConformancePackStatusesErrorKind::InvalidNextTokenException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_next_token_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_next_token_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeOrganizationConformancePackStatusesError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "NoSuchOrganizationConformancePackException" => crate::error::DescribeOrganizationConformancePackStatusesError { meta: generic, kind: crate::error::DescribeOrganizationConformancePackStatusesErrorKind::NoSuchOrganizationConformancePackException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::no_such_organization_conformance_pack_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_no_such_organization_conformance_pack_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeOrganizationConformancePackStatusesError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "OrganizationAccessDeniedException" => crate::error::DescribeOrganizationConformancePackStatusesError { meta: generic, kind: crate::error::DescribeOrganizationConformancePackStatusesErrorKind::OrganizationAccessDeniedException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::organization_access_denied_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_organization_access_denied_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeOrganizationConformancePackStatusesError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::DescribeOrganizationConformancePackStatusesError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_organization_conformance_pack_statuses_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeOrganizationConformancePackStatusesOutput,
    crate::error::DescribeOrganizationConformancePackStatusesError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::describe_organization_conformance_pack_statuses_output::Builder::default(
            );
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_describe_organization_conformance_pack_statuses(response.body().as_ref(), output).map_err(crate::error::DescribeOrganizationConformancePackStatusesError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_pending_aggregation_requests_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribePendingAggregationRequestsOutput,
    crate::error::DescribePendingAggregationRequestsError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::DescribePendingAggregationRequestsError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DescribePendingAggregationRequestsError::unhandled(generic))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InvalidLimitException" => crate::error::DescribePendingAggregationRequestsError { meta: generic, kind: crate::error::DescribePendingAggregationRequestsErrorKind::InvalidLimitException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_limit_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_limit_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribePendingAggregationRequestsError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidNextTokenException" => crate::error::DescribePendingAggregationRequestsError { meta: generic, kind: crate::error::DescribePendingAggregationRequestsErrorKind::InvalidNextTokenException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_next_token_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_next_token_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribePendingAggregationRequestsError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidParameterValueException" => crate::error::DescribePendingAggregationRequestsError { meta: generic, kind: crate::error::DescribePendingAggregationRequestsErrorKind::InvalidParameterValueException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_parameter_value_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_parameter_value_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribePendingAggregationRequestsError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::DescribePendingAggregationRequestsError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_pending_aggregation_requests_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribePendingAggregationRequestsOutput,
    crate::error::DescribePendingAggregationRequestsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::describe_pending_aggregation_requests_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_describe_pending_aggregation_requests(response.body().as_ref(), output).map_err(crate::error::DescribePendingAggregationRequestsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_remediation_configurations_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeRemediationConfigurationsOutput,
    crate::error::DescribeRemediationConfigurationsError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::DescribeRemediationConfigurationsError::unhandled)?;
    Err(crate::error::DescribeRemediationConfigurationsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_remediation_configurations_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeRemediationConfigurationsOutput,
    crate::error::DescribeRemediationConfigurationsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::describe_remediation_configurations_output::Builder::default();
        let _ = response;
        output =
            crate::json_deser::deser_operation_crate_operation_describe_remediation_configurations(
                response.body().as_ref(),
                output,
            )
            .map_err(crate::error::DescribeRemediationConfigurationsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_remediation_exceptions_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeRemediationExceptionsOutput,
    crate::error::DescribeRemediationExceptionsError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::DescribeRemediationExceptionsError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DescribeRemediationExceptionsError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InvalidNextTokenException" => crate::error::DescribeRemediationExceptionsError {
            meta: generic,
            kind: crate::error::DescribeRemediationExceptionsErrorKind::InvalidNextTokenException(
                {
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::invalid_next_token_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_crate_error_invalid_next_token_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeRemediationExceptionsError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                },
            ),
        },
        "InvalidParameterValueException" => crate::error::DescribeRemediationExceptionsError {
            meta: generic,
            kind:
                crate::error::DescribeRemediationExceptionsErrorKind::InvalidParameterValueException(
                    {
                        #[allow(unused_mut)]
                        let mut tmp = {
                            #[allow(unused_mut)]
                            let mut output =
                                crate::error::invalid_parameter_value_exception::Builder::default();
                            let _ = response;
                            output = crate::json_deser::deser_structure_crate_error_invalid_parameter_value_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeRemediationExceptionsError::unhandled)?;
                            output.build()
                        };
                        if (&tmp.message).is_none() {
                            tmp.message = _error_message;
                        }
                        tmp
                    },
                ),
        },
        _ => crate::error::DescribeRemediationExceptionsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_remediation_exceptions_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeRemediationExceptionsOutput,
    crate::error::DescribeRemediationExceptionsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_remediation_exceptions_output::Builder::default();
        let _ = response;
        output =
            crate::json_deser::deser_operation_crate_operation_describe_remediation_exceptions(
                response.body().as_ref(),
                output,
            )
            .map_err(crate::error::DescribeRemediationExceptionsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_remediation_execution_status_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeRemediationExecutionStatusOutput,
    crate::error::DescribeRemediationExecutionStatusError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::DescribeRemediationExecutionStatusError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DescribeRemediationExecutionStatusError::unhandled(generic))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InvalidNextTokenException" => crate::error::DescribeRemediationExecutionStatusError { meta: generic, kind: crate::error::DescribeRemediationExecutionStatusErrorKind::InvalidNextTokenException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_next_token_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_next_token_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeRemediationExecutionStatusError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidParameterValueException" => crate::error::DescribeRemediationExecutionStatusError { meta: generic, kind: crate::error::DescribeRemediationExecutionStatusErrorKind::InvalidParameterValueException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_parameter_value_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_parameter_value_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeRemediationExecutionStatusError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "NoSuchRemediationConfigurationException" => crate::error::DescribeRemediationExecutionStatusError { meta: generic, kind: crate::error::DescribeRemediationExecutionStatusErrorKind::NoSuchRemediationConfigurationException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::no_such_remediation_configuration_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_no_such_remediation_configuration_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeRemediationExecutionStatusError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::DescribeRemediationExecutionStatusError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_remediation_execution_status_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeRemediationExecutionStatusOutput,
    crate::error::DescribeRemediationExecutionStatusError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::describe_remediation_execution_status_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_describe_remediation_execution_status(response.body().as_ref(), output).map_err(crate::error::DescribeRemediationExecutionStatusError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_retention_configurations_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeRetentionConfigurationsOutput,
    crate::error::DescribeRetentionConfigurationsError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::DescribeRetentionConfigurationsError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DescribeRetentionConfigurationsError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InvalidNextTokenException" => crate::error::DescribeRetentionConfigurationsError { meta: generic, kind: crate::error::DescribeRetentionConfigurationsErrorKind::InvalidNextTokenException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_next_token_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_next_token_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeRetentionConfigurationsError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidParameterValueException" => crate::error::DescribeRetentionConfigurationsError { meta: generic, kind: crate::error::DescribeRetentionConfigurationsErrorKind::InvalidParameterValueException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_parameter_value_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_parameter_value_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeRetentionConfigurationsError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "NoSuchRetentionConfigurationException" => crate::error::DescribeRetentionConfigurationsError { meta: generic, kind: crate::error::DescribeRetentionConfigurationsErrorKind::NoSuchRetentionConfigurationException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::no_such_retention_configuration_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_no_such_retention_configuration_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeRetentionConfigurationsError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::DescribeRetentionConfigurationsError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_retention_configurations_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeRetentionConfigurationsOutput,
    crate::error::DescribeRetentionConfigurationsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::describe_retention_configurations_output::Builder::default();
        let _ = response;
        output =
            crate::json_deser::deser_operation_crate_operation_describe_retention_configurations(
                response.body().as_ref(),
                output,
            )
            .map_err(crate::error::DescribeRetentionConfigurationsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_aggregate_compliance_details_by_config_rule_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetAggregateComplianceDetailsByConfigRuleOutput,
    crate::error::GetAggregateComplianceDetailsByConfigRuleError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::GetAggregateComplianceDetailsByConfigRuleError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(
                crate::error::GetAggregateComplianceDetailsByConfigRuleError::unhandled(generic),
            )
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InvalidLimitException" => crate::error::GetAggregateComplianceDetailsByConfigRuleError { meta: generic, kind: crate::error::GetAggregateComplianceDetailsByConfigRuleErrorKind::InvalidLimitException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_limit_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_limit_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetAggregateComplianceDetailsByConfigRuleError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidNextTokenException" => crate::error::GetAggregateComplianceDetailsByConfigRuleError { meta: generic, kind: crate::error::GetAggregateComplianceDetailsByConfigRuleErrorKind::InvalidNextTokenException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_next_token_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_next_token_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetAggregateComplianceDetailsByConfigRuleError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "NoSuchConfigurationAggregatorException" => crate::error::GetAggregateComplianceDetailsByConfigRuleError { meta: generic, kind: crate::error::GetAggregateComplianceDetailsByConfigRuleErrorKind::NoSuchConfigurationAggregatorException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::no_such_configuration_aggregator_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_no_such_configuration_aggregator_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetAggregateComplianceDetailsByConfigRuleError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ValidationException" => crate::error::GetAggregateComplianceDetailsByConfigRuleError { meta: generic, kind: crate::error::GetAggregateComplianceDetailsByConfigRuleErrorKind::ValidationException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::validation_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_validation_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetAggregateComplianceDetailsByConfigRuleError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::GetAggregateComplianceDetailsByConfigRuleError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_aggregate_compliance_details_by_config_rule_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetAggregateComplianceDetailsByConfigRuleOutput,
    crate::error::GetAggregateComplianceDetailsByConfigRuleError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::get_aggregate_compliance_details_by_config_rule_output::Builder::default(
            );
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_get_aggregate_compliance_details_by_config_rule(response.body().as_ref(), output).map_err(crate::error::GetAggregateComplianceDetailsByConfigRuleError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_aggregate_config_rule_compliance_summary_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetAggregateConfigRuleComplianceSummaryOutput,
    crate::error::GetAggregateConfigRuleComplianceSummaryError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::GetAggregateConfigRuleComplianceSummaryError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(
                crate::error::GetAggregateConfigRuleComplianceSummaryError::unhandled(generic),
            )
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InvalidLimitException" => crate::error::GetAggregateConfigRuleComplianceSummaryError { meta: generic, kind: crate::error::GetAggregateConfigRuleComplianceSummaryErrorKind::InvalidLimitException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_limit_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_limit_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetAggregateConfigRuleComplianceSummaryError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidNextTokenException" => crate::error::GetAggregateConfigRuleComplianceSummaryError { meta: generic, kind: crate::error::GetAggregateConfigRuleComplianceSummaryErrorKind::InvalidNextTokenException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_next_token_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_next_token_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetAggregateConfigRuleComplianceSummaryError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "NoSuchConfigurationAggregatorException" => crate::error::GetAggregateConfigRuleComplianceSummaryError { meta: generic, kind: crate::error::GetAggregateConfigRuleComplianceSummaryErrorKind::NoSuchConfigurationAggregatorException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::no_such_configuration_aggregator_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_no_such_configuration_aggregator_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetAggregateConfigRuleComplianceSummaryError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ValidationException" => crate::error::GetAggregateConfigRuleComplianceSummaryError { meta: generic, kind: crate::error::GetAggregateConfigRuleComplianceSummaryErrorKind::ValidationException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::validation_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_validation_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetAggregateConfigRuleComplianceSummaryError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::GetAggregateConfigRuleComplianceSummaryError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_aggregate_config_rule_compliance_summary_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetAggregateConfigRuleComplianceSummaryOutput,
    crate::error::GetAggregateConfigRuleComplianceSummaryError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::get_aggregate_config_rule_compliance_summary_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_get_aggregate_config_rule_compliance_summary(response.body().as_ref(), output).map_err(crate::error::GetAggregateConfigRuleComplianceSummaryError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_aggregate_conformance_pack_compliance_summary_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetAggregateConformancePackComplianceSummaryOutput,
    crate::error::GetAggregateConformancePackComplianceSummaryError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::GetAggregateConformancePackComplianceSummaryError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(
                crate::error::GetAggregateConformancePackComplianceSummaryError::unhandled(generic),
            )
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InvalidLimitException" => crate::error::GetAggregateConformancePackComplianceSummaryError { meta: generic, kind: crate::error::GetAggregateConformancePackComplianceSummaryErrorKind::InvalidLimitException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_limit_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_limit_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetAggregateConformancePackComplianceSummaryError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidNextTokenException" => crate::error::GetAggregateConformancePackComplianceSummaryError { meta: generic, kind: crate::error::GetAggregateConformancePackComplianceSummaryErrorKind::InvalidNextTokenException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_next_token_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_next_token_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetAggregateConformancePackComplianceSummaryError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "NoSuchConfigurationAggregatorException" => crate::error::GetAggregateConformancePackComplianceSummaryError { meta: generic, kind: crate::error::GetAggregateConformancePackComplianceSummaryErrorKind::NoSuchConfigurationAggregatorException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::no_such_configuration_aggregator_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_no_such_configuration_aggregator_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetAggregateConformancePackComplianceSummaryError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ValidationException" => crate::error::GetAggregateConformancePackComplianceSummaryError { meta: generic, kind: crate::error::GetAggregateConformancePackComplianceSummaryErrorKind::ValidationException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::validation_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_validation_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetAggregateConformancePackComplianceSummaryError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::GetAggregateConformancePackComplianceSummaryError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_aggregate_conformance_pack_compliance_summary_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetAggregateConformancePackComplianceSummaryOutput,
    crate::error::GetAggregateConformancePackComplianceSummaryError,
> {
    Ok({
        #[allow(unused_mut)]let mut output = crate::output::get_aggregate_conformance_pack_compliance_summary_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_get_aggregate_conformance_pack_compliance_summary(response.body().as_ref(), output).map_err(crate::error::GetAggregateConformancePackComplianceSummaryError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_aggregate_discovered_resource_counts_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetAggregateDiscoveredResourceCountsOutput,
    crate::error::GetAggregateDiscoveredResourceCountsError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::GetAggregateDiscoveredResourceCountsError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::GetAggregateDiscoveredResourceCountsError::unhandled(generic))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InvalidLimitException" => crate::error::GetAggregateDiscoveredResourceCountsError { meta: generic, kind: crate::error::GetAggregateDiscoveredResourceCountsErrorKind::InvalidLimitException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_limit_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_limit_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetAggregateDiscoveredResourceCountsError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidNextTokenException" => crate::error::GetAggregateDiscoveredResourceCountsError { meta: generic, kind: crate::error::GetAggregateDiscoveredResourceCountsErrorKind::InvalidNextTokenException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_next_token_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_next_token_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetAggregateDiscoveredResourceCountsError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "NoSuchConfigurationAggregatorException" => crate::error::GetAggregateDiscoveredResourceCountsError { meta: generic, kind: crate::error::GetAggregateDiscoveredResourceCountsErrorKind::NoSuchConfigurationAggregatorException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::no_such_configuration_aggregator_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_no_such_configuration_aggregator_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetAggregateDiscoveredResourceCountsError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ValidationException" => crate::error::GetAggregateDiscoveredResourceCountsError { meta: generic, kind: crate::error::GetAggregateDiscoveredResourceCountsErrorKind::ValidationException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::validation_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_validation_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetAggregateDiscoveredResourceCountsError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::GetAggregateDiscoveredResourceCountsError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_aggregate_discovered_resource_counts_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetAggregateDiscoveredResourceCountsOutput,
    crate::error::GetAggregateDiscoveredResourceCountsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::get_aggregate_discovered_resource_counts_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_get_aggregate_discovered_resource_counts(response.body().as_ref(), output).map_err(crate::error::GetAggregateDiscoveredResourceCountsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_aggregate_resource_config_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetAggregateResourceConfigOutput,
    crate::error::GetAggregateResourceConfigError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::GetAggregateResourceConfigError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::GetAggregateResourceConfigError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "NoSuchConfigurationAggregatorException" => crate::error::GetAggregateResourceConfigError { meta: generic, kind: crate::error::GetAggregateResourceConfigErrorKind::NoSuchConfigurationAggregatorException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::no_such_configuration_aggregator_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_no_such_configuration_aggregator_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetAggregateResourceConfigError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "OversizedConfigurationItemException" => crate::error::GetAggregateResourceConfigError { meta: generic, kind: crate::error::GetAggregateResourceConfigErrorKind::OversizedConfigurationItemException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::oversized_configuration_item_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_oversized_configuration_item_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetAggregateResourceConfigError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ResourceNotDiscoveredException" => crate::error::GetAggregateResourceConfigError { meta: generic, kind: crate::error::GetAggregateResourceConfigErrorKind::ResourceNotDiscoveredException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::resource_not_discovered_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_resource_not_discovered_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetAggregateResourceConfigError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ValidationException" => crate::error::GetAggregateResourceConfigError { meta: generic, kind: crate::error::GetAggregateResourceConfigErrorKind::ValidationException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::validation_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_validation_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetAggregateResourceConfigError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::GetAggregateResourceConfigError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_aggregate_resource_config_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetAggregateResourceConfigOutput,
    crate::error::GetAggregateResourceConfigError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_aggregate_resource_config_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_get_aggregate_resource_config(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::GetAggregateResourceConfigError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_compliance_details_by_config_rule_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetComplianceDetailsByConfigRuleOutput,
    crate::error::GetComplianceDetailsByConfigRuleError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::GetComplianceDetailsByConfigRuleError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::GetComplianceDetailsByConfigRuleError::unhandled(generic))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InvalidNextTokenException" => crate::error::GetComplianceDetailsByConfigRuleError { meta: generic, kind: crate::error::GetComplianceDetailsByConfigRuleErrorKind::InvalidNextTokenException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_next_token_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_next_token_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetComplianceDetailsByConfigRuleError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidParameterValueException" => crate::error::GetComplianceDetailsByConfigRuleError { meta: generic, kind: crate::error::GetComplianceDetailsByConfigRuleErrorKind::InvalidParameterValueException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_parameter_value_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_parameter_value_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetComplianceDetailsByConfigRuleError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "NoSuchConfigRuleException" => crate::error::GetComplianceDetailsByConfigRuleError { meta: generic, kind: crate::error::GetComplianceDetailsByConfigRuleErrorKind::NoSuchConfigRuleException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::no_such_config_rule_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_no_such_config_rule_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetComplianceDetailsByConfigRuleError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::GetComplianceDetailsByConfigRuleError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_compliance_details_by_config_rule_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetComplianceDetailsByConfigRuleOutput,
    crate::error::GetComplianceDetailsByConfigRuleError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::get_compliance_details_by_config_rule_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_get_compliance_details_by_config_rule(response.body().as_ref(), output).map_err(crate::error::GetComplianceDetailsByConfigRuleError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_compliance_details_by_resource_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetComplianceDetailsByResourceOutput,
    crate::error::GetComplianceDetailsByResourceError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::GetComplianceDetailsByResourceError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::GetComplianceDetailsByResourceError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InvalidParameterValueException" => crate::error::GetComplianceDetailsByResourceError { meta: generic, kind: crate::error::GetComplianceDetailsByResourceErrorKind::InvalidParameterValueException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_parameter_value_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_parameter_value_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetComplianceDetailsByResourceError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::GetComplianceDetailsByResourceError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_compliance_details_by_resource_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetComplianceDetailsByResourceOutput,
    crate::error::GetComplianceDetailsByResourceError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::get_compliance_details_by_resource_output::Builder::default();
        let _ = response;
        output =
            crate::json_deser::deser_operation_crate_operation_get_compliance_details_by_resource(
                response.body().as_ref(),
                output,
            )
            .map_err(crate::error::GetComplianceDetailsByResourceError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_compliance_summary_by_config_rule_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetComplianceSummaryByConfigRuleOutput,
    crate::error::GetComplianceSummaryByConfigRuleError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::GetComplianceSummaryByConfigRuleError::unhandled)?;
    Err(crate::error::GetComplianceSummaryByConfigRuleError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_compliance_summary_by_config_rule_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetComplianceSummaryByConfigRuleOutput,
    crate::error::GetComplianceSummaryByConfigRuleError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::get_compliance_summary_by_config_rule_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_get_compliance_summary_by_config_rule(response.body().as_ref(), output).map_err(crate::error::GetComplianceSummaryByConfigRuleError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_compliance_summary_by_resource_type_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetComplianceSummaryByResourceTypeOutput,
    crate::error::GetComplianceSummaryByResourceTypeError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::GetComplianceSummaryByResourceTypeError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::GetComplianceSummaryByResourceTypeError::unhandled(generic))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InvalidParameterValueException" => crate::error::GetComplianceSummaryByResourceTypeError { meta: generic, kind: crate::error::GetComplianceSummaryByResourceTypeErrorKind::InvalidParameterValueException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_parameter_value_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_parameter_value_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetComplianceSummaryByResourceTypeError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::GetComplianceSummaryByResourceTypeError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_compliance_summary_by_resource_type_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetComplianceSummaryByResourceTypeOutput,
    crate::error::GetComplianceSummaryByResourceTypeError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::get_compliance_summary_by_resource_type_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_get_compliance_summary_by_resource_type(response.body().as_ref(), output).map_err(crate::error::GetComplianceSummaryByResourceTypeError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_conformance_pack_compliance_details_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetConformancePackComplianceDetailsOutput,
    crate::error::GetConformancePackComplianceDetailsError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::GetConformancePackComplianceDetailsError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::GetConformancePackComplianceDetailsError::unhandled(generic))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InvalidLimitException" => crate::error::GetConformancePackComplianceDetailsError { meta: generic, kind: crate::error::GetConformancePackComplianceDetailsErrorKind::InvalidLimitException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_limit_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_limit_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetConformancePackComplianceDetailsError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidNextTokenException" => crate::error::GetConformancePackComplianceDetailsError { meta: generic, kind: crate::error::GetConformancePackComplianceDetailsErrorKind::InvalidNextTokenException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_next_token_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_next_token_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetConformancePackComplianceDetailsError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidParameterValueException" => crate::error::GetConformancePackComplianceDetailsError { meta: generic, kind: crate::error::GetConformancePackComplianceDetailsErrorKind::InvalidParameterValueException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_parameter_value_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_parameter_value_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetConformancePackComplianceDetailsError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "NoSuchConfigRuleInConformancePackException" => crate::error::GetConformancePackComplianceDetailsError { meta: generic, kind: crate::error::GetConformancePackComplianceDetailsErrorKind::NoSuchConfigRuleInConformancePackException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::no_such_config_rule_in_conformance_pack_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_no_such_config_rule_in_conformance_pack_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetConformancePackComplianceDetailsError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "NoSuchConformancePackException" => crate::error::GetConformancePackComplianceDetailsError { meta: generic, kind: crate::error::GetConformancePackComplianceDetailsErrorKind::NoSuchConformancePackException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::no_such_conformance_pack_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_no_such_conformance_pack_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetConformancePackComplianceDetailsError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::GetConformancePackComplianceDetailsError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_conformance_pack_compliance_details_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetConformancePackComplianceDetailsOutput,
    crate::error::GetConformancePackComplianceDetailsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::get_conformance_pack_compliance_details_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_get_conformance_pack_compliance_details(response.body().as_ref(), output).map_err(crate::error::GetConformancePackComplianceDetailsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_conformance_pack_compliance_summary_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetConformancePackComplianceSummaryOutput,
    crate::error::GetConformancePackComplianceSummaryError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::GetConformancePackComplianceSummaryError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::GetConformancePackComplianceSummaryError::unhandled(generic))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InvalidLimitException" => crate::error::GetConformancePackComplianceSummaryError { meta: generic, kind: crate::error::GetConformancePackComplianceSummaryErrorKind::InvalidLimitException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_limit_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_limit_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetConformancePackComplianceSummaryError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidNextTokenException" => crate::error::GetConformancePackComplianceSummaryError { meta: generic, kind: crate::error::GetConformancePackComplianceSummaryErrorKind::InvalidNextTokenException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_next_token_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_next_token_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetConformancePackComplianceSummaryError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "NoSuchConformancePackException" => crate::error::GetConformancePackComplianceSummaryError { meta: generic, kind: crate::error::GetConformancePackComplianceSummaryErrorKind::NoSuchConformancePackException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::no_such_conformance_pack_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_no_such_conformance_pack_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetConformancePackComplianceSummaryError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::GetConformancePackComplianceSummaryError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_conformance_pack_compliance_summary_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetConformancePackComplianceSummaryOutput,
    crate::error::GetConformancePackComplianceSummaryError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::get_conformance_pack_compliance_summary_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_get_conformance_pack_compliance_summary(response.body().as_ref(), output).map_err(crate::error::GetConformancePackComplianceSummaryError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_discovered_resource_counts_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetDiscoveredResourceCountsOutput,
    crate::error::GetDiscoveredResourceCountsError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::GetDiscoveredResourceCountsError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::GetDiscoveredResourceCountsError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InvalidLimitException" => crate::error::GetDiscoveredResourceCountsError {
            meta: generic,
            kind: crate::error::GetDiscoveredResourceCountsErrorKind::InvalidLimitException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_limit_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_limit_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetDiscoveredResourceCountsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidNextTokenException" => crate::error::GetDiscoveredResourceCountsError {
            meta: generic,
            kind: crate::error::GetDiscoveredResourceCountsErrorKind::InvalidNextTokenException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_next_token_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_next_token_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetDiscoveredResourceCountsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ValidationException" => crate::error::GetDiscoveredResourceCountsError {
            meta: generic,
            kind: crate::error::GetDiscoveredResourceCountsErrorKind::ValidationException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::validation_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_validation_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetDiscoveredResourceCountsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::GetDiscoveredResourceCountsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_discovered_resource_counts_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetDiscoveredResourceCountsOutput,
    crate::error::GetDiscoveredResourceCountsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_discovered_resource_counts_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_get_discovered_resource_counts(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::GetDiscoveredResourceCountsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_organization_config_rule_detailed_status_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetOrganizationConfigRuleDetailedStatusOutput,
    crate::error::GetOrganizationConfigRuleDetailedStatusError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::GetOrganizationConfigRuleDetailedStatusError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(
                crate::error::GetOrganizationConfigRuleDetailedStatusError::unhandled(generic),
            )
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InvalidLimitException" => crate::error::GetOrganizationConfigRuleDetailedStatusError { meta: generic, kind: crate::error::GetOrganizationConfigRuleDetailedStatusErrorKind::InvalidLimitException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_limit_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_limit_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetOrganizationConfigRuleDetailedStatusError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidNextTokenException" => crate::error::GetOrganizationConfigRuleDetailedStatusError { meta: generic, kind: crate::error::GetOrganizationConfigRuleDetailedStatusErrorKind::InvalidNextTokenException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_next_token_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_next_token_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetOrganizationConfigRuleDetailedStatusError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "NoSuchOrganizationConfigRuleException" => crate::error::GetOrganizationConfigRuleDetailedStatusError { meta: generic, kind: crate::error::GetOrganizationConfigRuleDetailedStatusErrorKind::NoSuchOrganizationConfigRuleException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::no_such_organization_config_rule_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_no_such_organization_config_rule_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetOrganizationConfigRuleDetailedStatusError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "OrganizationAccessDeniedException" => crate::error::GetOrganizationConfigRuleDetailedStatusError { meta: generic, kind: crate::error::GetOrganizationConfigRuleDetailedStatusErrorKind::OrganizationAccessDeniedException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::organization_access_denied_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_organization_access_denied_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetOrganizationConfigRuleDetailedStatusError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::GetOrganizationConfigRuleDetailedStatusError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_organization_config_rule_detailed_status_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetOrganizationConfigRuleDetailedStatusOutput,
    crate::error::GetOrganizationConfigRuleDetailedStatusError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::get_organization_config_rule_detailed_status_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_get_organization_config_rule_detailed_status(response.body().as_ref(), output).map_err(crate::error::GetOrganizationConfigRuleDetailedStatusError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_organization_conformance_pack_detailed_status_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetOrganizationConformancePackDetailedStatusOutput,
    crate::error::GetOrganizationConformancePackDetailedStatusError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::GetOrganizationConformancePackDetailedStatusError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(
                crate::error::GetOrganizationConformancePackDetailedStatusError::unhandled(generic),
            )
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InvalidLimitException" => crate::error::GetOrganizationConformancePackDetailedStatusError { meta: generic, kind: crate::error::GetOrganizationConformancePackDetailedStatusErrorKind::InvalidLimitException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_limit_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_limit_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetOrganizationConformancePackDetailedStatusError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidNextTokenException" => crate::error::GetOrganizationConformancePackDetailedStatusError { meta: generic, kind: crate::error::GetOrganizationConformancePackDetailedStatusErrorKind::InvalidNextTokenException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_next_token_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_next_token_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetOrganizationConformancePackDetailedStatusError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "NoSuchOrganizationConformancePackException" => crate::error::GetOrganizationConformancePackDetailedStatusError { meta: generic, kind: crate::error::GetOrganizationConformancePackDetailedStatusErrorKind::NoSuchOrganizationConformancePackException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::no_such_organization_conformance_pack_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_no_such_organization_conformance_pack_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetOrganizationConformancePackDetailedStatusError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "OrganizationAccessDeniedException" => crate::error::GetOrganizationConformancePackDetailedStatusError { meta: generic, kind: crate::error::GetOrganizationConformancePackDetailedStatusErrorKind::OrganizationAccessDeniedException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::organization_access_denied_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_organization_access_denied_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetOrganizationConformancePackDetailedStatusError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::GetOrganizationConformancePackDetailedStatusError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_organization_conformance_pack_detailed_status_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetOrganizationConformancePackDetailedStatusOutput,
    crate::error::GetOrganizationConformancePackDetailedStatusError,
> {
    Ok({
        #[allow(unused_mut)]let mut output = crate::output::get_organization_conformance_pack_detailed_status_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_get_organization_conformance_pack_detailed_status(response.body().as_ref(), output).map_err(crate::error::GetOrganizationConformancePackDetailedStatusError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_resource_config_history_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetResourceConfigHistoryOutput,
    crate::error::GetResourceConfigHistoryError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::GetResourceConfigHistoryError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::GetResourceConfigHistoryError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InvalidLimitException" => crate::error::GetResourceConfigHistoryError { meta: generic, kind: crate::error::GetResourceConfigHistoryErrorKind::InvalidLimitException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_limit_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_limit_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetResourceConfigHistoryError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidNextTokenException" => crate::error::GetResourceConfigHistoryError { meta: generic, kind: crate::error::GetResourceConfigHistoryErrorKind::InvalidNextTokenException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_next_token_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_next_token_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetResourceConfigHistoryError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidTimeRangeException" => crate::error::GetResourceConfigHistoryError { meta: generic, kind: crate::error::GetResourceConfigHistoryErrorKind::InvalidTimeRangeException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_time_range_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_time_range_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetResourceConfigHistoryError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "NoAvailableConfigurationRecorderException" => crate::error::GetResourceConfigHistoryError { meta: generic, kind: crate::error::GetResourceConfigHistoryErrorKind::NoAvailableConfigurationRecorderException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::no_available_configuration_recorder_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_no_available_configuration_recorder_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetResourceConfigHistoryError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ResourceNotDiscoveredException" => crate::error::GetResourceConfigHistoryError { meta: generic, kind: crate::error::GetResourceConfigHistoryErrorKind::ResourceNotDiscoveredException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::resource_not_discovered_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_resource_not_discovered_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetResourceConfigHistoryError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ValidationException" => crate::error::GetResourceConfigHistoryError { meta: generic, kind: crate::error::GetResourceConfigHistoryErrorKind::ValidationException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::validation_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_validation_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetResourceConfigHistoryError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::GetResourceConfigHistoryError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_resource_config_history_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetResourceConfigHistoryOutput,
    crate::error::GetResourceConfigHistoryError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_resource_config_history_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_get_resource_config_history(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::GetResourceConfigHistoryError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_stored_query_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetStoredQueryOutput, crate::error::GetStoredQueryError> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::GetStoredQueryError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::GetStoredQueryError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ResourceNotFoundException" => crate::error::GetStoredQueryError {
            meta: generic,
            kind: crate::error::GetStoredQueryErrorKind::ResourceNotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::resource_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_resource_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetStoredQueryError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ValidationException" => crate::error::GetStoredQueryError {
            meta: generic,
            kind: crate::error::GetStoredQueryErrorKind::ValidationException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::validation_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_validation_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetStoredQueryError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::GetStoredQueryError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_stored_query_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetStoredQueryOutput, crate::error::GetStoredQueryError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_stored_query_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_get_stored_query(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::GetStoredQueryError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_aggregate_discovered_resources_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListAggregateDiscoveredResourcesOutput,
    crate::error::ListAggregateDiscoveredResourcesError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::ListAggregateDiscoveredResourcesError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::ListAggregateDiscoveredResourcesError::unhandled(generic))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InvalidLimitException" => crate::error::ListAggregateDiscoveredResourcesError { meta: generic, kind: crate::error::ListAggregateDiscoveredResourcesErrorKind::InvalidLimitException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_limit_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_limit_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListAggregateDiscoveredResourcesError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidNextTokenException" => crate::error::ListAggregateDiscoveredResourcesError { meta: generic, kind: crate::error::ListAggregateDiscoveredResourcesErrorKind::InvalidNextTokenException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_next_token_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_next_token_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListAggregateDiscoveredResourcesError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "NoSuchConfigurationAggregatorException" => crate::error::ListAggregateDiscoveredResourcesError { meta: generic, kind: crate::error::ListAggregateDiscoveredResourcesErrorKind::NoSuchConfigurationAggregatorException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::no_such_configuration_aggregator_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_no_such_configuration_aggregator_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListAggregateDiscoveredResourcesError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ValidationException" => crate::error::ListAggregateDiscoveredResourcesError { meta: generic, kind: crate::error::ListAggregateDiscoveredResourcesErrorKind::ValidationException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::validation_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_validation_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListAggregateDiscoveredResourcesError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::ListAggregateDiscoveredResourcesError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_aggregate_discovered_resources_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListAggregateDiscoveredResourcesOutput,
    crate::error::ListAggregateDiscoveredResourcesError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::list_aggregate_discovered_resources_output::Builder::default();
        let _ = response;
        output =
            crate::json_deser::deser_operation_crate_operation_list_aggregate_discovered_resources(
                response.body().as_ref(),
                output,
            )
            .map_err(crate::error::ListAggregateDiscoveredResourcesError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_discovered_resources_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListDiscoveredResourcesOutput,
    crate::error::ListDiscoveredResourcesError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::ListDiscoveredResourcesError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::ListDiscoveredResourcesError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InvalidLimitException" => crate::error::ListDiscoveredResourcesError { meta: generic, kind: crate::error::ListDiscoveredResourcesErrorKind::InvalidLimitException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_limit_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_limit_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListDiscoveredResourcesError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidNextTokenException" => crate::error::ListDiscoveredResourcesError { meta: generic, kind: crate::error::ListDiscoveredResourcesErrorKind::InvalidNextTokenException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_next_token_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_next_token_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListDiscoveredResourcesError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "NoAvailableConfigurationRecorderException" => crate::error::ListDiscoveredResourcesError { meta: generic, kind: crate::error::ListDiscoveredResourcesErrorKind::NoAvailableConfigurationRecorderException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::no_available_configuration_recorder_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_no_available_configuration_recorder_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListDiscoveredResourcesError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ValidationException" => crate::error::ListDiscoveredResourcesError { meta: generic, kind: crate::error::ListDiscoveredResourcesErrorKind::ValidationException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::validation_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_validation_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListDiscoveredResourcesError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::ListDiscoveredResourcesError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_discovered_resources_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListDiscoveredResourcesOutput,
    crate::error::ListDiscoveredResourcesError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_discovered_resources_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_list_discovered_resources(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListDiscoveredResourcesError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_stored_queries_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListStoredQueriesOutput, crate::error::ListStoredQueriesError>
{
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::ListStoredQueriesError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ListStoredQueriesError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InvalidNextTokenException" => crate::error::ListStoredQueriesError {
            meta: generic,
            kind: crate::error::ListStoredQueriesErrorKind::InvalidNextTokenException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_next_token_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_next_token_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListStoredQueriesError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ValidationException" => crate::error::ListStoredQueriesError {
            meta: generic,
            kind: crate::error::ListStoredQueriesErrorKind::ValidationException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::validation_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_validation_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListStoredQueriesError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::ListStoredQueriesError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_stored_queries_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListStoredQueriesOutput, crate::error::ListStoredQueriesError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_stored_queries_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_list_stored_queries(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListStoredQueriesError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_tags_for_resource_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListTagsForResourceOutput,
    crate::error::ListTagsForResourceError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::ListTagsForResourceError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ListTagsForResourceError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InvalidLimitException" => crate::error::ListTagsForResourceError {
            meta: generic,
            kind: crate::error::ListTagsForResourceErrorKind::InvalidLimitException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_limit_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_limit_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListTagsForResourceError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidNextTokenException" => crate::error::ListTagsForResourceError {
            meta: generic,
            kind: crate::error::ListTagsForResourceErrorKind::InvalidNextTokenException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_next_token_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_next_token_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListTagsForResourceError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ResourceNotFoundException" => crate::error::ListTagsForResourceError {
            meta: generic,
            kind: crate::error::ListTagsForResourceErrorKind::ResourceNotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::resource_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_resource_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListTagsForResourceError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ValidationException" => crate::error::ListTagsForResourceError {
            meta: generic,
            kind: crate::error::ListTagsForResourceErrorKind::ValidationException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::validation_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_validation_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListTagsForResourceError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::ListTagsForResourceError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_tags_for_resource_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListTagsForResourceOutput,
    crate::error::ListTagsForResourceError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_tags_for_resource_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_list_tags_for_resource(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListTagsForResourceError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_put_aggregation_authorization_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::PutAggregationAuthorizationOutput,
    crate::error::PutAggregationAuthorizationError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::PutAggregationAuthorizationError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::PutAggregationAuthorizationError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InvalidParameterValueException" => crate::error::PutAggregationAuthorizationError {
            meta: generic,
            kind:
                crate::error::PutAggregationAuthorizationErrorKind::InvalidParameterValueException(
                    {
                        #[allow(unused_mut)]
                        let mut tmp = {
                            #[allow(unused_mut)]
                            let mut output =
                                crate::error::invalid_parameter_value_exception::Builder::default();
                            let _ = response;
                            output = crate::json_deser::deser_structure_crate_error_invalid_parameter_value_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutAggregationAuthorizationError::unhandled)?;
                            output.build()
                        };
                        if (&tmp.message).is_none() {
                            tmp.message = _error_message;
                        }
                        tmp
                    },
                ),
        },
        _ => crate::error::PutAggregationAuthorizationError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_put_aggregation_authorization_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::PutAggregationAuthorizationOutput,
    crate::error::PutAggregationAuthorizationError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::put_aggregation_authorization_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_put_aggregation_authorization(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::PutAggregationAuthorizationError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_put_config_rule_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::PutConfigRuleOutput, crate::error::PutConfigRuleError> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::PutConfigRuleError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::PutConfigRuleError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InsufficientPermissionsException" => crate::error::PutConfigRuleError {
            meta: generic,
            kind: crate::error::PutConfigRuleErrorKind::InsufficientPermissionsException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::insufficient_permissions_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_insufficient_permissions_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutConfigRuleError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidParameterValueException" => crate::error::PutConfigRuleError {
            meta: generic,
            kind: crate::error::PutConfigRuleErrorKind::InvalidParameterValueException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_parameter_value_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_parameter_value_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutConfigRuleError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "MaxNumberOfConfigRulesExceededException" => crate::error::PutConfigRuleError {
            meta: generic,
            kind: crate::error::PutConfigRuleErrorKind::MaxNumberOfConfigRulesExceededException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]let mut output = crate::error::max_number_of_config_rules_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_max_number_of_config_rules_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutConfigRuleError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "NoAvailableConfigurationRecorderException" => crate::error::PutConfigRuleError {
            meta: generic,
            kind: crate::error::PutConfigRuleErrorKind::NoAvailableConfigurationRecorderException(
                {
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]let mut output = crate::error::no_available_configuration_recorder_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_crate_error_no_available_configuration_recorder_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutConfigRuleError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                },
            ),
        },
        "ResourceInUseException" => crate::error::PutConfigRuleError {
            meta: generic,
            kind: crate::error::PutConfigRuleErrorKind::ResourceInUseException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::resource_in_use_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_resource_in_use_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutConfigRuleError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::PutConfigRuleError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_put_config_rule_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::PutConfigRuleOutput, crate::error::PutConfigRuleError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::put_config_rule_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_put_configuration_aggregator_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::PutConfigurationAggregatorOutput,
    crate::error::PutConfigurationAggregatorError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::PutConfigurationAggregatorError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::PutConfigurationAggregatorError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InvalidParameterValueException" => crate::error::PutConfigurationAggregatorError { meta: generic, kind: crate::error::PutConfigurationAggregatorErrorKind::InvalidParameterValueException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_parameter_value_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_parameter_value_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutConfigurationAggregatorError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRoleException" => crate::error::PutConfigurationAggregatorError { meta: generic, kind: crate::error::PutConfigurationAggregatorErrorKind::InvalidRoleException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_role_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_role_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutConfigurationAggregatorError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "LimitExceededException" => crate::error::PutConfigurationAggregatorError { meta: generic, kind: crate::error::PutConfigurationAggregatorErrorKind::LimitExceededException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_limit_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutConfigurationAggregatorError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "NoAvailableOrganizationException" => crate::error::PutConfigurationAggregatorError { meta: generic, kind: crate::error::PutConfigurationAggregatorErrorKind::NoAvailableOrganizationException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::no_available_organization_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_no_available_organization_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutConfigurationAggregatorError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "OrganizationAccessDeniedException" => crate::error::PutConfigurationAggregatorError { meta: generic, kind: crate::error::PutConfigurationAggregatorErrorKind::OrganizationAccessDeniedException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::organization_access_denied_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_organization_access_denied_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutConfigurationAggregatorError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "OrganizationAllFeaturesNotEnabledException" => crate::error::PutConfigurationAggregatorError { meta: generic, kind: crate::error::PutConfigurationAggregatorErrorKind::OrganizationAllFeaturesNotEnabledException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::organization_all_features_not_enabled_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_organization_all_features_not_enabled_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutConfigurationAggregatorError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::PutConfigurationAggregatorError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_put_configuration_aggregator_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::PutConfigurationAggregatorOutput,
    crate::error::PutConfigurationAggregatorError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::put_configuration_aggregator_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_put_configuration_aggregator(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::PutConfigurationAggregatorError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_put_configuration_recorder_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::PutConfigurationRecorderOutput,
    crate::error::PutConfigurationRecorderError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::PutConfigurationRecorderError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::PutConfigurationRecorderError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InvalidConfigurationRecorderNameException" => crate::error::PutConfigurationRecorderError { meta: generic, kind: crate::error::PutConfigurationRecorderErrorKind::InvalidConfigurationRecorderNameException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_configuration_recorder_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_configuration_recorder_name_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutConfigurationRecorderError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRecordingGroupException" => crate::error::PutConfigurationRecorderError { meta: generic, kind: crate::error::PutConfigurationRecorderErrorKind::InvalidRecordingGroupException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_recording_group_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_recording_group_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutConfigurationRecorderError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRoleException" => crate::error::PutConfigurationRecorderError { meta: generic, kind: crate::error::PutConfigurationRecorderErrorKind::InvalidRoleException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_role_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_role_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutConfigurationRecorderError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "MaxNumberOfConfigurationRecordersExceededException" => crate::error::PutConfigurationRecorderError { meta: generic, kind: crate::error::PutConfigurationRecorderErrorKind::MaxNumberOfConfigurationRecordersExceededException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::max_number_of_configuration_recorders_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_max_number_of_configuration_recorders_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutConfigurationRecorderError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::PutConfigurationRecorderError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_put_configuration_recorder_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::PutConfigurationRecorderOutput,
    crate::error::PutConfigurationRecorderError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::put_configuration_recorder_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_put_conformance_pack_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::PutConformancePackOutput,
    crate::error::PutConformancePackError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::PutConformancePackError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::PutConformancePackError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ConformancePackTemplateValidationException" => crate::error::PutConformancePackError { meta: generic, kind: crate::error::PutConformancePackErrorKind::ConformancePackTemplateValidationException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::conformance_pack_template_validation_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_conformance_pack_template_validation_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutConformancePackError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InsufficientPermissionsException" => crate::error::PutConformancePackError { meta: generic, kind: crate::error::PutConformancePackErrorKind::InsufficientPermissionsException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::insufficient_permissions_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_insufficient_permissions_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutConformancePackError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidParameterValueException" => crate::error::PutConformancePackError { meta: generic, kind: crate::error::PutConformancePackErrorKind::InvalidParameterValueException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_parameter_value_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_parameter_value_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutConformancePackError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "MaxNumberOfConformancePacksExceededException" => crate::error::PutConformancePackError { meta: generic, kind: crate::error::PutConformancePackErrorKind::MaxNumberOfConformancePacksExceededException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::max_number_of_conformance_packs_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_max_number_of_conformance_packs_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutConformancePackError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ResourceInUseException" => crate::error::PutConformancePackError { meta: generic, kind: crate::error::PutConformancePackErrorKind::ResourceInUseException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::resource_in_use_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_resource_in_use_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutConformancePackError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::PutConformancePackError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_put_conformance_pack_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::PutConformancePackOutput,
    crate::error::PutConformancePackError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::put_conformance_pack_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_put_conformance_pack(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::PutConformancePackError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_put_delivery_channel_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::PutDeliveryChannelOutput,
    crate::error::PutDeliveryChannelError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::PutDeliveryChannelError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::PutDeliveryChannelError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InsufficientDeliveryPolicyException" => crate::error::PutDeliveryChannelError { meta: generic, kind: crate::error::PutDeliveryChannelErrorKind::InsufficientDeliveryPolicyException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::insufficient_delivery_policy_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_insufficient_delivery_policy_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutDeliveryChannelError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidDeliveryChannelNameException" => crate::error::PutDeliveryChannelError { meta: generic, kind: crate::error::PutDeliveryChannelErrorKind::InvalidDeliveryChannelNameException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_delivery_channel_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_delivery_channel_name_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutDeliveryChannelError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidS3KeyPrefixException" => crate::error::PutDeliveryChannelError { meta: generic, kind: crate::error::PutDeliveryChannelErrorKind::InvalidS3KeyPrefixException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_s3_key_prefix_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_s3_key_prefix_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutDeliveryChannelError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidS3KmsKeyArnException" => crate::error::PutDeliveryChannelError { meta: generic, kind: crate::error::PutDeliveryChannelErrorKind::InvalidS3KmsKeyArnException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_s3_kms_key_arn_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_s3_kms_key_arn_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutDeliveryChannelError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidSNSTopicARNException" => crate::error::PutDeliveryChannelError { meta: generic, kind: crate::error::PutDeliveryChannelErrorKind::InvalidSnsTopicArnException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_sns_topic_arn_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_sns_topic_arn_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutDeliveryChannelError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "MaxNumberOfDeliveryChannelsExceededException" => crate::error::PutDeliveryChannelError { meta: generic, kind: crate::error::PutDeliveryChannelErrorKind::MaxNumberOfDeliveryChannelsExceededException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::max_number_of_delivery_channels_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_max_number_of_delivery_channels_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutDeliveryChannelError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "NoAvailableConfigurationRecorderException" => crate::error::PutDeliveryChannelError { meta: generic, kind: crate::error::PutDeliveryChannelErrorKind::NoAvailableConfigurationRecorderException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::no_available_configuration_recorder_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_no_available_configuration_recorder_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutDeliveryChannelError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "NoSuchBucketException" => crate::error::PutDeliveryChannelError { meta: generic, kind: crate::error::PutDeliveryChannelErrorKind::NoSuchBucketException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::no_such_bucket_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_no_such_bucket_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutDeliveryChannelError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::PutDeliveryChannelError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_put_delivery_channel_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::PutDeliveryChannelOutput,
    crate::error::PutDeliveryChannelError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::put_delivery_channel_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_put_evaluations_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::PutEvaluationsOutput, crate::error::PutEvaluationsError> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::PutEvaluationsError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::PutEvaluationsError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InvalidParameterValueException" => crate::error::PutEvaluationsError {
            meta: generic,
            kind: crate::error::PutEvaluationsErrorKind::InvalidParameterValueException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_parameter_value_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_parameter_value_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutEvaluationsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidResultTokenException" => crate::error::PutEvaluationsError {
            meta: generic,
            kind: crate::error::PutEvaluationsErrorKind::InvalidResultTokenException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_result_token_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_result_token_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutEvaluationsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "NoSuchConfigRuleException" => crate::error::PutEvaluationsError {
            meta: generic,
            kind: crate::error::PutEvaluationsErrorKind::NoSuchConfigRuleException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::no_such_config_rule_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_no_such_config_rule_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutEvaluationsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::PutEvaluationsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_put_evaluations_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::PutEvaluationsOutput, crate::error::PutEvaluationsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::put_evaluations_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_put_evaluations(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::PutEvaluationsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_put_external_evaluation_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::PutExternalEvaluationOutput,
    crate::error::PutExternalEvaluationError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::PutExternalEvaluationError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::PutExternalEvaluationError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InvalidParameterValueException" => crate::error::PutExternalEvaluationError {
            meta: generic,
            kind: crate::error::PutExternalEvaluationErrorKind::InvalidParameterValueException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_parameter_value_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_parameter_value_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutExternalEvaluationError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "NoSuchConfigRuleException" => crate::error::PutExternalEvaluationError {
            meta: generic,
            kind: crate::error::PutExternalEvaluationErrorKind::NoSuchConfigRuleException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::no_such_config_rule_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_no_such_config_rule_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutExternalEvaluationError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::PutExternalEvaluationError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_put_external_evaluation_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::PutExternalEvaluationOutput,
    crate::error::PutExternalEvaluationError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::put_external_evaluation_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_put_organization_config_rule_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::PutOrganizationConfigRuleOutput,
    crate::error::PutOrganizationConfigRuleError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::PutOrganizationConfigRuleError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::PutOrganizationConfigRuleError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InsufficientPermissionsException" => crate::error::PutOrganizationConfigRuleError { meta: generic, kind: crate::error::PutOrganizationConfigRuleErrorKind::InsufficientPermissionsException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::insufficient_permissions_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_insufficient_permissions_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutOrganizationConfigRuleError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidParameterValueException" => crate::error::PutOrganizationConfigRuleError { meta: generic, kind: crate::error::PutOrganizationConfigRuleErrorKind::InvalidParameterValueException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_parameter_value_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_parameter_value_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutOrganizationConfigRuleError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "MaxNumberOfOrganizationConfigRulesExceededException" => crate::error::PutOrganizationConfigRuleError { meta: generic, kind: crate::error::PutOrganizationConfigRuleErrorKind::MaxNumberOfOrganizationConfigRulesExceededException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::max_number_of_organization_config_rules_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_max_number_of_organization_config_rules_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutOrganizationConfigRuleError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "NoAvailableOrganizationException" => crate::error::PutOrganizationConfigRuleError { meta: generic, kind: crate::error::PutOrganizationConfigRuleErrorKind::NoAvailableOrganizationException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::no_available_organization_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_no_available_organization_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutOrganizationConfigRuleError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "OrganizationAccessDeniedException" => crate::error::PutOrganizationConfigRuleError { meta: generic, kind: crate::error::PutOrganizationConfigRuleErrorKind::OrganizationAccessDeniedException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::organization_access_denied_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_organization_access_denied_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutOrganizationConfigRuleError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "OrganizationAllFeaturesNotEnabledException" => crate::error::PutOrganizationConfigRuleError { meta: generic, kind: crate::error::PutOrganizationConfigRuleErrorKind::OrganizationAllFeaturesNotEnabledException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::organization_all_features_not_enabled_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_organization_all_features_not_enabled_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutOrganizationConfigRuleError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ResourceInUseException" => crate::error::PutOrganizationConfigRuleError { meta: generic, kind: crate::error::PutOrganizationConfigRuleErrorKind::ResourceInUseException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::resource_in_use_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_resource_in_use_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutOrganizationConfigRuleError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ValidationException" => crate::error::PutOrganizationConfigRuleError { meta: generic, kind: crate::error::PutOrganizationConfigRuleErrorKind::ValidationException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::validation_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_validation_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutOrganizationConfigRuleError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::PutOrganizationConfigRuleError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_put_organization_config_rule_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::PutOrganizationConfigRuleOutput,
    crate::error::PutOrganizationConfigRuleError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::put_organization_config_rule_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_put_organization_config_rule(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::PutOrganizationConfigRuleError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_put_organization_conformance_pack_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::PutOrganizationConformancePackOutput,
    crate::error::PutOrganizationConformancePackError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::PutOrganizationConformancePackError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::PutOrganizationConformancePackError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InsufficientPermissionsException" => crate::error::PutOrganizationConformancePackError { meta: generic, kind: crate::error::PutOrganizationConformancePackErrorKind::InsufficientPermissionsException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::insufficient_permissions_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_insufficient_permissions_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutOrganizationConformancePackError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "MaxNumberOfOrganizationConformancePacksExceededException" => crate::error::PutOrganizationConformancePackError { meta: generic, kind: crate::error::PutOrganizationConformancePackErrorKind::MaxNumberOfOrganizationConformancePacksExceededException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::max_number_of_organization_conformance_packs_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_max_number_of_organization_conformance_packs_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutOrganizationConformancePackError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "NoAvailableOrganizationException" => crate::error::PutOrganizationConformancePackError { meta: generic, kind: crate::error::PutOrganizationConformancePackErrorKind::NoAvailableOrganizationException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::no_available_organization_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_no_available_organization_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutOrganizationConformancePackError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "OrganizationAccessDeniedException" => crate::error::PutOrganizationConformancePackError { meta: generic, kind: crate::error::PutOrganizationConformancePackErrorKind::OrganizationAccessDeniedException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::organization_access_denied_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_organization_access_denied_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutOrganizationConformancePackError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "OrganizationAllFeaturesNotEnabledException" => crate::error::PutOrganizationConformancePackError { meta: generic, kind: crate::error::PutOrganizationConformancePackErrorKind::OrganizationAllFeaturesNotEnabledException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::organization_all_features_not_enabled_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_organization_all_features_not_enabled_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutOrganizationConformancePackError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "OrganizationConformancePackTemplateValidationException" => crate::error::PutOrganizationConformancePackError { meta: generic, kind: crate::error::PutOrganizationConformancePackErrorKind::OrganizationConformancePackTemplateValidationException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::organization_conformance_pack_template_validation_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_organization_conformance_pack_template_validation_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutOrganizationConformancePackError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ResourceInUseException" => crate::error::PutOrganizationConformancePackError { meta: generic, kind: crate::error::PutOrganizationConformancePackErrorKind::ResourceInUseException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::resource_in_use_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_resource_in_use_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutOrganizationConformancePackError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ValidationException" => crate::error::PutOrganizationConformancePackError { meta: generic, kind: crate::error::PutOrganizationConformancePackErrorKind::ValidationException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::validation_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_validation_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutOrganizationConformancePackError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::PutOrganizationConformancePackError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_put_organization_conformance_pack_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::PutOrganizationConformancePackOutput,
    crate::error::PutOrganizationConformancePackError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::put_organization_conformance_pack_output::Builder::default();
        let _ = response;
        output =
            crate::json_deser::deser_operation_crate_operation_put_organization_conformance_pack(
                response.body().as_ref(),
                output,
            )
            .map_err(crate::error::PutOrganizationConformancePackError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_put_remediation_configurations_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::PutRemediationConfigurationsOutput,
    crate::error::PutRemediationConfigurationsError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::PutRemediationConfigurationsError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::PutRemediationConfigurationsError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InsufficientPermissionsException" => crate::error::PutRemediationConfigurationsError { meta: generic, kind: crate::error::PutRemediationConfigurationsErrorKind::InsufficientPermissionsException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::insufficient_permissions_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_insufficient_permissions_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutRemediationConfigurationsError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidParameterValueException" => crate::error::PutRemediationConfigurationsError { meta: generic, kind: crate::error::PutRemediationConfigurationsErrorKind::InvalidParameterValueException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_parameter_value_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_parameter_value_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutRemediationConfigurationsError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::PutRemediationConfigurationsError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_put_remediation_configurations_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::PutRemediationConfigurationsOutput,
    crate::error::PutRemediationConfigurationsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::put_remediation_configurations_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_put_remediation_configurations(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::PutRemediationConfigurationsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_put_remediation_exceptions_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::PutRemediationExceptionsOutput,
    crate::error::PutRemediationExceptionsError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::PutRemediationExceptionsError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::PutRemediationExceptionsError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InsufficientPermissionsException" => crate::error::PutRemediationExceptionsError {
            meta: generic,
            kind: crate::error::PutRemediationExceptionsErrorKind::InsufficientPermissionsException(
                {
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::insufficient_permissions_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_crate_error_insufficient_permissions_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutRemediationExceptionsError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                },
            ),
        },
        "InvalidParameterValueException" => crate::error::PutRemediationExceptionsError {
            meta: generic,
            kind: crate::error::PutRemediationExceptionsErrorKind::InvalidParameterValueException(
                {
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::invalid_parameter_value_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_crate_error_invalid_parameter_value_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutRemediationExceptionsError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                },
            ),
        },
        _ => crate::error::PutRemediationExceptionsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_put_remediation_exceptions_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::PutRemediationExceptionsOutput,
    crate::error::PutRemediationExceptionsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::put_remediation_exceptions_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_put_remediation_exceptions(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::PutRemediationExceptionsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_put_resource_config_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::PutResourceConfigOutput, crate::error::PutResourceConfigError>
{
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::PutResourceConfigError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::PutResourceConfigError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InsufficientPermissionsException" => crate::error::PutResourceConfigError {
            meta: generic,
            kind: crate::error::PutResourceConfigErrorKind::InsufficientPermissionsException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::insufficient_permissions_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_insufficient_permissions_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutResourceConfigError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "MaxActiveResourcesExceededException" => crate::error::PutResourceConfigError {
            meta: generic,
            kind: crate::error::PutResourceConfigErrorKind::MaxActiveResourcesExceededException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::max_active_resources_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_max_active_resources_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutResourceConfigError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "NoRunningConfigurationRecorderException" => crate::error::PutResourceConfigError {
            meta: generic,
            kind: crate::error::PutResourceConfigErrorKind::NoRunningConfigurationRecorderException(
                {
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]let mut output = crate::error::no_running_configuration_recorder_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_crate_error_no_running_configuration_recorder_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutResourceConfigError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                },
            ),
        },
        "ValidationException" => crate::error::PutResourceConfigError {
            meta: generic,
            kind: crate::error::PutResourceConfigErrorKind::ValidationException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::validation_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_validation_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutResourceConfigError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::PutResourceConfigError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_put_resource_config_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::PutResourceConfigOutput, crate::error::PutResourceConfigError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::put_resource_config_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_put_retention_configuration_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::PutRetentionConfigurationOutput,
    crate::error::PutRetentionConfigurationError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::PutRetentionConfigurationError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::PutRetentionConfigurationError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InvalidParameterValueException" => crate::error::PutRetentionConfigurationError { meta: generic, kind: crate::error::PutRetentionConfigurationErrorKind::InvalidParameterValueException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_parameter_value_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_parameter_value_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutRetentionConfigurationError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "MaxNumberOfRetentionConfigurationsExceededException" => crate::error::PutRetentionConfigurationError { meta: generic, kind: crate::error::PutRetentionConfigurationErrorKind::MaxNumberOfRetentionConfigurationsExceededException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::max_number_of_retention_configurations_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_max_number_of_retention_configurations_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutRetentionConfigurationError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::PutRetentionConfigurationError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_put_retention_configuration_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::PutRetentionConfigurationOutput,
    crate::error::PutRetentionConfigurationError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::put_retention_configuration_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_put_retention_configuration(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::PutRetentionConfigurationError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_put_stored_query_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::PutStoredQueryOutput, crate::error::PutStoredQueryError> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::PutStoredQueryError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::PutStoredQueryError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ResourceConcurrentModificationException" => crate::error::PutStoredQueryError {
            meta: generic,
            kind: crate::error::PutStoredQueryErrorKind::ResourceConcurrentModificationException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::resource_concurrent_modification_exception::Builder::default(
                        );
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_resource_concurrent_modification_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutStoredQueryError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "TooManyTagsException" => crate::error::PutStoredQueryError {
            meta: generic,
            kind: crate::error::PutStoredQueryErrorKind::TooManyTagsException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::too_many_tags_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_too_many_tags_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutStoredQueryError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ValidationException" => crate::error::PutStoredQueryError {
            meta: generic,
            kind: crate::error::PutStoredQueryErrorKind::ValidationException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::validation_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_validation_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutStoredQueryError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::PutStoredQueryError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_put_stored_query_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::PutStoredQueryOutput, crate::error::PutStoredQueryError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::put_stored_query_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_put_stored_query(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::PutStoredQueryError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_select_aggregate_resource_config_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::SelectAggregateResourceConfigOutput,
    crate::error::SelectAggregateResourceConfigError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::SelectAggregateResourceConfigError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::SelectAggregateResourceConfigError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InvalidExpressionException" => crate::error::SelectAggregateResourceConfigError { meta: generic, kind: crate::error::SelectAggregateResourceConfigErrorKind::InvalidExpressionException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_expression_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_expression_exception_json_err(response.body().as_ref(), output).map_err(crate::error::SelectAggregateResourceConfigError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidLimitException" => crate::error::SelectAggregateResourceConfigError { meta: generic, kind: crate::error::SelectAggregateResourceConfigErrorKind::InvalidLimitException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_limit_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_limit_exception_json_err(response.body().as_ref(), output).map_err(crate::error::SelectAggregateResourceConfigError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidNextTokenException" => crate::error::SelectAggregateResourceConfigError { meta: generic, kind: crate::error::SelectAggregateResourceConfigErrorKind::InvalidNextTokenException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_next_token_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_next_token_exception_json_err(response.body().as_ref(), output).map_err(crate::error::SelectAggregateResourceConfigError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "NoSuchConfigurationAggregatorException" => crate::error::SelectAggregateResourceConfigError { meta: generic, kind: crate::error::SelectAggregateResourceConfigErrorKind::NoSuchConfigurationAggregatorException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::no_such_configuration_aggregator_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_no_such_configuration_aggregator_exception_json_err(response.body().as_ref(), output).map_err(crate::error::SelectAggregateResourceConfigError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::SelectAggregateResourceConfigError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_select_aggregate_resource_config_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::SelectAggregateResourceConfigOutput,
    crate::error::SelectAggregateResourceConfigError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::select_aggregate_resource_config_output::Builder::default();
        let _ = response;
        output =
            crate::json_deser::deser_operation_crate_operation_select_aggregate_resource_config(
                response.body().as_ref(),
                output,
            )
            .map_err(crate::error::SelectAggregateResourceConfigError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_select_resource_config_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::SelectResourceConfigOutput,
    crate::error::SelectResourceConfigError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::SelectResourceConfigError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::SelectResourceConfigError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InvalidExpressionException" => crate::error::SelectResourceConfigError {
            meta: generic,
            kind: crate::error::SelectResourceConfigErrorKind::InvalidExpressionException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_expression_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_expression_exception_json_err(response.body().as_ref(), output).map_err(crate::error::SelectResourceConfigError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidLimitException" => crate::error::SelectResourceConfigError {
            meta: generic,
            kind: crate::error::SelectResourceConfigErrorKind::InvalidLimitException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_limit_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_limit_exception_json_err(response.body().as_ref(), output).map_err(crate::error::SelectResourceConfigError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidNextTokenException" => crate::error::SelectResourceConfigError {
            meta: generic,
            kind: crate::error::SelectResourceConfigErrorKind::InvalidNextTokenException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_next_token_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_next_token_exception_json_err(response.body().as_ref(), output).map_err(crate::error::SelectResourceConfigError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::SelectResourceConfigError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_select_resource_config_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::SelectResourceConfigOutput,
    crate::error::SelectResourceConfigError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::select_resource_config_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_select_resource_config(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::SelectResourceConfigError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_start_config_rules_evaluation_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::StartConfigRulesEvaluationOutput,
    crate::error::StartConfigRulesEvaluationError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::StartConfigRulesEvaluationError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::StartConfigRulesEvaluationError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InvalidParameterValueException" => crate::error::StartConfigRulesEvaluationError {
            meta: generic,
            kind: crate::error::StartConfigRulesEvaluationErrorKind::InvalidParameterValueException(
                {
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::invalid_parameter_value_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_crate_error_invalid_parameter_value_exception_json_err(response.body().as_ref(), output).map_err(crate::error::StartConfigRulesEvaluationError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                },
            ),
        },
        "LimitExceededException" => crate::error::StartConfigRulesEvaluationError {
            meta: generic,
            kind: crate::error::StartConfigRulesEvaluationErrorKind::LimitExceededException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_limit_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::StartConfigRulesEvaluationError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "NoSuchConfigRuleException" => crate::error::StartConfigRulesEvaluationError {
            meta: generic,
            kind: crate::error::StartConfigRulesEvaluationErrorKind::NoSuchConfigRuleException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::no_such_config_rule_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_no_such_config_rule_exception_json_err(response.body().as_ref(), output).map_err(crate::error::StartConfigRulesEvaluationError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ResourceInUseException" => crate::error::StartConfigRulesEvaluationError {
            meta: generic,
            kind: crate::error::StartConfigRulesEvaluationErrorKind::ResourceInUseException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::resource_in_use_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_resource_in_use_exception_json_err(response.body().as_ref(), output).map_err(crate::error::StartConfigRulesEvaluationError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::StartConfigRulesEvaluationError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_start_config_rules_evaluation_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::StartConfigRulesEvaluationOutput,
    crate::error::StartConfigRulesEvaluationError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::start_config_rules_evaluation_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_start_configuration_recorder_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::StartConfigurationRecorderOutput,
    crate::error::StartConfigurationRecorderError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::StartConfigurationRecorderError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::StartConfigurationRecorderError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "NoAvailableDeliveryChannelException" => crate::error::StartConfigurationRecorderError { meta: generic, kind: crate::error::StartConfigurationRecorderErrorKind::NoAvailableDeliveryChannelException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::no_available_delivery_channel_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_no_available_delivery_channel_exception_json_err(response.body().as_ref(), output).map_err(crate::error::StartConfigurationRecorderError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "NoSuchConfigurationRecorderException" => crate::error::StartConfigurationRecorderError { meta: generic, kind: crate::error::StartConfigurationRecorderErrorKind::NoSuchConfigurationRecorderException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::no_such_configuration_recorder_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_no_such_configuration_recorder_exception_json_err(response.body().as_ref(), output).map_err(crate::error::StartConfigurationRecorderError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::StartConfigurationRecorderError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_start_configuration_recorder_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::StartConfigurationRecorderOutput,
    crate::error::StartConfigurationRecorderError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::start_configuration_recorder_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_start_remediation_execution_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::StartRemediationExecutionOutput,
    crate::error::StartRemediationExecutionError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::StartRemediationExecutionError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::StartRemediationExecutionError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InsufficientPermissionsException" => crate::error::StartRemediationExecutionError { meta: generic, kind: crate::error::StartRemediationExecutionErrorKind::InsufficientPermissionsException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::insufficient_permissions_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_insufficient_permissions_exception_json_err(response.body().as_ref(), output).map_err(crate::error::StartRemediationExecutionError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidParameterValueException" => crate::error::StartRemediationExecutionError { meta: generic, kind: crate::error::StartRemediationExecutionErrorKind::InvalidParameterValueException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_parameter_value_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_parameter_value_exception_json_err(response.body().as_ref(), output).map_err(crate::error::StartRemediationExecutionError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "NoSuchRemediationConfigurationException" => crate::error::StartRemediationExecutionError { meta: generic, kind: crate::error::StartRemediationExecutionErrorKind::NoSuchRemediationConfigurationException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::no_such_remediation_configuration_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_no_such_remediation_configuration_exception_json_err(response.body().as_ref(), output).map_err(crate::error::StartRemediationExecutionError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::StartRemediationExecutionError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_start_remediation_execution_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::StartRemediationExecutionOutput,
    crate::error::StartRemediationExecutionError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::start_remediation_execution_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_start_remediation_execution(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::StartRemediationExecutionError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_stop_configuration_recorder_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::StopConfigurationRecorderOutput,
    crate::error::StopConfigurationRecorderError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::StopConfigurationRecorderError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::StopConfigurationRecorderError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "NoSuchConfigurationRecorderException" => crate::error::StopConfigurationRecorderError { meta: generic, kind: crate::error::StopConfigurationRecorderErrorKind::NoSuchConfigurationRecorderException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::no_such_configuration_recorder_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_no_such_configuration_recorder_exception_json_err(response.body().as_ref(), output).map_err(crate::error::StopConfigurationRecorderError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::StopConfigurationRecorderError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_stop_configuration_recorder_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::StopConfigurationRecorderOutput,
    crate::error::StopConfigurationRecorderError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::stop_configuration_recorder_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_tag_resource_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::TagResourceOutput, crate::error::TagResourceError> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::TagResourceError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::TagResourceError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ResourceNotFoundException" => crate::error::TagResourceError {
            meta: generic,
            kind: crate::error::TagResourceErrorKind::ResourceNotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::resource_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_resource_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::TagResourceError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "TooManyTagsException" => crate::error::TagResourceError {
            meta: generic,
            kind: crate::error::TagResourceErrorKind::TooManyTagsException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::too_many_tags_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_too_many_tags_exception_json_err(response.body().as_ref(), output).map_err(crate::error::TagResourceError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ValidationException" => crate::error::TagResourceError {
            meta: generic,
            kind: crate::error::TagResourceErrorKind::ValidationException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::validation_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_validation_exception_json_err(response.body().as_ref(), output).map_err(crate::error::TagResourceError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::TagResourceError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_tag_resource_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::TagResourceOutput, crate::error::TagResourceError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::tag_resource_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_untag_resource_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::UntagResourceOutput, crate::error::UntagResourceError> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::UntagResourceError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::UntagResourceError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ResourceNotFoundException" => crate::error::UntagResourceError {
            meta: generic,
            kind: crate::error::UntagResourceErrorKind::ResourceNotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::resource_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_resource_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UntagResourceError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ValidationException" => crate::error::UntagResourceError {
            meta: generic,
            kind: crate::error::UntagResourceErrorKind::ValidationException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::validation_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_validation_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UntagResourceError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::UntagResourceError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_untag_resource_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::UntagResourceOutput, crate::error::UntagResourceError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::untag_resource_output::Builder::default();
        let _ = response;
        output.build()
    })
}
