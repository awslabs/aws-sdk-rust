// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
/// Error type for the `AddDraftAppVersionResourceMappings` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct AddDraftAppVersionResourceMappingsError {
    /// Kind of error that occurred.
    pub kind: AddDraftAppVersionResourceMappingsErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `AddDraftAppVersionResourceMappings` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum AddDraftAppVersionResourceMappingsErrorKind {
    /// <p>You don't have permissions to perform the requested operation. The user or role that is
    /// making the request must have at least one IAM permissions policy attached that grants the
    /// required permissions.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>Occurs when a conflict with a previous successful write is detected. This generally occurs
    /// when the previous write did not have time to propagate to the host serving the current
    /// request. A retry (with appropriate backoff logic) is the recommended response to this
    /// exception.</p>
    ConflictException(crate::error::ConflictException),
    /// <p>This exception occurs when there is an internal failure in the AWS Resilience Hub
    /// service.</p>
    InternalServerException(crate::error::InternalServerException),
    /// <p>The specified resource could not be found.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>The limit on the number of requests per second was exceeded.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>Indicates that a request was not valid.</p>
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for AddDraftAppVersionResourceMappingsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            AddDraftAppVersionResourceMappingsErrorKind::AccessDeniedException(_inner) => {
                _inner.fmt(f)
            }
            AddDraftAppVersionResourceMappingsErrorKind::ConflictException(_inner) => _inner.fmt(f),
            AddDraftAppVersionResourceMappingsErrorKind::InternalServerException(_inner) => {
                _inner.fmt(f)
            }
            AddDraftAppVersionResourceMappingsErrorKind::ResourceNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            AddDraftAppVersionResourceMappingsErrorKind::ThrottlingException(_inner) => {
                _inner.fmt(f)
            }
            AddDraftAppVersionResourceMappingsErrorKind::ValidationException(_inner) => {
                _inner.fmt(f)
            }
            AddDraftAppVersionResourceMappingsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for AddDraftAppVersionResourceMappingsError {
    fn code(&self) -> Option<&str> {
        AddDraftAppVersionResourceMappingsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl AddDraftAppVersionResourceMappingsError {
    /// Creates a new `AddDraftAppVersionResourceMappingsError`.
    pub fn new(
        kind: AddDraftAppVersionResourceMappingsErrorKind,
        meta: aws_smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    /// Creates the `AddDraftAppVersionResourceMappingsError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: AddDraftAppVersionResourceMappingsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `AddDraftAppVersionResourceMappingsError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: AddDraftAppVersionResourceMappingsErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `AddDraftAppVersionResourceMappingsErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            AddDraftAppVersionResourceMappingsErrorKind::AccessDeniedException(_)
        )
    }
    /// Returns `true` if the error kind is `AddDraftAppVersionResourceMappingsErrorKind::ConflictException`.
    pub fn is_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            AddDraftAppVersionResourceMappingsErrorKind::ConflictException(_)
        )
    }
    /// Returns `true` if the error kind is `AddDraftAppVersionResourceMappingsErrorKind::InternalServerException`.
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            AddDraftAppVersionResourceMappingsErrorKind::InternalServerException(_)
        )
    }
    /// Returns `true` if the error kind is `AddDraftAppVersionResourceMappingsErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            AddDraftAppVersionResourceMappingsErrorKind::ResourceNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `AddDraftAppVersionResourceMappingsErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            AddDraftAppVersionResourceMappingsErrorKind::ThrottlingException(_)
        )
    }
    /// Returns `true` if the error kind is `AddDraftAppVersionResourceMappingsErrorKind::ValidationException`.
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            AddDraftAppVersionResourceMappingsErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for AddDraftAppVersionResourceMappingsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            AddDraftAppVersionResourceMappingsErrorKind::AccessDeniedException(_inner) => {
                Some(_inner)
            }
            AddDraftAppVersionResourceMappingsErrorKind::ConflictException(_inner) => Some(_inner),
            AddDraftAppVersionResourceMappingsErrorKind::InternalServerException(_inner) => {
                Some(_inner)
            }
            AddDraftAppVersionResourceMappingsErrorKind::ResourceNotFoundException(_inner) => {
                Some(_inner)
            }
            AddDraftAppVersionResourceMappingsErrorKind::ThrottlingException(_inner) => {
                Some(_inner)
            }
            AddDraftAppVersionResourceMappingsErrorKind::ValidationException(_inner) => {
                Some(_inner)
            }
            AddDraftAppVersionResourceMappingsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `CreateApp` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateAppError {
    /// Kind of error that occurred.
    pub kind: CreateAppErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `CreateApp` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateAppErrorKind {
    /// <p>You don't have permissions to perform the requested operation. The user or role that is
    /// making the request must have at least one IAM permissions policy attached that grants the
    /// required permissions.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>Occurs when a conflict with a previous successful write is detected. This generally occurs
    /// when the previous write did not have time to propagate to the host serving the current
    /// request. A retry (with appropriate backoff logic) is the recommended response to this
    /// exception.</p>
    ConflictException(crate::error::ConflictException),
    /// <p>This exception occurs when there is an internal failure in the AWS Resilience Hub
    /// service.</p>
    InternalServerException(crate::error::InternalServerException),
    /// <p>The specified resource could not be found.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>You have exceeded your service quota. To perform the requested action, remove some of the
    /// relevant resources, or use Service Quotas to request a service quota increase.</p>
    ServiceQuotaExceededException(crate::error::ServiceQuotaExceededException),
    /// <p>The limit on the number of requests per second was exceeded.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>Indicates that a request was not valid.</p>
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateAppError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateAppErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            CreateAppErrorKind::ConflictException(_inner) => _inner.fmt(f),
            CreateAppErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            CreateAppErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            CreateAppErrorKind::ServiceQuotaExceededException(_inner) => _inner.fmt(f),
            CreateAppErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            CreateAppErrorKind::ValidationException(_inner) => _inner.fmt(f),
            CreateAppErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for CreateAppError {
    fn code(&self) -> Option<&str> {
        CreateAppError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateAppError {
    /// Creates a new `CreateAppError`.
    pub fn new(kind: CreateAppErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `CreateAppError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateAppErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `CreateAppError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateAppErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `CreateAppErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, CreateAppErrorKind::AccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `CreateAppErrorKind::ConflictException`.
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, CreateAppErrorKind::ConflictException(_))
    }
    /// Returns `true` if the error kind is `CreateAppErrorKind::InternalServerException`.
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(&self.kind, CreateAppErrorKind::InternalServerException(_))
    }
    /// Returns `true` if the error kind is `CreateAppErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(&self.kind, CreateAppErrorKind::ResourceNotFoundException(_))
    }
    /// Returns `true` if the error kind is `CreateAppErrorKind::ServiceQuotaExceededException`.
    pub fn is_service_quota_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateAppErrorKind::ServiceQuotaExceededException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateAppErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, CreateAppErrorKind::ThrottlingException(_))
    }
    /// Returns `true` if the error kind is `CreateAppErrorKind::ValidationException`.
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self.kind, CreateAppErrorKind::ValidationException(_))
    }
}
impl std::error::Error for CreateAppError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateAppErrorKind::AccessDeniedException(_inner) => Some(_inner),
            CreateAppErrorKind::ConflictException(_inner) => Some(_inner),
            CreateAppErrorKind::InternalServerException(_inner) => Some(_inner),
            CreateAppErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            CreateAppErrorKind::ServiceQuotaExceededException(_inner) => Some(_inner),
            CreateAppErrorKind::ThrottlingException(_inner) => Some(_inner),
            CreateAppErrorKind::ValidationException(_inner) => Some(_inner),
            CreateAppErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `CreateRecommendationTemplate` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateRecommendationTemplateError {
    /// Kind of error that occurred.
    pub kind: CreateRecommendationTemplateErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `CreateRecommendationTemplate` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateRecommendationTemplateErrorKind {
    /// <p>You don't have permissions to perform the requested operation. The user or role that is
    /// making the request must have at least one IAM permissions policy attached that grants the
    /// required permissions.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>Occurs when a conflict with a previous successful write is detected. This generally occurs
    /// when the previous write did not have time to propagate to the host serving the current
    /// request. A retry (with appropriate backoff logic) is the recommended response to this
    /// exception.</p>
    ConflictException(crate::error::ConflictException),
    /// <p>This exception occurs when there is an internal failure in the AWS Resilience Hub
    /// service.</p>
    InternalServerException(crate::error::InternalServerException),
    /// <p>The specified resource could not be found.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>The limit on the number of requests per second was exceeded.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>Indicates that a request was not valid.</p>
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateRecommendationTemplateError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateRecommendationTemplateErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            CreateRecommendationTemplateErrorKind::ConflictException(_inner) => _inner.fmt(f),
            CreateRecommendationTemplateErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            CreateRecommendationTemplateErrorKind::ResourceNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            CreateRecommendationTemplateErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            CreateRecommendationTemplateErrorKind::ValidationException(_inner) => _inner.fmt(f),
            CreateRecommendationTemplateErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for CreateRecommendationTemplateError {
    fn code(&self) -> Option<&str> {
        CreateRecommendationTemplateError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateRecommendationTemplateError {
    /// Creates a new `CreateRecommendationTemplateError`.
    pub fn new(kind: CreateRecommendationTemplateErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `CreateRecommendationTemplateError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateRecommendationTemplateErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `CreateRecommendationTemplateError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateRecommendationTemplateErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `CreateRecommendationTemplateErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateRecommendationTemplateErrorKind::AccessDeniedException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateRecommendationTemplateErrorKind::ConflictException`.
    pub fn is_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateRecommendationTemplateErrorKind::ConflictException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateRecommendationTemplateErrorKind::InternalServerException`.
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateRecommendationTemplateErrorKind::InternalServerException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateRecommendationTemplateErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateRecommendationTemplateErrorKind::ResourceNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateRecommendationTemplateErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateRecommendationTemplateErrorKind::ThrottlingException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateRecommendationTemplateErrorKind::ValidationException`.
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateRecommendationTemplateErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for CreateRecommendationTemplateError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateRecommendationTemplateErrorKind::AccessDeniedException(_inner) => Some(_inner),
            CreateRecommendationTemplateErrorKind::ConflictException(_inner) => Some(_inner),
            CreateRecommendationTemplateErrorKind::InternalServerException(_inner) => Some(_inner),
            CreateRecommendationTemplateErrorKind::ResourceNotFoundException(_inner) => {
                Some(_inner)
            }
            CreateRecommendationTemplateErrorKind::ThrottlingException(_inner) => Some(_inner),
            CreateRecommendationTemplateErrorKind::ValidationException(_inner) => Some(_inner),
            CreateRecommendationTemplateErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `CreateResiliencyPolicy` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateResiliencyPolicyError {
    /// Kind of error that occurred.
    pub kind: CreateResiliencyPolicyErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `CreateResiliencyPolicy` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateResiliencyPolicyErrorKind {
    /// <p>You don't have permissions to perform the requested operation. The user or role that is
    /// making the request must have at least one IAM permissions policy attached that grants the
    /// required permissions.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>Occurs when a conflict with a previous successful write is detected. This generally occurs
    /// when the previous write did not have time to propagate to the host serving the current
    /// request. A retry (with appropriate backoff logic) is the recommended response to this
    /// exception.</p>
    ConflictException(crate::error::ConflictException),
    /// <p>This exception occurs when there is an internal failure in the AWS Resilience Hub
    /// service.</p>
    InternalServerException(crate::error::InternalServerException),
    /// <p>You have exceeded your service quota. To perform the requested action, remove some of the
    /// relevant resources, or use Service Quotas to request a service quota increase.</p>
    ServiceQuotaExceededException(crate::error::ServiceQuotaExceededException),
    /// <p>The limit on the number of requests per second was exceeded.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>Indicates that a request was not valid.</p>
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateResiliencyPolicyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateResiliencyPolicyErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            CreateResiliencyPolicyErrorKind::ConflictException(_inner) => _inner.fmt(f),
            CreateResiliencyPolicyErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            CreateResiliencyPolicyErrorKind::ServiceQuotaExceededException(_inner) => _inner.fmt(f),
            CreateResiliencyPolicyErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            CreateResiliencyPolicyErrorKind::ValidationException(_inner) => _inner.fmt(f),
            CreateResiliencyPolicyErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for CreateResiliencyPolicyError {
    fn code(&self) -> Option<&str> {
        CreateResiliencyPolicyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateResiliencyPolicyError {
    /// Creates a new `CreateResiliencyPolicyError`.
    pub fn new(kind: CreateResiliencyPolicyErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `CreateResiliencyPolicyError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateResiliencyPolicyErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `CreateResiliencyPolicyError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateResiliencyPolicyErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `CreateResiliencyPolicyErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateResiliencyPolicyErrorKind::AccessDeniedException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateResiliencyPolicyErrorKind::ConflictException`.
    pub fn is_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateResiliencyPolicyErrorKind::ConflictException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateResiliencyPolicyErrorKind::InternalServerException`.
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateResiliencyPolicyErrorKind::InternalServerException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateResiliencyPolicyErrorKind::ServiceQuotaExceededException`.
    pub fn is_service_quota_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateResiliencyPolicyErrorKind::ServiceQuotaExceededException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateResiliencyPolicyErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateResiliencyPolicyErrorKind::ThrottlingException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateResiliencyPolicyErrorKind::ValidationException`.
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateResiliencyPolicyErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for CreateResiliencyPolicyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateResiliencyPolicyErrorKind::AccessDeniedException(_inner) => Some(_inner),
            CreateResiliencyPolicyErrorKind::ConflictException(_inner) => Some(_inner),
            CreateResiliencyPolicyErrorKind::InternalServerException(_inner) => Some(_inner),
            CreateResiliencyPolicyErrorKind::ServiceQuotaExceededException(_inner) => Some(_inner),
            CreateResiliencyPolicyErrorKind::ThrottlingException(_inner) => Some(_inner),
            CreateResiliencyPolicyErrorKind::ValidationException(_inner) => Some(_inner),
            CreateResiliencyPolicyErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `DeleteApp` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteAppError {
    /// Kind of error that occurred.
    pub kind: DeleteAppErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `DeleteApp` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteAppErrorKind {
    /// <p>Occurs when a conflict with a previous successful write is detected. This generally occurs
    /// when the previous write did not have time to propagate to the host serving the current
    /// request. A retry (with appropriate backoff logic) is the recommended response to this
    /// exception.</p>
    ConflictException(crate::error::ConflictException),
    /// <p>This exception occurs when there is an internal failure in the AWS Resilience Hub
    /// service.</p>
    InternalServerException(crate::error::InternalServerException),
    /// <p>The specified resource could not be found.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>The limit on the number of requests per second was exceeded.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>Indicates that a request was not valid.</p>
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteAppError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteAppErrorKind::ConflictException(_inner) => _inner.fmt(f),
            DeleteAppErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            DeleteAppErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DeleteAppErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DeleteAppErrorKind::ValidationException(_inner) => _inner.fmt(f),
            DeleteAppErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DeleteAppError {
    fn code(&self) -> Option<&str> {
        DeleteAppError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteAppError {
    /// Creates a new `DeleteAppError`.
    pub fn new(kind: DeleteAppErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `DeleteAppError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteAppErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `DeleteAppError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteAppErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `DeleteAppErrorKind::ConflictException`.
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, DeleteAppErrorKind::ConflictException(_))
    }
    /// Returns `true` if the error kind is `DeleteAppErrorKind::InternalServerException`.
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(&self.kind, DeleteAppErrorKind::InternalServerException(_))
    }
    /// Returns `true` if the error kind is `DeleteAppErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(&self.kind, DeleteAppErrorKind::ResourceNotFoundException(_))
    }
    /// Returns `true` if the error kind is `DeleteAppErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, DeleteAppErrorKind::ThrottlingException(_))
    }
    /// Returns `true` if the error kind is `DeleteAppErrorKind::ValidationException`.
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self.kind, DeleteAppErrorKind::ValidationException(_))
    }
}
impl std::error::Error for DeleteAppError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteAppErrorKind::ConflictException(_inner) => Some(_inner),
            DeleteAppErrorKind::InternalServerException(_inner) => Some(_inner),
            DeleteAppErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DeleteAppErrorKind::ThrottlingException(_inner) => Some(_inner),
            DeleteAppErrorKind::ValidationException(_inner) => Some(_inner),
            DeleteAppErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `DeleteAppAssessment` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteAppAssessmentError {
    /// Kind of error that occurred.
    pub kind: DeleteAppAssessmentErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `DeleteAppAssessment` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteAppAssessmentErrorKind {
    /// <p>You don't have permissions to perform the requested operation. The user or role that is
    /// making the request must have at least one IAM permissions policy attached that grants the
    /// required permissions.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>Occurs when a conflict with a previous successful write is detected. This generally occurs
    /// when the previous write did not have time to propagate to the host serving the current
    /// request. A retry (with appropriate backoff logic) is the recommended response to this
    /// exception.</p>
    ConflictException(crate::error::ConflictException),
    /// <p>This exception occurs when there is an internal failure in the AWS Resilience Hub
    /// service.</p>
    InternalServerException(crate::error::InternalServerException),
    /// <p>The specified resource could not be found.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>The limit on the number of requests per second was exceeded.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>Indicates that a request was not valid.</p>
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteAppAssessmentError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteAppAssessmentErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            DeleteAppAssessmentErrorKind::ConflictException(_inner) => _inner.fmt(f),
            DeleteAppAssessmentErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            DeleteAppAssessmentErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DeleteAppAssessmentErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DeleteAppAssessmentErrorKind::ValidationException(_inner) => _inner.fmt(f),
            DeleteAppAssessmentErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DeleteAppAssessmentError {
    fn code(&self) -> Option<&str> {
        DeleteAppAssessmentError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteAppAssessmentError {
    /// Creates a new `DeleteAppAssessmentError`.
    pub fn new(kind: DeleteAppAssessmentErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `DeleteAppAssessmentError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteAppAssessmentErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `DeleteAppAssessmentError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteAppAssessmentErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `DeleteAppAssessmentErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteAppAssessmentErrorKind::AccessDeniedException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteAppAssessmentErrorKind::ConflictException`.
    pub fn is_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteAppAssessmentErrorKind::ConflictException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteAppAssessmentErrorKind::InternalServerException`.
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteAppAssessmentErrorKind::InternalServerException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteAppAssessmentErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteAppAssessmentErrorKind::ResourceNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteAppAssessmentErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteAppAssessmentErrorKind::ThrottlingException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteAppAssessmentErrorKind::ValidationException`.
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteAppAssessmentErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for DeleteAppAssessmentError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteAppAssessmentErrorKind::AccessDeniedException(_inner) => Some(_inner),
            DeleteAppAssessmentErrorKind::ConflictException(_inner) => Some(_inner),
            DeleteAppAssessmentErrorKind::InternalServerException(_inner) => Some(_inner),
            DeleteAppAssessmentErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DeleteAppAssessmentErrorKind::ThrottlingException(_inner) => Some(_inner),
            DeleteAppAssessmentErrorKind::ValidationException(_inner) => Some(_inner),
            DeleteAppAssessmentErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `DeleteRecommendationTemplate` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteRecommendationTemplateError {
    /// Kind of error that occurred.
    pub kind: DeleteRecommendationTemplateErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `DeleteRecommendationTemplate` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteRecommendationTemplateErrorKind {
    /// <p>You don't have permissions to perform the requested operation. The user or role that is
    /// making the request must have at least one IAM permissions policy attached that grants the
    /// required permissions.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>This exception occurs when there is an internal failure in the AWS Resilience Hub
    /// service.</p>
    InternalServerException(crate::error::InternalServerException),
    /// <p>The specified resource could not be found.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>The limit on the number of requests per second was exceeded.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>Indicates that a request was not valid.</p>
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteRecommendationTemplateError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteRecommendationTemplateErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            DeleteRecommendationTemplateErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            DeleteRecommendationTemplateErrorKind::ResourceNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            DeleteRecommendationTemplateErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DeleteRecommendationTemplateErrorKind::ValidationException(_inner) => _inner.fmt(f),
            DeleteRecommendationTemplateErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DeleteRecommendationTemplateError {
    fn code(&self) -> Option<&str> {
        DeleteRecommendationTemplateError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteRecommendationTemplateError {
    /// Creates a new `DeleteRecommendationTemplateError`.
    pub fn new(kind: DeleteRecommendationTemplateErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `DeleteRecommendationTemplateError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteRecommendationTemplateErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `DeleteRecommendationTemplateError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteRecommendationTemplateErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `DeleteRecommendationTemplateErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteRecommendationTemplateErrorKind::AccessDeniedException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteRecommendationTemplateErrorKind::InternalServerException`.
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteRecommendationTemplateErrorKind::InternalServerException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteRecommendationTemplateErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteRecommendationTemplateErrorKind::ResourceNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteRecommendationTemplateErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteRecommendationTemplateErrorKind::ThrottlingException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteRecommendationTemplateErrorKind::ValidationException`.
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteRecommendationTemplateErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for DeleteRecommendationTemplateError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteRecommendationTemplateErrorKind::AccessDeniedException(_inner) => Some(_inner),
            DeleteRecommendationTemplateErrorKind::InternalServerException(_inner) => Some(_inner),
            DeleteRecommendationTemplateErrorKind::ResourceNotFoundException(_inner) => {
                Some(_inner)
            }
            DeleteRecommendationTemplateErrorKind::ThrottlingException(_inner) => Some(_inner),
            DeleteRecommendationTemplateErrorKind::ValidationException(_inner) => Some(_inner),
            DeleteRecommendationTemplateErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `DeleteResiliencyPolicy` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteResiliencyPolicyError {
    /// Kind of error that occurred.
    pub kind: DeleteResiliencyPolicyErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `DeleteResiliencyPolicy` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteResiliencyPolicyErrorKind {
    /// <p>You don't have permissions to perform the requested operation. The user or role that is
    /// making the request must have at least one IAM permissions policy attached that grants the
    /// required permissions.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>Occurs when a conflict with a previous successful write is detected. This generally occurs
    /// when the previous write did not have time to propagate to the host serving the current
    /// request. A retry (with appropriate backoff logic) is the recommended response to this
    /// exception.</p>
    ConflictException(crate::error::ConflictException),
    /// <p>This exception occurs when there is an internal failure in the AWS Resilience Hub
    /// service.</p>
    InternalServerException(crate::error::InternalServerException),
    /// <p>The specified resource could not be found.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>The limit on the number of requests per second was exceeded.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>Indicates that a request was not valid.</p>
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteResiliencyPolicyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteResiliencyPolicyErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            DeleteResiliencyPolicyErrorKind::ConflictException(_inner) => _inner.fmt(f),
            DeleteResiliencyPolicyErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            DeleteResiliencyPolicyErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DeleteResiliencyPolicyErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DeleteResiliencyPolicyErrorKind::ValidationException(_inner) => _inner.fmt(f),
            DeleteResiliencyPolicyErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DeleteResiliencyPolicyError {
    fn code(&self) -> Option<&str> {
        DeleteResiliencyPolicyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteResiliencyPolicyError {
    /// Creates a new `DeleteResiliencyPolicyError`.
    pub fn new(kind: DeleteResiliencyPolicyErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `DeleteResiliencyPolicyError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteResiliencyPolicyErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `DeleteResiliencyPolicyError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteResiliencyPolicyErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `DeleteResiliencyPolicyErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteResiliencyPolicyErrorKind::AccessDeniedException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteResiliencyPolicyErrorKind::ConflictException`.
    pub fn is_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteResiliencyPolicyErrorKind::ConflictException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteResiliencyPolicyErrorKind::InternalServerException`.
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteResiliencyPolicyErrorKind::InternalServerException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteResiliencyPolicyErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteResiliencyPolicyErrorKind::ResourceNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteResiliencyPolicyErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteResiliencyPolicyErrorKind::ThrottlingException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteResiliencyPolicyErrorKind::ValidationException`.
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteResiliencyPolicyErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for DeleteResiliencyPolicyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteResiliencyPolicyErrorKind::AccessDeniedException(_inner) => Some(_inner),
            DeleteResiliencyPolicyErrorKind::ConflictException(_inner) => Some(_inner),
            DeleteResiliencyPolicyErrorKind::InternalServerException(_inner) => Some(_inner),
            DeleteResiliencyPolicyErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DeleteResiliencyPolicyErrorKind::ThrottlingException(_inner) => Some(_inner),
            DeleteResiliencyPolicyErrorKind::ValidationException(_inner) => Some(_inner),
            DeleteResiliencyPolicyErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `DescribeApp` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeAppError {
    /// Kind of error that occurred.
    pub kind: DescribeAppErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `DescribeApp` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeAppErrorKind {
    /// <p>You don't have permissions to perform the requested operation. The user or role that is
    /// making the request must have at least one IAM permissions policy attached that grants the
    /// required permissions.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>This exception occurs when there is an internal failure in the AWS Resilience Hub
    /// service.</p>
    InternalServerException(crate::error::InternalServerException),
    /// <p>The specified resource could not be found.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>The limit on the number of requests per second was exceeded.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>Indicates that a request was not valid.</p>
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeAppError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeAppErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            DescribeAppErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            DescribeAppErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DescribeAppErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DescribeAppErrorKind::ValidationException(_inner) => _inner.fmt(f),
            DescribeAppErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DescribeAppError {
    fn code(&self) -> Option<&str> {
        DescribeAppError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeAppError {
    /// Creates a new `DescribeAppError`.
    pub fn new(kind: DescribeAppErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `DescribeAppError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeAppErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `DescribeAppError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeAppErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `DescribeAppErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, DescribeAppErrorKind::AccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `DescribeAppErrorKind::InternalServerException`.
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(&self.kind, DescribeAppErrorKind::InternalServerException(_))
    }
    /// Returns `true` if the error kind is `DescribeAppErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeAppErrorKind::ResourceNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `DescribeAppErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, DescribeAppErrorKind::ThrottlingException(_))
    }
    /// Returns `true` if the error kind is `DescribeAppErrorKind::ValidationException`.
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self.kind, DescribeAppErrorKind::ValidationException(_))
    }
}
impl std::error::Error for DescribeAppError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeAppErrorKind::AccessDeniedException(_inner) => Some(_inner),
            DescribeAppErrorKind::InternalServerException(_inner) => Some(_inner),
            DescribeAppErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DescribeAppErrorKind::ThrottlingException(_inner) => Some(_inner),
            DescribeAppErrorKind::ValidationException(_inner) => Some(_inner),
            DescribeAppErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `DescribeAppAssessment` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeAppAssessmentError {
    /// Kind of error that occurred.
    pub kind: DescribeAppAssessmentErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `DescribeAppAssessment` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeAppAssessmentErrorKind {
    /// <p>You don't have permissions to perform the requested operation. The user or role that is
    /// making the request must have at least one IAM permissions policy attached that grants the
    /// required permissions.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>This exception occurs when there is an internal failure in the AWS Resilience Hub
    /// service.</p>
    InternalServerException(crate::error::InternalServerException),
    /// <p>The specified resource could not be found.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>The limit on the number of requests per second was exceeded.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>Indicates that a request was not valid.</p>
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeAppAssessmentError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeAppAssessmentErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            DescribeAppAssessmentErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            DescribeAppAssessmentErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DescribeAppAssessmentErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DescribeAppAssessmentErrorKind::ValidationException(_inner) => _inner.fmt(f),
            DescribeAppAssessmentErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DescribeAppAssessmentError {
    fn code(&self) -> Option<&str> {
        DescribeAppAssessmentError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeAppAssessmentError {
    /// Creates a new `DescribeAppAssessmentError`.
    pub fn new(kind: DescribeAppAssessmentErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `DescribeAppAssessmentError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeAppAssessmentErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `DescribeAppAssessmentError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeAppAssessmentErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `DescribeAppAssessmentErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeAppAssessmentErrorKind::AccessDeniedException(_)
        )
    }
    /// Returns `true` if the error kind is `DescribeAppAssessmentErrorKind::InternalServerException`.
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeAppAssessmentErrorKind::InternalServerException(_)
        )
    }
    /// Returns `true` if the error kind is `DescribeAppAssessmentErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeAppAssessmentErrorKind::ResourceNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `DescribeAppAssessmentErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeAppAssessmentErrorKind::ThrottlingException(_)
        )
    }
    /// Returns `true` if the error kind is `DescribeAppAssessmentErrorKind::ValidationException`.
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeAppAssessmentErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for DescribeAppAssessmentError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeAppAssessmentErrorKind::AccessDeniedException(_inner) => Some(_inner),
            DescribeAppAssessmentErrorKind::InternalServerException(_inner) => Some(_inner),
            DescribeAppAssessmentErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DescribeAppAssessmentErrorKind::ThrottlingException(_inner) => Some(_inner),
            DescribeAppAssessmentErrorKind::ValidationException(_inner) => Some(_inner),
            DescribeAppAssessmentErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `DescribeAppVersionResourcesResolutionStatus` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeAppVersionResourcesResolutionStatusError {
    /// Kind of error that occurred.
    pub kind: DescribeAppVersionResourcesResolutionStatusErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `DescribeAppVersionResourcesResolutionStatus` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeAppVersionResourcesResolutionStatusErrorKind {
    /// <p>You don't have permissions to perform the requested operation. The user or role that is
    /// making the request must have at least one IAM permissions policy attached that grants the
    /// required permissions.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>This exception occurs when there is an internal failure in the AWS Resilience Hub
    /// service.</p>
    InternalServerException(crate::error::InternalServerException),
    /// <p>The specified resource could not be found.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>The limit on the number of requests per second was exceeded.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>Indicates that a request was not valid.</p>
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeAppVersionResourcesResolutionStatusError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeAppVersionResourcesResolutionStatusErrorKind::AccessDeniedException(_inner) => {
                _inner.fmt(f)
            }
            DescribeAppVersionResourcesResolutionStatusErrorKind::InternalServerException(
                _inner,
            ) => _inner.fmt(f),
            DescribeAppVersionResourcesResolutionStatusErrorKind::ResourceNotFoundException(
                _inner,
            ) => _inner.fmt(f),
            DescribeAppVersionResourcesResolutionStatusErrorKind::ThrottlingException(_inner) => {
                _inner.fmt(f)
            }
            DescribeAppVersionResourcesResolutionStatusErrorKind::ValidationException(_inner) => {
                _inner.fmt(f)
            }
            DescribeAppVersionResourcesResolutionStatusErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind
    for DescribeAppVersionResourcesResolutionStatusError
{
    fn code(&self) -> Option<&str> {
        DescribeAppVersionResourcesResolutionStatusError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeAppVersionResourcesResolutionStatusError {
    /// Creates a new `DescribeAppVersionResourcesResolutionStatusError`.
    pub fn new(
        kind: DescribeAppVersionResourcesResolutionStatusErrorKind,
        meta: aws_smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    /// Creates the `DescribeAppVersionResourcesResolutionStatusError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeAppVersionResourcesResolutionStatusErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `DescribeAppVersionResourcesResolutionStatusError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeAppVersionResourcesResolutionStatusErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `DescribeAppVersionResourcesResolutionStatusErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeAppVersionResourcesResolutionStatusErrorKind::AccessDeniedException(_)
        )
    }
    /// Returns `true` if the error kind is `DescribeAppVersionResourcesResolutionStatusErrorKind::InternalServerException`.
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeAppVersionResourcesResolutionStatusErrorKind::InternalServerException(_)
        )
    }
    /// Returns `true` if the error kind is `DescribeAppVersionResourcesResolutionStatusErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeAppVersionResourcesResolutionStatusErrorKind::ResourceNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `DescribeAppVersionResourcesResolutionStatusErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeAppVersionResourcesResolutionStatusErrorKind::ThrottlingException(_)
        )
    }
    /// Returns `true` if the error kind is `DescribeAppVersionResourcesResolutionStatusErrorKind::ValidationException`.
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeAppVersionResourcesResolutionStatusErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for DescribeAppVersionResourcesResolutionStatusError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeAppVersionResourcesResolutionStatusErrorKind::AccessDeniedException(_inner) => {
                Some(_inner)
            }
            DescribeAppVersionResourcesResolutionStatusErrorKind::InternalServerException(
                _inner,
            ) => Some(_inner),
            DescribeAppVersionResourcesResolutionStatusErrorKind::ResourceNotFoundException(
                _inner,
            ) => Some(_inner),
            DescribeAppVersionResourcesResolutionStatusErrorKind::ThrottlingException(_inner) => {
                Some(_inner)
            }
            DescribeAppVersionResourcesResolutionStatusErrorKind::ValidationException(_inner) => {
                Some(_inner)
            }
            DescribeAppVersionResourcesResolutionStatusErrorKind::Unhandled(_inner) => {
                Some(_inner.as_ref())
            }
        }
    }
}

/// Error type for the `DescribeAppVersionTemplate` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeAppVersionTemplateError {
    /// Kind of error that occurred.
    pub kind: DescribeAppVersionTemplateErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `DescribeAppVersionTemplate` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeAppVersionTemplateErrorKind {
    /// <p>You don't have permissions to perform the requested operation. The user or role that is
    /// making the request must have at least one IAM permissions policy attached that grants the
    /// required permissions.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>This exception occurs when there is an internal failure in the AWS Resilience Hub
    /// service.</p>
    InternalServerException(crate::error::InternalServerException),
    /// <p>The specified resource could not be found.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>The limit on the number of requests per second was exceeded.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>Indicates that a request was not valid.</p>
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeAppVersionTemplateError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeAppVersionTemplateErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            DescribeAppVersionTemplateErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            DescribeAppVersionTemplateErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DescribeAppVersionTemplateErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DescribeAppVersionTemplateErrorKind::ValidationException(_inner) => _inner.fmt(f),
            DescribeAppVersionTemplateErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DescribeAppVersionTemplateError {
    fn code(&self) -> Option<&str> {
        DescribeAppVersionTemplateError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeAppVersionTemplateError {
    /// Creates a new `DescribeAppVersionTemplateError`.
    pub fn new(kind: DescribeAppVersionTemplateErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `DescribeAppVersionTemplateError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeAppVersionTemplateErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `DescribeAppVersionTemplateError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeAppVersionTemplateErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `DescribeAppVersionTemplateErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeAppVersionTemplateErrorKind::AccessDeniedException(_)
        )
    }
    /// Returns `true` if the error kind is `DescribeAppVersionTemplateErrorKind::InternalServerException`.
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeAppVersionTemplateErrorKind::InternalServerException(_)
        )
    }
    /// Returns `true` if the error kind is `DescribeAppVersionTemplateErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeAppVersionTemplateErrorKind::ResourceNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `DescribeAppVersionTemplateErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeAppVersionTemplateErrorKind::ThrottlingException(_)
        )
    }
    /// Returns `true` if the error kind is `DescribeAppVersionTemplateErrorKind::ValidationException`.
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeAppVersionTemplateErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for DescribeAppVersionTemplateError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeAppVersionTemplateErrorKind::AccessDeniedException(_inner) => Some(_inner),
            DescribeAppVersionTemplateErrorKind::InternalServerException(_inner) => Some(_inner),
            DescribeAppVersionTemplateErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DescribeAppVersionTemplateErrorKind::ThrottlingException(_inner) => Some(_inner),
            DescribeAppVersionTemplateErrorKind::ValidationException(_inner) => Some(_inner),
            DescribeAppVersionTemplateErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `DescribeDraftAppVersionResourcesImportStatus` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeDraftAppVersionResourcesImportStatusError {
    /// Kind of error that occurred.
    pub kind: DescribeDraftAppVersionResourcesImportStatusErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `DescribeDraftAppVersionResourcesImportStatus` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeDraftAppVersionResourcesImportStatusErrorKind {
    /// <p>You don't have permissions to perform the requested operation. The user or role that is
    /// making the request must have at least one IAM permissions policy attached that grants the
    /// required permissions.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>This exception occurs when there is an internal failure in the AWS Resilience Hub
    /// service.</p>
    InternalServerException(crate::error::InternalServerException),
    /// <p>The specified resource could not be found.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>The limit on the number of requests per second was exceeded.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>Indicates that a request was not valid.</p>
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeDraftAppVersionResourcesImportStatusError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeDraftAppVersionResourcesImportStatusErrorKind::AccessDeniedException(
                _inner,
            ) => _inner.fmt(f),
            DescribeDraftAppVersionResourcesImportStatusErrorKind::InternalServerException(
                _inner,
            ) => _inner.fmt(f),
            DescribeDraftAppVersionResourcesImportStatusErrorKind::ResourceNotFoundException(
                _inner,
            ) => _inner.fmt(f),
            DescribeDraftAppVersionResourcesImportStatusErrorKind::ThrottlingException(_inner) => {
                _inner.fmt(f)
            }
            DescribeDraftAppVersionResourcesImportStatusErrorKind::ValidationException(_inner) => {
                _inner.fmt(f)
            }
            DescribeDraftAppVersionResourcesImportStatusErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind
    for DescribeDraftAppVersionResourcesImportStatusError
{
    fn code(&self) -> Option<&str> {
        DescribeDraftAppVersionResourcesImportStatusError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeDraftAppVersionResourcesImportStatusError {
    /// Creates a new `DescribeDraftAppVersionResourcesImportStatusError`.
    pub fn new(
        kind: DescribeDraftAppVersionResourcesImportStatusErrorKind,
        meta: aws_smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    /// Creates the `DescribeDraftAppVersionResourcesImportStatusError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeDraftAppVersionResourcesImportStatusErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `DescribeDraftAppVersionResourcesImportStatusError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeDraftAppVersionResourcesImportStatusErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `DescribeDraftAppVersionResourcesImportStatusErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeDraftAppVersionResourcesImportStatusErrorKind::AccessDeniedException(_)
        )
    }
    /// Returns `true` if the error kind is `DescribeDraftAppVersionResourcesImportStatusErrorKind::InternalServerException`.
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeDraftAppVersionResourcesImportStatusErrorKind::InternalServerException(_)
        )
    }
    /// Returns `true` if the error kind is `DescribeDraftAppVersionResourcesImportStatusErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeDraftAppVersionResourcesImportStatusErrorKind::ResourceNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `DescribeDraftAppVersionResourcesImportStatusErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeDraftAppVersionResourcesImportStatusErrorKind::ThrottlingException(_)
        )
    }
    /// Returns `true` if the error kind is `DescribeDraftAppVersionResourcesImportStatusErrorKind::ValidationException`.
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeDraftAppVersionResourcesImportStatusErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for DescribeDraftAppVersionResourcesImportStatusError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeDraftAppVersionResourcesImportStatusErrorKind::AccessDeniedException(
                _inner,
            ) => Some(_inner),
            DescribeDraftAppVersionResourcesImportStatusErrorKind::InternalServerException(
                _inner,
            ) => Some(_inner),
            DescribeDraftAppVersionResourcesImportStatusErrorKind::ResourceNotFoundException(
                _inner,
            ) => Some(_inner),
            DescribeDraftAppVersionResourcesImportStatusErrorKind::ThrottlingException(_inner) => {
                Some(_inner)
            }
            DescribeDraftAppVersionResourcesImportStatusErrorKind::ValidationException(_inner) => {
                Some(_inner)
            }
            DescribeDraftAppVersionResourcesImportStatusErrorKind::Unhandled(_inner) => {
                Some(_inner.as_ref())
            }
        }
    }
}

/// Error type for the `DescribeResiliencyPolicy` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeResiliencyPolicyError {
    /// Kind of error that occurred.
    pub kind: DescribeResiliencyPolicyErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `DescribeResiliencyPolicy` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeResiliencyPolicyErrorKind {
    /// <p>You don't have permissions to perform the requested operation. The user or role that is
    /// making the request must have at least one IAM permissions policy attached that grants the
    /// required permissions.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>This exception occurs when there is an internal failure in the AWS Resilience Hub
    /// service.</p>
    InternalServerException(crate::error::InternalServerException),
    /// <p>The specified resource could not be found.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>The limit on the number of requests per second was exceeded.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>Indicates that a request was not valid.</p>
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeResiliencyPolicyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeResiliencyPolicyErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            DescribeResiliencyPolicyErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            DescribeResiliencyPolicyErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DescribeResiliencyPolicyErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DescribeResiliencyPolicyErrorKind::ValidationException(_inner) => _inner.fmt(f),
            DescribeResiliencyPolicyErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DescribeResiliencyPolicyError {
    fn code(&self) -> Option<&str> {
        DescribeResiliencyPolicyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeResiliencyPolicyError {
    /// Creates a new `DescribeResiliencyPolicyError`.
    pub fn new(kind: DescribeResiliencyPolicyErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `DescribeResiliencyPolicyError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeResiliencyPolicyErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `DescribeResiliencyPolicyError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeResiliencyPolicyErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `DescribeResiliencyPolicyErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeResiliencyPolicyErrorKind::AccessDeniedException(_)
        )
    }
    /// Returns `true` if the error kind is `DescribeResiliencyPolicyErrorKind::InternalServerException`.
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeResiliencyPolicyErrorKind::InternalServerException(_)
        )
    }
    /// Returns `true` if the error kind is `DescribeResiliencyPolicyErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeResiliencyPolicyErrorKind::ResourceNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `DescribeResiliencyPolicyErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeResiliencyPolicyErrorKind::ThrottlingException(_)
        )
    }
    /// Returns `true` if the error kind is `DescribeResiliencyPolicyErrorKind::ValidationException`.
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeResiliencyPolicyErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for DescribeResiliencyPolicyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeResiliencyPolicyErrorKind::AccessDeniedException(_inner) => Some(_inner),
            DescribeResiliencyPolicyErrorKind::InternalServerException(_inner) => Some(_inner),
            DescribeResiliencyPolicyErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DescribeResiliencyPolicyErrorKind::ThrottlingException(_inner) => Some(_inner),
            DescribeResiliencyPolicyErrorKind::ValidationException(_inner) => Some(_inner),
            DescribeResiliencyPolicyErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `ImportResourcesToDraftAppVersion` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ImportResourcesToDraftAppVersionError {
    /// Kind of error that occurred.
    pub kind: ImportResourcesToDraftAppVersionErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `ImportResourcesToDraftAppVersion` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ImportResourcesToDraftAppVersionErrorKind {
    /// <p>You don't have permissions to perform the requested operation. The user or role that is
    /// making the request must have at least one IAM permissions policy attached that grants the
    /// required permissions.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>Occurs when a conflict with a previous successful write is detected. This generally occurs
    /// when the previous write did not have time to propagate to the host serving the current
    /// request. A retry (with appropriate backoff logic) is the recommended response to this
    /// exception.</p>
    ConflictException(crate::error::ConflictException),
    /// <p>This exception occurs when there is an internal failure in the AWS Resilience Hub
    /// service.</p>
    InternalServerException(crate::error::InternalServerException),
    /// <p>The specified resource could not be found.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>The limit on the number of requests per second was exceeded.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>Indicates that a request was not valid.</p>
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ImportResourcesToDraftAppVersionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ImportResourcesToDraftAppVersionErrorKind::AccessDeniedException(_inner) => {
                _inner.fmt(f)
            }
            ImportResourcesToDraftAppVersionErrorKind::ConflictException(_inner) => _inner.fmt(f),
            ImportResourcesToDraftAppVersionErrorKind::InternalServerException(_inner) => {
                _inner.fmt(f)
            }
            ImportResourcesToDraftAppVersionErrorKind::ResourceNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            ImportResourcesToDraftAppVersionErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            ImportResourcesToDraftAppVersionErrorKind::ValidationException(_inner) => _inner.fmt(f),
            ImportResourcesToDraftAppVersionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ImportResourcesToDraftAppVersionError {
    fn code(&self) -> Option<&str> {
        ImportResourcesToDraftAppVersionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ImportResourcesToDraftAppVersionError {
    /// Creates a new `ImportResourcesToDraftAppVersionError`.
    pub fn new(
        kind: ImportResourcesToDraftAppVersionErrorKind,
        meta: aws_smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    /// Creates the `ImportResourcesToDraftAppVersionError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ImportResourcesToDraftAppVersionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `ImportResourcesToDraftAppVersionError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ImportResourcesToDraftAppVersionErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `ImportResourcesToDraftAppVersionErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            ImportResourcesToDraftAppVersionErrorKind::AccessDeniedException(_)
        )
    }
    /// Returns `true` if the error kind is `ImportResourcesToDraftAppVersionErrorKind::ConflictException`.
    pub fn is_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            ImportResourcesToDraftAppVersionErrorKind::ConflictException(_)
        )
    }
    /// Returns `true` if the error kind is `ImportResourcesToDraftAppVersionErrorKind::InternalServerException`.
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            ImportResourcesToDraftAppVersionErrorKind::InternalServerException(_)
        )
    }
    /// Returns `true` if the error kind is `ImportResourcesToDraftAppVersionErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            ImportResourcesToDraftAppVersionErrorKind::ResourceNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `ImportResourcesToDraftAppVersionErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            ImportResourcesToDraftAppVersionErrorKind::ThrottlingException(_)
        )
    }
    /// Returns `true` if the error kind is `ImportResourcesToDraftAppVersionErrorKind::ValidationException`.
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            ImportResourcesToDraftAppVersionErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for ImportResourcesToDraftAppVersionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ImportResourcesToDraftAppVersionErrorKind::AccessDeniedException(_inner) => {
                Some(_inner)
            }
            ImportResourcesToDraftAppVersionErrorKind::ConflictException(_inner) => Some(_inner),
            ImportResourcesToDraftAppVersionErrorKind::InternalServerException(_inner) => {
                Some(_inner)
            }
            ImportResourcesToDraftAppVersionErrorKind::ResourceNotFoundException(_inner) => {
                Some(_inner)
            }
            ImportResourcesToDraftAppVersionErrorKind::ThrottlingException(_inner) => Some(_inner),
            ImportResourcesToDraftAppVersionErrorKind::ValidationException(_inner) => Some(_inner),
            ImportResourcesToDraftAppVersionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `ListAlarmRecommendations` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListAlarmRecommendationsError {
    /// Kind of error that occurred.
    pub kind: ListAlarmRecommendationsErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `ListAlarmRecommendations` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListAlarmRecommendationsErrorKind {
    /// <p>You don't have permissions to perform the requested operation. The user or role that is
    /// making the request must have at least one IAM permissions policy attached that grants the
    /// required permissions.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>This exception occurs when there is an internal failure in the AWS Resilience Hub
    /// service.</p>
    InternalServerException(crate::error::InternalServerException),
    /// <p>The specified resource could not be found.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>The limit on the number of requests per second was exceeded.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>Indicates that a request was not valid.</p>
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListAlarmRecommendationsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListAlarmRecommendationsErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            ListAlarmRecommendationsErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            ListAlarmRecommendationsErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            ListAlarmRecommendationsErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            ListAlarmRecommendationsErrorKind::ValidationException(_inner) => _inner.fmt(f),
            ListAlarmRecommendationsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ListAlarmRecommendationsError {
    fn code(&self) -> Option<&str> {
        ListAlarmRecommendationsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListAlarmRecommendationsError {
    /// Creates a new `ListAlarmRecommendationsError`.
    pub fn new(kind: ListAlarmRecommendationsErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `ListAlarmRecommendationsError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListAlarmRecommendationsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `ListAlarmRecommendationsError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListAlarmRecommendationsErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `ListAlarmRecommendationsErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListAlarmRecommendationsErrorKind::AccessDeniedException(_)
        )
    }
    /// Returns `true` if the error kind is `ListAlarmRecommendationsErrorKind::InternalServerException`.
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListAlarmRecommendationsErrorKind::InternalServerException(_)
        )
    }
    /// Returns `true` if the error kind is `ListAlarmRecommendationsErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListAlarmRecommendationsErrorKind::ResourceNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `ListAlarmRecommendationsErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListAlarmRecommendationsErrorKind::ThrottlingException(_)
        )
    }
    /// Returns `true` if the error kind is `ListAlarmRecommendationsErrorKind::ValidationException`.
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListAlarmRecommendationsErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for ListAlarmRecommendationsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListAlarmRecommendationsErrorKind::AccessDeniedException(_inner) => Some(_inner),
            ListAlarmRecommendationsErrorKind::InternalServerException(_inner) => Some(_inner),
            ListAlarmRecommendationsErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            ListAlarmRecommendationsErrorKind::ThrottlingException(_inner) => Some(_inner),
            ListAlarmRecommendationsErrorKind::ValidationException(_inner) => Some(_inner),
            ListAlarmRecommendationsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `ListAppAssessments` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListAppAssessmentsError {
    /// Kind of error that occurred.
    pub kind: ListAppAssessmentsErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `ListAppAssessments` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListAppAssessmentsErrorKind {
    /// <p>You don't have permissions to perform the requested operation. The user or role that is
    /// making the request must have at least one IAM permissions policy attached that grants the
    /// required permissions.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>This exception occurs when there is an internal failure in the AWS Resilience Hub
    /// service.</p>
    InternalServerException(crate::error::InternalServerException),
    /// <p>The specified resource could not be found.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>The limit on the number of requests per second was exceeded.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>Indicates that a request was not valid.</p>
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListAppAssessmentsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListAppAssessmentsErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            ListAppAssessmentsErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            ListAppAssessmentsErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            ListAppAssessmentsErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            ListAppAssessmentsErrorKind::ValidationException(_inner) => _inner.fmt(f),
            ListAppAssessmentsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ListAppAssessmentsError {
    fn code(&self) -> Option<&str> {
        ListAppAssessmentsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListAppAssessmentsError {
    /// Creates a new `ListAppAssessmentsError`.
    pub fn new(kind: ListAppAssessmentsErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `ListAppAssessmentsError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListAppAssessmentsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `ListAppAssessmentsError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListAppAssessmentsErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `ListAppAssessmentsErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListAppAssessmentsErrorKind::AccessDeniedException(_)
        )
    }
    /// Returns `true` if the error kind is `ListAppAssessmentsErrorKind::InternalServerException`.
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListAppAssessmentsErrorKind::InternalServerException(_)
        )
    }
    /// Returns `true` if the error kind is `ListAppAssessmentsErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListAppAssessmentsErrorKind::ResourceNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `ListAppAssessmentsErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListAppAssessmentsErrorKind::ThrottlingException(_)
        )
    }
    /// Returns `true` if the error kind is `ListAppAssessmentsErrorKind::ValidationException`.
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListAppAssessmentsErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for ListAppAssessmentsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListAppAssessmentsErrorKind::AccessDeniedException(_inner) => Some(_inner),
            ListAppAssessmentsErrorKind::InternalServerException(_inner) => Some(_inner),
            ListAppAssessmentsErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            ListAppAssessmentsErrorKind::ThrottlingException(_inner) => Some(_inner),
            ListAppAssessmentsErrorKind::ValidationException(_inner) => Some(_inner),
            ListAppAssessmentsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `ListAppComponentCompliances` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListAppComponentCompliancesError {
    /// Kind of error that occurred.
    pub kind: ListAppComponentCompliancesErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `ListAppComponentCompliances` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListAppComponentCompliancesErrorKind {
    /// <p>You don't have permissions to perform the requested operation. The user or role that is
    /// making the request must have at least one IAM permissions policy attached that grants the
    /// required permissions.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>This exception occurs when there is an internal failure in the AWS Resilience Hub
    /// service.</p>
    InternalServerException(crate::error::InternalServerException),
    /// <p>The specified resource could not be found.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>The limit on the number of requests per second was exceeded.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>Indicates that a request was not valid.</p>
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListAppComponentCompliancesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListAppComponentCompliancesErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            ListAppComponentCompliancesErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            ListAppComponentCompliancesErrorKind::ResourceNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            ListAppComponentCompliancesErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            ListAppComponentCompliancesErrorKind::ValidationException(_inner) => _inner.fmt(f),
            ListAppComponentCompliancesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ListAppComponentCompliancesError {
    fn code(&self) -> Option<&str> {
        ListAppComponentCompliancesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListAppComponentCompliancesError {
    /// Creates a new `ListAppComponentCompliancesError`.
    pub fn new(kind: ListAppComponentCompliancesErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `ListAppComponentCompliancesError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListAppComponentCompliancesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `ListAppComponentCompliancesError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListAppComponentCompliancesErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `ListAppComponentCompliancesErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListAppComponentCompliancesErrorKind::AccessDeniedException(_)
        )
    }
    /// Returns `true` if the error kind is `ListAppComponentCompliancesErrorKind::InternalServerException`.
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListAppComponentCompliancesErrorKind::InternalServerException(_)
        )
    }
    /// Returns `true` if the error kind is `ListAppComponentCompliancesErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListAppComponentCompliancesErrorKind::ResourceNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `ListAppComponentCompliancesErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListAppComponentCompliancesErrorKind::ThrottlingException(_)
        )
    }
    /// Returns `true` if the error kind is `ListAppComponentCompliancesErrorKind::ValidationException`.
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListAppComponentCompliancesErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for ListAppComponentCompliancesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListAppComponentCompliancesErrorKind::AccessDeniedException(_inner) => Some(_inner),
            ListAppComponentCompliancesErrorKind::InternalServerException(_inner) => Some(_inner),
            ListAppComponentCompliancesErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            ListAppComponentCompliancesErrorKind::ThrottlingException(_inner) => Some(_inner),
            ListAppComponentCompliancesErrorKind::ValidationException(_inner) => Some(_inner),
            ListAppComponentCompliancesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `ListAppComponentRecommendations` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListAppComponentRecommendationsError {
    /// Kind of error that occurred.
    pub kind: ListAppComponentRecommendationsErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `ListAppComponentRecommendations` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListAppComponentRecommendationsErrorKind {
    /// <p>You don't have permissions to perform the requested operation. The user or role that is
    /// making the request must have at least one IAM permissions policy attached that grants the
    /// required permissions.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>This exception occurs when there is an internal failure in the AWS Resilience Hub
    /// service.</p>
    InternalServerException(crate::error::InternalServerException),
    /// <p>The specified resource could not be found.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>The limit on the number of requests per second was exceeded.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>Indicates that a request was not valid.</p>
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListAppComponentRecommendationsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListAppComponentRecommendationsErrorKind::AccessDeniedException(_inner) => {
                _inner.fmt(f)
            }
            ListAppComponentRecommendationsErrorKind::InternalServerException(_inner) => {
                _inner.fmt(f)
            }
            ListAppComponentRecommendationsErrorKind::ResourceNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            ListAppComponentRecommendationsErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            ListAppComponentRecommendationsErrorKind::ValidationException(_inner) => _inner.fmt(f),
            ListAppComponentRecommendationsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ListAppComponentRecommendationsError {
    fn code(&self) -> Option<&str> {
        ListAppComponentRecommendationsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListAppComponentRecommendationsError {
    /// Creates a new `ListAppComponentRecommendationsError`.
    pub fn new(
        kind: ListAppComponentRecommendationsErrorKind,
        meta: aws_smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    /// Creates the `ListAppComponentRecommendationsError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListAppComponentRecommendationsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `ListAppComponentRecommendationsError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListAppComponentRecommendationsErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `ListAppComponentRecommendationsErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListAppComponentRecommendationsErrorKind::AccessDeniedException(_)
        )
    }
    /// Returns `true` if the error kind is `ListAppComponentRecommendationsErrorKind::InternalServerException`.
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListAppComponentRecommendationsErrorKind::InternalServerException(_)
        )
    }
    /// Returns `true` if the error kind is `ListAppComponentRecommendationsErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListAppComponentRecommendationsErrorKind::ResourceNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `ListAppComponentRecommendationsErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListAppComponentRecommendationsErrorKind::ThrottlingException(_)
        )
    }
    /// Returns `true` if the error kind is `ListAppComponentRecommendationsErrorKind::ValidationException`.
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListAppComponentRecommendationsErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for ListAppComponentRecommendationsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListAppComponentRecommendationsErrorKind::AccessDeniedException(_inner) => Some(_inner),
            ListAppComponentRecommendationsErrorKind::InternalServerException(_inner) => {
                Some(_inner)
            }
            ListAppComponentRecommendationsErrorKind::ResourceNotFoundException(_inner) => {
                Some(_inner)
            }
            ListAppComponentRecommendationsErrorKind::ThrottlingException(_inner) => Some(_inner),
            ListAppComponentRecommendationsErrorKind::ValidationException(_inner) => Some(_inner),
            ListAppComponentRecommendationsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `ListApps` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListAppsError {
    /// Kind of error that occurred.
    pub kind: ListAppsErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `ListApps` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListAppsErrorKind {
    /// <p>You don't have permissions to perform the requested operation. The user or role that is
    /// making the request must have at least one IAM permissions policy attached that grants the
    /// required permissions.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>This exception occurs when there is an internal failure in the AWS Resilience Hub
    /// service.</p>
    InternalServerException(crate::error::InternalServerException),
    /// <p>The limit on the number of requests per second was exceeded.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>Indicates that a request was not valid.</p>
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListAppsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListAppsErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            ListAppsErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            ListAppsErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            ListAppsErrorKind::ValidationException(_inner) => _inner.fmt(f),
            ListAppsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ListAppsError {
    fn code(&self) -> Option<&str> {
        ListAppsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListAppsError {
    /// Creates a new `ListAppsError`.
    pub fn new(kind: ListAppsErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `ListAppsError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListAppsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `ListAppsError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListAppsErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `ListAppsErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, ListAppsErrorKind::AccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `ListAppsErrorKind::InternalServerException`.
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(&self.kind, ListAppsErrorKind::InternalServerException(_))
    }
    /// Returns `true` if the error kind is `ListAppsErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, ListAppsErrorKind::ThrottlingException(_))
    }
    /// Returns `true` if the error kind is `ListAppsErrorKind::ValidationException`.
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self.kind, ListAppsErrorKind::ValidationException(_))
    }
}
impl std::error::Error for ListAppsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListAppsErrorKind::AccessDeniedException(_inner) => Some(_inner),
            ListAppsErrorKind::InternalServerException(_inner) => Some(_inner),
            ListAppsErrorKind::ThrottlingException(_inner) => Some(_inner),
            ListAppsErrorKind::ValidationException(_inner) => Some(_inner),
            ListAppsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `ListAppVersionResourceMappings` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListAppVersionResourceMappingsError {
    /// Kind of error that occurred.
    pub kind: ListAppVersionResourceMappingsErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `ListAppVersionResourceMappings` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListAppVersionResourceMappingsErrorKind {
    /// <p>You don't have permissions to perform the requested operation. The user or role that is
    /// making the request must have at least one IAM permissions policy attached that grants the
    /// required permissions.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>This exception occurs when there is an internal failure in the AWS Resilience Hub
    /// service.</p>
    InternalServerException(crate::error::InternalServerException),
    /// <p>The specified resource could not be found.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>The limit on the number of requests per second was exceeded.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>Indicates that a request was not valid.</p>
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListAppVersionResourceMappingsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListAppVersionResourceMappingsErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            ListAppVersionResourceMappingsErrorKind::InternalServerException(_inner) => {
                _inner.fmt(f)
            }
            ListAppVersionResourceMappingsErrorKind::ResourceNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            ListAppVersionResourceMappingsErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            ListAppVersionResourceMappingsErrorKind::ValidationException(_inner) => _inner.fmt(f),
            ListAppVersionResourceMappingsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ListAppVersionResourceMappingsError {
    fn code(&self) -> Option<&str> {
        ListAppVersionResourceMappingsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListAppVersionResourceMappingsError {
    /// Creates a new `ListAppVersionResourceMappingsError`.
    pub fn new(
        kind: ListAppVersionResourceMappingsErrorKind,
        meta: aws_smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    /// Creates the `ListAppVersionResourceMappingsError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListAppVersionResourceMappingsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `ListAppVersionResourceMappingsError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListAppVersionResourceMappingsErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `ListAppVersionResourceMappingsErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListAppVersionResourceMappingsErrorKind::AccessDeniedException(_)
        )
    }
    /// Returns `true` if the error kind is `ListAppVersionResourceMappingsErrorKind::InternalServerException`.
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListAppVersionResourceMappingsErrorKind::InternalServerException(_)
        )
    }
    /// Returns `true` if the error kind is `ListAppVersionResourceMappingsErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListAppVersionResourceMappingsErrorKind::ResourceNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `ListAppVersionResourceMappingsErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListAppVersionResourceMappingsErrorKind::ThrottlingException(_)
        )
    }
    /// Returns `true` if the error kind is `ListAppVersionResourceMappingsErrorKind::ValidationException`.
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListAppVersionResourceMappingsErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for ListAppVersionResourceMappingsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListAppVersionResourceMappingsErrorKind::AccessDeniedException(_inner) => Some(_inner),
            ListAppVersionResourceMappingsErrorKind::InternalServerException(_inner) => {
                Some(_inner)
            }
            ListAppVersionResourceMappingsErrorKind::ResourceNotFoundException(_inner) => {
                Some(_inner)
            }
            ListAppVersionResourceMappingsErrorKind::ThrottlingException(_inner) => Some(_inner),
            ListAppVersionResourceMappingsErrorKind::ValidationException(_inner) => Some(_inner),
            ListAppVersionResourceMappingsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `ListAppVersionResources` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListAppVersionResourcesError {
    /// Kind of error that occurred.
    pub kind: ListAppVersionResourcesErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `ListAppVersionResources` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListAppVersionResourcesErrorKind {
    /// <p>You don't have permissions to perform the requested operation. The user or role that is
    /// making the request must have at least one IAM permissions policy attached that grants the
    /// required permissions.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>Occurs when a conflict with a previous successful write is detected. This generally occurs
    /// when the previous write did not have time to propagate to the host serving the current
    /// request. A retry (with appropriate backoff logic) is the recommended response to this
    /// exception.</p>
    ConflictException(crate::error::ConflictException),
    /// <p>This exception occurs when there is an internal failure in the AWS Resilience Hub
    /// service.</p>
    InternalServerException(crate::error::InternalServerException),
    /// <p>The specified resource could not be found.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>The limit on the number of requests per second was exceeded.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>Indicates that a request was not valid.</p>
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListAppVersionResourcesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListAppVersionResourcesErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            ListAppVersionResourcesErrorKind::ConflictException(_inner) => _inner.fmt(f),
            ListAppVersionResourcesErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            ListAppVersionResourcesErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            ListAppVersionResourcesErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            ListAppVersionResourcesErrorKind::ValidationException(_inner) => _inner.fmt(f),
            ListAppVersionResourcesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ListAppVersionResourcesError {
    fn code(&self) -> Option<&str> {
        ListAppVersionResourcesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListAppVersionResourcesError {
    /// Creates a new `ListAppVersionResourcesError`.
    pub fn new(kind: ListAppVersionResourcesErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `ListAppVersionResourcesError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListAppVersionResourcesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `ListAppVersionResourcesError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListAppVersionResourcesErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `ListAppVersionResourcesErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListAppVersionResourcesErrorKind::AccessDeniedException(_)
        )
    }
    /// Returns `true` if the error kind is `ListAppVersionResourcesErrorKind::ConflictException`.
    pub fn is_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListAppVersionResourcesErrorKind::ConflictException(_)
        )
    }
    /// Returns `true` if the error kind is `ListAppVersionResourcesErrorKind::InternalServerException`.
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListAppVersionResourcesErrorKind::InternalServerException(_)
        )
    }
    /// Returns `true` if the error kind is `ListAppVersionResourcesErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListAppVersionResourcesErrorKind::ResourceNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `ListAppVersionResourcesErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListAppVersionResourcesErrorKind::ThrottlingException(_)
        )
    }
    /// Returns `true` if the error kind is `ListAppVersionResourcesErrorKind::ValidationException`.
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListAppVersionResourcesErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for ListAppVersionResourcesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListAppVersionResourcesErrorKind::AccessDeniedException(_inner) => Some(_inner),
            ListAppVersionResourcesErrorKind::ConflictException(_inner) => Some(_inner),
            ListAppVersionResourcesErrorKind::InternalServerException(_inner) => Some(_inner),
            ListAppVersionResourcesErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            ListAppVersionResourcesErrorKind::ThrottlingException(_inner) => Some(_inner),
            ListAppVersionResourcesErrorKind::ValidationException(_inner) => Some(_inner),
            ListAppVersionResourcesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `ListAppVersions` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListAppVersionsError {
    /// Kind of error that occurred.
    pub kind: ListAppVersionsErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `ListAppVersions` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListAppVersionsErrorKind {
    /// <p>You don't have permissions to perform the requested operation. The user or role that is
    /// making the request must have at least one IAM permissions policy attached that grants the
    /// required permissions.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>This exception occurs when there is an internal failure in the AWS Resilience Hub
    /// service.</p>
    InternalServerException(crate::error::InternalServerException),
    /// <p>The specified resource could not be found.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>Indicates that a request was not valid.</p>
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListAppVersionsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListAppVersionsErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            ListAppVersionsErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            ListAppVersionsErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            ListAppVersionsErrorKind::ValidationException(_inner) => _inner.fmt(f),
            ListAppVersionsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ListAppVersionsError {
    fn code(&self) -> Option<&str> {
        ListAppVersionsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListAppVersionsError {
    /// Creates a new `ListAppVersionsError`.
    pub fn new(kind: ListAppVersionsErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `ListAppVersionsError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListAppVersionsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `ListAppVersionsError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListAppVersionsErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `ListAppVersionsErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListAppVersionsErrorKind::AccessDeniedException(_)
        )
    }
    /// Returns `true` if the error kind is `ListAppVersionsErrorKind::InternalServerException`.
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListAppVersionsErrorKind::InternalServerException(_)
        )
    }
    /// Returns `true` if the error kind is `ListAppVersionsErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListAppVersionsErrorKind::ResourceNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `ListAppVersionsErrorKind::ValidationException`.
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self.kind, ListAppVersionsErrorKind::ValidationException(_))
    }
}
impl std::error::Error for ListAppVersionsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListAppVersionsErrorKind::AccessDeniedException(_inner) => Some(_inner),
            ListAppVersionsErrorKind::InternalServerException(_inner) => Some(_inner),
            ListAppVersionsErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            ListAppVersionsErrorKind::ValidationException(_inner) => Some(_inner),
            ListAppVersionsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `ListRecommendationTemplates` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListRecommendationTemplatesError {
    /// Kind of error that occurred.
    pub kind: ListRecommendationTemplatesErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `ListRecommendationTemplates` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListRecommendationTemplatesErrorKind {
    /// <p>You don't have permissions to perform the requested operation. The user or role that is
    /// making the request must have at least one IAM permissions policy attached that grants the
    /// required permissions.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>This exception occurs when there is an internal failure in the AWS Resilience Hub
    /// service.</p>
    InternalServerException(crate::error::InternalServerException),
    /// <p>The limit on the number of requests per second was exceeded.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>Indicates that a request was not valid.</p>
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListRecommendationTemplatesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListRecommendationTemplatesErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            ListRecommendationTemplatesErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            ListRecommendationTemplatesErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            ListRecommendationTemplatesErrorKind::ValidationException(_inner) => _inner.fmt(f),
            ListRecommendationTemplatesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ListRecommendationTemplatesError {
    fn code(&self) -> Option<&str> {
        ListRecommendationTemplatesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListRecommendationTemplatesError {
    /// Creates a new `ListRecommendationTemplatesError`.
    pub fn new(kind: ListRecommendationTemplatesErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `ListRecommendationTemplatesError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListRecommendationTemplatesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `ListRecommendationTemplatesError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListRecommendationTemplatesErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `ListRecommendationTemplatesErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListRecommendationTemplatesErrorKind::AccessDeniedException(_)
        )
    }
    /// Returns `true` if the error kind is `ListRecommendationTemplatesErrorKind::InternalServerException`.
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListRecommendationTemplatesErrorKind::InternalServerException(_)
        )
    }
    /// Returns `true` if the error kind is `ListRecommendationTemplatesErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListRecommendationTemplatesErrorKind::ThrottlingException(_)
        )
    }
    /// Returns `true` if the error kind is `ListRecommendationTemplatesErrorKind::ValidationException`.
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListRecommendationTemplatesErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for ListRecommendationTemplatesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListRecommendationTemplatesErrorKind::AccessDeniedException(_inner) => Some(_inner),
            ListRecommendationTemplatesErrorKind::InternalServerException(_inner) => Some(_inner),
            ListRecommendationTemplatesErrorKind::ThrottlingException(_inner) => Some(_inner),
            ListRecommendationTemplatesErrorKind::ValidationException(_inner) => Some(_inner),
            ListRecommendationTemplatesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `ListResiliencyPolicies` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListResiliencyPoliciesError {
    /// Kind of error that occurred.
    pub kind: ListResiliencyPoliciesErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `ListResiliencyPolicies` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListResiliencyPoliciesErrorKind {
    /// <p>You don't have permissions to perform the requested operation. The user or role that is
    /// making the request must have at least one IAM permissions policy attached that grants the
    /// required permissions.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>This exception occurs when there is an internal failure in the AWS Resilience Hub
    /// service.</p>
    InternalServerException(crate::error::InternalServerException),
    /// <p>The specified resource could not be found.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>The limit on the number of requests per second was exceeded.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>Indicates that a request was not valid.</p>
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListResiliencyPoliciesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListResiliencyPoliciesErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            ListResiliencyPoliciesErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            ListResiliencyPoliciesErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            ListResiliencyPoliciesErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            ListResiliencyPoliciesErrorKind::ValidationException(_inner) => _inner.fmt(f),
            ListResiliencyPoliciesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ListResiliencyPoliciesError {
    fn code(&self) -> Option<&str> {
        ListResiliencyPoliciesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListResiliencyPoliciesError {
    /// Creates a new `ListResiliencyPoliciesError`.
    pub fn new(kind: ListResiliencyPoliciesErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `ListResiliencyPoliciesError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListResiliencyPoliciesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `ListResiliencyPoliciesError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListResiliencyPoliciesErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `ListResiliencyPoliciesErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListResiliencyPoliciesErrorKind::AccessDeniedException(_)
        )
    }
    /// Returns `true` if the error kind is `ListResiliencyPoliciesErrorKind::InternalServerException`.
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListResiliencyPoliciesErrorKind::InternalServerException(_)
        )
    }
    /// Returns `true` if the error kind is `ListResiliencyPoliciesErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListResiliencyPoliciesErrorKind::ResourceNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `ListResiliencyPoliciesErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListResiliencyPoliciesErrorKind::ThrottlingException(_)
        )
    }
    /// Returns `true` if the error kind is `ListResiliencyPoliciesErrorKind::ValidationException`.
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListResiliencyPoliciesErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for ListResiliencyPoliciesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListResiliencyPoliciesErrorKind::AccessDeniedException(_inner) => Some(_inner),
            ListResiliencyPoliciesErrorKind::InternalServerException(_inner) => Some(_inner),
            ListResiliencyPoliciesErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            ListResiliencyPoliciesErrorKind::ThrottlingException(_inner) => Some(_inner),
            ListResiliencyPoliciesErrorKind::ValidationException(_inner) => Some(_inner),
            ListResiliencyPoliciesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `ListSopRecommendations` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListSopRecommendationsError {
    /// Kind of error that occurred.
    pub kind: ListSopRecommendationsErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `ListSopRecommendations` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListSopRecommendationsErrorKind {
    /// <p>You don't have permissions to perform the requested operation. The user or role that is
    /// making the request must have at least one IAM permissions policy attached that grants the
    /// required permissions.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>Occurs when a conflict with a previous successful write is detected. This generally occurs
    /// when the previous write did not have time to propagate to the host serving the current
    /// request. A retry (with appropriate backoff logic) is the recommended response to this
    /// exception.</p>
    ConflictException(crate::error::ConflictException),
    /// <p>This exception occurs when there is an internal failure in the AWS Resilience Hub
    /// service.</p>
    InternalServerException(crate::error::InternalServerException),
    /// <p>The specified resource could not be found.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>The limit on the number of requests per second was exceeded.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>Indicates that a request was not valid.</p>
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListSopRecommendationsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListSopRecommendationsErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            ListSopRecommendationsErrorKind::ConflictException(_inner) => _inner.fmt(f),
            ListSopRecommendationsErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            ListSopRecommendationsErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            ListSopRecommendationsErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            ListSopRecommendationsErrorKind::ValidationException(_inner) => _inner.fmt(f),
            ListSopRecommendationsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ListSopRecommendationsError {
    fn code(&self) -> Option<&str> {
        ListSopRecommendationsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListSopRecommendationsError {
    /// Creates a new `ListSopRecommendationsError`.
    pub fn new(kind: ListSopRecommendationsErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `ListSopRecommendationsError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListSopRecommendationsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `ListSopRecommendationsError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListSopRecommendationsErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `ListSopRecommendationsErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListSopRecommendationsErrorKind::AccessDeniedException(_)
        )
    }
    /// Returns `true` if the error kind is `ListSopRecommendationsErrorKind::ConflictException`.
    pub fn is_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListSopRecommendationsErrorKind::ConflictException(_)
        )
    }
    /// Returns `true` if the error kind is `ListSopRecommendationsErrorKind::InternalServerException`.
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListSopRecommendationsErrorKind::InternalServerException(_)
        )
    }
    /// Returns `true` if the error kind is `ListSopRecommendationsErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListSopRecommendationsErrorKind::ResourceNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `ListSopRecommendationsErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListSopRecommendationsErrorKind::ThrottlingException(_)
        )
    }
    /// Returns `true` if the error kind is `ListSopRecommendationsErrorKind::ValidationException`.
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListSopRecommendationsErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for ListSopRecommendationsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListSopRecommendationsErrorKind::AccessDeniedException(_inner) => Some(_inner),
            ListSopRecommendationsErrorKind::ConflictException(_inner) => Some(_inner),
            ListSopRecommendationsErrorKind::InternalServerException(_inner) => Some(_inner),
            ListSopRecommendationsErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            ListSopRecommendationsErrorKind::ThrottlingException(_inner) => Some(_inner),
            ListSopRecommendationsErrorKind::ValidationException(_inner) => Some(_inner),
            ListSopRecommendationsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `ListSuggestedResiliencyPolicies` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListSuggestedResiliencyPoliciesError {
    /// Kind of error that occurred.
    pub kind: ListSuggestedResiliencyPoliciesErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `ListSuggestedResiliencyPolicies` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListSuggestedResiliencyPoliciesErrorKind {
    /// <p>You don't have permissions to perform the requested operation. The user or role that is
    /// making the request must have at least one IAM permissions policy attached that grants the
    /// required permissions.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>This exception occurs when there is an internal failure in the AWS Resilience Hub
    /// service.</p>
    InternalServerException(crate::error::InternalServerException),
    /// <p>The specified resource could not be found.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>The limit on the number of requests per second was exceeded.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>Indicates that a request was not valid.</p>
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListSuggestedResiliencyPoliciesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListSuggestedResiliencyPoliciesErrorKind::AccessDeniedException(_inner) => {
                _inner.fmt(f)
            }
            ListSuggestedResiliencyPoliciesErrorKind::InternalServerException(_inner) => {
                _inner.fmt(f)
            }
            ListSuggestedResiliencyPoliciesErrorKind::ResourceNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            ListSuggestedResiliencyPoliciesErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            ListSuggestedResiliencyPoliciesErrorKind::ValidationException(_inner) => _inner.fmt(f),
            ListSuggestedResiliencyPoliciesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ListSuggestedResiliencyPoliciesError {
    fn code(&self) -> Option<&str> {
        ListSuggestedResiliencyPoliciesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListSuggestedResiliencyPoliciesError {
    /// Creates a new `ListSuggestedResiliencyPoliciesError`.
    pub fn new(
        kind: ListSuggestedResiliencyPoliciesErrorKind,
        meta: aws_smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    /// Creates the `ListSuggestedResiliencyPoliciesError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListSuggestedResiliencyPoliciesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `ListSuggestedResiliencyPoliciesError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListSuggestedResiliencyPoliciesErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `ListSuggestedResiliencyPoliciesErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListSuggestedResiliencyPoliciesErrorKind::AccessDeniedException(_)
        )
    }
    /// Returns `true` if the error kind is `ListSuggestedResiliencyPoliciesErrorKind::InternalServerException`.
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListSuggestedResiliencyPoliciesErrorKind::InternalServerException(_)
        )
    }
    /// Returns `true` if the error kind is `ListSuggestedResiliencyPoliciesErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListSuggestedResiliencyPoliciesErrorKind::ResourceNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `ListSuggestedResiliencyPoliciesErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListSuggestedResiliencyPoliciesErrorKind::ThrottlingException(_)
        )
    }
    /// Returns `true` if the error kind is `ListSuggestedResiliencyPoliciesErrorKind::ValidationException`.
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListSuggestedResiliencyPoliciesErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for ListSuggestedResiliencyPoliciesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListSuggestedResiliencyPoliciesErrorKind::AccessDeniedException(_inner) => Some(_inner),
            ListSuggestedResiliencyPoliciesErrorKind::InternalServerException(_inner) => {
                Some(_inner)
            }
            ListSuggestedResiliencyPoliciesErrorKind::ResourceNotFoundException(_inner) => {
                Some(_inner)
            }
            ListSuggestedResiliencyPoliciesErrorKind::ThrottlingException(_inner) => Some(_inner),
            ListSuggestedResiliencyPoliciesErrorKind::ValidationException(_inner) => Some(_inner),
            ListSuggestedResiliencyPoliciesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `ListTagsForResource` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListTagsForResourceError {
    /// Kind of error that occurred.
    pub kind: ListTagsForResourceErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `ListTagsForResource` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListTagsForResourceErrorKind {
    /// <p>You don't have permissions to perform the requested operation. The user or role that is
    /// making the request must have at least one IAM permissions policy attached that grants the
    /// required permissions.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>This exception occurs when there is an internal failure in the AWS Resilience Hub
    /// service.</p>
    InternalServerException(crate::error::InternalServerException),
    /// <p>The specified resource could not be found.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>The limit on the number of requests per second was exceeded.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>Indicates that a request was not valid.</p>
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListTagsForResourceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListTagsForResourceErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            ListTagsForResourceErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            ListTagsForResourceErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            ListTagsForResourceErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            ListTagsForResourceErrorKind::ValidationException(_inner) => _inner.fmt(f),
            ListTagsForResourceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ListTagsForResourceError {
    fn code(&self) -> Option<&str> {
        ListTagsForResourceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListTagsForResourceError {
    /// Creates a new `ListTagsForResourceError`.
    pub fn new(kind: ListTagsForResourceErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `ListTagsForResourceError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListTagsForResourceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `ListTagsForResourceError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListTagsForResourceErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `ListTagsForResourceErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListTagsForResourceErrorKind::AccessDeniedException(_)
        )
    }
    /// Returns `true` if the error kind is `ListTagsForResourceErrorKind::InternalServerException`.
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListTagsForResourceErrorKind::InternalServerException(_)
        )
    }
    /// Returns `true` if the error kind is `ListTagsForResourceErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListTagsForResourceErrorKind::ResourceNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `ListTagsForResourceErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListTagsForResourceErrorKind::ThrottlingException(_)
        )
    }
    /// Returns `true` if the error kind is `ListTagsForResourceErrorKind::ValidationException`.
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListTagsForResourceErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for ListTagsForResourceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListTagsForResourceErrorKind::AccessDeniedException(_inner) => Some(_inner),
            ListTagsForResourceErrorKind::InternalServerException(_inner) => Some(_inner),
            ListTagsForResourceErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            ListTagsForResourceErrorKind::ThrottlingException(_inner) => Some(_inner),
            ListTagsForResourceErrorKind::ValidationException(_inner) => Some(_inner),
            ListTagsForResourceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `ListTestRecommendations` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListTestRecommendationsError {
    /// Kind of error that occurred.
    pub kind: ListTestRecommendationsErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `ListTestRecommendations` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListTestRecommendationsErrorKind {
    /// <p>You don't have permissions to perform the requested operation. The user or role that is
    /// making the request must have at least one IAM permissions policy attached that grants the
    /// required permissions.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>Occurs when a conflict with a previous successful write is detected. This generally occurs
    /// when the previous write did not have time to propagate to the host serving the current
    /// request. A retry (with appropriate backoff logic) is the recommended response to this
    /// exception.</p>
    ConflictException(crate::error::ConflictException),
    /// <p>This exception occurs when there is an internal failure in the AWS Resilience Hub
    /// service.</p>
    InternalServerException(crate::error::InternalServerException),
    /// <p>The specified resource could not be found.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>The limit on the number of requests per second was exceeded.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>Indicates that a request was not valid.</p>
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListTestRecommendationsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListTestRecommendationsErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            ListTestRecommendationsErrorKind::ConflictException(_inner) => _inner.fmt(f),
            ListTestRecommendationsErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            ListTestRecommendationsErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            ListTestRecommendationsErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            ListTestRecommendationsErrorKind::ValidationException(_inner) => _inner.fmt(f),
            ListTestRecommendationsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ListTestRecommendationsError {
    fn code(&self) -> Option<&str> {
        ListTestRecommendationsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListTestRecommendationsError {
    /// Creates a new `ListTestRecommendationsError`.
    pub fn new(kind: ListTestRecommendationsErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `ListTestRecommendationsError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListTestRecommendationsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `ListTestRecommendationsError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListTestRecommendationsErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `ListTestRecommendationsErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListTestRecommendationsErrorKind::AccessDeniedException(_)
        )
    }
    /// Returns `true` if the error kind is `ListTestRecommendationsErrorKind::ConflictException`.
    pub fn is_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListTestRecommendationsErrorKind::ConflictException(_)
        )
    }
    /// Returns `true` if the error kind is `ListTestRecommendationsErrorKind::InternalServerException`.
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListTestRecommendationsErrorKind::InternalServerException(_)
        )
    }
    /// Returns `true` if the error kind is `ListTestRecommendationsErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListTestRecommendationsErrorKind::ResourceNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `ListTestRecommendationsErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListTestRecommendationsErrorKind::ThrottlingException(_)
        )
    }
    /// Returns `true` if the error kind is `ListTestRecommendationsErrorKind::ValidationException`.
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListTestRecommendationsErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for ListTestRecommendationsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListTestRecommendationsErrorKind::AccessDeniedException(_inner) => Some(_inner),
            ListTestRecommendationsErrorKind::ConflictException(_inner) => Some(_inner),
            ListTestRecommendationsErrorKind::InternalServerException(_inner) => Some(_inner),
            ListTestRecommendationsErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            ListTestRecommendationsErrorKind::ThrottlingException(_inner) => Some(_inner),
            ListTestRecommendationsErrorKind::ValidationException(_inner) => Some(_inner),
            ListTestRecommendationsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `ListUnsupportedAppVersionResources` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListUnsupportedAppVersionResourcesError {
    /// Kind of error that occurred.
    pub kind: ListUnsupportedAppVersionResourcesErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `ListUnsupportedAppVersionResources` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListUnsupportedAppVersionResourcesErrorKind {
    /// <p>You don't have permissions to perform the requested operation. The user or role that is
    /// making the request must have at least one IAM permissions policy attached that grants the
    /// required permissions.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>Occurs when a conflict with a previous successful write is detected. This generally occurs
    /// when the previous write did not have time to propagate to the host serving the current
    /// request. A retry (with appropriate backoff logic) is the recommended response to this
    /// exception.</p>
    ConflictException(crate::error::ConflictException),
    /// <p>This exception occurs when there is an internal failure in the AWS Resilience Hub
    /// service.</p>
    InternalServerException(crate::error::InternalServerException),
    /// <p>The specified resource could not be found.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>The limit on the number of requests per second was exceeded.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>Indicates that a request was not valid.</p>
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListUnsupportedAppVersionResourcesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListUnsupportedAppVersionResourcesErrorKind::AccessDeniedException(_inner) => {
                _inner.fmt(f)
            }
            ListUnsupportedAppVersionResourcesErrorKind::ConflictException(_inner) => _inner.fmt(f),
            ListUnsupportedAppVersionResourcesErrorKind::InternalServerException(_inner) => {
                _inner.fmt(f)
            }
            ListUnsupportedAppVersionResourcesErrorKind::ResourceNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            ListUnsupportedAppVersionResourcesErrorKind::ThrottlingException(_inner) => {
                _inner.fmt(f)
            }
            ListUnsupportedAppVersionResourcesErrorKind::ValidationException(_inner) => {
                _inner.fmt(f)
            }
            ListUnsupportedAppVersionResourcesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ListUnsupportedAppVersionResourcesError {
    fn code(&self) -> Option<&str> {
        ListUnsupportedAppVersionResourcesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListUnsupportedAppVersionResourcesError {
    /// Creates a new `ListUnsupportedAppVersionResourcesError`.
    pub fn new(
        kind: ListUnsupportedAppVersionResourcesErrorKind,
        meta: aws_smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    /// Creates the `ListUnsupportedAppVersionResourcesError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListUnsupportedAppVersionResourcesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `ListUnsupportedAppVersionResourcesError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListUnsupportedAppVersionResourcesErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `ListUnsupportedAppVersionResourcesErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListUnsupportedAppVersionResourcesErrorKind::AccessDeniedException(_)
        )
    }
    /// Returns `true` if the error kind is `ListUnsupportedAppVersionResourcesErrorKind::ConflictException`.
    pub fn is_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListUnsupportedAppVersionResourcesErrorKind::ConflictException(_)
        )
    }
    /// Returns `true` if the error kind is `ListUnsupportedAppVersionResourcesErrorKind::InternalServerException`.
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListUnsupportedAppVersionResourcesErrorKind::InternalServerException(_)
        )
    }
    /// Returns `true` if the error kind is `ListUnsupportedAppVersionResourcesErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListUnsupportedAppVersionResourcesErrorKind::ResourceNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `ListUnsupportedAppVersionResourcesErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListUnsupportedAppVersionResourcesErrorKind::ThrottlingException(_)
        )
    }
    /// Returns `true` if the error kind is `ListUnsupportedAppVersionResourcesErrorKind::ValidationException`.
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListUnsupportedAppVersionResourcesErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for ListUnsupportedAppVersionResourcesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListUnsupportedAppVersionResourcesErrorKind::AccessDeniedException(_inner) => {
                Some(_inner)
            }
            ListUnsupportedAppVersionResourcesErrorKind::ConflictException(_inner) => Some(_inner),
            ListUnsupportedAppVersionResourcesErrorKind::InternalServerException(_inner) => {
                Some(_inner)
            }
            ListUnsupportedAppVersionResourcesErrorKind::ResourceNotFoundException(_inner) => {
                Some(_inner)
            }
            ListUnsupportedAppVersionResourcesErrorKind::ThrottlingException(_inner) => {
                Some(_inner)
            }
            ListUnsupportedAppVersionResourcesErrorKind::ValidationException(_inner) => {
                Some(_inner)
            }
            ListUnsupportedAppVersionResourcesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `PublishAppVersion` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct PublishAppVersionError {
    /// Kind of error that occurred.
    pub kind: PublishAppVersionErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `PublishAppVersion` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum PublishAppVersionErrorKind {
    /// <p>You don't have permissions to perform the requested operation. The user or role that is
    /// making the request must have at least one IAM permissions policy attached that grants the
    /// required permissions.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>Occurs when a conflict with a previous successful write is detected. This generally occurs
    /// when the previous write did not have time to propagate to the host serving the current
    /// request. A retry (with appropriate backoff logic) is the recommended response to this
    /// exception.</p>
    ConflictException(crate::error::ConflictException),
    /// <p>This exception occurs when there is an internal failure in the AWS Resilience Hub
    /// service.</p>
    InternalServerException(crate::error::InternalServerException),
    /// <p>The specified resource could not be found.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>The limit on the number of requests per second was exceeded.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>Indicates that a request was not valid.</p>
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for PublishAppVersionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            PublishAppVersionErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            PublishAppVersionErrorKind::ConflictException(_inner) => _inner.fmt(f),
            PublishAppVersionErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            PublishAppVersionErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            PublishAppVersionErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            PublishAppVersionErrorKind::ValidationException(_inner) => _inner.fmt(f),
            PublishAppVersionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for PublishAppVersionError {
    fn code(&self) -> Option<&str> {
        PublishAppVersionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl PublishAppVersionError {
    /// Creates a new `PublishAppVersionError`.
    pub fn new(kind: PublishAppVersionErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `PublishAppVersionError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: PublishAppVersionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `PublishAppVersionError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: PublishAppVersionErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `PublishAppVersionErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            PublishAppVersionErrorKind::AccessDeniedException(_)
        )
    }
    /// Returns `true` if the error kind is `PublishAppVersionErrorKind::ConflictException`.
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, PublishAppVersionErrorKind::ConflictException(_))
    }
    /// Returns `true` if the error kind is `PublishAppVersionErrorKind::InternalServerException`.
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            PublishAppVersionErrorKind::InternalServerException(_)
        )
    }
    /// Returns `true` if the error kind is `PublishAppVersionErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            PublishAppVersionErrorKind::ResourceNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `PublishAppVersionErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            PublishAppVersionErrorKind::ThrottlingException(_)
        )
    }
    /// Returns `true` if the error kind is `PublishAppVersionErrorKind::ValidationException`.
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            PublishAppVersionErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for PublishAppVersionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            PublishAppVersionErrorKind::AccessDeniedException(_inner) => Some(_inner),
            PublishAppVersionErrorKind::ConflictException(_inner) => Some(_inner),
            PublishAppVersionErrorKind::InternalServerException(_inner) => Some(_inner),
            PublishAppVersionErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            PublishAppVersionErrorKind::ThrottlingException(_inner) => Some(_inner),
            PublishAppVersionErrorKind::ValidationException(_inner) => Some(_inner),
            PublishAppVersionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `PutDraftAppVersionTemplate` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct PutDraftAppVersionTemplateError {
    /// Kind of error that occurred.
    pub kind: PutDraftAppVersionTemplateErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `PutDraftAppVersionTemplate` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum PutDraftAppVersionTemplateErrorKind {
    /// <p>You don't have permissions to perform the requested operation. The user or role that is
    /// making the request must have at least one IAM permissions policy attached that grants the
    /// required permissions.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>Occurs when a conflict with a previous successful write is detected. This generally occurs
    /// when the previous write did not have time to propagate to the host serving the current
    /// request. A retry (with appropriate backoff logic) is the recommended response to this
    /// exception.</p>
    ConflictException(crate::error::ConflictException),
    /// <p>This exception occurs when there is an internal failure in the AWS Resilience Hub
    /// service.</p>
    InternalServerException(crate::error::InternalServerException),
    /// <p>The specified resource could not be found.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>The limit on the number of requests per second was exceeded.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>Indicates that a request was not valid.</p>
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for PutDraftAppVersionTemplateError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            PutDraftAppVersionTemplateErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            PutDraftAppVersionTemplateErrorKind::ConflictException(_inner) => _inner.fmt(f),
            PutDraftAppVersionTemplateErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            PutDraftAppVersionTemplateErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            PutDraftAppVersionTemplateErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            PutDraftAppVersionTemplateErrorKind::ValidationException(_inner) => _inner.fmt(f),
            PutDraftAppVersionTemplateErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for PutDraftAppVersionTemplateError {
    fn code(&self) -> Option<&str> {
        PutDraftAppVersionTemplateError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl PutDraftAppVersionTemplateError {
    /// Creates a new `PutDraftAppVersionTemplateError`.
    pub fn new(kind: PutDraftAppVersionTemplateErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `PutDraftAppVersionTemplateError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: PutDraftAppVersionTemplateErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `PutDraftAppVersionTemplateError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: PutDraftAppVersionTemplateErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `PutDraftAppVersionTemplateErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutDraftAppVersionTemplateErrorKind::AccessDeniedException(_)
        )
    }
    /// Returns `true` if the error kind is `PutDraftAppVersionTemplateErrorKind::ConflictException`.
    pub fn is_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutDraftAppVersionTemplateErrorKind::ConflictException(_)
        )
    }
    /// Returns `true` if the error kind is `PutDraftAppVersionTemplateErrorKind::InternalServerException`.
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutDraftAppVersionTemplateErrorKind::InternalServerException(_)
        )
    }
    /// Returns `true` if the error kind is `PutDraftAppVersionTemplateErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutDraftAppVersionTemplateErrorKind::ResourceNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `PutDraftAppVersionTemplateErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutDraftAppVersionTemplateErrorKind::ThrottlingException(_)
        )
    }
    /// Returns `true` if the error kind is `PutDraftAppVersionTemplateErrorKind::ValidationException`.
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutDraftAppVersionTemplateErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for PutDraftAppVersionTemplateError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            PutDraftAppVersionTemplateErrorKind::AccessDeniedException(_inner) => Some(_inner),
            PutDraftAppVersionTemplateErrorKind::ConflictException(_inner) => Some(_inner),
            PutDraftAppVersionTemplateErrorKind::InternalServerException(_inner) => Some(_inner),
            PutDraftAppVersionTemplateErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            PutDraftAppVersionTemplateErrorKind::ThrottlingException(_inner) => Some(_inner),
            PutDraftAppVersionTemplateErrorKind::ValidationException(_inner) => Some(_inner),
            PutDraftAppVersionTemplateErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `RemoveDraftAppVersionResourceMappings` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct RemoveDraftAppVersionResourceMappingsError {
    /// Kind of error that occurred.
    pub kind: RemoveDraftAppVersionResourceMappingsErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `RemoveDraftAppVersionResourceMappings` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum RemoveDraftAppVersionResourceMappingsErrorKind {
    /// <p>You don't have permissions to perform the requested operation. The user or role that is
    /// making the request must have at least one IAM permissions policy attached that grants the
    /// required permissions.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>Occurs when a conflict with a previous successful write is detected. This generally occurs
    /// when the previous write did not have time to propagate to the host serving the current
    /// request. A retry (with appropriate backoff logic) is the recommended response to this
    /// exception.</p>
    ConflictException(crate::error::ConflictException),
    /// <p>This exception occurs when there is an internal failure in the AWS Resilience Hub
    /// service.</p>
    InternalServerException(crate::error::InternalServerException),
    /// <p>The specified resource could not be found.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>The limit on the number of requests per second was exceeded.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>Indicates that a request was not valid.</p>
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for RemoveDraftAppVersionResourceMappingsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            RemoveDraftAppVersionResourceMappingsErrorKind::AccessDeniedException(_inner) => {
                _inner.fmt(f)
            }
            RemoveDraftAppVersionResourceMappingsErrorKind::ConflictException(_inner) => {
                _inner.fmt(f)
            }
            RemoveDraftAppVersionResourceMappingsErrorKind::InternalServerException(_inner) => {
                _inner.fmt(f)
            }
            RemoveDraftAppVersionResourceMappingsErrorKind::ResourceNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            RemoveDraftAppVersionResourceMappingsErrorKind::ThrottlingException(_inner) => {
                _inner.fmt(f)
            }
            RemoveDraftAppVersionResourceMappingsErrorKind::ValidationException(_inner) => {
                _inner.fmt(f)
            }
            RemoveDraftAppVersionResourceMappingsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for RemoveDraftAppVersionResourceMappingsError {
    fn code(&self) -> Option<&str> {
        RemoveDraftAppVersionResourceMappingsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl RemoveDraftAppVersionResourceMappingsError {
    /// Creates a new `RemoveDraftAppVersionResourceMappingsError`.
    pub fn new(
        kind: RemoveDraftAppVersionResourceMappingsErrorKind,
        meta: aws_smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    /// Creates the `RemoveDraftAppVersionResourceMappingsError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: RemoveDraftAppVersionResourceMappingsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `RemoveDraftAppVersionResourceMappingsError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: RemoveDraftAppVersionResourceMappingsErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `RemoveDraftAppVersionResourceMappingsErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            RemoveDraftAppVersionResourceMappingsErrorKind::AccessDeniedException(_)
        )
    }
    /// Returns `true` if the error kind is `RemoveDraftAppVersionResourceMappingsErrorKind::ConflictException`.
    pub fn is_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            RemoveDraftAppVersionResourceMappingsErrorKind::ConflictException(_)
        )
    }
    /// Returns `true` if the error kind is `RemoveDraftAppVersionResourceMappingsErrorKind::InternalServerException`.
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            RemoveDraftAppVersionResourceMappingsErrorKind::InternalServerException(_)
        )
    }
    /// Returns `true` if the error kind is `RemoveDraftAppVersionResourceMappingsErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            RemoveDraftAppVersionResourceMappingsErrorKind::ResourceNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `RemoveDraftAppVersionResourceMappingsErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            RemoveDraftAppVersionResourceMappingsErrorKind::ThrottlingException(_)
        )
    }
    /// Returns `true` if the error kind is `RemoveDraftAppVersionResourceMappingsErrorKind::ValidationException`.
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            RemoveDraftAppVersionResourceMappingsErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for RemoveDraftAppVersionResourceMappingsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            RemoveDraftAppVersionResourceMappingsErrorKind::AccessDeniedException(_inner) => {
                Some(_inner)
            }
            RemoveDraftAppVersionResourceMappingsErrorKind::ConflictException(_inner) => {
                Some(_inner)
            }
            RemoveDraftAppVersionResourceMappingsErrorKind::InternalServerException(_inner) => {
                Some(_inner)
            }
            RemoveDraftAppVersionResourceMappingsErrorKind::ResourceNotFoundException(_inner) => {
                Some(_inner)
            }
            RemoveDraftAppVersionResourceMappingsErrorKind::ThrottlingException(_inner) => {
                Some(_inner)
            }
            RemoveDraftAppVersionResourceMappingsErrorKind::ValidationException(_inner) => {
                Some(_inner)
            }
            RemoveDraftAppVersionResourceMappingsErrorKind::Unhandled(_inner) => {
                Some(_inner.as_ref())
            }
        }
    }
}

/// Error type for the `ResolveAppVersionResources` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ResolveAppVersionResourcesError {
    /// Kind of error that occurred.
    pub kind: ResolveAppVersionResourcesErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `ResolveAppVersionResources` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ResolveAppVersionResourcesErrorKind {
    /// <p>You don't have permissions to perform the requested operation. The user or role that is
    /// making the request must have at least one IAM permissions policy attached that grants the
    /// required permissions.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>Occurs when a conflict with a previous successful write is detected. This generally occurs
    /// when the previous write did not have time to propagate to the host serving the current
    /// request. A retry (with appropriate backoff logic) is the recommended response to this
    /// exception.</p>
    ConflictException(crate::error::ConflictException),
    /// <p>This exception occurs when there is an internal failure in the AWS Resilience Hub
    /// service.</p>
    InternalServerException(crate::error::InternalServerException),
    /// <p>The specified resource could not be found.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>The limit on the number of requests per second was exceeded.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>Indicates that a request was not valid.</p>
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ResolveAppVersionResourcesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ResolveAppVersionResourcesErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            ResolveAppVersionResourcesErrorKind::ConflictException(_inner) => _inner.fmt(f),
            ResolveAppVersionResourcesErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            ResolveAppVersionResourcesErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            ResolveAppVersionResourcesErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            ResolveAppVersionResourcesErrorKind::ValidationException(_inner) => _inner.fmt(f),
            ResolveAppVersionResourcesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ResolveAppVersionResourcesError {
    fn code(&self) -> Option<&str> {
        ResolveAppVersionResourcesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ResolveAppVersionResourcesError {
    /// Creates a new `ResolveAppVersionResourcesError`.
    pub fn new(kind: ResolveAppVersionResourcesErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `ResolveAppVersionResourcesError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ResolveAppVersionResourcesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `ResolveAppVersionResourcesError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ResolveAppVersionResourcesErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `ResolveAppVersionResourcesErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            ResolveAppVersionResourcesErrorKind::AccessDeniedException(_)
        )
    }
    /// Returns `true` if the error kind is `ResolveAppVersionResourcesErrorKind::ConflictException`.
    pub fn is_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            ResolveAppVersionResourcesErrorKind::ConflictException(_)
        )
    }
    /// Returns `true` if the error kind is `ResolveAppVersionResourcesErrorKind::InternalServerException`.
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            ResolveAppVersionResourcesErrorKind::InternalServerException(_)
        )
    }
    /// Returns `true` if the error kind is `ResolveAppVersionResourcesErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            ResolveAppVersionResourcesErrorKind::ResourceNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `ResolveAppVersionResourcesErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            ResolveAppVersionResourcesErrorKind::ThrottlingException(_)
        )
    }
    /// Returns `true` if the error kind is `ResolveAppVersionResourcesErrorKind::ValidationException`.
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            ResolveAppVersionResourcesErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for ResolveAppVersionResourcesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ResolveAppVersionResourcesErrorKind::AccessDeniedException(_inner) => Some(_inner),
            ResolveAppVersionResourcesErrorKind::ConflictException(_inner) => Some(_inner),
            ResolveAppVersionResourcesErrorKind::InternalServerException(_inner) => Some(_inner),
            ResolveAppVersionResourcesErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            ResolveAppVersionResourcesErrorKind::ThrottlingException(_inner) => Some(_inner),
            ResolveAppVersionResourcesErrorKind::ValidationException(_inner) => Some(_inner),
            ResolveAppVersionResourcesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `StartAppAssessment` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct StartAppAssessmentError {
    /// Kind of error that occurred.
    pub kind: StartAppAssessmentErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `StartAppAssessment` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum StartAppAssessmentErrorKind {
    /// <p>You don't have permissions to perform the requested operation. The user or role that is
    /// making the request must have at least one IAM permissions policy attached that grants the
    /// required permissions.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>Occurs when a conflict with a previous successful write is detected. This generally occurs
    /// when the previous write did not have time to propagate to the host serving the current
    /// request. A retry (with appropriate backoff logic) is the recommended response to this
    /// exception.</p>
    ConflictException(crate::error::ConflictException),
    /// <p>This exception occurs when there is an internal failure in the AWS Resilience Hub
    /// service.</p>
    InternalServerException(crate::error::InternalServerException),
    /// <p>The specified resource could not be found.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>You have exceeded your service quota. To perform the requested action, remove some of the
    /// relevant resources, or use Service Quotas to request a service quota increase.</p>
    ServiceQuotaExceededException(crate::error::ServiceQuotaExceededException),
    /// <p>The limit on the number of requests per second was exceeded.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>Indicates that a request was not valid.</p>
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for StartAppAssessmentError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            StartAppAssessmentErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            StartAppAssessmentErrorKind::ConflictException(_inner) => _inner.fmt(f),
            StartAppAssessmentErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            StartAppAssessmentErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            StartAppAssessmentErrorKind::ServiceQuotaExceededException(_inner) => _inner.fmt(f),
            StartAppAssessmentErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            StartAppAssessmentErrorKind::ValidationException(_inner) => _inner.fmt(f),
            StartAppAssessmentErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for StartAppAssessmentError {
    fn code(&self) -> Option<&str> {
        StartAppAssessmentError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl StartAppAssessmentError {
    /// Creates a new `StartAppAssessmentError`.
    pub fn new(kind: StartAppAssessmentErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `StartAppAssessmentError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: StartAppAssessmentErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `StartAppAssessmentError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: StartAppAssessmentErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `StartAppAssessmentErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartAppAssessmentErrorKind::AccessDeniedException(_)
        )
    }
    /// Returns `true` if the error kind is `StartAppAssessmentErrorKind::ConflictException`.
    pub fn is_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartAppAssessmentErrorKind::ConflictException(_)
        )
    }
    /// Returns `true` if the error kind is `StartAppAssessmentErrorKind::InternalServerException`.
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartAppAssessmentErrorKind::InternalServerException(_)
        )
    }
    /// Returns `true` if the error kind is `StartAppAssessmentErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartAppAssessmentErrorKind::ResourceNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `StartAppAssessmentErrorKind::ServiceQuotaExceededException`.
    pub fn is_service_quota_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartAppAssessmentErrorKind::ServiceQuotaExceededException(_)
        )
    }
    /// Returns `true` if the error kind is `StartAppAssessmentErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartAppAssessmentErrorKind::ThrottlingException(_)
        )
    }
    /// Returns `true` if the error kind is `StartAppAssessmentErrorKind::ValidationException`.
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartAppAssessmentErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for StartAppAssessmentError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            StartAppAssessmentErrorKind::AccessDeniedException(_inner) => Some(_inner),
            StartAppAssessmentErrorKind::ConflictException(_inner) => Some(_inner),
            StartAppAssessmentErrorKind::InternalServerException(_inner) => Some(_inner),
            StartAppAssessmentErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            StartAppAssessmentErrorKind::ServiceQuotaExceededException(_inner) => Some(_inner),
            StartAppAssessmentErrorKind::ThrottlingException(_inner) => Some(_inner),
            StartAppAssessmentErrorKind::ValidationException(_inner) => Some(_inner),
            StartAppAssessmentErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `TagResource` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct TagResourceError {
    /// Kind of error that occurred.
    pub kind: TagResourceErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `TagResource` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum TagResourceErrorKind {
    /// <p>You don't have permissions to perform the requested operation. The user or role that is
    /// making the request must have at least one IAM permissions policy attached that grants the
    /// required permissions.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>This exception occurs when there is an internal failure in the AWS Resilience Hub
    /// service.</p>
    InternalServerException(crate::error::InternalServerException),
    /// <p>The specified resource could not be found.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>The limit on the number of requests per second was exceeded.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>Indicates that a request was not valid.</p>
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for TagResourceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            TagResourceErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            TagResourceErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            TagResourceErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            TagResourceErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            TagResourceErrorKind::ValidationException(_inner) => _inner.fmt(f),
            TagResourceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for TagResourceError {
    fn code(&self) -> Option<&str> {
        TagResourceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl TagResourceError {
    /// Creates a new `TagResourceError`.
    pub fn new(kind: TagResourceErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `TagResourceError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: TagResourceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `TagResourceError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: TagResourceErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `TagResourceErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, TagResourceErrorKind::AccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `TagResourceErrorKind::InternalServerException`.
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(&self.kind, TagResourceErrorKind::InternalServerException(_))
    }
    /// Returns `true` if the error kind is `TagResourceErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            TagResourceErrorKind::ResourceNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `TagResourceErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, TagResourceErrorKind::ThrottlingException(_))
    }
    /// Returns `true` if the error kind is `TagResourceErrorKind::ValidationException`.
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self.kind, TagResourceErrorKind::ValidationException(_))
    }
}
impl std::error::Error for TagResourceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            TagResourceErrorKind::AccessDeniedException(_inner) => Some(_inner),
            TagResourceErrorKind::InternalServerException(_inner) => Some(_inner),
            TagResourceErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            TagResourceErrorKind::ThrottlingException(_inner) => Some(_inner),
            TagResourceErrorKind::ValidationException(_inner) => Some(_inner),
            TagResourceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `UntagResource` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UntagResourceError {
    /// Kind of error that occurred.
    pub kind: UntagResourceErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `UntagResource` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UntagResourceErrorKind {
    /// <p>You don't have permissions to perform the requested operation. The user or role that is
    /// making the request must have at least one IAM permissions policy attached that grants the
    /// required permissions.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>This exception occurs when there is an internal failure in the AWS Resilience Hub
    /// service.</p>
    InternalServerException(crate::error::InternalServerException),
    /// <p>The specified resource could not be found.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>The limit on the number of requests per second was exceeded.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>Indicates that a request was not valid.</p>
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UntagResourceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UntagResourceErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            UntagResourceErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            UntagResourceErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            UntagResourceErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            UntagResourceErrorKind::ValidationException(_inner) => _inner.fmt(f),
            UntagResourceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for UntagResourceError {
    fn code(&self) -> Option<&str> {
        UntagResourceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl UntagResourceError {
    /// Creates a new `UntagResourceError`.
    pub fn new(kind: UntagResourceErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `UntagResourceError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UntagResourceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `UntagResourceError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UntagResourceErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `UntagResourceErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, UntagResourceErrorKind::AccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `UntagResourceErrorKind::InternalServerException`.
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            UntagResourceErrorKind::InternalServerException(_)
        )
    }
    /// Returns `true` if the error kind is `UntagResourceErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UntagResourceErrorKind::ResourceNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `UntagResourceErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, UntagResourceErrorKind::ThrottlingException(_))
    }
    /// Returns `true` if the error kind is `UntagResourceErrorKind::ValidationException`.
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self.kind, UntagResourceErrorKind::ValidationException(_))
    }
}
impl std::error::Error for UntagResourceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UntagResourceErrorKind::AccessDeniedException(_inner) => Some(_inner),
            UntagResourceErrorKind::InternalServerException(_inner) => Some(_inner),
            UntagResourceErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            UntagResourceErrorKind::ThrottlingException(_inner) => Some(_inner),
            UntagResourceErrorKind::ValidationException(_inner) => Some(_inner),
            UntagResourceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `UpdateApp` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateAppError {
    /// Kind of error that occurred.
    pub kind: UpdateAppErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `UpdateApp` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateAppErrorKind {
    /// <p>You don't have permissions to perform the requested operation. The user or role that is
    /// making the request must have at least one IAM permissions policy attached that grants the
    /// required permissions.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>Occurs when a conflict with a previous successful write is detected. This generally occurs
    /// when the previous write did not have time to propagate to the host serving the current
    /// request. A retry (with appropriate backoff logic) is the recommended response to this
    /// exception.</p>
    ConflictException(crate::error::ConflictException),
    /// <p>This exception occurs when there is an internal failure in the AWS Resilience Hub
    /// service.</p>
    InternalServerException(crate::error::InternalServerException),
    /// <p>The specified resource could not be found.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>The limit on the number of requests per second was exceeded.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>Indicates that a request was not valid.</p>
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateAppError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateAppErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            UpdateAppErrorKind::ConflictException(_inner) => _inner.fmt(f),
            UpdateAppErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            UpdateAppErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            UpdateAppErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            UpdateAppErrorKind::ValidationException(_inner) => _inner.fmt(f),
            UpdateAppErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for UpdateAppError {
    fn code(&self) -> Option<&str> {
        UpdateAppError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateAppError {
    /// Creates a new `UpdateAppError`.
    pub fn new(kind: UpdateAppErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `UpdateAppError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateAppErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `UpdateAppError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateAppErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `UpdateAppErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, UpdateAppErrorKind::AccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `UpdateAppErrorKind::ConflictException`.
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, UpdateAppErrorKind::ConflictException(_))
    }
    /// Returns `true` if the error kind is `UpdateAppErrorKind::InternalServerException`.
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(&self.kind, UpdateAppErrorKind::InternalServerException(_))
    }
    /// Returns `true` if the error kind is `UpdateAppErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(&self.kind, UpdateAppErrorKind::ResourceNotFoundException(_))
    }
    /// Returns `true` if the error kind is `UpdateAppErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, UpdateAppErrorKind::ThrottlingException(_))
    }
    /// Returns `true` if the error kind is `UpdateAppErrorKind::ValidationException`.
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self.kind, UpdateAppErrorKind::ValidationException(_))
    }
}
impl std::error::Error for UpdateAppError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateAppErrorKind::AccessDeniedException(_inner) => Some(_inner),
            UpdateAppErrorKind::ConflictException(_inner) => Some(_inner),
            UpdateAppErrorKind::InternalServerException(_inner) => Some(_inner),
            UpdateAppErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            UpdateAppErrorKind::ThrottlingException(_inner) => Some(_inner),
            UpdateAppErrorKind::ValidationException(_inner) => Some(_inner),
            UpdateAppErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `UpdateResiliencyPolicy` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateResiliencyPolicyError {
    /// Kind of error that occurred.
    pub kind: UpdateResiliencyPolicyErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `UpdateResiliencyPolicy` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateResiliencyPolicyErrorKind {
    /// <p>You don't have permissions to perform the requested operation. The user or role that is
    /// making the request must have at least one IAM permissions policy attached that grants the
    /// required permissions.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>Occurs when a conflict with a previous successful write is detected. This generally occurs
    /// when the previous write did not have time to propagate to the host serving the current
    /// request. A retry (with appropriate backoff logic) is the recommended response to this
    /// exception.</p>
    ConflictException(crate::error::ConflictException),
    /// <p>This exception occurs when there is an internal failure in the AWS Resilience Hub
    /// service.</p>
    InternalServerException(crate::error::InternalServerException),
    /// <p>The specified resource could not be found.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>The limit on the number of requests per second was exceeded.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>Indicates that a request was not valid.</p>
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateResiliencyPolicyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateResiliencyPolicyErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            UpdateResiliencyPolicyErrorKind::ConflictException(_inner) => _inner.fmt(f),
            UpdateResiliencyPolicyErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            UpdateResiliencyPolicyErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            UpdateResiliencyPolicyErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            UpdateResiliencyPolicyErrorKind::ValidationException(_inner) => _inner.fmt(f),
            UpdateResiliencyPolicyErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for UpdateResiliencyPolicyError {
    fn code(&self) -> Option<&str> {
        UpdateResiliencyPolicyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateResiliencyPolicyError {
    /// Creates a new `UpdateResiliencyPolicyError`.
    pub fn new(kind: UpdateResiliencyPolicyErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `UpdateResiliencyPolicyError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateResiliencyPolicyErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `UpdateResiliencyPolicyError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateResiliencyPolicyErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `UpdateResiliencyPolicyErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateResiliencyPolicyErrorKind::AccessDeniedException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdateResiliencyPolicyErrorKind::ConflictException`.
    pub fn is_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateResiliencyPolicyErrorKind::ConflictException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdateResiliencyPolicyErrorKind::InternalServerException`.
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateResiliencyPolicyErrorKind::InternalServerException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdateResiliencyPolicyErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateResiliencyPolicyErrorKind::ResourceNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdateResiliencyPolicyErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateResiliencyPolicyErrorKind::ThrottlingException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdateResiliencyPolicyErrorKind::ValidationException`.
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateResiliencyPolicyErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for UpdateResiliencyPolicyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateResiliencyPolicyErrorKind::AccessDeniedException(_inner) => Some(_inner),
            UpdateResiliencyPolicyErrorKind::ConflictException(_inner) => Some(_inner),
            UpdateResiliencyPolicyErrorKind::InternalServerException(_inner) => Some(_inner),
            UpdateResiliencyPolicyErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            UpdateResiliencyPolicyErrorKind::ThrottlingException(_inner) => Some(_inner),
            UpdateResiliencyPolicyErrorKind::ValidationException(_inner) => Some(_inner),
            UpdateResiliencyPolicyErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// <p>Indicates that a request was not valid.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ValidationException {
    #[allow(missing_docs)] // documentation missing in model
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ValidationException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ValidationException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ValidationException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ValidationException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ValidationException")?;
        if let Some(inner_1) = &self.message {
            write!(f, ": {}", inner_1)?;
        }
        Ok(())
    }
}
impl std::error::Error for ValidationException {}
/// See [`ValidationException`](crate::error::ValidationException)
pub mod validation_exception {
    /// A builder for [`ValidationException`](crate::error::ValidationException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ValidationException`](crate::error::ValidationException)
        pub fn build(self) -> crate::error::ValidationException {
            crate::error::ValidationException {
                message: self.message,
            }
        }
    }
}
impl ValidationException {
    /// Creates a new builder-style object to manufacture [`ValidationException`](crate::error::ValidationException)
    pub fn builder() -> crate::error::validation_exception::Builder {
        crate::error::validation_exception::Builder::default()
    }
}

/// <p>The limit on the number of requests per second was exceeded.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ThrottlingException {
    #[allow(missing_docs)] // documentation missing in model
    pub message: std::option::Option<std::string::String>,
    /// <p>The number of seconds to wait before retrying the operation.</p>
    pub retry_after_seconds: std::option::Option<i32>,
}
impl ThrottlingException {
    /// <p>The number of seconds to wait before retrying the operation.</p>
    pub fn retry_after_seconds(&self) -> std::option::Option<i32> {
        self.retry_after_seconds
    }
}
impl std::fmt::Debug for ThrottlingException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ThrottlingException");
        formatter.field("message", &self.message);
        formatter.field("retry_after_seconds", &self.retry_after_seconds);
        formatter.finish()
    }
}
impl ThrottlingException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ThrottlingException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ThrottlingException")?;
        if let Some(inner_2) = &self.message {
            write!(f, ": {}", inner_2)?;
        }
        Ok(())
    }
}
impl std::error::Error for ThrottlingException {}
/// See [`ThrottlingException`](crate::error::ThrottlingException)
pub mod throttling_exception {
    /// A builder for [`ThrottlingException`](crate::error::ThrottlingException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) retry_after_seconds: std::option::Option<i32>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// <p>The number of seconds to wait before retrying the operation.</p>
        pub fn retry_after_seconds(mut self, input: i32) -> Self {
            self.retry_after_seconds = Some(input);
            self
        }
        /// <p>The number of seconds to wait before retrying the operation.</p>
        pub fn set_retry_after_seconds(mut self, input: std::option::Option<i32>) -> Self {
            self.retry_after_seconds = input;
            self
        }
        /// Consumes the builder and constructs a [`ThrottlingException`](crate::error::ThrottlingException)
        pub fn build(self) -> crate::error::ThrottlingException {
            crate::error::ThrottlingException {
                message: self.message,
                retry_after_seconds: self.retry_after_seconds,
            }
        }
    }
}
impl ThrottlingException {
    /// Creates a new builder-style object to manufacture [`ThrottlingException`](crate::error::ThrottlingException)
    pub fn builder() -> crate::error::throttling_exception::Builder {
        crate::error::throttling_exception::Builder::default()
    }
}

/// <p>The specified resource could not be found.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ResourceNotFoundException {
    #[allow(missing_docs)] // documentation missing in model
    pub message: std::option::Option<std::string::String>,
    /// <p>The identifier of the resource that the exception applies to.</p>
    pub resource_id: std::option::Option<std::string::String>,
    /// <p>The type of the resource that the exception applies to.</p>
    pub resource_type: std::option::Option<std::string::String>,
}
impl ResourceNotFoundException {
    /// <p>The identifier of the resource that the exception applies to.</p>
    pub fn resource_id(&self) -> std::option::Option<&str> {
        self.resource_id.as_deref()
    }
    /// <p>The type of the resource that the exception applies to.</p>
    pub fn resource_type(&self) -> std::option::Option<&str> {
        self.resource_type.as_deref()
    }
}
impl std::fmt::Debug for ResourceNotFoundException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ResourceNotFoundException");
        formatter.field("message", &self.message);
        formatter.field("resource_id", &self.resource_id);
        formatter.field("resource_type", &self.resource_type);
        formatter.finish()
    }
}
impl ResourceNotFoundException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ResourceNotFoundException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ResourceNotFoundException")?;
        if let Some(inner_3) = &self.message {
            write!(f, ": {}", inner_3)?;
        }
        Ok(())
    }
}
impl std::error::Error for ResourceNotFoundException {}
/// See [`ResourceNotFoundException`](crate::error::ResourceNotFoundException)
pub mod resource_not_found_exception {
    /// A builder for [`ResourceNotFoundException`](crate::error::ResourceNotFoundException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) resource_id: std::option::Option<std::string::String>,
        pub(crate) resource_type: std::option::Option<std::string::String>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// <p>The identifier of the resource that the exception applies to.</p>
        pub fn resource_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_id = Some(input.into());
            self
        }
        /// <p>The identifier of the resource that the exception applies to.</p>
        pub fn set_resource_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.resource_id = input;
            self
        }
        /// <p>The type of the resource that the exception applies to.</p>
        pub fn resource_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_type = Some(input.into());
            self
        }
        /// <p>The type of the resource that the exception applies to.</p>
        pub fn set_resource_type(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.resource_type = input;
            self
        }
        /// Consumes the builder and constructs a [`ResourceNotFoundException`](crate::error::ResourceNotFoundException)
        pub fn build(self) -> crate::error::ResourceNotFoundException {
            crate::error::ResourceNotFoundException {
                message: self.message,
                resource_id: self.resource_id,
                resource_type: self.resource_type,
            }
        }
    }
}
impl ResourceNotFoundException {
    /// Creates a new builder-style object to manufacture [`ResourceNotFoundException`](crate::error::ResourceNotFoundException)
    pub fn builder() -> crate::error::resource_not_found_exception::Builder {
        crate::error::resource_not_found_exception::Builder::default()
    }
}

/// <p>This exception occurs when there is an internal failure in the AWS Resilience Hub
/// service.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InternalServerException {
    #[allow(missing_docs)] // documentation missing in model
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InternalServerException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InternalServerException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InternalServerException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InternalServerException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InternalServerException")?;
        if let Some(inner_4) = &self.message {
            write!(f, ": {}", inner_4)?;
        }
        Ok(())
    }
}
impl std::error::Error for InternalServerException {}
/// See [`InternalServerException`](crate::error::InternalServerException)
pub mod internal_server_exception {
    /// A builder for [`InternalServerException`](crate::error::InternalServerException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InternalServerException`](crate::error::InternalServerException)
        pub fn build(self) -> crate::error::InternalServerException {
            crate::error::InternalServerException {
                message: self.message,
            }
        }
    }
}
impl InternalServerException {
    /// Creates a new builder-style object to manufacture [`InternalServerException`](crate::error::InternalServerException)
    pub fn builder() -> crate::error::internal_server_exception::Builder {
        crate::error::internal_server_exception::Builder::default()
    }
}

/// <p>Occurs when a conflict with a previous successful write is detected. This generally occurs
/// when the previous write did not have time to propagate to the host serving the current
/// request. A retry (with appropriate backoff logic) is the recommended response to this
/// exception.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ConflictException {
    #[allow(missing_docs)] // documentation missing in model
    pub message: std::option::Option<std::string::String>,
    /// <p>The identifier of the resource that the exception applies to.</p>
    pub resource_id: std::option::Option<std::string::String>,
    /// <p>The type of the resource that the exception applies to.</p>
    pub resource_type: std::option::Option<std::string::String>,
}
impl ConflictException {
    /// <p>The identifier of the resource that the exception applies to.</p>
    pub fn resource_id(&self) -> std::option::Option<&str> {
        self.resource_id.as_deref()
    }
    /// <p>The type of the resource that the exception applies to.</p>
    pub fn resource_type(&self) -> std::option::Option<&str> {
        self.resource_type.as_deref()
    }
}
impl std::fmt::Debug for ConflictException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ConflictException");
        formatter.field("message", &self.message);
        formatter.field("resource_id", &self.resource_id);
        formatter.field("resource_type", &self.resource_type);
        formatter.finish()
    }
}
impl ConflictException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ConflictException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ConflictException")?;
        if let Some(inner_5) = &self.message {
            write!(f, ": {}", inner_5)?;
        }
        Ok(())
    }
}
impl std::error::Error for ConflictException {}
/// See [`ConflictException`](crate::error::ConflictException)
pub mod conflict_exception {
    /// A builder for [`ConflictException`](crate::error::ConflictException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) resource_id: std::option::Option<std::string::String>,
        pub(crate) resource_type: std::option::Option<std::string::String>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// <p>The identifier of the resource that the exception applies to.</p>
        pub fn resource_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_id = Some(input.into());
            self
        }
        /// <p>The identifier of the resource that the exception applies to.</p>
        pub fn set_resource_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.resource_id = input;
            self
        }
        /// <p>The type of the resource that the exception applies to.</p>
        pub fn resource_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_type = Some(input.into());
            self
        }
        /// <p>The type of the resource that the exception applies to.</p>
        pub fn set_resource_type(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.resource_type = input;
            self
        }
        /// Consumes the builder and constructs a [`ConflictException`](crate::error::ConflictException)
        pub fn build(self) -> crate::error::ConflictException {
            crate::error::ConflictException {
                message: self.message,
                resource_id: self.resource_id,
                resource_type: self.resource_type,
            }
        }
    }
}
impl ConflictException {
    /// Creates a new builder-style object to manufacture [`ConflictException`](crate::error::ConflictException)
    pub fn builder() -> crate::error::conflict_exception::Builder {
        crate::error::conflict_exception::Builder::default()
    }
}

/// <p>You don't have permissions to perform the requested operation. The user or role that is
/// making the request must have at least one IAM permissions policy attached that grants the
/// required permissions.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AccessDeniedException {
    #[allow(missing_docs)] // documentation missing in model
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for AccessDeniedException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AccessDeniedException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl AccessDeniedException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for AccessDeniedException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "AccessDeniedException")?;
        if let Some(inner_6) = &self.message {
            write!(f, ": {}", inner_6)?;
        }
        Ok(())
    }
}
impl std::error::Error for AccessDeniedException {}
/// See [`AccessDeniedException`](crate::error::AccessDeniedException)
pub mod access_denied_exception {
    /// A builder for [`AccessDeniedException`](crate::error::AccessDeniedException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`AccessDeniedException`](crate::error::AccessDeniedException)
        pub fn build(self) -> crate::error::AccessDeniedException {
            crate::error::AccessDeniedException {
                message: self.message,
            }
        }
    }
}
impl AccessDeniedException {
    /// Creates a new builder-style object to manufacture [`AccessDeniedException`](crate::error::AccessDeniedException)
    pub fn builder() -> crate::error::access_denied_exception::Builder {
        crate::error::access_denied_exception::Builder::default()
    }
}

/// <p>You have exceeded your service quota. To perform the requested action, remove some of the
/// relevant resources, or use Service Quotas to request a service quota increase.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ServiceQuotaExceededException {
    #[allow(missing_docs)] // documentation missing in model
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ServiceQuotaExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ServiceQuotaExceededException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ServiceQuotaExceededException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ServiceQuotaExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ServiceQuotaExceededException")?;
        if let Some(inner_7) = &self.message {
            write!(f, ": {}", inner_7)?;
        }
        Ok(())
    }
}
impl std::error::Error for ServiceQuotaExceededException {}
/// See [`ServiceQuotaExceededException`](crate::error::ServiceQuotaExceededException)
pub mod service_quota_exceeded_exception {
    /// A builder for [`ServiceQuotaExceededException`](crate::error::ServiceQuotaExceededException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ServiceQuotaExceededException`](crate::error::ServiceQuotaExceededException)
        pub fn build(self) -> crate::error::ServiceQuotaExceededException {
            crate::error::ServiceQuotaExceededException {
                message: self.message,
            }
        }
    }
}
impl ServiceQuotaExceededException {
    /// Creates a new builder-style object to manufacture [`ServiceQuotaExceededException`](crate::error::ServiceQuotaExceededException)
    pub fn builder() -> crate::error::service_quota_exceeded_exception::Builder {
        crate::error::service_quota_exceeded_exception::Builder::default()
    }
}
