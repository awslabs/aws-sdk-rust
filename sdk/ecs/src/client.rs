// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[derive(std::fmt::Debug)]
pub(crate) struct Handle<C = aws_hyper::DynConnector> {
    client: aws_hyper::Client<C>,
    conf: crate::Config,
}

#[derive(Clone, std::fmt::Debug)]
pub struct Client<C = aws_hyper::DynConnector> {
    handle: std::sync::Arc<Handle<C>>,
}
impl<C> Client<C> {
    pub fn from_conf_conn(conf: crate::Config, conn: C) -> Self {
        let client = aws_hyper::Client::new(conn);
        Self {
            handle: std::sync::Arc::new(Handle { client, conf }),
        }
    }

    pub fn conf(&self) -> &crate::Config {
        &self.handle.conf
    }
}
impl Client {
    #[cfg(any(feature = "rustls", feature = "native-tls"))]
    pub fn from_env() -> Self {
        Self::from_conf(crate::Config::builder().build())
    }

    #[cfg(any(feature = "rustls", feature = "native-tls"))]
    pub fn from_conf(conf: crate::Config) -> Self {
        let client = aws_hyper::Client::https();
        Self {
            handle: std::sync::Arc::new(Handle { client, conf }),
        }
    }
}
impl<C> Client<C>
where
    C: aws_hyper::SmithyConnector,
{
    pub fn create_capacity_provider(&self) -> fluent_builders::CreateCapacityProvider<C> {
        fluent_builders::CreateCapacityProvider::new(self.handle.clone())
    }
    pub fn create_cluster(&self) -> fluent_builders::CreateCluster<C> {
        fluent_builders::CreateCluster::new(self.handle.clone())
    }
    pub fn create_service(&self) -> fluent_builders::CreateService<C> {
        fluent_builders::CreateService::new(self.handle.clone())
    }
    pub fn create_task_set(&self) -> fluent_builders::CreateTaskSet<C> {
        fluent_builders::CreateTaskSet::new(self.handle.clone())
    }
    pub fn delete_account_setting(&self) -> fluent_builders::DeleteAccountSetting<C> {
        fluent_builders::DeleteAccountSetting::new(self.handle.clone())
    }
    pub fn delete_attributes(&self) -> fluent_builders::DeleteAttributes<C> {
        fluent_builders::DeleteAttributes::new(self.handle.clone())
    }
    pub fn delete_capacity_provider(&self) -> fluent_builders::DeleteCapacityProvider<C> {
        fluent_builders::DeleteCapacityProvider::new(self.handle.clone())
    }
    pub fn delete_cluster(&self) -> fluent_builders::DeleteCluster<C> {
        fluent_builders::DeleteCluster::new(self.handle.clone())
    }
    pub fn delete_service(&self) -> fluent_builders::DeleteService<C> {
        fluent_builders::DeleteService::new(self.handle.clone())
    }
    pub fn delete_task_set(&self) -> fluent_builders::DeleteTaskSet<C> {
        fluent_builders::DeleteTaskSet::new(self.handle.clone())
    }
    pub fn deregister_container_instance(&self) -> fluent_builders::DeregisterContainerInstance<C> {
        fluent_builders::DeregisterContainerInstance::new(self.handle.clone())
    }
    pub fn deregister_task_definition(&self) -> fluent_builders::DeregisterTaskDefinition<C> {
        fluent_builders::DeregisterTaskDefinition::new(self.handle.clone())
    }
    pub fn describe_capacity_providers(&self) -> fluent_builders::DescribeCapacityProviders<C> {
        fluent_builders::DescribeCapacityProviders::new(self.handle.clone())
    }
    pub fn describe_clusters(&self) -> fluent_builders::DescribeClusters<C> {
        fluent_builders::DescribeClusters::new(self.handle.clone())
    }
    pub fn describe_container_instances(&self) -> fluent_builders::DescribeContainerInstances<C> {
        fluent_builders::DescribeContainerInstances::new(self.handle.clone())
    }
    pub fn describe_services(&self) -> fluent_builders::DescribeServices<C> {
        fluent_builders::DescribeServices::new(self.handle.clone())
    }
    pub fn describe_task_definition(&self) -> fluent_builders::DescribeTaskDefinition<C> {
        fluent_builders::DescribeTaskDefinition::new(self.handle.clone())
    }
    pub fn describe_tasks(&self) -> fluent_builders::DescribeTasks<C> {
        fluent_builders::DescribeTasks::new(self.handle.clone())
    }
    pub fn describe_task_sets(&self) -> fluent_builders::DescribeTaskSets<C> {
        fluent_builders::DescribeTaskSets::new(self.handle.clone())
    }
    pub fn discover_poll_endpoint(&self) -> fluent_builders::DiscoverPollEndpoint<C> {
        fluent_builders::DiscoverPollEndpoint::new(self.handle.clone())
    }
    pub fn execute_command(&self) -> fluent_builders::ExecuteCommand<C> {
        fluent_builders::ExecuteCommand::new(self.handle.clone())
    }
    pub fn list_account_settings(&self) -> fluent_builders::ListAccountSettings<C> {
        fluent_builders::ListAccountSettings::new(self.handle.clone())
    }
    pub fn list_attributes(&self) -> fluent_builders::ListAttributes<C> {
        fluent_builders::ListAttributes::new(self.handle.clone())
    }
    pub fn list_clusters(&self) -> fluent_builders::ListClusters<C> {
        fluent_builders::ListClusters::new(self.handle.clone())
    }
    pub fn list_container_instances(&self) -> fluent_builders::ListContainerInstances<C> {
        fluent_builders::ListContainerInstances::new(self.handle.clone())
    }
    pub fn list_services(&self) -> fluent_builders::ListServices<C> {
        fluent_builders::ListServices::new(self.handle.clone())
    }
    pub fn list_tags_for_resource(&self) -> fluent_builders::ListTagsForResource<C> {
        fluent_builders::ListTagsForResource::new(self.handle.clone())
    }
    pub fn list_task_definition_families(&self) -> fluent_builders::ListTaskDefinitionFamilies<C> {
        fluent_builders::ListTaskDefinitionFamilies::new(self.handle.clone())
    }
    pub fn list_task_definitions(&self) -> fluent_builders::ListTaskDefinitions<C> {
        fluent_builders::ListTaskDefinitions::new(self.handle.clone())
    }
    pub fn list_tasks(&self) -> fluent_builders::ListTasks<C> {
        fluent_builders::ListTasks::new(self.handle.clone())
    }
    pub fn put_account_setting(&self) -> fluent_builders::PutAccountSetting<C> {
        fluent_builders::PutAccountSetting::new(self.handle.clone())
    }
    pub fn put_account_setting_default(&self) -> fluent_builders::PutAccountSettingDefault<C> {
        fluent_builders::PutAccountSettingDefault::new(self.handle.clone())
    }
    pub fn put_attributes(&self) -> fluent_builders::PutAttributes<C> {
        fluent_builders::PutAttributes::new(self.handle.clone())
    }
    pub fn put_cluster_capacity_providers(
        &self,
    ) -> fluent_builders::PutClusterCapacityProviders<C> {
        fluent_builders::PutClusterCapacityProviders::new(self.handle.clone())
    }
    pub fn register_container_instance(&self) -> fluent_builders::RegisterContainerInstance<C> {
        fluent_builders::RegisterContainerInstance::new(self.handle.clone())
    }
    pub fn register_task_definition(&self) -> fluent_builders::RegisterTaskDefinition<C> {
        fluent_builders::RegisterTaskDefinition::new(self.handle.clone())
    }
    pub fn run_task(&self) -> fluent_builders::RunTask<C> {
        fluent_builders::RunTask::new(self.handle.clone())
    }
    pub fn start_task(&self) -> fluent_builders::StartTask<C> {
        fluent_builders::StartTask::new(self.handle.clone())
    }
    pub fn stop_task(&self) -> fluent_builders::StopTask<C> {
        fluent_builders::StopTask::new(self.handle.clone())
    }
    pub fn submit_attachment_state_changes(
        &self,
    ) -> fluent_builders::SubmitAttachmentStateChanges<C> {
        fluent_builders::SubmitAttachmentStateChanges::new(self.handle.clone())
    }
    pub fn submit_container_state_change(&self) -> fluent_builders::SubmitContainerStateChange<C> {
        fluent_builders::SubmitContainerStateChange::new(self.handle.clone())
    }
    pub fn submit_task_state_change(&self) -> fluent_builders::SubmitTaskStateChange<C> {
        fluent_builders::SubmitTaskStateChange::new(self.handle.clone())
    }
    pub fn tag_resource(&self) -> fluent_builders::TagResource<C> {
        fluent_builders::TagResource::new(self.handle.clone())
    }
    pub fn untag_resource(&self) -> fluent_builders::UntagResource<C> {
        fluent_builders::UntagResource::new(self.handle.clone())
    }
    pub fn update_capacity_provider(&self) -> fluent_builders::UpdateCapacityProvider<C> {
        fluent_builders::UpdateCapacityProvider::new(self.handle.clone())
    }
    pub fn update_cluster(&self) -> fluent_builders::UpdateCluster<C> {
        fluent_builders::UpdateCluster::new(self.handle.clone())
    }
    pub fn update_cluster_settings(&self) -> fluent_builders::UpdateClusterSettings<C> {
        fluent_builders::UpdateClusterSettings::new(self.handle.clone())
    }
    pub fn update_container_agent(&self) -> fluent_builders::UpdateContainerAgent<C> {
        fluent_builders::UpdateContainerAgent::new(self.handle.clone())
    }
    pub fn update_container_instances_state(
        &self,
    ) -> fluent_builders::UpdateContainerInstancesState<C> {
        fluent_builders::UpdateContainerInstancesState::new(self.handle.clone())
    }
    pub fn update_service(&self) -> fluent_builders::UpdateService<C> {
        fluent_builders::UpdateService::new(self.handle.clone())
    }
    pub fn update_service_primary_task_set(
        &self,
    ) -> fluent_builders::UpdateServicePrimaryTaskSet<C> {
        fluent_builders::UpdateServicePrimaryTaskSet::new(self.handle.clone())
    }
    pub fn update_task_set(&self) -> fluent_builders::UpdateTaskSet<C> {
        fluent_builders::UpdateTaskSet::new(self.handle.clone())
    }
}
pub mod fluent_builders {
    #[derive(std::fmt::Debug)]
    pub struct CreateCapacityProvider<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_capacity_provider_input::Builder,
    }
    impl<C> CreateCapacityProvider<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateCapacityProviderOutput,
            smithy_http::result::SdkError<crate::error::CreateCapacityProviderError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the capacity provider. Up to 255 characters are allowed, including letters
        /// (upper and lowercase), numbers, underscores, and hyphens. The name cannot be prefixed
        /// with "<code>aws</code>", "<code>ecs</code>", or "<code>fargate</code>".</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(input);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
        /// <p>The details of the Auto Scaling group for the capacity provider.</p>
        pub fn auto_scaling_group_provider(
            mut self,
            input: crate::model::AutoScalingGroupProvider,
        ) -> Self {
            self.inner = self.inner.auto_scaling_group_provider(input);
            self
        }
        pub fn set_auto_scaling_group_provider(
            mut self,
            input: std::option::Option<crate::model::AutoScalingGroupProvider>,
        ) -> Self {
            self.inner = self.inner.set_auto_scaling_group_provider(input);
            self
        }
        /// <p>The metadata that you apply to the capacity provider to help you categorize and
        /// organize them. Each tag consists of a key and an optional value, both of which you
        /// define.</p>
        /// <p>The following basic restrictions apply to tags:</p>
        /// <ul>
        /// <li>
        /// <p>Maximum number of tags per resource - 50</p>
        /// </li>
        /// <li>
        /// <p>For each resource, each tag key must be unique, and each tag key can have only
        /// one value.</p>
        /// </li>
        /// <li>
        /// <p>Maximum key length - 128 Unicode characters in UTF-8</p>
        /// </li>
        /// <li>
        /// <p>Maximum value length - 256 Unicode characters in UTF-8</p>
        /// </li>
        /// <li>
        /// <p>If your tagging schema is used across multiple services and resources,
        /// remember that other services may have restrictions on allowed characters.
        /// Generally allowed characters are: letters, numbers, and spaces representable in
        /// UTF-8, and the following characters: + - = . _ : / @.</p>
        /// </li>
        /// <li>
        /// <p>Tag keys and values are case-sensitive.</p>
        /// </li>
        /// <li>
        /// <p>Do not use <code>aws:</code>, <code>AWS:</code>, or any upper or lowercase
        /// combination of such as a prefix for either keys or values as it is reserved for
        /// AWS use. You cannot edit or delete tag keys or values with this prefix. Tags with
        /// this prefix do not count against your tags per resource limit.</p>
        /// </li>
        /// </ul>
        pub fn tags(mut self, inp: impl Into<crate::model::Tag>) -> Self {
            self.inner = self.inner.tags(inp);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateCluster<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_cluster_input::Builder,
    }
    impl<C> CreateCluster<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateClusterOutput,
            smithy_http::result::SdkError<crate::error::CreateClusterError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of your cluster. If you do not specify a name for your cluster, you create a
        /// cluster named <code>default</code>. Up to 255 letters (uppercase and lowercase), numbers, underscores, and hyphens are allowed. </p>
        pub fn cluster_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.cluster_name(input);
            self
        }
        pub fn set_cluster_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_cluster_name(input);
            self
        }
        /// <p>The metadata that you apply to the cluster to help you categorize and organize them.
        /// Each tag consists of a key and an optional value, both of which you define.</p>
        /// <p>The following basic restrictions apply to tags:</p>
        /// <ul>
        /// <li>
        /// <p>Maximum number of tags per resource - 50</p>
        /// </li>
        /// <li>
        /// <p>For each resource, each tag key must be unique, and each tag key can have only
        /// one value.</p>
        /// </li>
        /// <li>
        /// <p>Maximum key length - 128 Unicode characters in UTF-8</p>
        /// </li>
        /// <li>
        /// <p>Maximum value length - 256 Unicode characters in UTF-8</p>
        /// </li>
        /// <li>
        /// <p>If your tagging schema is used across multiple services and resources,
        /// remember that other services may have restrictions on allowed characters.
        /// Generally allowed characters are: letters, numbers, and spaces representable in
        /// UTF-8, and the following characters: + - = . _ : / @.</p>
        /// </li>
        /// <li>
        /// <p>Tag keys and values are case-sensitive.</p>
        /// </li>
        /// <li>
        /// <p>Do not use <code>aws:</code>, <code>AWS:</code>, or any upper or lowercase
        /// combination of such as a prefix for either keys or values as it is reserved for
        /// AWS use. You cannot edit or delete tag keys or values with this prefix. Tags with
        /// this prefix do not count against your tags per resource limit.</p>
        /// </li>
        /// </ul>
        pub fn tags(mut self, inp: impl Into<crate::model::Tag>) -> Self {
            self.inner = self.inner.tags(inp);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
        /// <p>The setting to use when creating a cluster. This parameter is used to enable CloudWatch
        /// Container Insights for a cluster. If this value is specified, it will override the
        /// <code>containerInsights</code> value set with <a>PutAccountSetting</a> or
        /// <a>PutAccountSettingDefault</a>.</p>
        pub fn settings(mut self, inp: impl Into<crate::model::ClusterSetting>) -> Self {
            self.inner = self.inner.settings(inp);
            self
        }
        pub fn set_settings(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ClusterSetting>>,
        ) -> Self {
            self.inner = self.inner.set_settings(input);
            self
        }
        /// <p>The execute command configuration for the cluster.</p>
        pub fn configuration(mut self, input: crate::model::ClusterConfiguration) -> Self {
            self.inner = self.inner.configuration(input);
            self
        }
        pub fn set_configuration(
            mut self,
            input: std::option::Option<crate::model::ClusterConfiguration>,
        ) -> Self {
            self.inner = self.inner.set_configuration(input);
            self
        }
        /// <p>The short name of one or more capacity providers to associate with the cluster. A
        /// capacity provider must be associated with a cluster before it can be included as part of
        /// the default capacity provider strategy of the cluster or used in a capacity provider
        /// strategy when calling the <a>CreateService</a> or <a>RunTask</a>
        /// actions.</p>
        /// <p>If specifying a capacity provider that uses an Auto Scaling group, the capacity
        /// provider must already be created and not already associated with another cluster. New
        /// Auto Scaling group capacity providers can be created with the <a>CreateCapacityProvider</a> API operation.</p>
        /// <p>To use a AWS Fargate capacity provider, specify either the <code>FARGATE</code> or
        /// <code>FARGATE_SPOT</code> capacity providers. The AWS Fargate capacity providers are
        /// available to all accounts and only need to be associated with a cluster to be
        /// used.</p>
        /// <p>The <a>PutClusterCapacityProviders</a> API operation is used to update the
        /// list of available capacity providers for a cluster after the cluster is created.</p>
        pub fn capacity_providers(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.capacity_providers(inp);
            self
        }
        pub fn set_capacity_providers(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_capacity_providers(input);
            self
        }
        /// <p>The capacity provider strategy to set as the default for the cluster. When a default
        /// capacity provider strategy is set for a cluster, when calling the <a>RunTask</a> or <a>CreateService</a> APIs wtih no capacity
        /// provider strategy or launch type specified, the default capacity provider strategy for
        /// the cluster is used.</p>
        /// <p>If a default capacity provider strategy is not defined for a cluster during creation,
        /// it can be defined later with the <a>PutClusterCapacityProviders</a> API
        /// operation.</p>
        pub fn default_capacity_provider_strategy(
            mut self,
            inp: impl Into<crate::model::CapacityProviderStrategyItem>,
        ) -> Self {
            self.inner = self.inner.default_capacity_provider_strategy(inp);
            self
        }
        pub fn set_default_capacity_provider_strategy(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::CapacityProviderStrategyItem>>,
        ) -> Self {
            self.inner = self.inner.set_default_capacity_provider_strategy(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateService<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_service_input::Builder,
    }
    impl<C> CreateService<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateServiceOutput,
            smithy_http::result::SdkError<crate::error::CreateServiceError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The short name or full Amazon Resource Name (ARN) of the cluster on which to run your service.
        /// If you do not specify a cluster, the default cluster is assumed.</p>
        pub fn cluster(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.cluster(input);
            self
        }
        pub fn set_cluster(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_cluster(input);
            self
        }
        /// <p>The name of your service. Up to 255 letters (uppercase and lowercase), numbers, underscores, and hyphens are allowed. Service names must be unique within
        /// a cluster, but you can have similarly named services in multiple clusters within a
        /// Region or across multiple Regions.</p>
        pub fn service_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.service_name(input);
            self
        }
        pub fn set_service_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_service_name(input);
            self
        }
        /// <p>The <code>family</code> and <code>revision</code> (<code>family:revision</code>) or
        /// full ARN of the task definition to run in your service. If a <code>revision</code> is
        /// not specified, the latest <code>ACTIVE</code> revision is used.</p>
        /// <p>A task definition must be specified if the service is using either the
        /// <code>ECS</code> or <code>CODE_DEPLOY</code> deployment controllers.</p>
        pub fn task_definition(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.task_definition(input);
            self
        }
        pub fn set_task_definition(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_task_definition(input);
            self
        }
        /// <p>A load balancer object representing the load balancers to use with your service. For
        /// more information, see <a href="https://docs.aws.amazon.com/AmazonECS/latest/developerguide/service-load-balancing.html">Service Load Balancing</a> in the
        /// <i>Amazon Elastic Container Service Developer Guide</i>.</p>
        /// <p>If the service is using the rolling update (<code>ECS</code>) deployment controller
        /// and using either an Application Load Balancer or Network Load Balancer, you must specify one or more target group ARNs to
        /// attach to the service. The service-linked role is required for services that make use of
        /// multiple target groups. For more information, see <a href="https://docs.aws.amazon.com/AmazonECS/latest/developerguide/using-service-linked-roles.html">Using service-linked roles for Amazon ECS</a> in the
        /// <i>Amazon Elastic Container Service Developer Guide</i>.</p>
        /// <p>If the service is using the <code>CODE_DEPLOY</code> deployment controller, the
        /// service is required to use either an Application Load Balancer or Network Load Balancer. When creating an AWS CodeDeploy deployment
        /// group, you specify two target groups (referred to as a <code>targetGroupPair</code>).
        /// During a deployment, AWS CodeDeploy determines which task set in your service has the status
        /// <code>PRIMARY</code> and associates one target group with it, and then associates
        /// the other target group with the replacement task set. The load balancer can also have up
        /// to two listeners: a required listener for production traffic and an optional listener
        /// that allows you perform validation tests with Lambda functions before routing production
        /// traffic to it.</p>
        /// <p>After you create a service using the <code>ECS</code> deployment controller, the load
        /// balancer name or target group ARN, container name, and container port specified in the
        /// service definition are immutable. If you are using the <code>CODE_DEPLOY</code>
        /// deployment controller, these values can be changed when updating the service.</p>
        /// <p>For Application Load Balancers and Network Load Balancers, this object must contain the load balancer target group ARN,
        /// the container name (as it appears in a container definition), and the container port to
        /// access from the load balancer. The load balancer name parameter must be omitted. When a
        /// task from this service is placed on a container instance, the container instance and
        /// port combination is registered as a target in the target group specified here.</p>
        /// <p>For Classic Load Balancers, this object must contain the load balancer name, the container name (as it
        /// appears in a container definition), and the container port to access from the load
        /// balancer. The target group ARN parameter must be omitted. When a task from this service
        /// is placed on a container instance, the container instance is registered with the load
        /// balancer specified here.</p>
        /// <p>Services with tasks that use the <code>awsvpc</code> network mode (for example, those
        /// with the Fargate launch type) only support Application Load Balancers and Network Load Balancers. Classic Load Balancers are
        /// not supported. Also, when you create any target groups for these services, you must
        /// choose <code>ip</code> as the target type, not <code>instance</code>, because tasks that
        /// use the <code>awsvpc</code> network mode are associated with an elastic network
        /// interface, not an Amazon EC2 instance.</p>
        pub fn load_balancers(mut self, inp: impl Into<crate::model::LoadBalancer>) -> Self {
            self.inner = self.inner.load_balancers(inp);
            self
        }
        pub fn set_load_balancers(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::LoadBalancer>>,
        ) -> Self {
            self.inner = self.inner.set_load_balancers(input);
            self
        }
        /// <p>The details of the service discovery registry to associate with this service. For more
        /// information, see <a href="https://docs.aws.amazon.com/AmazonECS/latest/developerguide/service-discovery.html">Service
        /// discovery</a>.</p>
        /// <note>
        /// <p>Each service may be associated with one service registry. Multiple service
        /// registries per service isn't supported.</p>
        /// </note>
        pub fn service_registries(mut self, inp: impl Into<crate::model::ServiceRegistry>) -> Self {
            self.inner = self.inner.service_registries(inp);
            self
        }
        pub fn set_service_registries(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ServiceRegistry>>,
        ) -> Self {
            self.inner = self.inner.set_service_registries(input);
            self
        }
        /// <p>The number of instantiations of the specified task definition to place and keep
        /// running on your cluster.</p>
        /// <p>This is required if <code>schedulingStrategy</code> is <code>REPLICA</code> or is not
        /// specified. If <code>schedulingStrategy</code> is <code>DAEMON</code> then this is not
        /// required.</p>
        pub fn desired_count(mut self, input: i32) -> Self {
            self.inner = self.inner.desired_count(input);
            self
        }
        pub fn set_desired_count(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_desired_count(input);
            self
        }
        /// <p>Unique, case-sensitive identifier that you provide to ensure the idempotency of the
        /// request. Up to 32 ASCII characters are allowed.</p>
        pub fn client_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.client_token(input);
            self
        }
        pub fn set_client_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_client_token(input);
            self
        }
        /// <p>The infrastructure on which to run your service. For more information, see <a href="https://docs.aws.amazon.com/AmazonECS/latest/developerguide/launch_types.html">Amazon ECS
        /// launch types</a> in the <i>Amazon Elastic Container Service Developer Guide</i>.</p>
        /// <p>The <code>FARGATE</code> launch type runs your tasks on AWS Fargate On-Demand
        /// infrastructure.</p>
        /// <note>
        /// <p>Fargate Spot infrastructure is available for use but a capacity provider
        /// strategy must be used. For more information, see <a href="https://docs.aws.amazon.com/AmazonECS/latest/userguide/fargate-capacity-providers.html">AWS Fargate capacity providers</a> in the
        /// <i>Amazon ECS User Guide for AWS Fargate</i>.</p>
        /// </note>
        /// <p>The <code>EC2</code> launch type runs your tasks on Amazon EC2 instances registered to your
        /// cluster.</p>
        /// <p>The <code>EXTERNAL</code> launch type runs your tasks on your on-premise server or
        /// virtual machine (VM) capacity registered to your cluster.</p>
        /// <p>A service can use either a launch type or a capacity provider strategy. If a
        /// <code>launchType</code> is specified, the <code>capacityProviderStrategy</code>
        /// parameter must be omitted.</p>
        pub fn launch_type(mut self, input: crate::model::LaunchType) -> Self {
            self.inner = self.inner.launch_type(input);
            self
        }
        pub fn set_launch_type(
            mut self,
            input: std::option::Option<crate::model::LaunchType>,
        ) -> Self {
            self.inner = self.inner.set_launch_type(input);
            self
        }
        /// <p>The capacity provider strategy to use for the service.</p>
        /// <p>If a <code>capacityProviderStrategy</code> is specified, the <code>launchType</code>
        /// parameter must be omitted. If no <code>capacityProviderStrategy</code> or
        /// <code>launchType</code> is specified, the
        /// <code>defaultCapacityProviderStrategy</code> for the cluster is used.</p>
        pub fn capacity_provider_strategy(
            mut self,
            inp: impl Into<crate::model::CapacityProviderStrategyItem>,
        ) -> Self {
            self.inner = self.inner.capacity_provider_strategy(inp);
            self
        }
        pub fn set_capacity_provider_strategy(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::CapacityProviderStrategyItem>>,
        ) -> Self {
            self.inner = self.inner.set_capacity_provider_strategy(input);
            self
        }
        /// <p>The platform version that your tasks in the service are running on. A platform version
        /// is specified only for tasks using the Fargate launch type. If one isn't
        /// specified, the <code>LATEST</code> platform version is used by default. For more
        /// information, see <a href="https://docs.aws.amazon.com/AmazonECS/latest/developerguide/platform_versions.html">AWS Fargate platform
        /// versions</a> in the <i>Amazon Elastic Container Service Developer Guide</i>.</p>
        pub fn platform_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.platform_version(input);
            self
        }
        pub fn set_platform_version(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_platform_version(input);
            self
        }
        /// <p>The name or full Amazon Resource Name (ARN) of the IAM role that allows Amazon ECS to make calls to your
        /// load balancer on your behalf. This parameter is only permitted if you are using a load
        /// balancer with your service and your task definition does not use the <code>awsvpc</code>
        /// network mode. If you specify the <code>role</code> parameter, you must also specify a
        /// load balancer object with the <code>loadBalancers</code> parameter.</p>
        /// <important>
        /// <p>If your account has already created the Amazon ECS service-linked role, that role is
        /// used by default for your service unless you specify a role here. The service-linked
        /// role is required if your task definition uses the <code>awsvpc</code> network mode
        /// or if the service is configured to use service discovery, an external deployment
        /// controller, multiple target groups, or Elastic Inference accelerators in which case
        /// you should not specify a role here. For more information, see <a href="https://docs.aws.amazon.com/AmazonECS/latest/developerguide/using-service-linked-roles.html">Using
        /// service-linked roles for Amazon ECS</a> in the
        /// <i>Amazon Elastic Container Service Developer Guide</i>.</p>
        /// </important>
        /// <p>If your specified role has a path other than <code>/</code>, then you must either
        /// specify the full role ARN (this is recommended) or prefix the role name with the path.
        /// For example, if a role with the name <code>bar</code> has a path of <code>/foo/</code>
        /// then you would specify <code>/foo/bar</code> as the role name. For more information, see
        /// <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_identifiers.html#identifiers-friendly-names">Friendly names and paths</a> in the <i>IAM User Guide</i>.</p>
        pub fn role(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.role(input);
            self
        }
        pub fn set_role(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_role(input);
            self
        }
        /// <p>Optional deployment parameters that control how many tasks run during the deployment
        /// and the ordering of stopping and starting tasks.</p>
        pub fn deployment_configuration(
            mut self,
            input: crate::model::DeploymentConfiguration,
        ) -> Self {
            self.inner = self.inner.deployment_configuration(input);
            self
        }
        pub fn set_deployment_configuration(
            mut self,
            input: std::option::Option<crate::model::DeploymentConfiguration>,
        ) -> Self {
            self.inner = self.inner.set_deployment_configuration(input);
            self
        }
        /// <p>An array of placement constraint objects to use for tasks in your service. You can
        /// specify a maximum of 10 constraints per task (this limit includes constraints in the
        /// task definition and those specified at runtime). </p>
        pub fn placement_constraints(
            mut self,
            inp: impl Into<crate::model::PlacementConstraint>,
        ) -> Self {
            self.inner = self.inner.placement_constraints(inp);
            self
        }
        pub fn set_placement_constraints(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::PlacementConstraint>>,
        ) -> Self {
            self.inner = self.inner.set_placement_constraints(input);
            self
        }
        /// <p>The placement strategy objects to use for tasks in your service. You can specify a
        /// maximum of five strategy rules per service.</p>
        pub fn placement_strategy(
            mut self,
            inp: impl Into<crate::model::PlacementStrategy>,
        ) -> Self {
            self.inner = self.inner.placement_strategy(inp);
            self
        }
        pub fn set_placement_strategy(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::PlacementStrategy>>,
        ) -> Self {
            self.inner = self.inner.set_placement_strategy(input);
            self
        }
        /// <p>The network configuration for the service. This parameter is required for task
        /// definitions that use the <code>awsvpc</code> network mode to receive their own elastic
        /// network interface, and it is not supported for other network modes. For more
        /// information, see <a href="https://docs.aws.amazon.com/AmazonECS/latest/developerguide/task-networking.html">Task networking</a>
        /// in the <i>Amazon Elastic Container Service Developer Guide</i>.</p>
        pub fn network_configuration(mut self, input: crate::model::NetworkConfiguration) -> Self {
            self.inner = self.inner.network_configuration(input);
            self
        }
        pub fn set_network_configuration(
            mut self,
            input: std::option::Option<crate::model::NetworkConfiguration>,
        ) -> Self {
            self.inner = self.inner.set_network_configuration(input);
            self
        }
        /// <p>The period of time, in seconds, that the Amazon ECS service scheduler should ignore
        /// unhealthy Elastic Load Balancing target health checks after a task has first started. This is only used
        /// when your service is configured to use a load balancer. If your service has a load
        /// balancer defined and you don't specify a health check grace period value, the default
        /// value of <code>0</code> is used.</p>
        /// <p>If your service's tasks take a while to start and respond to Elastic Load Balancing health checks, you
        /// can specify a health check grace period of up to 2,147,483,647 seconds. During that
        /// time, the Amazon ECS service scheduler ignores health check status. This grace period can
        /// prevent the service scheduler from marking tasks as unhealthy and stopping them before
        /// they have time to come up.</p>
        pub fn health_check_grace_period_seconds(mut self, input: i32) -> Self {
            self.inner = self.inner.health_check_grace_period_seconds(input);
            self
        }
        pub fn set_health_check_grace_period_seconds(
            mut self,
            input: std::option::Option<i32>,
        ) -> Self {
            self.inner = self.inner.set_health_check_grace_period_seconds(input);
            self
        }
        /// <p>The scheduling strategy to use for the service. For more information, see <a href="https://docs.aws.amazon.com/AmazonECS/latest/developerguide/ecs_services.html">Services</a>.</p>
        /// <p>There are two service scheduler strategies available:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>REPLICA</code>-The replica scheduling strategy places and
        /// maintains the desired number of tasks across your cluster. By default, the
        /// service scheduler spreads tasks across Availability Zones. You can use task
        /// placement strategies and constraints to customize task placement decisions. This
        /// scheduler strategy is required if the service is using the
        /// <code>CODE_DEPLOY</code> or <code>EXTERNAL</code> deployment controller
        /// types.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>DAEMON</code>-The daemon scheduling strategy deploys exactly one
        /// task on each active container instance that meets all of the task placement
        /// constraints that you specify in your cluster. The service scheduler also
        /// evaluates the task placement constraints for running tasks and will stop tasks
        /// that do not meet the placement constraints. When you're using this strategy, you
        /// don't need to specify a desired number of tasks, a task placement strategy, or
        /// use Service Auto Scaling policies.</p>
        /// <note>
        /// <p>Tasks using the Fargate launch type or the
        /// <code>CODE_DEPLOY</code> or <code>EXTERNAL</code> deployment controller
        /// types don't support the <code>DAEMON</code> scheduling strategy.</p>
        /// </note>
        /// </li>
        /// </ul>
        pub fn scheduling_strategy(mut self, input: crate::model::SchedulingStrategy) -> Self {
            self.inner = self.inner.scheduling_strategy(input);
            self
        }
        pub fn set_scheduling_strategy(
            mut self,
            input: std::option::Option<crate::model::SchedulingStrategy>,
        ) -> Self {
            self.inner = self.inner.set_scheduling_strategy(input);
            self
        }
        /// <p>The deployment controller to use for the service. If no deployment controller is
        /// specified, the default value of <code>ECS</code> is used.</p>
        pub fn deployment_controller(mut self, input: crate::model::DeploymentController) -> Self {
            self.inner = self.inner.deployment_controller(input);
            self
        }
        pub fn set_deployment_controller(
            mut self,
            input: std::option::Option<crate::model::DeploymentController>,
        ) -> Self {
            self.inner = self.inner.set_deployment_controller(input);
            self
        }
        /// <p>The metadata that you apply to the service to help you categorize and organize them.
        /// Each tag consists of a key and an optional value, both of which you define. When a
        /// service is deleted, the tags are deleted as well.</p>
        /// <p>The following basic restrictions apply to tags:</p>
        /// <ul>
        /// <li>
        /// <p>Maximum number of tags per resource - 50</p>
        /// </li>
        /// <li>
        /// <p>For each resource, each tag key must be unique, and each tag key can have only
        /// one value.</p>
        /// </li>
        /// <li>
        /// <p>Maximum key length - 128 Unicode characters in UTF-8</p>
        /// </li>
        /// <li>
        /// <p>Maximum value length - 256 Unicode characters in UTF-8</p>
        /// </li>
        /// <li>
        /// <p>If your tagging schema is used across multiple services and resources,
        /// remember that other services may have restrictions on allowed characters.
        /// Generally allowed characters are: letters, numbers, and spaces representable in
        /// UTF-8, and the following characters: + - = . _ : / @.</p>
        /// </li>
        /// <li>
        /// <p>Tag keys and values are case-sensitive.</p>
        /// </li>
        /// <li>
        /// <p>Do not use <code>aws:</code>, <code>AWS:</code>, or any upper or lowercase
        /// combination of such as a prefix for either keys or values as it is reserved for
        /// AWS use. You cannot edit or delete tag keys or values with this prefix. Tags with
        /// this prefix do not count against your tags per resource limit.</p>
        /// </li>
        /// </ul>
        pub fn tags(mut self, inp: impl Into<crate::model::Tag>) -> Self {
            self.inner = self.inner.tags(inp);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
        /// <p>Specifies whether to enable Amazon ECS managed tags for the tasks within the service. For
        /// more information, see <a href="https://docs.aws.amazon.com/AmazonECS/latest/developerguide/ecs-using-tags.html">Tagging Your Amazon ECS
        /// Resources</a> in the <i>Amazon Elastic Container Service Developer Guide</i>.</p>
        pub fn enable_ecs_managed_tags(mut self, input: bool) -> Self {
            self.inner = self.inner.enable_ecs_managed_tags(input);
            self
        }
        pub fn set_enable_ecs_managed_tags(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_enable_ecs_managed_tags(input);
            self
        }
        /// <p>Specifies whether to propagate the tags from the task definition or the service to the
        /// tasks in the service. If no value is specified, the tags are not propagated. Tags can
        /// only be propagated to the tasks within the service during service creation. To add tags
        /// to a task after service creation, use the <a>TagResource</a> API
        /// action.</p>
        pub fn propagate_tags(mut self, input: crate::model::PropagateTags) -> Self {
            self.inner = self.inner.propagate_tags(input);
            self
        }
        pub fn set_propagate_tags(
            mut self,
            input: std::option::Option<crate::model::PropagateTags>,
        ) -> Self {
            self.inner = self.inner.set_propagate_tags(input);
            self
        }
        /// <p>Whether or not the execute command functionality is enabled for the service. If
        /// <code>true</code>, this enables execute command functionality on all containers in
        /// the service tasks.</p>
        pub fn enable_execute_command(mut self, input: bool) -> Self {
            self.inner = self.inner.enable_execute_command(input);
            self
        }
        pub fn set_enable_execute_command(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_enable_execute_command(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateTaskSet<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_task_set_input::Builder,
    }
    impl<C> CreateTaskSet<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateTaskSetOutput,
            smithy_http::result::SdkError<crate::error::CreateTaskSetError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The short name or full Amazon Resource Name (ARN) of the service to create the task set in.</p>
        pub fn service(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.service(input);
            self
        }
        pub fn set_service(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_service(input);
            self
        }
        /// <p>The short name or full Amazon Resource Name (ARN) of the cluster that hosts the service to create the
        /// task set in.</p>
        pub fn cluster(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.cluster(input);
            self
        }
        pub fn set_cluster(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_cluster(input);
            self
        }
        /// <p>An optional non-unique tag that identifies this task set in external systems. If the
        /// task set is associated with a service discovery registry, the tasks in this task set
        /// will have the <code>ECS_TASK_SET_EXTERNAL_ID</code> AWS Cloud Map attribute set to the provided
        /// value.</p>
        pub fn external_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.external_id(input);
            self
        }
        pub fn set_external_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_external_id(input);
            self
        }
        /// <p>The task definition for the tasks in the task set to use.</p>
        pub fn task_definition(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.task_definition(input);
            self
        }
        pub fn set_task_definition(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_task_definition(input);
            self
        }
        /// <p>An object representing the network configuration for a task set.</p>
        pub fn network_configuration(mut self, input: crate::model::NetworkConfiguration) -> Self {
            self.inner = self.inner.network_configuration(input);
            self
        }
        pub fn set_network_configuration(
            mut self,
            input: std::option::Option<crate::model::NetworkConfiguration>,
        ) -> Self {
            self.inner = self.inner.set_network_configuration(input);
            self
        }
        /// <p>A load balancer object representing the load balancer to use with the task set. The
        /// supported load balancer types are either an Application Load Balancer or a Network Load Balancer.</p>
        pub fn load_balancers(mut self, inp: impl Into<crate::model::LoadBalancer>) -> Self {
            self.inner = self.inner.load_balancers(inp);
            self
        }
        pub fn set_load_balancers(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::LoadBalancer>>,
        ) -> Self {
            self.inner = self.inner.set_load_balancers(input);
            self
        }
        /// <p>The details of the service discovery registries to assign to this task set. For more
        /// information, see <a href="https://docs.aws.amazon.com/AmazonECS/latest/developerguide/service-discovery.html">Service
        /// Discovery</a>.</p>
        pub fn service_registries(mut self, inp: impl Into<crate::model::ServiceRegistry>) -> Self {
            self.inner = self.inner.service_registries(inp);
            self
        }
        pub fn set_service_registries(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ServiceRegistry>>,
        ) -> Self {
            self.inner = self.inner.set_service_registries(input);
            self
        }
        /// <p>The launch type that new tasks in the task set will use. For more information, see
        /// <a href="https://docs.aws.amazon.com/AmazonECS/latest/developerguide/launch_types.html">Amazon ECS Launch Types</a> in the <i>Amazon Elastic Container Service Developer Guide</i>.</p>
        /// <p>If a <code>launchType</code> is specified, the <code>capacityProviderStrategy</code>
        /// parameter must be omitted.</p>
        pub fn launch_type(mut self, input: crate::model::LaunchType) -> Self {
            self.inner = self.inner.launch_type(input);
            self
        }
        pub fn set_launch_type(
            mut self,
            input: std::option::Option<crate::model::LaunchType>,
        ) -> Self {
            self.inner = self.inner.set_launch_type(input);
            self
        }
        /// <p>The capacity provider strategy to use for the task set.</p>
        /// <p>A capacity provider strategy consists of one or more capacity providers along with the
        /// <code>base</code> and <code>weight</code> to assign to them. A capacity provider
        /// must be associated with the cluster to be used in a capacity provider strategy. The
        /// <a>PutClusterCapacityProviders</a> API is used to associate a capacity
        /// provider with a cluster. Only capacity providers with an <code>ACTIVE</code> or
        /// <code>UPDATING</code> status can be used.</p>
        /// <p>If a <code>capacityProviderStrategy</code> is specified, the <code>launchType</code>
        /// parameter must be omitted. If no <code>capacityProviderStrategy</code> or
        /// <code>launchType</code> is specified, the
        /// <code>defaultCapacityProviderStrategy</code> for the cluster is used.</p>
        /// <p>If specifying a capacity provider that uses an Auto Scaling group, the capacity
        /// provider must already be created. New capacity providers can be created with the <a>CreateCapacityProvider</a> API operation.</p>
        /// <p>To use a AWS Fargate capacity provider, specify either the <code>FARGATE</code> or
        /// <code>FARGATE_SPOT</code> capacity providers. The AWS Fargate capacity providers are
        /// available to all accounts and only need to be associated with a cluster to be
        /// used.</p>
        /// <p>The <a>PutClusterCapacityProviders</a> API operation is used to update the
        /// list of available capacity providers for a cluster after the cluster is created.</p>
        pub fn capacity_provider_strategy(
            mut self,
            inp: impl Into<crate::model::CapacityProviderStrategyItem>,
        ) -> Self {
            self.inner = self.inner.capacity_provider_strategy(inp);
            self
        }
        pub fn set_capacity_provider_strategy(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::CapacityProviderStrategyItem>>,
        ) -> Self {
            self.inner = self.inner.set_capacity_provider_strategy(input);
            self
        }
        /// <p>The platform version that the tasks in the task set should use. A platform version is
        /// specified only for tasks using the Fargate launch type. If one isn't
        /// specified, the <code>LATEST</code> platform version is used by default.</p>
        pub fn platform_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.platform_version(input);
            self
        }
        pub fn set_platform_version(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_platform_version(input);
            self
        }
        /// <p>A floating-point percentage of the desired number of tasks to place and keep running
        /// in the task set.</p>
        pub fn scale(mut self, input: crate::model::Scale) -> Self {
            self.inner = self.inner.scale(input);
            self
        }
        pub fn set_scale(mut self, input: std::option::Option<crate::model::Scale>) -> Self {
            self.inner = self.inner.set_scale(input);
            self
        }
        /// <p>Unique, case-sensitive identifier that you provide to ensure the idempotency of the
        /// request. Up to 32 ASCII characters are allowed.</p>
        pub fn client_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.client_token(input);
            self
        }
        pub fn set_client_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_client_token(input);
            self
        }
        /// <p>The metadata that you apply to the task set to help you categorize and organize them.
        /// Each tag consists of a key and an optional value, both of which you define. When a
        /// service is deleted, the tags are deleted as well.</p>
        /// <p>The following basic restrictions apply to tags:</p>
        /// <ul>
        /// <li>
        /// <p>Maximum number of tags per resource - 50</p>
        /// </li>
        /// <li>
        /// <p>For each resource, each tag key must be unique, and each tag key can have only
        /// one value.</p>
        /// </li>
        /// <li>
        /// <p>Maximum key length - 128 Unicode characters in UTF-8</p>
        /// </li>
        /// <li>
        /// <p>Maximum value length - 256 Unicode characters in UTF-8</p>
        /// </li>
        /// <li>
        /// <p>If your tagging schema is used across multiple services and resources,
        /// remember that other services may have restrictions on allowed characters.
        /// Generally allowed characters are: letters, numbers, and spaces representable in
        /// UTF-8, and the following characters: + - = . _ : / @.</p>
        /// </li>
        /// <li>
        /// <p>Tag keys and values are case-sensitive.</p>
        /// </li>
        /// <li>
        /// <p>Do not use <code>aws:</code>, <code>AWS:</code>, or any upper or lowercase
        /// combination of such as a prefix for either keys or values as it is reserved for
        /// AWS use. You cannot edit or delete tag keys or values with this prefix. Tags with
        /// this prefix do not count against your tags per resource limit.</p>
        /// </li>
        /// </ul>
        pub fn tags(mut self, inp: impl Into<crate::model::Tag>) -> Self {
            self.inner = self.inner.tags(inp);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteAccountSetting<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_account_setting_input::Builder,
    }
    impl<C> DeleteAccountSetting<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteAccountSettingOutput,
            smithy_http::result::SdkError<crate::error::DeleteAccountSettingError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The resource name for which to disable the account setting. If
        /// <code>serviceLongArnFormat</code> is specified, the ARN for your Amazon ECS services is
        /// affected. If <code>taskLongArnFormat</code> is specified, the ARN and resource ID for
        /// your Amazon ECS tasks is affected. If <code>containerInstanceLongArnFormat</code> is
        /// specified, the ARN and resource ID for your Amazon ECS container instances is affected. If
        /// <code>awsvpcTrunking</code> is specified, the ENI limit for your Amazon ECS container
        /// instances is affected.</p>
        pub fn name(mut self, input: crate::model::SettingName) -> Self {
            self.inner = self.inner.name(input);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<crate::model::SettingName>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
        /// <p>The ARN of the principal, which can be an IAM user, IAM role, or the root user. If you
        /// specify the root user, it disables the account setting for all IAM users, IAM roles, and
        /// the root user of the account unless an IAM user or role explicitly overrides these
        /// settings. If this field is omitted, the setting is changed only for the authenticated
        /// user.</p>
        pub fn principal_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.principal_arn(input);
            self
        }
        pub fn set_principal_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_principal_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteAttributes<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_attributes_input::Builder,
    }
    impl<C> DeleteAttributes<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteAttributesOutput,
            smithy_http::result::SdkError<crate::error::DeleteAttributesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The short name or full Amazon Resource Name (ARN) of the cluster that contains the resource to delete
        /// attributes. If you do not specify a cluster, the default cluster is assumed.</p>
        pub fn cluster(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.cluster(input);
            self
        }
        pub fn set_cluster(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_cluster(input);
            self
        }
        /// <p>The attributes to delete from your resource. You can specify up to 10 attributes per
        /// request. For custom attributes, specify the attribute name and target ID, but do not
        /// specify the value. If you specify the target ID using the short form, you must also
        /// specify the target type.</p>
        pub fn attributes(mut self, inp: impl Into<crate::model::Attribute>) -> Self {
            self.inner = self.inner.attributes(inp);
            self
        }
        pub fn set_attributes(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Attribute>>,
        ) -> Self {
            self.inner = self.inner.set_attributes(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteCapacityProvider<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_capacity_provider_input::Builder,
    }
    impl<C> DeleteCapacityProvider<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteCapacityProviderOutput,
            smithy_http::result::SdkError<crate::error::DeleteCapacityProviderError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The short name or full Amazon Resource Name (ARN) of the capacity provider to delete.</p>
        pub fn capacity_provider(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.capacity_provider(input);
            self
        }
        pub fn set_capacity_provider(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_capacity_provider(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteCluster<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_cluster_input::Builder,
    }
    impl<C> DeleteCluster<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteClusterOutput,
            smithy_http::result::SdkError<crate::error::DeleteClusterError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The short name or full Amazon Resource Name (ARN) of the cluster to delete.</p>
        pub fn cluster(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.cluster(input);
            self
        }
        pub fn set_cluster(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_cluster(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteService<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_service_input::Builder,
    }
    impl<C> DeleteService<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteServiceOutput,
            smithy_http::result::SdkError<crate::error::DeleteServiceError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The short name or full Amazon Resource Name (ARN) of the cluster that hosts the service to delete.
        /// If you do not specify a cluster, the default cluster is assumed.</p>
        pub fn cluster(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.cluster(input);
            self
        }
        pub fn set_cluster(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_cluster(input);
            self
        }
        /// <p>The name of the service to delete.</p>
        pub fn service(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.service(input);
            self
        }
        pub fn set_service(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_service(input);
            self
        }
        /// <p>If <code>true</code>, allows you to delete a service even if it has not been scaled
        /// down to zero tasks. It is only necessary to use this if the service is using the
        /// <code>REPLICA</code> scheduling strategy.</p>
        pub fn force(mut self, input: bool) -> Self {
            self.inner = self.inner.force(input);
            self
        }
        pub fn set_force(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_force(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteTaskSet<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_task_set_input::Builder,
    }
    impl<C> DeleteTaskSet<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteTaskSetOutput,
            smithy_http::result::SdkError<crate::error::DeleteTaskSetError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The short name or full Amazon Resource Name (ARN) of the cluster that hosts the service that the task
        /// set exists in to delete.</p>
        pub fn cluster(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.cluster(input);
            self
        }
        pub fn set_cluster(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_cluster(input);
            self
        }
        /// <p>The short name or full Amazon Resource Name (ARN) of the service that hosts the task set to
        /// delete.</p>
        pub fn service(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.service(input);
            self
        }
        pub fn set_service(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_service(input);
            self
        }
        /// <p>The task set ID or full Amazon Resource Name (ARN) of the task set to delete.</p>
        pub fn task_set(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.task_set(input);
            self
        }
        pub fn set_task_set(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_task_set(input);
            self
        }
        /// <p>If <code>true</code>, this allows you to delete a task set even if it hasn't been
        /// scaled down to zero.</p>
        pub fn force(mut self, input: bool) -> Self {
            self.inner = self.inner.force(input);
            self
        }
        pub fn set_force(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_force(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeregisterContainerInstance<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::deregister_container_instance_input::Builder,
    }
    impl<C> DeregisterContainerInstance<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeregisterContainerInstanceOutput,
            smithy_http::result::SdkError<crate::error::DeregisterContainerInstanceError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The short name or full Amazon Resource Name (ARN) of the cluster that hosts the container instance to
        /// deregister. If you do not specify a cluster, the default cluster is assumed.</p>
        pub fn cluster(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.cluster(input);
            self
        }
        pub fn set_cluster(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_cluster(input);
            self
        }
        /// <p>The container instance ID or full ARN of the container instance to deregister.
        /// The ARN contains the <code>arn:aws:ecs</code> namespace, followed by the Region of the container instance, the AWS account ID of the container instance owner, the <code>container-instance</code> namespace, and then the container instance ID. For example, <code>arn:aws:ecs:region:aws_account_id:container-instance/container_instance_ID</code>.</p>
        pub fn container_instance(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.container_instance(input);
            self
        }
        pub fn set_container_instance(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_container_instance(input);
            self
        }
        /// <p>Forces the deregistration of the container instance. If you have tasks running on the
        /// container instance when you deregister it with the <code>force</code> option, these
        /// tasks remain running until you terminate the instance or the tasks stop through some
        /// other means, but they are orphaned (no longer monitored or accounted for by Amazon ECS). If
        /// an orphaned task on your container instance is part of an Amazon ECS service, then the
        /// service scheduler starts another copy of that task, on a different container instance if
        /// possible. </p>
        /// <p>Any containers in orphaned service tasks that are registered with a Classic Load Balancer or an Application Load Balancer
        /// target group are deregistered. They begin connection draining according to the settings
        /// on the load balancer or target group.</p>
        pub fn force(mut self, input: bool) -> Self {
            self.inner = self.inner.force(input);
            self
        }
        pub fn set_force(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_force(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeregisterTaskDefinition<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::deregister_task_definition_input::Builder,
    }
    impl<C> DeregisterTaskDefinition<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeregisterTaskDefinitionOutput,
            smithy_http::result::SdkError<crate::error::DeregisterTaskDefinitionError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The <code>family</code> and <code>revision</code> (<code>family:revision</code>) or
        /// full Amazon Resource Name (ARN) of the task definition to deregister. You must specify a
        /// <code>revision</code>.</p>
        pub fn task_definition(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.task_definition(input);
            self
        }
        pub fn set_task_definition(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_task_definition(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeCapacityProviders<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_capacity_providers_input::Builder,
    }
    impl<C> DescribeCapacityProviders<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeCapacityProvidersOutput,
            smithy_http::result::SdkError<crate::error::DescribeCapacityProvidersError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The short name or full Amazon Resource Name (ARN) of one or more capacity providers. Up to
        /// <code>100</code> capacity providers can be described in an action.</p>
        pub fn capacity_providers(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.capacity_providers(inp);
            self
        }
        pub fn set_capacity_providers(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_capacity_providers(input);
            self
        }
        /// <p>Specifies whether or not you want to see the resource tags for the capacity provider.
        /// If <code>TAGS</code> is specified, the tags are included in the response. If this field
        /// is omitted, tags are not included in the response.</p>
        pub fn include(mut self, inp: impl Into<crate::model::CapacityProviderField>) -> Self {
            self.inner = self.inner.include(inp);
            self
        }
        pub fn set_include(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::CapacityProviderField>>,
        ) -> Self {
            self.inner = self.inner.set_include(input);
            self
        }
        /// <p>The maximum number of account setting results returned by
        /// <code>DescribeCapacityProviders</code> in paginated output. When this parameter is
        /// used, <code>DescribeCapacityProviders</code> only returns <code>maxResults</code>
        /// results in a single page along with a <code>nextToken</code> response element. The
        /// remaining results of the initial request can be seen by sending another
        /// <code>DescribeCapacityProviders</code> request with the returned
        /// <code>nextToken</code> value. This value can be between
        /// 1 and 10. If this
        /// parameter is not used, then <code>DescribeCapacityProviders</code> returns up to
        /// 10 results and a <code>nextToken</code> value
        /// if applicable.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>The <code>nextToken</code> value returned from a previous paginated
        /// <code>DescribeCapacityProviders</code> request where <code>maxResults</code> was
        /// used and the results exceeded the value of that parameter. Pagination continues from the
        /// end of the previous results that returned the <code>nextToken</code> value.</p>
        /// <note>
        /// <p>This token should be treated as an opaque identifier that is only used to
        /// retrieve the next items in a list and not for other programmatic purposes.</p>
        /// </note>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeClusters<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_clusters_input::Builder,
    }
    impl<C> DescribeClusters<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeClustersOutput,
            smithy_http::result::SdkError<crate::error::DescribeClustersError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>A list of up to 100 cluster names or full cluster Amazon Resource Name (ARN) entries.
        /// If you do not specify a cluster, the default cluster is assumed.</p>
        pub fn clusters(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.clusters(inp);
            self
        }
        pub fn set_clusters(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_clusters(input);
            self
        }
        /// <p>Whether to include additional information about the clusters in the response. If this
        /// field is omitted, this information isn't included.</p>
        /// <p>If <code>ATTACHMENTS</code> is specified, the attachments for the container instances
        /// or tasks within the cluster are included.</p>
        /// <p>If <code>SETTINGS</code> is specified, the settings for the cluster are
        /// included.</p>
        /// <p>If <code>STATISTICS</code> is specified, the task and service count is included,
        /// separated by launch type.</p>
        /// <p>If <code>TAGS</code> is specified, the metadata tags associated with the cluster are
        /// included.</p>
        pub fn include(mut self, inp: impl Into<crate::model::ClusterField>) -> Self {
            self.inner = self.inner.include(inp);
            self
        }
        pub fn set_include(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ClusterField>>,
        ) -> Self {
            self.inner = self.inner.set_include(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeContainerInstances<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_container_instances_input::Builder,
    }
    impl<C> DescribeContainerInstances<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeContainerInstancesOutput,
            smithy_http::result::SdkError<crate::error::DescribeContainerInstancesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The short name or full Amazon Resource Name (ARN) of the cluster that hosts the container instances to
        /// describe. If you do not specify a cluster, the default cluster is assumed. This parameter is required if the container instance
        /// or container instances you are describing were launched in any cluster other than the
        /// default cluster.</p>
        pub fn cluster(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.cluster(input);
            self
        }
        pub fn set_cluster(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_cluster(input);
            self
        }
        /// <p>A list of up to 100 container instance IDs or full Amazon Resource Name (ARN) entries.</p>
        pub fn container_instances(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.container_instances(inp);
            self
        }
        pub fn set_container_instances(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_container_instances(input);
            self
        }
        /// <p>Specifies whether you want to see the resource tags for the container instance. If
        /// <code>TAGS</code> is specified, the tags are included in the response. If this field
        /// is omitted, tags are not included in the response.</p>
        pub fn include(mut self, inp: impl Into<crate::model::ContainerInstanceField>) -> Self {
            self.inner = self.inner.include(inp);
            self
        }
        pub fn set_include(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ContainerInstanceField>>,
        ) -> Self {
            self.inner = self.inner.set_include(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeServices<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_services_input::Builder,
    }
    impl<C> DescribeServices<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeServicesOutput,
            smithy_http::result::SdkError<crate::error::DescribeServicesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The short name or full Amazon Resource Name (ARN)the cluster that hosts the service to describe.
        /// If you do not specify a cluster, the default cluster is assumed. This parameter is required if the service or services you are
        /// describing were launched in any cluster other than the default cluster.</p>
        pub fn cluster(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.cluster(input);
            self
        }
        pub fn set_cluster(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_cluster(input);
            self
        }
        /// <p>A list of services to describe. You may specify up to 10 services to describe in a
        /// single operation.</p>
        pub fn services(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.services(inp);
            self
        }
        pub fn set_services(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_services(input);
            self
        }
        /// <p>Specifies whether you want to see the resource tags for the service. If
        /// <code>TAGS</code> is specified, the tags are included in the response. If this field
        /// is omitted, tags are not included in the response.</p>
        pub fn include(mut self, inp: impl Into<crate::model::ServiceField>) -> Self {
            self.inner = self.inner.include(inp);
            self
        }
        pub fn set_include(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ServiceField>>,
        ) -> Self {
            self.inner = self.inner.set_include(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeTaskDefinition<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_task_definition_input::Builder,
    }
    impl<C> DescribeTaskDefinition<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeTaskDefinitionOutput,
            smithy_http::result::SdkError<crate::error::DescribeTaskDefinitionError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The <code>family</code> for the latest <code>ACTIVE</code> revision,
        /// <code>family</code> and <code>revision</code> (<code>family:revision</code>) for a
        /// specific revision in the family, or full Amazon Resource Name (ARN) of the task definition to
        /// describe.</p>
        pub fn task_definition(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.task_definition(input);
            self
        }
        pub fn set_task_definition(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_task_definition(input);
            self
        }
        /// <p>Specifies whether to see the resource tags for the task definition. If
        /// <code>TAGS</code> is specified, the tags are included in the response. If this field
        /// is omitted, tags are not included in the response.</p>
        pub fn include(mut self, inp: impl Into<crate::model::TaskDefinitionField>) -> Self {
            self.inner = self.inner.include(inp);
            self
        }
        pub fn set_include(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::TaskDefinitionField>>,
        ) -> Self {
            self.inner = self.inner.set_include(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeTasks<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_tasks_input::Builder,
    }
    impl<C> DescribeTasks<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeTasksOutput,
            smithy_http::result::SdkError<crate::error::DescribeTasksError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The short name or full Amazon Resource Name (ARN) of the cluster that hosts the task or tasks to
        /// describe. If you do not specify a cluster, the default cluster is assumed. This parameter is required if the task or tasks you
        /// are describing were launched in any cluster other than the default cluster.</p>
        pub fn cluster(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.cluster(input);
            self
        }
        pub fn set_cluster(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_cluster(input);
            self
        }
        /// <p>A list of up to 100 task IDs or full ARN entries.</p>
        pub fn tasks(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.tasks(inp);
            self
        }
        pub fn set_tasks(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_tasks(input);
            self
        }
        /// <p>Specifies whether you want to see the resource tags for the task. If <code>TAGS</code>
        /// is specified, the tags are included in the response. If this field is omitted, tags are
        /// not included in the response.</p>
        pub fn include(mut self, inp: impl Into<crate::model::TaskField>) -> Self {
            self.inner = self.inner.include(inp);
            self
        }
        pub fn set_include(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::TaskField>>,
        ) -> Self {
            self.inner = self.inner.set_include(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeTaskSets<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_task_sets_input::Builder,
    }
    impl<C> DescribeTaskSets<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeTaskSetsOutput,
            smithy_http::result::SdkError<crate::error::DescribeTaskSetsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The short name or full Amazon Resource Name (ARN) of the cluster that hosts the service that the task
        /// sets exist in.</p>
        pub fn cluster(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.cluster(input);
            self
        }
        pub fn set_cluster(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_cluster(input);
            self
        }
        /// <p>The short name or full Amazon Resource Name (ARN) of the service that the task sets exist in.</p>
        pub fn service(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.service(input);
            self
        }
        pub fn set_service(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_service(input);
            self
        }
        /// <p>The ID or full Amazon Resource Name (ARN) of task sets to
        /// describe.</p>
        pub fn task_sets(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.task_sets(inp);
            self
        }
        pub fn set_task_sets(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_task_sets(input);
            self
        }
        /// <p>Specifies whether to see the resource tags for the task set. If <code>TAGS</code> is
        /// specified, the tags are included in the response. If this field is omitted, tags are not
        /// included in the response.</p>
        pub fn include(mut self, inp: impl Into<crate::model::TaskSetField>) -> Self {
            self.inner = self.inner.include(inp);
            self
        }
        pub fn set_include(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::TaskSetField>>,
        ) -> Self {
            self.inner = self.inner.set_include(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DiscoverPollEndpoint<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::discover_poll_endpoint_input::Builder,
    }
    impl<C> DiscoverPollEndpoint<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DiscoverPollEndpointOutput,
            smithy_http::result::SdkError<crate::error::DiscoverPollEndpointError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The container instance ID or full ARN of the container instance.
        /// The ARN contains the <code>arn:aws:ecs</code> namespace, followed by the Region of the container instance, the AWS account ID of the container instance owner, the <code>container-instance</code> namespace, and then the container instance ID. For example, <code>arn:aws:ecs:region:aws_account_id:container-instance/container_instance_ID</code>.</p>
        pub fn container_instance(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.container_instance(input);
            self
        }
        pub fn set_container_instance(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_container_instance(input);
            self
        }
        /// <p>The short name or full Amazon Resource Name (ARN) of the cluster to which the container instance
        /// belongs.</p>
        pub fn cluster(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.cluster(input);
            self
        }
        pub fn set_cluster(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_cluster(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ExecuteCommand<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::execute_command_input::Builder,
    }
    impl<C> ExecuteCommand<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ExecuteCommandOutput,
            smithy_http::result::SdkError<crate::error::ExecuteCommandError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) or short name of the cluster the task is running in.
        /// If you do not specify a cluster, the default cluster is assumed.</p>
        pub fn cluster(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.cluster(input);
            self
        }
        pub fn set_cluster(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_cluster(input);
            self
        }
        /// <p>The name of the container to execute the command on. A container name only needs to be
        /// specified for tasks containing multiple containers.</p>
        pub fn container(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.container(input);
            self
        }
        pub fn set_container(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_container(input);
            self
        }
        /// <p>The command to run on the container.</p>
        pub fn command(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.command(input);
            self
        }
        pub fn set_command(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_command(input);
            self
        }
        /// <p>Use this flag to run your command in interactive mode.</p>
        pub fn interactive(mut self, input: bool) -> Self {
            self.inner = self.inner.interactive(input);
            self
        }
        pub fn set_interactive(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_interactive(input);
            self
        }
        /// <p>The Amazon Resource Name (ARN) or ID of the task the container is part of.</p>
        pub fn task(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.task(input);
            self
        }
        pub fn set_task(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_task(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListAccountSettings<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_account_settings_input::Builder,
    }
    impl<C> ListAccountSettings<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListAccountSettingsOutput,
            smithy_http::result::SdkError<crate::error::ListAccountSettingsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the account setting you want to list the settings for.</p>
        pub fn name(mut self, input: crate::model::SettingName) -> Self {
            self.inner = self.inner.name(input);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<crate::model::SettingName>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
        /// <p>The value of the account settings with which to filter results. You must also specify
        /// an account setting name to use this parameter.</p>
        pub fn value(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.value(input);
            self
        }
        pub fn set_value(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_value(input);
            self
        }
        /// <p>The ARN of the principal, which can be an IAM user, IAM role, or the root user. If
        /// this field is omitted, the account settings are listed only for the authenticated
        /// user.</p>
        /// <note>
        /// <p>Federated users assume the account setting of the root user and can't have
        /// explicit account settings set for them.</p>
        /// </note>
        pub fn principal_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.principal_arn(input);
            self
        }
        pub fn set_principal_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_principal_arn(input);
            self
        }
        /// <p>Specifies whether to return the effective settings. If <code>true</code>, the account
        /// settings for the root user or the default setting for the <code>principalArn</code> are
        /// returned. If <code>false</code>, the account settings for the <code>principalArn</code>
        /// are returned if they are set. Otherwise, no account settings are returned.</p>
        pub fn effective_settings(mut self, input: bool) -> Self {
            self.inner = self.inner.effective_settings(input);
            self
        }
        pub fn set_effective_settings(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_effective_settings(input);
            self
        }
        /// <p>The <code>nextToken</code> value returned from a <code>ListAccountSettings</code>
        /// request indicating that more results are available to fulfill the request and further
        /// calls will be needed. If <code>maxResults</code> was provided, it is possible the number
        /// of results to be fewer than <code>maxResults</code>.</p>
        /// <note>
        /// <p>This token should be treated as an opaque identifier that is only used to
        /// retrieve the next items in a list and not for other programmatic purposes.</p>
        /// </note>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>The maximum number of account setting results returned by
        /// <code>ListAccountSettings</code> in paginated output. When this parameter is used,
        /// <code>ListAccountSettings</code> only returns <code>maxResults</code> results in a
        /// single page along with a <code>nextToken</code> response element. The remaining results
        /// of the initial request can be seen by sending another <code>ListAccountSettings</code>
        /// request with the returned <code>nextToken</code> value. This value can be between
        /// 1 and 10. If this
        /// parameter is not used, then <code>ListAccountSettings</code> returns up to
        /// 10 results and a <code>nextToken</code> value
        /// if applicable.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListAttributes<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_attributes_input::Builder,
    }
    impl<C> ListAttributes<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListAttributesOutput,
            smithy_http::result::SdkError<crate::error::ListAttributesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The short name or full Amazon Resource Name (ARN) of the cluster to list attributes.
        /// If you do not specify a cluster, the default cluster is assumed.</p>
        pub fn cluster(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.cluster(input);
            self
        }
        pub fn set_cluster(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_cluster(input);
            self
        }
        /// <p>The type of the target with which to list attributes.</p>
        pub fn target_type(mut self, input: crate::model::TargetType) -> Self {
            self.inner = self.inner.target_type(input);
            self
        }
        pub fn set_target_type(
            mut self,
            input: std::option::Option<crate::model::TargetType>,
        ) -> Self {
            self.inner = self.inner.set_target_type(input);
            self
        }
        /// <p>The name of the attribute with which to filter the results. </p>
        pub fn attribute_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.attribute_name(input);
            self
        }
        pub fn set_attribute_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_attribute_name(input);
            self
        }
        /// <p>The value of the attribute with which to filter results. You must also specify an
        /// attribute name to use this parameter.</p>
        pub fn attribute_value(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.attribute_value(input);
            self
        }
        pub fn set_attribute_value(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_attribute_value(input);
            self
        }
        /// <p>The <code>nextToken</code> value returned from a <code>ListAttributes</code> request
        /// indicating that more results are available to fulfill the request and further calls will
        /// be needed. If <code>maxResults</code> was provided, it is possible the number of results
        /// to be fewer than <code>maxResults</code>.</p>
        /// <note>
        /// <p>This token should be treated as an opaque identifier that is only used to
        /// retrieve the next items in a list and not for other programmatic purposes.</p>
        /// </note>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>The maximum number of cluster results returned by <code>ListAttributes</code> in
        /// paginated output. When this parameter is used, <code>ListAttributes</code> only returns
        /// <code>maxResults</code> results in a single page along with a <code>nextToken</code>
        /// response element. The remaining results of the initial request can be seen by sending
        /// another <code>ListAttributes</code> request with the returned <code>nextToken</code>
        /// value. This value can be between 1 and 100. If this
        /// parameter is not used, then <code>ListAttributes</code> returns up to
        /// 100 results and a <code>nextToken</code> value if applicable.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListClusters<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_clusters_input::Builder,
    }
    impl<C> ListClusters<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListClustersOutput,
            smithy_http::result::SdkError<crate::error::ListClustersError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The <code>nextToken</code> value returned from a <code>ListClusters</code> request
        /// indicating that more results are available to fulfill the request and further calls will
        /// be needed. If <code>maxResults</code> was provided, it is possible the number of results
        /// to be fewer than <code>maxResults</code>.</p>
        /// <note>
        /// <p>This token should be treated as an opaque identifier that is only used to
        /// retrieve the next items in a list and not for other programmatic purposes.</p>
        /// </note>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>The maximum number of cluster results returned by <code>ListClusters</code> in
        /// paginated output. When this parameter is used, <code>ListClusters</code> only returns
        /// <code>maxResults</code> results in a single page along with a <code>nextToken</code>
        /// response element. The remaining results of the initial request can be seen by sending
        /// another <code>ListClusters</code> request with the returned <code>nextToken</code>
        /// value. This value can be between 1 and 100. If this
        /// parameter is not used, then <code>ListClusters</code> returns up to
        /// 100 results and a <code>nextToken</code> value if applicable.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListContainerInstances<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_container_instances_input::Builder,
    }
    impl<C> ListContainerInstances<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListContainerInstancesOutput,
            smithy_http::result::SdkError<crate::error::ListContainerInstancesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The short name or full Amazon Resource Name (ARN) of the cluster that hosts the container instances to
        /// list. If you do not specify a cluster, the default cluster is assumed.</p>
        pub fn cluster(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.cluster(input);
            self
        }
        pub fn set_cluster(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_cluster(input);
            self
        }
        /// <p>You can filter the results of a <code>ListContainerInstances</code> operation with
        /// cluster query language statements. For more information, see <a href="https://docs.aws.amazon.com/AmazonECS/latest/developerguide/cluster-query-language.html">Cluster Query Language</a> in the
        /// <i>Amazon Elastic Container Service Developer Guide</i>.</p>
        pub fn filter(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.filter(input);
            self
        }
        pub fn set_filter(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_filter(input);
            self
        }
        /// <p>The <code>nextToken</code> value returned from a <code>ListContainerInstances</code>
        /// request indicating that more results are available to fulfill the request and further
        /// calls will be needed. If <code>maxResults</code> was provided, it is possible the number
        /// of results to be fewer than <code>maxResults</code>.</p>
        /// <note>
        /// <p>This token should be treated as an opaque identifier that is only used to
        /// retrieve the next items in a list and not for other programmatic purposes.</p>
        /// </note>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>The maximum number of container instance results returned by
        /// <code>ListContainerInstances</code> in paginated output. When this parameter is
        /// used, <code>ListContainerInstances</code> only returns <code>maxResults</code> results
        /// in a single page along with a <code>nextToken</code> response element. The remaining
        /// results of the initial request can be seen by sending another
        /// <code>ListContainerInstances</code> request with the returned <code>nextToken</code>
        /// value. This value can be between 1 and 100. If this
        /// parameter is not used, then <code>ListContainerInstances</code> returns up to
        /// 100 results and a <code>nextToken</code> value if applicable.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>Filters the container instances by status. For example, if you specify the
        /// <code>DRAINING</code> status, the results include only container instances that have
        /// been set to <code>DRAINING</code> using <a>UpdateContainerInstancesState</a>.
        /// If you do not specify this parameter, the default is to include container instances set
        /// to all states other than <code>INACTIVE</code>.</p>
        pub fn status(mut self, input: crate::model::ContainerInstanceStatus) -> Self {
            self.inner = self.inner.status(input);
            self
        }
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::ContainerInstanceStatus>,
        ) -> Self {
            self.inner = self.inner.set_status(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListServices<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_services_input::Builder,
    }
    impl<C> ListServices<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListServicesOutput,
            smithy_http::result::SdkError<crate::error::ListServicesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The short name or full Amazon Resource Name (ARN) of the cluster to use when filtering the
        /// <code>ListServices</code> results. If you do not specify a cluster, the default cluster is assumed.</p>
        pub fn cluster(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.cluster(input);
            self
        }
        pub fn set_cluster(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_cluster(input);
            self
        }
        /// <p>The <code>nextToken</code> value returned from a <code>ListServices</code> request
        /// indicating that more results are available to fulfill the request and further calls will
        /// be needed. If <code>maxResults</code> was provided, it is possible the number of results
        /// to be fewer than <code>maxResults</code>.</p>
        /// <note>
        /// <p>This token should be treated as an opaque identifier that is only used to
        /// retrieve the next items in a list and not for other programmatic purposes.</p>
        /// </note>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>The maximum number of service results returned by <code>ListServices</code> in
        /// paginated output. When this parameter is used, <code>ListServices</code> only returns
        /// <code>maxResults</code> results in a single page along with a <code>nextToken</code>
        /// response element. The remaining results of the initial request can be seen by sending
        /// another <code>ListServices</code> request with the returned <code>nextToken</code>
        /// value. This value can be between 1 and 100. If
        /// this parameter is not used, then <code>ListServices</code> returns up to
        /// 10 results and a <code>nextToken</code> value if
        /// applicable.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>The launch type to use when filtering the <code>ListServices</code> results.</p>
        pub fn launch_type(mut self, input: crate::model::LaunchType) -> Self {
            self.inner = self.inner.launch_type(input);
            self
        }
        pub fn set_launch_type(
            mut self,
            input: std::option::Option<crate::model::LaunchType>,
        ) -> Self {
            self.inner = self.inner.set_launch_type(input);
            self
        }
        /// <p>The scheduling strategy to use when filtering the <code>ListServices</code>
        /// results.</p>
        pub fn scheduling_strategy(mut self, input: crate::model::SchedulingStrategy) -> Self {
            self.inner = self.inner.scheduling_strategy(input);
            self
        }
        pub fn set_scheduling_strategy(
            mut self,
            input: std::option::Option<crate::model::SchedulingStrategy>,
        ) -> Self {
            self.inner = self.inner.set_scheduling_strategy(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListTagsForResource<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_tags_for_resource_input::Builder,
    }
    impl<C> ListTagsForResource<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListTagsForResourceOutput,
            smithy_http::result::SdkError<crate::error::ListTagsForResourceError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) that identifies the resource for which to list the tags. Currently, the
        /// supported resources are Amazon ECS tasks, services, task definitions, clusters, and container
        /// instances.</p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resource_arn(input);
            self
        }
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_resource_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListTaskDefinitionFamilies<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_task_definition_families_input::Builder,
    }
    impl<C> ListTaskDefinitionFamilies<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListTaskDefinitionFamiliesOutput,
            smithy_http::result::SdkError<crate::error::ListTaskDefinitionFamiliesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The <code>familyPrefix</code> is a string that is used to filter the results of
        /// <code>ListTaskDefinitionFamilies</code>. If you specify a <code>familyPrefix</code>,
        /// only task definition family names that begin with the <code>familyPrefix</code> string
        /// are returned.</p>
        pub fn family_prefix(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.family_prefix(input);
            self
        }
        pub fn set_family_prefix(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_family_prefix(input);
            self
        }
        /// <p>The task definition family status with which to filter the
        /// <code>ListTaskDefinitionFamilies</code> results. By default, both
        /// <code>ACTIVE</code> and <code>INACTIVE</code> task definition families are listed.
        /// If this parameter is set to <code>ACTIVE</code>, only task definition families that have
        /// an <code>ACTIVE</code> task definition revision are returned. If this parameter is set
        /// to <code>INACTIVE</code>, only task definition families that do not have any
        /// <code>ACTIVE</code> task definition revisions are returned. If you paginate the
        /// resulting output, be sure to keep the <code>status</code> value constant in each
        /// subsequent request.</p>
        pub fn status(mut self, input: crate::model::TaskDefinitionFamilyStatus) -> Self {
            self.inner = self.inner.status(input);
            self
        }
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::TaskDefinitionFamilyStatus>,
        ) -> Self {
            self.inner = self.inner.set_status(input);
            self
        }
        /// <p>The <code>nextToken</code> value returned from a
        /// <code>ListTaskDefinitionFamilies</code> request indicating that more results are
        /// available to fulfill the request and further calls will be needed. If
        /// <code>maxResults</code> was provided, it is possible the number of results to be
        /// fewer than <code>maxResults</code>.</p>
        /// <note>
        /// <p>This token should be treated as an opaque identifier that is only used to
        /// retrieve the next items in a list and not for other programmatic purposes.</p>
        /// </note>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>The maximum number of task definition family results returned by
        /// <code>ListTaskDefinitionFamilies</code> in paginated output. When this parameter is
        /// used, <code>ListTaskDefinitions</code> only returns <code>maxResults</code> results in a
        /// single page along with a <code>nextToken</code> response element. The remaining results
        /// of the initial request can be seen by sending another
        /// <code>ListTaskDefinitionFamilies</code> request with the returned
        /// <code>nextToken</code> value. This value can be between 1 and
        /// 100. If this parameter is not used, then
        /// <code>ListTaskDefinitionFamilies</code> returns up to 100 results
        /// and a <code>nextToken</code> value if applicable.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListTaskDefinitions<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_task_definitions_input::Builder,
    }
    impl<C> ListTaskDefinitions<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListTaskDefinitionsOutput,
            smithy_http::result::SdkError<crate::error::ListTaskDefinitionsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The full family name with which to filter the <code>ListTaskDefinitions</code>
        /// results. Specifying a <code>familyPrefix</code> limits the listed task definitions to
        /// task definition revisions that belong to that family.</p>
        pub fn family_prefix(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.family_prefix(input);
            self
        }
        pub fn set_family_prefix(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_family_prefix(input);
            self
        }
        /// <p>The task definition status with which to filter the <code>ListTaskDefinitions</code>
        /// results. By default, only <code>ACTIVE</code> task definitions are listed. By setting
        /// this parameter to <code>INACTIVE</code>, you can view task definitions that are
        /// <code>INACTIVE</code> as long as an active task or service still references them. If
        /// you paginate the resulting output, be sure to keep the <code>status</code> value
        /// constant in each subsequent request.</p>
        pub fn status(mut self, input: crate::model::TaskDefinitionStatus) -> Self {
            self.inner = self.inner.status(input);
            self
        }
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::TaskDefinitionStatus>,
        ) -> Self {
            self.inner = self.inner.set_status(input);
            self
        }
        /// <p>The order in which to sort the results. Valid values are <code>ASC</code> and
        /// <code>DESC</code>. By default (<code>ASC</code>), task definitions are listed
        /// lexicographically by family name and in ascending numerical order by revision so that
        /// the newest task definitions in a family are listed last. Setting this parameter to
        /// <code>DESC</code> reverses the sort order on family name and revision so that the
        /// newest task definitions in a family are listed first.</p>
        pub fn sort(mut self, input: crate::model::SortOrder) -> Self {
            self.inner = self.inner.sort(input);
            self
        }
        pub fn set_sort(mut self, input: std::option::Option<crate::model::SortOrder>) -> Self {
            self.inner = self.inner.set_sort(input);
            self
        }
        /// <p>The <code>nextToken</code> value returned from a <code>ListTaskDefinitions</code>
        /// request indicating that more results are available to fulfill the request and further
        /// calls will be needed. If <code>maxResults</code> was provided, it is possible the number
        /// of results to be fewer than <code>maxResults</code>.</p>
        /// <note>
        /// <p>This token should be treated as an opaque identifier that is only used to
        /// retrieve the next items in a list and not for other programmatic purposes.</p>
        /// </note>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>The maximum number of task definition results returned by
        /// <code>ListTaskDefinitions</code> in paginated output. When this parameter is used,
        /// <code>ListTaskDefinitions</code> only returns <code>maxResults</code> results in a
        /// single page along with a <code>nextToken</code> response element. The remaining results
        /// of the initial request can be seen by sending another <code>ListTaskDefinitions</code>
        /// request with the returned <code>nextToken</code> value. This value can be between
        /// 1 and 100. If this parameter is not used, then
        /// <code>ListTaskDefinitions</code> returns up to 100 results and a
        /// <code>nextToken</code> value if applicable.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListTasks<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_tasks_input::Builder,
    }
    impl<C> ListTasks<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListTasksOutput,
            smithy_http::result::SdkError<crate::error::ListTasksError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The short name or full Amazon Resource Name (ARN) of the cluster to use when filtering the
        /// <code>ListTasks</code> results. If you do not specify a cluster, the default cluster is assumed.</p>
        pub fn cluster(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.cluster(input);
            self
        }
        pub fn set_cluster(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_cluster(input);
            self
        }
        /// <p>The container instance ID or full ARN of the container instance to use when
        /// filtering the <code>ListTasks</code> results. Specifying a
        /// <code>containerInstance</code> limits the results to tasks that belong to that
        /// container instance.</p>
        pub fn container_instance(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.container_instance(input);
            self
        }
        pub fn set_container_instance(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_container_instance(input);
            self
        }
        /// <p>The name of the task definition family to use when filtering the
        /// <code>ListTasks</code> results. Specifying a <code>family</code> limits the results
        /// to tasks that belong to that family.</p>
        pub fn family(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.family(input);
            self
        }
        pub fn set_family(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_family(input);
            self
        }
        /// <p>The <code>nextToken</code> value returned from a <code>ListTasks</code> request
        /// indicating that more results are available to fulfill the request and further calls will
        /// be needed. If <code>maxResults</code> was provided, it is possible the number of results
        /// to be fewer than <code>maxResults</code>.</p>
        /// <note>
        /// <p>This token should be treated as an opaque identifier that is only used to
        /// retrieve the next items in a list and not for other programmatic purposes.</p>
        /// </note>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>The maximum number of task results returned by <code>ListTasks</code> in paginated
        /// output. When this parameter is used, <code>ListTasks</code> only returns
        /// <code>maxResults</code> results in a single page along with a <code>nextToken</code>
        /// response element. The remaining results of the initial request can be seen by sending
        /// another <code>ListTasks</code> request with the returned <code>nextToken</code> value.
        /// This value can be between 1 and 100. If this parameter is
        /// not used, then <code>ListTasks</code> returns up to 100 results and a
        /// <code>nextToken</code> value if applicable.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>The <code>startedBy</code> value with which to filter the task results. Specifying a
        /// <code>startedBy</code> value limits the results to tasks that were started with that
        /// value.</p>
        pub fn started_by(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.started_by(input);
            self
        }
        pub fn set_started_by(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_started_by(input);
            self
        }
        /// <p>The name of the service to use when filtering the <code>ListTasks</code> results.
        /// Specifying a <code>serviceName</code> limits the results to tasks that belong to that
        /// service.</p>
        pub fn service_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.service_name(input);
            self
        }
        pub fn set_service_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_service_name(input);
            self
        }
        /// <p>The task desired status to use when filtering the <code>ListTasks</code> results.
        /// Specifying a <code>desiredStatus</code> of <code>STOPPED</code> limits the results to
        /// tasks that Amazon ECS has set the desired status to <code>STOPPED</code>. This can be useful
        /// for debugging tasks that are not starting properly or have died or finished. The default
        /// status filter is <code>RUNNING</code>, which shows tasks that Amazon ECS has set the desired
        /// status to <code>RUNNING</code>.</p>
        /// <note>
        /// <p>Although you can filter results based on a desired status of <code>PENDING</code>,
        /// this does not return any results. Amazon ECS never sets the desired status of a task to
        /// that value (only a task's <code>lastStatus</code> may have a value of
        /// <code>PENDING</code>).</p>
        /// </note>
        pub fn desired_status(mut self, input: crate::model::DesiredStatus) -> Self {
            self.inner = self.inner.desired_status(input);
            self
        }
        pub fn set_desired_status(
            mut self,
            input: std::option::Option<crate::model::DesiredStatus>,
        ) -> Self {
            self.inner = self.inner.set_desired_status(input);
            self
        }
        /// <p>The launch type to use when filtering the <code>ListTasks</code> results.</p>
        pub fn launch_type(mut self, input: crate::model::LaunchType) -> Self {
            self.inner = self.inner.launch_type(input);
            self
        }
        pub fn set_launch_type(
            mut self,
            input: std::option::Option<crate::model::LaunchType>,
        ) -> Self {
            self.inner = self.inner.set_launch_type(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct PutAccountSetting<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::put_account_setting_input::Builder,
    }
    impl<C> PutAccountSetting<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::PutAccountSettingOutput,
            smithy_http::result::SdkError<crate::error::PutAccountSettingError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon ECS resource name for which to modify the account setting. If
        /// <code>serviceLongArnFormat</code> is specified, the ARN for your Amazon ECS services is
        /// affected. If <code>taskLongArnFormat</code> is specified, the ARN and resource ID for
        /// your Amazon ECS tasks is affected. If <code>containerInstanceLongArnFormat</code> is
        /// specified, the ARN and resource ID for your Amazon ECS container instances is affected. If
        /// <code>awsvpcTrunking</code> is specified, the elastic network interface (ENI) limit
        /// for your Amazon ECS container instances is affected. If <code>containerInsights</code> is
        /// specified, the default setting for CloudWatch Container Insights for your clusters is
        /// affected.</p>
        pub fn name(mut self, input: crate::model::SettingName) -> Self {
            self.inner = self.inner.name(input);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<crate::model::SettingName>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
        /// <p>The account setting value for the specified principal ARN. Accepted values are
        /// <code>enabled</code> and <code>disabled</code>.</p>
        pub fn value(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.value(input);
            self
        }
        pub fn set_value(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_value(input);
            self
        }
        /// <p>The ARN of the principal, which can be an IAM user, IAM role, or the root user. If you
        /// specify the root user, it modifies the account setting for all IAM users, IAM roles, and
        /// the root user of the account unless an IAM user or role explicitly overrides these
        /// settings. If this field is omitted, the setting is changed only for the authenticated
        /// user.</p>
        /// <note>
        /// <p>Federated users assume the account setting of the root user and can't have
        /// explicit account settings set for them.</p>
        /// </note>
        pub fn principal_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.principal_arn(input);
            self
        }
        pub fn set_principal_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_principal_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct PutAccountSettingDefault<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::put_account_setting_default_input::Builder,
    }
    impl<C> PutAccountSettingDefault<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::PutAccountSettingDefaultOutput,
            smithy_http::result::SdkError<crate::error::PutAccountSettingDefaultError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The resource name for which to modify the account setting. If
        /// <code>serviceLongArnFormat</code> is specified, the ARN for your Amazon ECS services is
        /// affected. If <code>taskLongArnFormat</code> is specified, the ARN and resource ID for
        /// your Amazon ECS tasks is affected. If <code>containerInstanceLongArnFormat</code> is
        /// specified, the ARN and resource ID for your Amazon ECS container instances is affected. If
        /// <code>awsvpcTrunking</code> is specified, the ENI limit for your Amazon ECS container
        /// instances is affected. If <code>containerInsights</code> is specified, the default
        /// setting for CloudWatch Container Insights for your clusters is affected.</p>
        pub fn name(mut self, input: crate::model::SettingName) -> Self {
            self.inner = self.inner.name(input);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<crate::model::SettingName>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
        /// <p>The account setting value for the specified principal ARN. Accepted values are
        /// <code>enabled</code> and <code>disabled</code>.</p>
        pub fn value(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.value(input);
            self
        }
        pub fn set_value(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_value(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct PutAttributes<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::put_attributes_input::Builder,
    }
    impl<C> PutAttributes<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::PutAttributesOutput,
            smithy_http::result::SdkError<crate::error::PutAttributesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The short name or full Amazon Resource Name (ARN) of the cluster that contains the resource to apply
        /// attributes. If you do not specify a cluster, the default cluster is assumed.</p>
        pub fn cluster(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.cluster(input);
            self
        }
        pub fn set_cluster(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_cluster(input);
            self
        }
        /// <p>The attributes to apply to your resource. You can specify up to 10 custom attributes
        /// per resource. You can specify up to 10 attributes in a single call.</p>
        pub fn attributes(mut self, inp: impl Into<crate::model::Attribute>) -> Self {
            self.inner = self.inner.attributes(inp);
            self
        }
        pub fn set_attributes(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Attribute>>,
        ) -> Self {
            self.inner = self.inner.set_attributes(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct PutClusterCapacityProviders<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::put_cluster_capacity_providers_input::Builder,
    }
    impl<C> PutClusterCapacityProviders<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::PutClusterCapacityProvidersOutput,
            smithy_http::result::SdkError<crate::error::PutClusterCapacityProvidersError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The short name or full Amazon Resource Name (ARN) of the cluster to modify the capacity provider
        /// settings for. If you do not specify a cluster, the default cluster is assumed.</p>
        pub fn cluster(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.cluster(input);
            self
        }
        pub fn set_cluster(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_cluster(input);
            self
        }
        /// <p>The name of one or more capacity providers to associate with the cluster.</p>
        /// <p>If specifying a capacity provider that uses an Auto Scaling group, the capacity
        /// provider must already be created. New capacity providers can be created with the <a>CreateCapacityProvider</a> API operation.</p>
        /// <p>To use a AWS Fargate capacity provider, specify either the <code>FARGATE</code> or
        /// <code>FARGATE_SPOT</code> capacity providers. The AWS Fargate capacity providers are
        /// available to all accounts and only need to be associated with a cluster to be
        /// used.</p>
        pub fn capacity_providers(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.capacity_providers(inp);
            self
        }
        pub fn set_capacity_providers(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_capacity_providers(input);
            self
        }
        /// <p>The capacity provider strategy to use by default for the cluster.</p>
        /// <p>When creating a service or running a task on a cluster, if no capacity provider or
        /// launch type is specified then the default capacity provider strategy for the cluster is
        /// used.</p>
        /// <p>A capacity provider strategy consists of one or more capacity providers along with the
        /// <code>base</code> and <code>weight</code> to assign to them. A capacity provider
        /// must be associated with the cluster to be used in a capacity provider strategy. The
        /// <a>PutClusterCapacityProviders</a> API is used to associate a capacity
        /// provider with a cluster. Only capacity providers with an <code>ACTIVE</code> or
        /// <code>UPDATING</code> status can be used.</p>
        /// <p>If specifying a capacity provider that uses an Auto Scaling group, the capacity
        /// provider must already be created. New capacity providers can be created with the <a>CreateCapacityProvider</a> API operation.</p>
        /// <p>To use a AWS Fargate capacity provider, specify either the <code>FARGATE</code> or
        /// <code>FARGATE_SPOT</code> capacity providers. The AWS Fargate capacity providers are
        /// available to all accounts and only need to be associated with a cluster to be
        /// used.</p>
        pub fn default_capacity_provider_strategy(
            mut self,
            inp: impl Into<crate::model::CapacityProviderStrategyItem>,
        ) -> Self {
            self.inner = self.inner.default_capacity_provider_strategy(inp);
            self
        }
        pub fn set_default_capacity_provider_strategy(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::CapacityProviderStrategyItem>>,
        ) -> Self {
            self.inner = self.inner.set_default_capacity_provider_strategy(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct RegisterContainerInstance<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::register_container_instance_input::Builder,
    }
    impl<C> RegisterContainerInstance<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::RegisterContainerInstanceOutput,
            smithy_http::result::SdkError<crate::error::RegisterContainerInstanceError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The short name or full Amazon Resource Name (ARN) of the cluster with which to register your container
        /// instance. If you do not specify a cluster, the default cluster is assumed.</p>
        pub fn cluster(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.cluster(input);
            self
        }
        pub fn set_cluster(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_cluster(input);
            self
        }
        /// <p>The instance identity document for the EC2 instance to register. This document can be
        /// found by running the following command from the instance: <code>curl
        /// http://169.254.169.254/latest/dynamic/instance-identity/document/</code>
        /// </p>
        pub fn instance_identity_document(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.instance_identity_document(input);
            self
        }
        pub fn set_instance_identity_document(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_instance_identity_document(input);
            self
        }
        /// <p>The instance identity document signature for the EC2 instance to register. This
        /// signature can be found by running the following command from the instance: <code>curl
        /// http://169.254.169.254/latest/dynamic/instance-identity/signature/</code>
        /// </p>
        pub fn instance_identity_document_signature(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.instance_identity_document_signature(input);
            self
        }
        pub fn set_instance_identity_document_signature(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_instance_identity_document_signature(input);
            self
        }
        /// <p>The resources available on the instance.</p>
        pub fn total_resources(mut self, inp: impl Into<crate::model::Resource>) -> Self {
            self.inner = self.inner.total_resources(inp);
            self
        }
        pub fn set_total_resources(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Resource>>,
        ) -> Self {
            self.inner = self.inner.set_total_resources(input);
            self
        }
        /// <p>The version information for the Amazon ECS container agent and Docker daemon running on the
        /// container instance.</p>
        pub fn version_info(mut self, input: crate::model::VersionInfo) -> Self {
            self.inner = self.inner.version_info(input);
            self
        }
        pub fn set_version_info(
            mut self,
            input: std::option::Option<crate::model::VersionInfo>,
        ) -> Self {
            self.inner = self.inner.set_version_info(input);
            self
        }
        /// <p>The ARN of the container instance (if it was previously registered).</p>
        pub fn container_instance_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.container_instance_arn(input);
            self
        }
        pub fn set_container_instance_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_container_instance_arn(input);
            self
        }
        /// <p>The container instance attributes that this container instance supports.</p>
        pub fn attributes(mut self, inp: impl Into<crate::model::Attribute>) -> Self {
            self.inner = self.inner.attributes(inp);
            self
        }
        pub fn set_attributes(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Attribute>>,
        ) -> Self {
            self.inner = self.inner.set_attributes(input);
            self
        }
        /// <p>The devices that are available on the container instance. The only supported device
        /// type is a GPU.</p>
        pub fn platform_devices(mut self, inp: impl Into<crate::model::PlatformDevice>) -> Self {
            self.inner = self.inner.platform_devices(inp);
            self
        }
        pub fn set_platform_devices(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::PlatformDevice>>,
        ) -> Self {
            self.inner = self.inner.set_platform_devices(input);
            self
        }
        /// <p>The metadata that you apply to the container instance to help you categorize and
        /// organize them. Each tag consists of a key and an optional value, both of which you
        /// define.</p>
        /// <p>The following basic restrictions apply to tags:</p>
        /// <ul>
        /// <li>
        /// <p>Maximum number of tags per resource - 50</p>
        /// </li>
        /// <li>
        /// <p>For each resource, each tag key must be unique, and each tag key can have only
        /// one value.</p>
        /// </li>
        /// <li>
        /// <p>Maximum key length - 128 Unicode characters in UTF-8</p>
        /// </li>
        /// <li>
        /// <p>Maximum value length - 256 Unicode characters in UTF-8</p>
        /// </li>
        /// <li>
        /// <p>If your tagging schema is used across multiple services and resources,
        /// remember that other services may have restrictions on allowed characters.
        /// Generally allowed characters are: letters, numbers, and spaces representable in
        /// UTF-8, and the following characters: + - = . _ : / @.</p>
        /// </li>
        /// <li>
        /// <p>Tag keys and values are case-sensitive.</p>
        /// </li>
        /// <li>
        /// <p>Do not use <code>aws:</code>, <code>AWS:</code>, or any upper or lowercase
        /// combination of such as a prefix for either keys or values as it is reserved for
        /// AWS use. You cannot edit or delete tag keys or values with this prefix. Tags with
        /// this prefix do not count against your tags per resource limit.</p>
        /// </li>
        /// </ul>
        pub fn tags(mut self, inp: impl Into<crate::model::Tag>) -> Self {
            self.inner = self.inner.tags(inp);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct RegisterTaskDefinition<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::register_task_definition_input::Builder,
    }
    impl<C> RegisterTaskDefinition<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::RegisterTaskDefinitionOutput,
            smithy_http::result::SdkError<crate::error::RegisterTaskDefinitionError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>You must specify a <code>family</code> for a task definition, which allows you to
        /// track multiple versions of the same task definition. The <code>family</code> is used as
        /// a name for your task definition. Up to 255 letters (uppercase and lowercase), numbers, underscores, and hyphens are allowed.</p>
        pub fn family(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.family(input);
            self
        }
        pub fn set_family(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_family(input);
            self
        }
        /// <p>The short name or full Amazon Resource Name (ARN) of the IAM role that containers in this task can
        /// assume. All containers in this task are granted the permissions that are specified in
        /// this role. For more information, see <a href="https://docs.aws.amazon.com/AmazonECS/latest/developerguide/task-iam-roles.html">IAM Roles for
        /// Tasks</a> in the <i>Amazon Elastic Container Service Developer Guide</i>.</p>
        pub fn task_role_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.task_role_arn(input);
            self
        }
        pub fn set_task_role_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_task_role_arn(input);
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the task execution role that grants the Amazon ECS container agent
        /// permission to make AWS API calls on your behalf. The task execution IAM role is required
        /// depending on the requirements of your task. For more information, see <a href="https://docs.aws.amazon.com/AmazonECS/latest/developerguide/task_execution_IAM_role.html">Amazon ECS task
        /// execution IAM role</a> in the <i>Amazon Elastic Container Service Developer Guide</i>.</p>
        pub fn execution_role_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.execution_role_arn(input);
            self
        }
        pub fn set_execution_role_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_execution_role_arn(input);
            self
        }
        /// <p>The Docker networking mode to use for the containers in the task. The valid values are
        /// <code>none</code>, <code>bridge</code>, <code>awsvpc</code>, and <code>host</code>.
        /// If no network mode is specified, the default is <code>bridge</code>.</p>
        /// <p>For Amazon ECS tasks on Fargate, the <code>awsvpc</code> network mode is required.
        /// For Amazon ECS tasks on Amazon EC2 instances, any network mode can be used. If the network
        /// mode is set to <code>none</code>, you cannot specify port mappings in your container
        /// definitions, and the tasks containers do not have external connectivity. The
        /// <code>host</code> and <code>awsvpc</code> network modes offer the highest networking
        /// performance for containers because they use the EC2 network stack instead of the
        /// virtualized network stack provided by the <code>bridge</code> mode.</p>
        /// <p>With the <code>host</code> and <code>awsvpc</code> network modes, exposed container
        /// ports are mapped directly to the corresponding host port (for the <code>host</code>
        /// network mode) or the attached elastic network interface port (for the
        /// <code>awsvpc</code> network mode), so you cannot take advantage of dynamic host port
        /// mappings. </p>
        /// <important>
        /// <p>When using the <code>host</code> network mode, you should not run
        /// containers using the root user (UID 0). It is considered best practice
        /// to use a non-root user.</p>
        /// </important>
        /// <p>If the network mode is <code>awsvpc</code>, the task is allocated an elastic network
        /// interface, and you must specify a <a>NetworkConfiguration</a> value when you create
        /// a service or run a task with the task definition. For more information, see <a href="https://docs.aws.amazon.com/AmazonECS/latest/developerguide/task-networking.html">Task Networking</a> in the
        /// <i>Amazon Elastic Container Service Developer Guide</i>.</p>
        /// <note>
        /// <p>Currently, only Amazon ECS-optimized AMIs, other Amazon Linux variants with the
        /// <code>ecs-init</code> package, or AWS Fargate infrastructure support the
        /// <code>awsvpc</code> network mode. </p>
        /// </note>
        /// <p>If the network mode is <code>host</code>, you cannot run multiple instantiations of the
        /// same task on a single container instance when port mappings are used.</p>
        /// <p>Docker for Windows uses different network modes than Docker for Linux. When you
        /// register a task definition with Windows containers, you must not specify a network mode.
        /// If you use the console to register a task definition with Windows containers, you must
        /// choose the <code><default></code> network mode object. </p>
        /// <p>For more information, see <a href="https://docs.docker.com/engine/reference/run/#network-settings">Network
        /// settings</a> in the <i>Docker run reference</i>.</p>
        pub fn network_mode(mut self, input: crate::model::NetworkMode) -> Self {
            self.inner = self.inner.network_mode(input);
            self
        }
        pub fn set_network_mode(
            mut self,
            input: std::option::Option<crate::model::NetworkMode>,
        ) -> Self {
            self.inner = self.inner.set_network_mode(input);
            self
        }
        /// <p>A list of container definitions in JSON format that describe the different containers
        /// that make up your task.</p>
        pub fn container_definitions(
            mut self,
            inp: impl Into<crate::model::ContainerDefinition>,
        ) -> Self {
            self.inner = self.inner.container_definitions(inp);
            self
        }
        pub fn set_container_definitions(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ContainerDefinition>>,
        ) -> Self {
            self.inner = self.inner.set_container_definitions(input);
            self
        }
        /// <p>A list of volume definitions in JSON format that containers in your task may
        /// use.</p>
        pub fn volumes(mut self, inp: impl Into<crate::model::Volume>) -> Self {
            self.inner = self.inner.volumes(inp);
            self
        }
        pub fn set_volumes(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Volume>>,
        ) -> Self {
            self.inner = self.inner.set_volumes(input);
            self
        }
        /// <p>An array of placement constraint objects to use for the task. You can specify a
        /// maximum of 10 constraints per task (this limit includes constraints in the task
        /// definition and those specified at runtime).</p>
        pub fn placement_constraints(
            mut self,
            inp: impl Into<crate::model::TaskDefinitionPlacementConstraint>,
        ) -> Self {
            self.inner = self.inner.placement_constraints(inp);
            self
        }
        pub fn set_placement_constraints(
            mut self,
            input: std::option::Option<
                std::vec::Vec<crate::model::TaskDefinitionPlacementConstraint>,
            >,
        ) -> Self {
            self.inner = self.inner.set_placement_constraints(input);
            self
        }
        /// <p>The task launch type that Amazon ECS should validate the task definition against. A client
        /// exception is returned if the task definition doesn't validate against the
        /// compatibilities specified. If no value is specified, the parameter is omitted from the
        /// response.</p>
        pub fn requires_compatibilities(
            mut self,
            inp: impl Into<crate::model::Compatibility>,
        ) -> Self {
            self.inner = self.inner.requires_compatibilities(inp);
            self
        }
        pub fn set_requires_compatibilities(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Compatibility>>,
        ) -> Self {
            self.inner = self.inner.set_requires_compatibilities(input);
            self
        }
        /// <p>The number of CPU units used by the task. It can be expressed as an integer using CPU
        /// units, for example <code>1024</code>, or as a string using vCPUs, for example <code>1
        /// vCPU</code> or <code>1 vcpu</code>, in a task definition. String values are
        /// converted to an integer indicating the CPU units when the task definition is
        /// registered.</p>
        /// <note>
        /// <p>Task-level CPU and memory parameters are ignored for Windows containers. We
        /// recommend specifying container-level resources for Windows containers.</p>
        /// </note>
        /// <p>If you are using the EC2 launch type, this field is optional. Supported
        /// values are between <code>128</code> CPU units (<code>0.125</code> vCPUs) and
        /// <code>10240</code> CPU units (<code>10</code> vCPUs).</p>
        /// <p>If you are using the Fargate launch type, this field is required and you
        /// must use one of the following values, which determines your range of supported values
        /// for the <code>memory</code> parameter:</p>
        /// <ul>
        /// <li>
        /// <p>256 (.25 vCPU) - Available <code>memory</code> values: 512 (0.5 GB), 1024 (1 GB), 2048 (2 GB)</p>
        /// </li>
        /// <li>
        /// <p>512 (.5 vCPU) - Available <code>memory</code> values: 1024 (1 GB), 2048 (2 GB), 3072 (3 GB), 4096 (4 GB)</p>
        /// </li>
        /// <li>
        /// <p>1024 (1 vCPU) - Available <code>memory</code> values: 2048 (2 GB), 3072 (3 GB), 4096 (4 GB), 5120 (5 GB), 6144 (6 GB), 7168 (7 GB), 8192 (8 GB)</p>
        /// </li>
        /// <li>
        /// <p>2048 (2 vCPU) - Available <code>memory</code> values: Between 4096 (4 GB) and 16384 (16 GB) in increments of 1024 (1 GB)</p>
        /// </li>
        /// <li>
        /// <p>4096 (4 vCPU) - Available <code>memory</code> values: Between 8192 (8 GB) and 30720 (30 GB) in increments of 1024 (1 GB)</p>
        /// </li>
        /// </ul>
        pub fn cpu(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.cpu(input);
            self
        }
        pub fn set_cpu(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_cpu(input);
            self
        }
        /// <p>The amount of memory (in MiB) used by the task. It can be expressed as an integer
        /// using MiB, for example <code>1024</code>, or as a string using GB, for example
        /// <code>1GB</code> or <code>1 GB</code>, in a task definition. String values are
        /// converted to an integer indicating the MiB when the task definition is
        /// registered.</p>
        /// <note>
        /// <p>Task-level CPU and memory parameters are ignored for Windows containers. We
        /// recommend specifying container-level resources for Windows containers.</p>
        /// </note>
        /// <p>If using the EC2 launch type, this field is optional.</p>
        /// <p>If using the Fargate launch type, this field is required and you must
        /// use one of the following values, which determines your range of supported values for the
        /// <code>cpu</code> parameter:</p>
        /// <ul>
        /// <li>
        /// <p>512 (0.5 GB), 1024 (1 GB), 2048 (2 GB) - Available <code>cpu</code> values: 256 (.25 vCPU)</p>
        /// </li>
        /// <li>
        /// <p>1024 (1 GB), 2048 (2 GB), 3072 (3 GB), 4096 (4 GB) - Available <code>cpu</code> values: 512 (.5 vCPU)</p>
        /// </li>
        /// <li>
        /// <p>2048 (2 GB), 3072 (3 GB), 4096 (4 GB), 5120 (5 GB), 6144 (6 GB), 7168 (7 GB), 8192 (8 GB) - Available <code>cpu</code> values: 1024 (1 vCPU)</p>
        /// </li>
        /// <li>
        /// <p>Between 4096 (4 GB) and 16384 (16 GB) in increments of 1024 (1 GB) - Available <code>cpu</code> values: 2048 (2 vCPU)</p>
        /// </li>
        /// <li>
        /// <p>Between 8192 (8 GB) and 30720 (30 GB) in increments of 1024 (1 GB) - Available <code>cpu</code> values: 4096 (4 vCPU)</p>
        /// </li>
        /// </ul>
        pub fn memory(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.memory(input);
            self
        }
        pub fn set_memory(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_memory(input);
            self
        }
        /// <p>The metadata that you apply to the task definition to help you categorize and organize
        /// them. Each tag consists of a key and an optional value, both of which you define.</p>
        /// <p>The following basic restrictions apply to tags:</p>
        /// <ul>
        /// <li>
        /// <p>Maximum number of tags per resource - 50</p>
        /// </li>
        /// <li>
        /// <p>For each resource, each tag key must be unique, and each tag key can have only
        /// one value.</p>
        /// </li>
        /// <li>
        /// <p>Maximum key length - 128 Unicode characters in UTF-8</p>
        /// </li>
        /// <li>
        /// <p>Maximum value length - 256 Unicode characters in UTF-8</p>
        /// </li>
        /// <li>
        /// <p>If your tagging schema is used across multiple services and resources,
        /// remember that other services may have restrictions on allowed characters.
        /// Generally allowed characters are: letters, numbers, and spaces representable in
        /// UTF-8, and the following characters: + - = . _ : / @.</p>
        /// </li>
        /// <li>
        /// <p>Tag keys and values are case-sensitive.</p>
        /// </li>
        /// <li>
        /// <p>Do not use <code>aws:</code>, <code>AWS:</code>, or any upper or lowercase
        /// combination of such as a prefix for either keys or values as it is reserved for
        /// AWS use. You cannot edit or delete tag keys or values with this prefix. Tags with
        /// this prefix do not count against your tags per resource limit.</p>
        /// </li>
        /// </ul>
        pub fn tags(mut self, inp: impl Into<crate::model::Tag>) -> Self {
            self.inner = self.inner.tags(inp);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
        /// <p>The process namespace to use for the containers in the task. The valid
        /// values are <code>host</code> or <code>task</code>. If <code>host</code>
        /// is specified, then all containers within the tasks that specified the
        /// <code>host</code> PID mode on the same container instance share the
        /// same process namespace with the host Amazon EC2 instance. If <code>task</code> is
        /// specified, all containers within the specified task share the same
        /// process namespace. If no value is specified, the default is a private
        /// namespace. For more information, see <a href="https://docs.docker.com/engine/reference/run/#pid-settings---pid">PID settings</a> in the <i>Docker run
        /// reference</i>.</p>
        /// <p>If the <code>host</code> PID mode is used, be aware that there is a
        /// heightened risk of undesired process namespace expose. For more
        /// information, see <a href="https://docs.docker.com/engine/security/security/">Docker
        /// security</a>.</p>
        /// <note>
        /// <p>This parameter is not supported for Windows containers or tasks run on AWS Fargate.</p>
        /// </note>
        pub fn pid_mode(mut self, input: crate::model::PidMode) -> Self {
            self.inner = self.inner.pid_mode(input);
            self
        }
        pub fn set_pid_mode(mut self, input: std::option::Option<crate::model::PidMode>) -> Self {
            self.inner = self.inner.set_pid_mode(input);
            self
        }
        /// <p>The IPC resource namespace to use for the containers in the task. The valid values are
        /// <code>host</code>, <code>task</code>, or <code>none</code>. If <code>host</code> is
        /// specified, then all containers within the tasks that specified the <code>host</code> IPC
        /// mode on the same container instance share the same IPC resources with the host Amazon EC2
        /// instance. If <code>task</code> is specified, all containers within the specified task
        /// share the same IPC resources. If <code>none</code> is specified, then IPC resources
        /// within the containers of a task are private and not shared with other containers in a
        /// task or on the container instance. If no value is specified, then the IPC resource
        /// namespace sharing depends on the Docker daemon setting on the container instance. For
        /// more information, see <a href="https://docs.docker.com/engine/reference/run/#ipc-settings---ipc">IPC
        /// settings</a> in the <i>Docker run reference</i>.</p>
        /// <p>If the <code>host</code> IPC mode is used, be aware that there is a heightened risk of
        /// undesired IPC namespace expose. For more information, see <a href="https://docs.docker.com/engine/security/security/">Docker
        /// security</a>.</p>
        /// <p>If you are setting namespaced kernel parameters using <code>systemControls</code> for
        /// the containers in the task, the following will apply to your IPC resource namespace. For
        /// more information, see <a href="https://docs.aws.amazon.com/AmazonECS/latest/developerguide/task_definition_parameters.html">System
        /// Controls</a> in the <i>Amazon Elastic Container Service Developer Guide</i>.</p>
        /// <ul>
        /// <li>
        /// <p>For tasks that use the <code>host</code> IPC mode, IPC namespace related
        /// <code>systemControls</code> are not supported.</p>
        /// </li>
        /// <li>
        /// <p>For tasks that use the <code>task</code> IPC mode, IPC namespace related
        /// <code>systemControls</code> will apply to all containers within a
        /// task.</p>
        /// </li>
        /// </ul>
        /// <note>
        /// <p>This parameter is not supported for Windows containers or tasks run on AWS Fargate.</p>
        /// </note>
        pub fn ipc_mode(mut self, input: crate::model::IpcMode) -> Self {
            self.inner = self.inner.ipc_mode(input);
            self
        }
        pub fn set_ipc_mode(mut self, input: std::option::Option<crate::model::IpcMode>) -> Self {
            self.inner = self.inner.set_ipc_mode(input);
            self
        }
        /// <p>The configuration details for the App Mesh proxy.</p>
        /// <p>For tasks hosted on Amazon EC2 instances, the container instances require at least version
        /// <code>1.26.0</code> of the container agent and at least version
        /// <code>1.26.0-1</code> of the <code>ecs-init</code> package to enable a proxy
        /// configuration. If your container instances are launched from the Amazon ECS-optimized
        /// AMI version <code>20190301</code> or later, then they contain the required versions of
        /// the container agent and <code>ecs-init</code>. For more information, see <a href="https://docs.aws.amazon.com/AmazonECS/latest/developerguide/ecs-ami-versions.html">Amazon ECS-optimized AMI versions</a> in the
        /// <i>Amazon Elastic Container Service Developer Guide</i>.</p>
        pub fn proxy_configuration(mut self, input: crate::model::ProxyConfiguration) -> Self {
            self.inner = self.inner.proxy_configuration(input);
            self
        }
        pub fn set_proxy_configuration(
            mut self,
            input: std::option::Option<crate::model::ProxyConfiguration>,
        ) -> Self {
            self.inner = self.inner.set_proxy_configuration(input);
            self
        }
        /// <p>The Elastic Inference accelerators to use for the containers in the task.</p>
        pub fn inference_accelerators(
            mut self,
            inp: impl Into<crate::model::InferenceAccelerator>,
        ) -> Self {
            self.inner = self.inner.inference_accelerators(inp);
            self
        }
        pub fn set_inference_accelerators(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::InferenceAccelerator>>,
        ) -> Self {
            self.inner = self.inner.set_inference_accelerators(input);
            self
        }
        /// <p>The amount of ephemeral storage to allocate for the task. This parameter is used to
        /// expand the total amount of ephemeral storage available, beyond the default amount, for
        /// tasks hosted on AWS Fargate. For more information, see <a href="https://docs.aws.amazon.com/AmazonECS/latest/userguide/using_data_volumes.html">Fargate task
        /// storage</a> in the <i>Amazon ECS User Guide for AWS Fargate</i>.</p>
        /// <note>
        /// <p>This parameter is only supported for tasks hosted on AWS Fargate using platform
        /// version <code>1.4.0</code> or later.</p>
        /// </note>
        pub fn ephemeral_storage(mut self, input: crate::model::EphemeralStorage) -> Self {
            self.inner = self.inner.ephemeral_storage(input);
            self
        }
        pub fn set_ephemeral_storage(
            mut self,
            input: std::option::Option<crate::model::EphemeralStorage>,
        ) -> Self {
            self.inner = self.inner.set_ephemeral_storage(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct RunTask<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::run_task_input::Builder,
    }
    impl<C> RunTask<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::RunTaskOutput,
            smithy_http::result::SdkError<crate::error::RunTaskError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The capacity provider strategy to use for the task.</p>
        /// <p>If a <code>capacityProviderStrategy</code> is specified, the <code>launchType</code>
        /// parameter must be omitted. If no <code>capacityProviderStrategy</code> or
        /// <code>launchType</code> is specified, the
        /// <code>defaultCapacityProviderStrategy</code> for the cluster is used.</p>
        pub fn capacity_provider_strategy(
            mut self,
            inp: impl Into<crate::model::CapacityProviderStrategyItem>,
        ) -> Self {
            self.inner = self.inner.capacity_provider_strategy(inp);
            self
        }
        pub fn set_capacity_provider_strategy(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::CapacityProviderStrategyItem>>,
        ) -> Self {
            self.inner = self.inner.set_capacity_provider_strategy(input);
            self
        }
        /// <p>The short name or full Amazon Resource Name (ARN) of the cluster on which to run your task.
        /// If you do not specify a cluster, the default cluster is assumed.</p>
        pub fn cluster(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.cluster(input);
            self
        }
        pub fn set_cluster(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_cluster(input);
            self
        }
        /// <p>The number of instantiations of the specified task to place on your cluster. You can
        /// specify up to 10 tasks per call.</p>
        pub fn count(mut self, input: i32) -> Self {
            self.inner = self.inner.count(input);
            self
        }
        pub fn set_count(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_count(input);
            self
        }
        /// <p>Specifies whether to enable Amazon ECS managed tags for the task. For more information, see
        /// <a href="https://docs.aws.amazon.com/AmazonECS/latest/developerguide/ecs-using-tags.html">Tagging Your Amazon ECS
        /// Resources</a> in the <i>Amazon Elastic Container Service Developer Guide</i>.</p>
        pub fn enable_ecs_managed_tags(mut self, input: bool) -> Self {
            self.inner = self.inner.enable_ecs_managed_tags(input);
            self
        }
        pub fn set_enable_ecs_managed_tags(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_enable_ecs_managed_tags(input);
            self
        }
        /// <p>Whether or not to enable the execute command functionality for the containers in this
        /// task. If <code>true</code>, this enables execute command functionality on all containers
        /// in the task.</p>
        pub fn enable_execute_command(mut self, input: bool) -> Self {
            self.inner = self.inner.enable_execute_command(input);
            self
        }
        pub fn set_enable_execute_command(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_enable_execute_command(input);
            self
        }
        /// <p>The name of the task group to associate with the task. The default value is the family
        /// name of the task definition (for example, family:my-family-name).</p>
        pub fn group(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.group(input);
            self
        }
        pub fn set_group(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_group(input);
            self
        }
        /// <p>The infrastructure on which to run your standalone task. For more information, see
        /// <a href="https://docs.aws.amazon.com/AmazonECS/latest/developerguide/launch_types.html">Amazon ECS launch types</a> in the <i>Amazon Elastic Container Service Developer Guide</i>.</p>
        /// <p>The <code>FARGATE</code> launch type runs your tasks on AWS Fargate On-Demand
        /// infrastructure.</p>
        /// <note>
        /// <p>Fargate Spot infrastructure is available for use but a capacity provider
        /// strategy must be used. For more information, see <a href="https://docs.aws.amazon.com/AmazonECS/latest/userguide/fargate-capacity-providers.html">AWS Fargate capacity providers</a> in the
        /// <i>Amazon ECS User Guide for AWS Fargate</i>.</p>
        /// </note>
        /// <p>The <code>EC2</code> launch type runs your tasks on Amazon EC2 instances registered to your
        /// cluster.</p>
        /// <p>The <code>EXTERNAL</code> launch type runs your tasks on your on-premise server or
        /// virtual machine (VM) capacity registered to your cluster.</p>
        /// <p>A task can use either a launch type or a capacity provider strategy. If a
        /// <code>launchType</code> is specified, the <code>capacityProviderStrategy</code>
        /// parameter must be omitted.</p>
        pub fn launch_type(mut self, input: crate::model::LaunchType) -> Self {
            self.inner = self.inner.launch_type(input);
            self
        }
        pub fn set_launch_type(
            mut self,
            input: std::option::Option<crate::model::LaunchType>,
        ) -> Self {
            self.inner = self.inner.set_launch_type(input);
            self
        }
        /// <p>The network configuration for the task. This parameter is required for task
        /// definitions that use the <code>awsvpc</code> network mode to receive their own elastic
        /// network interface, and it is not supported for other network modes. For more
        /// information, see <a href="https://docs.aws.amazon.com/AmazonECS/latest/developerguide/task-networking.html">Task Networking</a>
        /// in the <i>Amazon Elastic Container Service Developer Guide</i>.</p>
        pub fn network_configuration(mut self, input: crate::model::NetworkConfiguration) -> Self {
            self.inner = self.inner.network_configuration(input);
            self
        }
        pub fn set_network_configuration(
            mut self,
            input: std::option::Option<crate::model::NetworkConfiguration>,
        ) -> Self {
            self.inner = self.inner.set_network_configuration(input);
            self
        }
        /// <p>A list of container overrides in JSON format that specify the name of a container in
        /// the specified task definition and the overrides it should receive. You can override the
        /// default command for a container (that is specified in the task definition or Docker
        /// image) with a <code>command</code> override. You can also override existing environment
        /// variables (that are specified in the task definition or Docker image) on a container or
        /// add new environment variables to it with an <code>environment</code> override.</p>
        /// <note>
        /// <p>A total of 8192 characters are allowed for overrides. This limit includes the JSON
        /// formatting characters of the override structure.</p>
        /// </note>
        pub fn overrides(mut self, input: crate::model::TaskOverride) -> Self {
            self.inner = self.inner.overrides(input);
            self
        }
        pub fn set_overrides(
            mut self,
            input: std::option::Option<crate::model::TaskOverride>,
        ) -> Self {
            self.inner = self.inner.set_overrides(input);
            self
        }
        /// <p>An array of placement constraint objects to use for the task. You can specify up to 10
        /// constraints per task (including constraints in the task definition and those specified
        /// at runtime).</p>
        pub fn placement_constraints(
            mut self,
            inp: impl Into<crate::model::PlacementConstraint>,
        ) -> Self {
            self.inner = self.inner.placement_constraints(inp);
            self
        }
        pub fn set_placement_constraints(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::PlacementConstraint>>,
        ) -> Self {
            self.inner = self.inner.set_placement_constraints(input);
            self
        }
        /// <p>The placement strategy objects to use for the task. You can specify a maximum of five
        /// strategy rules per task.</p>
        pub fn placement_strategy(
            mut self,
            inp: impl Into<crate::model::PlacementStrategy>,
        ) -> Self {
            self.inner = self.inner.placement_strategy(inp);
            self
        }
        pub fn set_placement_strategy(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::PlacementStrategy>>,
        ) -> Self {
            self.inner = self.inner.set_placement_strategy(input);
            self
        }
        /// <p>The platform version the task should run. A platform version is only specified for
        /// tasks using the Fargate launch type. If one is not specified, the
        /// <code>LATEST</code> platform version is used by default. For more information, see
        /// <a href="https://docs.aws.amazon.com/AmazonECS/latest/developerguide/platform_versions.html">AWS Fargate Platform
        /// Versions</a> in the <i>Amazon Elastic Container Service Developer Guide</i>.</p>
        pub fn platform_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.platform_version(input);
            self
        }
        pub fn set_platform_version(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_platform_version(input);
            self
        }
        /// <p>Specifies whether to propagate the tags from the task definition to the task. If no
        /// value is specified, the tags are not propagated. Tags can only be propagated to the task
        /// during task creation. To add tags to a task after task creation, use the <a>TagResource</a> API action.</p>
        /// <note>
        /// <p>An error will be received if you specify the <code>SERVICE</code> option when
        /// running a task.</p>
        /// </note>
        pub fn propagate_tags(mut self, input: crate::model::PropagateTags) -> Self {
            self.inner = self.inner.propagate_tags(input);
            self
        }
        pub fn set_propagate_tags(
            mut self,
            input: std::option::Option<crate::model::PropagateTags>,
        ) -> Self {
            self.inner = self.inner.set_propagate_tags(input);
            self
        }
        /// <p>The reference ID to use for the task.</p>
        pub fn reference_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.reference_id(input);
            self
        }
        pub fn set_reference_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_reference_id(input);
            self
        }
        /// <p>An optional tag specified when a task is started. For example, if you automatically
        /// trigger a task to run a batch process job, you could apply a unique identifier for that
        /// job to your task with the <code>startedBy</code> parameter. You can then identify which
        /// tasks belong to that job by filtering the results of a <a>ListTasks</a> call
        /// with the <code>startedBy</code> value. Up to 36 letters (uppercase and lowercase),
        /// numbers, hyphens, and underscores are allowed.</p>
        /// <p>If a task is started by an Amazon ECS service, then the <code>startedBy</code> parameter
        /// contains the deployment ID of the service that starts it.</p>
        pub fn started_by(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.started_by(input);
            self
        }
        pub fn set_started_by(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_started_by(input);
            self
        }
        /// <p>The metadata that you apply to the task to help you categorize and organize them. Each
        /// tag consists of a key and an optional value, both of which you define.</p>
        /// <p>The following basic restrictions apply to tags:</p>
        /// <ul>
        /// <li>
        /// <p>Maximum number of tags per resource - 50</p>
        /// </li>
        /// <li>
        /// <p>For each resource, each tag key must be unique, and each tag key can have only
        /// one value.</p>
        /// </li>
        /// <li>
        /// <p>Maximum key length - 128 Unicode characters in UTF-8</p>
        /// </li>
        /// <li>
        /// <p>Maximum value length - 256 Unicode characters in UTF-8</p>
        /// </li>
        /// <li>
        /// <p>If your tagging schema is used across multiple services and resources,
        /// remember that other services may have restrictions on allowed characters.
        /// Generally allowed characters are: letters, numbers, and spaces representable in
        /// UTF-8, and the following characters: + - = . _ : / @.</p>
        /// </li>
        /// <li>
        /// <p>Tag keys and values are case-sensitive.</p>
        /// </li>
        /// <li>
        /// <p>Do not use <code>aws:</code>, <code>AWS:</code>, or any upper or lowercase
        /// combination of such as a prefix for either keys or values as it is reserved for
        /// AWS use. You cannot edit or delete tag keys or values with this prefix. Tags with
        /// this prefix do not count against your tags per resource limit.</p>
        /// </li>
        /// </ul>
        pub fn tags(mut self, inp: impl Into<crate::model::Tag>) -> Self {
            self.inner = self.inner.tags(inp);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
        /// <p>The <code>family</code> and <code>revision</code> (<code>family:revision</code>) or
        /// full ARN of the task definition to run. If a <code>revision</code> is not specified,
        /// the latest <code>ACTIVE</code> revision is used.</p>
        pub fn task_definition(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.task_definition(input);
            self
        }
        pub fn set_task_definition(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_task_definition(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct StartTask<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::start_task_input::Builder,
    }
    impl<C> StartTask<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::StartTaskOutput,
            smithy_http::result::SdkError<crate::error::StartTaskError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The short name or full Amazon Resource Name (ARN) of the cluster on which to start your task.
        /// If you do not specify a cluster, the default cluster is assumed.</p>
        pub fn cluster(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.cluster(input);
            self
        }
        pub fn set_cluster(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_cluster(input);
            self
        }
        /// <p>The container instance IDs or full ARN entries for the container instances on which
        /// you would like to place your task. You can specify up to 10 container instances.</p>
        pub fn container_instances(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.container_instances(inp);
            self
        }
        pub fn set_container_instances(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_container_instances(input);
            self
        }
        /// <p>Specifies whether to enable Amazon ECS managed tags for the task. For more information, see
        /// <a href="https://docs.aws.amazon.com/AmazonECS/latest/developerguide/ecs-using-tags.html">Tagging Your Amazon ECS
        /// Resources</a> in the <i>Amazon Elastic Container Service Developer Guide</i>.</p>
        pub fn enable_ecs_managed_tags(mut self, input: bool) -> Self {
            self.inner = self.inner.enable_ecs_managed_tags(input);
            self
        }
        pub fn set_enable_ecs_managed_tags(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_enable_ecs_managed_tags(input);
            self
        }
        /// <p>Whether or not the execute command functionality is enabled for the task. If
        /// <code>true</code>, this enables execute command functionality on all containers in
        /// the task.</p>
        pub fn enable_execute_command(mut self, input: bool) -> Self {
            self.inner = self.inner.enable_execute_command(input);
            self
        }
        pub fn set_enable_execute_command(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_enable_execute_command(input);
            self
        }
        /// <p>The name of the task group to associate with the task. The default value is the family
        /// name of the task definition (for example, family:my-family-name).</p>
        pub fn group(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.group(input);
            self
        }
        pub fn set_group(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_group(input);
            self
        }
        /// <p>The VPC subnet and security group configuration for tasks that receive their own
        /// elastic network interface by using the <code>awsvpc</code> networking mode.</p>
        pub fn network_configuration(mut self, input: crate::model::NetworkConfiguration) -> Self {
            self.inner = self.inner.network_configuration(input);
            self
        }
        pub fn set_network_configuration(
            mut self,
            input: std::option::Option<crate::model::NetworkConfiguration>,
        ) -> Self {
            self.inner = self.inner.set_network_configuration(input);
            self
        }
        /// <p>A list of container overrides in JSON format that specify the name of a container in
        /// the specified task definition and the overrides it should receive. You can override the
        /// default command for a container (that is specified in the task definition or Docker
        /// image) with a <code>command</code> override. You can also override existing environment
        /// variables (that are specified in the task definition or Docker image) on a container or
        /// add new environment variables to it with an <code>environment</code> override.</p>
        /// <note>
        /// <p>A total of 8192 characters are allowed for overrides. This limit includes the JSON
        /// formatting characters of the override structure.</p>
        /// </note>
        pub fn overrides(mut self, input: crate::model::TaskOverride) -> Self {
            self.inner = self.inner.overrides(input);
            self
        }
        pub fn set_overrides(
            mut self,
            input: std::option::Option<crate::model::TaskOverride>,
        ) -> Self {
            self.inner = self.inner.set_overrides(input);
            self
        }
        /// <p>Specifies whether to propagate the tags from the task definition or the service to the
        /// task. If no value is specified, the tags are not propagated.</p>
        pub fn propagate_tags(mut self, input: crate::model::PropagateTags) -> Self {
            self.inner = self.inner.propagate_tags(input);
            self
        }
        pub fn set_propagate_tags(
            mut self,
            input: std::option::Option<crate::model::PropagateTags>,
        ) -> Self {
            self.inner = self.inner.set_propagate_tags(input);
            self
        }
        /// <p>The reference ID to use for the task.</p>
        pub fn reference_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.reference_id(input);
            self
        }
        pub fn set_reference_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_reference_id(input);
            self
        }
        /// <p>An optional tag specified when a task is started. For example, if you automatically
        /// trigger a task to run a batch process job, you could apply a unique identifier for that
        /// job to your task with the <code>startedBy</code> parameter. You can then identify which
        /// tasks belong to that job by filtering the results of a <a>ListTasks</a> call
        /// with the <code>startedBy</code> value. Up to 36 letters (uppercase and lowercase),
        /// numbers, hyphens, and underscores are allowed.</p>
        /// <p>If a task is started by an Amazon ECS service, then the <code>startedBy</code> parameter
        /// contains the deployment ID of the service that starts it.</p>
        pub fn started_by(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.started_by(input);
            self
        }
        pub fn set_started_by(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_started_by(input);
            self
        }
        /// <p>The metadata that you apply to the task to help you categorize and organize them. Each
        /// tag consists of a key and an optional value, both of which you define.</p>
        /// <p>The following basic restrictions apply to tags:</p>
        /// <ul>
        /// <li>
        /// <p>Maximum number of tags per resource - 50</p>
        /// </li>
        /// <li>
        /// <p>For each resource, each tag key must be unique, and each tag key can have only
        /// one value.</p>
        /// </li>
        /// <li>
        /// <p>Maximum key length - 128 Unicode characters in UTF-8</p>
        /// </li>
        /// <li>
        /// <p>Maximum value length - 256 Unicode characters in UTF-8</p>
        /// </li>
        /// <li>
        /// <p>If your tagging schema is used across multiple services and resources,
        /// remember that other services may have restrictions on allowed characters.
        /// Generally allowed characters are: letters, numbers, and spaces representable in
        /// UTF-8, and the following characters: + - = . _ : / @.</p>
        /// </li>
        /// <li>
        /// <p>Tag keys and values are case-sensitive.</p>
        /// </li>
        /// <li>
        /// <p>Do not use <code>aws:</code>, <code>AWS:</code>, or any upper or lowercase
        /// combination of such as a prefix for either keys or values as it is reserved for
        /// AWS use. You cannot edit or delete tag keys or values with this prefix. Tags with
        /// this prefix do not count against your tags per resource limit.</p>
        /// </li>
        /// </ul>
        pub fn tags(mut self, inp: impl Into<crate::model::Tag>) -> Self {
            self.inner = self.inner.tags(inp);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
        /// <p>The <code>family</code> and <code>revision</code> (<code>family:revision</code>) or
        /// full ARN of the task definition to start. If a <code>revision</code> is not specified,
        /// the latest <code>ACTIVE</code> revision is used.</p>
        pub fn task_definition(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.task_definition(input);
            self
        }
        pub fn set_task_definition(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_task_definition(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct StopTask<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::stop_task_input::Builder,
    }
    impl<C> StopTask<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::StopTaskOutput,
            smithy_http::result::SdkError<crate::error::StopTaskError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The short name or full Amazon Resource Name (ARN) of the cluster that hosts the task to stop.
        /// If you do not specify a cluster, the default cluster is assumed.</p>
        pub fn cluster(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.cluster(input);
            self
        }
        pub fn set_cluster(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_cluster(input);
            self
        }
        /// <p>The task ID or full Amazon Resource Name (ARN) of the task to stop.</p>
        pub fn task(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.task(input);
            self
        }
        pub fn set_task(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_task(input);
            self
        }
        /// <p>An optional message specified when a task is stopped. For example, if you are using a
        /// custom scheduler, you can use this parameter to specify the reason for stopping the task
        /// here, and the message appears in subsequent <a>DescribeTasks</a> API
        /// operations on this task. Up to 255 characters are allowed in this message.</p>
        pub fn reason(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.reason(input);
            self
        }
        pub fn set_reason(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_reason(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct SubmitAttachmentStateChanges<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::submit_attachment_state_changes_input::Builder,
    }
    impl<C> SubmitAttachmentStateChanges<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::SubmitAttachmentStateChangesOutput,
            smithy_http::result::SdkError<crate::error::SubmitAttachmentStateChangesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The short name or full ARN of the cluster that hosts the container instance the
        /// attachment belongs to.</p>
        pub fn cluster(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.cluster(input);
            self
        }
        pub fn set_cluster(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_cluster(input);
            self
        }
        /// <p>Any attachments associated with the state change request.</p>
        pub fn attachments(mut self, inp: impl Into<crate::model::AttachmentStateChange>) -> Self {
            self.inner = self.inner.attachments(inp);
            self
        }
        pub fn set_attachments(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::AttachmentStateChange>>,
        ) -> Self {
            self.inner = self.inner.set_attachments(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct SubmitContainerStateChange<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::submit_container_state_change_input::Builder,
    }
    impl<C> SubmitContainerStateChange<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::SubmitContainerStateChangeOutput,
            smithy_http::result::SdkError<crate::error::SubmitContainerStateChangeError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The short name or full ARN of the cluster that hosts the container.</p>
        pub fn cluster(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.cluster(input);
            self
        }
        pub fn set_cluster(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_cluster(input);
            self
        }
        /// <p>The task ID or full Amazon Resource Name (ARN) of the task that hosts the container.</p>
        pub fn task(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.task(input);
            self
        }
        pub fn set_task(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_task(input);
            self
        }
        /// <p>The name of the container.</p>
        pub fn container_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.container_name(input);
            self
        }
        pub fn set_container_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_container_name(input);
            self
        }
        /// <p>The ID of the Docker container.</p>
        pub fn runtime_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.runtime_id(input);
            self
        }
        pub fn set_runtime_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_runtime_id(input);
            self
        }
        /// <p>The status of the state change request.</p>
        pub fn status(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.status(input);
            self
        }
        pub fn set_status(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_status(input);
            self
        }
        /// <p>The exit code returned for the state change request.</p>
        pub fn exit_code(mut self, input: i32) -> Self {
            self.inner = self.inner.exit_code(input);
            self
        }
        pub fn set_exit_code(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_exit_code(input);
            self
        }
        /// <p>The reason for the state change request.</p>
        pub fn reason(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.reason(input);
            self
        }
        pub fn set_reason(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_reason(input);
            self
        }
        /// <p>The network bindings of the container.</p>
        pub fn network_bindings(mut self, inp: impl Into<crate::model::NetworkBinding>) -> Self {
            self.inner = self.inner.network_bindings(inp);
            self
        }
        pub fn set_network_bindings(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::NetworkBinding>>,
        ) -> Self {
            self.inner = self.inner.set_network_bindings(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct SubmitTaskStateChange<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::submit_task_state_change_input::Builder,
    }
    impl<C> SubmitTaskStateChange<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::SubmitTaskStateChangeOutput,
            smithy_http::result::SdkError<crate::error::SubmitTaskStateChangeError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The short name or full Amazon Resource Name (ARN) of the cluster that hosts the task.</p>
        pub fn cluster(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.cluster(input);
            self
        }
        pub fn set_cluster(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_cluster(input);
            self
        }
        /// <p>The task ID or full ARN of the task in the state change request.</p>
        pub fn task(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.task(input);
            self
        }
        pub fn set_task(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_task(input);
            self
        }
        /// <p>The status of the state change request.</p>
        pub fn status(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.status(input);
            self
        }
        pub fn set_status(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_status(input);
            self
        }
        /// <p>The reason for the state change request.</p>
        pub fn reason(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.reason(input);
            self
        }
        pub fn set_reason(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_reason(input);
            self
        }
        /// <p>Any containers associated with the state change request.</p>
        pub fn containers(mut self, inp: impl Into<crate::model::ContainerStateChange>) -> Self {
            self.inner = self.inner.containers(inp);
            self
        }
        pub fn set_containers(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ContainerStateChange>>,
        ) -> Self {
            self.inner = self.inner.set_containers(input);
            self
        }
        /// <p>Any attachments associated with the state change request.</p>
        pub fn attachments(mut self, inp: impl Into<crate::model::AttachmentStateChange>) -> Self {
            self.inner = self.inner.attachments(inp);
            self
        }
        pub fn set_attachments(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::AttachmentStateChange>>,
        ) -> Self {
            self.inner = self.inner.set_attachments(input);
            self
        }
        /// <p>The details for the managed agent associated with the task.</p>
        pub fn managed_agents(
            mut self,
            inp: impl Into<crate::model::ManagedAgentStateChange>,
        ) -> Self {
            self.inner = self.inner.managed_agents(inp);
            self
        }
        pub fn set_managed_agents(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ManagedAgentStateChange>>,
        ) -> Self {
            self.inner = self.inner.set_managed_agents(input);
            self
        }
        /// <p>The Unix timestamp for when the container image pull began.</p>
        pub fn pull_started_at(mut self, input: smithy_types::Instant) -> Self {
            self.inner = self.inner.pull_started_at(input);
            self
        }
        pub fn set_pull_started_at(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.inner = self.inner.set_pull_started_at(input);
            self
        }
        /// <p>The Unix timestamp for when the container image pull completed.</p>
        pub fn pull_stopped_at(mut self, input: smithy_types::Instant) -> Self {
            self.inner = self.inner.pull_stopped_at(input);
            self
        }
        pub fn set_pull_stopped_at(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.inner = self.inner.set_pull_stopped_at(input);
            self
        }
        /// <p>The Unix timestamp for when the task execution stopped.</p>
        pub fn execution_stopped_at(mut self, input: smithy_types::Instant) -> Self {
            self.inner = self.inner.execution_stopped_at(input);
            self
        }
        pub fn set_execution_stopped_at(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.inner = self.inner.set_execution_stopped_at(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct TagResource<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::tag_resource_input::Builder,
    }
    impl<C> TagResource<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::TagResourceOutput,
            smithy_http::result::SdkError<crate::error::TagResourceError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the resource to which to add tags. Currently, the supported resources
        /// are Amazon ECS capacity providers, tasks, services, task definitions, clusters, and container
        /// instances.</p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resource_arn(input);
            self
        }
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_resource_arn(input);
            self
        }
        /// <p>The tags to add to the resource. A tag is an array of key-value pairs.</p>
        /// <p>The following basic restrictions apply to tags:</p>
        /// <ul>
        /// <li>
        /// <p>Maximum number of tags per resource - 50</p>
        /// </li>
        /// <li>
        /// <p>For each resource, each tag key must be unique, and each tag key can have only
        /// one value.</p>
        /// </li>
        /// <li>
        /// <p>Maximum key length - 128 Unicode characters in UTF-8</p>
        /// </li>
        /// <li>
        /// <p>Maximum value length - 256 Unicode characters in UTF-8</p>
        /// </li>
        /// <li>
        /// <p>If your tagging schema is used across multiple services and resources,
        /// remember that other services may have restrictions on allowed characters.
        /// Generally allowed characters are: letters, numbers, and spaces representable in
        /// UTF-8, and the following characters: + - = . _ : / @.</p>
        /// </li>
        /// <li>
        /// <p>Tag keys and values are case-sensitive.</p>
        /// </li>
        /// <li>
        /// <p>Do not use <code>aws:</code>, <code>AWS:</code>, or any upper or lowercase
        /// combination of such as a prefix for either keys or values as it is reserved for
        /// AWS use. You cannot edit or delete tag keys or values with this prefix. Tags with
        /// this prefix do not count against your tags per resource limit.</p>
        /// </li>
        /// </ul>
        pub fn tags(mut self, inp: impl Into<crate::model::Tag>) -> Self {
            self.inner = self.inner.tags(inp);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UntagResource<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::untag_resource_input::Builder,
    }
    impl<C> UntagResource<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UntagResourceOutput,
            smithy_http::result::SdkError<crate::error::UntagResourceError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the resource from which to delete tags. Currently, the supported
        /// resources are Amazon ECS capacity providers, tasks, services, task definitions, clusters, and
        /// container instances.</p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resource_arn(input);
            self
        }
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_resource_arn(input);
            self
        }
        /// <p>The keys of the tags to be removed.</p>
        pub fn tag_keys(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.tag_keys(inp);
            self
        }
        pub fn set_tag_keys(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_tag_keys(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateCapacityProvider<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::update_capacity_provider_input::Builder,
    }
    impl<C> UpdateCapacityProvider<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateCapacityProviderOutput,
            smithy_http::result::SdkError<crate::error::UpdateCapacityProviderError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the capacity provider to update.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(input);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
        /// <p>An object representing the parameters to update for the Auto Scaling group capacity
        /// provider.</p>
        pub fn auto_scaling_group_provider(
            mut self,
            input: crate::model::AutoScalingGroupProviderUpdate,
        ) -> Self {
            self.inner = self.inner.auto_scaling_group_provider(input);
            self
        }
        pub fn set_auto_scaling_group_provider(
            mut self,
            input: std::option::Option<crate::model::AutoScalingGroupProviderUpdate>,
        ) -> Self {
            self.inner = self.inner.set_auto_scaling_group_provider(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateCluster<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::update_cluster_input::Builder,
    }
    impl<C> UpdateCluster<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateClusterOutput,
            smithy_http::result::SdkError<crate::error::UpdateClusterError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the cluster to modify the settings for.</p>
        pub fn cluster(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.cluster(input);
            self
        }
        pub fn set_cluster(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_cluster(input);
            self
        }
        /// <p>The cluster settings for your cluster.</p>
        pub fn settings(mut self, inp: impl Into<crate::model::ClusterSetting>) -> Self {
            self.inner = self.inner.settings(inp);
            self
        }
        pub fn set_settings(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ClusterSetting>>,
        ) -> Self {
            self.inner = self.inner.set_settings(input);
            self
        }
        /// <p>The execute command configuration for the cluster.</p>
        pub fn configuration(mut self, input: crate::model::ClusterConfiguration) -> Self {
            self.inner = self.inner.configuration(input);
            self
        }
        pub fn set_configuration(
            mut self,
            input: std::option::Option<crate::model::ClusterConfiguration>,
        ) -> Self {
            self.inner = self.inner.set_configuration(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateClusterSettings<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::update_cluster_settings_input::Builder,
    }
    impl<C> UpdateClusterSettings<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateClusterSettingsOutput,
            smithy_http::result::SdkError<crate::error::UpdateClusterSettingsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the cluster to modify the settings for.</p>
        pub fn cluster(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.cluster(input);
            self
        }
        pub fn set_cluster(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_cluster(input);
            self
        }
        /// <p>The setting to use by default for a cluster. This parameter is used to enable CloudWatch
        /// Container Insights for a cluster. If this value is specified, it will override the
        /// <code>containerInsights</code> value set with <a>PutAccountSetting</a> or
        /// <a>PutAccountSettingDefault</a>.</p>
        pub fn settings(mut self, inp: impl Into<crate::model::ClusterSetting>) -> Self {
            self.inner = self.inner.settings(inp);
            self
        }
        pub fn set_settings(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ClusterSetting>>,
        ) -> Self {
            self.inner = self.inner.set_settings(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateContainerAgent<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::update_container_agent_input::Builder,
    }
    impl<C> UpdateContainerAgent<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateContainerAgentOutput,
            smithy_http::result::SdkError<crate::error::UpdateContainerAgentError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The short name or full Amazon Resource Name (ARN) of the cluster that your container instance is
        /// running on. If you do not specify a cluster, the default cluster is assumed.</p>
        pub fn cluster(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.cluster(input);
            self
        }
        pub fn set_cluster(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_cluster(input);
            self
        }
        /// <p>The container instance ID or full ARN entries for the container instance on which
        /// you would like to update the Amazon ECS container agent.</p>
        pub fn container_instance(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.container_instance(input);
            self
        }
        pub fn set_container_instance(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_container_instance(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateContainerInstancesState<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::update_container_instances_state_input::Builder,
    }
    impl<C> UpdateContainerInstancesState<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateContainerInstancesStateOutput,
            smithy_http::result::SdkError<crate::error::UpdateContainerInstancesStateError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The short name or full Amazon Resource Name (ARN) of the cluster that hosts the container instance to
        /// update. If you do not specify a cluster, the default cluster is assumed.</p>
        pub fn cluster(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.cluster(input);
            self
        }
        pub fn set_cluster(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_cluster(input);
            self
        }
        /// <p>A list of container instance IDs or full ARN entries.</p>
        pub fn container_instances(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.container_instances(inp);
            self
        }
        pub fn set_container_instances(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_container_instances(input);
            self
        }
        /// <p>The container instance state with which to update the container instance. The only
        /// valid values for this action are <code>ACTIVE</code> and <code>DRAINING</code>. A
        /// container instance can only be updated to <code>DRAINING</code> status once it has
        /// reached an <code>ACTIVE</code> state. If a container instance is in
        /// <code>REGISTERING</code>, <code>DEREGISTERING</code>, or
        /// <code>REGISTRATION_FAILED</code> state you can describe the container instance but
        /// will be unable to update the container instance state.</p>
        pub fn status(mut self, input: crate::model::ContainerInstanceStatus) -> Self {
            self.inner = self.inner.status(input);
            self
        }
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::ContainerInstanceStatus>,
        ) -> Self {
            self.inner = self.inner.set_status(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateService<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::update_service_input::Builder,
    }
    impl<C> UpdateService<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateServiceOutput,
            smithy_http::result::SdkError<crate::error::UpdateServiceError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The short name or full Amazon Resource Name (ARN) of the cluster that your service is running on.
        /// If you do not specify a cluster, the default cluster is assumed.</p>
        pub fn cluster(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.cluster(input);
            self
        }
        pub fn set_cluster(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_cluster(input);
            self
        }
        /// <p>The name of the service to update.</p>
        pub fn service(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.service(input);
            self
        }
        pub fn set_service(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_service(input);
            self
        }
        /// <p>The number of instantiations of the task to place and keep running in your
        /// service.</p>
        pub fn desired_count(mut self, input: i32) -> Self {
            self.inner = self.inner.desired_count(input);
            self
        }
        pub fn set_desired_count(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_desired_count(input);
            self
        }
        /// <p>The <code>family</code> and <code>revision</code> (<code>family:revision</code>) or
        /// full ARN of the task definition to run in your service. If a <code>revision</code> is
        /// not specified, the latest <code>ACTIVE</code> revision is used. If you modify the task
        /// definition with <code>UpdateService</code>, Amazon ECS spawns a task with the new version of
        /// the task definition and then stops an old task after the new version is running.</p>
        pub fn task_definition(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.task_definition(input);
            self
        }
        pub fn set_task_definition(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_task_definition(input);
            self
        }
        /// <p>The capacity provider strategy to update the service to use.</p>
        /// <p>If the service is using the default capacity provider strategy for the cluster, the
        /// service can be updated to use one or more capacity providers as opposed to the default
        /// capacity provider strategy. However, when a service is using a capacity provider
        /// strategy that is not the default capacity provider strategy, the service cannot be
        /// updated to use the cluster's default capacity provider strategy.</p>
        /// <p>A capacity provider strategy consists of one or more capacity providers along with the
        /// <code>base</code> and <code>weight</code> to assign to them. A capacity provider
        /// must be associated with the cluster to be used in a capacity provider strategy. The
        /// <a>PutClusterCapacityProviders</a> API is used to associate a capacity
        /// provider with a cluster. Only capacity providers with an <code>ACTIVE</code> or
        /// <code>UPDATING</code> status can be used.</p>
        /// <p>If specifying a capacity provider that uses an Auto Scaling group, the capacity
        /// provider must already be created. New capacity providers can be created with the <a>CreateCapacityProvider</a> API operation.</p>
        /// <p>To use a AWS Fargate capacity provider, specify either the <code>FARGATE</code> or
        /// <code>FARGATE_SPOT</code> capacity providers. The AWS Fargate capacity providers are
        /// available to all accounts and only need to be associated with a cluster to be
        /// used.</p>
        /// <p>The <a>PutClusterCapacityProviders</a> API operation is used to update the
        /// list of available capacity providers for a cluster after the cluster is created.</p>
        /// <p></p>
        pub fn capacity_provider_strategy(
            mut self,
            inp: impl Into<crate::model::CapacityProviderStrategyItem>,
        ) -> Self {
            self.inner = self.inner.capacity_provider_strategy(inp);
            self
        }
        pub fn set_capacity_provider_strategy(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::CapacityProviderStrategyItem>>,
        ) -> Self {
            self.inner = self.inner.set_capacity_provider_strategy(input);
            self
        }
        /// <p>Optional deployment parameters that control how many tasks run during the deployment
        /// and the ordering of stopping and starting tasks.</p>
        pub fn deployment_configuration(
            mut self,
            input: crate::model::DeploymentConfiguration,
        ) -> Self {
            self.inner = self.inner.deployment_configuration(input);
            self
        }
        pub fn set_deployment_configuration(
            mut self,
            input: std::option::Option<crate::model::DeploymentConfiguration>,
        ) -> Self {
            self.inner = self.inner.set_deployment_configuration(input);
            self
        }
        /// <p>An object representing the network configuration for the service.</p>
        pub fn network_configuration(mut self, input: crate::model::NetworkConfiguration) -> Self {
            self.inner = self.inner.network_configuration(input);
            self
        }
        pub fn set_network_configuration(
            mut self,
            input: std::option::Option<crate::model::NetworkConfiguration>,
        ) -> Self {
            self.inner = self.inner.set_network_configuration(input);
            self
        }
        /// <p>An array of task placement constraint objects to update the service to use. If no
        /// value is specified, the existing placement constraints for the service will remain
        /// unchanged. If this value is specified, it will override any existing placement
        /// constraints defined for the service. To remove all existing placement constraints,
        /// specify an empty array.</p>
        /// <p>You can specify a maximum of 10 constraints per task (this limit includes constraints
        /// in the task definition and those specified at runtime).</p>
        pub fn placement_constraints(
            mut self,
            inp: impl Into<crate::model::PlacementConstraint>,
        ) -> Self {
            self.inner = self.inner.placement_constraints(inp);
            self
        }
        pub fn set_placement_constraints(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::PlacementConstraint>>,
        ) -> Self {
            self.inner = self.inner.set_placement_constraints(input);
            self
        }
        /// <p>The task placement strategy objects to update the service to use. If no value is
        /// specified, the existing placement strategy for the service will remain unchanged. If
        /// this value is specified, it will override the existing placement strategy defined for
        /// the service. To remove an existing placement strategy, specify an empty object.</p>
        /// <p>You can specify a maximum of five strategy rules per service.</p>
        pub fn placement_strategy(
            mut self,
            inp: impl Into<crate::model::PlacementStrategy>,
        ) -> Self {
            self.inner = self.inner.placement_strategy(inp);
            self
        }
        pub fn set_placement_strategy(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::PlacementStrategy>>,
        ) -> Self {
            self.inner = self.inner.set_placement_strategy(input);
            self
        }
        /// <p>The platform version on which your tasks in the service are running. A platform
        /// version is only specified for tasks using the Fargate launch type. If a
        /// platform version is not specified, the <code>LATEST</code> platform version is used by
        /// default. For more information, see <a href="https://docs.aws.amazon.com/AmazonECS/latest/developerguide/platform_versions.html">AWS Fargate Platform
        /// Versions</a> in the <i>Amazon Elastic Container Service Developer Guide</i>.</p>
        pub fn platform_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.platform_version(input);
            self
        }
        pub fn set_platform_version(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_platform_version(input);
            self
        }
        /// <p>Whether to force a new deployment of the service. Deployments are not forced by
        /// default. You can use this option to trigger a new deployment with no service definition
        /// changes. For example, you can update a service's tasks to use a newer Docker image with
        /// the same image/tag combination (<code>my_image:latest</code>) or to roll Fargate tasks
        /// onto a newer platform version.</p>
        pub fn force_new_deployment(mut self, input: bool) -> Self {
            self.inner = self.inner.force_new_deployment(input);
            self
        }
        pub fn set_force_new_deployment(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_force_new_deployment(input);
            self
        }
        /// <p>The period of time, in seconds, that the Amazon ECS service scheduler should ignore
        /// unhealthy Elastic Load Balancing target health checks after a task has first started. This is only valid
        /// if your service is configured to use a load balancer. If your service's tasks take a
        /// while to start and respond to Elastic Load Balancing health checks, you can specify a health check grace
        /// period of up to 2,147,483,647 seconds. During that time, the Amazon ECS service
        /// scheduler ignores the Elastic Load Balancing health check status. This grace period can prevent the ECS
        /// service scheduler from marking tasks as unhealthy and stopping them before they have
        /// time to come up.</p>
        pub fn health_check_grace_period_seconds(mut self, input: i32) -> Self {
            self.inner = self.inner.health_check_grace_period_seconds(input);
            self
        }
        pub fn set_health_check_grace_period_seconds(
            mut self,
            input: std::option::Option<i32>,
        ) -> Self {
            self.inner = self.inner.set_health_check_grace_period_seconds(input);
            self
        }
        /// <p>If <code>true</code>, this enables execute command functionality on all task
        /// containers.</p>
        /// <p>If you do not want to override the value that was set when the service was created,
        /// you can set this to <code>null</code> when performing this action.</p>
        pub fn enable_execute_command(mut self, input: bool) -> Self {
            self.inner = self.inner.enable_execute_command(input);
            self
        }
        pub fn set_enable_execute_command(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_enable_execute_command(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateServicePrimaryTaskSet<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::update_service_primary_task_set_input::Builder,
    }
    impl<C> UpdateServicePrimaryTaskSet<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateServicePrimaryTaskSetOutput,
            smithy_http::result::SdkError<crate::error::UpdateServicePrimaryTaskSetError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The short name or full Amazon Resource Name (ARN) of the cluster that hosts the service that the task
        /// set exists in.</p>
        pub fn cluster(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.cluster(input);
            self
        }
        pub fn set_cluster(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_cluster(input);
            self
        }
        /// <p>The short name or full Amazon Resource Name (ARN) of the service that the task set exists in.</p>
        pub fn service(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.service(input);
            self
        }
        pub fn set_service(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_service(input);
            self
        }
        /// <p>The short name or full Amazon Resource Name (ARN) of the task set to set as the primary task set in the
        /// deployment.</p>
        pub fn primary_task_set(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.primary_task_set(input);
            self
        }
        pub fn set_primary_task_set(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_primary_task_set(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateTaskSet<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::update_task_set_input::Builder,
    }
    impl<C> UpdateTaskSet<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateTaskSetOutput,
            smithy_http::result::SdkError<crate::error::UpdateTaskSetError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The short name or full Amazon Resource Name (ARN) of the cluster that hosts the service that the task
        /// set exists in.</p>
        pub fn cluster(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.cluster(input);
            self
        }
        pub fn set_cluster(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_cluster(input);
            self
        }
        /// <p>The short name or full Amazon Resource Name (ARN) of the service that the task set exists in.</p>
        pub fn service(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.service(input);
            self
        }
        pub fn set_service(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_service(input);
            self
        }
        /// <p>The short name or full Amazon Resource Name (ARN) of the task set to update.</p>
        pub fn task_set(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.task_set(input);
            self
        }
        pub fn set_task_set(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_task_set(input);
            self
        }
        /// <p>A floating-point percentage of the desired number of tasks to place and keep running
        /// in the task set.</p>
        pub fn scale(mut self, input: crate::model::Scale) -> Self {
            self.inner = self.inner.scale(input);
            self
        }
        pub fn set_scale(mut self, input: std::option::Option<crate::model::Scale>) -> Self {
            self.inner = self.inner.set_scale(input);
            self
        }
    }
}
