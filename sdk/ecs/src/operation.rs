// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
/// <p>Creates a new capacity provider. Capacity providers are associated with an Amazon ECS
/// cluster and are used in capacity provider strategies to facilitate cluster auto
/// scaling.</p>
/// <p>Only capacity providers using an Auto Scaling group can be created. Amazon ECS tasks on
/// AWS Fargate use the <code>FARGATE</code> and <code>FARGATE_SPOT</code> capacity providers
/// which are already created and available to all accounts in Regions supported by
/// AWS Fargate.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateCapacityProvider {
    _private: (),
}
impl CreateCapacityProvider {
    /// Creates a new builder-style object to manufacture [`CreateCapacityProviderInput`](crate::input::CreateCapacityProviderInput)
    pub fn builder() -> crate::input::create_capacity_provider_input::Builder {
        crate::input::create_capacity_provider_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    #[allow(dead_code)]
    fn parse_response(
        &self,
        response: &http::response::Response<bytes::Bytes>,
    ) -> Result<
        crate::output::CreateCapacityProviderOutput,
        crate::error::CreateCapacityProviderError,
    > {
        if crate::aws_json_errors::is_error(&response) {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);
            let error_code = match generic.code() {
                Some(code) => code,
                None => {
                    return Err(crate::error::CreateCapacityProviderError::unhandled(
                        generic,
                    ))
                }
            };
            return Err(match error_code {
                "ClientException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::CreateCapacityProviderError {
                        kind: crate::error::CreateCapacityProviderErrorKind::ClientError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::CreateCapacityProviderError::unhandled(e),
                },
                "InvalidParameterException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::CreateCapacityProviderError {
                        kind: crate::error::CreateCapacityProviderErrorKind::InvalidParameterError(
                            body,
                        ),
                        meta: generic,
                    },
                    Err(e) => crate::error::CreateCapacityProviderError::unhandled(e),
                },
                "LimitExceededException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::CreateCapacityProviderError {
                        kind: crate::error::CreateCapacityProviderErrorKind::LimitExceededError(
                            body,
                        ),
                        meta: generic,
                    },
                    Err(e) => crate::error::CreateCapacityProviderError::unhandled(e),
                },
                "ServerException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::CreateCapacityProviderError {
                        kind: crate::error::CreateCapacityProviderErrorKind::ServerError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::CreateCapacityProviderError::unhandled(e),
                },
                "UpdateInProgressException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::CreateCapacityProviderError {
                        kind: crate::error::CreateCapacityProviderErrorKind::UpdateInProgressError(
                            body,
                        ),
                        meta: generic,
                    },
                    Err(e) => crate::error::CreateCapacityProviderError::unhandled(e),
                },
                _ => crate::error::CreateCapacityProviderError::generic(generic),
            });
        }
        #[allow(unused_mut)]
        let mut builder = crate::output::create_capacity_provider_output::Builder::default();
        builder = crate::json_deser::create_capacity_provider_deser_operation(
            response.body().as_ref(),
            builder,
        )
        .map_err(crate::error::CreateCapacityProviderError::unhandled)?;
        Ok(builder.build())
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateCapacityProvider {
    type Output = Result<
        crate::output::CreateCapacityProviderOutput,
        crate::error::CreateCapacityProviderError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Creates a new Amazon ECS cluster. By default, your account receives a <code>default</code>
/// cluster when you launch your first container instance. However, you can create your own
/// cluster with a unique name with the <code>CreateCluster</code> action.</p>
/// <note>
/// <p>When you call the <a>CreateCluster</a> API operation, Amazon ECS attempts to
/// create the Amazon ECS service-linked role for your account so that required resources in
/// other AWS services can be managed on your behalf. However, if the IAM user that
/// makes the call does not have permissions to create the service-linked role, it is
/// not created. For more information, see <a href="https://docs.aws.amazon.com/AmazonECS/latest/developerguide/using-service-linked-roles.html">Using
/// Service-Linked Roles for Amazon ECS</a> in the
/// <i>Amazon Elastic Container Service Developer Guide</i>.</p>
/// </note>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateCluster {
    _private: (),
}
impl CreateCluster {
    /// Creates a new builder-style object to manufacture [`CreateClusterInput`](crate::input::CreateClusterInput)
    pub fn builder() -> crate::input::create_cluster_input::Builder {
        crate::input::create_cluster_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    #[allow(dead_code)]
    fn parse_response(
        &self,
        response: &http::response::Response<bytes::Bytes>,
    ) -> Result<crate::output::CreateClusterOutput, crate::error::CreateClusterError> {
        if crate::aws_json_errors::is_error(&response) {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);
            let error_code = match generic.code() {
                Some(code) => code,
                None => return Err(crate::error::CreateClusterError::unhandled(generic)),
            };
            return Err(match error_code {
                "ClientException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::CreateClusterError {
                        kind: crate::error::CreateClusterErrorKind::ClientError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::CreateClusterError::unhandled(e),
                },
                "InvalidParameterException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::CreateClusterError {
                        kind: crate::error::CreateClusterErrorKind::InvalidParameterError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::CreateClusterError::unhandled(e),
                },
                "ServerException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::CreateClusterError {
                        kind: crate::error::CreateClusterErrorKind::ServerError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::CreateClusterError::unhandled(e),
                },
                _ => crate::error::CreateClusterError::generic(generic),
            });
        }
        #[allow(unused_mut)]
        let mut builder = crate::output::create_cluster_output::Builder::default();
        builder =
            crate::json_deser::create_cluster_deser_operation(response.body().as_ref(), builder)
                .map_err(crate::error::CreateClusterError::unhandled)?;
        Ok(builder.build())
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateCluster {
    type Output = Result<crate::output::CreateClusterOutput, crate::error::CreateClusterError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Runs and maintains a desired number of tasks from a specified task definition. If the
/// number of tasks running in a service drops below the <code>desiredCount</code>, Amazon ECS
/// runs another copy of the task in the specified cluster. To update an existing service,
/// see the UpdateService action.</p>
/// <p>In addition to maintaining the desired count of tasks in your service, you can
/// optionally run your service behind one or more load balancers. The load balancers
/// distribute traffic across the tasks that are associated with the service. For more
/// information, see <a href="https://docs.aws.amazon.com/AmazonECS/latest/developerguide/service-load-balancing.html">Service Load Balancing</a> in the
/// <i>Amazon Elastic Container Service Developer Guide</i>.</p>
/// <p>Tasks for services that <i>do not</i> use a load balancer are considered
/// healthy if they're in the <code>RUNNING</code> state. Tasks for services that
/// <i>do</i> use a load balancer are considered healthy if they're in the
/// <code>RUNNING</code> state and the container instance that they're hosted on is
/// reported as healthy by the load balancer.</p>
/// <p>There are two service scheduler strategies available:</p>
/// <ul>
/// <li>
/// <p>
/// <code>REPLICA</code> - The replica scheduling strategy places and
/// maintains the desired number of tasks across your cluster. By default, the
/// service scheduler spreads tasks across Availability Zones. You can use task
/// placement strategies and constraints to customize task placement decisions. For
/// more information, see <a href="https://docs.aws.amazon.com/AmazonECS/latest/developerguide/ecs_services.html">Service Scheduler Concepts</a> in the
/// <i>Amazon Elastic Container Service Developer Guide</i>.</p>
/// </li>
/// <li>
/// <p>
/// <code>DAEMON</code> - The daemon scheduling strategy deploys exactly one
/// task on each active container instance that meets all of the task placement
/// constraints that you specify in your cluster. The service scheduler also
/// evaluates the task placement constraints for running tasks and will stop tasks
/// that do not meet the placement constraints. When using this strategy, you don't
/// need to specify a desired number of tasks, a task placement strategy, or use
/// Service Auto Scaling policies. For more information, see <a href="https://docs.aws.amazon.com/AmazonECS/latest/developerguide/ecs_services.html">Service Scheduler Concepts</a> in the
/// <i>Amazon Elastic Container Service Developer Guide</i>.</p>
/// </li>
/// </ul>
/// <p>You can optionally specify a deployment configuration for your service. The deployment
/// is triggered by changing properties, such as the task definition or the desired count of
/// a service, with an <a>UpdateService</a> operation. The default value for a
/// replica service for <code>minimumHealthyPercent</code> is 100%. The default value for a
/// daemon service for <code>minimumHealthyPercent</code> is 0%.</p>
/// <p>If a service is using the <code>ECS</code> deployment controller, the minimum healthy
/// percent represents a lower limit on the number of tasks in a service that must remain in
/// the <code>RUNNING</code> state during a deployment, as a percentage of the desired
/// number of tasks (rounded up to the nearest integer), and while any container instances
/// are in the <code>DRAINING</code> state if the service contains tasks using the
/// EC2 launch type. This parameter enables you to deploy without using
/// additional cluster capacity. For example, if your service has a desired number of four
/// tasks and a minimum healthy percent of 50%, the scheduler might stop two existing tasks
/// to free up cluster capacity before starting two new tasks. Tasks for services that
/// <i>do not</i> use a load balancer are considered healthy if they're in
/// the <code>RUNNING</code> state. Tasks for services that <i>do</i> use a
/// load balancer are considered healthy if they're in the <code>RUNNING</code> state and
/// they're reported as healthy by the load balancer. The default value for minimum healthy
/// percent is 100%.</p>
/// <p>If a service is using the <code>ECS</code> deployment controller, the <b>maximum percent</b> parameter represents an upper limit on the
/// number of tasks in a service that are allowed in the <code>RUNNING</code> or
/// <code>PENDING</code> state during a deployment, as a percentage of the desired
/// number of tasks (rounded down to the nearest integer), and while any container instances
/// are in the <code>DRAINING</code> state if the service contains tasks using the
/// EC2 launch type. This parameter enables you to define the deployment batch
/// size. For example, if your service has a desired number of four tasks and a maximum
/// percent value of 200%, the scheduler may start four new tasks before stopping the four
/// older tasks (provided that the cluster resources required to do this are available). The
/// default value for maximum percent is 200%.</p>
/// <p>If a service is using either the <code>CODE_DEPLOY</code> or <code>EXTERNAL</code>
/// deployment controller types and tasks that use the EC2 launch type, the
/// <b>minimum healthy percent</b> and <b>maximum percent</b> values are used only to define the lower and upper limit
/// on the number of the tasks in the service that remain in the <code>RUNNING</code> state
/// while the container instances are in the <code>DRAINING</code> state. If the tasks in
/// the service use the Fargate launch type, the minimum healthy percent and
/// maximum percent values aren't used, although they're currently visible when describing
/// your service.</p>
/// <p>When creating a service that uses the <code>EXTERNAL</code> deployment controller, you
/// can specify only parameters that aren't controlled at the task set level. The only
/// required parameter is the service name. You control your services using the <a>CreateTaskSet</a> operation. For more information, see <a href="https://docs.aws.amazon.com/AmazonECS/latest/developerguide/deployment-types.html">Amazon ECS Deployment Types</a> in the <i>Amazon Elastic Container Service Developer Guide</i>.</p>
/// <p>When the service scheduler launches new tasks, it determines task placement in your
/// cluster using the following logic:</p>
/// <ul>
/// <li>
/// <p>Determine which of the container instances in your cluster can support your
/// service's task definition (for example, they have the required CPU, memory,
/// ports, and container instance attributes).</p>
/// </li>
/// <li>
/// <p>By default, the service scheduler attempts to balance tasks across
/// Availability Zones in this manner (although you can choose a different placement
/// strategy) with the <code>placementStrategy</code> parameter):</p>
/// <ul>
/// <li>
/// <p>Sort the valid container instances, giving priority to instances that
/// have the fewest number of running tasks for this service in their
/// respective Availability Zone. For example, if zone A has one running
/// service task and zones B and C each have zero, valid container instances
/// in either zone B or C are considered optimal for placement.</p>
/// </li>
/// <li>
/// <p>Place the new service task on a valid container instance in an optimal
/// Availability Zone (based on the previous steps), favoring container
/// instances with the fewest number of running tasks for this
/// service.</p>
/// </li>
/// </ul>
/// </li>
/// </ul>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateService {
    _private: (),
}
impl CreateService {
    /// Creates a new builder-style object to manufacture [`CreateServiceInput`](crate::input::CreateServiceInput)
    pub fn builder() -> crate::input::create_service_input::Builder {
        crate::input::create_service_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    #[allow(dead_code)]
    fn parse_response(
        &self,
        response: &http::response::Response<bytes::Bytes>,
    ) -> Result<crate::output::CreateServiceOutput, crate::error::CreateServiceError> {
        if crate::aws_json_errors::is_error(&response) {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);
            let error_code = match generic.code() {
                Some(code) => code,
                None => return Err(crate::error::CreateServiceError::unhandled(generic)),
            };
            return Err(match error_code {
                "AccessDeniedException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::CreateServiceError { kind: crate::error::CreateServiceErrorKind::AccessDeniedError(body), meta: generic },
                    Err(e) => crate::error::CreateServiceError::unhandled(e)
                }
                "ClientException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::CreateServiceError { kind: crate::error::CreateServiceErrorKind::ClientError(body), meta: generic },
                    Err(e) => crate::error::CreateServiceError::unhandled(e)
                }
                "ClusterNotFoundException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::CreateServiceError { kind: crate::error::CreateServiceErrorKind::ClusterNotFoundError(body), meta: generic },
                    Err(e) => crate::error::CreateServiceError::unhandled(e)
                }
                "InvalidParameterException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::CreateServiceError { kind: crate::error::CreateServiceErrorKind::InvalidParameterError(body), meta: generic },
                    Err(e) => crate::error::CreateServiceError::unhandled(e)
                }
                "PlatformTaskDefinitionIncompatibilityException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::CreateServiceError { kind: crate::error::CreateServiceErrorKind::PlatformTaskDefinitionIncompatibilityError(body), meta: generic },
                    Err(e) => crate::error::CreateServiceError::unhandled(e)
                }
                "PlatformUnknownException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::CreateServiceError { kind: crate::error::CreateServiceErrorKind::PlatformUnknownError(body), meta: generic },
                    Err(e) => crate::error::CreateServiceError::unhandled(e)
                }
                "ServerException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::CreateServiceError { kind: crate::error::CreateServiceErrorKind::ServerError(body), meta: generic },
                    Err(e) => crate::error::CreateServiceError::unhandled(e)
                }
                "UnsupportedFeatureException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::CreateServiceError { kind: crate::error::CreateServiceErrorKind::UnsupportedFeatureError(body), meta: generic },
                    Err(e) => crate::error::CreateServiceError::unhandled(e)
                }
                _ => crate::error::CreateServiceError::generic(generic)
            });
        }
        #[allow(unused_mut)]
        let mut builder = crate::output::create_service_output::Builder::default();
        builder =
            crate::json_deser::create_service_deser_operation(response.body().as_ref(), builder)
                .map_err(crate::error::CreateServiceError::unhandled)?;
        Ok(builder.build())
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateService {
    type Output = Result<crate::output::CreateServiceOutput, crate::error::CreateServiceError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Create a task set in the specified cluster and service. This is used when a service
/// uses the <code>EXTERNAL</code> deployment controller type. For more information, see
/// <a href="https://docs.aws.amazon.com/AmazonECS/latest/developerguide/deployment-types.html">Amazon ECS Deployment
/// Types</a> in the <i>Amazon Elastic Container Service Developer Guide</i>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateTaskSet {
    _private: (),
}
impl CreateTaskSet {
    /// Creates a new builder-style object to manufacture [`CreateTaskSetInput`](crate::input::CreateTaskSetInput)
    pub fn builder() -> crate::input::create_task_set_input::Builder {
        crate::input::create_task_set_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    #[allow(dead_code)]
    fn parse_response(
        &self,
        response: &http::response::Response<bytes::Bytes>,
    ) -> Result<crate::output::CreateTaskSetOutput, crate::error::CreateTaskSetError> {
        if crate::aws_json_errors::is_error(&response) {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);
            let error_code = match generic.code() {
                Some(code) => code,
                None => return Err(crate::error::CreateTaskSetError::unhandled(generic)),
            };
            return Err(match error_code {
                "AccessDeniedException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::CreateTaskSetError { kind: crate::error::CreateTaskSetErrorKind::AccessDeniedError(body), meta: generic },
                    Err(e) => crate::error::CreateTaskSetError::unhandled(e)
                }
                "ClientException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::CreateTaskSetError { kind: crate::error::CreateTaskSetErrorKind::ClientError(body), meta: generic },
                    Err(e) => crate::error::CreateTaskSetError::unhandled(e)
                }
                "ClusterNotFoundException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::CreateTaskSetError { kind: crate::error::CreateTaskSetErrorKind::ClusterNotFoundError(body), meta: generic },
                    Err(e) => crate::error::CreateTaskSetError::unhandled(e)
                }
                "InvalidParameterException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::CreateTaskSetError { kind: crate::error::CreateTaskSetErrorKind::InvalidParameterError(body), meta: generic },
                    Err(e) => crate::error::CreateTaskSetError::unhandled(e)
                }
                "PlatformTaskDefinitionIncompatibilityException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::CreateTaskSetError { kind: crate::error::CreateTaskSetErrorKind::PlatformTaskDefinitionIncompatibilityError(body), meta: generic },
                    Err(e) => crate::error::CreateTaskSetError::unhandled(e)
                }
                "PlatformUnknownException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::CreateTaskSetError { kind: crate::error::CreateTaskSetErrorKind::PlatformUnknownError(body), meta: generic },
                    Err(e) => crate::error::CreateTaskSetError::unhandled(e)
                }
                "ServerException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::CreateTaskSetError { kind: crate::error::CreateTaskSetErrorKind::ServerError(body), meta: generic },
                    Err(e) => crate::error::CreateTaskSetError::unhandled(e)
                }
                "ServiceNotActiveException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::CreateTaskSetError { kind: crate::error::CreateTaskSetErrorKind::ServiceNotActiveError(body), meta: generic },
                    Err(e) => crate::error::CreateTaskSetError::unhandled(e)
                }
                "ServiceNotFoundException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::CreateTaskSetError { kind: crate::error::CreateTaskSetErrorKind::ServiceNotFoundError(body), meta: generic },
                    Err(e) => crate::error::CreateTaskSetError::unhandled(e)
                }
                "UnsupportedFeatureException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::CreateTaskSetError { kind: crate::error::CreateTaskSetErrorKind::UnsupportedFeatureError(body), meta: generic },
                    Err(e) => crate::error::CreateTaskSetError::unhandled(e)
                }
                _ => crate::error::CreateTaskSetError::generic(generic)
            });
        }
        #[allow(unused_mut)]
        let mut builder = crate::output::create_task_set_output::Builder::default();
        builder =
            crate::json_deser::create_task_set_deser_operation(response.body().as_ref(), builder)
                .map_err(crate::error::CreateTaskSetError::unhandled)?;
        Ok(builder.build())
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateTaskSet {
    type Output = Result<crate::output::CreateTaskSetOutput, crate::error::CreateTaskSetError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Disables an account setting for a specified IAM user, IAM role, or the root user for
/// an account.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteAccountSetting {
    _private: (),
}
impl DeleteAccountSetting {
    /// Creates a new builder-style object to manufacture [`DeleteAccountSettingInput`](crate::input::DeleteAccountSettingInput)
    pub fn builder() -> crate::input::delete_account_setting_input::Builder {
        crate::input::delete_account_setting_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    #[allow(dead_code)]
    fn parse_response(
        &self,
        response: &http::response::Response<bytes::Bytes>,
    ) -> Result<crate::output::DeleteAccountSettingOutput, crate::error::DeleteAccountSettingError>
    {
        if crate::aws_json_errors::is_error(&response) {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);
            let error_code = match generic.code() {
                Some(code) => code,
                None => return Err(crate::error::DeleteAccountSettingError::unhandled(generic)),
            };
            return Err(match error_code {
                "ClientException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::DeleteAccountSettingError {
                        kind: crate::error::DeleteAccountSettingErrorKind::ClientError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::DeleteAccountSettingError::unhandled(e),
                },
                "InvalidParameterException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::DeleteAccountSettingError {
                        kind: crate::error::DeleteAccountSettingErrorKind::InvalidParameterError(
                            body,
                        ),
                        meta: generic,
                    },
                    Err(e) => crate::error::DeleteAccountSettingError::unhandled(e),
                },
                "ServerException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::DeleteAccountSettingError {
                        kind: crate::error::DeleteAccountSettingErrorKind::ServerError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::DeleteAccountSettingError::unhandled(e),
                },
                _ => crate::error::DeleteAccountSettingError::generic(generic),
            });
        }
        #[allow(unused_mut)]
        let mut builder = crate::output::delete_account_setting_output::Builder::default();
        builder = crate::json_deser::delete_account_setting_deser_operation(
            response.body().as_ref(),
            builder,
        )
        .map_err(crate::error::DeleteAccountSettingError::unhandled)?;
        Ok(builder.build())
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteAccountSetting {
    type Output =
        Result<crate::output::DeleteAccountSettingOutput, crate::error::DeleteAccountSettingError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Deletes one or more custom attributes from an Amazon ECS resource.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteAttributes {
    _private: (),
}
impl DeleteAttributes {
    /// Creates a new builder-style object to manufacture [`DeleteAttributesInput`](crate::input::DeleteAttributesInput)
    pub fn builder() -> crate::input::delete_attributes_input::Builder {
        crate::input::delete_attributes_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    #[allow(dead_code)]
    fn parse_response(
        &self,
        response: &http::response::Response<bytes::Bytes>,
    ) -> Result<crate::output::DeleteAttributesOutput, crate::error::DeleteAttributesError> {
        if crate::aws_json_errors::is_error(&response) {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);
            let error_code = match generic.code() {
                Some(code) => code,
                None => return Err(crate::error::DeleteAttributesError::unhandled(generic)),
            };
            return Err(match error_code {
                "ClusterNotFoundException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::DeleteAttributesError {
                        kind: crate::error::DeleteAttributesErrorKind::ClusterNotFoundError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::DeleteAttributesError::unhandled(e),
                },
                "InvalidParameterException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::DeleteAttributesError {
                        kind: crate::error::DeleteAttributesErrorKind::InvalidParameterError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::DeleteAttributesError::unhandled(e),
                },
                "TargetNotFoundException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::DeleteAttributesError {
                        kind: crate::error::DeleteAttributesErrorKind::TargetNotFoundError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::DeleteAttributesError::unhandled(e),
                },
                _ => crate::error::DeleteAttributesError::generic(generic),
            });
        }
        #[allow(unused_mut)]
        let mut builder = crate::output::delete_attributes_output::Builder::default();
        builder =
            crate::json_deser::delete_attributes_deser_operation(response.body().as_ref(), builder)
                .map_err(crate::error::DeleteAttributesError::unhandled)?;
        Ok(builder.build())
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteAttributes {
    type Output =
        Result<crate::output::DeleteAttributesOutput, crate::error::DeleteAttributesError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Deletes the specified capacity provider.</p>
/// <note>
/// <p>The <code>FARGATE</code> and <code>FARGATE_SPOT</code> capacity providers are
/// reserved and cannot be deleted. You can disassociate them from a cluster using
/// either the <a>PutClusterCapacityProviders</a> API or by deleting the
/// cluster.</p>
/// </note>
/// <p>Prior to a capacity provider being deleted, the capacity provider must be removed from
/// the capacity provider strategy from all services. The <a>UpdateService</a>
/// API can be used to remove a capacity provider from a service's capacity provider
/// strategy. When updating a service, the <code>forceNewDeployment</code> option can be
/// used to ensure that any tasks using the Amazon EC2 instance capacity provided by the capacity
/// provider are transitioned to use the capacity from the remaining capacity providers.
/// Only capacity providers that are not associated with a cluster can be deleted. To remove
/// a capacity provider from a cluster, you can either use <a>PutClusterCapacityProviders</a> or delete the cluster.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteCapacityProvider {
    _private: (),
}
impl DeleteCapacityProvider {
    /// Creates a new builder-style object to manufacture [`DeleteCapacityProviderInput`](crate::input::DeleteCapacityProviderInput)
    pub fn builder() -> crate::input::delete_capacity_provider_input::Builder {
        crate::input::delete_capacity_provider_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    #[allow(dead_code)]
    fn parse_response(
        &self,
        response: &http::response::Response<bytes::Bytes>,
    ) -> Result<
        crate::output::DeleteCapacityProviderOutput,
        crate::error::DeleteCapacityProviderError,
    > {
        if crate::aws_json_errors::is_error(&response) {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);
            let error_code = match generic.code() {
                Some(code) => code,
                None => {
                    return Err(crate::error::DeleteCapacityProviderError::unhandled(
                        generic,
                    ))
                }
            };
            return Err(match error_code {
                "ClientException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::DeleteCapacityProviderError {
                        kind: crate::error::DeleteCapacityProviderErrorKind::ClientError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::DeleteCapacityProviderError::unhandled(e),
                },
                "InvalidParameterException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::DeleteCapacityProviderError {
                        kind: crate::error::DeleteCapacityProviderErrorKind::InvalidParameterError(
                            body,
                        ),
                        meta: generic,
                    },
                    Err(e) => crate::error::DeleteCapacityProviderError::unhandled(e),
                },
                "ServerException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::DeleteCapacityProviderError {
                        kind: crate::error::DeleteCapacityProviderErrorKind::ServerError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::DeleteCapacityProviderError::unhandled(e),
                },
                _ => crate::error::DeleteCapacityProviderError::generic(generic),
            });
        }
        #[allow(unused_mut)]
        let mut builder = crate::output::delete_capacity_provider_output::Builder::default();
        builder = crate::json_deser::delete_capacity_provider_deser_operation(
            response.body().as_ref(),
            builder,
        )
        .map_err(crate::error::DeleteCapacityProviderError::unhandled)?;
        Ok(builder.build())
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteCapacityProvider {
    type Output = Result<
        crate::output::DeleteCapacityProviderOutput,
        crate::error::DeleteCapacityProviderError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Deletes the specified cluster. The cluster will transition to the
/// <code>INACTIVE</code> state. Clusters with an <code>INACTIVE</code> status may
/// remain discoverable in your account for a period of time. However, this behavior is
/// subject to change in the future, so you should not rely on <code>INACTIVE</code>
/// clusters persisting.</p>
/// <p>You must deregister all container instances from this cluster before you may delete
/// it. You can list the container instances in a cluster with <a>ListContainerInstances</a> and deregister them with <a>DeregisterContainerInstance</a>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteCluster {
    _private: (),
}
impl DeleteCluster {
    /// Creates a new builder-style object to manufacture [`DeleteClusterInput`](crate::input::DeleteClusterInput)
    pub fn builder() -> crate::input::delete_cluster_input::Builder {
        crate::input::delete_cluster_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    #[allow(dead_code)]
    fn parse_response(
        &self,
        response: &http::response::Response<bytes::Bytes>,
    ) -> Result<crate::output::DeleteClusterOutput, crate::error::DeleteClusterError> {
        if crate::aws_json_errors::is_error(&response) {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);
            let error_code = match generic.code() {
                Some(code) => code,
                None => return Err(crate::error::DeleteClusterError::unhandled(generic)),
            };
            return Err(match error_code {
                "ClientException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::DeleteClusterError { kind: crate::error::DeleteClusterErrorKind::ClientError(body), meta: generic },
                    Err(e) => crate::error::DeleteClusterError::unhandled(e)
                }
                "ClusterContainsContainerInstancesException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::DeleteClusterError { kind: crate::error::DeleteClusterErrorKind::ClusterContainsContainerInstancesError(body), meta: generic },
                    Err(e) => crate::error::DeleteClusterError::unhandled(e)
                }
                "ClusterContainsServicesException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::DeleteClusterError { kind: crate::error::DeleteClusterErrorKind::ClusterContainsServicesError(body), meta: generic },
                    Err(e) => crate::error::DeleteClusterError::unhandled(e)
                }
                "ClusterContainsTasksException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::DeleteClusterError { kind: crate::error::DeleteClusterErrorKind::ClusterContainsTasksError(body), meta: generic },
                    Err(e) => crate::error::DeleteClusterError::unhandled(e)
                }
                "ClusterNotFoundException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::DeleteClusterError { kind: crate::error::DeleteClusterErrorKind::ClusterNotFoundError(body), meta: generic },
                    Err(e) => crate::error::DeleteClusterError::unhandled(e)
                }
                "InvalidParameterException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::DeleteClusterError { kind: crate::error::DeleteClusterErrorKind::InvalidParameterError(body), meta: generic },
                    Err(e) => crate::error::DeleteClusterError::unhandled(e)
                }
                "ServerException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::DeleteClusterError { kind: crate::error::DeleteClusterErrorKind::ServerError(body), meta: generic },
                    Err(e) => crate::error::DeleteClusterError::unhandled(e)
                }
                "UpdateInProgressException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::DeleteClusterError { kind: crate::error::DeleteClusterErrorKind::UpdateInProgressError(body), meta: generic },
                    Err(e) => crate::error::DeleteClusterError::unhandled(e)
                }
                _ => crate::error::DeleteClusterError::generic(generic)
            });
        }
        #[allow(unused_mut)]
        let mut builder = crate::output::delete_cluster_output::Builder::default();
        builder =
            crate::json_deser::delete_cluster_deser_operation(response.body().as_ref(), builder)
                .map_err(crate::error::DeleteClusterError::unhandled)?;
        Ok(builder.build())
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteCluster {
    type Output = Result<crate::output::DeleteClusterOutput, crate::error::DeleteClusterError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Deletes a specified service within a cluster. You can delete a service if you have no
/// running tasks in it and the desired task count is zero. If the service is actively
/// maintaining tasks, you cannot delete it, and you must update the service to a desired
/// task count of zero. For more information, see <a>UpdateService</a>.</p>
/// <note>
/// <p>When you delete a service, if there are still running tasks that require cleanup,
/// the service status moves from <code>ACTIVE</code> to <code>DRAINING</code>, and the
/// service is no longer visible in the console or in the <a>ListServices</a>
/// API operation. After all tasks have transitioned to either <code>STOPPING</code> or
/// <code>STOPPED</code> status, the service status moves from <code>DRAINING</code>
/// to <code>INACTIVE</code>. Services in the <code>DRAINING</code> or
/// <code>INACTIVE</code> status can still be viewed with the <a>DescribeServices</a> API operation. However, in the future,
/// <code>INACTIVE</code> services may be cleaned up and purged from Amazon ECS record
/// keeping, and <a>DescribeServices</a> calls on those services return a
/// <code>ServiceNotFoundException</code> error.</p>
/// </note>
/// <important>
/// <p>If you attempt to create a new service with the same name as an existing service
/// in either <code>ACTIVE</code> or <code>DRAINING</code> status, you receive an
/// error.</p>
/// </important>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteService {
    _private: (),
}
impl DeleteService {
    /// Creates a new builder-style object to manufacture [`DeleteServiceInput`](crate::input::DeleteServiceInput)
    pub fn builder() -> crate::input::delete_service_input::Builder {
        crate::input::delete_service_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    #[allow(dead_code)]
    fn parse_response(
        &self,
        response: &http::response::Response<bytes::Bytes>,
    ) -> Result<crate::output::DeleteServiceOutput, crate::error::DeleteServiceError> {
        if crate::aws_json_errors::is_error(&response) {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);
            let error_code = match generic.code() {
                Some(code) => code,
                None => return Err(crate::error::DeleteServiceError::unhandled(generic)),
            };
            return Err(match error_code {
                "ClientException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::DeleteServiceError {
                        kind: crate::error::DeleteServiceErrorKind::ClientError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::DeleteServiceError::unhandled(e),
                },
                "ClusterNotFoundException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::DeleteServiceError {
                        kind: crate::error::DeleteServiceErrorKind::ClusterNotFoundError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::DeleteServiceError::unhandled(e),
                },
                "InvalidParameterException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::DeleteServiceError {
                        kind: crate::error::DeleteServiceErrorKind::InvalidParameterError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::DeleteServiceError::unhandled(e),
                },
                "ServerException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::DeleteServiceError {
                        kind: crate::error::DeleteServiceErrorKind::ServerError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::DeleteServiceError::unhandled(e),
                },
                "ServiceNotFoundException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::DeleteServiceError {
                        kind: crate::error::DeleteServiceErrorKind::ServiceNotFoundError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::DeleteServiceError::unhandled(e),
                },
                _ => crate::error::DeleteServiceError::generic(generic),
            });
        }
        #[allow(unused_mut)]
        let mut builder = crate::output::delete_service_output::Builder::default();
        builder =
            crate::json_deser::delete_service_deser_operation(response.body().as_ref(), builder)
                .map_err(crate::error::DeleteServiceError::unhandled)?;
        Ok(builder.build())
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteService {
    type Output = Result<crate::output::DeleteServiceOutput, crate::error::DeleteServiceError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Deletes a specified task set within a service. This is used when a service uses the
/// <code>EXTERNAL</code> deployment controller type. For more information, see <a href="https://docs.aws.amazon.com/AmazonECS/latest/developerguide/deployment-types.html">Amazon ECS Deployment Types</a> in the <i>Amazon Elastic Container Service Developer Guide</i>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteTaskSet {
    _private: (),
}
impl DeleteTaskSet {
    /// Creates a new builder-style object to manufacture [`DeleteTaskSetInput`](crate::input::DeleteTaskSetInput)
    pub fn builder() -> crate::input::delete_task_set_input::Builder {
        crate::input::delete_task_set_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    #[allow(dead_code)]
    fn parse_response(
        &self,
        response: &http::response::Response<bytes::Bytes>,
    ) -> Result<crate::output::DeleteTaskSetOutput, crate::error::DeleteTaskSetError> {
        if crate::aws_json_errors::is_error(&response) {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);
            let error_code = match generic.code() {
                Some(code) => code,
                None => return Err(crate::error::DeleteTaskSetError::unhandled(generic)),
            };
            return Err(match error_code {
                "AccessDeniedException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::DeleteTaskSetError {
                        kind: crate::error::DeleteTaskSetErrorKind::AccessDeniedError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::DeleteTaskSetError::unhandled(e),
                },
                "ClientException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::DeleteTaskSetError {
                        kind: crate::error::DeleteTaskSetErrorKind::ClientError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::DeleteTaskSetError::unhandled(e),
                },
                "ClusterNotFoundException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::DeleteTaskSetError {
                        kind: crate::error::DeleteTaskSetErrorKind::ClusterNotFoundError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::DeleteTaskSetError::unhandled(e),
                },
                "InvalidParameterException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::DeleteTaskSetError {
                        kind: crate::error::DeleteTaskSetErrorKind::InvalidParameterError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::DeleteTaskSetError::unhandled(e),
                },
                "ServerException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::DeleteTaskSetError {
                        kind: crate::error::DeleteTaskSetErrorKind::ServerError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::DeleteTaskSetError::unhandled(e),
                },
                "ServiceNotActiveException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::DeleteTaskSetError {
                        kind: crate::error::DeleteTaskSetErrorKind::ServiceNotActiveError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::DeleteTaskSetError::unhandled(e),
                },
                "ServiceNotFoundException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::DeleteTaskSetError {
                        kind: crate::error::DeleteTaskSetErrorKind::ServiceNotFoundError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::DeleteTaskSetError::unhandled(e),
                },
                "TaskSetNotFoundException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::DeleteTaskSetError {
                        kind: crate::error::DeleteTaskSetErrorKind::TaskSetNotFoundError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::DeleteTaskSetError::unhandled(e),
                },
                "UnsupportedFeatureException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::DeleteTaskSetError {
                        kind: crate::error::DeleteTaskSetErrorKind::UnsupportedFeatureError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::DeleteTaskSetError::unhandled(e),
                },
                _ => crate::error::DeleteTaskSetError::generic(generic),
            });
        }
        #[allow(unused_mut)]
        let mut builder = crate::output::delete_task_set_output::Builder::default();
        builder =
            crate::json_deser::delete_task_set_deser_operation(response.body().as_ref(), builder)
                .map_err(crate::error::DeleteTaskSetError::unhandled)?;
        Ok(builder.build())
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteTaskSet {
    type Output = Result<crate::output::DeleteTaskSetOutput, crate::error::DeleteTaskSetError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Deregisters an Amazon ECS container instance from the specified cluster. This instance is
/// no longer available to run tasks.</p>
/// <p>If you intend to use the container instance for some other purpose after
/// deregistration, you should stop all of the tasks running on the container instance
/// before deregistration. That prevents any orphaned tasks from consuming resources.</p>
/// <p>Deregistering a container instance removes the instance from a cluster, but it does
/// not terminate the EC2 instance. If you are finished using the instance, be sure to
/// terminate it in the Amazon EC2 console to stop billing.</p>
/// <note>
/// <p>If you terminate a running container instance, Amazon ECS automatically deregisters the
/// instance from your cluster (stopped container instances or instances with
/// disconnected agents are not automatically deregistered when terminated).</p>
/// </note>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeregisterContainerInstance {
    _private: (),
}
impl DeregisterContainerInstance {
    /// Creates a new builder-style object to manufacture [`DeregisterContainerInstanceInput`](crate::input::DeregisterContainerInstanceInput)
    pub fn builder() -> crate::input::deregister_container_instance_input::Builder {
        crate::input::deregister_container_instance_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    #[allow(dead_code)]
    fn parse_response(
        &self,
        response: &http::response::Response<bytes::Bytes>,
    ) -> Result<
        crate::output::DeregisterContainerInstanceOutput,
        crate::error::DeregisterContainerInstanceError,
    > {
        if crate::aws_json_errors::is_error(&response) {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);
            let error_code = match generic.code() {
                Some(code) => code,
                None => {
                    return Err(crate::error::DeregisterContainerInstanceError::unhandled(
                        generic,
                    ))
                }
            };
            return Err(match error_code {
                "ClientException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::DeregisterContainerInstanceError { kind: crate::error::DeregisterContainerInstanceErrorKind::ClientError(body), meta: generic },
                    Err(e) => crate::error::DeregisterContainerInstanceError::unhandled(e)
                }
                "ClusterNotFoundException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::DeregisterContainerInstanceError { kind: crate::error::DeregisterContainerInstanceErrorKind::ClusterNotFoundError(body), meta: generic },
                    Err(e) => crate::error::DeregisterContainerInstanceError::unhandled(e)
                }
                "InvalidParameterException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::DeregisterContainerInstanceError { kind: crate::error::DeregisterContainerInstanceErrorKind::InvalidParameterError(body), meta: generic },
                    Err(e) => crate::error::DeregisterContainerInstanceError::unhandled(e)
                }
                "ServerException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::DeregisterContainerInstanceError { kind: crate::error::DeregisterContainerInstanceErrorKind::ServerError(body), meta: generic },
                    Err(e) => crate::error::DeregisterContainerInstanceError::unhandled(e)
                }
                _ => crate::error::DeregisterContainerInstanceError::generic(generic)
            });
        }
        #[allow(unused_mut)]
        let mut builder = crate::output::deregister_container_instance_output::Builder::default();
        builder = crate::json_deser::deregister_container_instance_deser_operation(
            response.body().as_ref(),
            builder,
        )
        .map_err(crate::error::DeregisterContainerInstanceError::unhandled)?;
        Ok(builder.build())
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeregisterContainerInstance {
    type Output = Result<
        crate::output::DeregisterContainerInstanceOutput,
        crate::error::DeregisterContainerInstanceError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Deregisters the specified task definition by family and revision. Upon deregistration,
/// the task definition is marked as <code>INACTIVE</code>. Existing tasks and services that
/// reference an <code>INACTIVE</code> task definition continue to run without disruption.
/// Existing services that reference an <code>INACTIVE</code> task definition can still
/// scale up or down by modifying the service's desired count.</p>
/// <p>You cannot use an <code>INACTIVE</code> task definition to run new tasks or create new
/// services, and you cannot update an existing service to reference an
/// <code>INACTIVE</code> task definition. However, there may be up to a 10-minute
/// window following deregistration where these restrictions have not yet taken
/// effect.</p>
/// <note>
/// <p>At this time, <code>INACTIVE</code> task definitions remain discoverable in your
/// account indefinitely. However, this behavior is subject to change in the future, so
/// you should not rely on <code>INACTIVE</code> task definitions persisting beyond the
/// lifecycle of any associated tasks and services.</p>
/// </note>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeregisterTaskDefinition {
    _private: (),
}
impl DeregisterTaskDefinition {
    /// Creates a new builder-style object to manufacture [`DeregisterTaskDefinitionInput`](crate::input::DeregisterTaskDefinitionInput)
    pub fn builder() -> crate::input::deregister_task_definition_input::Builder {
        crate::input::deregister_task_definition_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    #[allow(dead_code)]
    fn parse_response(
        &self,
        response: &http::response::Response<bytes::Bytes>,
    ) -> Result<
        crate::output::DeregisterTaskDefinitionOutput,
        crate::error::DeregisterTaskDefinitionError,
    > {
        if crate::aws_json_errors::is_error(&response) {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);
            let error_code = match generic.code() {
                Some(code) => code,
                None => {
                    return Err(crate::error::DeregisterTaskDefinitionError::unhandled(
                        generic,
                    ))
                }
            };
            return Err(match error_code {
                "ClientException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::DeregisterTaskDefinitionError {
                        kind: crate::error::DeregisterTaskDefinitionErrorKind::ClientError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::DeregisterTaskDefinitionError::unhandled(e),
                },
                "InvalidParameterException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::DeregisterTaskDefinitionError {
                        kind:
                            crate::error::DeregisterTaskDefinitionErrorKind::InvalidParameterError(
                                body,
                            ),
                        meta: generic,
                    },
                    Err(e) => crate::error::DeregisterTaskDefinitionError::unhandled(e),
                },
                "ServerException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::DeregisterTaskDefinitionError {
                        kind: crate::error::DeregisterTaskDefinitionErrorKind::ServerError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::DeregisterTaskDefinitionError::unhandled(e),
                },
                _ => crate::error::DeregisterTaskDefinitionError::generic(generic),
            });
        }
        #[allow(unused_mut)]
        let mut builder = crate::output::deregister_task_definition_output::Builder::default();
        builder = crate::json_deser::deregister_task_definition_deser_operation(
            response.body().as_ref(),
            builder,
        )
        .map_err(crate::error::DeregisterTaskDefinitionError::unhandled)?;
        Ok(builder.build())
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeregisterTaskDefinition {
    type Output = Result<
        crate::output::DeregisterTaskDefinitionOutput,
        crate::error::DeregisterTaskDefinitionError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Describes one or more of your capacity providers.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeCapacityProviders {
    _private: (),
}
impl DescribeCapacityProviders {
    /// Creates a new builder-style object to manufacture [`DescribeCapacityProvidersInput`](crate::input::DescribeCapacityProvidersInput)
    pub fn builder() -> crate::input::describe_capacity_providers_input::Builder {
        crate::input::describe_capacity_providers_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    #[allow(dead_code)]
    fn parse_response(
        &self,
        response: &http::response::Response<bytes::Bytes>,
    ) -> Result<
        crate::output::DescribeCapacityProvidersOutput,
        crate::error::DescribeCapacityProvidersError,
    > {
        if crate::aws_json_errors::is_error(&response) {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);
            let error_code = match generic.code() {
                Some(code) => code,
                None => {
                    return Err(crate::error::DescribeCapacityProvidersError::unhandled(
                        generic,
                    ))
                }
            };
            return Err(match error_code {
                "ClientException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::DescribeCapacityProvidersError {
                        kind: crate::error::DescribeCapacityProvidersErrorKind::ClientError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::DescribeCapacityProvidersError::unhandled(e),
                },
                "InvalidParameterException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::DescribeCapacityProvidersError {
                        kind:
                            crate::error::DescribeCapacityProvidersErrorKind::InvalidParameterError(
                                body,
                            ),
                        meta: generic,
                    },
                    Err(e) => crate::error::DescribeCapacityProvidersError::unhandled(e),
                },
                "ServerException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::DescribeCapacityProvidersError {
                        kind: crate::error::DescribeCapacityProvidersErrorKind::ServerError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::DescribeCapacityProvidersError::unhandled(e),
                },
                _ => crate::error::DescribeCapacityProvidersError::generic(generic),
            });
        }
        #[allow(unused_mut)]
        let mut builder = crate::output::describe_capacity_providers_output::Builder::default();
        builder = crate::json_deser::describe_capacity_providers_deser_operation(
            response.body().as_ref(),
            builder,
        )
        .map_err(crate::error::DescribeCapacityProvidersError::unhandled)?;
        Ok(builder.build())
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeCapacityProviders {
    type Output = Result<
        crate::output::DescribeCapacityProvidersOutput,
        crate::error::DescribeCapacityProvidersError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Describes one or more of your clusters.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeClusters {
    _private: (),
}
impl DescribeClusters {
    /// Creates a new builder-style object to manufacture [`DescribeClustersInput`](crate::input::DescribeClustersInput)
    pub fn builder() -> crate::input::describe_clusters_input::Builder {
        crate::input::describe_clusters_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    #[allow(dead_code)]
    fn parse_response(
        &self,
        response: &http::response::Response<bytes::Bytes>,
    ) -> Result<crate::output::DescribeClustersOutput, crate::error::DescribeClustersError> {
        if crate::aws_json_errors::is_error(&response) {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);
            let error_code = match generic.code() {
                Some(code) => code,
                None => return Err(crate::error::DescribeClustersError::unhandled(generic)),
            };
            return Err(match error_code {
                "ClientException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::DescribeClustersError {
                        kind: crate::error::DescribeClustersErrorKind::ClientError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::DescribeClustersError::unhandled(e),
                },
                "InvalidParameterException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::DescribeClustersError {
                        kind: crate::error::DescribeClustersErrorKind::InvalidParameterError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::DescribeClustersError::unhandled(e),
                },
                "ServerException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::DescribeClustersError {
                        kind: crate::error::DescribeClustersErrorKind::ServerError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::DescribeClustersError::unhandled(e),
                },
                _ => crate::error::DescribeClustersError::generic(generic),
            });
        }
        #[allow(unused_mut)]
        let mut builder = crate::output::describe_clusters_output::Builder::default();
        builder =
            crate::json_deser::describe_clusters_deser_operation(response.body().as_ref(), builder)
                .map_err(crate::error::DescribeClustersError::unhandled)?;
        Ok(builder.build())
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeClusters {
    type Output =
        Result<crate::output::DescribeClustersOutput, crate::error::DescribeClustersError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Describes Amazon Elastic Container Service container instances. Returns metadata about registered and
/// remaining resources on each container instance requested.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeContainerInstances {
    _private: (),
}
impl DescribeContainerInstances {
    /// Creates a new builder-style object to manufacture [`DescribeContainerInstancesInput`](crate::input::DescribeContainerInstancesInput)
    pub fn builder() -> crate::input::describe_container_instances_input::Builder {
        crate::input::describe_container_instances_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    #[allow(dead_code)]
    fn parse_response(
        &self,
        response: &http::response::Response<bytes::Bytes>,
    ) -> Result<
        crate::output::DescribeContainerInstancesOutput,
        crate::error::DescribeContainerInstancesError,
    > {
        if crate::aws_json_errors::is_error(&response) {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);
            let error_code = match generic.code() {
                Some(code) => code,
                None => {
                    return Err(crate::error::DescribeContainerInstancesError::unhandled(
                        generic,
                    ))
                }
            };
            return Err(match error_code {
                "ClientException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::DescribeContainerInstancesError {
                        kind: crate::error::DescribeContainerInstancesErrorKind::ClientError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::DescribeContainerInstancesError::unhandled(e),
                },
                "ClusterNotFoundException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::DescribeContainerInstancesError {
                        kind:
                            crate::error::DescribeContainerInstancesErrorKind::ClusterNotFoundError(
                                body,
                            ),
                        meta: generic,
                    },
                    Err(e) => crate::error::DescribeContainerInstancesError::unhandled(e),
                },
                "InvalidParameterException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::DescribeContainerInstancesError {
                        kind:
                            crate::error::DescribeContainerInstancesErrorKind::InvalidParameterError(
                                body,
                            ),
                        meta: generic,
                    },
                    Err(e) => crate::error::DescribeContainerInstancesError::unhandled(e),
                },
                "ServerException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::DescribeContainerInstancesError {
                        kind: crate::error::DescribeContainerInstancesErrorKind::ServerError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::DescribeContainerInstancesError::unhandled(e),
                },
                _ => crate::error::DescribeContainerInstancesError::generic(generic),
            });
        }
        #[allow(unused_mut)]
        let mut builder = crate::output::describe_container_instances_output::Builder::default();
        builder = crate::json_deser::describe_container_instances_deser_operation(
            response.body().as_ref(),
            builder,
        )
        .map_err(crate::error::DescribeContainerInstancesError::unhandled)?;
        Ok(builder.build())
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeContainerInstances {
    type Output = Result<
        crate::output::DescribeContainerInstancesOutput,
        crate::error::DescribeContainerInstancesError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Describes the specified services running in your cluster.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeServices {
    _private: (),
}
impl DescribeServices {
    /// Creates a new builder-style object to manufacture [`DescribeServicesInput`](crate::input::DescribeServicesInput)
    pub fn builder() -> crate::input::describe_services_input::Builder {
        crate::input::describe_services_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    #[allow(dead_code)]
    fn parse_response(
        &self,
        response: &http::response::Response<bytes::Bytes>,
    ) -> Result<crate::output::DescribeServicesOutput, crate::error::DescribeServicesError> {
        if crate::aws_json_errors::is_error(&response) {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);
            let error_code = match generic.code() {
                Some(code) => code,
                None => return Err(crate::error::DescribeServicesError::unhandled(generic)),
            };
            return Err(match error_code {
                "ClientException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::DescribeServicesError {
                        kind: crate::error::DescribeServicesErrorKind::ClientError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::DescribeServicesError::unhandled(e),
                },
                "ClusterNotFoundException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::DescribeServicesError {
                        kind: crate::error::DescribeServicesErrorKind::ClusterNotFoundError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::DescribeServicesError::unhandled(e),
                },
                "InvalidParameterException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::DescribeServicesError {
                        kind: crate::error::DescribeServicesErrorKind::InvalidParameterError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::DescribeServicesError::unhandled(e),
                },
                "ServerException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::DescribeServicesError {
                        kind: crate::error::DescribeServicesErrorKind::ServerError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::DescribeServicesError::unhandled(e),
                },
                _ => crate::error::DescribeServicesError::generic(generic),
            });
        }
        #[allow(unused_mut)]
        let mut builder = crate::output::describe_services_output::Builder::default();
        builder =
            crate::json_deser::describe_services_deser_operation(response.body().as_ref(), builder)
                .map_err(crate::error::DescribeServicesError::unhandled)?;
        Ok(builder.build())
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeServices {
    type Output =
        Result<crate::output::DescribeServicesOutput, crate::error::DescribeServicesError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Describes a task definition. You can specify a <code>family</code> and
/// <code>revision</code> to find information about a specific task definition, or you
/// can simply specify the family to find the latest <code>ACTIVE</code> revision in that
/// family.</p>
/// <note>
/// <p>You can only describe <code>INACTIVE</code> task definitions while an active task
/// or service references them.</p>
/// </note>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeTaskDefinition {
    _private: (),
}
impl DescribeTaskDefinition {
    /// Creates a new builder-style object to manufacture [`DescribeTaskDefinitionInput`](crate::input::DescribeTaskDefinitionInput)
    pub fn builder() -> crate::input::describe_task_definition_input::Builder {
        crate::input::describe_task_definition_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    #[allow(dead_code)]
    fn parse_response(
        &self,
        response: &http::response::Response<bytes::Bytes>,
    ) -> Result<
        crate::output::DescribeTaskDefinitionOutput,
        crate::error::DescribeTaskDefinitionError,
    > {
        if crate::aws_json_errors::is_error(&response) {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);
            let error_code = match generic.code() {
                Some(code) => code,
                None => {
                    return Err(crate::error::DescribeTaskDefinitionError::unhandled(
                        generic,
                    ))
                }
            };
            return Err(match error_code {
                "ClientException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::DescribeTaskDefinitionError {
                        kind: crate::error::DescribeTaskDefinitionErrorKind::ClientError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::DescribeTaskDefinitionError::unhandled(e),
                },
                "InvalidParameterException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::DescribeTaskDefinitionError {
                        kind: crate::error::DescribeTaskDefinitionErrorKind::InvalidParameterError(
                            body,
                        ),
                        meta: generic,
                    },
                    Err(e) => crate::error::DescribeTaskDefinitionError::unhandled(e),
                },
                "ServerException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::DescribeTaskDefinitionError {
                        kind: crate::error::DescribeTaskDefinitionErrorKind::ServerError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::DescribeTaskDefinitionError::unhandled(e),
                },
                _ => crate::error::DescribeTaskDefinitionError::generic(generic),
            });
        }
        #[allow(unused_mut)]
        let mut builder = crate::output::describe_task_definition_output::Builder::default();
        builder = crate::json_deser::describe_task_definition_deser_operation(
            response.body().as_ref(),
            builder,
        )
        .map_err(crate::error::DescribeTaskDefinitionError::unhandled)?;
        Ok(builder.build())
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeTaskDefinition {
    type Output = Result<
        crate::output::DescribeTaskDefinitionOutput,
        crate::error::DescribeTaskDefinitionError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Describes a specified task or tasks.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeTasks {
    _private: (),
}
impl DescribeTasks {
    /// Creates a new builder-style object to manufacture [`DescribeTasksInput`](crate::input::DescribeTasksInput)
    pub fn builder() -> crate::input::describe_tasks_input::Builder {
        crate::input::describe_tasks_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    #[allow(dead_code)]
    fn parse_response(
        &self,
        response: &http::response::Response<bytes::Bytes>,
    ) -> Result<crate::output::DescribeTasksOutput, crate::error::DescribeTasksError> {
        if crate::aws_json_errors::is_error(&response) {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);
            let error_code = match generic.code() {
                Some(code) => code,
                None => return Err(crate::error::DescribeTasksError::unhandled(generic)),
            };
            return Err(match error_code {
                "ClientException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::DescribeTasksError {
                        kind: crate::error::DescribeTasksErrorKind::ClientError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::DescribeTasksError::unhandled(e),
                },
                "ClusterNotFoundException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::DescribeTasksError {
                        kind: crate::error::DescribeTasksErrorKind::ClusterNotFoundError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::DescribeTasksError::unhandled(e),
                },
                "InvalidParameterException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::DescribeTasksError {
                        kind: crate::error::DescribeTasksErrorKind::InvalidParameterError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::DescribeTasksError::unhandled(e),
                },
                "ServerException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::DescribeTasksError {
                        kind: crate::error::DescribeTasksErrorKind::ServerError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::DescribeTasksError::unhandled(e),
                },
                _ => crate::error::DescribeTasksError::generic(generic),
            });
        }
        #[allow(unused_mut)]
        let mut builder = crate::output::describe_tasks_output::Builder::default();
        builder =
            crate::json_deser::describe_tasks_deser_operation(response.body().as_ref(), builder)
                .map_err(crate::error::DescribeTasksError::unhandled)?;
        Ok(builder.build())
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeTasks {
    type Output = Result<crate::output::DescribeTasksOutput, crate::error::DescribeTasksError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Describes the task sets in the specified cluster and service. This is used when a
/// service uses the <code>EXTERNAL</code> deployment controller type. For more information,
/// see <a href="https://docs.aws.amazon.com/AmazonECS/latest/developerguide/deployment-types.html">Amazon ECS Deployment
/// Types</a> in the <i>Amazon Elastic Container Service Developer Guide</i>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeTaskSets {
    _private: (),
}
impl DescribeTaskSets {
    /// Creates a new builder-style object to manufacture [`DescribeTaskSetsInput`](crate::input::DescribeTaskSetsInput)
    pub fn builder() -> crate::input::describe_task_sets_input::Builder {
        crate::input::describe_task_sets_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    #[allow(dead_code)]
    fn parse_response(
        &self,
        response: &http::response::Response<bytes::Bytes>,
    ) -> Result<crate::output::DescribeTaskSetsOutput, crate::error::DescribeTaskSetsError> {
        if crate::aws_json_errors::is_error(&response) {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);
            let error_code = match generic.code() {
                Some(code) => code,
                None => return Err(crate::error::DescribeTaskSetsError::unhandled(generic)),
            };
            return Err(match error_code {
                "AccessDeniedException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::DescribeTaskSetsError {
                        kind: crate::error::DescribeTaskSetsErrorKind::AccessDeniedError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::DescribeTaskSetsError::unhandled(e),
                },
                "ClientException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::DescribeTaskSetsError {
                        kind: crate::error::DescribeTaskSetsErrorKind::ClientError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::DescribeTaskSetsError::unhandled(e),
                },
                "ClusterNotFoundException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::DescribeTaskSetsError {
                        kind: crate::error::DescribeTaskSetsErrorKind::ClusterNotFoundError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::DescribeTaskSetsError::unhandled(e),
                },
                "InvalidParameterException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::DescribeTaskSetsError {
                        kind: crate::error::DescribeTaskSetsErrorKind::InvalidParameterError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::DescribeTaskSetsError::unhandled(e),
                },
                "ServerException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::DescribeTaskSetsError {
                        kind: crate::error::DescribeTaskSetsErrorKind::ServerError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::DescribeTaskSetsError::unhandled(e),
                },
                "ServiceNotActiveException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::DescribeTaskSetsError {
                        kind: crate::error::DescribeTaskSetsErrorKind::ServiceNotActiveError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::DescribeTaskSetsError::unhandled(e),
                },
                "ServiceNotFoundException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::DescribeTaskSetsError {
                        kind: crate::error::DescribeTaskSetsErrorKind::ServiceNotFoundError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::DescribeTaskSetsError::unhandled(e),
                },
                "UnsupportedFeatureException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::DescribeTaskSetsError {
                        kind: crate::error::DescribeTaskSetsErrorKind::UnsupportedFeatureError(
                            body,
                        ),
                        meta: generic,
                    },
                    Err(e) => crate::error::DescribeTaskSetsError::unhandled(e),
                },
                _ => crate::error::DescribeTaskSetsError::generic(generic),
            });
        }
        #[allow(unused_mut)]
        let mut builder = crate::output::describe_task_sets_output::Builder::default();
        builder = crate::json_deser::describe_task_sets_deser_operation(
            response.body().as_ref(),
            builder,
        )
        .map_err(crate::error::DescribeTaskSetsError::unhandled)?;
        Ok(builder.build())
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeTaskSets {
    type Output =
        Result<crate::output::DescribeTaskSetsOutput, crate::error::DescribeTaskSetsError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <note>
/// <p>This action is only used by the Amazon ECS agent, and it is not intended for use outside of the agent.</p>
/// </note>
/// <p>Returns an endpoint for
/// the Amazon ECS agent to poll for updates.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DiscoverPollEndpoint {
    _private: (),
}
impl DiscoverPollEndpoint {
    /// Creates a new builder-style object to manufacture [`DiscoverPollEndpointInput`](crate::input::DiscoverPollEndpointInput)
    pub fn builder() -> crate::input::discover_poll_endpoint_input::Builder {
        crate::input::discover_poll_endpoint_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    #[allow(dead_code)]
    fn parse_response(
        &self,
        response: &http::response::Response<bytes::Bytes>,
    ) -> Result<crate::output::DiscoverPollEndpointOutput, crate::error::DiscoverPollEndpointError>
    {
        if crate::aws_json_errors::is_error(&response) {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);
            let error_code = match generic.code() {
                Some(code) => code,
                None => return Err(crate::error::DiscoverPollEndpointError::unhandled(generic)),
            };
            return Err(match error_code {
                "ClientException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::DiscoverPollEndpointError {
                        kind: crate::error::DiscoverPollEndpointErrorKind::ClientError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::DiscoverPollEndpointError::unhandled(e),
                },
                "ServerException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::DiscoverPollEndpointError {
                        kind: crate::error::DiscoverPollEndpointErrorKind::ServerError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::DiscoverPollEndpointError::unhandled(e),
                },
                _ => crate::error::DiscoverPollEndpointError::generic(generic),
            });
        }
        #[allow(unused_mut)]
        let mut builder = crate::output::discover_poll_endpoint_output::Builder::default();
        builder = crate::json_deser::discover_poll_endpoint_deser_operation(
            response.body().as_ref(),
            builder,
        )
        .map_err(crate::error::DiscoverPollEndpointError::unhandled)?;
        Ok(builder.build())
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DiscoverPollEndpoint {
    type Output =
        Result<crate::output::DiscoverPollEndpointOutput, crate::error::DiscoverPollEndpointError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Runs a command remotely on a container within a task.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ExecuteCommand {
    _private: (),
}
impl ExecuteCommand {
    /// Creates a new builder-style object to manufacture [`ExecuteCommandInput`](crate::input::ExecuteCommandInput)
    pub fn builder() -> crate::input::execute_command_input::Builder {
        crate::input::execute_command_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    #[allow(dead_code)]
    fn parse_response(
        &self,
        response: &http::response::Response<bytes::Bytes>,
    ) -> Result<crate::output::ExecuteCommandOutput, crate::error::ExecuteCommandError> {
        if crate::aws_json_errors::is_error(&response) {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);
            let error_code = match generic.code() {
                Some(code) => code,
                None => return Err(crate::error::ExecuteCommandError::unhandled(generic)),
            };
            return Err(match error_code {
                "AccessDeniedException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::ExecuteCommandError {
                        kind: crate::error::ExecuteCommandErrorKind::AccessDeniedError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::ExecuteCommandError::unhandled(e),
                },
                "ClientException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::ExecuteCommandError {
                        kind: crate::error::ExecuteCommandErrorKind::ClientError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::ExecuteCommandError::unhandled(e),
                },
                "ClusterNotFoundException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::ExecuteCommandError {
                        kind: crate::error::ExecuteCommandErrorKind::ClusterNotFoundError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::ExecuteCommandError::unhandled(e),
                },
                "InvalidParameterException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::ExecuteCommandError {
                        kind: crate::error::ExecuteCommandErrorKind::InvalidParameterError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::ExecuteCommandError::unhandled(e),
                },
                "ServerException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::ExecuteCommandError {
                        kind: crate::error::ExecuteCommandErrorKind::ServerError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::ExecuteCommandError::unhandled(e),
                },
                "TargetNotConnectedException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::ExecuteCommandError {
                        kind: crate::error::ExecuteCommandErrorKind::TargetNotConnectedError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::ExecuteCommandError::unhandled(e),
                },
                _ => crate::error::ExecuteCommandError::generic(generic),
            });
        }
        #[allow(unused_mut)]
        let mut builder = crate::output::execute_command_output::Builder::default();
        builder =
            crate::json_deser::execute_command_deser_operation(response.body().as_ref(), builder)
                .map_err(crate::error::ExecuteCommandError::unhandled)?;
        Ok(builder.build())
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ExecuteCommand {
    type Output = Result<crate::output::ExecuteCommandOutput, crate::error::ExecuteCommandError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Lists the account settings for a specified principal.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListAccountSettings {
    _private: (),
}
impl ListAccountSettings {
    /// Creates a new builder-style object to manufacture [`ListAccountSettingsInput`](crate::input::ListAccountSettingsInput)
    pub fn builder() -> crate::input::list_account_settings_input::Builder {
        crate::input::list_account_settings_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    #[allow(dead_code)]
    fn parse_response(
        &self,
        response: &http::response::Response<bytes::Bytes>,
    ) -> Result<crate::output::ListAccountSettingsOutput, crate::error::ListAccountSettingsError>
    {
        if crate::aws_json_errors::is_error(&response) {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);
            let error_code = match generic.code() {
                Some(code) => code,
                None => return Err(crate::error::ListAccountSettingsError::unhandled(generic)),
            };
            return Err(match error_code {
                "ClientException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::ListAccountSettingsError {
                        kind: crate::error::ListAccountSettingsErrorKind::ClientError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::ListAccountSettingsError::unhandled(e),
                },
                "InvalidParameterException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::ListAccountSettingsError {
                        kind: crate::error::ListAccountSettingsErrorKind::InvalidParameterError(
                            body,
                        ),
                        meta: generic,
                    },
                    Err(e) => crate::error::ListAccountSettingsError::unhandled(e),
                },
                "ServerException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::ListAccountSettingsError {
                        kind: crate::error::ListAccountSettingsErrorKind::ServerError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::ListAccountSettingsError::unhandled(e),
                },
                _ => crate::error::ListAccountSettingsError::generic(generic),
            });
        }
        #[allow(unused_mut)]
        let mut builder = crate::output::list_account_settings_output::Builder::default();
        builder = crate::json_deser::list_account_settings_deser_operation(
            response.body().as_ref(),
            builder,
        )
        .map_err(crate::error::ListAccountSettingsError::unhandled)?;
        Ok(builder.build())
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListAccountSettings {
    type Output =
        Result<crate::output::ListAccountSettingsOutput, crate::error::ListAccountSettingsError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Lists the attributes for Amazon ECS resources within a specified target type and cluster.
/// When you specify a target type and cluster, <code>ListAttributes</code> returns a list
/// of attribute objects, one for each attribute on each resource. You can filter the list
/// of results to a single attribute name to only return results that have that name. You
/// can also filter the results by attribute name and value, for example, to see which
/// container instances in a cluster are running a Linux AMI
/// (<code>ecs.os-type=linux</code>). </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListAttributes {
    _private: (),
}
impl ListAttributes {
    /// Creates a new builder-style object to manufacture [`ListAttributesInput`](crate::input::ListAttributesInput)
    pub fn builder() -> crate::input::list_attributes_input::Builder {
        crate::input::list_attributes_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    #[allow(dead_code)]
    fn parse_response(
        &self,
        response: &http::response::Response<bytes::Bytes>,
    ) -> Result<crate::output::ListAttributesOutput, crate::error::ListAttributesError> {
        if crate::aws_json_errors::is_error(&response) {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);
            let error_code = match generic.code() {
                Some(code) => code,
                None => return Err(crate::error::ListAttributesError::unhandled(generic)),
            };
            return Err(match error_code {
                "ClusterNotFoundException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::ListAttributesError {
                        kind: crate::error::ListAttributesErrorKind::ClusterNotFoundError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::ListAttributesError::unhandled(e),
                },
                "InvalidParameterException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::ListAttributesError {
                        kind: crate::error::ListAttributesErrorKind::InvalidParameterError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::ListAttributesError::unhandled(e),
                },
                _ => crate::error::ListAttributesError::generic(generic),
            });
        }
        #[allow(unused_mut)]
        let mut builder = crate::output::list_attributes_output::Builder::default();
        builder =
            crate::json_deser::list_attributes_deser_operation(response.body().as_ref(), builder)
                .map_err(crate::error::ListAttributesError::unhandled)?;
        Ok(builder.build())
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListAttributes {
    type Output = Result<crate::output::ListAttributesOutput, crate::error::ListAttributesError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Returns a list of existing clusters.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListClusters {
    _private: (),
}
impl ListClusters {
    /// Creates a new builder-style object to manufacture [`ListClustersInput`](crate::input::ListClustersInput)
    pub fn builder() -> crate::input::list_clusters_input::Builder {
        crate::input::list_clusters_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    #[allow(dead_code)]
    fn parse_response(
        &self,
        response: &http::response::Response<bytes::Bytes>,
    ) -> Result<crate::output::ListClustersOutput, crate::error::ListClustersError> {
        if crate::aws_json_errors::is_error(&response) {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);
            let error_code = match generic.code() {
                Some(code) => code,
                None => return Err(crate::error::ListClustersError::unhandled(generic)),
            };
            return Err(match error_code {
                "ClientException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::ListClustersError {
                        kind: crate::error::ListClustersErrorKind::ClientError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::ListClustersError::unhandled(e),
                },
                "InvalidParameterException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::ListClustersError {
                        kind: crate::error::ListClustersErrorKind::InvalidParameterError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::ListClustersError::unhandled(e),
                },
                "ServerException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::ListClustersError {
                        kind: crate::error::ListClustersErrorKind::ServerError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::ListClustersError::unhandled(e),
                },
                _ => crate::error::ListClustersError::generic(generic),
            });
        }
        #[allow(unused_mut)]
        let mut builder = crate::output::list_clusters_output::Builder::default();
        builder =
            crate::json_deser::list_clusters_deser_operation(response.body().as_ref(), builder)
                .map_err(crate::error::ListClustersError::unhandled)?;
        Ok(builder.build())
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListClusters {
    type Output = Result<crate::output::ListClustersOutput, crate::error::ListClustersError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Returns a list of container instances in a specified cluster. You can filter the
/// results of a <code>ListContainerInstances</code> operation with cluster query language
/// statements inside the <code>filter</code> parameter. For more information, see <a href="https://docs.aws.amazon.com/AmazonECS/latest/developerguide/cluster-query-language.html">Cluster Query Language</a> in the
/// <i>Amazon Elastic Container Service Developer Guide</i>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListContainerInstances {
    _private: (),
}
impl ListContainerInstances {
    /// Creates a new builder-style object to manufacture [`ListContainerInstancesInput`](crate::input::ListContainerInstancesInput)
    pub fn builder() -> crate::input::list_container_instances_input::Builder {
        crate::input::list_container_instances_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    #[allow(dead_code)]
    fn parse_response(
        &self,
        response: &http::response::Response<bytes::Bytes>,
    ) -> Result<
        crate::output::ListContainerInstancesOutput,
        crate::error::ListContainerInstancesError,
    > {
        if crate::aws_json_errors::is_error(&response) {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);
            let error_code = match generic.code() {
                Some(code) => code,
                None => {
                    return Err(crate::error::ListContainerInstancesError::unhandled(
                        generic,
                    ))
                }
            };
            return Err(match error_code {
                "ClientException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::ListContainerInstancesError {
                        kind: crate::error::ListContainerInstancesErrorKind::ClientError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::ListContainerInstancesError::unhandled(e),
                },
                "ClusterNotFoundException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::ListContainerInstancesError {
                        kind: crate::error::ListContainerInstancesErrorKind::ClusterNotFoundError(
                            body,
                        ),
                        meta: generic,
                    },
                    Err(e) => crate::error::ListContainerInstancesError::unhandled(e),
                },
                "InvalidParameterException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::ListContainerInstancesError {
                        kind: crate::error::ListContainerInstancesErrorKind::InvalidParameterError(
                            body,
                        ),
                        meta: generic,
                    },
                    Err(e) => crate::error::ListContainerInstancesError::unhandled(e),
                },
                "ServerException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::ListContainerInstancesError {
                        kind: crate::error::ListContainerInstancesErrorKind::ServerError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::ListContainerInstancesError::unhandled(e),
                },
                _ => crate::error::ListContainerInstancesError::generic(generic),
            });
        }
        #[allow(unused_mut)]
        let mut builder = crate::output::list_container_instances_output::Builder::default();
        builder = crate::json_deser::list_container_instances_deser_operation(
            response.body().as_ref(),
            builder,
        )
        .map_err(crate::error::ListContainerInstancesError::unhandled)?;
        Ok(builder.build())
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListContainerInstances {
    type Output = Result<
        crate::output::ListContainerInstancesOutput,
        crate::error::ListContainerInstancesError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Returns a list of services. You can filter the results by cluster, launch type, and
/// scheduling strategy.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListServices {
    _private: (),
}
impl ListServices {
    /// Creates a new builder-style object to manufacture [`ListServicesInput`](crate::input::ListServicesInput)
    pub fn builder() -> crate::input::list_services_input::Builder {
        crate::input::list_services_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    #[allow(dead_code)]
    fn parse_response(
        &self,
        response: &http::response::Response<bytes::Bytes>,
    ) -> Result<crate::output::ListServicesOutput, crate::error::ListServicesError> {
        if crate::aws_json_errors::is_error(&response) {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);
            let error_code = match generic.code() {
                Some(code) => code,
                None => return Err(crate::error::ListServicesError::unhandled(generic)),
            };
            return Err(match error_code {
                "ClientException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::ListServicesError {
                        kind: crate::error::ListServicesErrorKind::ClientError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::ListServicesError::unhandled(e),
                },
                "ClusterNotFoundException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::ListServicesError {
                        kind: crate::error::ListServicesErrorKind::ClusterNotFoundError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::ListServicesError::unhandled(e),
                },
                "InvalidParameterException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::ListServicesError {
                        kind: crate::error::ListServicesErrorKind::InvalidParameterError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::ListServicesError::unhandled(e),
                },
                "ServerException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::ListServicesError {
                        kind: crate::error::ListServicesErrorKind::ServerError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::ListServicesError::unhandled(e),
                },
                _ => crate::error::ListServicesError::generic(generic),
            });
        }
        #[allow(unused_mut)]
        let mut builder = crate::output::list_services_output::Builder::default();
        builder =
            crate::json_deser::list_services_deser_operation(response.body().as_ref(), builder)
                .map_err(crate::error::ListServicesError::unhandled)?;
        Ok(builder.build())
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListServices {
    type Output = Result<crate::output::ListServicesOutput, crate::error::ListServicesError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>List the tags for an Amazon ECS resource.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListTagsForResource {
    _private: (),
}
impl ListTagsForResource {
    /// Creates a new builder-style object to manufacture [`ListTagsForResourceInput`](crate::input::ListTagsForResourceInput)
    pub fn builder() -> crate::input::list_tags_for_resource_input::Builder {
        crate::input::list_tags_for_resource_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    #[allow(dead_code)]
    fn parse_response(
        &self,
        response: &http::response::Response<bytes::Bytes>,
    ) -> Result<crate::output::ListTagsForResourceOutput, crate::error::ListTagsForResourceError>
    {
        if crate::aws_json_errors::is_error(&response) {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);
            let error_code = match generic.code() {
                Some(code) => code,
                None => return Err(crate::error::ListTagsForResourceError::unhandled(generic)),
            };
            return Err(match error_code {
                "ClientException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::ListTagsForResourceError {
                        kind: crate::error::ListTagsForResourceErrorKind::ClientError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::ListTagsForResourceError::unhandled(e),
                },
                "ClusterNotFoundException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::ListTagsForResourceError {
                        kind: crate::error::ListTagsForResourceErrorKind::ClusterNotFoundError(
                            body,
                        ),
                        meta: generic,
                    },
                    Err(e) => crate::error::ListTagsForResourceError::unhandled(e),
                },
                "InvalidParameterException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::ListTagsForResourceError {
                        kind: crate::error::ListTagsForResourceErrorKind::InvalidParameterError(
                            body,
                        ),
                        meta: generic,
                    },
                    Err(e) => crate::error::ListTagsForResourceError::unhandled(e),
                },
                "ServerException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::ListTagsForResourceError {
                        kind: crate::error::ListTagsForResourceErrorKind::ServerError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::ListTagsForResourceError::unhandled(e),
                },
                _ => crate::error::ListTagsForResourceError::generic(generic),
            });
        }
        #[allow(unused_mut)]
        let mut builder = crate::output::list_tags_for_resource_output::Builder::default();
        builder = crate::json_deser::list_tags_for_resource_deser_operation(
            response.body().as_ref(),
            builder,
        )
        .map_err(crate::error::ListTagsForResourceError::unhandled)?;
        Ok(builder.build())
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListTagsForResource {
    type Output =
        Result<crate::output::ListTagsForResourceOutput, crate::error::ListTagsForResourceError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Returns a list of task definition families that are registered to your account (which
/// may include task definition families that no longer have any <code>ACTIVE</code> task
/// definition revisions).</p>
/// <p>You can filter out task definition families that do not contain any
/// <code>ACTIVE</code> task definition revisions by setting the <code>status</code>
/// parameter to <code>ACTIVE</code>. You can also filter the results with the
/// <code>familyPrefix</code> parameter.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListTaskDefinitionFamilies {
    _private: (),
}
impl ListTaskDefinitionFamilies {
    /// Creates a new builder-style object to manufacture [`ListTaskDefinitionFamiliesInput`](crate::input::ListTaskDefinitionFamiliesInput)
    pub fn builder() -> crate::input::list_task_definition_families_input::Builder {
        crate::input::list_task_definition_families_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    #[allow(dead_code)]
    fn parse_response(
        &self,
        response: &http::response::Response<bytes::Bytes>,
    ) -> Result<
        crate::output::ListTaskDefinitionFamiliesOutput,
        crate::error::ListTaskDefinitionFamiliesError,
    > {
        if crate::aws_json_errors::is_error(&response) {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);
            let error_code = match generic.code() {
                Some(code) => code,
                None => {
                    return Err(crate::error::ListTaskDefinitionFamiliesError::unhandled(
                        generic,
                    ))
                }
            };
            return Err(match error_code {
                "ClientException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::ListTaskDefinitionFamiliesError {
                        kind: crate::error::ListTaskDefinitionFamiliesErrorKind::ClientError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::ListTaskDefinitionFamiliesError::unhandled(e),
                },
                "InvalidParameterException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::ListTaskDefinitionFamiliesError {
                        kind:
                            crate::error::ListTaskDefinitionFamiliesErrorKind::InvalidParameterError(
                                body,
                            ),
                        meta: generic,
                    },
                    Err(e) => crate::error::ListTaskDefinitionFamiliesError::unhandled(e),
                },
                "ServerException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::ListTaskDefinitionFamiliesError {
                        kind: crate::error::ListTaskDefinitionFamiliesErrorKind::ServerError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::ListTaskDefinitionFamiliesError::unhandled(e),
                },
                _ => crate::error::ListTaskDefinitionFamiliesError::generic(generic),
            });
        }
        #[allow(unused_mut)]
        let mut builder = crate::output::list_task_definition_families_output::Builder::default();
        builder = crate::json_deser::list_task_definition_families_deser_operation(
            response.body().as_ref(),
            builder,
        )
        .map_err(crate::error::ListTaskDefinitionFamiliesError::unhandled)?;
        Ok(builder.build())
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListTaskDefinitionFamilies {
    type Output = Result<
        crate::output::ListTaskDefinitionFamiliesOutput,
        crate::error::ListTaskDefinitionFamiliesError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Returns a list of task definitions that are registered to your account. You can filter
/// the results by family name with the <code>familyPrefix</code> parameter or by status
/// with the <code>status</code> parameter.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListTaskDefinitions {
    _private: (),
}
impl ListTaskDefinitions {
    /// Creates a new builder-style object to manufacture [`ListTaskDefinitionsInput`](crate::input::ListTaskDefinitionsInput)
    pub fn builder() -> crate::input::list_task_definitions_input::Builder {
        crate::input::list_task_definitions_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    #[allow(dead_code)]
    fn parse_response(
        &self,
        response: &http::response::Response<bytes::Bytes>,
    ) -> Result<crate::output::ListTaskDefinitionsOutput, crate::error::ListTaskDefinitionsError>
    {
        if crate::aws_json_errors::is_error(&response) {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);
            let error_code = match generic.code() {
                Some(code) => code,
                None => return Err(crate::error::ListTaskDefinitionsError::unhandled(generic)),
            };
            return Err(match error_code {
                "ClientException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::ListTaskDefinitionsError {
                        kind: crate::error::ListTaskDefinitionsErrorKind::ClientError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::ListTaskDefinitionsError::unhandled(e),
                },
                "InvalidParameterException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::ListTaskDefinitionsError {
                        kind: crate::error::ListTaskDefinitionsErrorKind::InvalidParameterError(
                            body,
                        ),
                        meta: generic,
                    },
                    Err(e) => crate::error::ListTaskDefinitionsError::unhandled(e),
                },
                "ServerException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::ListTaskDefinitionsError {
                        kind: crate::error::ListTaskDefinitionsErrorKind::ServerError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::ListTaskDefinitionsError::unhandled(e),
                },
                _ => crate::error::ListTaskDefinitionsError::generic(generic),
            });
        }
        #[allow(unused_mut)]
        let mut builder = crate::output::list_task_definitions_output::Builder::default();
        builder = crate::json_deser::list_task_definitions_deser_operation(
            response.body().as_ref(),
            builder,
        )
        .map_err(crate::error::ListTaskDefinitionsError::unhandled)?;
        Ok(builder.build())
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListTaskDefinitions {
    type Output =
        Result<crate::output::ListTaskDefinitionsOutput, crate::error::ListTaskDefinitionsError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Returns a list of tasks. You can filter the results by cluster, task definition
/// family, container instance, launch type, what IAM principal started the task, or by the
/// desired status of the task.</p>
/// <p>Recently stopped tasks might appear in the returned results. Currently, stopped tasks
/// appear in the returned results for at least one hour.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListTasks {
    _private: (),
}
impl ListTasks {
    /// Creates a new builder-style object to manufacture [`ListTasksInput`](crate::input::ListTasksInput)
    pub fn builder() -> crate::input::list_tasks_input::Builder {
        crate::input::list_tasks_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    #[allow(dead_code)]
    fn parse_response(
        &self,
        response: &http::response::Response<bytes::Bytes>,
    ) -> Result<crate::output::ListTasksOutput, crate::error::ListTasksError> {
        if crate::aws_json_errors::is_error(&response) {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);
            let error_code = match generic.code() {
                Some(code) => code,
                None => return Err(crate::error::ListTasksError::unhandled(generic)),
            };
            return Err(match error_code {
                "ClientException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::ListTasksError {
                        kind: crate::error::ListTasksErrorKind::ClientError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::ListTasksError::unhandled(e),
                },
                "ClusterNotFoundException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::ListTasksError {
                        kind: crate::error::ListTasksErrorKind::ClusterNotFoundError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::ListTasksError::unhandled(e),
                },
                "InvalidParameterException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::ListTasksError {
                        kind: crate::error::ListTasksErrorKind::InvalidParameterError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::ListTasksError::unhandled(e),
                },
                "ServerException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::ListTasksError {
                        kind: crate::error::ListTasksErrorKind::ServerError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::ListTasksError::unhandled(e),
                },
                "ServiceNotFoundException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::ListTasksError {
                        kind: crate::error::ListTasksErrorKind::ServiceNotFoundError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::ListTasksError::unhandled(e),
                },
                _ => crate::error::ListTasksError::generic(generic),
            });
        }
        #[allow(unused_mut)]
        let mut builder = crate::output::list_tasks_output::Builder::default();
        builder = crate::json_deser::list_tasks_deser_operation(response.body().as_ref(), builder)
            .map_err(crate::error::ListTasksError::unhandled)?;
        Ok(builder.build())
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListTasks {
    type Output = Result<crate::output::ListTasksOutput, crate::error::ListTasksError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Modifies an account setting. Account settings are set on a per-Region basis.</p>
/// <p>If you change the account setting for the root user, the default settings for all of
/// the IAM users and roles for which no individual account setting has been specified are
/// reset. For more information, see <a href="https://docs.aws.amazon.com/AmazonECS/latest/developerguide/ecs-account-settings.html">Account
/// Settings</a> in the <i>Amazon Elastic Container Service Developer Guide</i>.</p>
/// <p>When <code>serviceLongArnFormat</code>, <code>taskLongArnFormat</code>, or
/// <code>containerInstanceLongArnFormat</code> are specified, the Amazon Resource Name
/// (ARN) and resource ID format of the resource type for a specified IAM user, IAM role, or
/// the root user for an account is affected. The opt-in and opt-out account setting must be
/// set for each Amazon ECS resource separately. The ARN and resource ID format of a resource
/// will be defined by the opt-in status of the IAM user or role that created the resource.
/// You must enable this setting to use Amazon ECS features such as resource tagging.</p>
/// <p>When <code>awsvpcTrunking</code> is specified, the elastic network interface (ENI)
/// limit for any new container instances that support the feature is changed. If
/// <code>awsvpcTrunking</code> is enabled, any new container instances that support the
/// feature are launched have the increased ENI limits available to them. For more
/// information, see <a href="https://docs.aws.amazon.com/AmazonECS/latest/developerguide/container-instance-eni.html">Elastic Network
/// Interface Trunking</a> in the <i>Amazon Elastic Container Service Developer Guide</i>.</p>
/// <p>When <code>containerInsights</code> is specified, the default setting indicating
/// whether CloudWatch Container Insights is enabled for your clusters is changed. If
/// <code>containerInsights</code> is enabled, any new clusters that are created will
/// have Container Insights enabled unless you disable it during cluster creation. For more
/// information, see <a href="https://docs.aws.amazon.com/AmazonECS/latest/developerguide/cloudwatch-container-insights.html">CloudWatch
/// Container Insights</a> in the <i>Amazon Elastic Container Service Developer Guide</i>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct PutAccountSetting {
    _private: (),
}
impl PutAccountSetting {
    /// Creates a new builder-style object to manufacture [`PutAccountSettingInput`](crate::input::PutAccountSettingInput)
    pub fn builder() -> crate::input::put_account_setting_input::Builder {
        crate::input::put_account_setting_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    #[allow(dead_code)]
    fn parse_response(
        &self,
        response: &http::response::Response<bytes::Bytes>,
    ) -> Result<crate::output::PutAccountSettingOutput, crate::error::PutAccountSettingError> {
        if crate::aws_json_errors::is_error(&response) {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);
            let error_code = match generic.code() {
                Some(code) => code,
                None => return Err(crate::error::PutAccountSettingError::unhandled(generic)),
            };
            return Err(match error_code {
                "ClientException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::PutAccountSettingError {
                        kind: crate::error::PutAccountSettingErrorKind::ClientError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::PutAccountSettingError::unhandled(e),
                },
                "InvalidParameterException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::PutAccountSettingError {
                        kind: crate::error::PutAccountSettingErrorKind::InvalidParameterError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::PutAccountSettingError::unhandled(e),
                },
                "ServerException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::PutAccountSettingError {
                        kind: crate::error::PutAccountSettingErrorKind::ServerError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::PutAccountSettingError::unhandled(e),
                },
                _ => crate::error::PutAccountSettingError::generic(generic),
            });
        }
        #[allow(unused_mut)]
        let mut builder = crate::output::put_account_setting_output::Builder::default();
        builder = crate::json_deser::put_account_setting_deser_operation(
            response.body().as_ref(),
            builder,
        )
        .map_err(crate::error::PutAccountSettingError::unhandled)?;
        Ok(builder.build())
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for PutAccountSetting {
    type Output =
        Result<crate::output::PutAccountSettingOutput, crate::error::PutAccountSettingError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Modifies an account setting for all IAM users on an account for whom no individual
/// account setting has been specified. Account settings are set on a per-Region
/// basis.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct PutAccountSettingDefault {
    _private: (),
}
impl PutAccountSettingDefault {
    /// Creates a new builder-style object to manufacture [`PutAccountSettingDefaultInput`](crate::input::PutAccountSettingDefaultInput)
    pub fn builder() -> crate::input::put_account_setting_default_input::Builder {
        crate::input::put_account_setting_default_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    #[allow(dead_code)]
    fn parse_response(
        &self,
        response: &http::response::Response<bytes::Bytes>,
    ) -> Result<
        crate::output::PutAccountSettingDefaultOutput,
        crate::error::PutAccountSettingDefaultError,
    > {
        if crate::aws_json_errors::is_error(&response) {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);
            let error_code = match generic.code() {
                Some(code) => code,
                None => {
                    return Err(crate::error::PutAccountSettingDefaultError::unhandled(
                        generic,
                    ))
                }
            };
            return Err(match error_code {
                "ClientException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::PutAccountSettingDefaultError {
                        kind: crate::error::PutAccountSettingDefaultErrorKind::ClientError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::PutAccountSettingDefaultError::unhandled(e),
                },
                "InvalidParameterException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::PutAccountSettingDefaultError {
                        kind:
                            crate::error::PutAccountSettingDefaultErrorKind::InvalidParameterError(
                                body,
                            ),
                        meta: generic,
                    },
                    Err(e) => crate::error::PutAccountSettingDefaultError::unhandled(e),
                },
                "ServerException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::PutAccountSettingDefaultError {
                        kind: crate::error::PutAccountSettingDefaultErrorKind::ServerError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::PutAccountSettingDefaultError::unhandled(e),
                },
                _ => crate::error::PutAccountSettingDefaultError::generic(generic),
            });
        }
        #[allow(unused_mut)]
        let mut builder = crate::output::put_account_setting_default_output::Builder::default();
        builder = crate::json_deser::put_account_setting_default_deser_operation(
            response.body().as_ref(),
            builder,
        )
        .map_err(crate::error::PutAccountSettingDefaultError::unhandled)?;
        Ok(builder.build())
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for PutAccountSettingDefault {
    type Output = Result<
        crate::output::PutAccountSettingDefaultOutput,
        crate::error::PutAccountSettingDefaultError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Create or update an attribute on an Amazon ECS resource. If the attribute does not exist,
/// it is created. If the attribute exists, its value is replaced with the specified value.
/// To delete an attribute, use <a>DeleteAttributes</a>. For more information,
/// see <a href="https://docs.aws.amazon.com/AmazonECS/latest/developerguide/task-placement-constraints.html#attributes">Attributes</a> in the
/// <i>Amazon Elastic Container Service Developer Guide</i>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct PutAttributes {
    _private: (),
}
impl PutAttributes {
    /// Creates a new builder-style object to manufacture [`PutAttributesInput`](crate::input::PutAttributesInput)
    pub fn builder() -> crate::input::put_attributes_input::Builder {
        crate::input::put_attributes_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    #[allow(dead_code)]
    fn parse_response(
        &self,
        response: &http::response::Response<bytes::Bytes>,
    ) -> Result<crate::output::PutAttributesOutput, crate::error::PutAttributesError> {
        if crate::aws_json_errors::is_error(&response) {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);
            let error_code = match generic.code() {
                Some(code) => code,
                None => return Err(crate::error::PutAttributesError::unhandled(generic)),
            };
            return Err(match error_code {
                "AttributeLimitExceededException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::PutAttributesError {
                        kind: crate::error::PutAttributesErrorKind::AttributeLimitExceededError(
                            body,
                        ),
                        meta: generic,
                    },
                    Err(e) => crate::error::PutAttributesError::unhandled(e),
                },
                "ClusterNotFoundException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::PutAttributesError {
                        kind: crate::error::PutAttributesErrorKind::ClusterNotFoundError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::PutAttributesError::unhandled(e),
                },
                "InvalidParameterException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::PutAttributesError {
                        kind: crate::error::PutAttributesErrorKind::InvalidParameterError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::PutAttributesError::unhandled(e),
                },
                "TargetNotFoundException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::PutAttributesError {
                        kind: crate::error::PutAttributesErrorKind::TargetNotFoundError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::PutAttributesError::unhandled(e),
                },
                _ => crate::error::PutAttributesError::generic(generic),
            });
        }
        #[allow(unused_mut)]
        let mut builder = crate::output::put_attributes_output::Builder::default();
        builder =
            crate::json_deser::put_attributes_deser_operation(response.body().as_ref(), builder)
                .map_err(crate::error::PutAttributesError::unhandled)?;
        Ok(builder.build())
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for PutAttributes {
    type Output = Result<crate::output::PutAttributesOutput, crate::error::PutAttributesError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Modifies the available capacity providers and the default capacity provider strategy
/// for a cluster.</p>
/// <p>You must specify both the available capacity providers and a default capacity provider
/// strategy for the cluster. If the specified cluster has existing capacity providers
/// associated with it, you must specify all existing capacity providers in addition to any
/// new ones you want to add. Any existing capacity providers associated with a cluster that
/// are omitted from a <a>PutClusterCapacityProviders</a> API call will be
/// disassociated with the cluster. You can only disassociate an existing capacity provider
/// from a cluster if it's not being used by any existing tasks.</p>
/// <p>When creating a service or running a task on a cluster, if no capacity provider or
/// launch type is specified, then the cluster's default capacity provider strategy is used.
/// It is recommended to define a default capacity provider strategy for your cluster,
/// however you may specify an empty array (<code>[]</code>) to bypass defining a default
/// strategy.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct PutClusterCapacityProviders {
    _private: (),
}
impl PutClusterCapacityProviders {
    /// Creates a new builder-style object to manufacture [`PutClusterCapacityProvidersInput`](crate::input::PutClusterCapacityProvidersInput)
    pub fn builder() -> crate::input::put_cluster_capacity_providers_input::Builder {
        crate::input::put_cluster_capacity_providers_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    #[allow(dead_code)]
    fn parse_response(
        &self,
        response: &http::response::Response<bytes::Bytes>,
    ) -> Result<
        crate::output::PutClusterCapacityProvidersOutput,
        crate::error::PutClusterCapacityProvidersError,
    > {
        if crate::aws_json_errors::is_error(&response) {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);
            let error_code = match generic.code() {
                Some(code) => code,
                None => {
                    return Err(crate::error::PutClusterCapacityProvidersError::unhandled(
                        generic,
                    ))
                }
            };
            return Err(match error_code {
                "ClientException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::PutClusterCapacityProvidersError { kind: crate::error::PutClusterCapacityProvidersErrorKind::ClientError(body), meta: generic },
                    Err(e) => crate::error::PutClusterCapacityProvidersError::unhandled(e)
                }
                "ClusterNotFoundException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::PutClusterCapacityProvidersError { kind: crate::error::PutClusterCapacityProvidersErrorKind::ClusterNotFoundError(body), meta: generic },
                    Err(e) => crate::error::PutClusterCapacityProvidersError::unhandled(e)
                }
                "InvalidParameterException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::PutClusterCapacityProvidersError { kind: crate::error::PutClusterCapacityProvidersErrorKind::InvalidParameterError(body), meta: generic },
                    Err(e) => crate::error::PutClusterCapacityProvidersError::unhandled(e)
                }
                "ResourceInUseException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::PutClusterCapacityProvidersError { kind: crate::error::PutClusterCapacityProvidersErrorKind::ResourceInUseError(body), meta: generic },
                    Err(e) => crate::error::PutClusterCapacityProvidersError::unhandled(e)
                }
                "ServerException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::PutClusterCapacityProvidersError { kind: crate::error::PutClusterCapacityProvidersErrorKind::ServerError(body), meta: generic },
                    Err(e) => crate::error::PutClusterCapacityProvidersError::unhandled(e)
                }
                "UpdateInProgressException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::PutClusterCapacityProvidersError { kind: crate::error::PutClusterCapacityProvidersErrorKind::UpdateInProgressError(body), meta: generic },
                    Err(e) => crate::error::PutClusterCapacityProvidersError::unhandled(e)
                }
                _ => crate::error::PutClusterCapacityProvidersError::generic(generic)
            });
        }
        #[allow(unused_mut)]
        let mut builder = crate::output::put_cluster_capacity_providers_output::Builder::default();
        builder = crate::json_deser::put_cluster_capacity_providers_deser_operation(
            response.body().as_ref(),
            builder,
        )
        .map_err(crate::error::PutClusterCapacityProvidersError::unhandled)?;
        Ok(builder.build())
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for PutClusterCapacityProviders {
    type Output = Result<
        crate::output::PutClusterCapacityProvidersOutput,
        crate::error::PutClusterCapacityProvidersError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <note>
/// <p>This action is only used by the Amazon ECS agent, and it is not intended for use outside of the agent.</p>
/// </note>
/// <p>Registers an EC2
/// instance into the specified cluster. This instance becomes available to place containers
/// on.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct RegisterContainerInstance {
    _private: (),
}
impl RegisterContainerInstance {
    /// Creates a new builder-style object to manufacture [`RegisterContainerInstanceInput`](crate::input::RegisterContainerInstanceInput)
    pub fn builder() -> crate::input::register_container_instance_input::Builder {
        crate::input::register_container_instance_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    #[allow(dead_code)]
    fn parse_response(
        &self,
        response: &http::response::Response<bytes::Bytes>,
    ) -> Result<
        crate::output::RegisterContainerInstanceOutput,
        crate::error::RegisterContainerInstanceError,
    > {
        if crate::aws_json_errors::is_error(&response) {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);
            let error_code = match generic.code() {
                Some(code) => code,
                None => {
                    return Err(crate::error::RegisterContainerInstanceError::unhandled(
                        generic,
                    ))
                }
            };
            return Err(match error_code {
                "ClientException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::RegisterContainerInstanceError {
                        kind: crate::error::RegisterContainerInstanceErrorKind::ClientError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::RegisterContainerInstanceError::unhandled(e),
                },
                "InvalidParameterException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::RegisterContainerInstanceError {
                        kind:
                            crate::error::RegisterContainerInstanceErrorKind::InvalidParameterError(
                                body,
                            ),
                        meta: generic,
                    },
                    Err(e) => crate::error::RegisterContainerInstanceError::unhandled(e),
                },
                "ServerException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::RegisterContainerInstanceError {
                        kind: crate::error::RegisterContainerInstanceErrorKind::ServerError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::RegisterContainerInstanceError::unhandled(e),
                },
                _ => crate::error::RegisterContainerInstanceError::generic(generic),
            });
        }
        #[allow(unused_mut)]
        let mut builder = crate::output::register_container_instance_output::Builder::default();
        builder = crate::json_deser::register_container_instance_deser_operation(
            response.body().as_ref(),
            builder,
        )
        .map_err(crate::error::RegisterContainerInstanceError::unhandled)?;
        Ok(builder.build())
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for RegisterContainerInstance {
    type Output = Result<
        crate::output::RegisterContainerInstanceOutput,
        crate::error::RegisterContainerInstanceError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Registers a new task definition from the supplied <code>family</code> and
/// <code>containerDefinitions</code>. Optionally, you can add data volumes to your
/// containers with the <code>volumes</code> parameter. For more information about task
/// definition parameters and defaults, see <a href="https://docs.aws.amazon.com/AmazonECS/latest/developerguide/task_defintions.html">Amazon ECS Task
/// Definitions</a> in the <i>Amazon Elastic Container Service Developer Guide</i>.</p>
/// <p>You can specify an IAM role for your task with the <code>taskRoleArn</code> parameter.
/// When you specify an IAM role for a task, its containers can then use the latest versions
/// of the AWS CLI or SDKs to make API requests to the AWS services that are specified in
/// the IAM policy associated with the role. For more information, see <a href="https://docs.aws.amazon.com/AmazonECS/latest/developerguide/task-iam-roles.html">IAM
/// Roles for Tasks</a> in the <i>Amazon Elastic Container Service Developer Guide</i>.</p>
/// <p>You can specify a Docker networking mode for the containers in your task definition
/// with the <code>networkMode</code> parameter. The available network modes correspond to
/// those described in <a href="https://docs.docker.com/engine/reference/run/#/network-settings">Network
/// settings</a> in the Docker run reference. If you specify the <code>awsvpc</code>
/// network mode, the task is allocated an elastic network interface, and you must specify a
/// <a>NetworkConfiguration</a> when you create a service or run a task with
/// the task definition. For more information, see <a href="https://docs.aws.amazon.com/AmazonECS/latest/developerguide/task-networking.html">Task Networking</a>
/// in the <i>Amazon Elastic Container Service Developer Guide</i>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct RegisterTaskDefinition {
    _private: (),
}
impl RegisterTaskDefinition {
    /// Creates a new builder-style object to manufacture [`RegisterTaskDefinitionInput`](crate::input::RegisterTaskDefinitionInput)
    pub fn builder() -> crate::input::register_task_definition_input::Builder {
        crate::input::register_task_definition_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    #[allow(dead_code)]
    fn parse_response(
        &self,
        response: &http::response::Response<bytes::Bytes>,
    ) -> Result<
        crate::output::RegisterTaskDefinitionOutput,
        crate::error::RegisterTaskDefinitionError,
    > {
        if crate::aws_json_errors::is_error(&response) {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);
            let error_code = match generic.code() {
                Some(code) => code,
                None => {
                    return Err(crate::error::RegisterTaskDefinitionError::unhandled(
                        generic,
                    ))
                }
            };
            return Err(match error_code {
                "ClientException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::RegisterTaskDefinitionError {
                        kind: crate::error::RegisterTaskDefinitionErrorKind::ClientError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::RegisterTaskDefinitionError::unhandled(e),
                },
                "InvalidParameterException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::RegisterTaskDefinitionError {
                        kind: crate::error::RegisterTaskDefinitionErrorKind::InvalidParameterError(
                            body,
                        ),
                        meta: generic,
                    },
                    Err(e) => crate::error::RegisterTaskDefinitionError::unhandled(e),
                },
                "ServerException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::RegisterTaskDefinitionError {
                        kind: crate::error::RegisterTaskDefinitionErrorKind::ServerError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::RegisterTaskDefinitionError::unhandled(e),
                },
                _ => crate::error::RegisterTaskDefinitionError::generic(generic),
            });
        }
        #[allow(unused_mut)]
        let mut builder = crate::output::register_task_definition_output::Builder::default();
        builder = crate::json_deser::register_task_definition_deser_operation(
            response.body().as_ref(),
            builder,
        )
        .map_err(crate::error::RegisterTaskDefinitionError::unhandled)?;
        Ok(builder.build())
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for RegisterTaskDefinition {
    type Output = Result<
        crate::output::RegisterTaskDefinitionOutput,
        crate::error::RegisterTaskDefinitionError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Starts a new task using the specified task definition.</p>
/// <p>You can allow Amazon ECS to place tasks for you, or you can customize how Amazon ECS places
/// tasks using placement constraints and placement strategies. For more information, see
/// <a href="https://docs.aws.amazon.com/AmazonECS/latest/developerguide/scheduling_tasks.html">Scheduling Tasks</a> in the
/// <i>Amazon Elastic Container Service Developer Guide</i>.</p>
/// <p>Alternatively, you can use <a>StartTask</a> to use your own scheduler or
/// place tasks manually on specific container instances.</p>
/// <p>The Amazon ECS API follows an eventual consistency model, due to the distributed nature of
/// the system supporting the API. This means that the result of an API command you run that
/// affects your Amazon ECS resources might not be immediately visible to all subsequent commands
/// you run. Keep this in mind when you carry out an API command that immediately follows a
/// previous API command.</p>
/// <p>To manage eventual consistency, you can do the following:</p>
/// <ul>
/// <li>
/// <p>Confirm the state of the resource before you run a command to modify it. Run
/// the DescribeTasks command using an exponential backoff algorithm to ensure that
/// you allow enough time for the previous command to propagate through the system.
/// To do this, run the DescribeTasks command repeatedly, starting with a couple of
/// seconds of wait time and increasing gradually up to five minutes of wait
/// time.</p>
/// </li>
/// <li>
/// <p>Add wait time between subsequent commands, even if the DescribeTasks command
/// returns an accurate response. Apply an exponential backoff algorithm starting
/// with a couple of seconds of wait time, and increase gradually up to about five
/// minutes of wait time.</p>
/// </li>
/// </ul>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct RunTask {
    _private: (),
}
impl RunTask {
    /// Creates a new builder-style object to manufacture [`RunTaskInput`](crate::input::RunTaskInput)
    pub fn builder() -> crate::input::run_task_input::Builder {
        crate::input::run_task_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    #[allow(dead_code)]
    fn parse_response(
        &self,
        response: &http::response::Response<bytes::Bytes>,
    ) -> Result<crate::output::RunTaskOutput, crate::error::RunTaskError> {
        if crate::aws_json_errors::is_error(&response) {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);
            let error_code = match generic.code() {
                Some(code) => code,
                None => return Err(crate::error::RunTaskError::unhandled(generic)),
            };
            return Err(match error_code {
                "AccessDeniedException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::RunTaskError { kind: crate::error::RunTaskErrorKind::AccessDeniedError(body), meta: generic },
                    Err(e) => crate::error::RunTaskError::unhandled(e)
                }
                "BlockedException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::RunTaskError { kind: crate::error::RunTaskErrorKind::BlockedError(body), meta: generic },
                    Err(e) => crate::error::RunTaskError::unhandled(e)
                }
                "ClientException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::RunTaskError { kind: crate::error::RunTaskErrorKind::ClientError(body), meta: generic },
                    Err(e) => crate::error::RunTaskError::unhandled(e)
                }
                "ClusterNotFoundException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::RunTaskError { kind: crate::error::RunTaskErrorKind::ClusterNotFoundError(body), meta: generic },
                    Err(e) => crate::error::RunTaskError::unhandled(e)
                }
                "InvalidParameterException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::RunTaskError { kind: crate::error::RunTaskErrorKind::InvalidParameterError(body), meta: generic },
                    Err(e) => crate::error::RunTaskError::unhandled(e)
                }
                "PlatformTaskDefinitionIncompatibilityException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::RunTaskError { kind: crate::error::RunTaskErrorKind::PlatformTaskDefinitionIncompatibilityError(body), meta: generic },
                    Err(e) => crate::error::RunTaskError::unhandled(e)
                }
                "PlatformUnknownException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::RunTaskError { kind: crate::error::RunTaskErrorKind::PlatformUnknownError(body), meta: generic },
                    Err(e) => crate::error::RunTaskError::unhandled(e)
                }
                "ServerException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::RunTaskError { kind: crate::error::RunTaskErrorKind::ServerError(body), meta: generic },
                    Err(e) => crate::error::RunTaskError::unhandled(e)
                }
                "UnsupportedFeatureException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::RunTaskError { kind: crate::error::RunTaskErrorKind::UnsupportedFeatureError(body), meta: generic },
                    Err(e) => crate::error::RunTaskError::unhandled(e)
                }
                _ => crate::error::RunTaskError::generic(generic)
            });
        }
        #[allow(unused_mut)]
        let mut builder = crate::output::run_task_output::Builder::default();
        builder = crate::json_deser::run_task_deser_operation(response.body().as_ref(), builder)
            .map_err(crate::error::RunTaskError::unhandled)?;
        Ok(builder.build())
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for RunTask {
    type Output = Result<crate::output::RunTaskOutput, crate::error::RunTaskError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Starts a new task from the specified task definition on the specified container
/// instance or instances.</p>
/// <p>Alternatively, you can use <a>RunTask</a> to place tasks for you. For more
/// information, see <a href="https://docs.aws.amazon.com/AmazonECS/latest/developerguide/scheduling_tasks.html">Scheduling Tasks</a> in the
/// <i>Amazon Elastic Container Service Developer Guide</i>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct StartTask {
    _private: (),
}
impl StartTask {
    /// Creates a new builder-style object to manufacture [`StartTaskInput`](crate::input::StartTaskInput)
    pub fn builder() -> crate::input::start_task_input::Builder {
        crate::input::start_task_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    #[allow(dead_code)]
    fn parse_response(
        &self,
        response: &http::response::Response<bytes::Bytes>,
    ) -> Result<crate::output::StartTaskOutput, crate::error::StartTaskError> {
        if crate::aws_json_errors::is_error(&response) {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);
            let error_code = match generic.code() {
                Some(code) => code,
                None => return Err(crate::error::StartTaskError::unhandled(generic)),
            };
            return Err(match error_code {
                "ClientException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::StartTaskError {
                        kind: crate::error::StartTaskErrorKind::ClientError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::StartTaskError::unhandled(e),
                },
                "ClusterNotFoundException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::StartTaskError {
                        kind: crate::error::StartTaskErrorKind::ClusterNotFoundError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::StartTaskError::unhandled(e),
                },
                "InvalidParameterException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::StartTaskError {
                        kind: crate::error::StartTaskErrorKind::InvalidParameterError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::StartTaskError::unhandled(e),
                },
                "ServerException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::StartTaskError {
                        kind: crate::error::StartTaskErrorKind::ServerError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::StartTaskError::unhandled(e),
                },
                _ => crate::error::StartTaskError::generic(generic),
            });
        }
        #[allow(unused_mut)]
        let mut builder = crate::output::start_task_output::Builder::default();
        builder = crate::json_deser::start_task_deser_operation(response.body().as_ref(), builder)
            .map_err(crate::error::StartTaskError::unhandled)?;
        Ok(builder.build())
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for StartTask {
    type Output = Result<crate::output::StartTaskOutput, crate::error::StartTaskError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Stops a running task. Any tags associated with the task will be deleted.</p>
/// <p>When <a>StopTask</a> is called on a task, the equivalent of <code>docker
/// stop</code> is issued to the containers running in the task. This results in a
/// <code>SIGTERM</code> value and a default 30-second timeout, after which the
/// <code>SIGKILL</code> value is sent and the containers are forcibly stopped. If the
/// container handles the <code>SIGTERM</code> value gracefully and exits within 30 seconds
/// from receiving it, no <code>SIGKILL</code> value is sent.</p>
/// <note>
/// <p>The default 30-second timeout can be configured on the Amazon ECS container agent with
/// the <code>ECS_CONTAINER_STOP_TIMEOUT</code> variable. For more information, see
/// <a href="https://docs.aws.amazon.com/AmazonECS/latest/developerguide/ecs-agent-config.html">Amazon ECS Container Agent Configuration</a> in the
/// <i>Amazon Elastic Container Service Developer Guide</i>.</p>
/// </note>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct StopTask {
    _private: (),
}
impl StopTask {
    /// Creates a new builder-style object to manufacture [`StopTaskInput`](crate::input::StopTaskInput)
    pub fn builder() -> crate::input::stop_task_input::Builder {
        crate::input::stop_task_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    #[allow(dead_code)]
    fn parse_response(
        &self,
        response: &http::response::Response<bytes::Bytes>,
    ) -> Result<crate::output::StopTaskOutput, crate::error::StopTaskError> {
        if crate::aws_json_errors::is_error(&response) {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);
            let error_code = match generic.code() {
                Some(code) => code,
                None => return Err(crate::error::StopTaskError::unhandled(generic)),
            };
            return Err(match error_code {
                "ClientException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::StopTaskError {
                        kind: crate::error::StopTaskErrorKind::ClientError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::StopTaskError::unhandled(e),
                },
                "ClusterNotFoundException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::StopTaskError {
                        kind: crate::error::StopTaskErrorKind::ClusterNotFoundError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::StopTaskError::unhandled(e),
                },
                "InvalidParameterException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::StopTaskError {
                        kind: crate::error::StopTaskErrorKind::InvalidParameterError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::StopTaskError::unhandled(e),
                },
                "ServerException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::StopTaskError {
                        kind: crate::error::StopTaskErrorKind::ServerError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::StopTaskError::unhandled(e),
                },
                _ => crate::error::StopTaskError::generic(generic),
            });
        }
        #[allow(unused_mut)]
        let mut builder = crate::output::stop_task_output::Builder::default();
        builder = crate::json_deser::stop_task_deser_operation(response.body().as_ref(), builder)
            .map_err(crate::error::StopTaskError::unhandled)?;
        Ok(builder.build())
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for StopTask {
    type Output = Result<crate::output::StopTaskOutput, crate::error::StopTaskError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <note>
/// <p>This action is only used by the Amazon ECS agent, and it is not intended for use outside of the agent.</p>
/// </note>
/// <p>Sent to
/// acknowledge that an attachment changed states.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct SubmitAttachmentStateChanges {
    _private: (),
}
impl SubmitAttachmentStateChanges {
    /// Creates a new builder-style object to manufacture [`SubmitAttachmentStateChangesInput`](crate::input::SubmitAttachmentStateChangesInput)
    pub fn builder() -> crate::input::submit_attachment_state_changes_input::Builder {
        crate::input::submit_attachment_state_changes_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    #[allow(dead_code)]
    fn parse_response(
        &self,
        response: &http::response::Response<bytes::Bytes>,
    ) -> Result<
        crate::output::SubmitAttachmentStateChangesOutput,
        crate::error::SubmitAttachmentStateChangesError,
    > {
        if crate::aws_json_errors::is_error(&response) {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);
            let error_code = match generic.code() {
                Some(code) => code,
                None => {
                    return Err(crate::error::SubmitAttachmentStateChangesError::unhandled(
                        generic,
                    ))
                }
            };
            return Err(match error_code {
                "AccessDeniedException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::SubmitAttachmentStateChangesError { kind: crate::error::SubmitAttachmentStateChangesErrorKind::AccessDeniedError(body), meta: generic },
                    Err(e) => crate::error::SubmitAttachmentStateChangesError::unhandled(e)
                }
                "ClientException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::SubmitAttachmentStateChangesError { kind: crate::error::SubmitAttachmentStateChangesErrorKind::ClientError(body), meta: generic },
                    Err(e) => crate::error::SubmitAttachmentStateChangesError::unhandled(e)
                }
                "InvalidParameterException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::SubmitAttachmentStateChangesError { kind: crate::error::SubmitAttachmentStateChangesErrorKind::InvalidParameterError(body), meta: generic },
                    Err(e) => crate::error::SubmitAttachmentStateChangesError::unhandled(e)
                }
                "ServerException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::SubmitAttachmentStateChangesError { kind: crate::error::SubmitAttachmentStateChangesErrorKind::ServerError(body), meta: generic },
                    Err(e) => crate::error::SubmitAttachmentStateChangesError::unhandled(e)
                }
                _ => crate::error::SubmitAttachmentStateChangesError::generic(generic)
            });
        }
        #[allow(unused_mut)]
        let mut builder = crate::output::submit_attachment_state_changes_output::Builder::default();
        builder = crate::json_deser::submit_attachment_state_changes_deser_operation(
            response.body().as_ref(),
            builder,
        )
        .map_err(crate::error::SubmitAttachmentStateChangesError::unhandled)?;
        Ok(builder.build())
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for SubmitAttachmentStateChanges {
    type Output = Result<
        crate::output::SubmitAttachmentStateChangesOutput,
        crate::error::SubmitAttachmentStateChangesError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <note>
/// <p>This action is only used by the Amazon ECS agent, and it is not intended for use outside of the agent.</p>
/// </note>
/// <p>Sent to
/// acknowledge that a container changed states.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct SubmitContainerStateChange {
    _private: (),
}
impl SubmitContainerStateChange {
    /// Creates a new builder-style object to manufacture [`SubmitContainerStateChangeInput`](crate::input::SubmitContainerStateChangeInput)
    pub fn builder() -> crate::input::submit_container_state_change_input::Builder {
        crate::input::submit_container_state_change_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    #[allow(dead_code)]
    fn parse_response(
        &self,
        response: &http::response::Response<bytes::Bytes>,
    ) -> Result<
        crate::output::SubmitContainerStateChangeOutput,
        crate::error::SubmitContainerStateChangeError,
    > {
        if crate::aws_json_errors::is_error(&response) {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);
            let error_code = match generic.code() {
                Some(code) => code,
                None => {
                    return Err(crate::error::SubmitContainerStateChangeError::unhandled(
                        generic,
                    ))
                }
            };
            return Err(match error_code {
                "AccessDeniedException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::SubmitContainerStateChangeError {
                        kind: crate::error::SubmitContainerStateChangeErrorKind::AccessDeniedError(
                            body,
                        ),
                        meta: generic,
                    },
                    Err(e) => crate::error::SubmitContainerStateChangeError::unhandled(e),
                },
                "ClientException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::SubmitContainerStateChangeError {
                        kind: crate::error::SubmitContainerStateChangeErrorKind::ClientError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::SubmitContainerStateChangeError::unhandled(e),
                },
                "ServerException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::SubmitContainerStateChangeError {
                        kind: crate::error::SubmitContainerStateChangeErrorKind::ServerError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::SubmitContainerStateChangeError::unhandled(e),
                },
                _ => crate::error::SubmitContainerStateChangeError::generic(generic),
            });
        }
        #[allow(unused_mut)]
        let mut builder = crate::output::submit_container_state_change_output::Builder::default();
        builder = crate::json_deser::submit_container_state_change_deser_operation(
            response.body().as_ref(),
            builder,
        )
        .map_err(crate::error::SubmitContainerStateChangeError::unhandled)?;
        Ok(builder.build())
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for SubmitContainerStateChange {
    type Output = Result<
        crate::output::SubmitContainerStateChangeOutput,
        crate::error::SubmitContainerStateChangeError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <note>
/// <p>This action is only used by the Amazon ECS agent, and it is not intended for use outside of the agent.</p>
/// </note>
/// <p>Sent to acknowledge
/// that a task changed states.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct SubmitTaskStateChange {
    _private: (),
}
impl SubmitTaskStateChange {
    /// Creates a new builder-style object to manufacture [`SubmitTaskStateChangeInput`](crate::input::SubmitTaskStateChangeInput)
    pub fn builder() -> crate::input::submit_task_state_change_input::Builder {
        crate::input::submit_task_state_change_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    #[allow(dead_code)]
    fn parse_response(
        &self,
        response: &http::response::Response<bytes::Bytes>,
    ) -> Result<crate::output::SubmitTaskStateChangeOutput, crate::error::SubmitTaskStateChangeError>
    {
        if crate::aws_json_errors::is_error(&response) {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);
            let error_code = match generic.code() {
                Some(code) => code,
                None => return Err(crate::error::SubmitTaskStateChangeError::unhandled(generic)),
            };
            return Err(match error_code {
                "AccessDeniedException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::SubmitTaskStateChangeError {
                        kind: crate::error::SubmitTaskStateChangeErrorKind::AccessDeniedError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::SubmitTaskStateChangeError::unhandled(e),
                },
                "ClientException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::SubmitTaskStateChangeError {
                        kind: crate::error::SubmitTaskStateChangeErrorKind::ClientError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::SubmitTaskStateChangeError::unhandled(e),
                },
                "InvalidParameterException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::SubmitTaskStateChangeError {
                        kind: crate::error::SubmitTaskStateChangeErrorKind::InvalidParameterError(
                            body,
                        ),
                        meta: generic,
                    },
                    Err(e) => crate::error::SubmitTaskStateChangeError::unhandled(e),
                },
                "ServerException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::SubmitTaskStateChangeError {
                        kind: crate::error::SubmitTaskStateChangeErrorKind::ServerError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::SubmitTaskStateChangeError::unhandled(e),
                },
                _ => crate::error::SubmitTaskStateChangeError::generic(generic),
            });
        }
        #[allow(unused_mut)]
        let mut builder = crate::output::submit_task_state_change_output::Builder::default();
        builder = crate::json_deser::submit_task_state_change_deser_operation(
            response.body().as_ref(),
            builder,
        )
        .map_err(crate::error::SubmitTaskStateChangeError::unhandled)?;
        Ok(builder.build())
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for SubmitTaskStateChange {
    type Output = Result<
        crate::output::SubmitTaskStateChangeOutput,
        crate::error::SubmitTaskStateChangeError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Associates the specified tags to a resource with the specified
/// <code>resourceArn</code>. If existing tags on a resource are not specified in the
/// request parameters, they are not changed. When a resource is deleted, the tags
/// associated with that resource are deleted as well.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct TagResource {
    _private: (),
}
impl TagResource {
    /// Creates a new builder-style object to manufacture [`TagResourceInput`](crate::input::TagResourceInput)
    pub fn builder() -> crate::input::tag_resource_input::Builder {
        crate::input::tag_resource_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    #[allow(dead_code)]
    fn parse_response(
        &self,
        response: &http::response::Response<bytes::Bytes>,
    ) -> Result<crate::output::TagResourceOutput, crate::error::TagResourceError> {
        if crate::aws_json_errors::is_error(&response) {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);
            let error_code = match generic.code() {
                Some(code) => code,
                None => return Err(crate::error::TagResourceError::unhandled(generic)),
            };
            return Err(match error_code {
                "ClientException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::TagResourceError {
                        kind: crate::error::TagResourceErrorKind::ClientError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::TagResourceError::unhandled(e),
                },
                "ClusterNotFoundException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::TagResourceError {
                        kind: crate::error::TagResourceErrorKind::ClusterNotFoundError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::TagResourceError::unhandled(e),
                },
                "InvalidParameterException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::TagResourceError {
                        kind: crate::error::TagResourceErrorKind::InvalidParameterError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::TagResourceError::unhandled(e),
                },
                "ResourceNotFoundException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::TagResourceError {
                        kind: crate::error::TagResourceErrorKind::ResourceNotFoundError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::TagResourceError::unhandled(e),
                },
                "ServerException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::TagResourceError {
                        kind: crate::error::TagResourceErrorKind::ServerError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::TagResourceError::unhandled(e),
                },
                _ => crate::error::TagResourceError::generic(generic),
            });
        }
        #[allow(unused_mut)]
        let mut builder = crate::output::tag_resource_output::Builder::default();
        Ok(builder.build())
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for TagResource {
    type Output = Result<crate::output::TagResourceOutput, crate::error::TagResourceError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Deletes specified tags from a resource.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UntagResource {
    _private: (),
}
impl UntagResource {
    /// Creates a new builder-style object to manufacture [`UntagResourceInput`](crate::input::UntagResourceInput)
    pub fn builder() -> crate::input::untag_resource_input::Builder {
        crate::input::untag_resource_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    #[allow(dead_code)]
    fn parse_response(
        &self,
        response: &http::response::Response<bytes::Bytes>,
    ) -> Result<crate::output::UntagResourceOutput, crate::error::UntagResourceError> {
        if crate::aws_json_errors::is_error(&response) {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);
            let error_code = match generic.code() {
                Some(code) => code,
                None => return Err(crate::error::UntagResourceError::unhandled(generic)),
            };
            return Err(match error_code {
                "ClientException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::UntagResourceError {
                        kind: crate::error::UntagResourceErrorKind::ClientError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::UntagResourceError::unhandled(e),
                },
                "ClusterNotFoundException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::UntagResourceError {
                        kind: crate::error::UntagResourceErrorKind::ClusterNotFoundError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::UntagResourceError::unhandled(e),
                },
                "InvalidParameterException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::UntagResourceError {
                        kind: crate::error::UntagResourceErrorKind::InvalidParameterError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::UntagResourceError::unhandled(e),
                },
                "ResourceNotFoundException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::UntagResourceError {
                        kind: crate::error::UntagResourceErrorKind::ResourceNotFoundError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::UntagResourceError::unhandled(e),
                },
                "ServerException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::UntagResourceError {
                        kind: crate::error::UntagResourceErrorKind::ServerError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::UntagResourceError::unhandled(e),
                },
                _ => crate::error::UntagResourceError::generic(generic),
            });
        }
        #[allow(unused_mut)]
        let mut builder = crate::output::untag_resource_output::Builder::default();
        Ok(builder.build())
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UntagResource {
    type Output = Result<crate::output::UntagResourceOutput, crate::error::UntagResourceError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Modifies the parameters for a capacity provider.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdateCapacityProvider {
    _private: (),
}
impl UpdateCapacityProvider {
    /// Creates a new builder-style object to manufacture [`UpdateCapacityProviderInput`](crate::input::UpdateCapacityProviderInput)
    pub fn builder() -> crate::input::update_capacity_provider_input::Builder {
        crate::input::update_capacity_provider_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    #[allow(dead_code)]
    fn parse_response(
        &self,
        response: &http::response::Response<bytes::Bytes>,
    ) -> Result<
        crate::output::UpdateCapacityProviderOutput,
        crate::error::UpdateCapacityProviderError,
    > {
        if crate::aws_json_errors::is_error(&response) {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);
            let error_code = match generic.code() {
                Some(code) => code,
                None => {
                    return Err(crate::error::UpdateCapacityProviderError::unhandled(
                        generic,
                    ))
                }
            };
            return Err(match error_code {
                "ClientException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::UpdateCapacityProviderError {
                        kind: crate::error::UpdateCapacityProviderErrorKind::ClientError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::UpdateCapacityProviderError::unhandled(e),
                },
                "InvalidParameterException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::UpdateCapacityProviderError {
                        kind: crate::error::UpdateCapacityProviderErrorKind::InvalidParameterError(
                            body,
                        ),
                        meta: generic,
                    },
                    Err(e) => crate::error::UpdateCapacityProviderError::unhandled(e),
                },
                "ServerException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::UpdateCapacityProviderError {
                        kind: crate::error::UpdateCapacityProviderErrorKind::ServerError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::UpdateCapacityProviderError::unhandled(e),
                },
                _ => crate::error::UpdateCapacityProviderError::generic(generic),
            });
        }
        #[allow(unused_mut)]
        let mut builder = crate::output::update_capacity_provider_output::Builder::default();
        builder = crate::json_deser::update_capacity_provider_deser_operation(
            response.body().as_ref(),
            builder,
        )
        .map_err(crate::error::UpdateCapacityProviderError::unhandled)?;
        Ok(builder.build())
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdateCapacityProvider {
    type Output = Result<
        crate::output::UpdateCapacityProviderOutput,
        crate::error::UpdateCapacityProviderError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Updates the cluster.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdateCluster {
    _private: (),
}
impl UpdateCluster {
    /// Creates a new builder-style object to manufacture [`UpdateClusterInput`](crate::input::UpdateClusterInput)
    pub fn builder() -> crate::input::update_cluster_input::Builder {
        crate::input::update_cluster_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    #[allow(dead_code)]
    fn parse_response(
        &self,
        response: &http::response::Response<bytes::Bytes>,
    ) -> Result<crate::output::UpdateClusterOutput, crate::error::UpdateClusterError> {
        if crate::aws_json_errors::is_error(&response) {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);
            let error_code = match generic.code() {
                Some(code) => code,
                None => return Err(crate::error::UpdateClusterError::unhandled(generic)),
            };
            return Err(match error_code {
                "ClientException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::UpdateClusterError {
                        kind: crate::error::UpdateClusterErrorKind::ClientError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::UpdateClusterError::unhandled(e),
                },
                "ClusterNotFoundException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::UpdateClusterError {
                        kind: crate::error::UpdateClusterErrorKind::ClusterNotFoundError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::UpdateClusterError::unhandled(e),
                },
                "InvalidParameterException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::UpdateClusterError {
                        kind: crate::error::UpdateClusterErrorKind::InvalidParameterError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::UpdateClusterError::unhandled(e),
                },
                "ServerException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::UpdateClusterError {
                        kind: crate::error::UpdateClusterErrorKind::ServerError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::UpdateClusterError::unhandled(e),
                },
                _ => crate::error::UpdateClusterError::generic(generic),
            });
        }
        #[allow(unused_mut)]
        let mut builder = crate::output::update_cluster_output::Builder::default();
        builder =
            crate::json_deser::update_cluster_deser_operation(response.body().as_ref(), builder)
                .map_err(crate::error::UpdateClusterError::unhandled)?;
        Ok(builder.build())
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdateCluster {
    type Output = Result<crate::output::UpdateClusterOutput, crate::error::UpdateClusterError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Modifies the settings to use for a cluster.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdateClusterSettings {
    _private: (),
}
impl UpdateClusterSettings {
    /// Creates a new builder-style object to manufacture [`UpdateClusterSettingsInput`](crate::input::UpdateClusterSettingsInput)
    pub fn builder() -> crate::input::update_cluster_settings_input::Builder {
        crate::input::update_cluster_settings_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    #[allow(dead_code)]
    fn parse_response(
        &self,
        response: &http::response::Response<bytes::Bytes>,
    ) -> Result<crate::output::UpdateClusterSettingsOutput, crate::error::UpdateClusterSettingsError>
    {
        if crate::aws_json_errors::is_error(&response) {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);
            let error_code = match generic.code() {
                Some(code) => code,
                None => return Err(crate::error::UpdateClusterSettingsError::unhandled(generic)),
            };
            return Err(match error_code {
                "ClientException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::UpdateClusterSettingsError {
                        kind: crate::error::UpdateClusterSettingsErrorKind::ClientError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::UpdateClusterSettingsError::unhandled(e),
                },
                "ClusterNotFoundException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::UpdateClusterSettingsError {
                        kind: crate::error::UpdateClusterSettingsErrorKind::ClusterNotFoundError(
                            body,
                        ),
                        meta: generic,
                    },
                    Err(e) => crate::error::UpdateClusterSettingsError::unhandled(e),
                },
                "InvalidParameterException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::UpdateClusterSettingsError {
                        kind: crate::error::UpdateClusterSettingsErrorKind::InvalidParameterError(
                            body,
                        ),
                        meta: generic,
                    },
                    Err(e) => crate::error::UpdateClusterSettingsError::unhandled(e),
                },
                "ServerException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::UpdateClusterSettingsError {
                        kind: crate::error::UpdateClusterSettingsErrorKind::ServerError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::UpdateClusterSettingsError::unhandled(e),
                },
                _ => crate::error::UpdateClusterSettingsError::generic(generic),
            });
        }
        #[allow(unused_mut)]
        let mut builder = crate::output::update_cluster_settings_output::Builder::default();
        builder = crate::json_deser::update_cluster_settings_deser_operation(
            response.body().as_ref(),
            builder,
        )
        .map_err(crate::error::UpdateClusterSettingsError::unhandled)?;
        Ok(builder.build())
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdateClusterSettings {
    type Output = Result<
        crate::output::UpdateClusterSettingsOutput,
        crate::error::UpdateClusterSettingsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Updates the Amazon ECS container agent on a specified container instance. Updating the
/// Amazon ECS container agent does not interrupt running tasks or services on the container
/// instance. The process for updating the agent differs depending on whether your container
/// instance was launched with the Amazon ECS-optimized AMI or another operating system.</p>
/// <note>
/// <p>The <code>UpdateContainerAgent</code> API isn't supported for container instances
/// using the Amazon ECS-optimized Amazon Linux 2 (arm64) AMI. To update the container agent,
/// you can update the <code>ecs-init</code> package which will update the agent. For
/// more information, see <a href="https://docs.aws.amazon.com/AmazonECS/latest/developerguide/agent-update-ecs-ami.html">Updating the
/// Amazon ECS container agent</a> in the
/// <i>Amazon Elastic Container Service Developer Guide</i>.</p>
/// </note>
/// <p>The <code>UpdateContainerAgent</code> API requires an Amazon ECS-optimized AMI or Amazon
/// Linux AMI with the <code>ecs-init</code> service installed and running. For help
/// updating the Amazon ECS container agent on other operating systems, see <a href="https://docs.aws.amazon.com/AmazonECS/latest/developerguide/ecs-agent-update.html#manually_update_agent">Manually updating the Amazon ECS container agent</a> in the
/// <i>Amazon Elastic Container Service Developer Guide</i>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdateContainerAgent {
    _private: (),
}
impl UpdateContainerAgent {
    /// Creates a new builder-style object to manufacture [`UpdateContainerAgentInput`](crate::input::UpdateContainerAgentInput)
    pub fn builder() -> crate::input::update_container_agent_input::Builder {
        crate::input::update_container_agent_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    #[allow(dead_code)]
    fn parse_response(
        &self,
        response: &http::response::Response<bytes::Bytes>,
    ) -> Result<crate::output::UpdateContainerAgentOutput, crate::error::UpdateContainerAgentError>
    {
        if crate::aws_json_errors::is_error(&response) {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);
            let error_code = match generic.code() {
                Some(code) => code,
                None => return Err(crate::error::UpdateContainerAgentError::unhandled(generic)),
            };
            return Err(match error_code {
                "ClientException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::UpdateContainerAgentError {
                        kind: crate::error::UpdateContainerAgentErrorKind::ClientError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::UpdateContainerAgentError::unhandled(e),
                },
                "ClusterNotFoundException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::UpdateContainerAgentError {
                        kind: crate::error::UpdateContainerAgentErrorKind::ClusterNotFoundError(
                            body,
                        ),
                        meta: generic,
                    },
                    Err(e) => crate::error::UpdateContainerAgentError::unhandled(e),
                },
                "InvalidParameterException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::UpdateContainerAgentError {
                        kind: crate::error::UpdateContainerAgentErrorKind::InvalidParameterError(
                            body,
                        ),
                        meta: generic,
                    },
                    Err(e) => crate::error::UpdateContainerAgentError::unhandled(e),
                },
                "MissingVersionException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::UpdateContainerAgentError {
                        kind: crate::error::UpdateContainerAgentErrorKind::MissingVersionError(
                            body,
                        ),
                        meta: generic,
                    },
                    Err(e) => crate::error::UpdateContainerAgentError::unhandled(e),
                },
                "NoUpdateAvailableException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::UpdateContainerAgentError {
                        kind: crate::error::UpdateContainerAgentErrorKind::NoUpdateAvailableError(
                            body,
                        ),
                        meta: generic,
                    },
                    Err(e) => crate::error::UpdateContainerAgentError::unhandled(e),
                },
                "ServerException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::UpdateContainerAgentError {
                        kind: crate::error::UpdateContainerAgentErrorKind::ServerError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::UpdateContainerAgentError::unhandled(e),
                },
                "UpdateInProgressException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::UpdateContainerAgentError {
                        kind: crate::error::UpdateContainerAgentErrorKind::UpdateInProgressError(
                            body,
                        ),
                        meta: generic,
                    },
                    Err(e) => crate::error::UpdateContainerAgentError::unhandled(e),
                },
                _ => crate::error::UpdateContainerAgentError::generic(generic),
            });
        }
        #[allow(unused_mut)]
        let mut builder = crate::output::update_container_agent_output::Builder::default();
        builder = crate::json_deser::update_container_agent_deser_operation(
            response.body().as_ref(),
            builder,
        )
        .map_err(crate::error::UpdateContainerAgentError::unhandled)?;
        Ok(builder.build())
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdateContainerAgent {
    type Output =
        Result<crate::output::UpdateContainerAgentOutput, crate::error::UpdateContainerAgentError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Modifies the status of an Amazon ECS container instance.</p>
/// <p>Once a container instance has reached an <code>ACTIVE</code> state, you can change the
/// status of a container instance to <code>DRAINING</code> to manually remove an instance
/// from a cluster, for example to perform system updates, update the Docker daemon, or
/// scale down the cluster size.</p>
/// <important>
/// <p>A container instance cannot be changed to <code>DRAINING</code> until it has
/// reached an <code>ACTIVE</code> status. If the instance is in any other status, an
/// error will be received.</p>
/// </important>
/// <p>When you set a container instance to <code>DRAINING</code>, Amazon ECS prevents new tasks
/// from being scheduled for placement on the container instance and replacement service
/// tasks are started on other container instances in the cluster if the resources are
/// available. Service tasks on the container instance that are in the <code>PENDING</code>
/// state are stopped immediately.</p>
/// <p>Service tasks on the container instance that are in the <code>RUNNING</code> state are
/// stopped and replaced according to the service's deployment configuration parameters,
/// <code>minimumHealthyPercent</code> and <code>maximumPercent</code>. You can change
/// the deployment configuration of your service using <a>UpdateService</a>.</p>
/// <ul>
/// <li>
/// <p>If <code>minimumHealthyPercent</code> is below 100%, the scheduler can ignore
/// <code>desiredCount</code> temporarily during task replacement. For example,
/// <code>desiredCount</code> is four tasks, a minimum of 50% allows the
/// scheduler to stop two existing tasks before starting two new tasks. If the
/// minimum is 100%, the service scheduler can't remove existing tasks until the
/// replacement tasks are considered healthy. Tasks for services that do not use a
/// load balancer are considered healthy if they are in the <code>RUNNING</code>
/// state. Tasks for services that use a load balancer are considered healthy if
/// they are in the <code>RUNNING</code> state and the container instance they are
/// hosted on is reported as healthy by the load balancer.</p>
/// </li>
/// <li>
/// <p>The <code>maximumPercent</code> parameter represents an upper limit on the
/// number of running tasks during task replacement, which enables you to define the
/// replacement batch size. For example, if <code>desiredCount</code> is four tasks,
/// a maximum of 200% starts four new tasks before stopping the four tasks to be
/// drained, provided that the cluster resources required to do this are available.
/// If the maximum is 100%, then replacement tasks can't start until the draining
/// tasks have stopped.</p>
/// </li>
/// </ul>
/// <p>Any <code>PENDING</code> or <code>RUNNING</code> tasks that do not belong to a service
/// are not affected. You must wait for them to finish or stop them manually.</p>
/// <p>A container instance has completed draining when it has no more <code>RUNNING</code>
/// tasks. You can verify this using <a>ListTasks</a>.</p>
/// <p>When a container instance has been drained, you can set a container instance to
/// <code>ACTIVE</code> status and once it has reached that status the Amazon ECS scheduler
/// can begin scheduling tasks on the instance again.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdateContainerInstancesState {
    _private: (),
}
impl UpdateContainerInstancesState {
    /// Creates a new builder-style object to manufacture [`UpdateContainerInstancesStateInput`](crate::input::UpdateContainerInstancesStateInput)
    pub fn builder() -> crate::input::update_container_instances_state_input::Builder {
        crate::input::update_container_instances_state_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    #[allow(dead_code)]
    fn parse_response(
        &self,
        response: &http::response::Response<bytes::Bytes>,
    ) -> Result<
        crate::output::UpdateContainerInstancesStateOutput,
        crate::error::UpdateContainerInstancesStateError,
    > {
        if crate::aws_json_errors::is_error(&response) {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);
            let error_code = match generic.code() {
                Some(code) => code,
                None => {
                    return Err(crate::error::UpdateContainerInstancesStateError::unhandled(
                        generic,
                    ))
                }
            };
            return Err(match error_code {
                "ClientException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::UpdateContainerInstancesStateError { kind: crate::error::UpdateContainerInstancesStateErrorKind::ClientError(body), meta: generic },
                    Err(e) => crate::error::UpdateContainerInstancesStateError::unhandled(e)
                }
                "ClusterNotFoundException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::UpdateContainerInstancesStateError { kind: crate::error::UpdateContainerInstancesStateErrorKind::ClusterNotFoundError(body), meta: generic },
                    Err(e) => crate::error::UpdateContainerInstancesStateError::unhandled(e)
                }
                "InvalidParameterException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::UpdateContainerInstancesStateError { kind: crate::error::UpdateContainerInstancesStateErrorKind::InvalidParameterError(body), meta: generic },
                    Err(e) => crate::error::UpdateContainerInstancesStateError::unhandled(e)
                }
                "ServerException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::UpdateContainerInstancesStateError { kind: crate::error::UpdateContainerInstancesStateErrorKind::ServerError(body), meta: generic },
                    Err(e) => crate::error::UpdateContainerInstancesStateError::unhandled(e)
                }
                _ => crate::error::UpdateContainerInstancesStateError::generic(generic)
            });
        }
        #[allow(unused_mut)]
        let mut builder =
            crate::output::update_container_instances_state_output::Builder::default();
        builder = crate::json_deser::update_container_instances_state_deser_operation(
            response.body().as_ref(),
            builder,
        )
        .map_err(crate::error::UpdateContainerInstancesStateError::unhandled)?;
        Ok(builder.build())
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdateContainerInstancesState {
    type Output = Result<
        crate::output::UpdateContainerInstancesStateOutput,
        crate::error::UpdateContainerInstancesStateError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <important>
/// <p>Updating the task placement strategies and constraints on an Amazon ECS service remains
/// in preview and is a Beta Service as defined by and subject to the Beta Service
/// Participation Service Terms located at <a href="https://aws.amazon.com/service-terms">https://aws.amazon.com/service-terms</a> ("Beta Terms"). These Beta Terms
/// apply to your participation in this preview.</p>
/// </important>
/// <p>Modifies the parameters of a service.</p>
/// <p>For services using the rolling update (<code>ECS</code>) deployment controller, the
/// desired count, deployment configuration, network configuration, task placement
/// constraints and strategies, or task definition used can be updated.</p>
/// <p>For services using the blue/green (<code>CODE_DEPLOY</code>) deployment controller,
/// only the desired count, deployment configuration, task placement constraints and
/// strategies, and health check grace period can be updated using this API. If the network
/// configuration, platform version, or task definition need to be updated, a new AWS CodeDeploy
/// deployment should be created. For more information, see <a href="https://docs.aws.amazon.com/codedeploy/latest/APIReference/API_CreateDeployment.html">CreateDeployment</a> in the <i>AWS CodeDeploy API Reference</i>.</p>
/// <p>For services using an external deployment controller, you can update only the desired
/// count, task placement constraints and strategies, and health check grace period using
/// this API. If the launch type, load balancer, network configuration, platform version, or
/// task definition need to be updated, you should create a new task set. For more
/// information, see <a>CreateTaskSet</a>.</p>
/// <p>You can add to or subtract from the number of instantiations of a task definition in a
/// service by specifying the cluster that the service is running in and a new
/// <code>desiredCount</code> parameter.</p>
/// <p>If you have updated the Docker image of your application, you can create a new task
/// definition with that image and deploy it to your service. The service scheduler uses the
/// minimum healthy percent and maximum percent parameters (in the service's deployment
/// configuration) to determine the deployment strategy.</p>
/// <note>
/// <p>If your updated Docker image uses the same tag as what is in the existing task
/// definition for your service (for example, <code>my_image:latest</code>), you do not
/// need to create a new revision of your task definition. You can update the service
/// using the <code>forceNewDeployment</code> option. The new tasks launched by the
/// deployment pull the current image/tag combination from your repository when they
/// start.</p>
/// </note>
/// <p>You can also update the deployment configuration of a service. When a deployment is
/// triggered by updating the task definition of a service, the service scheduler uses the
/// deployment configuration parameters, <code>minimumHealthyPercent</code> and
/// <code>maximumPercent</code>, to determine the deployment strategy.</p>
/// <ul>
/// <li>
/// <p>If <code>minimumHealthyPercent</code> is below 100%, the scheduler can ignore
/// <code>desiredCount</code> temporarily during a deployment. For example, if
/// <code>desiredCount</code> is four tasks, a minimum of 50% allows the
/// scheduler to stop two existing tasks before starting two new tasks. Tasks for
/// services that do not use a load balancer are considered healthy if they are in
/// the <code>RUNNING</code> state. Tasks for services that use a load balancer are
/// considered healthy if they are in the <code>RUNNING</code> state and the
/// container instance they are hosted on is reported as healthy by the load
/// balancer.</p>
/// </li>
/// <li>
/// <p>The <code>maximumPercent</code> parameter represents an upper limit on the
/// number of running tasks during a deployment, which enables you to define the
/// deployment batch size. For example, if <code>desiredCount</code> is four tasks,
/// a maximum of 200% starts four new tasks before stopping the four older tasks
/// (provided that the cluster resources required to do this are available).</p>
/// </li>
/// </ul>
/// <p>When <a>UpdateService</a> stops a task during a deployment, the equivalent
/// of <code>docker stop</code> is issued to the containers running in the task. This
/// results in a <code>SIGTERM</code> and a 30-second timeout, after which
/// <code>SIGKILL</code> is sent and the containers are forcibly stopped. If the
/// container handles the <code>SIGTERM</code> gracefully and exits within 30 seconds from
/// receiving it, no <code>SIGKILL</code> is sent.</p>
/// <p>When the service scheduler launches new tasks, it determines task placement in your
/// cluster with the following logic:</p>
/// <ul>
/// <li>
/// <p>Determine which of the container instances in your cluster can support your
/// service's task definition (for example, they have the required CPU, memory,
/// ports, and container instance attributes).</p>
/// </li>
/// <li>
/// <p>By default, the service scheduler attempts to balance tasks across
/// Availability Zones in this manner (although you can choose a different placement
/// strategy):</p>
/// <ul>
/// <li>
/// <p>Sort the valid container instances by the fewest number of running
/// tasks for this service in the same Availability Zone as the instance.
/// For example, if zone A has one running service task and zones B and C
/// each have zero, valid container instances in either zone B or C are
/// considered optimal for placement.</p>
/// </li>
/// <li>
/// <p>Place the new service task on a valid container instance in an optimal
/// Availability Zone (based on the previous steps), favoring container
/// instances with the fewest number of running tasks for this
/// service.</p>
/// </li>
/// </ul>
/// </li>
/// </ul>
/// <p>When the service scheduler stops running tasks, it attempts to maintain balance across
/// the Availability Zones in your cluster using the following logic: </p>
/// <ul>
/// <li>
/// <p>Sort the container instances by the largest number of running tasks for this
/// service in the same Availability Zone as the instance. For example, if zone A
/// has one running service task and zones B and C each have two, container
/// instances in either zone B or C are considered optimal for termination.</p>
/// </li>
/// <li>
/// <p>Stop the task on a container instance in an optimal Availability Zone (based
/// on the previous steps), favoring container instances with the largest number of
/// running tasks for this service.</p>
/// </li>
/// </ul>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdateService {
    _private: (),
}
impl UpdateService {
    /// Creates a new builder-style object to manufacture [`UpdateServiceInput`](crate::input::UpdateServiceInput)
    pub fn builder() -> crate::input::update_service_input::Builder {
        crate::input::update_service_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    #[allow(dead_code)]
    fn parse_response(
        &self,
        response: &http::response::Response<bytes::Bytes>,
    ) -> Result<crate::output::UpdateServiceOutput, crate::error::UpdateServiceError> {
        if crate::aws_json_errors::is_error(&response) {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);
            let error_code = match generic.code() {
                Some(code) => code,
                None => return Err(crate::error::UpdateServiceError::unhandled(generic)),
            };
            return Err(match error_code {
                "AccessDeniedException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::UpdateServiceError { kind: crate::error::UpdateServiceErrorKind::AccessDeniedError(body), meta: generic },
                    Err(e) => crate::error::UpdateServiceError::unhandled(e)
                }
                "ClientException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::UpdateServiceError { kind: crate::error::UpdateServiceErrorKind::ClientError(body), meta: generic },
                    Err(e) => crate::error::UpdateServiceError::unhandled(e)
                }
                "ClusterNotFoundException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::UpdateServiceError { kind: crate::error::UpdateServiceErrorKind::ClusterNotFoundError(body), meta: generic },
                    Err(e) => crate::error::UpdateServiceError::unhandled(e)
                }
                "InvalidParameterException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::UpdateServiceError { kind: crate::error::UpdateServiceErrorKind::InvalidParameterError(body), meta: generic },
                    Err(e) => crate::error::UpdateServiceError::unhandled(e)
                }
                "PlatformTaskDefinitionIncompatibilityException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::UpdateServiceError { kind: crate::error::UpdateServiceErrorKind::PlatformTaskDefinitionIncompatibilityError(body), meta: generic },
                    Err(e) => crate::error::UpdateServiceError::unhandled(e)
                }
                "PlatformUnknownException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::UpdateServiceError { kind: crate::error::UpdateServiceErrorKind::PlatformUnknownError(body), meta: generic },
                    Err(e) => crate::error::UpdateServiceError::unhandled(e)
                }
                "ServerException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::UpdateServiceError { kind: crate::error::UpdateServiceErrorKind::ServerError(body), meta: generic },
                    Err(e) => crate::error::UpdateServiceError::unhandled(e)
                }
                "ServiceNotActiveException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::UpdateServiceError { kind: crate::error::UpdateServiceErrorKind::ServiceNotActiveError(body), meta: generic },
                    Err(e) => crate::error::UpdateServiceError::unhandled(e)
                }
                "ServiceNotFoundException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::UpdateServiceError { kind: crate::error::UpdateServiceErrorKind::ServiceNotFoundError(body), meta: generic },
                    Err(e) => crate::error::UpdateServiceError::unhandled(e)
                }
                _ => crate::error::UpdateServiceError::generic(generic)
            });
        }
        #[allow(unused_mut)]
        let mut builder = crate::output::update_service_output::Builder::default();
        builder =
            crate::json_deser::update_service_deser_operation(response.body().as_ref(), builder)
                .map_err(crate::error::UpdateServiceError::unhandled)?;
        Ok(builder.build())
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdateService {
    type Output = Result<crate::output::UpdateServiceOutput, crate::error::UpdateServiceError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Modifies which task set in a service is the primary task set. Any parameters that are
/// updated on the primary task set in a service will transition to the service. This is
/// used when a service uses the <code>EXTERNAL</code> deployment controller type. For more
/// information, see <a href="https://docs.aws.amazon.com/AmazonECS/latest/developerguide/deployment-types.html">Amazon ECS Deployment
/// Types</a> in the <i>Amazon Elastic Container Service Developer Guide</i>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdateServicePrimaryTaskSet {
    _private: (),
}
impl UpdateServicePrimaryTaskSet {
    /// Creates a new builder-style object to manufacture [`UpdateServicePrimaryTaskSetInput`](crate::input::UpdateServicePrimaryTaskSetInput)
    pub fn builder() -> crate::input::update_service_primary_task_set_input::Builder {
        crate::input::update_service_primary_task_set_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    #[allow(dead_code)]
    fn parse_response(
        &self,
        response: &http::response::Response<bytes::Bytes>,
    ) -> Result<
        crate::output::UpdateServicePrimaryTaskSetOutput,
        crate::error::UpdateServicePrimaryTaskSetError,
    > {
        if crate::aws_json_errors::is_error(&response) {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);
            let error_code = match generic.code() {
                Some(code) => code,
                None => {
                    return Err(crate::error::UpdateServicePrimaryTaskSetError::unhandled(
                        generic,
                    ))
                }
            };
            return Err(match error_code {
                "AccessDeniedException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::UpdateServicePrimaryTaskSetError { kind: crate::error::UpdateServicePrimaryTaskSetErrorKind::AccessDeniedError(body), meta: generic },
                    Err(e) => crate::error::UpdateServicePrimaryTaskSetError::unhandled(e)
                }
                "ClientException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::UpdateServicePrimaryTaskSetError { kind: crate::error::UpdateServicePrimaryTaskSetErrorKind::ClientError(body), meta: generic },
                    Err(e) => crate::error::UpdateServicePrimaryTaskSetError::unhandled(e)
                }
                "ClusterNotFoundException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::UpdateServicePrimaryTaskSetError { kind: crate::error::UpdateServicePrimaryTaskSetErrorKind::ClusterNotFoundError(body), meta: generic },
                    Err(e) => crate::error::UpdateServicePrimaryTaskSetError::unhandled(e)
                }
                "InvalidParameterException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::UpdateServicePrimaryTaskSetError { kind: crate::error::UpdateServicePrimaryTaskSetErrorKind::InvalidParameterError(body), meta: generic },
                    Err(e) => crate::error::UpdateServicePrimaryTaskSetError::unhandled(e)
                }
                "ServerException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::UpdateServicePrimaryTaskSetError { kind: crate::error::UpdateServicePrimaryTaskSetErrorKind::ServerError(body), meta: generic },
                    Err(e) => crate::error::UpdateServicePrimaryTaskSetError::unhandled(e)
                }
                "ServiceNotActiveException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::UpdateServicePrimaryTaskSetError { kind: crate::error::UpdateServicePrimaryTaskSetErrorKind::ServiceNotActiveError(body), meta: generic },
                    Err(e) => crate::error::UpdateServicePrimaryTaskSetError::unhandled(e)
                }
                "ServiceNotFoundException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::UpdateServicePrimaryTaskSetError { kind: crate::error::UpdateServicePrimaryTaskSetErrorKind::ServiceNotFoundError(body), meta: generic },
                    Err(e) => crate::error::UpdateServicePrimaryTaskSetError::unhandled(e)
                }
                "TaskSetNotFoundException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::UpdateServicePrimaryTaskSetError { kind: crate::error::UpdateServicePrimaryTaskSetErrorKind::TaskSetNotFoundError(body), meta: generic },
                    Err(e) => crate::error::UpdateServicePrimaryTaskSetError::unhandled(e)
                }
                "UnsupportedFeatureException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::UpdateServicePrimaryTaskSetError { kind: crate::error::UpdateServicePrimaryTaskSetErrorKind::UnsupportedFeatureError(body), meta: generic },
                    Err(e) => crate::error::UpdateServicePrimaryTaskSetError::unhandled(e)
                }
                _ => crate::error::UpdateServicePrimaryTaskSetError::generic(generic)
            });
        }
        #[allow(unused_mut)]
        let mut builder = crate::output::update_service_primary_task_set_output::Builder::default();
        builder = crate::json_deser::update_service_primary_task_set_deser_operation(
            response.body().as_ref(),
            builder,
        )
        .map_err(crate::error::UpdateServicePrimaryTaskSetError::unhandled)?;
        Ok(builder.build())
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdateServicePrimaryTaskSet {
    type Output = Result<
        crate::output::UpdateServicePrimaryTaskSetOutput,
        crate::error::UpdateServicePrimaryTaskSetError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Modifies a task set. This is used when a service uses the <code>EXTERNAL</code>
/// deployment controller type. For more information, see <a href="https://docs.aws.amazon.com/AmazonECS/latest/developerguide/deployment-types.html">Amazon ECS Deployment
/// Types</a> in the <i>Amazon Elastic Container Service Developer Guide</i>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdateTaskSet {
    _private: (),
}
impl UpdateTaskSet {
    /// Creates a new builder-style object to manufacture [`UpdateTaskSetInput`](crate::input::UpdateTaskSetInput)
    pub fn builder() -> crate::input::update_task_set_input::Builder {
        crate::input::update_task_set_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    #[allow(dead_code)]
    fn parse_response(
        &self,
        response: &http::response::Response<bytes::Bytes>,
    ) -> Result<crate::output::UpdateTaskSetOutput, crate::error::UpdateTaskSetError> {
        if crate::aws_json_errors::is_error(&response) {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);
            let error_code = match generic.code() {
                Some(code) => code,
                None => return Err(crate::error::UpdateTaskSetError::unhandled(generic)),
            };
            return Err(match error_code {
                "AccessDeniedException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::UpdateTaskSetError {
                        kind: crate::error::UpdateTaskSetErrorKind::AccessDeniedError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::UpdateTaskSetError::unhandled(e),
                },
                "ClientException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::UpdateTaskSetError {
                        kind: crate::error::UpdateTaskSetErrorKind::ClientError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::UpdateTaskSetError::unhandled(e),
                },
                "ClusterNotFoundException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::UpdateTaskSetError {
                        kind: crate::error::UpdateTaskSetErrorKind::ClusterNotFoundError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::UpdateTaskSetError::unhandled(e),
                },
                "InvalidParameterException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::UpdateTaskSetError {
                        kind: crate::error::UpdateTaskSetErrorKind::InvalidParameterError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::UpdateTaskSetError::unhandled(e),
                },
                "ServerException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::UpdateTaskSetError {
                        kind: crate::error::UpdateTaskSetErrorKind::ServerError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::UpdateTaskSetError::unhandled(e),
                },
                "ServiceNotActiveException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::UpdateTaskSetError {
                        kind: crate::error::UpdateTaskSetErrorKind::ServiceNotActiveError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::UpdateTaskSetError::unhandled(e),
                },
                "ServiceNotFoundException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::UpdateTaskSetError {
                        kind: crate::error::UpdateTaskSetErrorKind::ServiceNotFoundError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::UpdateTaskSetError::unhandled(e),
                },
                "TaskSetNotFoundException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::UpdateTaskSetError {
                        kind: crate::error::UpdateTaskSetErrorKind::TaskSetNotFoundError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::UpdateTaskSetError::unhandled(e),
                },
                "UnsupportedFeatureException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::UpdateTaskSetError {
                        kind: crate::error::UpdateTaskSetErrorKind::UnsupportedFeatureError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::UpdateTaskSetError::unhandled(e),
                },
                _ => crate::error::UpdateTaskSetError::generic(generic),
            });
        }
        #[allow(unused_mut)]
        let mut builder = crate::output::update_task_set_output::Builder::default();
        builder =
            crate::json_deser::update_task_set_deser_operation(response.body().as_ref(), builder)
                .map_err(crate::error::UpdateTaskSetError::unhandled)?;
        Ok(builder.build())
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdateTaskSet {
    type Output = Result<crate::output::UpdateTaskSetOutput, crate::error::UpdateTaskSetError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}
