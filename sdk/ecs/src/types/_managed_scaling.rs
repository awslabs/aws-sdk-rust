// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>The managed scaling settings for the Auto Scaling group capacity provider.</p>
/// <p>When managed scaling is enabled, Amazon ECS manages the scale-in and scale-out actions of the Auto Scaling group. Amazon ECS manages a target tracking scaling policy using an Amazon ECS managed CloudWatch metric with the specified <code>targetCapacity</code> value as the target value for the metric. For more information, see <a href="https://docs.aws.amazon.com/AmazonECS/latest/developerguide/asg-capacity-providers.html#asg-capacity-providers-managed-scaling">Using managed scaling</a> in the <i>Amazon Elastic Container Service Developer Guide</i>.</p>
/// <p>If managed scaling is off, the user must manage the scaling of the Auto Scaling group.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ManagedScaling {
    /// <p>Determines whether to use managed scaling for the capacity provider.</p>
    #[doc(hidden)]
    pub status: std::option::Option<crate::types::ManagedScalingStatus>,
    /// <p>The target capacity value for the capacity provider. The specified value must be greater than <code>0</code> and less than or equal to <code>100</code>. A value of <code>100</code> results in the Amazon EC2 instances in your Auto Scaling group being completely used.</p>
    #[doc(hidden)]
    pub target_capacity: std::option::Option<i32>,
    /// <p>The minimum number of Amazon EC2 instances that Amazon ECS will scale out at one time. The scale in process is not affected by this parameter If this parameter is omitted, the default value of <code>1</code> is used.</p>
    /// <p>When additional capacity is required, Amazon ECS will scale up the minimum scaling step size even if the actual demand is less than the minimum scaling step size.</p>
    /// <p>If you use a capacity provider with an Auto Scaling group configured with more than one Amazon EC2 instance type or Availability Zone, Amazon ECS will scale up by the exact minimum scaling step size value and will ignore both the maximum scaling step size as well as the capacity demand.</p>
    #[doc(hidden)]
    pub minimum_scaling_step_size: std::option::Option<i32>,
    /// <p>The maximum number of Amazon EC2 instances that Amazon ECS will scale out at one time. The scale in process is not affected by this parameter. If this parameter is omitted, the default value of <code>1</code> is used.</p>
    #[doc(hidden)]
    pub maximum_scaling_step_size: std::option::Option<i32>,
    /// <p>The period of time, in seconds, after a newly launched Amazon EC2 instance can contribute to CloudWatch metrics for Auto Scaling group. If this parameter is omitted, the default value of <code>300</code> seconds is used.</p>
    #[doc(hidden)]
    pub instance_warmup_period: std::option::Option<i32>,
}
impl ManagedScaling {
    /// <p>Determines whether to use managed scaling for the capacity provider.</p>
    pub fn status(&self) -> std::option::Option<&crate::types::ManagedScalingStatus> {
        self.status.as_ref()
    }
    /// <p>The target capacity value for the capacity provider. The specified value must be greater than <code>0</code> and less than or equal to <code>100</code>. A value of <code>100</code> results in the Amazon EC2 instances in your Auto Scaling group being completely used.</p>
    pub fn target_capacity(&self) -> std::option::Option<i32> {
        self.target_capacity
    }
    /// <p>The minimum number of Amazon EC2 instances that Amazon ECS will scale out at one time. The scale in process is not affected by this parameter If this parameter is omitted, the default value of <code>1</code> is used.</p>
    /// <p>When additional capacity is required, Amazon ECS will scale up the minimum scaling step size even if the actual demand is less than the minimum scaling step size.</p>
    /// <p>If you use a capacity provider with an Auto Scaling group configured with more than one Amazon EC2 instance type or Availability Zone, Amazon ECS will scale up by the exact minimum scaling step size value and will ignore both the maximum scaling step size as well as the capacity demand.</p>
    pub fn minimum_scaling_step_size(&self) -> std::option::Option<i32> {
        self.minimum_scaling_step_size
    }
    /// <p>The maximum number of Amazon EC2 instances that Amazon ECS will scale out at one time. The scale in process is not affected by this parameter. If this parameter is omitted, the default value of <code>1</code> is used.</p>
    pub fn maximum_scaling_step_size(&self) -> std::option::Option<i32> {
        self.maximum_scaling_step_size
    }
    /// <p>The period of time, in seconds, after a newly launched Amazon EC2 instance can contribute to CloudWatch metrics for Auto Scaling group. If this parameter is omitted, the default value of <code>300</code> seconds is used.</p>
    pub fn instance_warmup_period(&self) -> std::option::Option<i32> {
        self.instance_warmup_period
    }
}
impl ManagedScaling {
    /// Creates a new builder-style object to manufacture [`ManagedScaling`](crate::types::ManagedScaling).
    pub fn builder() -> crate::types::builders::ManagedScalingBuilder {
        crate::types::builders::ManagedScalingBuilder::default()
    }
}

/// A builder for [`ManagedScaling`](crate::types::ManagedScaling).
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
pub struct ManagedScalingBuilder {
    pub(crate) status: std::option::Option<crate::types::ManagedScalingStatus>,
    pub(crate) target_capacity: std::option::Option<i32>,
    pub(crate) minimum_scaling_step_size: std::option::Option<i32>,
    pub(crate) maximum_scaling_step_size: std::option::Option<i32>,
    pub(crate) instance_warmup_period: std::option::Option<i32>,
}
impl ManagedScalingBuilder {
    /// <p>Determines whether to use managed scaling for the capacity provider.</p>
    pub fn status(mut self, input: crate::types::ManagedScalingStatus) -> Self {
        self.status = Some(input);
        self
    }
    /// <p>Determines whether to use managed scaling for the capacity provider.</p>
    pub fn set_status(
        mut self,
        input: std::option::Option<crate::types::ManagedScalingStatus>,
    ) -> Self {
        self.status = input;
        self
    }
    /// <p>The target capacity value for the capacity provider. The specified value must be greater than <code>0</code> and less than or equal to <code>100</code>. A value of <code>100</code> results in the Amazon EC2 instances in your Auto Scaling group being completely used.</p>
    pub fn target_capacity(mut self, input: i32) -> Self {
        self.target_capacity = Some(input);
        self
    }
    /// <p>The target capacity value for the capacity provider. The specified value must be greater than <code>0</code> and less than or equal to <code>100</code>. A value of <code>100</code> results in the Amazon EC2 instances in your Auto Scaling group being completely used.</p>
    pub fn set_target_capacity(mut self, input: std::option::Option<i32>) -> Self {
        self.target_capacity = input;
        self
    }
    /// <p>The minimum number of Amazon EC2 instances that Amazon ECS will scale out at one time. The scale in process is not affected by this parameter If this parameter is omitted, the default value of <code>1</code> is used.</p>
    /// <p>When additional capacity is required, Amazon ECS will scale up the minimum scaling step size even if the actual demand is less than the minimum scaling step size.</p>
    /// <p>If you use a capacity provider with an Auto Scaling group configured with more than one Amazon EC2 instance type or Availability Zone, Amazon ECS will scale up by the exact minimum scaling step size value and will ignore both the maximum scaling step size as well as the capacity demand.</p>
    pub fn minimum_scaling_step_size(mut self, input: i32) -> Self {
        self.minimum_scaling_step_size = Some(input);
        self
    }
    /// <p>The minimum number of Amazon EC2 instances that Amazon ECS will scale out at one time. The scale in process is not affected by this parameter If this parameter is omitted, the default value of <code>1</code> is used.</p>
    /// <p>When additional capacity is required, Amazon ECS will scale up the minimum scaling step size even if the actual demand is less than the minimum scaling step size.</p>
    /// <p>If you use a capacity provider with an Auto Scaling group configured with more than one Amazon EC2 instance type or Availability Zone, Amazon ECS will scale up by the exact minimum scaling step size value and will ignore both the maximum scaling step size as well as the capacity demand.</p>
    pub fn set_minimum_scaling_step_size(mut self, input: std::option::Option<i32>) -> Self {
        self.minimum_scaling_step_size = input;
        self
    }
    /// <p>The maximum number of Amazon EC2 instances that Amazon ECS will scale out at one time. The scale in process is not affected by this parameter. If this parameter is omitted, the default value of <code>1</code> is used.</p>
    pub fn maximum_scaling_step_size(mut self, input: i32) -> Self {
        self.maximum_scaling_step_size = Some(input);
        self
    }
    /// <p>The maximum number of Amazon EC2 instances that Amazon ECS will scale out at one time. The scale in process is not affected by this parameter. If this parameter is omitted, the default value of <code>1</code> is used.</p>
    pub fn set_maximum_scaling_step_size(mut self, input: std::option::Option<i32>) -> Self {
        self.maximum_scaling_step_size = input;
        self
    }
    /// <p>The period of time, in seconds, after a newly launched Amazon EC2 instance can contribute to CloudWatch metrics for Auto Scaling group. If this parameter is omitted, the default value of <code>300</code> seconds is used.</p>
    pub fn instance_warmup_period(mut self, input: i32) -> Self {
        self.instance_warmup_period = Some(input);
        self
    }
    /// <p>The period of time, in seconds, after a newly launched Amazon EC2 instance can contribute to CloudWatch metrics for Auto Scaling group. If this parameter is omitted, the default value of <code>300</code> seconds is used.</p>
    pub fn set_instance_warmup_period(mut self, input: std::option::Option<i32>) -> Self {
        self.instance_warmup_period = input;
        self
    }
    /// Consumes the builder and constructs a [`ManagedScaling`](crate::types::ManagedScaling).
    pub fn build(self) -> crate::types::ManagedScaling {
        crate::types::ManagedScaling {
            status: self.status,
            target_capacity: self.target_capacity,
            minimum_scaling_step_size: self.minimum_scaling_step_size,
            maximum_scaling_step_size: self.maximum_scaling_step_size,
            instance_warmup_period: self.instance_warmup_period,
        }
    }
}
