// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>The Service Connect service object configuration. For more information, see <a href="https://docs.aws.amazon.com/AmazonECS/latest/developerguide/service-connect.html">Service Connect</a> in the <i>Amazon Elastic Container Service Developer Guide</i>.</p>
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct ServiceConnectService {
    /// <p>The <code>portName</code> must match the name of one of the <code>portMappings</code> from all the containers in the task definition of this Amazon ECS service.</p>
    pub port_name: ::std::string::String,
    /// <p>The <code>discoveryName</code> is the name of the new Cloud Map service that Amazon ECS creates for this Amazon ECS service. This must be unique within the Cloud Map namespace. The name can contain up to 64 characters. The name can include lowercase letters, numbers, underscores (_), and hyphens (-). The name can't start with a hyphen.</p>
    /// <p>If the <code>discoveryName</code> isn't specified, the port mapping name from the task definition is used in <code>portName.namespace</code>.</p>
    pub discovery_name: ::std::option::Option<::std::string::String>,
    /// <p>The list of client aliases for this Service Connect service. You use these to assign names that can be used by client applications. The maximum number of client aliases that you can have in this list is 1.</p>
    /// <p>Each alias ("endpoint") is a fully-qualified name and port number that other Amazon ECS tasks ("clients") can use to connect to this service.</p>
    /// <p>Each name and port mapping must be unique within the namespace.</p>
    /// <p>For each <code>ServiceConnectService</code>, you must provide at least one <code>clientAlias</code> with one <code>port</code>.</p>
    pub client_aliases: ::std::option::Option<::std::vec::Vec<crate::types::ServiceConnectClientAlias>>,
    /// <p>The port number for the Service Connect proxy to listen on.</p>
    /// <p>Use the value of this field to bypass the proxy for traffic on the port number specified in the named <code>portMapping</code> in the task definition of this application, and then use it in your VPC security groups to allow traffic into the proxy for this Amazon ECS service.</p>
    /// <p>In <code>awsvpc</code> mode and Fargate, the default value is the container port number. The container port number is in the <code>portMapping</code> in the task definition. In bridge mode, the default value is the ephemeral port of the Service Connect proxy.</p>
    pub ingress_port_override: ::std::option::Option<i32>,
    /// <p>A reference to an object that represents the configured timeouts for Service Connect.</p>
    pub timeout: ::std::option::Option<crate::types::TimeoutConfiguration>,
    /// <p>A reference to an object that represents a Transport Layer Security (TLS) configuration.</p>
    pub tls: ::std::option::Option<crate::types::ServiceConnectTlsConfiguration>,
}
impl ServiceConnectService {
    /// <p>The <code>portName</code> must match the name of one of the <code>portMappings</code> from all the containers in the task definition of this Amazon ECS service.</p>
    pub fn port_name(&self) -> &str {
        use std::ops::Deref;
        self.port_name.deref()
    }
    /// <p>The <code>discoveryName</code> is the name of the new Cloud Map service that Amazon ECS creates for this Amazon ECS service. This must be unique within the Cloud Map namespace. The name can contain up to 64 characters. The name can include lowercase letters, numbers, underscores (_), and hyphens (-). The name can't start with a hyphen.</p>
    /// <p>If the <code>discoveryName</code> isn't specified, the port mapping name from the task definition is used in <code>portName.namespace</code>.</p>
    pub fn discovery_name(&self) -> ::std::option::Option<&str> {
        self.discovery_name.as_deref()
    }
    /// <p>The list of client aliases for this Service Connect service. You use these to assign names that can be used by client applications. The maximum number of client aliases that you can have in this list is 1.</p>
    /// <p>Each alias ("endpoint") is a fully-qualified name and port number that other Amazon ECS tasks ("clients") can use to connect to this service.</p>
    /// <p>Each name and port mapping must be unique within the namespace.</p>
    /// <p>For each <code>ServiceConnectService</code>, you must provide at least one <code>clientAlias</code> with one <code>port</code>.</p>
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.client_aliases.is_none()`.
    pub fn client_aliases(&self) -> &[crate::types::ServiceConnectClientAlias] {
        self.client_aliases.as_deref().unwrap_or_default()
    }
    /// <p>The port number for the Service Connect proxy to listen on.</p>
    /// <p>Use the value of this field to bypass the proxy for traffic on the port number specified in the named <code>portMapping</code> in the task definition of this application, and then use it in your VPC security groups to allow traffic into the proxy for this Amazon ECS service.</p>
    /// <p>In <code>awsvpc</code> mode and Fargate, the default value is the container port number. The container port number is in the <code>portMapping</code> in the task definition. In bridge mode, the default value is the ephemeral port of the Service Connect proxy.</p>
    pub fn ingress_port_override(&self) -> ::std::option::Option<i32> {
        self.ingress_port_override
    }
    /// <p>A reference to an object that represents the configured timeouts for Service Connect.</p>
    pub fn timeout(&self) -> ::std::option::Option<&crate::types::TimeoutConfiguration> {
        self.timeout.as_ref()
    }
    /// <p>A reference to an object that represents a Transport Layer Security (TLS) configuration.</p>
    pub fn tls(&self) -> ::std::option::Option<&crate::types::ServiceConnectTlsConfiguration> {
        self.tls.as_ref()
    }
}
impl ServiceConnectService {
    /// Creates a new builder-style object to manufacture [`ServiceConnectService`](crate::types::ServiceConnectService).
    pub fn builder() -> crate::types::builders::ServiceConnectServiceBuilder {
        crate::types::builders::ServiceConnectServiceBuilder::default()
    }
}

/// A builder for [`ServiceConnectService`](crate::types::ServiceConnectService).
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::default::Default, ::std::fmt::Debug)]
pub struct ServiceConnectServiceBuilder {
    pub(crate) port_name: ::std::option::Option<::std::string::String>,
    pub(crate) discovery_name: ::std::option::Option<::std::string::String>,
    pub(crate) client_aliases: ::std::option::Option<::std::vec::Vec<crate::types::ServiceConnectClientAlias>>,
    pub(crate) ingress_port_override: ::std::option::Option<i32>,
    pub(crate) timeout: ::std::option::Option<crate::types::TimeoutConfiguration>,
    pub(crate) tls: ::std::option::Option<crate::types::ServiceConnectTlsConfiguration>,
}
impl ServiceConnectServiceBuilder {
    /// <p>The <code>portName</code> must match the name of one of the <code>portMappings</code> from all the containers in the task definition of this Amazon ECS service.</p>
    /// This field is required.
    pub fn port_name(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.port_name = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The <code>portName</code> must match the name of one of the <code>portMappings</code> from all the containers in the task definition of this Amazon ECS service.</p>
    pub fn set_port_name(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.port_name = input;
        self
    }
    /// <p>The <code>portName</code> must match the name of one of the <code>portMappings</code> from all the containers in the task definition of this Amazon ECS service.</p>
    pub fn get_port_name(&self) -> &::std::option::Option<::std::string::String> {
        &self.port_name
    }
    /// <p>The <code>discoveryName</code> is the name of the new Cloud Map service that Amazon ECS creates for this Amazon ECS service. This must be unique within the Cloud Map namespace. The name can contain up to 64 characters. The name can include lowercase letters, numbers, underscores (_), and hyphens (-). The name can't start with a hyphen.</p>
    /// <p>If the <code>discoveryName</code> isn't specified, the port mapping name from the task definition is used in <code>portName.namespace</code>.</p>
    pub fn discovery_name(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.discovery_name = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The <code>discoveryName</code> is the name of the new Cloud Map service that Amazon ECS creates for this Amazon ECS service. This must be unique within the Cloud Map namespace. The name can contain up to 64 characters. The name can include lowercase letters, numbers, underscores (_), and hyphens (-). The name can't start with a hyphen.</p>
    /// <p>If the <code>discoveryName</code> isn't specified, the port mapping name from the task definition is used in <code>portName.namespace</code>.</p>
    pub fn set_discovery_name(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.discovery_name = input;
        self
    }
    /// <p>The <code>discoveryName</code> is the name of the new Cloud Map service that Amazon ECS creates for this Amazon ECS service. This must be unique within the Cloud Map namespace. The name can contain up to 64 characters. The name can include lowercase letters, numbers, underscores (_), and hyphens (-). The name can't start with a hyphen.</p>
    /// <p>If the <code>discoveryName</code> isn't specified, the port mapping name from the task definition is used in <code>portName.namespace</code>.</p>
    pub fn get_discovery_name(&self) -> &::std::option::Option<::std::string::String> {
        &self.discovery_name
    }
    /// Appends an item to `client_aliases`.
    ///
    /// To override the contents of this collection use [`set_client_aliases`](Self::set_client_aliases).
    ///
    /// <p>The list of client aliases for this Service Connect service. You use these to assign names that can be used by client applications. The maximum number of client aliases that you can have in this list is 1.</p>
    /// <p>Each alias ("endpoint") is a fully-qualified name and port number that other Amazon ECS tasks ("clients") can use to connect to this service.</p>
    /// <p>Each name and port mapping must be unique within the namespace.</p>
    /// <p>For each <code>ServiceConnectService</code>, you must provide at least one <code>clientAlias</code> with one <code>port</code>.</p>
    pub fn client_aliases(mut self, input: crate::types::ServiceConnectClientAlias) -> Self {
        let mut v = self.client_aliases.unwrap_or_default();
        v.push(input);
        self.client_aliases = ::std::option::Option::Some(v);
        self
    }
    /// <p>The list of client aliases for this Service Connect service. You use these to assign names that can be used by client applications. The maximum number of client aliases that you can have in this list is 1.</p>
    /// <p>Each alias ("endpoint") is a fully-qualified name and port number that other Amazon ECS tasks ("clients") can use to connect to this service.</p>
    /// <p>Each name and port mapping must be unique within the namespace.</p>
    /// <p>For each <code>ServiceConnectService</code>, you must provide at least one <code>clientAlias</code> with one <code>port</code>.</p>
    pub fn set_client_aliases(mut self, input: ::std::option::Option<::std::vec::Vec<crate::types::ServiceConnectClientAlias>>) -> Self {
        self.client_aliases = input;
        self
    }
    /// <p>The list of client aliases for this Service Connect service. You use these to assign names that can be used by client applications. The maximum number of client aliases that you can have in this list is 1.</p>
    /// <p>Each alias ("endpoint") is a fully-qualified name and port number that other Amazon ECS tasks ("clients") can use to connect to this service.</p>
    /// <p>Each name and port mapping must be unique within the namespace.</p>
    /// <p>For each <code>ServiceConnectService</code>, you must provide at least one <code>clientAlias</code> with one <code>port</code>.</p>
    pub fn get_client_aliases(&self) -> &::std::option::Option<::std::vec::Vec<crate::types::ServiceConnectClientAlias>> {
        &self.client_aliases
    }
    /// <p>The port number for the Service Connect proxy to listen on.</p>
    /// <p>Use the value of this field to bypass the proxy for traffic on the port number specified in the named <code>portMapping</code> in the task definition of this application, and then use it in your VPC security groups to allow traffic into the proxy for this Amazon ECS service.</p>
    /// <p>In <code>awsvpc</code> mode and Fargate, the default value is the container port number. The container port number is in the <code>portMapping</code> in the task definition. In bridge mode, the default value is the ephemeral port of the Service Connect proxy.</p>
    pub fn ingress_port_override(mut self, input: i32) -> Self {
        self.ingress_port_override = ::std::option::Option::Some(input);
        self
    }
    /// <p>The port number for the Service Connect proxy to listen on.</p>
    /// <p>Use the value of this field to bypass the proxy for traffic on the port number specified in the named <code>portMapping</code> in the task definition of this application, and then use it in your VPC security groups to allow traffic into the proxy for this Amazon ECS service.</p>
    /// <p>In <code>awsvpc</code> mode and Fargate, the default value is the container port number. The container port number is in the <code>portMapping</code> in the task definition. In bridge mode, the default value is the ephemeral port of the Service Connect proxy.</p>
    pub fn set_ingress_port_override(mut self, input: ::std::option::Option<i32>) -> Self {
        self.ingress_port_override = input;
        self
    }
    /// <p>The port number for the Service Connect proxy to listen on.</p>
    /// <p>Use the value of this field to bypass the proxy for traffic on the port number specified in the named <code>portMapping</code> in the task definition of this application, and then use it in your VPC security groups to allow traffic into the proxy for this Amazon ECS service.</p>
    /// <p>In <code>awsvpc</code> mode and Fargate, the default value is the container port number. The container port number is in the <code>portMapping</code> in the task definition. In bridge mode, the default value is the ephemeral port of the Service Connect proxy.</p>
    pub fn get_ingress_port_override(&self) -> &::std::option::Option<i32> {
        &self.ingress_port_override
    }
    /// <p>A reference to an object that represents the configured timeouts for Service Connect.</p>
    pub fn timeout(mut self, input: crate::types::TimeoutConfiguration) -> Self {
        self.timeout = ::std::option::Option::Some(input);
        self
    }
    /// <p>A reference to an object that represents the configured timeouts for Service Connect.</p>
    pub fn set_timeout(mut self, input: ::std::option::Option<crate::types::TimeoutConfiguration>) -> Self {
        self.timeout = input;
        self
    }
    /// <p>A reference to an object that represents the configured timeouts for Service Connect.</p>
    pub fn get_timeout(&self) -> &::std::option::Option<crate::types::TimeoutConfiguration> {
        &self.timeout
    }
    /// <p>A reference to an object that represents a Transport Layer Security (TLS) configuration.</p>
    pub fn tls(mut self, input: crate::types::ServiceConnectTlsConfiguration) -> Self {
        self.tls = ::std::option::Option::Some(input);
        self
    }
    /// <p>A reference to an object that represents a Transport Layer Security (TLS) configuration.</p>
    pub fn set_tls(mut self, input: ::std::option::Option<crate::types::ServiceConnectTlsConfiguration>) -> Self {
        self.tls = input;
        self
    }
    /// <p>A reference to an object that represents a Transport Layer Security (TLS) configuration.</p>
    pub fn get_tls(&self) -> &::std::option::Option<crate::types::ServiceConnectTlsConfiguration> {
        &self.tls
    }
    /// Consumes the builder and constructs a [`ServiceConnectService`](crate::types::ServiceConnectService).
    /// This method will fail if any of the following fields are not set:
    /// - [`port_name`](crate::types::builders::ServiceConnectServiceBuilder::port_name)
    pub fn build(self) -> ::std::result::Result<crate::types::ServiceConnectService, ::aws_smithy_types::error::operation::BuildError> {
        ::std::result::Result::Ok(crate::types::ServiceConnectService {
            port_name: self.port_name.ok_or_else(|| {
                ::aws_smithy_types::error::operation::BuildError::missing_field(
                    "port_name",
                    "port_name was not specified but it is required when building ServiceConnectService",
                )
            })?,
            discovery_name: self.discovery_name,
            client_aliases: self.client_aliases,
            ingress_port_override: self.ingress_port_override,
            timeout: self.timeout,
            tls: self.tls,
        })
    }
}
