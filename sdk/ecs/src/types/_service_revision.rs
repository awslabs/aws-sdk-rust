// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>Information about the service revision.</p>
/// <p>A service revision contains a record of the workload configuration Amazon ECS is attempting to deploy. Whenever you create or deploy a service, Amazon ECS automatically creates and captures the configuration that you're trying to deploy in the service revision. For information about service revisions, see <a href="https://docs.aws.amazon.com/AmazonECS/latest/developerguide/service-revision.html">Amazon ECS service revisions</a> in the <i> <i>Amazon Elastic Container Service Developer Guide</i> </i>.</p>
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct ServiceRevision {
    /// <p>The ARN of the service revision.</p>
    pub service_revision_arn: ::std::option::Option<::std::string::String>,
    /// <p>The ARN of the service for the service revision.</p>
    pub service_arn: ::std::option::Option<::std::string::String>,
    /// <p>The ARN of the cluster that hosts the service.</p>
    pub cluster_arn: ::std::option::Option<::std::string::String>,
    /// <p>The task definition the service revision uses.</p>
    pub task_definition: ::std::option::Option<::std::string::String>,
    /// <p>The capacity provider strategy the service revision uses.</p>
    pub capacity_provider_strategy: ::std::option::Option<::std::vec::Vec<crate::types::CapacityProviderStrategyItem>>,
    /// <p>The launch type the service revision uses.</p>
    pub launch_type: ::std::option::Option<crate::types::LaunchType>,
    /// <p>For the Fargate launch type, the platform version the service revision uses.</p>
    pub platform_version: ::std::option::Option<::std::string::String>,
    /// <p>The platform family the service revision uses.</p>
    pub platform_family: ::std::option::Option<::std::string::String>,
    /// <p>The load balancers the service revision uses.</p>
    pub load_balancers: ::std::option::Option<::std::vec::Vec<crate::types::LoadBalancer>>,
    /// <p>The service registries (for Service Discovery) the service revision uses.</p>
    pub service_registries: ::std::option::Option<::std::vec::Vec<crate::types::ServiceRegistry>>,
    /// <p>The network configuration for a task or service.</p>
    pub network_configuration: ::std::option::Option<crate::types::NetworkConfiguration>,
    /// <p>The container images the service revision uses.</p>
    pub container_images: ::std::option::Option<::std::vec::Vec<crate::types::ContainerImage>>,
    /// <p>Indicates whether Runtime Monitoring is turned on.</p>
    pub guard_duty_enabled: bool,
    /// <p>The Service Connect configuration of your Amazon ECS service. The configuration for this service to discover and connect to services, and be discovered by, and connected from, other services within a namespace.</p>
    /// <p>Tasks that run in a namespace can use short names to connect to services in the namespace. Tasks can connect to services across all of the clusters in the namespace. Tasks connect through a managed proxy container that collects logs and metrics for increased visibility. Only the tasks that Amazon ECS services create are supported with Service Connect. For more information, see <a href="https://docs.aws.amazon.com/AmazonECS/latest/developerguide/service-connect.html">Service Connect</a> in the <i>Amazon Elastic Container Service Developer Guide</i>.</p>
    pub service_connect_configuration: ::std::option::Option<crate::types::ServiceConnectConfiguration>,
    /// <p>The volumes that are configured at deployment that the service revision uses.</p>
    pub volume_configurations: ::std::option::Option<::std::vec::Vec<crate::types::ServiceVolumeConfiguration>>,
    /// <p>The amount of ephemeral storage to allocate for the deployment.</p>
    pub fargate_ephemeral_storage: ::std::option::Option<crate::types::DeploymentEphemeralStorage>,
    /// <p>The time that the service revision was created. The format is yyyy-mm-dd HH:mm:ss.SSSSS.</p>
    pub created_at: ::std::option::Option<::aws_smithy_types::DateTime>,
    /// <p>The VPC Lattice configuration for the service revision.</p>
    pub vpc_lattice_configurations: ::std::option::Option<::std::vec::Vec<crate::types::VpcLatticeConfiguration>>,
    /// <p>The resolved configuration for the service revision which contains the actual resources your service revision uses, such as which target groups serve traffic.</p>
    pub resolved_configuration: ::std::option::Option<crate::types::ResolvedConfiguration>,
    /// <p>The resources created and managed by Amazon ECS when you create an Express service for Amazon ECS.</p>
    pub ecs_managed_resources: ::std::option::Option<crate::types::EcsManagedResources>,
}
impl ServiceRevision {
    /// <p>The ARN of the service revision.</p>
    pub fn service_revision_arn(&self) -> ::std::option::Option<&str> {
        self.service_revision_arn.as_deref()
    }
    /// <p>The ARN of the service for the service revision.</p>
    pub fn service_arn(&self) -> ::std::option::Option<&str> {
        self.service_arn.as_deref()
    }
    /// <p>The ARN of the cluster that hosts the service.</p>
    pub fn cluster_arn(&self) -> ::std::option::Option<&str> {
        self.cluster_arn.as_deref()
    }
    /// <p>The task definition the service revision uses.</p>
    pub fn task_definition(&self) -> ::std::option::Option<&str> {
        self.task_definition.as_deref()
    }
    /// <p>The capacity provider strategy the service revision uses.</p>
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.capacity_provider_strategy.is_none()`.
    pub fn capacity_provider_strategy(&self) -> &[crate::types::CapacityProviderStrategyItem] {
        self.capacity_provider_strategy.as_deref().unwrap_or_default()
    }
    /// <p>The launch type the service revision uses.</p>
    pub fn launch_type(&self) -> ::std::option::Option<&crate::types::LaunchType> {
        self.launch_type.as_ref()
    }
    /// <p>For the Fargate launch type, the platform version the service revision uses.</p>
    pub fn platform_version(&self) -> ::std::option::Option<&str> {
        self.platform_version.as_deref()
    }
    /// <p>The platform family the service revision uses.</p>
    pub fn platform_family(&self) -> ::std::option::Option<&str> {
        self.platform_family.as_deref()
    }
    /// <p>The load balancers the service revision uses.</p>
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.load_balancers.is_none()`.
    pub fn load_balancers(&self) -> &[crate::types::LoadBalancer] {
        self.load_balancers.as_deref().unwrap_or_default()
    }
    /// <p>The service registries (for Service Discovery) the service revision uses.</p>
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.service_registries.is_none()`.
    pub fn service_registries(&self) -> &[crate::types::ServiceRegistry] {
        self.service_registries.as_deref().unwrap_or_default()
    }
    /// <p>The network configuration for a task or service.</p>
    pub fn network_configuration(&self) -> ::std::option::Option<&crate::types::NetworkConfiguration> {
        self.network_configuration.as_ref()
    }
    /// <p>The container images the service revision uses.</p>
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.container_images.is_none()`.
    pub fn container_images(&self) -> &[crate::types::ContainerImage] {
        self.container_images.as_deref().unwrap_or_default()
    }
    /// <p>Indicates whether Runtime Monitoring is turned on.</p>
    pub fn guard_duty_enabled(&self) -> bool {
        self.guard_duty_enabled
    }
    /// <p>The Service Connect configuration of your Amazon ECS service. The configuration for this service to discover and connect to services, and be discovered by, and connected from, other services within a namespace.</p>
    /// <p>Tasks that run in a namespace can use short names to connect to services in the namespace. Tasks can connect to services across all of the clusters in the namespace. Tasks connect through a managed proxy container that collects logs and metrics for increased visibility. Only the tasks that Amazon ECS services create are supported with Service Connect. For more information, see <a href="https://docs.aws.amazon.com/AmazonECS/latest/developerguide/service-connect.html">Service Connect</a> in the <i>Amazon Elastic Container Service Developer Guide</i>.</p>
    pub fn service_connect_configuration(&self) -> ::std::option::Option<&crate::types::ServiceConnectConfiguration> {
        self.service_connect_configuration.as_ref()
    }
    /// <p>The volumes that are configured at deployment that the service revision uses.</p>
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.volume_configurations.is_none()`.
    pub fn volume_configurations(&self) -> &[crate::types::ServiceVolumeConfiguration] {
        self.volume_configurations.as_deref().unwrap_or_default()
    }
    /// <p>The amount of ephemeral storage to allocate for the deployment.</p>
    pub fn fargate_ephemeral_storage(&self) -> ::std::option::Option<&crate::types::DeploymentEphemeralStorage> {
        self.fargate_ephemeral_storage.as_ref()
    }
    /// <p>The time that the service revision was created. The format is yyyy-mm-dd HH:mm:ss.SSSSS.</p>
    pub fn created_at(&self) -> ::std::option::Option<&::aws_smithy_types::DateTime> {
        self.created_at.as_ref()
    }
    /// <p>The VPC Lattice configuration for the service revision.</p>
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.vpc_lattice_configurations.is_none()`.
    pub fn vpc_lattice_configurations(&self) -> &[crate::types::VpcLatticeConfiguration] {
        self.vpc_lattice_configurations.as_deref().unwrap_or_default()
    }
    /// <p>The resolved configuration for the service revision which contains the actual resources your service revision uses, such as which target groups serve traffic.</p>
    pub fn resolved_configuration(&self) -> ::std::option::Option<&crate::types::ResolvedConfiguration> {
        self.resolved_configuration.as_ref()
    }
    /// <p>The resources created and managed by Amazon ECS when you create an Express service for Amazon ECS.</p>
    pub fn ecs_managed_resources(&self) -> ::std::option::Option<&crate::types::EcsManagedResources> {
        self.ecs_managed_resources.as_ref()
    }
}
impl ServiceRevision {
    /// Creates a new builder-style object to manufacture [`ServiceRevision`](crate::types::ServiceRevision).
    pub fn builder() -> crate::types::builders::ServiceRevisionBuilder {
        crate::types::builders::ServiceRevisionBuilder::default()
    }
}

/// A builder for [`ServiceRevision`](crate::types::ServiceRevision).
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::default::Default, ::std::fmt::Debug)]
#[non_exhaustive]
pub struct ServiceRevisionBuilder {
    pub(crate) service_revision_arn: ::std::option::Option<::std::string::String>,
    pub(crate) service_arn: ::std::option::Option<::std::string::String>,
    pub(crate) cluster_arn: ::std::option::Option<::std::string::String>,
    pub(crate) task_definition: ::std::option::Option<::std::string::String>,
    pub(crate) capacity_provider_strategy: ::std::option::Option<::std::vec::Vec<crate::types::CapacityProviderStrategyItem>>,
    pub(crate) launch_type: ::std::option::Option<crate::types::LaunchType>,
    pub(crate) platform_version: ::std::option::Option<::std::string::String>,
    pub(crate) platform_family: ::std::option::Option<::std::string::String>,
    pub(crate) load_balancers: ::std::option::Option<::std::vec::Vec<crate::types::LoadBalancer>>,
    pub(crate) service_registries: ::std::option::Option<::std::vec::Vec<crate::types::ServiceRegistry>>,
    pub(crate) network_configuration: ::std::option::Option<crate::types::NetworkConfiguration>,
    pub(crate) container_images: ::std::option::Option<::std::vec::Vec<crate::types::ContainerImage>>,
    pub(crate) guard_duty_enabled: ::std::option::Option<bool>,
    pub(crate) service_connect_configuration: ::std::option::Option<crate::types::ServiceConnectConfiguration>,
    pub(crate) volume_configurations: ::std::option::Option<::std::vec::Vec<crate::types::ServiceVolumeConfiguration>>,
    pub(crate) fargate_ephemeral_storage: ::std::option::Option<crate::types::DeploymentEphemeralStorage>,
    pub(crate) created_at: ::std::option::Option<::aws_smithy_types::DateTime>,
    pub(crate) vpc_lattice_configurations: ::std::option::Option<::std::vec::Vec<crate::types::VpcLatticeConfiguration>>,
    pub(crate) resolved_configuration: ::std::option::Option<crate::types::ResolvedConfiguration>,
    pub(crate) ecs_managed_resources: ::std::option::Option<crate::types::EcsManagedResources>,
}
impl ServiceRevisionBuilder {
    /// <p>The ARN of the service revision.</p>
    pub fn service_revision_arn(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.service_revision_arn = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The ARN of the service revision.</p>
    pub fn set_service_revision_arn(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.service_revision_arn = input;
        self
    }
    /// <p>The ARN of the service revision.</p>
    pub fn get_service_revision_arn(&self) -> &::std::option::Option<::std::string::String> {
        &self.service_revision_arn
    }
    /// <p>The ARN of the service for the service revision.</p>
    pub fn service_arn(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.service_arn = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The ARN of the service for the service revision.</p>
    pub fn set_service_arn(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.service_arn = input;
        self
    }
    /// <p>The ARN of the service for the service revision.</p>
    pub fn get_service_arn(&self) -> &::std::option::Option<::std::string::String> {
        &self.service_arn
    }
    /// <p>The ARN of the cluster that hosts the service.</p>
    pub fn cluster_arn(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.cluster_arn = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The ARN of the cluster that hosts the service.</p>
    pub fn set_cluster_arn(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.cluster_arn = input;
        self
    }
    /// <p>The ARN of the cluster that hosts the service.</p>
    pub fn get_cluster_arn(&self) -> &::std::option::Option<::std::string::String> {
        &self.cluster_arn
    }
    /// <p>The task definition the service revision uses.</p>
    pub fn task_definition(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.task_definition = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The task definition the service revision uses.</p>
    pub fn set_task_definition(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.task_definition = input;
        self
    }
    /// <p>The task definition the service revision uses.</p>
    pub fn get_task_definition(&self) -> &::std::option::Option<::std::string::String> {
        &self.task_definition
    }
    /// Appends an item to `capacity_provider_strategy`.
    ///
    /// To override the contents of this collection use [`set_capacity_provider_strategy`](Self::set_capacity_provider_strategy).
    ///
    /// <p>The capacity provider strategy the service revision uses.</p>
    pub fn capacity_provider_strategy(mut self, input: crate::types::CapacityProviderStrategyItem) -> Self {
        let mut v = self.capacity_provider_strategy.unwrap_or_default();
        v.push(input);
        self.capacity_provider_strategy = ::std::option::Option::Some(v);
        self
    }
    /// <p>The capacity provider strategy the service revision uses.</p>
    pub fn set_capacity_provider_strategy(
        mut self,
        input: ::std::option::Option<::std::vec::Vec<crate::types::CapacityProviderStrategyItem>>,
    ) -> Self {
        self.capacity_provider_strategy = input;
        self
    }
    /// <p>The capacity provider strategy the service revision uses.</p>
    pub fn get_capacity_provider_strategy(&self) -> &::std::option::Option<::std::vec::Vec<crate::types::CapacityProviderStrategyItem>> {
        &self.capacity_provider_strategy
    }
    /// <p>The launch type the service revision uses.</p>
    pub fn launch_type(mut self, input: crate::types::LaunchType) -> Self {
        self.launch_type = ::std::option::Option::Some(input);
        self
    }
    /// <p>The launch type the service revision uses.</p>
    pub fn set_launch_type(mut self, input: ::std::option::Option<crate::types::LaunchType>) -> Self {
        self.launch_type = input;
        self
    }
    /// <p>The launch type the service revision uses.</p>
    pub fn get_launch_type(&self) -> &::std::option::Option<crate::types::LaunchType> {
        &self.launch_type
    }
    /// <p>For the Fargate launch type, the platform version the service revision uses.</p>
    pub fn platform_version(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.platform_version = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>For the Fargate launch type, the platform version the service revision uses.</p>
    pub fn set_platform_version(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.platform_version = input;
        self
    }
    /// <p>For the Fargate launch type, the platform version the service revision uses.</p>
    pub fn get_platform_version(&self) -> &::std::option::Option<::std::string::String> {
        &self.platform_version
    }
    /// <p>The platform family the service revision uses.</p>
    pub fn platform_family(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.platform_family = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The platform family the service revision uses.</p>
    pub fn set_platform_family(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.platform_family = input;
        self
    }
    /// <p>The platform family the service revision uses.</p>
    pub fn get_platform_family(&self) -> &::std::option::Option<::std::string::String> {
        &self.platform_family
    }
    /// Appends an item to `load_balancers`.
    ///
    /// To override the contents of this collection use [`set_load_balancers`](Self::set_load_balancers).
    ///
    /// <p>The load balancers the service revision uses.</p>
    pub fn load_balancers(mut self, input: crate::types::LoadBalancer) -> Self {
        let mut v = self.load_balancers.unwrap_or_default();
        v.push(input);
        self.load_balancers = ::std::option::Option::Some(v);
        self
    }
    /// <p>The load balancers the service revision uses.</p>
    pub fn set_load_balancers(mut self, input: ::std::option::Option<::std::vec::Vec<crate::types::LoadBalancer>>) -> Self {
        self.load_balancers = input;
        self
    }
    /// <p>The load balancers the service revision uses.</p>
    pub fn get_load_balancers(&self) -> &::std::option::Option<::std::vec::Vec<crate::types::LoadBalancer>> {
        &self.load_balancers
    }
    /// Appends an item to `service_registries`.
    ///
    /// To override the contents of this collection use [`set_service_registries`](Self::set_service_registries).
    ///
    /// <p>The service registries (for Service Discovery) the service revision uses.</p>
    pub fn service_registries(mut self, input: crate::types::ServiceRegistry) -> Self {
        let mut v = self.service_registries.unwrap_or_default();
        v.push(input);
        self.service_registries = ::std::option::Option::Some(v);
        self
    }
    /// <p>The service registries (for Service Discovery) the service revision uses.</p>
    pub fn set_service_registries(mut self, input: ::std::option::Option<::std::vec::Vec<crate::types::ServiceRegistry>>) -> Self {
        self.service_registries = input;
        self
    }
    /// <p>The service registries (for Service Discovery) the service revision uses.</p>
    pub fn get_service_registries(&self) -> &::std::option::Option<::std::vec::Vec<crate::types::ServiceRegistry>> {
        &self.service_registries
    }
    /// <p>The network configuration for a task or service.</p>
    pub fn network_configuration(mut self, input: crate::types::NetworkConfiguration) -> Self {
        self.network_configuration = ::std::option::Option::Some(input);
        self
    }
    /// <p>The network configuration for a task or service.</p>
    pub fn set_network_configuration(mut self, input: ::std::option::Option<crate::types::NetworkConfiguration>) -> Self {
        self.network_configuration = input;
        self
    }
    /// <p>The network configuration for a task or service.</p>
    pub fn get_network_configuration(&self) -> &::std::option::Option<crate::types::NetworkConfiguration> {
        &self.network_configuration
    }
    /// Appends an item to `container_images`.
    ///
    /// To override the contents of this collection use [`set_container_images`](Self::set_container_images).
    ///
    /// <p>The container images the service revision uses.</p>
    pub fn container_images(mut self, input: crate::types::ContainerImage) -> Self {
        let mut v = self.container_images.unwrap_or_default();
        v.push(input);
        self.container_images = ::std::option::Option::Some(v);
        self
    }
    /// <p>The container images the service revision uses.</p>
    pub fn set_container_images(mut self, input: ::std::option::Option<::std::vec::Vec<crate::types::ContainerImage>>) -> Self {
        self.container_images = input;
        self
    }
    /// <p>The container images the service revision uses.</p>
    pub fn get_container_images(&self) -> &::std::option::Option<::std::vec::Vec<crate::types::ContainerImage>> {
        &self.container_images
    }
    /// <p>Indicates whether Runtime Monitoring is turned on.</p>
    pub fn guard_duty_enabled(mut self, input: bool) -> Self {
        self.guard_duty_enabled = ::std::option::Option::Some(input);
        self
    }
    /// <p>Indicates whether Runtime Monitoring is turned on.</p>
    pub fn set_guard_duty_enabled(mut self, input: ::std::option::Option<bool>) -> Self {
        self.guard_duty_enabled = input;
        self
    }
    /// <p>Indicates whether Runtime Monitoring is turned on.</p>
    pub fn get_guard_duty_enabled(&self) -> &::std::option::Option<bool> {
        &self.guard_duty_enabled
    }
    /// <p>The Service Connect configuration of your Amazon ECS service. The configuration for this service to discover and connect to services, and be discovered by, and connected from, other services within a namespace.</p>
    /// <p>Tasks that run in a namespace can use short names to connect to services in the namespace. Tasks can connect to services across all of the clusters in the namespace. Tasks connect through a managed proxy container that collects logs and metrics for increased visibility. Only the tasks that Amazon ECS services create are supported with Service Connect. For more information, see <a href="https://docs.aws.amazon.com/AmazonECS/latest/developerguide/service-connect.html">Service Connect</a> in the <i>Amazon Elastic Container Service Developer Guide</i>.</p>
    pub fn service_connect_configuration(mut self, input: crate::types::ServiceConnectConfiguration) -> Self {
        self.service_connect_configuration = ::std::option::Option::Some(input);
        self
    }
    /// <p>The Service Connect configuration of your Amazon ECS service. The configuration for this service to discover and connect to services, and be discovered by, and connected from, other services within a namespace.</p>
    /// <p>Tasks that run in a namespace can use short names to connect to services in the namespace. Tasks can connect to services across all of the clusters in the namespace. Tasks connect through a managed proxy container that collects logs and metrics for increased visibility. Only the tasks that Amazon ECS services create are supported with Service Connect. For more information, see <a href="https://docs.aws.amazon.com/AmazonECS/latest/developerguide/service-connect.html">Service Connect</a> in the <i>Amazon Elastic Container Service Developer Guide</i>.</p>
    pub fn set_service_connect_configuration(mut self, input: ::std::option::Option<crate::types::ServiceConnectConfiguration>) -> Self {
        self.service_connect_configuration = input;
        self
    }
    /// <p>The Service Connect configuration of your Amazon ECS service. The configuration for this service to discover and connect to services, and be discovered by, and connected from, other services within a namespace.</p>
    /// <p>Tasks that run in a namespace can use short names to connect to services in the namespace. Tasks can connect to services across all of the clusters in the namespace. Tasks connect through a managed proxy container that collects logs and metrics for increased visibility. Only the tasks that Amazon ECS services create are supported with Service Connect. For more information, see <a href="https://docs.aws.amazon.com/AmazonECS/latest/developerguide/service-connect.html">Service Connect</a> in the <i>Amazon Elastic Container Service Developer Guide</i>.</p>
    pub fn get_service_connect_configuration(&self) -> &::std::option::Option<crate::types::ServiceConnectConfiguration> {
        &self.service_connect_configuration
    }
    /// Appends an item to `volume_configurations`.
    ///
    /// To override the contents of this collection use [`set_volume_configurations`](Self::set_volume_configurations).
    ///
    /// <p>The volumes that are configured at deployment that the service revision uses.</p>
    pub fn volume_configurations(mut self, input: crate::types::ServiceVolumeConfiguration) -> Self {
        let mut v = self.volume_configurations.unwrap_or_default();
        v.push(input);
        self.volume_configurations = ::std::option::Option::Some(v);
        self
    }
    /// <p>The volumes that are configured at deployment that the service revision uses.</p>
    pub fn set_volume_configurations(mut self, input: ::std::option::Option<::std::vec::Vec<crate::types::ServiceVolumeConfiguration>>) -> Self {
        self.volume_configurations = input;
        self
    }
    /// <p>The volumes that are configured at deployment that the service revision uses.</p>
    pub fn get_volume_configurations(&self) -> &::std::option::Option<::std::vec::Vec<crate::types::ServiceVolumeConfiguration>> {
        &self.volume_configurations
    }
    /// <p>The amount of ephemeral storage to allocate for the deployment.</p>
    pub fn fargate_ephemeral_storage(mut self, input: crate::types::DeploymentEphemeralStorage) -> Self {
        self.fargate_ephemeral_storage = ::std::option::Option::Some(input);
        self
    }
    /// <p>The amount of ephemeral storage to allocate for the deployment.</p>
    pub fn set_fargate_ephemeral_storage(mut self, input: ::std::option::Option<crate::types::DeploymentEphemeralStorage>) -> Self {
        self.fargate_ephemeral_storage = input;
        self
    }
    /// <p>The amount of ephemeral storage to allocate for the deployment.</p>
    pub fn get_fargate_ephemeral_storage(&self) -> &::std::option::Option<crate::types::DeploymentEphemeralStorage> {
        &self.fargate_ephemeral_storage
    }
    /// <p>The time that the service revision was created. The format is yyyy-mm-dd HH:mm:ss.SSSSS.</p>
    pub fn created_at(mut self, input: ::aws_smithy_types::DateTime) -> Self {
        self.created_at = ::std::option::Option::Some(input);
        self
    }
    /// <p>The time that the service revision was created. The format is yyyy-mm-dd HH:mm:ss.SSSSS.</p>
    pub fn set_created_at(mut self, input: ::std::option::Option<::aws_smithy_types::DateTime>) -> Self {
        self.created_at = input;
        self
    }
    /// <p>The time that the service revision was created. The format is yyyy-mm-dd HH:mm:ss.SSSSS.</p>
    pub fn get_created_at(&self) -> &::std::option::Option<::aws_smithy_types::DateTime> {
        &self.created_at
    }
    /// Appends an item to `vpc_lattice_configurations`.
    ///
    /// To override the contents of this collection use [`set_vpc_lattice_configurations`](Self::set_vpc_lattice_configurations).
    ///
    /// <p>The VPC Lattice configuration for the service revision.</p>
    pub fn vpc_lattice_configurations(mut self, input: crate::types::VpcLatticeConfiguration) -> Self {
        let mut v = self.vpc_lattice_configurations.unwrap_or_default();
        v.push(input);
        self.vpc_lattice_configurations = ::std::option::Option::Some(v);
        self
    }
    /// <p>The VPC Lattice configuration for the service revision.</p>
    pub fn set_vpc_lattice_configurations(mut self, input: ::std::option::Option<::std::vec::Vec<crate::types::VpcLatticeConfiguration>>) -> Self {
        self.vpc_lattice_configurations = input;
        self
    }
    /// <p>The VPC Lattice configuration for the service revision.</p>
    pub fn get_vpc_lattice_configurations(&self) -> &::std::option::Option<::std::vec::Vec<crate::types::VpcLatticeConfiguration>> {
        &self.vpc_lattice_configurations
    }
    /// <p>The resolved configuration for the service revision which contains the actual resources your service revision uses, such as which target groups serve traffic.</p>
    pub fn resolved_configuration(mut self, input: crate::types::ResolvedConfiguration) -> Self {
        self.resolved_configuration = ::std::option::Option::Some(input);
        self
    }
    /// <p>The resolved configuration for the service revision which contains the actual resources your service revision uses, such as which target groups serve traffic.</p>
    pub fn set_resolved_configuration(mut self, input: ::std::option::Option<crate::types::ResolvedConfiguration>) -> Self {
        self.resolved_configuration = input;
        self
    }
    /// <p>The resolved configuration for the service revision which contains the actual resources your service revision uses, such as which target groups serve traffic.</p>
    pub fn get_resolved_configuration(&self) -> &::std::option::Option<crate::types::ResolvedConfiguration> {
        &self.resolved_configuration
    }
    /// <p>The resources created and managed by Amazon ECS when you create an Express service for Amazon ECS.</p>
    pub fn ecs_managed_resources(mut self, input: crate::types::EcsManagedResources) -> Self {
        self.ecs_managed_resources = ::std::option::Option::Some(input);
        self
    }
    /// <p>The resources created and managed by Amazon ECS when you create an Express service for Amazon ECS.</p>
    pub fn set_ecs_managed_resources(mut self, input: ::std::option::Option<crate::types::EcsManagedResources>) -> Self {
        self.ecs_managed_resources = input;
        self
    }
    /// <p>The resources created and managed by Amazon ECS when you create an Express service for Amazon ECS.</p>
    pub fn get_ecs_managed_resources(&self) -> &::std::option::Option<crate::types::EcsManagedResources> {
        &self.ecs_managed_resources
    }
    /// Consumes the builder and constructs a [`ServiceRevision`](crate::types::ServiceRevision).
    pub fn build(self) -> crate::types::ServiceRevision {
        crate::types::ServiceRevision {
            service_revision_arn: self.service_revision_arn,
            service_arn: self.service_arn,
            cluster_arn: self.cluster_arn,
            task_definition: self.task_definition,
            capacity_provider_strategy: self.capacity_provider_strategy,
            launch_type: self.launch_type,
            platform_version: self.platform_version,
            platform_family: self.platform_family,
            load_balancers: self.load_balancers,
            service_registries: self.service_registries,
            network_configuration: self.network_configuration,
            container_images: self.container_images,
            guard_duty_enabled: self.guard_duty_enabled.unwrap_or_default(),
            service_connect_configuration: self.service_connect_configuration,
            volume_configurations: self.volume_configurations,
            fargate_ephemeral_storage: self.fargate_ephemeral_storage,
            created_at: self.created_at,
            vpc_lattice_configurations: self.vpc_lattice_configurations,
            resolved_configuration: self.resolved_configuration,
            ecs_managed_resources: self.ecs_managed_resources,
        }
    }
}
