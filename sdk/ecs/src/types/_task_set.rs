// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>Information about a set of Amazon ECS tasks in either an CodeDeploy or an <code>EXTERNAL</code> deployment. An Amazon ECS task set includes details such as the desired number of tasks, how many tasks are running, and whether the task set serves production traffic.</p>
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct TaskSet {
    /// <p>The ID of the task set.</p>
    pub id: ::std::option::Option<::std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the task set.</p>
    pub task_set_arn: ::std::option::Option<::std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the service the task set exists in.</p>
    pub service_arn: ::std::option::Option<::std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the cluster that the service that hosts the task set exists in.</p>
    pub cluster_arn: ::std::option::Option<::std::string::String>,
    /// <p>The tag specified when a task set is started. If an CodeDeploy deployment created the task set, the <code>startedBy</code> parameter is <code>CODE_DEPLOY</code>. If an external deployment created the task set, the <code>startedBy</code> field isn't used.</p>
    pub started_by: ::std::option::Option<::std::string::String>,
    /// <p>The external ID associated with the task set.</p>
    /// <p>If an CodeDeploy deployment created a task set, the <code>externalId</code> parameter contains the CodeDeploy deployment ID.</p>
    /// <p>If a task set is created for an external deployment and is associated with a service discovery registry, the <code>externalId</code> parameter contains the <code>ECS_TASK_SET_EXTERNAL_ID</code> Cloud Map attribute.</p>
    pub external_id: ::std::option::Option<::std::string::String>,
    /// <p>The status of the task set. The following describes each state.</p>
    /// <dl>
    /// <dt>
    /// PRIMARY
    /// </dt>
    /// <dd>
    /// <p>The task set is serving production traffic.</p>
    /// </dd>
    /// <dt>
    /// ACTIVE
    /// </dt>
    /// <dd>
    /// <p>The task set isn't serving production traffic.</p>
    /// </dd>
    /// <dt>
    /// DRAINING
    /// </dt>
    /// <dd>
    /// <p>The tasks in the task set are being stopped, and their corresponding targets are being deregistered from their target group.</p>
    /// </dd>
    /// </dl>
    pub status: ::std::option::Option<::std::string::String>,
    /// <p>The task definition that the task set is using.</p>
    pub task_definition: ::std::option::Option<::std::string::String>,
    /// <p>The computed desired count for the task set. This is calculated by multiplying the service's <code>desiredCount</code> by the task set's <code>scale</code> percentage. The result is always rounded up. For example, if the computed desired count is 1.2, it rounds up to 2 tasks.</p>
    pub computed_desired_count: i32,
    /// <p>The number of tasks in the task set that are in the <code>PENDING</code> status during a deployment. A task in the <code>PENDING</code> state is preparing to enter the <code>RUNNING</code> state. A task set enters the <code>PENDING</code> status when it launches for the first time or when it's restarted after being in the <code>STOPPED</code> state.</p>
    pub pending_count: i32,
    /// <p>The number of tasks in the task set that are in the <code>RUNNING</code> status during a deployment. A task in the <code>RUNNING</code> state is running and ready for use.</p>
    pub running_count: i32,
    /// <p>The Unix timestamp for the time when the task set was created.</p>
    pub created_at: ::std::option::Option<::aws_smithy_types::DateTime>,
    /// <p>The Unix timestamp for the time when the task set was last updated.</p>
    pub updated_at: ::std::option::Option<::aws_smithy_types::DateTime>,
    /// <p>The launch type the tasks in the task set are using. For more information, see <a href="https://docs.aws.amazon.com/AmazonECS/latest/developerguide/launch_types.html">Amazon ECS launch types</a> in the <i>Amazon Elastic Container Service Developer Guide</i>.</p>
    pub launch_type: ::std::option::Option<crate::types::LaunchType>,
    /// <p>The capacity provider strategy that are associated with the task set.</p>
    pub capacity_provider_strategy: ::std::option::Option<::std::vec::Vec<crate::types::CapacityProviderStrategyItem>>,
    /// <p>The Fargate platform version where the tasks in the task set are running. A platform version is only specified for tasks run on Fargate. For more information, see <a href="https://docs.aws.amazon.com/AmazonECS/latest/developerguide/platform_versions.html">Fargate platform versions</a> in the <i>Amazon Elastic Container Service Developer Guide</i>.</p>
    pub platform_version: ::std::option::Option<::std::string::String>,
    /// <p>The operating system that your tasks in the set are running on. A platform family is specified only for tasks that use the Fargate launch type. </p>
    /// <p> All tasks in the set must have the same value.</p>
    pub platform_family: ::std::option::Option<::std::string::String>,
    /// <p>The network configuration for the task set.</p>
    pub network_configuration: ::std::option::Option<crate::types::NetworkConfiguration>,
    /// <p>Details on a load balancer that are used with a task set.</p>
    pub load_balancers: ::std::option::Option<::std::vec::Vec<crate::types::LoadBalancer>>,
    /// <p>The details for the service discovery registries to assign to this task set. For more information, see <a href="https://docs.aws.amazon.com/AmazonECS/latest/developerguide/service-discovery.html">Service discovery</a>.</p>
    pub service_registries: ::std::option::Option<::std::vec::Vec<crate::types::ServiceRegistry>>,
    /// <p>A floating-point percentage of your desired number of tasks to place and keep running in the task set.</p>
    pub scale: ::std::option::Option<crate::types::Scale>,
    /// <p>The stability status. This indicates whether the task set has reached a steady state. If the following conditions are met, the task set are in <code>STEADY_STATE</code>:</p>
    /// <ul>
    /// <li> <p>The task <code>runningCount</code> is equal to the <code>computedDesiredCount</code>.</p> </li>
    /// <li> <p>The <code>pendingCount</code> is <code>0</code>.</p> </li>
    /// <li> <p>There are no tasks that are running on container instances in the <code>DRAINING</code> status.</p> </li>
    /// <li> <p>All tasks are reporting a healthy status from the load balancers, service discovery, and container health checks.</p> </li>
    /// </ul>
    /// <p>If any of those conditions aren't met, the stability status returns <code>STABILIZING</code>.</p>
    pub stability_status: ::std::option::Option<crate::types::StabilityStatus>,
    /// <p>The Unix timestamp for the time when the task set stability status was retrieved.</p>
    pub stability_status_at: ::std::option::Option<::aws_smithy_types::DateTime>,
    /// <p>The metadata that you apply to the task set to help you categorize and organize them. Each tag consists of a key and an optional value. You define both.</p>
    /// <p>The following basic restrictions apply to tags:</p>
    /// <ul>
    /// <li> <p>Maximum number of tags per resource - 50</p> </li>
    /// <li> <p>For each resource, each tag key must be unique, and each tag key can have only one value.</p> </li>
    /// <li> <p>Maximum key length - 128 Unicode characters in UTF-8</p> </li>
    /// <li> <p>Maximum value length - 256 Unicode characters in UTF-8</p> </li>
    /// <li> <p>If your tagging schema is used across multiple services and resources, remember that other services may have restrictions on allowed characters. Generally allowed characters are: letters, numbers, and spaces representable in UTF-8, and the following characters: + - = . _ : / @.</p> </li>
    /// <li> <p>Tag keys and values are case-sensitive.</p> </li>
    /// <li> <p>Do not use <code>aws:</code>, <code>AWS:</code>, or any upper or lowercase combination of such as a prefix for either keys or values as it is reserved for Amazon Web Services use. You cannot edit or delete tag keys or values with this prefix. Tags with this prefix do not count against your tags per resource limit.</p> </li>
    /// </ul>
    pub tags: ::std::option::Option<::std::vec::Vec<crate::types::Tag>>,
}
impl TaskSet {
    /// <p>The ID of the task set.</p>
    pub fn id(&self) -> ::std::option::Option<&str> {
        self.id.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the task set.</p>
    pub fn task_set_arn(&self) -> ::std::option::Option<&str> {
        self.task_set_arn.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the service the task set exists in.</p>
    pub fn service_arn(&self) -> ::std::option::Option<&str> {
        self.service_arn.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the cluster that the service that hosts the task set exists in.</p>
    pub fn cluster_arn(&self) -> ::std::option::Option<&str> {
        self.cluster_arn.as_deref()
    }
    /// <p>The tag specified when a task set is started. If an CodeDeploy deployment created the task set, the <code>startedBy</code> parameter is <code>CODE_DEPLOY</code>. If an external deployment created the task set, the <code>startedBy</code> field isn't used.</p>
    pub fn started_by(&self) -> ::std::option::Option<&str> {
        self.started_by.as_deref()
    }
    /// <p>The external ID associated with the task set.</p>
    /// <p>If an CodeDeploy deployment created a task set, the <code>externalId</code> parameter contains the CodeDeploy deployment ID.</p>
    /// <p>If a task set is created for an external deployment and is associated with a service discovery registry, the <code>externalId</code> parameter contains the <code>ECS_TASK_SET_EXTERNAL_ID</code> Cloud Map attribute.</p>
    pub fn external_id(&self) -> ::std::option::Option<&str> {
        self.external_id.as_deref()
    }
    /// <p>The status of the task set. The following describes each state.</p>
    /// <dl>
    /// <dt>
    /// PRIMARY
    /// </dt>
    /// <dd>
    /// <p>The task set is serving production traffic.</p>
    /// </dd>
    /// <dt>
    /// ACTIVE
    /// </dt>
    /// <dd>
    /// <p>The task set isn't serving production traffic.</p>
    /// </dd>
    /// <dt>
    /// DRAINING
    /// </dt>
    /// <dd>
    /// <p>The tasks in the task set are being stopped, and their corresponding targets are being deregistered from their target group.</p>
    /// </dd>
    /// </dl>
    pub fn status(&self) -> ::std::option::Option<&str> {
        self.status.as_deref()
    }
    /// <p>The task definition that the task set is using.</p>
    pub fn task_definition(&self) -> ::std::option::Option<&str> {
        self.task_definition.as_deref()
    }
    /// <p>The computed desired count for the task set. This is calculated by multiplying the service's <code>desiredCount</code> by the task set's <code>scale</code> percentage. The result is always rounded up. For example, if the computed desired count is 1.2, it rounds up to 2 tasks.</p>
    pub fn computed_desired_count(&self) -> i32 {
        self.computed_desired_count
    }
    /// <p>The number of tasks in the task set that are in the <code>PENDING</code> status during a deployment. A task in the <code>PENDING</code> state is preparing to enter the <code>RUNNING</code> state. A task set enters the <code>PENDING</code> status when it launches for the first time or when it's restarted after being in the <code>STOPPED</code> state.</p>
    pub fn pending_count(&self) -> i32 {
        self.pending_count
    }
    /// <p>The number of tasks in the task set that are in the <code>RUNNING</code> status during a deployment. A task in the <code>RUNNING</code> state is running and ready for use.</p>
    pub fn running_count(&self) -> i32 {
        self.running_count
    }
    /// <p>The Unix timestamp for the time when the task set was created.</p>
    pub fn created_at(&self) -> ::std::option::Option<&::aws_smithy_types::DateTime> {
        self.created_at.as_ref()
    }
    /// <p>The Unix timestamp for the time when the task set was last updated.</p>
    pub fn updated_at(&self) -> ::std::option::Option<&::aws_smithy_types::DateTime> {
        self.updated_at.as_ref()
    }
    /// <p>The launch type the tasks in the task set are using. For more information, see <a href="https://docs.aws.amazon.com/AmazonECS/latest/developerguide/launch_types.html">Amazon ECS launch types</a> in the <i>Amazon Elastic Container Service Developer Guide</i>.</p>
    pub fn launch_type(&self) -> ::std::option::Option<&crate::types::LaunchType> {
        self.launch_type.as_ref()
    }
    /// <p>The capacity provider strategy that are associated with the task set.</p>
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.capacity_provider_strategy.is_none()`.
    pub fn capacity_provider_strategy(&self) -> &[crate::types::CapacityProviderStrategyItem] {
        self.capacity_provider_strategy.as_deref().unwrap_or_default()
    }
    /// <p>The Fargate platform version where the tasks in the task set are running. A platform version is only specified for tasks run on Fargate. For more information, see <a href="https://docs.aws.amazon.com/AmazonECS/latest/developerguide/platform_versions.html">Fargate platform versions</a> in the <i>Amazon Elastic Container Service Developer Guide</i>.</p>
    pub fn platform_version(&self) -> ::std::option::Option<&str> {
        self.platform_version.as_deref()
    }
    /// <p>The operating system that your tasks in the set are running on. A platform family is specified only for tasks that use the Fargate launch type. </p>
    /// <p> All tasks in the set must have the same value.</p>
    pub fn platform_family(&self) -> ::std::option::Option<&str> {
        self.platform_family.as_deref()
    }
    /// <p>The network configuration for the task set.</p>
    pub fn network_configuration(&self) -> ::std::option::Option<&crate::types::NetworkConfiguration> {
        self.network_configuration.as_ref()
    }
    /// <p>Details on a load balancer that are used with a task set.</p>
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.load_balancers.is_none()`.
    pub fn load_balancers(&self) -> &[crate::types::LoadBalancer] {
        self.load_balancers.as_deref().unwrap_or_default()
    }
    /// <p>The details for the service discovery registries to assign to this task set. For more information, see <a href="https://docs.aws.amazon.com/AmazonECS/latest/developerguide/service-discovery.html">Service discovery</a>.</p>
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.service_registries.is_none()`.
    pub fn service_registries(&self) -> &[crate::types::ServiceRegistry] {
        self.service_registries.as_deref().unwrap_or_default()
    }
    /// <p>A floating-point percentage of your desired number of tasks to place and keep running in the task set.</p>
    pub fn scale(&self) -> ::std::option::Option<&crate::types::Scale> {
        self.scale.as_ref()
    }
    /// <p>The stability status. This indicates whether the task set has reached a steady state. If the following conditions are met, the task set are in <code>STEADY_STATE</code>:</p>
    /// <ul>
    /// <li> <p>The task <code>runningCount</code> is equal to the <code>computedDesiredCount</code>.</p> </li>
    /// <li> <p>The <code>pendingCount</code> is <code>0</code>.</p> </li>
    /// <li> <p>There are no tasks that are running on container instances in the <code>DRAINING</code> status.</p> </li>
    /// <li> <p>All tasks are reporting a healthy status from the load balancers, service discovery, and container health checks.</p> </li>
    /// </ul>
    /// <p>If any of those conditions aren't met, the stability status returns <code>STABILIZING</code>.</p>
    pub fn stability_status(&self) -> ::std::option::Option<&crate::types::StabilityStatus> {
        self.stability_status.as_ref()
    }
    /// <p>The Unix timestamp for the time when the task set stability status was retrieved.</p>
    pub fn stability_status_at(&self) -> ::std::option::Option<&::aws_smithy_types::DateTime> {
        self.stability_status_at.as_ref()
    }
    /// <p>The metadata that you apply to the task set to help you categorize and organize them. Each tag consists of a key and an optional value. You define both.</p>
    /// <p>The following basic restrictions apply to tags:</p>
    /// <ul>
    /// <li> <p>Maximum number of tags per resource - 50</p> </li>
    /// <li> <p>For each resource, each tag key must be unique, and each tag key can have only one value.</p> </li>
    /// <li> <p>Maximum key length - 128 Unicode characters in UTF-8</p> </li>
    /// <li> <p>Maximum value length - 256 Unicode characters in UTF-8</p> </li>
    /// <li> <p>If your tagging schema is used across multiple services and resources, remember that other services may have restrictions on allowed characters. Generally allowed characters are: letters, numbers, and spaces representable in UTF-8, and the following characters: + - = . _ : / @.</p> </li>
    /// <li> <p>Tag keys and values are case-sensitive.</p> </li>
    /// <li> <p>Do not use <code>aws:</code>, <code>AWS:</code>, or any upper or lowercase combination of such as a prefix for either keys or values as it is reserved for Amazon Web Services use. You cannot edit or delete tag keys or values with this prefix. Tags with this prefix do not count against your tags per resource limit.</p> </li>
    /// </ul>
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.tags.is_none()`.
    pub fn tags(&self) -> &[crate::types::Tag] {
        self.tags.as_deref().unwrap_or_default()
    }
}
impl TaskSet {
    /// Creates a new builder-style object to manufacture [`TaskSet`](crate::types::TaskSet).
    pub fn builder() -> crate::types::builders::TaskSetBuilder {
        crate::types::builders::TaskSetBuilder::default()
    }
}

/// A builder for [`TaskSet`](crate::types::TaskSet).
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::default::Default, ::std::fmt::Debug)]
pub struct TaskSetBuilder {
    pub(crate) id: ::std::option::Option<::std::string::String>,
    pub(crate) task_set_arn: ::std::option::Option<::std::string::String>,
    pub(crate) service_arn: ::std::option::Option<::std::string::String>,
    pub(crate) cluster_arn: ::std::option::Option<::std::string::String>,
    pub(crate) started_by: ::std::option::Option<::std::string::String>,
    pub(crate) external_id: ::std::option::Option<::std::string::String>,
    pub(crate) status: ::std::option::Option<::std::string::String>,
    pub(crate) task_definition: ::std::option::Option<::std::string::String>,
    pub(crate) computed_desired_count: ::std::option::Option<i32>,
    pub(crate) pending_count: ::std::option::Option<i32>,
    pub(crate) running_count: ::std::option::Option<i32>,
    pub(crate) created_at: ::std::option::Option<::aws_smithy_types::DateTime>,
    pub(crate) updated_at: ::std::option::Option<::aws_smithy_types::DateTime>,
    pub(crate) launch_type: ::std::option::Option<crate::types::LaunchType>,
    pub(crate) capacity_provider_strategy: ::std::option::Option<::std::vec::Vec<crate::types::CapacityProviderStrategyItem>>,
    pub(crate) platform_version: ::std::option::Option<::std::string::String>,
    pub(crate) platform_family: ::std::option::Option<::std::string::String>,
    pub(crate) network_configuration: ::std::option::Option<crate::types::NetworkConfiguration>,
    pub(crate) load_balancers: ::std::option::Option<::std::vec::Vec<crate::types::LoadBalancer>>,
    pub(crate) service_registries: ::std::option::Option<::std::vec::Vec<crate::types::ServiceRegistry>>,
    pub(crate) scale: ::std::option::Option<crate::types::Scale>,
    pub(crate) stability_status: ::std::option::Option<crate::types::StabilityStatus>,
    pub(crate) stability_status_at: ::std::option::Option<::aws_smithy_types::DateTime>,
    pub(crate) tags: ::std::option::Option<::std::vec::Vec<crate::types::Tag>>,
}
impl TaskSetBuilder {
    /// <p>The ID of the task set.</p>
    pub fn id(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.id = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The ID of the task set.</p>
    pub fn set_id(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.id = input;
        self
    }
    /// <p>The ID of the task set.</p>
    pub fn get_id(&self) -> &::std::option::Option<::std::string::String> {
        &self.id
    }
    /// <p>The Amazon Resource Name (ARN) of the task set.</p>
    pub fn task_set_arn(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.task_set_arn = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The Amazon Resource Name (ARN) of the task set.</p>
    pub fn set_task_set_arn(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.task_set_arn = input;
        self
    }
    /// <p>The Amazon Resource Name (ARN) of the task set.</p>
    pub fn get_task_set_arn(&self) -> &::std::option::Option<::std::string::String> {
        &self.task_set_arn
    }
    /// <p>The Amazon Resource Name (ARN) of the service the task set exists in.</p>
    pub fn service_arn(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.service_arn = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The Amazon Resource Name (ARN) of the service the task set exists in.</p>
    pub fn set_service_arn(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.service_arn = input;
        self
    }
    /// <p>The Amazon Resource Name (ARN) of the service the task set exists in.</p>
    pub fn get_service_arn(&self) -> &::std::option::Option<::std::string::String> {
        &self.service_arn
    }
    /// <p>The Amazon Resource Name (ARN) of the cluster that the service that hosts the task set exists in.</p>
    pub fn cluster_arn(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.cluster_arn = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The Amazon Resource Name (ARN) of the cluster that the service that hosts the task set exists in.</p>
    pub fn set_cluster_arn(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.cluster_arn = input;
        self
    }
    /// <p>The Amazon Resource Name (ARN) of the cluster that the service that hosts the task set exists in.</p>
    pub fn get_cluster_arn(&self) -> &::std::option::Option<::std::string::String> {
        &self.cluster_arn
    }
    /// <p>The tag specified when a task set is started. If an CodeDeploy deployment created the task set, the <code>startedBy</code> parameter is <code>CODE_DEPLOY</code>. If an external deployment created the task set, the <code>startedBy</code> field isn't used.</p>
    pub fn started_by(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.started_by = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The tag specified when a task set is started. If an CodeDeploy deployment created the task set, the <code>startedBy</code> parameter is <code>CODE_DEPLOY</code>. If an external deployment created the task set, the <code>startedBy</code> field isn't used.</p>
    pub fn set_started_by(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.started_by = input;
        self
    }
    /// <p>The tag specified when a task set is started. If an CodeDeploy deployment created the task set, the <code>startedBy</code> parameter is <code>CODE_DEPLOY</code>. If an external deployment created the task set, the <code>startedBy</code> field isn't used.</p>
    pub fn get_started_by(&self) -> &::std::option::Option<::std::string::String> {
        &self.started_by
    }
    /// <p>The external ID associated with the task set.</p>
    /// <p>If an CodeDeploy deployment created a task set, the <code>externalId</code> parameter contains the CodeDeploy deployment ID.</p>
    /// <p>If a task set is created for an external deployment and is associated with a service discovery registry, the <code>externalId</code> parameter contains the <code>ECS_TASK_SET_EXTERNAL_ID</code> Cloud Map attribute.</p>
    pub fn external_id(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.external_id = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The external ID associated with the task set.</p>
    /// <p>If an CodeDeploy deployment created a task set, the <code>externalId</code> parameter contains the CodeDeploy deployment ID.</p>
    /// <p>If a task set is created for an external deployment and is associated with a service discovery registry, the <code>externalId</code> parameter contains the <code>ECS_TASK_SET_EXTERNAL_ID</code> Cloud Map attribute.</p>
    pub fn set_external_id(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.external_id = input;
        self
    }
    /// <p>The external ID associated with the task set.</p>
    /// <p>If an CodeDeploy deployment created a task set, the <code>externalId</code> parameter contains the CodeDeploy deployment ID.</p>
    /// <p>If a task set is created for an external deployment and is associated with a service discovery registry, the <code>externalId</code> parameter contains the <code>ECS_TASK_SET_EXTERNAL_ID</code> Cloud Map attribute.</p>
    pub fn get_external_id(&self) -> &::std::option::Option<::std::string::String> {
        &self.external_id
    }
    /// <p>The status of the task set. The following describes each state.</p>
    /// <dl>
    /// <dt>
    /// PRIMARY
    /// </dt>
    /// <dd>
    /// <p>The task set is serving production traffic.</p>
    /// </dd>
    /// <dt>
    /// ACTIVE
    /// </dt>
    /// <dd>
    /// <p>The task set isn't serving production traffic.</p>
    /// </dd>
    /// <dt>
    /// DRAINING
    /// </dt>
    /// <dd>
    /// <p>The tasks in the task set are being stopped, and their corresponding targets are being deregistered from their target group.</p>
    /// </dd>
    /// </dl>
    pub fn status(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.status = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The status of the task set. The following describes each state.</p>
    /// <dl>
    /// <dt>
    /// PRIMARY
    /// </dt>
    /// <dd>
    /// <p>The task set is serving production traffic.</p>
    /// </dd>
    /// <dt>
    /// ACTIVE
    /// </dt>
    /// <dd>
    /// <p>The task set isn't serving production traffic.</p>
    /// </dd>
    /// <dt>
    /// DRAINING
    /// </dt>
    /// <dd>
    /// <p>The tasks in the task set are being stopped, and their corresponding targets are being deregistered from their target group.</p>
    /// </dd>
    /// </dl>
    pub fn set_status(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.status = input;
        self
    }
    /// <p>The status of the task set. The following describes each state.</p>
    /// <dl>
    /// <dt>
    /// PRIMARY
    /// </dt>
    /// <dd>
    /// <p>The task set is serving production traffic.</p>
    /// </dd>
    /// <dt>
    /// ACTIVE
    /// </dt>
    /// <dd>
    /// <p>The task set isn't serving production traffic.</p>
    /// </dd>
    /// <dt>
    /// DRAINING
    /// </dt>
    /// <dd>
    /// <p>The tasks in the task set are being stopped, and their corresponding targets are being deregistered from their target group.</p>
    /// </dd>
    /// </dl>
    pub fn get_status(&self) -> &::std::option::Option<::std::string::String> {
        &self.status
    }
    /// <p>The task definition that the task set is using.</p>
    pub fn task_definition(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.task_definition = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The task definition that the task set is using.</p>
    pub fn set_task_definition(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.task_definition = input;
        self
    }
    /// <p>The task definition that the task set is using.</p>
    pub fn get_task_definition(&self) -> &::std::option::Option<::std::string::String> {
        &self.task_definition
    }
    /// <p>The computed desired count for the task set. This is calculated by multiplying the service's <code>desiredCount</code> by the task set's <code>scale</code> percentage. The result is always rounded up. For example, if the computed desired count is 1.2, it rounds up to 2 tasks.</p>
    pub fn computed_desired_count(mut self, input: i32) -> Self {
        self.computed_desired_count = ::std::option::Option::Some(input);
        self
    }
    /// <p>The computed desired count for the task set. This is calculated by multiplying the service's <code>desiredCount</code> by the task set's <code>scale</code> percentage. The result is always rounded up. For example, if the computed desired count is 1.2, it rounds up to 2 tasks.</p>
    pub fn set_computed_desired_count(mut self, input: ::std::option::Option<i32>) -> Self {
        self.computed_desired_count = input;
        self
    }
    /// <p>The computed desired count for the task set. This is calculated by multiplying the service's <code>desiredCount</code> by the task set's <code>scale</code> percentage. The result is always rounded up. For example, if the computed desired count is 1.2, it rounds up to 2 tasks.</p>
    pub fn get_computed_desired_count(&self) -> &::std::option::Option<i32> {
        &self.computed_desired_count
    }
    /// <p>The number of tasks in the task set that are in the <code>PENDING</code> status during a deployment. A task in the <code>PENDING</code> state is preparing to enter the <code>RUNNING</code> state. A task set enters the <code>PENDING</code> status when it launches for the first time or when it's restarted after being in the <code>STOPPED</code> state.</p>
    pub fn pending_count(mut self, input: i32) -> Self {
        self.pending_count = ::std::option::Option::Some(input);
        self
    }
    /// <p>The number of tasks in the task set that are in the <code>PENDING</code> status during a deployment. A task in the <code>PENDING</code> state is preparing to enter the <code>RUNNING</code> state. A task set enters the <code>PENDING</code> status when it launches for the first time or when it's restarted after being in the <code>STOPPED</code> state.</p>
    pub fn set_pending_count(mut self, input: ::std::option::Option<i32>) -> Self {
        self.pending_count = input;
        self
    }
    /// <p>The number of tasks in the task set that are in the <code>PENDING</code> status during a deployment. A task in the <code>PENDING</code> state is preparing to enter the <code>RUNNING</code> state. A task set enters the <code>PENDING</code> status when it launches for the first time or when it's restarted after being in the <code>STOPPED</code> state.</p>
    pub fn get_pending_count(&self) -> &::std::option::Option<i32> {
        &self.pending_count
    }
    /// <p>The number of tasks in the task set that are in the <code>RUNNING</code> status during a deployment. A task in the <code>RUNNING</code> state is running and ready for use.</p>
    pub fn running_count(mut self, input: i32) -> Self {
        self.running_count = ::std::option::Option::Some(input);
        self
    }
    /// <p>The number of tasks in the task set that are in the <code>RUNNING</code> status during a deployment. A task in the <code>RUNNING</code> state is running and ready for use.</p>
    pub fn set_running_count(mut self, input: ::std::option::Option<i32>) -> Self {
        self.running_count = input;
        self
    }
    /// <p>The number of tasks in the task set that are in the <code>RUNNING</code> status during a deployment. A task in the <code>RUNNING</code> state is running and ready for use.</p>
    pub fn get_running_count(&self) -> &::std::option::Option<i32> {
        &self.running_count
    }
    /// <p>The Unix timestamp for the time when the task set was created.</p>
    pub fn created_at(mut self, input: ::aws_smithy_types::DateTime) -> Self {
        self.created_at = ::std::option::Option::Some(input);
        self
    }
    /// <p>The Unix timestamp for the time when the task set was created.</p>
    pub fn set_created_at(mut self, input: ::std::option::Option<::aws_smithy_types::DateTime>) -> Self {
        self.created_at = input;
        self
    }
    /// <p>The Unix timestamp for the time when the task set was created.</p>
    pub fn get_created_at(&self) -> &::std::option::Option<::aws_smithy_types::DateTime> {
        &self.created_at
    }
    /// <p>The Unix timestamp for the time when the task set was last updated.</p>
    pub fn updated_at(mut self, input: ::aws_smithy_types::DateTime) -> Self {
        self.updated_at = ::std::option::Option::Some(input);
        self
    }
    /// <p>The Unix timestamp for the time when the task set was last updated.</p>
    pub fn set_updated_at(mut self, input: ::std::option::Option<::aws_smithy_types::DateTime>) -> Self {
        self.updated_at = input;
        self
    }
    /// <p>The Unix timestamp for the time when the task set was last updated.</p>
    pub fn get_updated_at(&self) -> &::std::option::Option<::aws_smithy_types::DateTime> {
        &self.updated_at
    }
    /// <p>The launch type the tasks in the task set are using. For more information, see <a href="https://docs.aws.amazon.com/AmazonECS/latest/developerguide/launch_types.html">Amazon ECS launch types</a> in the <i>Amazon Elastic Container Service Developer Guide</i>.</p>
    pub fn launch_type(mut self, input: crate::types::LaunchType) -> Self {
        self.launch_type = ::std::option::Option::Some(input);
        self
    }
    /// <p>The launch type the tasks in the task set are using. For more information, see <a href="https://docs.aws.amazon.com/AmazonECS/latest/developerguide/launch_types.html">Amazon ECS launch types</a> in the <i>Amazon Elastic Container Service Developer Guide</i>.</p>
    pub fn set_launch_type(mut self, input: ::std::option::Option<crate::types::LaunchType>) -> Self {
        self.launch_type = input;
        self
    }
    /// <p>The launch type the tasks in the task set are using. For more information, see <a href="https://docs.aws.amazon.com/AmazonECS/latest/developerguide/launch_types.html">Amazon ECS launch types</a> in the <i>Amazon Elastic Container Service Developer Guide</i>.</p>
    pub fn get_launch_type(&self) -> &::std::option::Option<crate::types::LaunchType> {
        &self.launch_type
    }
    /// Appends an item to `capacity_provider_strategy`.
    ///
    /// To override the contents of this collection use [`set_capacity_provider_strategy`](Self::set_capacity_provider_strategy).
    ///
    /// <p>The capacity provider strategy that are associated with the task set.</p>
    pub fn capacity_provider_strategy(mut self, input: crate::types::CapacityProviderStrategyItem) -> Self {
        let mut v = self.capacity_provider_strategy.unwrap_or_default();
        v.push(input);
        self.capacity_provider_strategy = ::std::option::Option::Some(v);
        self
    }
    /// <p>The capacity provider strategy that are associated with the task set.</p>
    pub fn set_capacity_provider_strategy(
        mut self,
        input: ::std::option::Option<::std::vec::Vec<crate::types::CapacityProviderStrategyItem>>,
    ) -> Self {
        self.capacity_provider_strategy = input;
        self
    }
    /// <p>The capacity provider strategy that are associated with the task set.</p>
    pub fn get_capacity_provider_strategy(&self) -> &::std::option::Option<::std::vec::Vec<crate::types::CapacityProviderStrategyItem>> {
        &self.capacity_provider_strategy
    }
    /// <p>The Fargate platform version where the tasks in the task set are running. A platform version is only specified for tasks run on Fargate. For more information, see <a href="https://docs.aws.amazon.com/AmazonECS/latest/developerguide/platform_versions.html">Fargate platform versions</a> in the <i>Amazon Elastic Container Service Developer Guide</i>.</p>
    pub fn platform_version(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.platform_version = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The Fargate platform version where the tasks in the task set are running. A platform version is only specified for tasks run on Fargate. For more information, see <a href="https://docs.aws.amazon.com/AmazonECS/latest/developerguide/platform_versions.html">Fargate platform versions</a> in the <i>Amazon Elastic Container Service Developer Guide</i>.</p>
    pub fn set_platform_version(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.platform_version = input;
        self
    }
    /// <p>The Fargate platform version where the tasks in the task set are running. A platform version is only specified for tasks run on Fargate. For more information, see <a href="https://docs.aws.amazon.com/AmazonECS/latest/developerguide/platform_versions.html">Fargate platform versions</a> in the <i>Amazon Elastic Container Service Developer Guide</i>.</p>
    pub fn get_platform_version(&self) -> &::std::option::Option<::std::string::String> {
        &self.platform_version
    }
    /// <p>The operating system that your tasks in the set are running on. A platform family is specified only for tasks that use the Fargate launch type. </p>
    /// <p> All tasks in the set must have the same value.</p>
    pub fn platform_family(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.platform_family = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The operating system that your tasks in the set are running on. A platform family is specified only for tasks that use the Fargate launch type. </p>
    /// <p> All tasks in the set must have the same value.</p>
    pub fn set_platform_family(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.platform_family = input;
        self
    }
    /// <p>The operating system that your tasks in the set are running on. A platform family is specified only for tasks that use the Fargate launch type. </p>
    /// <p> All tasks in the set must have the same value.</p>
    pub fn get_platform_family(&self) -> &::std::option::Option<::std::string::String> {
        &self.platform_family
    }
    /// <p>The network configuration for the task set.</p>
    pub fn network_configuration(mut self, input: crate::types::NetworkConfiguration) -> Self {
        self.network_configuration = ::std::option::Option::Some(input);
        self
    }
    /// <p>The network configuration for the task set.</p>
    pub fn set_network_configuration(mut self, input: ::std::option::Option<crate::types::NetworkConfiguration>) -> Self {
        self.network_configuration = input;
        self
    }
    /// <p>The network configuration for the task set.</p>
    pub fn get_network_configuration(&self) -> &::std::option::Option<crate::types::NetworkConfiguration> {
        &self.network_configuration
    }
    /// Appends an item to `load_balancers`.
    ///
    /// To override the contents of this collection use [`set_load_balancers`](Self::set_load_balancers).
    ///
    /// <p>Details on a load balancer that are used with a task set.</p>
    pub fn load_balancers(mut self, input: crate::types::LoadBalancer) -> Self {
        let mut v = self.load_balancers.unwrap_or_default();
        v.push(input);
        self.load_balancers = ::std::option::Option::Some(v);
        self
    }
    /// <p>Details on a load balancer that are used with a task set.</p>
    pub fn set_load_balancers(mut self, input: ::std::option::Option<::std::vec::Vec<crate::types::LoadBalancer>>) -> Self {
        self.load_balancers = input;
        self
    }
    /// <p>Details on a load balancer that are used with a task set.</p>
    pub fn get_load_balancers(&self) -> &::std::option::Option<::std::vec::Vec<crate::types::LoadBalancer>> {
        &self.load_balancers
    }
    /// Appends an item to `service_registries`.
    ///
    /// To override the contents of this collection use [`set_service_registries`](Self::set_service_registries).
    ///
    /// <p>The details for the service discovery registries to assign to this task set. For more information, see <a href="https://docs.aws.amazon.com/AmazonECS/latest/developerguide/service-discovery.html">Service discovery</a>.</p>
    pub fn service_registries(mut self, input: crate::types::ServiceRegistry) -> Self {
        let mut v = self.service_registries.unwrap_or_default();
        v.push(input);
        self.service_registries = ::std::option::Option::Some(v);
        self
    }
    /// <p>The details for the service discovery registries to assign to this task set. For more information, see <a href="https://docs.aws.amazon.com/AmazonECS/latest/developerguide/service-discovery.html">Service discovery</a>.</p>
    pub fn set_service_registries(mut self, input: ::std::option::Option<::std::vec::Vec<crate::types::ServiceRegistry>>) -> Self {
        self.service_registries = input;
        self
    }
    /// <p>The details for the service discovery registries to assign to this task set. For more information, see <a href="https://docs.aws.amazon.com/AmazonECS/latest/developerguide/service-discovery.html">Service discovery</a>.</p>
    pub fn get_service_registries(&self) -> &::std::option::Option<::std::vec::Vec<crate::types::ServiceRegistry>> {
        &self.service_registries
    }
    /// <p>A floating-point percentage of your desired number of tasks to place and keep running in the task set.</p>
    pub fn scale(mut self, input: crate::types::Scale) -> Self {
        self.scale = ::std::option::Option::Some(input);
        self
    }
    /// <p>A floating-point percentage of your desired number of tasks to place and keep running in the task set.</p>
    pub fn set_scale(mut self, input: ::std::option::Option<crate::types::Scale>) -> Self {
        self.scale = input;
        self
    }
    /// <p>A floating-point percentage of your desired number of tasks to place and keep running in the task set.</p>
    pub fn get_scale(&self) -> &::std::option::Option<crate::types::Scale> {
        &self.scale
    }
    /// <p>The stability status. This indicates whether the task set has reached a steady state. If the following conditions are met, the task set are in <code>STEADY_STATE</code>:</p>
    /// <ul>
    /// <li> <p>The task <code>runningCount</code> is equal to the <code>computedDesiredCount</code>.</p> </li>
    /// <li> <p>The <code>pendingCount</code> is <code>0</code>.</p> </li>
    /// <li> <p>There are no tasks that are running on container instances in the <code>DRAINING</code> status.</p> </li>
    /// <li> <p>All tasks are reporting a healthy status from the load balancers, service discovery, and container health checks.</p> </li>
    /// </ul>
    /// <p>If any of those conditions aren't met, the stability status returns <code>STABILIZING</code>.</p>
    pub fn stability_status(mut self, input: crate::types::StabilityStatus) -> Self {
        self.stability_status = ::std::option::Option::Some(input);
        self
    }
    /// <p>The stability status. This indicates whether the task set has reached a steady state. If the following conditions are met, the task set are in <code>STEADY_STATE</code>:</p>
    /// <ul>
    /// <li> <p>The task <code>runningCount</code> is equal to the <code>computedDesiredCount</code>.</p> </li>
    /// <li> <p>The <code>pendingCount</code> is <code>0</code>.</p> </li>
    /// <li> <p>There are no tasks that are running on container instances in the <code>DRAINING</code> status.</p> </li>
    /// <li> <p>All tasks are reporting a healthy status from the load balancers, service discovery, and container health checks.</p> </li>
    /// </ul>
    /// <p>If any of those conditions aren't met, the stability status returns <code>STABILIZING</code>.</p>
    pub fn set_stability_status(mut self, input: ::std::option::Option<crate::types::StabilityStatus>) -> Self {
        self.stability_status = input;
        self
    }
    /// <p>The stability status. This indicates whether the task set has reached a steady state. If the following conditions are met, the task set are in <code>STEADY_STATE</code>:</p>
    /// <ul>
    /// <li> <p>The task <code>runningCount</code> is equal to the <code>computedDesiredCount</code>.</p> </li>
    /// <li> <p>The <code>pendingCount</code> is <code>0</code>.</p> </li>
    /// <li> <p>There are no tasks that are running on container instances in the <code>DRAINING</code> status.</p> </li>
    /// <li> <p>All tasks are reporting a healthy status from the load balancers, service discovery, and container health checks.</p> </li>
    /// </ul>
    /// <p>If any of those conditions aren't met, the stability status returns <code>STABILIZING</code>.</p>
    pub fn get_stability_status(&self) -> &::std::option::Option<crate::types::StabilityStatus> {
        &self.stability_status
    }
    /// <p>The Unix timestamp for the time when the task set stability status was retrieved.</p>
    pub fn stability_status_at(mut self, input: ::aws_smithy_types::DateTime) -> Self {
        self.stability_status_at = ::std::option::Option::Some(input);
        self
    }
    /// <p>The Unix timestamp for the time when the task set stability status was retrieved.</p>
    pub fn set_stability_status_at(mut self, input: ::std::option::Option<::aws_smithy_types::DateTime>) -> Self {
        self.stability_status_at = input;
        self
    }
    /// <p>The Unix timestamp for the time when the task set stability status was retrieved.</p>
    pub fn get_stability_status_at(&self) -> &::std::option::Option<::aws_smithy_types::DateTime> {
        &self.stability_status_at
    }
    /// Appends an item to `tags`.
    ///
    /// To override the contents of this collection use [`set_tags`](Self::set_tags).
    ///
    /// <p>The metadata that you apply to the task set to help you categorize and organize them. Each tag consists of a key and an optional value. You define both.</p>
    /// <p>The following basic restrictions apply to tags:</p>
    /// <ul>
    /// <li> <p>Maximum number of tags per resource - 50</p> </li>
    /// <li> <p>For each resource, each tag key must be unique, and each tag key can have only one value.</p> </li>
    /// <li> <p>Maximum key length - 128 Unicode characters in UTF-8</p> </li>
    /// <li> <p>Maximum value length - 256 Unicode characters in UTF-8</p> </li>
    /// <li> <p>If your tagging schema is used across multiple services and resources, remember that other services may have restrictions on allowed characters. Generally allowed characters are: letters, numbers, and spaces representable in UTF-8, and the following characters: + - = . _ : / @.</p> </li>
    /// <li> <p>Tag keys and values are case-sensitive.</p> </li>
    /// <li> <p>Do not use <code>aws:</code>, <code>AWS:</code>, or any upper or lowercase combination of such as a prefix for either keys or values as it is reserved for Amazon Web Services use. You cannot edit or delete tag keys or values with this prefix. Tags with this prefix do not count against your tags per resource limit.</p> </li>
    /// </ul>
    pub fn tags(mut self, input: crate::types::Tag) -> Self {
        let mut v = self.tags.unwrap_or_default();
        v.push(input);
        self.tags = ::std::option::Option::Some(v);
        self
    }
    /// <p>The metadata that you apply to the task set to help you categorize and organize them. Each tag consists of a key and an optional value. You define both.</p>
    /// <p>The following basic restrictions apply to tags:</p>
    /// <ul>
    /// <li> <p>Maximum number of tags per resource - 50</p> </li>
    /// <li> <p>For each resource, each tag key must be unique, and each tag key can have only one value.</p> </li>
    /// <li> <p>Maximum key length - 128 Unicode characters in UTF-8</p> </li>
    /// <li> <p>Maximum value length - 256 Unicode characters in UTF-8</p> </li>
    /// <li> <p>If your tagging schema is used across multiple services and resources, remember that other services may have restrictions on allowed characters. Generally allowed characters are: letters, numbers, and spaces representable in UTF-8, and the following characters: + - = . _ : / @.</p> </li>
    /// <li> <p>Tag keys and values are case-sensitive.</p> </li>
    /// <li> <p>Do not use <code>aws:</code>, <code>AWS:</code>, or any upper or lowercase combination of such as a prefix for either keys or values as it is reserved for Amazon Web Services use. You cannot edit or delete tag keys or values with this prefix. Tags with this prefix do not count against your tags per resource limit.</p> </li>
    /// </ul>
    pub fn set_tags(mut self, input: ::std::option::Option<::std::vec::Vec<crate::types::Tag>>) -> Self {
        self.tags = input;
        self
    }
    /// <p>The metadata that you apply to the task set to help you categorize and organize them. Each tag consists of a key and an optional value. You define both.</p>
    /// <p>The following basic restrictions apply to tags:</p>
    /// <ul>
    /// <li> <p>Maximum number of tags per resource - 50</p> </li>
    /// <li> <p>For each resource, each tag key must be unique, and each tag key can have only one value.</p> </li>
    /// <li> <p>Maximum key length - 128 Unicode characters in UTF-8</p> </li>
    /// <li> <p>Maximum value length - 256 Unicode characters in UTF-8</p> </li>
    /// <li> <p>If your tagging schema is used across multiple services and resources, remember that other services may have restrictions on allowed characters. Generally allowed characters are: letters, numbers, and spaces representable in UTF-8, and the following characters: + - = . _ : / @.</p> </li>
    /// <li> <p>Tag keys and values are case-sensitive.</p> </li>
    /// <li> <p>Do not use <code>aws:</code>, <code>AWS:</code>, or any upper or lowercase combination of such as a prefix for either keys or values as it is reserved for Amazon Web Services use. You cannot edit or delete tag keys or values with this prefix. Tags with this prefix do not count against your tags per resource limit.</p> </li>
    /// </ul>
    pub fn get_tags(&self) -> &::std::option::Option<::std::vec::Vec<crate::types::Tag>> {
        &self.tags
    }
    /// Consumes the builder and constructs a [`TaskSet`](crate::types::TaskSet).
    pub fn build(self) -> crate::types::TaskSet {
        crate::types::TaskSet {
            id: self.id,
            task_set_arn: self.task_set_arn,
            service_arn: self.service_arn,
            cluster_arn: self.cluster_arn,
            started_by: self.started_by,
            external_id: self.external_id,
            status: self.status,
            task_definition: self.task_definition,
            computed_desired_count: self.computed_desired_count.unwrap_or_default(),
            pending_count: self.pending_count.unwrap_or_default(),
            running_count: self.running_count.unwrap_or_default(),
            created_at: self.created_at,
            updated_at: self.updated_at,
            launch_type: self.launch_type,
            capacity_provider_strategy: self.capacity_provider_strategy,
            platform_version: self.platform_version,
            platform_family: self.platform_family,
            network_configuration: self.network_configuration,
            load_balancers: self.load_balancers,
            service_registries: self.service_registries,
            scale: self.scale,
            stability_status: self.stability_status,
            stability_status_at: self.stability_status_at,
            tags: self.tags,
        }
    }
}
