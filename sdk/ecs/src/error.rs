// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateCapacityProviderError {
    pub kind: CreateCapacityProviderErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateCapacityProviderErrorKind {
    ClientError(crate::error::ClientError),
    InvalidParameterError(crate::error::InvalidParameterError),
    LimitExceededError(crate::error::LimitExceededError),
    ServerError(crate::error::ServerError),
    UpdateInProgressError(crate::error::UpdateInProgressError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateCapacityProviderError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateCapacityProviderErrorKind::ClientError(_inner) => _inner.fmt(f),
            CreateCapacityProviderErrorKind::InvalidParameterError(_inner) => _inner.fmt(f),
            CreateCapacityProviderErrorKind::LimitExceededError(_inner) => _inner.fmt(f),
            CreateCapacityProviderErrorKind::ServerError(_inner) => _inner.fmt(f),
            CreateCapacityProviderErrorKind::UpdateInProgressError(_inner) => _inner.fmt(f),
            CreateCapacityProviderErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateCapacityProviderError {
    fn code(&self) -> Option<&str> {
        CreateCapacityProviderError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateCapacityProviderError {
    pub fn new(kind: CreateCapacityProviderErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateCapacityProviderErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateCapacityProviderErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_client_error(&self) -> bool {
        matches!(&self.kind, CreateCapacityProviderErrorKind::ClientError(_))
    }
    pub fn is_invalid_parameter_error(&self) -> bool {
        matches!(
            &self.kind,
            CreateCapacityProviderErrorKind::InvalidParameterError(_)
        )
    }
    pub fn is_limit_exceeded_error(&self) -> bool {
        matches!(
            &self.kind,
            CreateCapacityProviderErrorKind::LimitExceededError(_)
        )
    }
    pub fn is_server_error(&self) -> bool {
        matches!(&self.kind, CreateCapacityProviderErrorKind::ServerError(_))
    }
    pub fn is_update_in_progress_error(&self) -> bool {
        matches!(
            &self.kind,
            CreateCapacityProviderErrorKind::UpdateInProgressError(_)
        )
    }
}
impl std::error::Error for CreateCapacityProviderError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateCapacityProviderErrorKind::ClientError(_inner) => Some(_inner),
            CreateCapacityProviderErrorKind::InvalidParameterError(_inner) => Some(_inner),
            CreateCapacityProviderErrorKind::LimitExceededError(_inner) => Some(_inner),
            CreateCapacityProviderErrorKind::ServerError(_inner) => Some(_inner),
            CreateCapacityProviderErrorKind::UpdateInProgressError(_inner) => Some(_inner),
            CreateCapacityProviderErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateClusterError {
    pub kind: CreateClusterErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateClusterErrorKind {
    ClientError(crate::error::ClientError),
    InvalidParameterError(crate::error::InvalidParameterError),
    ServerError(crate::error::ServerError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateClusterError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateClusterErrorKind::ClientError(_inner) => _inner.fmt(f),
            CreateClusterErrorKind::InvalidParameterError(_inner) => _inner.fmt(f),
            CreateClusterErrorKind::ServerError(_inner) => _inner.fmt(f),
            CreateClusterErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateClusterError {
    fn code(&self) -> Option<&str> {
        CreateClusterError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateClusterError {
    pub fn new(kind: CreateClusterErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateClusterErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateClusterErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_client_error(&self) -> bool {
        matches!(&self.kind, CreateClusterErrorKind::ClientError(_))
    }
    pub fn is_invalid_parameter_error(&self) -> bool {
        matches!(&self.kind, CreateClusterErrorKind::InvalidParameterError(_))
    }
    pub fn is_server_error(&self) -> bool {
        matches!(&self.kind, CreateClusterErrorKind::ServerError(_))
    }
}
impl std::error::Error for CreateClusterError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateClusterErrorKind::ClientError(_inner) => Some(_inner),
            CreateClusterErrorKind::InvalidParameterError(_inner) => Some(_inner),
            CreateClusterErrorKind::ServerError(_inner) => Some(_inner),
            CreateClusterErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateServiceError {
    pub kind: CreateServiceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateServiceErrorKind {
    AccessDeniedError(crate::error::AccessDeniedError),
    ClientError(crate::error::ClientError),
    ClusterNotFoundError(crate::error::ClusterNotFoundError),
    InvalidParameterError(crate::error::InvalidParameterError),
    PlatformTaskDefinitionIncompatibilityError(
        crate::error::PlatformTaskDefinitionIncompatibilityError,
    ),
    PlatformUnknownError(crate::error::PlatformUnknownError),
    ServerError(crate::error::ServerError),
    UnsupportedFeatureError(crate::error::UnsupportedFeatureError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateServiceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateServiceErrorKind::AccessDeniedError(_inner) => _inner.fmt(f),
            CreateServiceErrorKind::ClientError(_inner) => _inner.fmt(f),
            CreateServiceErrorKind::ClusterNotFoundError(_inner) => _inner.fmt(f),
            CreateServiceErrorKind::InvalidParameterError(_inner) => _inner.fmt(f),
            CreateServiceErrorKind::PlatformTaskDefinitionIncompatibilityError(_inner) => {
                _inner.fmt(f)
            }
            CreateServiceErrorKind::PlatformUnknownError(_inner) => _inner.fmt(f),
            CreateServiceErrorKind::ServerError(_inner) => _inner.fmt(f),
            CreateServiceErrorKind::UnsupportedFeatureError(_inner) => _inner.fmt(f),
            CreateServiceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateServiceError {
    fn code(&self) -> Option<&str> {
        CreateServiceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateServiceError {
    pub fn new(kind: CreateServiceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateServiceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateServiceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_error(&self) -> bool {
        matches!(&self.kind, CreateServiceErrorKind::AccessDeniedError(_))
    }
    pub fn is_client_error(&self) -> bool {
        matches!(&self.kind, CreateServiceErrorKind::ClientError(_))
    }
    pub fn is_cluster_not_found_error(&self) -> bool {
        matches!(&self.kind, CreateServiceErrorKind::ClusterNotFoundError(_))
    }
    pub fn is_invalid_parameter_error(&self) -> bool {
        matches!(&self.kind, CreateServiceErrorKind::InvalidParameterError(_))
    }
    pub fn is_platform_task_definition_incompatibility_error(&self) -> bool {
        matches!(
            &self.kind,
            CreateServiceErrorKind::PlatformTaskDefinitionIncompatibilityError(_)
        )
    }
    pub fn is_platform_unknown_error(&self) -> bool {
        matches!(&self.kind, CreateServiceErrorKind::PlatformUnknownError(_))
    }
    pub fn is_server_error(&self) -> bool {
        matches!(&self.kind, CreateServiceErrorKind::ServerError(_))
    }
    pub fn is_unsupported_feature_error(&self) -> bool {
        matches!(
            &self.kind,
            CreateServiceErrorKind::UnsupportedFeatureError(_)
        )
    }
}
impl std::error::Error for CreateServiceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateServiceErrorKind::AccessDeniedError(_inner) => Some(_inner),
            CreateServiceErrorKind::ClientError(_inner) => Some(_inner),
            CreateServiceErrorKind::ClusterNotFoundError(_inner) => Some(_inner),
            CreateServiceErrorKind::InvalidParameterError(_inner) => Some(_inner),
            CreateServiceErrorKind::PlatformTaskDefinitionIncompatibilityError(_inner) => {
                Some(_inner)
            }
            CreateServiceErrorKind::PlatformUnknownError(_inner) => Some(_inner),
            CreateServiceErrorKind::ServerError(_inner) => Some(_inner),
            CreateServiceErrorKind::UnsupportedFeatureError(_inner) => Some(_inner),
            CreateServiceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateTaskSetError {
    pub kind: CreateTaskSetErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateTaskSetErrorKind {
    AccessDeniedError(crate::error::AccessDeniedError),
    ClientError(crate::error::ClientError),
    ClusterNotFoundError(crate::error::ClusterNotFoundError),
    InvalidParameterError(crate::error::InvalidParameterError),
    PlatformTaskDefinitionIncompatibilityError(
        crate::error::PlatformTaskDefinitionIncompatibilityError,
    ),
    PlatformUnknownError(crate::error::PlatformUnknownError),
    ServerError(crate::error::ServerError),
    ServiceNotActiveError(crate::error::ServiceNotActiveError),
    ServiceNotFoundError(crate::error::ServiceNotFoundError),
    UnsupportedFeatureError(crate::error::UnsupportedFeatureError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateTaskSetError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateTaskSetErrorKind::AccessDeniedError(_inner) => _inner.fmt(f),
            CreateTaskSetErrorKind::ClientError(_inner) => _inner.fmt(f),
            CreateTaskSetErrorKind::ClusterNotFoundError(_inner) => _inner.fmt(f),
            CreateTaskSetErrorKind::InvalidParameterError(_inner) => _inner.fmt(f),
            CreateTaskSetErrorKind::PlatformTaskDefinitionIncompatibilityError(_inner) => {
                _inner.fmt(f)
            }
            CreateTaskSetErrorKind::PlatformUnknownError(_inner) => _inner.fmt(f),
            CreateTaskSetErrorKind::ServerError(_inner) => _inner.fmt(f),
            CreateTaskSetErrorKind::ServiceNotActiveError(_inner) => _inner.fmt(f),
            CreateTaskSetErrorKind::ServiceNotFoundError(_inner) => _inner.fmt(f),
            CreateTaskSetErrorKind::UnsupportedFeatureError(_inner) => _inner.fmt(f),
            CreateTaskSetErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateTaskSetError {
    fn code(&self) -> Option<&str> {
        CreateTaskSetError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateTaskSetError {
    pub fn new(kind: CreateTaskSetErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateTaskSetErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateTaskSetErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_error(&self) -> bool {
        matches!(&self.kind, CreateTaskSetErrorKind::AccessDeniedError(_))
    }
    pub fn is_client_error(&self) -> bool {
        matches!(&self.kind, CreateTaskSetErrorKind::ClientError(_))
    }
    pub fn is_cluster_not_found_error(&self) -> bool {
        matches!(&self.kind, CreateTaskSetErrorKind::ClusterNotFoundError(_))
    }
    pub fn is_invalid_parameter_error(&self) -> bool {
        matches!(&self.kind, CreateTaskSetErrorKind::InvalidParameterError(_))
    }
    pub fn is_platform_task_definition_incompatibility_error(&self) -> bool {
        matches!(
            &self.kind,
            CreateTaskSetErrorKind::PlatformTaskDefinitionIncompatibilityError(_)
        )
    }
    pub fn is_platform_unknown_error(&self) -> bool {
        matches!(&self.kind, CreateTaskSetErrorKind::PlatformUnknownError(_))
    }
    pub fn is_server_error(&self) -> bool {
        matches!(&self.kind, CreateTaskSetErrorKind::ServerError(_))
    }
    pub fn is_service_not_active_error(&self) -> bool {
        matches!(&self.kind, CreateTaskSetErrorKind::ServiceNotActiveError(_))
    }
    pub fn is_service_not_found_error(&self) -> bool {
        matches!(&self.kind, CreateTaskSetErrorKind::ServiceNotFoundError(_))
    }
    pub fn is_unsupported_feature_error(&self) -> bool {
        matches!(
            &self.kind,
            CreateTaskSetErrorKind::UnsupportedFeatureError(_)
        )
    }
}
impl std::error::Error for CreateTaskSetError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateTaskSetErrorKind::AccessDeniedError(_inner) => Some(_inner),
            CreateTaskSetErrorKind::ClientError(_inner) => Some(_inner),
            CreateTaskSetErrorKind::ClusterNotFoundError(_inner) => Some(_inner),
            CreateTaskSetErrorKind::InvalidParameterError(_inner) => Some(_inner),
            CreateTaskSetErrorKind::PlatformTaskDefinitionIncompatibilityError(_inner) => {
                Some(_inner)
            }
            CreateTaskSetErrorKind::PlatformUnknownError(_inner) => Some(_inner),
            CreateTaskSetErrorKind::ServerError(_inner) => Some(_inner),
            CreateTaskSetErrorKind::ServiceNotActiveError(_inner) => Some(_inner),
            CreateTaskSetErrorKind::ServiceNotFoundError(_inner) => Some(_inner),
            CreateTaskSetErrorKind::UnsupportedFeatureError(_inner) => Some(_inner),
            CreateTaskSetErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteAccountSettingError {
    pub kind: DeleteAccountSettingErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteAccountSettingErrorKind {
    ClientError(crate::error::ClientError),
    InvalidParameterError(crate::error::InvalidParameterError),
    ServerError(crate::error::ServerError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteAccountSettingError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteAccountSettingErrorKind::ClientError(_inner) => _inner.fmt(f),
            DeleteAccountSettingErrorKind::InvalidParameterError(_inner) => _inner.fmt(f),
            DeleteAccountSettingErrorKind::ServerError(_inner) => _inner.fmt(f),
            DeleteAccountSettingErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteAccountSettingError {
    fn code(&self) -> Option<&str> {
        DeleteAccountSettingError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteAccountSettingError {
    pub fn new(kind: DeleteAccountSettingErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteAccountSettingErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteAccountSettingErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_client_error(&self) -> bool {
        matches!(&self.kind, DeleteAccountSettingErrorKind::ClientError(_))
    }
    pub fn is_invalid_parameter_error(&self) -> bool {
        matches!(
            &self.kind,
            DeleteAccountSettingErrorKind::InvalidParameterError(_)
        )
    }
    pub fn is_server_error(&self) -> bool {
        matches!(&self.kind, DeleteAccountSettingErrorKind::ServerError(_))
    }
}
impl std::error::Error for DeleteAccountSettingError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteAccountSettingErrorKind::ClientError(_inner) => Some(_inner),
            DeleteAccountSettingErrorKind::InvalidParameterError(_inner) => Some(_inner),
            DeleteAccountSettingErrorKind::ServerError(_inner) => Some(_inner),
            DeleteAccountSettingErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteAttributesError {
    pub kind: DeleteAttributesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteAttributesErrorKind {
    ClusterNotFoundError(crate::error::ClusterNotFoundError),
    InvalidParameterError(crate::error::InvalidParameterError),
    TargetNotFoundError(crate::error::TargetNotFoundError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteAttributesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteAttributesErrorKind::ClusterNotFoundError(_inner) => _inner.fmt(f),
            DeleteAttributesErrorKind::InvalidParameterError(_inner) => _inner.fmt(f),
            DeleteAttributesErrorKind::TargetNotFoundError(_inner) => _inner.fmt(f),
            DeleteAttributesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteAttributesError {
    fn code(&self) -> Option<&str> {
        DeleteAttributesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteAttributesError {
    pub fn new(kind: DeleteAttributesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteAttributesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteAttributesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_cluster_not_found_error(&self) -> bool {
        matches!(
            &self.kind,
            DeleteAttributesErrorKind::ClusterNotFoundError(_)
        )
    }
    pub fn is_invalid_parameter_error(&self) -> bool {
        matches!(
            &self.kind,
            DeleteAttributesErrorKind::InvalidParameterError(_)
        )
    }
    pub fn is_target_not_found_error(&self) -> bool {
        matches!(
            &self.kind,
            DeleteAttributesErrorKind::TargetNotFoundError(_)
        )
    }
}
impl std::error::Error for DeleteAttributesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteAttributesErrorKind::ClusterNotFoundError(_inner) => Some(_inner),
            DeleteAttributesErrorKind::InvalidParameterError(_inner) => Some(_inner),
            DeleteAttributesErrorKind::TargetNotFoundError(_inner) => Some(_inner),
            DeleteAttributesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteCapacityProviderError {
    pub kind: DeleteCapacityProviderErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteCapacityProviderErrorKind {
    ClientError(crate::error::ClientError),
    InvalidParameterError(crate::error::InvalidParameterError),
    ServerError(crate::error::ServerError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteCapacityProviderError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteCapacityProviderErrorKind::ClientError(_inner) => _inner.fmt(f),
            DeleteCapacityProviderErrorKind::InvalidParameterError(_inner) => _inner.fmt(f),
            DeleteCapacityProviderErrorKind::ServerError(_inner) => _inner.fmt(f),
            DeleteCapacityProviderErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteCapacityProviderError {
    fn code(&self) -> Option<&str> {
        DeleteCapacityProviderError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteCapacityProviderError {
    pub fn new(kind: DeleteCapacityProviderErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteCapacityProviderErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteCapacityProviderErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_client_error(&self) -> bool {
        matches!(&self.kind, DeleteCapacityProviderErrorKind::ClientError(_))
    }
    pub fn is_invalid_parameter_error(&self) -> bool {
        matches!(
            &self.kind,
            DeleteCapacityProviderErrorKind::InvalidParameterError(_)
        )
    }
    pub fn is_server_error(&self) -> bool {
        matches!(&self.kind, DeleteCapacityProviderErrorKind::ServerError(_))
    }
}
impl std::error::Error for DeleteCapacityProviderError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteCapacityProviderErrorKind::ClientError(_inner) => Some(_inner),
            DeleteCapacityProviderErrorKind::InvalidParameterError(_inner) => Some(_inner),
            DeleteCapacityProviderErrorKind::ServerError(_inner) => Some(_inner),
            DeleteCapacityProviderErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteClusterError {
    pub kind: DeleteClusterErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteClusterErrorKind {
    ClientError(crate::error::ClientError),
    ClusterContainsContainerInstancesError(crate::error::ClusterContainsContainerInstancesError),
    ClusterContainsServicesError(crate::error::ClusterContainsServicesError),
    ClusterContainsTasksError(crate::error::ClusterContainsTasksError),
    ClusterNotFoundError(crate::error::ClusterNotFoundError),
    InvalidParameterError(crate::error::InvalidParameterError),
    ServerError(crate::error::ServerError),
    UpdateInProgressError(crate::error::UpdateInProgressError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteClusterError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteClusterErrorKind::ClientError(_inner) => _inner.fmt(f),
            DeleteClusterErrorKind::ClusterContainsContainerInstancesError(_inner) => _inner.fmt(f),
            DeleteClusterErrorKind::ClusterContainsServicesError(_inner) => _inner.fmt(f),
            DeleteClusterErrorKind::ClusterContainsTasksError(_inner) => _inner.fmt(f),
            DeleteClusterErrorKind::ClusterNotFoundError(_inner) => _inner.fmt(f),
            DeleteClusterErrorKind::InvalidParameterError(_inner) => _inner.fmt(f),
            DeleteClusterErrorKind::ServerError(_inner) => _inner.fmt(f),
            DeleteClusterErrorKind::UpdateInProgressError(_inner) => _inner.fmt(f),
            DeleteClusterErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteClusterError {
    fn code(&self) -> Option<&str> {
        DeleteClusterError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteClusterError {
    pub fn new(kind: DeleteClusterErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteClusterErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteClusterErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_client_error(&self) -> bool {
        matches!(&self.kind, DeleteClusterErrorKind::ClientError(_))
    }
    pub fn is_cluster_contains_container_instances_error(&self) -> bool {
        matches!(
            &self.kind,
            DeleteClusterErrorKind::ClusterContainsContainerInstancesError(_)
        )
    }
    pub fn is_cluster_contains_services_error(&self) -> bool {
        matches!(
            &self.kind,
            DeleteClusterErrorKind::ClusterContainsServicesError(_)
        )
    }
    pub fn is_cluster_contains_tasks_error(&self) -> bool {
        matches!(
            &self.kind,
            DeleteClusterErrorKind::ClusterContainsTasksError(_)
        )
    }
    pub fn is_cluster_not_found_error(&self) -> bool {
        matches!(&self.kind, DeleteClusterErrorKind::ClusterNotFoundError(_))
    }
    pub fn is_invalid_parameter_error(&self) -> bool {
        matches!(&self.kind, DeleteClusterErrorKind::InvalidParameterError(_))
    }
    pub fn is_server_error(&self) -> bool {
        matches!(&self.kind, DeleteClusterErrorKind::ServerError(_))
    }
    pub fn is_update_in_progress_error(&self) -> bool {
        matches!(&self.kind, DeleteClusterErrorKind::UpdateInProgressError(_))
    }
}
impl std::error::Error for DeleteClusterError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteClusterErrorKind::ClientError(_inner) => Some(_inner),
            DeleteClusterErrorKind::ClusterContainsContainerInstancesError(_inner) => Some(_inner),
            DeleteClusterErrorKind::ClusterContainsServicesError(_inner) => Some(_inner),
            DeleteClusterErrorKind::ClusterContainsTasksError(_inner) => Some(_inner),
            DeleteClusterErrorKind::ClusterNotFoundError(_inner) => Some(_inner),
            DeleteClusterErrorKind::InvalidParameterError(_inner) => Some(_inner),
            DeleteClusterErrorKind::ServerError(_inner) => Some(_inner),
            DeleteClusterErrorKind::UpdateInProgressError(_inner) => Some(_inner),
            DeleteClusterErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteServiceError {
    pub kind: DeleteServiceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteServiceErrorKind {
    ClientError(crate::error::ClientError),
    ClusterNotFoundError(crate::error::ClusterNotFoundError),
    InvalidParameterError(crate::error::InvalidParameterError),
    ServerError(crate::error::ServerError),
    ServiceNotFoundError(crate::error::ServiceNotFoundError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteServiceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteServiceErrorKind::ClientError(_inner) => _inner.fmt(f),
            DeleteServiceErrorKind::ClusterNotFoundError(_inner) => _inner.fmt(f),
            DeleteServiceErrorKind::InvalidParameterError(_inner) => _inner.fmt(f),
            DeleteServiceErrorKind::ServerError(_inner) => _inner.fmt(f),
            DeleteServiceErrorKind::ServiceNotFoundError(_inner) => _inner.fmt(f),
            DeleteServiceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteServiceError {
    fn code(&self) -> Option<&str> {
        DeleteServiceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteServiceError {
    pub fn new(kind: DeleteServiceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteServiceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteServiceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_client_error(&self) -> bool {
        matches!(&self.kind, DeleteServiceErrorKind::ClientError(_))
    }
    pub fn is_cluster_not_found_error(&self) -> bool {
        matches!(&self.kind, DeleteServiceErrorKind::ClusterNotFoundError(_))
    }
    pub fn is_invalid_parameter_error(&self) -> bool {
        matches!(&self.kind, DeleteServiceErrorKind::InvalidParameterError(_))
    }
    pub fn is_server_error(&self) -> bool {
        matches!(&self.kind, DeleteServiceErrorKind::ServerError(_))
    }
    pub fn is_service_not_found_error(&self) -> bool {
        matches!(&self.kind, DeleteServiceErrorKind::ServiceNotFoundError(_))
    }
}
impl std::error::Error for DeleteServiceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteServiceErrorKind::ClientError(_inner) => Some(_inner),
            DeleteServiceErrorKind::ClusterNotFoundError(_inner) => Some(_inner),
            DeleteServiceErrorKind::InvalidParameterError(_inner) => Some(_inner),
            DeleteServiceErrorKind::ServerError(_inner) => Some(_inner),
            DeleteServiceErrorKind::ServiceNotFoundError(_inner) => Some(_inner),
            DeleteServiceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteTaskSetError {
    pub kind: DeleteTaskSetErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteTaskSetErrorKind {
    AccessDeniedError(crate::error::AccessDeniedError),
    ClientError(crate::error::ClientError),
    ClusterNotFoundError(crate::error::ClusterNotFoundError),
    InvalidParameterError(crate::error::InvalidParameterError),
    ServerError(crate::error::ServerError),
    ServiceNotActiveError(crate::error::ServiceNotActiveError),
    ServiceNotFoundError(crate::error::ServiceNotFoundError),
    TaskSetNotFoundError(crate::error::TaskSetNotFoundError),
    UnsupportedFeatureError(crate::error::UnsupportedFeatureError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteTaskSetError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteTaskSetErrorKind::AccessDeniedError(_inner) => _inner.fmt(f),
            DeleteTaskSetErrorKind::ClientError(_inner) => _inner.fmt(f),
            DeleteTaskSetErrorKind::ClusterNotFoundError(_inner) => _inner.fmt(f),
            DeleteTaskSetErrorKind::InvalidParameterError(_inner) => _inner.fmt(f),
            DeleteTaskSetErrorKind::ServerError(_inner) => _inner.fmt(f),
            DeleteTaskSetErrorKind::ServiceNotActiveError(_inner) => _inner.fmt(f),
            DeleteTaskSetErrorKind::ServiceNotFoundError(_inner) => _inner.fmt(f),
            DeleteTaskSetErrorKind::TaskSetNotFoundError(_inner) => _inner.fmt(f),
            DeleteTaskSetErrorKind::UnsupportedFeatureError(_inner) => _inner.fmt(f),
            DeleteTaskSetErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteTaskSetError {
    fn code(&self) -> Option<&str> {
        DeleteTaskSetError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteTaskSetError {
    pub fn new(kind: DeleteTaskSetErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteTaskSetErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteTaskSetErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_error(&self) -> bool {
        matches!(&self.kind, DeleteTaskSetErrorKind::AccessDeniedError(_))
    }
    pub fn is_client_error(&self) -> bool {
        matches!(&self.kind, DeleteTaskSetErrorKind::ClientError(_))
    }
    pub fn is_cluster_not_found_error(&self) -> bool {
        matches!(&self.kind, DeleteTaskSetErrorKind::ClusterNotFoundError(_))
    }
    pub fn is_invalid_parameter_error(&self) -> bool {
        matches!(&self.kind, DeleteTaskSetErrorKind::InvalidParameterError(_))
    }
    pub fn is_server_error(&self) -> bool {
        matches!(&self.kind, DeleteTaskSetErrorKind::ServerError(_))
    }
    pub fn is_service_not_active_error(&self) -> bool {
        matches!(&self.kind, DeleteTaskSetErrorKind::ServiceNotActiveError(_))
    }
    pub fn is_service_not_found_error(&self) -> bool {
        matches!(&self.kind, DeleteTaskSetErrorKind::ServiceNotFoundError(_))
    }
    pub fn is_task_set_not_found_error(&self) -> bool {
        matches!(&self.kind, DeleteTaskSetErrorKind::TaskSetNotFoundError(_))
    }
    pub fn is_unsupported_feature_error(&self) -> bool {
        matches!(
            &self.kind,
            DeleteTaskSetErrorKind::UnsupportedFeatureError(_)
        )
    }
}
impl std::error::Error for DeleteTaskSetError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteTaskSetErrorKind::AccessDeniedError(_inner) => Some(_inner),
            DeleteTaskSetErrorKind::ClientError(_inner) => Some(_inner),
            DeleteTaskSetErrorKind::ClusterNotFoundError(_inner) => Some(_inner),
            DeleteTaskSetErrorKind::InvalidParameterError(_inner) => Some(_inner),
            DeleteTaskSetErrorKind::ServerError(_inner) => Some(_inner),
            DeleteTaskSetErrorKind::ServiceNotActiveError(_inner) => Some(_inner),
            DeleteTaskSetErrorKind::ServiceNotFoundError(_inner) => Some(_inner),
            DeleteTaskSetErrorKind::TaskSetNotFoundError(_inner) => Some(_inner),
            DeleteTaskSetErrorKind::UnsupportedFeatureError(_inner) => Some(_inner),
            DeleteTaskSetErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeregisterContainerInstanceError {
    pub kind: DeregisterContainerInstanceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeregisterContainerInstanceErrorKind {
    ClientError(crate::error::ClientError),
    ClusterNotFoundError(crate::error::ClusterNotFoundError),
    InvalidParameterError(crate::error::InvalidParameterError),
    ServerError(crate::error::ServerError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeregisterContainerInstanceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeregisterContainerInstanceErrorKind::ClientError(_inner) => _inner.fmt(f),
            DeregisterContainerInstanceErrorKind::ClusterNotFoundError(_inner) => _inner.fmt(f),
            DeregisterContainerInstanceErrorKind::InvalidParameterError(_inner) => _inner.fmt(f),
            DeregisterContainerInstanceErrorKind::ServerError(_inner) => _inner.fmt(f),
            DeregisterContainerInstanceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeregisterContainerInstanceError {
    fn code(&self) -> Option<&str> {
        DeregisterContainerInstanceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeregisterContainerInstanceError {
    pub fn new(kind: DeregisterContainerInstanceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeregisterContainerInstanceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeregisterContainerInstanceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_client_error(&self) -> bool {
        matches!(
            &self.kind,
            DeregisterContainerInstanceErrorKind::ClientError(_)
        )
    }
    pub fn is_cluster_not_found_error(&self) -> bool {
        matches!(
            &self.kind,
            DeregisterContainerInstanceErrorKind::ClusterNotFoundError(_)
        )
    }
    pub fn is_invalid_parameter_error(&self) -> bool {
        matches!(
            &self.kind,
            DeregisterContainerInstanceErrorKind::InvalidParameterError(_)
        )
    }
    pub fn is_server_error(&self) -> bool {
        matches!(
            &self.kind,
            DeregisterContainerInstanceErrorKind::ServerError(_)
        )
    }
}
impl std::error::Error for DeregisterContainerInstanceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeregisterContainerInstanceErrorKind::ClientError(_inner) => Some(_inner),
            DeregisterContainerInstanceErrorKind::ClusterNotFoundError(_inner) => Some(_inner),
            DeregisterContainerInstanceErrorKind::InvalidParameterError(_inner) => Some(_inner),
            DeregisterContainerInstanceErrorKind::ServerError(_inner) => Some(_inner),
            DeregisterContainerInstanceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeregisterTaskDefinitionError {
    pub kind: DeregisterTaskDefinitionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeregisterTaskDefinitionErrorKind {
    ClientError(crate::error::ClientError),
    InvalidParameterError(crate::error::InvalidParameterError),
    ServerError(crate::error::ServerError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeregisterTaskDefinitionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeregisterTaskDefinitionErrorKind::ClientError(_inner) => _inner.fmt(f),
            DeregisterTaskDefinitionErrorKind::InvalidParameterError(_inner) => _inner.fmt(f),
            DeregisterTaskDefinitionErrorKind::ServerError(_inner) => _inner.fmt(f),
            DeregisterTaskDefinitionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeregisterTaskDefinitionError {
    fn code(&self) -> Option<&str> {
        DeregisterTaskDefinitionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeregisterTaskDefinitionError {
    pub fn new(kind: DeregisterTaskDefinitionErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeregisterTaskDefinitionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeregisterTaskDefinitionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_client_error(&self) -> bool {
        matches!(
            &self.kind,
            DeregisterTaskDefinitionErrorKind::ClientError(_)
        )
    }
    pub fn is_invalid_parameter_error(&self) -> bool {
        matches!(
            &self.kind,
            DeregisterTaskDefinitionErrorKind::InvalidParameterError(_)
        )
    }
    pub fn is_server_error(&self) -> bool {
        matches!(
            &self.kind,
            DeregisterTaskDefinitionErrorKind::ServerError(_)
        )
    }
}
impl std::error::Error for DeregisterTaskDefinitionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeregisterTaskDefinitionErrorKind::ClientError(_inner) => Some(_inner),
            DeregisterTaskDefinitionErrorKind::InvalidParameterError(_inner) => Some(_inner),
            DeregisterTaskDefinitionErrorKind::ServerError(_inner) => Some(_inner),
            DeregisterTaskDefinitionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeCapacityProvidersError {
    pub kind: DescribeCapacityProvidersErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeCapacityProvidersErrorKind {
    ClientError(crate::error::ClientError),
    InvalidParameterError(crate::error::InvalidParameterError),
    ServerError(crate::error::ServerError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeCapacityProvidersError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeCapacityProvidersErrorKind::ClientError(_inner) => _inner.fmt(f),
            DescribeCapacityProvidersErrorKind::InvalidParameterError(_inner) => _inner.fmt(f),
            DescribeCapacityProvidersErrorKind::ServerError(_inner) => _inner.fmt(f),
            DescribeCapacityProvidersErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeCapacityProvidersError {
    fn code(&self) -> Option<&str> {
        DescribeCapacityProvidersError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeCapacityProvidersError {
    pub fn new(kind: DescribeCapacityProvidersErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeCapacityProvidersErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeCapacityProvidersErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_client_error(&self) -> bool {
        matches!(
            &self.kind,
            DescribeCapacityProvidersErrorKind::ClientError(_)
        )
    }
    pub fn is_invalid_parameter_error(&self) -> bool {
        matches!(
            &self.kind,
            DescribeCapacityProvidersErrorKind::InvalidParameterError(_)
        )
    }
    pub fn is_server_error(&self) -> bool {
        matches!(
            &self.kind,
            DescribeCapacityProvidersErrorKind::ServerError(_)
        )
    }
}
impl std::error::Error for DescribeCapacityProvidersError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeCapacityProvidersErrorKind::ClientError(_inner) => Some(_inner),
            DescribeCapacityProvidersErrorKind::InvalidParameterError(_inner) => Some(_inner),
            DescribeCapacityProvidersErrorKind::ServerError(_inner) => Some(_inner),
            DescribeCapacityProvidersErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeClustersError {
    pub kind: DescribeClustersErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeClustersErrorKind {
    ClientError(crate::error::ClientError),
    InvalidParameterError(crate::error::InvalidParameterError),
    ServerError(crate::error::ServerError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeClustersError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeClustersErrorKind::ClientError(_inner) => _inner.fmt(f),
            DescribeClustersErrorKind::InvalidParameterError(_inner) => _inner.fmt(f),
            DescribeClustersErrorKind::ServerError(_inner) => _inner.fmt(f),
            DescribeClustersErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeClustersError {
    fn code(&self) -> Option<&str> {
        DescribeClustersError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeClustersError {
    pub fn new(kind: DescribeClustersErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeClustersErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeClustersErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_client_error(&self) -> bool {
        matches!(&self.kind, DescribeClustersErrorKind::ClientError(_))
    }
    pub fn is_invalid_parameter_error(&self) -> bool {
        matches!(
            &self.kind,
            DescribeClustersErrorKind::InvalidParameterError(_)
        )
    }
    pub fn is_server_error(&self) -> bool {
        matches!(&self.kind, DescribeClustersErrorKind::ServerError(_))
    }
}
impl std::error::Error for DescribeClustersError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeClustersErrorKind::ClientError(_inner) => Some(_inner),
            DescribeClustersErrorKind::InvalidParameterError(_inner) => Some(_inner),
            DescribeClustersErrorKind::ServerError(_inner) => Some(_inner),
            DescribeClustersErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeContainerInstancesError {
    pub kind: DescribeContainerInstancesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeContainerInstancesErrorKind {
    ClientError(crate::error::ClientError),
    ClusterNotFoundError(crate::error::ClusterNotFoundError),
    InvalidParameterError(crate::error::InvalidParameterError),
    ServerError(crate::error::ServerError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeContainerInstancesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeContainerInstancesErrorKind::ClientError(_inner) => _inner.fmt(f),
            DescribeContainerInstancesErrorKind::ClusterNotFoundError(_inner) => _inner.fmt(f),
            DescribeContainerInstancesErrorKind::InvalidParameterError(_inner) => _inner.fmt(f),
            DescribeContainerInstancesErrorKind::ServerError(_inner) => _inner.fmt(f),
            DescribeContainerInstancesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeContainerInstancesError {
    fn code(&self) -> Option<&str> {
        DescribeContainerInstancesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeContainerInstancesError {
    pub fn new(kind: DescribeContainerInstancesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeContainerInstancesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeContainerInstancesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_client_error(&self) -> bool {
        matches!(
            &self.kind,
            DescribeContainerInstancesErrorKind::ClientError(_)
        )
    }
    pub fn is_cluster_not_found_error(&self) -> bool {
        matches!(
            &self.kind,
            DescribeContainerInstancesErrorKind::ClusterNotFoundError(_)
        )
    }
    pub fn is_invalid_parameter_error(&self) -> bool {
        matches!(
            &self.kind,
            DescribeContainerInstancesErrorKind::InvalidParameterError(_)
        )
    }
    pub fn is_server_error(&self) -> bool {
        matches!(
            &self.kind,
            DescribeContainerInstancesErrorKind::ServerError(_)
        )
    }
}
impl std::error::Error for DescribeContainerInstancesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeContainerInstancesErrorKind::ClientError(_inner) => Some(_inner),
            DescribeContainerInstancesErrorKind::ClusterNotFoundError(_inner) => Some(_inner),
            DescribeContainerInstancesErrorKind::InvalidParameterError(_inner) => Some(_inner),
            DescribeContainerInstancesErrorKind::ServerError(_inner) => Some(_inner),
            DescribeContainerInstancesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeServicesError {
    pub kind: DescribeServicesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeServicesErrorKind {
    ClientError(crate::error::ClientError),
    ClusterNotFoundError(crate::error::ClusterNotFoundError),
    InvalidParameterError(crate::error::InvalidParameterError),
    ServerError(crate::error::ServerError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeServicesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeServicesErrorKind::ClientError(_inner) => _inner.fmt(f),
            DescribeServicesErrorKind::ClusterNotFoundError(_inner) => _inner.fmt(f),
            DescribeServicesErrorKind::InvalidParameterError(_inner) => _inner.fmt(f),
            DescribeServicesErrorKind::ServerError(_inner) => _inner.fmt(f),
            DescribeServicesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeServicesError {
    fn code(&self) -> Option<&str> {
        DescribeServicesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeServicesError {
    pub fn new(kind: DescribeServicesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeServicesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeServicesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_client_error(&self) -> bool {
        matches!(&self.kind, DescribeServicesErrorKind::ClientError(_))
    }
    pub fn is_cluster_not_found_error(&self) -> bool {
        matches!(
            &self.kind,
            DescribeServicesErrorKind::ClusterNotFoundError(_)
        )
    }
    pub fn is_invalid_parameter_error(&self) -> bool {
        matches!(
            &self.kind,
            DescribeServicesErrorKind::InvalidParameterError(_)
        )
    }
    pub fn is_server_error(&self) -> bool {
        matches!(&self.kind, DescribeServicesErrorKind::ServerError(_))
    }
}
impl std::error::Error for DescribeServicesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeServicesErrorKind::ClientError(_inner) => Some(_inner),
            DescribeServicesErrorKind::ClusterNotFoundError(_inner) => Some(_inner),
            DescribeServicesErrorKind::InvalidParameterError(_inner) => Some(_inner),
            DescribeServicesErrorKind::ServerError(_inner) => Some(_inner),
            DescribeServicesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeTaskDefinitionError {
    pub kind: DescribeTaskDefinitionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeTaskDefinitionErrorKind {
    ClientError(crate::error::ClientError),
    InvalidParameterError(crate::error::InvalidParameterError),
    ServerError(crate::error::ServerError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeTaskDefinitionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeTaskDefinitionErrorKind::ClientError(_inner) => _inner.fmt(f),
            DescribeTaskDefinitionErrorKind::InvalidParameterError(_inner) => _inner.fmt(f),
            DescribeTaskDefinitionErrorKind::ServerError(_inner) => _inner.fmt(f),
            DescribeTaskDefinitionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeTaskDefinitionError {
    fn code(&self) -> Option<&str> {
        DescribeTaskDefinitionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeTaskDefinitionError {
    pub fn new(kind: DescribeTaskDefinitionErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeTaskDefinitionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeTaskDefinitionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_client_error(&self) -> bool {
        matches!(&self.kind, DescribeTaskDefinitionErrorKind::ClientError(_))
    }
    pub fn is_invalid_parameter_error(&self) -> bool {
        matches!(
            &self.kind,
            DescribeTaskDefinitionErrorKind::InvalidParameterError(_)
        )
    }
    pub fn is_server_error(&self) -> bool {
        matches!(&self.kind, DescribeTaskDefinitionErrorKind::ServerError(_))
    }
}
impl std::error::Error for DescribeTaskDefinitionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeTaskDefinitionErrorKind::ClientError(_inner) => Some(_inner),
            DescribeTaskDefinitionErrorKind::InvalidParameterError(_inner) => Some(_inner),
            DescribeTaskDefinitionErrorKind::ServerError(_inner) => Some(_inner),
            DescribeTaskDefinitionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeTasksError {
    pub kind: DescribeTasksErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeTasksErrorKind {
    ClientError(crate::error::ClientError),
    ClusterNotFoundError(crate::error::ClusterNotFoundError),
    InvalidParameterError(crate::error::InvalidParameterError),
    ServerError(crate::error::ServerError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeTasksError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeTasksErrorKind::ClientError(_inner) => _inner.fmt(f),
            DescribeTasksErrorKind::ClusterNotFoundError(_inner) => _inner.fmt(f),
            DescribeTasksErrorKind::InvalidParameterError(_inner) => _inner.fmt(f),
            DescribeTasksErrorKind::ServerError(_inner) => _inner.fmt(f),
            DescribeTasksErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeTasksError {
    fn code(&self) -> Option<&str> {
        DescribeTasksError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeTasksError {
    pub fn new(kind: DescribeTasksErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeTasksErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeTasksErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_client_error(&self) -> bool {
        matches!(&self.kind, DescribeTasksErrorKind::ClientError(_))
    }
    pub fn is_cluster_not_found_error(&self) -> bool {
        matches!(&self.kind, DescribeTasksErrorKind::ClusterNotFoundError(_))
    }
    pub fn is_invalid_parameter_error(&self) -> bool {
        matches!(&self.kind, DescribeTasksErrorKind::InvalidParameterError(_))
    }
    pub fn is_server_error(&self) -> bool {
        matches!(&self.kind, DescribeTasksErrorKind::ServerError(_))
    }
}
impl std::error::Error for DescribeTasksError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeTasksErrorKind::ClientError(_inner) => Some(_inner),
            DescribeTasksErrorKind::ClusterNotFoundError(_inner) => Some(_inner),
            DescribeTasksErrorKind::InvalidParameterError(_inner) => Some(_inner),
            DescribeTasksErrorKind::ServerError(_inner) => Some(_inner),
            DescribeTasksErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeTaskSetsError {
    pub kind: DescribeTaskSetsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeTaskSetsErrorKind {
    AccessDeniedError(crate::error::AccessDeniedError),
    ClientError(crate::error::ClientError),
    ClusterNotFoundError(crate::error::ClusterNotFoundError),
    InvalidParameterError(crate::error::InvalidParameterError),
    ServerError(crate::error::ServerError),
    ServiceNotActiveError(crate::error::ServiceNotActiveError),
    ServiceNotFoundError(crate::error::ServiceNotFoundError),
    UnsupportedFeatureError(crate::error::UnsupportedFeatureError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeTaskSetsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeTaskSetsErrorKind::AccessDeniedError(_inner) => _inner.fmt(f),
            DescribeTaskSetsErrorKind::ClientError(_inner) => _inner.fmt(f),
            DescribeTaskSetsErrorKind::ClusterNotFoundError(_inner) => _inner.fmt(f),
            DescribeTaskSetsErrorKind::InvalidParameterError(_inner) => _inner.fmt(f),
            DescribeTaskSetsErrorKind::ServerError(_inner) => _inner.fmt(f),
            DescribeTaskSetsErrorKind::ServiceNotActiveError(_inner) => _inner.fmt(f),
            DescribeTaskSetsErrorKind::ServiceNotFoundError(_inner) => _inner.fmt(f),
            DescribeTaskSetsErrorKind::UnsupportedFeatureError(_inner) => _inner.fmt(f),
            DescribeTaskSetsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeTaskSetsError {
    fn code(&self) -> Option<&str> {
        DescribeTaskSetsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeTaskSetsError {
    pub fn new(kind: DescribeTaskSetsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeTaskSetsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeTaskSetsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_error(&self) -> bool {
        matches!(&self.kind, DescribeTaskSetsErrorKind::AccessDeniedError(_))
    }
    pub fn is_client_error(&self) -> bool {
        matches!(&self.kind, DescribeTaskSetsErrorKind::ClientError(_))
    }
    pub fn is_cluster_not_found_error(&self) -> bool {
        matches!(
            &self.kind,
            DescribeTaskSetsErrorKind::ClusterNotFoundError(_)
        )
    }
    pub fn is_invalid_parameter_error(&self) -> bool {
        matches!(
            &self.kind,
            DescribeTaskSetsErrorKind::InvalidParameterError(_)
        )
    }
    pub fn is_server_error(&self) -> bool {
        matches!(&self.kind, DescribeTaskSetsErrorKind::ServerError(_))
    }
    pub fn is_service_not_active_error(&self) -> bool {
        matches!(
            &self.kind,
            DescribeTaskSetsErrorKind::ServiceNotActiveError(_)
        )
    }
    pub fn is_service_not_found_error(&self) -> bool {
        matches!(
            &self.kind,
            DescribeTaskSetsErrorKind::ServiceNotFoundError(_)
        )
    }
    pub fn is_unsupported_feature_error(&self) -> bool {
        matches!(
            &self.kind,
            DescribeTaskSetsErrorKind::UnsupportedFeatureError(_)
        )
    }
}
impl std::error::Error for DescribeTaskSetsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeTaskSetsErrorKind::AccessDeniedError(_inner) => Some(_inner),
            DescribeTaskSetsErrorKind::ClientError(_inner) => Some(_inner),
            DescribeTaskSetsErrorKind::ClusterNotFoundError(_inner) => Some(_inner),
            DescribeTaskSetsErrorKind::InvalidParameterError(_inner) => Some(_inner),
            DescribeTaskSetsErrorKind::ServerError(_inner) => Some(_inner),
            DescribeTaskSetsErrorKind::ServiceNotActiveError(_inner) => Some(_inner),
            DescribeTaskSetsErrorKind::ServiceNotFoundError(_inner) => Some(_inner),
            DescribeTaskSetsErrorKind::UnsupportedFeatureError(_inner) => Some(_inner),
            DescribeTaskSetsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DiscoverPollEndpointError {
    pub kind: DiscoverPollEndpointErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DiscoverPollEndpointErrorKind {
    ClientError(crate::error::ClientError),
    ServerError(crate::error::ServerError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DiscoverPollEndpointError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DiscoverPollEndpointErrorKind::ClientError(_inner) => _inner.fmt(f),
            DiscoverPollEndpointErrorKind::ServerError(_inner) => _inner.fmt(f),
            DiscoverPollEndpointErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DiscoverPollEndpointError {
    fn code(&self) -> Option<&str> {
        DiscoverPollEndpointError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DiscoverPollEndpointError {
    pub fn new(kind: DiscoverPollEndpointErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DiscoverPollEndpointErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DiscoverPollEndpointErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_client_error(&self) -> bool {
        matches!(&self.kind, DiscoverPollEndpointErrorKind::ClientError(_))
    }
    pub fn is_server_error(&self) -> bool {
        matches!(&self.kind, DiscoverPollEndpointErrorKind::ServerError(_))
    }
}
impl std::error::Error for DiscoverPollEndpointError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DiscoverPollEndpointErrorKind::ClientError(_inner) => Some(_inner),
            DiscoverPollEndpointErrorKind::ServerError(_inner) => Some(_inner),
            DiscoverPollEndpointErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ExecuteCommandError {
    pub kind: ExecuteCommandErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ExecuteCommandErrorKind {
    AccessDeniedError(crate::error::AccessDeniedError),
    ClientError(crate::error::ClientError),
    ClusterNotFoundError(crate::error::ClusterNotFoundError),
    InvalidParameterError(crate::error::InvalidParameterError),
    ServerError(crate::error::ServerError),
    TargetNotConnectedError(crate::error::TargetNotConnectedError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ExecuteCommandError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ExecuteCommandErrorKind::AccessDeniedError(_inner) => _inner.fmt(f),
            ExecuteCommandErrorKind::ClientError(_inner) => _inner.fmt(f),
            ExecuteCommandErrorKind::ClusterNotFoundError(_inner) => _inner.fmt(f),
            ExecuteCommandErrorKind::InvalidParameterError(_inner) => _inner.fmt(f),
            ExecuteCommandErrorKind::ServerError(_inner) => _inner.fmt(f),
            ExecuteCommandErrorKind::TargetNotConnectedError(_inner) => _inner.fmt(f),
            ExecuteCommandErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ExecuteCommandError {
    fn code(&self) -> Option<&str> {
        ExecuteCommandError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ExecuteCommandError {
    pub fn new(kind: ExecuteCommandErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ExecuteCommandErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ExecuteCommandErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_error(&self) -> bool {
        matches!(&self.kind, ExecuteCommandErrorKind::AccessDeniedError(_))
    }
    pub fn is_client_error(&self) -> bool {
        matches!(&self.kind, ExecuteCommandErrorKind::ClientError(_))
    }
    pub fn is_cluster_not_found_error(&self) -> bool {
        matches!(&self.kind, ExecuteCommandErrorKind::ClusterNotFoundError(_))
    }
    pub fn is_invalid_parameter_error(&self) -> bool {
        matches!(
            &self.kind,
            ExecuteCommandErrorKind::InvalidParameterError(_)
        )
    }
    pub fn is_server_error(&self) -> bool {
        matches!(&self.kind, ExecuteCommandErrorKind::ServerError(_))
    }
    pub fn is_target_not_connected_error(&self) -> bool {
        matches!(
            &self.kind,
            ExecuteCommandErrorKind::TargetNotConnectedError(_)
        )
    }
}
impl std::error::Error for ExecuteCommandError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ExecuteCommandErrorKind::AccessDeniedError(_inner) => Some(_inner),
            ExecuteCommandErrorKind::ClientError(_inner) => Some(_inner),
            ExecuteCommandErrorKind::ClusterNotFoundError(_inner) => Some(_inner),
            ExecuteCommandErrorKind::InvalidParameterError(_inner) => Some(_inner),
            ExecuteCommandErrorKind::ServerError(_inner) => Some(_inner),
            ExecuteCommandErrorKind::TargetNotConnectedError(_inner) => Some(_inner),
            ExecuteCommandErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListAccountSettingsError {
    pub kind: ListAccountSettingsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListAccountSettingsErrorKind {
    ClientError(crate::error::ClientError),
    InvalidParameterError(crate::error::InvalidParameterError),
    ServerError(crate::error::ServerError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListAccountSettingsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListAccountSettingsErrorKind::ClientError(_inner) => _inner.fmt(f),
            ListAccountSettingsErrorKind::InvalidParameterError(_inner) => _inner.fmt(f),
            ListAccountSettingsErrorKind::ServerError(_inner) => _inner.fmt(f),
            ListAccountSettingsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListAccountSettingsError {
    fn code(&self) -> Option<&str> {
        ListAccountSettingsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListAccountSettingsError {
    pub fn new(kind: ListAccountSettingsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListAccountSettingsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListAccountSettingsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_client_error(&self) -> bool {
        matches!(&self.kind, ListAccountSettingsErrorKind::ClientError(_))
    }
    pub fn is_invalid_parameter_error(&self) -> bool {
        matches!(
            &self.kind,
            ListAccountSettingsErrorKind::InvalidParameterError(_)
        )
    }
    pub fn is_server_error(&self) -> bool {
        matches!(&self.kind, ListAccountSettingsErrorKind::ServerError(_))
    }
}
impl std::error::Error for ListAccountSettingsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListAccountSettingsErrorKind::ClientError(_inner) => Some(_inner),
            ListAccountSettingsErrorKind::InvalidParameterError(_inner) => Some(_inner),
            ListAccountSettingsErrorKind::ServerError(_inner) => Some(_inner),
            ListAccountSettingsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListAttributesError {
    pub kind: ListAttributesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListAttributesErrorKind {
    ClusterNotFoundError(crate::error::ClusterNotFoundError),
    InvalidParameterError(crate::error::InvalidParameterError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListAttributesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListAttributesErrorKind::ClusterNotFoundError(_inner) => _inner.fmt(f),
            ListAttributesErrorKind::InvalidParameterError(_inner) => _inner.fmt(f),
            ListAttributesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListAttributesError {
    fn code(&self) -> Option<&str> {
        ListAttributesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListAttributesError {
    pub fn new(kind: ListAttributesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListAttributesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListAttributesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_cluster_not_found_error(&self) -> bool {
        matches!(&self.kind, ListAttributesErrorKind::ClusterNotFoundError(_))
    }
    pub fn is_invalid_parameter_error(&self) -> bool {
        matches!(
            &self.kind,
            ListAttributesErrorKind::InvalidParameterError(_)
        )
    }
}
impl std::error::Error for ListAttributesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListAttributesErrorKind::ClusterNotFoundError(_inner) => Some(_inner),
            ListAttributesErrorKind::InvalidParameterError(_inner) => Some(_inner),
            ListAttributesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListClustersError {
    pub kind: ListClustersErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListClustersErrorKind {
    ClientError(crate::error::ClientError),
    InvalidParameterError(crate::error::InvalidParameterError),
    ServerError(crate::error::ServerError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListClustersError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListClustersErrorKind::ClientError(_inner) => _inner.fmt(f),
            ListClustersErrorKind::InvalidParameterError(_inner) => _inner.fmt(f),
            ListClustersErrorKind::ServerError(_inner) => _inner.fmt(f),
            ListClustersErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListClustersError {
    fn code(&self) -> Option<&str> {
        ListClustersError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListClustersError {
    pub fn new(kind: ListClustersErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListClustersErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListClustersErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_client_error(&self) -> bool {
        matches!(&self.kind, ListClustersErrorKind::ClientError(_))
    }
    pub fn is_invalid_parameter_error(&self) -> bool {
        matches!(&self.kind, ListClustersErrorKind::InvalidParameterError(_))
    }
    pub fn is_server_error(&self) -> bool {
        matches!(&self.kind, ListClustersErrorKind::ServerError(_))
    }
}
impl std::error::Error for ListClustersError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListClustersErrorKind::ClientError(_inner) => Some(_inner),
            ListClustersErrorKind::InvalidParameterError(_inner) => Some(_inner),
            ListClustersErrorKind::ServerError(_inner) => Some(_inner),
            ListClustersErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListContainerInstancesError {
    pub kind: ListContainerInstancesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListContainerInstancesErrorKind {
    ClientError(crate::error::ClientError),
    ClusterNotFoundError(crate::error::ClusterNotFoundError),
    InvalidParameterError(crate::error::InvalidParameterError),
    ServerError(crate::error::ServerError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListContainerInstancesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListContainerInstancesErrorKind::ClientError(_inner) => _inner.fmt(f),
            ListContainerInstancesErrorKind::ClusterNotFoundError(_inner) => _inner.fmt(f),
            ListContainerInstancesErrorKind::InvalidParameterError(_inner) => _inner.fmt(f),
            ListContainerInstancesErrorKind::ServerError(_inner) => _inner.fmt(f),
            ListContainerInstancesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListContainerInstancesError {
    fn code(&self) -> Option<&str> {
        ListContainerInstancesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListContainerInstancesError {
    pub fn new(kind: ListContainerInstancesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListContainerInstancesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListContainerInstancesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_client_error(&self) -> bool {
        matches!(&self.kind, ListContainerInstancesErrorKind::ClientError(_))
    }
    pub fn is_cluster_not_found_error(&self) -> bool {
        matches!(
            &self.kind,
            ListContainerInstancesErrorKind::ClusterNotFoundError(_)
        )
    }
    pub fn is_invalid_parameter_error(&self) -> bool {
        matches!(
            &self.kind,
            ListContainerInstancesErrorKind::InvalidParameterError(_)
        )
    }
    pub fn is_server_error(&self) -> bool {
        matches!(&self.kind, ListContainerInstancesErrorKind::ServerError(_))
    }
}
impl std::error::Error for ListContainerInstancesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListContainerInstancesErrorKind::ClientError(_inner) => Some(_inner),
            ListContainerInstancesErrorKind::ClusterNotFoundError(_inner) => Some(_inner),
            ListContainerInstancesErrorKind::InvalidParameterError(_inner) => Some(_inner),
            ListContainerInstancesErrorKind::ServerError(_inner) => Some(_inner),
            ListContainerInstancesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListServicesError {
    pub kind: ListServicesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListServicesErrorKind {
    ClientError(crate::error::ClientError),
    ClusterNotFoundError(crate::error::ClusterNotFoundError),
    InvalidParameterError(crate::error::InvalidParameterError),
    ServerError(crate::error::ServerError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListServicesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListServicesErrorKind::ClientError(_inner) => _inner.fmt(f),
            ListServicesErrorKind::ClusterNotFoundError(_inner) => _inner.fmt(f),
            ListServicesErrorKind::InvalidParameterError(_inner) => _inner.fmt(f),
            ListServicesErrorKind::ServerError(_inner) => _inner.fmt(f),
            ListServicesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListServicesError {
    fn code(&self) -> Option<&str> {
        ListServicesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListServicesError {
    pub fn new(kind: ListServicesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListServicesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListServicesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_client_error(&self) -> bool {
        matches!(&self.kind, ListServicesErrorKind::ClientError(_))
    }
    pub fn is_cluster_not_found_error(&self) -> bool {
        matches!(&self.kind, ListServicesErrorKind::ClusterNotFoundError(_))
    }
    pub fn is_invalid_parameter_error(&self) -> bool {
        matches!(&self.kind, ListServicesErrorKind::InvalidParameterError(_))
    }
    pub fn is_server_error(&self) -> bool {
        matches!(&self.kind, ListServicesErrorKind::ServerError(_))
    }
}
impl std::error::Error for ListServicesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListServicesErrorKind::ClientError(_inner) => Some(_inner),
            ListServicesErrorKind::ClusterNotFoundError(_inner) => Some(_inner),
            ListServicesErrorKind::InvalidParameterError(_inner) => Some(_inner),
            ListServicesErrorKind::ServerError(_inner) => Some(_inner),
            ListServicesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListTagsForResourceError {
    pub kind: ListTagsForResourceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListTagsForResourceErrorKind {
    ClientError(crate::error::ClientError),
    ClusterNotFoundError(crate::error::ClusterNotFoundError),
    InvalidParameterError(crate::error::InvalidParameterError),
    ServerError(crate::error::ServerError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListTagsForResourceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListTagsForResourceErrorKind::ClientError(_inner) => _inner.fmt(f),
            ListTagsForResourceErrorKind::ClusterNotFoundError(_inner) => _inner.fmt(f),
            ListTagsForResourceErrorKind::InvalidParameterError(_inner) => _inner.fmt(f),
            ListTagsForResourceErrorKind::ServerError(_inner) => _inner.fmt(f),
            ListTagsForResourceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListTagsForResourceError {
    fn code(&self) -> Option<&str> {
        ListTagsForResourceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListTagsForResourceError {
    pub fn new(kind: ListTagsForResourceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListTagsForResourceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListTagsForResourceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_client_error(&self) -> bool {
        matches!(&self.kind, ListTagsForResourceErrorKind::ClientError(_))
    }
    pub fn is_cluster_not_found_error(&self) -> bool {
        matches!(
            &self.kind,
            ListTagsForResourceErrorKind::ClusterNotFoundError(_)
        )
    }
    pub fn is_invalid_parameter_error(&self) -> bool {
        matches!(
            &self.kind,
            ListTagsForResourceErrorKind::InvalidParameterError(_)
        )
    }
    pub fn is_server_error(&self) -> bool {
        matches!(&self.kind, ListTagsForResourceErrorKind::ServerError(_))
    }
}
impl std::error::Error for ListTagsForResourceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListTagsForResourceErrorKind::ClientError(_inner) => Some(_inner),
            ListTagsForResourceErrorKind::ClusterNotFoundError(_inner) => Some(_inner),
            ListTagsForResourceErrorKind::InvalidParameterError(_inner) => Some(_inner),
            ListTagsForResourceErrorKind::ServerError(_inner) => Some(_inner),
            ListTagsForResourceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListTaskDefinitionFamiliesError {
    pub kind: ListTaskDefinitionFamiliesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListTaskDefinitionFamiliesErrorKind {
    ClientError(crate::error::ClientError),
    InvalidParameterError(crate::error::InvalidParameterError),
    ServerError(crate::error::ServerError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListTaskDefinitionFamiliesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListTaskDefinitionFamiliesErrorKind::ClientError(_inner) => _inner.fmt(f),
            ListTaskDefinitionFamiliesErrorKind::InvalidParameterError(_inner) => _inner.fmt(f),
            ListTaskDefinitionFamiliesErrorKind::ServerError(_inner) => _inner.fmt(f),
            ListTaskDefinitionFamiliesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListTaskDefinitionFamiliesError {
    fn code(&self) -> Option<&str> {
        ListTaskDefinitionFamiliesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListTaskDefinitionFamiliesError {
    pub fn new(kind: ListTaskDefinitionFamiliesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListTaskDefinitionFamiliesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListTaskDefinitionFamiliesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_client_error(&self) -> bool {
        matches!(
            &self.kind,
            ListTaskDefinitionFamiliesErrorKind::ClientError(_)
        )
    }
    pub fn is_invalid_parameter_error(&self) -> bool {
        matches!(
            &self.kind,
            ListTaskDefinitionFamiliesErrorKind::InvalidParameterError(_)
        )
    }
    pub fn is_server_error(&self) -> bool {
        matches!(
            &self.kind,
            ListTaskDefinitionFamiliesErrorKind::ServerError(_)
        )
    }
}
impl std::error::Error for ListTaskDefinitionFamiliesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListTaskDefinitionFamiliesErrorKind::ClientError(_inner) => Some(_inner),
            ListTaskDefinitionFamiliesErrorKind::InvalidParameterError(_inner) => Some(_inner),
            ListTaskDefinitionFamiliesErrorKind::ServerError(_inner) => Some(_inner),
            ListTaskDefinitionFamiliesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListTaskDefinitionsError {
    pub kind: ListTaskDefinitionsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListTaskDefinitionsErrorKind {
    ClientError(crate::error::ClientError),
    InvalidParameterError(crate::error::InvalidParameterError),
    ServerError(crate::error::ServerError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListTaskDefinitionsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListTaskDefinitionsErrorKind::ClientError(_inner) => _inner.fmt(f),
            ListTaskDefinitionsErrorKind::InvalidParameterError(_inner) => _inner.fmt(f),
            ListTaskDefinitionsErrorKind::ServerError(_inner) => _inner.fmt(f),
            ListTaskDefinitionsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListTaskDefinitionsError {
    fn code(&self) -> Option<&str> {
        ListTaskDefinitionsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListTaskDefinitionsError {
    pub fn new(kind: ListTaskDefinitionsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListTaskDefinitionsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListTaskDefinitionsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_client_error(&self) -> bool {
        matches!(&self.kind, ListTaskDefinitionsErrorKind::ClientError(_))
    }
    pub fn is_invalid_parameter_error(&self) -> bool {
        matches!(
            &self.kind,
            ListTaskDefinitionsErrorKind::InvalidParameterError(_)
        )
    }
    pub fn is_server_error(&self) -> bool {
        matches!(&self.kind, ListTaskDefinitionsErrorKind::ServerError(_))
    }
}
impl std::error::Error for ListTaskDefinitionsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListTaskDefinitionsErrorKind::ClientError(_inner) => Some(_inner),
            ListTaskDefinitionsErrorKind::InvalidParameterError(_inner) => Some(_inner),
            ListTaskDefinitionsErrorKind::ServerError(_inner) => Some(_inner),
            ListTaskDefinitionsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListTasksError {
    pub kind: ListTasksErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListTasksErrorKind {
    ClientError(crate::error::ClientError),
    ClusterNotFoundError(crate::error::ClusterNotFoundError),
    InvalidParameterError(crate::error::InvalidParameterError),
    ServerError(crate::error::ServerError),
    ServiceNotFoundError(crate::error::ServiceNotFoundError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListTasksError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListTasksErrorKind::ClientError(_inner) => _inner.fmt(f),
            ListTasksErrorKind::ClusterNotFoundError(_inner) => _inner.fmt(f),
            ListTasksErrorKind::InvalidParameterError(_inner) => _inner.fmt(f),
            ListTasksErrorKind::ServerError(_inner) => _inner.fmt(f),
            ListTasksErrorKind::ServiceNotFoundError(_inner) => _inner.fmt(f),
            ListTasksErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListTasksError {
    fn code(&self) -> Option<&str> {
        ListTasksError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListTasksError {
    pub fn new(kind: ListTasksErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListTasksErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListTasksErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_client_error(&self) -> bool {
        matches!(&self.kind, ListTasksErrorKind::ClientError(_))
    }
    pub fn is_cluster_not_found_error(&self) -> bool {
        matches!(&self.kind, ListTasksErrorKind::ClusterNotFoundError(_))
    }
    pub fn is_invalid_parameter_error(&self) -> bool {
        matches!(&self.kind, ListTasksErrorKind::InvalidParameterError(_))
    }
    pub fn is_server_error(&self) -> bool {
        matches!(&self.kind, ListTasksErrorKind::ServerError(_))
    }
    pub fn is_service_not_found_error(&self) -> bool {
        matches!(&self.kind, ListTasksErrorKind::ServiceNotFoundError(_))
    }
}
impl std::error::Error for ListTasksError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListTasksErrorKind::ClientError(_inner) => Some(_inner),
            ListTasksErrorKind::ClusterNotFoundError(_inner) => Some(_inner),
            ListTasksErrorKind::InvalidParameterError(_inner) => Some(_inner),
            ListTasksErrorKind::ServerError(_inner) => Some(_inner),
            ListTasksErrorKind::ServiceNotFoundError(_inner) => Some(_inner),
            ListTasksErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct PutAccountSettingError {
    pub kind: PutAccountSettingErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum PutAccountSettingErrorKind {
    ClientError(crate::error::ClientError),
    InvalidParameterError(crate::error::InvalidParameterError),
    ServerError(crate::error::ServerError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for PutAccountSettingError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            PutAccountSettingErrorKind::ClientError(_inner) => _inner.fmt(f),
            PutAccountSettingErrorKind::InvalidParameterError(_inner) => _inner.fmt(f),
            PutAccountSettingErrorKind::ServerError(_inner) => _inner.fmt(f),
            PutAccountSettingErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for PutAccountSettingError {
    fn code(&self) -> Option<&str> {
        PutAccountSettingError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl PutAccountSettingError {
    pub fn new(kind: PutAccountSettingErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: PutAccountSettingErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: PutAccountSettingErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_client_error(&self) -> bool {
        matches!(&self.kind, PutAccountSettingErrorKind::ClientError(_))
    }
    pub fn is_invalid_parameter_error(&self) -> bool {
        matches!(
            &self.kind,
            PutAccountSettingErrorKind::InvalidParameterError(_)
        )
    }
    pub fn is_server_error(&self) -> bool {
        matches!(&self.kind, PutAccountSettingErrorKind::ServerError(_))
    }
}
impl std::error::Error for PutAccountSettingError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            PutAccountSettingErrorKind::ClientError(_inner) => Some(_inner),
            PutAccountSettingErrorKind::InvalidParameterError(_inner) => Some(_inner),
            PutAccountSettingErrorKind::ServerError(_inner) => Some(_inner),
            PutAccountSettingErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct PutAccountSettingDefaultError {
    pub kind: PutAccountSettingDefaultErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum PutAccountSettingDefaultErrorKind {
    ClientError(crate::error::ClientError),
    InvalidParameterError(crate::error::InvalidParameterError),
    ServerError(crate::error::ServerError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for PutAccountSettingDefaultError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            PutAccountSettingDefaultErrorKind::ClientError(_inner) => _inner.fmt(f),
            PutAccountSettingDefaultErrorKind::InvalidParameterError(_inner) => _inner.fmt(f),
            PutAccountSettingDefaultErrorKind::ServerError(_inner) => _inner.fmt(f),
            PutAccountSettingDefaultErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for PutAccountSettingDefaultError {
    fn code(&self) -> Option<&str> {
        PutAccountSettingDefaultError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl PutAccountSettingDefaultError {
    pub fn new(kind: PutAccountSettingDefaultErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: PutAccountSettingDefaultErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: PutAccountSettingDefaultErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_client_error(&self) -> bool {
        matches!(
            &self.kind,
            PutAccountSettingDefaultErrorKind::ClientError(_)
        )
    }
    pub fn is_invalid_parameter_error(&self) -> bool {
        matches!(
            &self.kind,
            PutAccountSettingDefaultErrorKind::InvalidParameterError(_)
        )
    }
    pub fn is_server_error(&self) -> bool {
        matches!(
            &self.kind,
            PutAccountSettingDefaultErrorKind::ServerError(_)
        )
    }
}
impl std::error::Error for PutAccountSettingDefaultError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            PutAccountSettingDefaultErrorKind::ClientError(_inner) => Some(_inner),
            PutAccountSettingDefaultErrorKind::InvalidParameterError(_inner) => Some(_inner),
            PutAccountSettingDefaultErrorKind::ServerError(_inner) => Some(_inner),
            PutAccountSettingDefaultErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct PutAttributesError {
    pub kind: PutAttributesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum PutAttributesErrorKind {
    AttributeLimitExceededError(crate::error::AttributeLimitExceededError),
    ClusterNotFoundError(crate::error::ClusterNotFoundError),
    InvalidParameterError(crate::error::InvalidParameterError),
    TargetNotFoundError(crate::error::TargetNotFoundError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for PutAttributesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            PutAttributesErrorKind::AttributeLimitExceededError(_inner) => _inner.fmt(f),
            PutAttributesErrorKind::ClusterNotFoundError(_inner) => _inner.fmt(f),
            PutAttributesErrorKind::InvalidParameterError(_inner) => _inner.fmt(f),
            PutAttributesErrorKind::TargetNotFoundError(_inner) => _inner.fmt(f),
            PutAttributesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for PutAttributesError {
    fn code(&self) -> Option<&str> {
        PutAttributesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl PutAttributesError {
    pub fn new(kind: PutAttributesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: PutAttributesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: PutAttributesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_attribute_limit_exceeded_error(&self) -> bool {
        matches!(
            &self.kind,
            PutAttributesErrorKind::AttributeLimitExceededError(_)
        )
    }
    pub fn is_cluster_not_found_error(&self) -> bool {
        matches!(&self.kind, PutAttributesErrorKind::ClusterNotFoundError(_))
    }
    pub fn is_invalid_parameter_error(&self) -> bool {
        matches!(&self.kind, PutAttributesErrorKind::InvalidParameterError(_))
    }
    pub fn is_target_not_found_error(&self) -> bool {
        matches!(&self.kind, PutAttributesErrorKind::TargetNotFoundError(_))
    }
}
impl std::error::Error for PutAttributesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            PutAttributesErrorKind::AttributeLimitExceededError(_inner) => Some(_inner),
            PutAttributesErrorKind::ClusterNotFoundError(_inner) => Some(_inner),
            PutAttributesErrorKind::InvalidParameterError(_inner) => Some(_inner),
            PutAttributesErrorKind::TargetNotFoundError(_inner) => Some(_inner),
            PutAttributesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct PutClusterCapacityProvidersError {
    pub kind: PutClusterCapacityProvidersErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum PutClusterCapacityProvidersErrorKind {
    ClientError(crate::error::ClientError),
    ClusterNotFoundError(crate::error::ClusterNotFoundError),
    InvalidParameterError(crate::error::InvalidParameterError),
    ResourceInUseError(crate::error::ResourceInUseError),
    ServerError(crate::error::ServerError),
    UpdateInProgressError(crate::error::UpdateInProgressError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for PutClusterCapacityProvidersError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            PutClusterCapacityProvidersErrorKind::ClientError(_inner) => _inner.fmt(f),
            PutClusterCapacityProvidersErrorKind::ClusterNotFoundError(_inner) => _inner.fmt(f),
            PutClusterCapacityProvidersErrorKind::InvalidParameterError(_inner) => _inner.fmt(f),
            PutClusterCapacityProvidersErrorKind::ResourceInUseError(_inner) => _inner.fmt(f),
            PutClusterCapacityProvidersErrorKind::ServerError(_inner) => _inner.fmt(f),
            PutClusterCapacityProvidersErrorKind::UpdateInProgressError(_inner) => _inner.fmt(f),
            PutClusterCapacityProvidersErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for PutClusterCapacityProvidersError {
    fn code(&self) -> Option<&str> {
        PutClusterCapacityProvidersError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl PutClusterCapacityProvidersError {
    pub fn new(kind: PutClusterCapacityProvidersErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: PutClusterCapacityProvidersErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: PutClusterCapacityProvidersErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_client_error(&self) -> bool {
        matches!(
            &self.kind,
            PutClusterCapacityProvidersErrorKind::ClientError(_)
        )
    }
    pub fn is_cluster_not_found_error(&self) -> bool {
        matches!(
            &self.kind,
            PutClusterCapacityProvidersErrorKind::ClusterNotFoundError(_)
        )
    }
    pub fn is_invalid_parameter_error(&self) -> bool {
        matches!(
            &self.kind,
            PutClusterCapacityProvidersErrorKind::InvalidParameterError(_)
        )
    }
    pub fn is_resource_in_use_error(&self) -> bool {
        matches!(
            &self.kind,
            PutClusterCapacityProvidersErrorKind::ResourceInUseError(_)
        )
    }
    pub fn is_server_error(&self) -> bool {
        matches!(
            &self.kind,
            PutClusterCapacityProvidersErrorKind::ServerError(_)
        )
    }
    pub fn is_update_in_progress_error(&self) -> bool {
        matches!(
            &self.kind,
            PutClusterCapacityProvidersErrorKind::UpdateInProgressError(_)
        )
    }
}
impl std::error::Error for PutClusterCapacityProvidersError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            PutClusterCapacityProvidersErrorKind::ClientError(_inner) => Some(_inner),
            PutClusterCapacityProvidersErrorKind::ClusterNotFoundError(_inner) => Some(_inner),
            PutClusterCapacityProvidersErrorKind::InvalidParameterError(_inner) => Some(_inner),
            PutClusterCapacityProvidersErrorKind::ResourceInUseError(_inner) => Some(_inner),
            PutClusterCapacityProvidersErrorKind::ServerError(_inner) => Some(_inner),
            PutClusterCapacityProvidersErrorKind::UpdateInProgressError(_inner) => Some(_inner),
            PutClusterCapacityProvidersErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct RegisterContainerInstanceError {
    pub kind: RegisterContainerInstanceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum RegisterContainerInstanceErrorKind {
    ClientError(crate::error::ClientError),
    InvalidParameterError(crate::error::InvalidParameterError),
    ServerError(crate::error::ServerError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for RegisterContainerInstanceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            RegisterContainerInstanceErrorKind::ClientError(_inner) => _inner.fmt(f),
            RegisterContainerInstanceErrorKind::InvalidParameterError(_inner) => _inner.fmt(f),
            RegisterContainerInstanceErrorKind::ServerError(_inner) => _inner.fmt(f),
            RegisterContainerInstanceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for RegisterContainerInstanceError {
    fn code(&self) -> Option<&str> {
        RegisterContainerInstanceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl RegisterContainerInstanceError {
    pub fn new(kind: RegisterContainerInstanceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: RegisterContainerInstanceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: RegisterContainerInstanceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_client_error(&self) -> bool {
        matches!(
            &self.kind,
            RegisterContainerInstanceErrorKind::ClientError(_)
        )
    }
    pub fn is_invalid_parameter_error(&self) -> bool {
        matches!(
            &self.kind,
            RegisterContainerInstanceErrorKind::InvalidParameterError(_)
        )
    }
    pub fn is_server_error(&self) -> bool {
        matches!(
            &self.kind,
            RegisterContainerInstanceErrorKind::ServerError(_)
        )
    }
}
impl std::error::Error for RegisterContainerInstanceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            RegisterContainerInstanceErrorKind::ClientError(_inner) => Some(_inner),
            RegisterContainerInstanceErrorKind::InvalidParameterError(_inner) => Some(_inner),
            RegisterContainerInstanceErrorKind::ServerError(_inner) => Some(_inner),
            RegisterContainerInstanceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct RegisterTaskDefinitionError {
    pub kind: RegisterTaskDefinitionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum RegisterTaskDefinitionErrorKind {
    ClientError(crate::error::ClientError),
    InvalidParameterError(crate::error::InvalidParameterError),
    ServerError(crate::error::ServerError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for RegisterTaskDefinitionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            RegisterTaskDefinitionErrorKind::ClientError(_inner) => _inner.fmt(f),
            RegisterTaskDefinitionErrorKind::InvalidParameterError(_inner) => _inner.fmt(f),
            RegisterTaskDefinitionErrorKind::ServerError(_inner) => _inner.fmt(f),
            RegisterTaskDefinitionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for RegisterTaskDefinitionError {
    fn code(&self) -> Option<&str> {
        RegisterTaskDefinitionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl RegisterTaskDefinitionError {
    pub fn new(kind: RegisterTaskDefinitionErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: RegisterTaskDefinitionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: RegisterTaskDefinitionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_client_error(&self) -> bool {
        matches!(&self.kind, RegisterTaskDefinitionErrorKind::ClientError(_))
    }
    pub fn is_invalid_parameter_error(&self) -> bool {
        matches!(
            &self.kind,
            RegisterTaskDefinitionErrorKind::InvalidParameterError(_)
        )
    }
    pub fn is_server_error(&self) -> bool {
        matches!(&self.kind, RegisterTaskDefinitionErrorKind::ServerError(_))
    }
}
impl std::error::Error for RegisterTaskDefinitionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            RegisterTaskDefinitionErrorKind::ClientError(_inner) => Some(_inner),
            RegisterTaskDefinitionErrorKind::InvalidParameterError(_inner) => Some(_inner),
            RegisterTaskDefinitionErrorKind::ServerError(_inner) => Some(_inner),
            RegisterTaskDefinitionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct RunTaskError {
    pub kind: RunTaskErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum RunTaskErrorKind {
    AccessDeniedError(crate::error::AccessDeniedError),
    BlockedError(crate::error::BlockedError),
    ClientError(crate::error::ClientError),
    ClusterNotFoundError(crate::error::ClusterNotFoundError),
    InvalidParameterError(crate::error::InvalidParameterError),
    PlatformTaskDefinitionIncompatibilityError(
        crate::error::PlatformTaskDefinitionIncompatibilityError,
    ),
    PlatformUnknownError(crate::error::PlatformUnknownError),
    ServerError(crate::error::ServerError),
    UnsupportedFeatureError(crate::error::UnsupportedFeatureError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for RunTaskError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            RunTaskErrorKind::AccessDeniedError(_inner) => _inner.fmt(f),
            RunTaskErrorKind::BlockedError(_inner) => _inner.fmt(f),
            RunTaskErrorKind::ClientError(_inner) => _inner.fmt(f),
            RunTaskErrorKind::ClusterNotFoundError(_inner) => _inner.fmt(f),
            RunTaskErrorKind::InvalidParameterError(_inner) => _inner.fmt(f),
            RunTaskErrorKind::PlatformTaskDefinitionIncompatibilityError(_inner) => _inner.fmt(f),
            RunTaskErrorKind::PlatformUnknownError(_inner) => _inner.fmt(f),
            RunTaskErrorKind::ServerError(_inner) => _inner.fmt(f),
            RunTaskErrorKind::UnsupportedFeatureError(_inner) => _inner.fmt(f),
            RunTaskErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for RunTaskError {
    fn code(&self) -> Option<&str> {
        RunTaskError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl RunTaskError {
    pub fn new(kind: RunTaskErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: RunTaskErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: RunTaskErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_error(&self) -> bool {
        matches!(&self.kind, RunTaskErrorKind::AccessDeniedError(_))
    }
    pub fn is_blocked_error(&self) -> bool {
        matches!(&self.kind, RunTaskErrorKind::BlockedError(_))
    }
    pub fn is_client_error(&self) -> bool {
        matches!(&self.kind, RunTaskErrorKind::ClientError(_))
    }
    pub fn is_cluster_not_found_error(&self) -> bool {
        matches!(&self.kind, RunTaskErrorKind::ClusterNotFoundError(_))
    }
    pub fn is_invalid_parameter_error(&self) -> bool {
        matches!(&self.kind, RunTaskErrorKind::InvalidParameterError(_))
    }
    pub fn is_platform_task_definition_incompatibility_error(&self) -> bool {
        matches!(
            &self.kind,
            RunTaskErrorKind::PlatformTaskDefinitionIncompatibilityError(_)
        )
    }
    pub fn is_platform_unknown_error(&self) -> bool {
        matches!(&self.kind, RunTaskErrorKind::PlatformUnknownError(_))
    }
    pub fn is_server_error(&self) -> bool {
        matches!(&self.kind, RunTaskErrorKind::ServerError(_))
    }
    pub fn is_unsupported_feature_error(&self) -> bool {
        matches!(&self.kind, RunTaskErrorKind::UnsupportedFeatureError(_))
    }
}
impl std::error::Error for RunTaskError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            RunTaskErrorKind::AccessDeniedError(_inner) => Some(_inner),
            RunTaskErrorKind::BlockedError(_inner) => Some(_inner),
            RunTaskErrorKind::ClientError(_inner) => Some(_inner),
            RunTaskErrorKind::ClusterNotFoundError(_inner) => Some(_inner),
            RunTaskErrorKind::InvalidParameterError(_inner) => Some(_inner),
            RunTaskErrorKind::PlatformTaskDefinitionIncompatibilityError(_inner) => Some(_inner),
            RunTaskErrorKind::PlatformUnknownError(_inner) => Some(_inner),
            RunTaskErrorKind::ServerError(_inner) => Some(_inner),
            RunTaskErrorKind::UnsupportedFeatureError(_inner) => Some(_inner),
            RunTaskErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct StartTaskError {
    pub kind: StartTaskErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum StartTaskErrorKind {
    ClientError(crate::error::ClientError),
    ClusterNotFoundError(crate::error::ClusterNotFoundError),
    InvalidParameterError(crate::error::InvalidParameterError),
    ServerError(crate::error::ServerError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for StartTaskError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            StartTaskErrorKind::ClientError(_inner) => _inner.fmt(f),
            StartTaskErrorKind::ClusterNotFoundError(_inner) => _inner.fmt(f),
            StartTaskErrorKind::InvalidParameterError(_inner) => _inner.fmt(f),
            StartTaskErrorKind::ServerError(_inner) => _inner.fmt(f),
            StartTaskErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for StartTaskError {
    fn code(&self) -> Option<&str> {
        StartTaskError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl StartTaskError {
    pub fn new(kind: StartTaskErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: StartTaskErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: StartTaskErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_client_error(&self) -> bool {
        matches!(&self.kind, StartTaskErrorKind::ClientError(_))
    }
    pub fn is_cluster_not_found_error(&self) -> bool {
        matches!(&self.kind, StartTaskErrorKind::ClusterNotFoundError(_))
    }
    pub fn is_invalid_parameter_error(&self) -> bool {
        matches!(&self.kind, StartTaskErrorKind::InvalidParameterError(_))
    }
    pub fn is_server_error(&self) -> bool {
        matches!(&self.kind, StartTaskErrorKind::ServerError(_))
    }
}
impl std::error::Error for StartTaskError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            StartTaskErrorKind::ClientError(_inner) => Some(_inner),
            StartTaskErrorKind::ClusterNotFoundError(_inner) => Some(_inner),
            StartTaskErrorKind::InvalidParameterError(_inner) => Some(_inner),
            StartTaskErrorKind::ServerError(_inner) => Some(_inner),
            StartTaskErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct StopTaskError {
    pub kind: StopTaskErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum StopTaskErrorKind {
    ClientError(crate::error::ClientError),
    ClusterNotFoundError(crate::error::ClusterNotFoundError),
    InvalidParameterError(crate::error::InvalidParameterError),
    ServerError(crate::error::ServerError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for StopTaskError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            StopTaskErrorKind::ClientError(_inner) => _inner.fmt(f),
            StopTaskErrorKind::ClusterNotFoundError(_inner) => _inner.fmt(f),
            StopTaskErrorKind::InvalidParameterError(_inner) => _inner.fmt(f),
            StopTaskErrorKind::ServerError(_inner) => _inner.fmt(f),
            StopTaskErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for StopTaskError {
    fn code(&self) -> Option<&str> {
        StopTaskError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl StopTaskError {
    pub fn new(kind: StopTaskErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: StopTaskErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: StopTaskErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_client_error(&self) -> bool {
        matches!(&self.kind, StopTaskErrorKind::ClientError(_))
    }
    pub fn is_cluster_not_found_error(&self) -> bool {
        matches!(&self.kind, StopTaskErrorKind::ClusterNotFoundError(_))
    }
    pub fn is_invalid_parameter_error(&self) -> bool {
        matches!(&self.kind, StopTaskErrorKind::InvalidParameterError(_))
    }
    pub fn is_server_error(&self) -> bool {
        matches!(&self.kind, StopTaskErrorKind::ServerError(_))
    }
}
impl std::error::Error for StopTaskError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            StopTaskErrorKind::ClientError(_inner) => Some(_inner),
            StopTaskErrorKind::ClusterNotFoundError(_inner) => Some(_inner),
            StopTaskErrorKind::InvalidParameterError(_inner) => Some(_inner),
            StopTaskErrorKind::ServerError(_inner) => Some(_inner),
            StopTaskErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct SubmitAttachmentStateChangesError {
    pub kind: SubmitAttachmentStateChangesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum SubmitAttachmentStateChangesErrorKind {
    AccessDeniedError(crate::error::AccessDeniedError),
    ClientError(crate::error::ClientError),
    InvalidParameterError(crate::error::InvalidParameterError),
    ServerError(crate::error::ServerError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for SubmitAttachmentStateChangesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            SubmitAttachmentStateChangesErrorKind::AccessDeniedError(_inner) => _inner.fmt(f),
            SubmitAttachmentStateChangesErrorKind::ClientError(_inner) => _inner.fmt(f),
            SubmitAttachmentStateChangesErrorKind::InvalidParameterError(_inner) => _inner.fmt(f),
            SubmitAttachmentStateChangesErrorKind::ServerError(_inner) => _inner.fmt(f),
            SubmitAttachmentStateChangesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for SubmitAttachmentStateChangesError {
    fn code(&self) -> Option<&str> {
        SubmitAttachmentStateChangesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl SubmitAttachmentStateChangesError {
    pub fn new(kind: SubmitAttachmentStateChangesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: SubmitAttachmentStateChangesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: SubmitAttachmentStateChangesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_error(&self) -> bool {
        matches!(
            &self.kind,
            SubmitAttachmentStateChangesErrorKind::AccessDeniedError(_)
        )
    }
    pub fn is_client_error(&self) -> bool {
        matches!(
            &self.kind,
            SubmitAttachmentStateChangesErrorKind::ClientError(_)
        )
    }
    pub fn is_invalid_parameter_error(&self) -> bool {
        matches!(
            &self.kind,
            SubmitAttachmentStateChangesErrorKind::InvalidParameterError(_)
        )
    }
    pub fn is_server_error(&self) -> bool {
        matches!(
            &self.kind,
            SubmitAttachmentStateChangesErrorKind::ServerError(_)
        )
    }
}
impl std::error::Error for SubmitAttachmentStateChangesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            SubmitAttachmentStateChangesErrorKind::AccessDeniedError(_inner) => Some(_inner),
            SubmitAttachmentStateChangesErrorKind::ClientError(_inner) => Some(_inner),
            SubmitAttachmentStateChangesErrorKind::InvalidParameterError(_inner) => Some(_inner),
            SubmitAttachmentStateChangesErrorKind::ServerError(_inner) => Some(_inner),
            SubmitAttachmentStateChangesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct SubmitContainerStateChangeError {
    pub kind: SubmitContainerStateChangeErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum SubmitContainerStateChangeErrorKind {
    AccessDeniedError(crate::error::AccessDeniedError),
    ClientError(crate::error::ClientError),
    ServerError(crate::error::ServerError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for SubmitContainerStateChangeError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            SubmitContainerStateChangeErrorKind::AccessDeniedError(_inner) => _inner.fmt(f),
            SubmitContainerStateChangeErrorKind::ClientError(_inner) => _inner.fmt(f),
            SubmitContainerStateChangeErrorKind::ServerError(_inner) => _inner.fmt(f),
            SubmitContainerStateChangeErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for SubmitContainerStateChangeError {
    fn code(&self) -> Option<&str> {
        SubmitContainerStateChangeError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl SubmitContainerStateChangeError {
    pub fn new(kind: SubmitContainerStateChangeErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: SubmitContainerStateChangeErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: SubmitContainerStateChangeErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_error(&self) -> bool {
        matches!(
            &self.kind,
            SubmitContainerStateChangeErrorKind::AccessDeniedError(_)
        )
    }
    pub fn is_client_error(&self) -> bool {
        matches!(
            &self.kind,
            SubmitContainerStateChangeErrorKind::ClientError(_)
        )
    }
    pub fn is_server_error(&self) -> bool {
        matches!(
            &self.kind,
            SubmitContainerStateChangeErrorKind::ServerError(_)
        )
    }
}
impl std::error::Error for SubmitContainerStateChangeError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            SubmitContainerStateChangeErrorKind::AccessDeniedError(_inner) => Some(_inner),
            SubmitContainerStateChangeErrorKind::ClientError(_inner) => Some(_inner),
            SubmitContainerStateChangeErrorKind::ServerError(_inner) => Some(_inner),
            SubmitContainerStateChangeErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct SubmitTaskStateChangeError {
    pub kind: SubmitTaskStateChangeErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum SubmitTaskStateChangeErrorKind {
    AccessDeniedError(crate::error::AccessDeniedError),
    ClientError(crate::error::ClientError),
    InvalidParameterError(crate::error::InvalidParameterError),
    ServerError(crate::error::ServerError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for SubmitTaskStateChangeError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            SubmitTaskStateChangeErrorKind::AccessDeniedError(_inner) => _inner.fmt(f),
            SubmitTaskStateChangeErrorKind::ClientError(_inner) => _inner.fmt(f),
            SubmitTaskStateChangeErrorKind::InvalidParameterError(_inner) => _inner.fmt(f),
            SubmitTaskStateChangeErrorKind::ServerError(_inner) => _inner.fmt(f),
            SubmitTaskStateChangeErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for SubmitTaskStateChangeError {
    fn code(&self) -> Option<&str> {
        SubmitTaskStateChangeError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl SubmitTaskStateChangeError {
    pub fn new(kind: SubmitTaskStateChangeErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: SubmitTaskStateChangeErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: SubmitTaskStateChangeErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_error(&self) -> bool {
        matches!(
            &self.kind,
            SubmitTaskStateChangeErrorKind::AccessDeniedError(_)
        )
    }
    pub fn is_client_error(&self) -> bool {
        matches!(&self.kind, SubmitTaskStateChangeErrorKind::ClientError(_))
    }
    pub fn is_invalid_parameter_error(&self) -> bool {
        matches!(
            &self.kind,
            SubmitTaskStateChangeErrorKind::InvalidParameterError(_)
        )
    }
    pub fn is_server_error(&self) -> bool {
        matches!(&self.kind, SubmitTaskStateChangeErrorKind::ServerError(_))
    }
}
impl std::error::Error for SubmitTaskStateChangeError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            SubmitTaskStateChangeErrorKind::AccessDeniedError(_inner) => Some(_inner),
            SubmitTaskStateChangeErrorKind::ClientError(_inner) => Some(_inner),
            SubmitTaskStateChangeErrorKind::InvalidParameterError(_inner) => Some(_inner),
            SubmitTaskStateChangeErrorKind::ServerError(_inner) => Some(_inner),
            SubmitTaskStateChangeErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct TagResourceError {
    pub kind: TagResourceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum TagResourceErrorKind {
    ClientError(crate::error::ClientError),
    ClusterNotFoundError(crate::error::ClusterNotFoundError),
    InvalidParameterError(crate::error::InvalidParameterError),
    ResourceNotFoundError(crate::error::ResourceNotFoundError),
    ServerError(crate::error::ServerError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for TagResourceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            TagResourceErrorKind::ClientError(_inner) => _inner.fmt(f),
            TagResourceErrorKind::ClusterNotFoundError(_inner) => _inner.fmt(f),
            TagResourceErrorKind::InvalidParameterError(_inner) => _inner.fmt(f),
            TagResourceErrorKind::ResourceNotFoundError(_inner) => _inner.fmt(f),
            TagResourceErrorKind::ServerError(_inner) => _inner.fmt(f),
            TagResourceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for TagResourceError {
    fn code(&self) -> Option<&str> {
        TagResourceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl TagResourceError {
    pub fn new(kind: TagResourceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: TagResourceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: TagResourceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_client_error(&self) -> bool {
        matches!(&self.kind, TagResourceErrorKind::ClientError(_))
    }
    pub fn is_cluster_not_found_error(&self) -> bool {
        matches!(&self.kind, TagResourceErrorKind::ClusterNotFoundError(_))
    }
    pub fn is_invalid_parameter_error(&self) -> bool {
        matches!(&self.kind, TagResourceErrorKind::InvalidParameterError(_))
    }
    pub fn is_resource_not_found_error(&self) -> bool {
        matches!(&self.kind, TagResourceErrorKind::ResourceNotFoundError(_))
    }
    pub fn is_server_error(&self) -> bool {
        matches!(&self.kind, TagResourceErrorKind::ServerError(_))
    }
}
impl std::error::Error for TagResourceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            TagResourceErrorKind::ClientError(_inner) => Some(_inner),
            TagResourceErrorKind::ClusterNotFoundError(_inner) => Some(_inner),
            TagResourceErrorKind::InvalidParameterError(_inner) => Some(_inner),
            TagResourceErrorKind::ResourceNotFoundError(_inner) => Some(_inner),
            TagResourceErrorKind::ServerError(_inner) => Some(_inner),
            TagResourceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UntagResourceError {
    pub kind: UntagResourceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UntagResourceErrorKind {
    ClientError(crate::error::ClientError),
    ClusterNotFoundError(crate::error::ClusterNotFoundError),
    InvalidParameterError(crate::error::InvalidParameterError),
    ResourceNotFoundError(crate::error::ResourceNotFoundError),
    ServerError(crate::error::ServerError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UntagResourceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UntagResourceErrorKind::ClientError(_inner) => _inner.fmt(f),
            UntagResourceErrorKind::ClusterNotFoundError(_inner) => _inner.fmt(f),
            UntagResourceErrorKind::InvalidParameterError(_inner) => _inner.fmt(f),
            UntagResourceErrorKind::ResourceNotFoundError(_inner) => _inner.fmt(f),
            UntagResourceErrorKind::ServerError(_inner) => _inner.fmt(f),
            UntagResourceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UntagResourceError {
    fn code(&self) -> Option<&str> {
        UntagResourceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UntagResourceError {
    pub fn new(kind: UntagResourceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UntagResourceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UntagResourceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_client_error(&self) -> bool {
        matches!(&self.kind, UntagResourceErrorKind::ClientError(_))
    }
    pub fn is_cluster_not_found_error(&self) -> bool {
        matches!(&self.kind, UntagResourceErrorKind::ClusterNotFoundError(_))
    }
    pub fn is_invalid_parameter_error(&self) -> bool {
        matches!(&self.kind, UntagResourceErrorKind::InvalidParameterError(_))
    }
    pub fn is_resource_not_found_error(&self) -> bool {
        matches!(&self.kind, UntagResourceErrorKind::ResourceNotFoundError(_))
    }
    pub fn is_server_error(&self) -> bool {
        matches!(&self.kind, UntagResourceErrorKind::ServerError(_))
    }
}
impl std::error::Error for UntagResourceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UntagResourceErrorKind::ClientError(_inner) => Some(_inner),
            UntagResourceErrorKind::ClusterNotFoundError(_inner) => Some(_inner),
            UntagResourceErrorKind::InvalidParameterError(_inner) => Some(_inner),
            UntagResourceErrorKind::ResourceNotFoundError(_inner) => Some(_inner),
            UntagResourceErrorKind::ServerError(_inner) => Some(_inner),
            UntagResourceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateCapacityProviderError {
    pub kind: UpdateCapacityProviderErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateCapacityProviderErrorKind {
    ClientError(crate::error::ClientError),
    InvalidParameterError(crate::error::InvalidParameterError),
    ServerError(crate::error::ServerError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateCapacityProviderError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateCapacityProviderErrorKind::ClientError(_inner) => _inner.fmt(f),
            UpdateCapacityProviderErrorKind::InvalidParameterError(_inner) => _inner.fmt(f),
            UpdateCapacityProviderErrorKind::ServerError(_inner) => _inner.fmt(f),
            UpdateCapacityProviderErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateCapacityProviderError {
    fn code(&self) -> Option<&str> {
        UpdateCapacityProviderError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateCapacityProviderError {
    pub fn new(kind: UpdateCapacityProviderErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateCapacityProviderErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateCapacityProviderErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_client_error(&self) -> bool {
        matches!(&self.kind, UpdateCapacityProviderErrorKind::ClientError(_))
    }
    pub fn is_invalid_parameter_error(&self) -> bool {
        matches!(
            &self.kind,
            UpdateCapacityProviderErrorKind::InvalidParameterError(_)
        )
    }
    pub fn is_server_error(&self) -> bool {
        matches!(&self.kind, UpdateCapacityProviderErrorKind::ServerError(_))
    }
}
impl std::error::Error for UpdateCapacityProviderError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateCapacityProviderErrorKind::ClientError(_inner) => Some(_inner),
            UpdateCapacityProviderErrorKind::InvalidParameterError(_inner) => Some(_inner),
            UpdateCapacityProviderErrorKind::ServerError(_inner) => Some(_inner),
            UpdateCapacityProviderErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateClusterError {
    pub kind: UpdateClusterErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateClusterErrorKind {
    ClientError(crate::error::ClientError),
    ClusterNotFoundError(crate::error::ClusterNotFoundError),
    InvalidParameterError(crate::error::InvalidParameterError),
    ServerError(crate::error::ServerError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateClusterError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateClusterErrorKind::ClientError(_inner) => _inner.fmt(f),
            UpdateClusterErrorKind::ClusterNotFoundError(_inner) => _inner.fmt(f),
            UpdateClusterErrorKind::InvalidParameterError(_inner) => _inner.fmt(f),
            UpdateClusterErrorKind::ServerError(_inner) => _inner.fmt(f),
            UpdateClusterErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateClusterError {
    fn code(&self) -> Option<&str> {
        UpdateClusterError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateClusterError {
    pub fn new(kind: UpdateClusterErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateClusterErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateClusterErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_client_error(&self) -> bool {
        matches!(&self.kind, UpdateClusterErrorKind::ClientError(_))
    }
    pub fn is_cluster_not_found_error(&self) -> bool {
        matches!(&self.kind, UpdateClusterErrorKind::ClusterNotFoundError(_))
    }
    pub fn is_invalid_parameter_error(&self) -> bool {
        matches!(&self.kind, UpdateClusterErrorKind::InvalidParameterError(_))
    }
    pub fn is_server_error(&self) -> bool {
        matches!(&self.kind, UpdateClusterErrorKind::ServerError(_))
    }
}
impl std::error::Error for UpdateClusterError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateClusterErrorKind::ClientError(_inner) => Some(_inner),
            UpdateClusterErrorKind::ClusterNotFoundError(_inner) => Some(_inner),
            UpdateClusterErrorKind::InvalidParameterError(_inner) => Some(_inner),
            UpdateClusterErrorKind::ServerError(_inner) => Some(_inner),
            UpdateClusterErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateClusterSettingsError {
    pub kind: UpdateClusterSettingsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateClusterSettingsErrorKind {
    ClientError(crate::error::ClientError),
    ClusterNotFoundError(crate::error::ClusterNotFoundError),
    InvalidParameterError(crate::error::InvalidParameterError),
    ServerError(crate::error::ServerError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateClusterSettingsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateClusterSettingsErrorKind::ClientError(_inner) => _inner.fmt(f),
            UpdateClusterSettingsErrorKind::ClusterNotFoundError(_inner) => _inner.fmt(f),
            UpdateClusterSettingsErrorKind::InvalidParameterError(_inner) => _inner.fmt(f),
            UpdateClusterSettingsErrorKind::ServerError(_inner) => _inner.fmt(f),
            UpdateClusterSettingsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateClusterSettingsError {
    fn code(&self) -> Option<&str> {
        UpdateClusterSettingsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateClusterSettingsError {
    pub fn new(kind: UpdateClusterSettingsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateClusterSettingsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateClusterSettingsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_client_error(&self) -> bool {
        matches!(&self.kind, UpdateClusterSettingsErrorKind::ClientError(_))
    }
    pub fn is_cluster_not_found_error(&self) -> bool {
        matches!(
            &self.kind,
            UpdateClusterSettingsErrorKind::ClusterNotFoundError(_)
        )
    }
    pub fn is_invalid_parameter_error(&self) -> bool {
        matches!(
            &self.kind,
            UpdateClusterSettingsErrorKind::InvalidParameterError(_)
        )
    }
    pub fn is_server_error(&self) -> bool {
        matches!(&self.kind, UpdateClusterSettingsErrorKind::ServerError(_))
    }
}
impl std::error::Error for UpdateClusterSettingsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateClusterSettingsErrorKind::ClientError(_inner) => Some(_inner),
            UpdateClusterSettingsErrorKind::ClusterNotFoundError(_inner) => Some(_inner),
            UpdateClusterSettingsErrorKind::InvalidParameterError(_inner) => Some(_inner),
            UpdateClusterSettingsErrorKind::ServerError(_inner) => Some(_inner),
            UpdateClusterSettingsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateContainerAgentError {
    pub kind: UpdateContainerAgentErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateContainerAgentErrorKind {
    ClientError(crate::error::ClientError),
    ClusterNotFoundError(crate::error::ClusterNotFoundError),
    InvalidParameterError(crate::error::InvalidParameterError),
    MissingVersionError(crate::error::MissingVersionError),
    NoUpdateAvailableError(crate::error::NoUpdateAvailableError),
    ServerError(crate::error::ServerError),
    UpdateInProgressError(crate::error::UpdateInProgressError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateContainerAgentError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateContainerAgentErrorKind::ClientError(_inner) => _inner.fmt(f),
            UpdateContainerAgentErrorKind::ClusterNotFoundError(_inner) => _inner.fmt(f),
            UpdateContainerAgentErrorKind::InvalidParameterError(_inner) => _inner.fmt(f),
            UpdateContainerAgentErrorKind::MissingVersionError(_inner) => _inner.fmt(f),
            UpdateContainerAgentErrorKind::NoUpdateAvailableError(_inner) => _inner.fmt(f),
            UpdateContainerAgentErrorKind::ServerError(_inner) => _inner.fmt(f),
            UpdateContainerAgentErrorKind::UpdateInProgressError(_inner) => _inner.fmt(f),
            UpdateContainerAgentErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateContainerAgentError {
    fn code(&self) -> Option<&str> {
        UpdateContainerAgentError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateContainerAgentError {
    pub fn new(kind: UpdateContainerAgentErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateContainerAgentErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateContainerAgentErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_client_error(&self) -> bool {
        matches!(&self.kind, UpdateContainerAgentErrorKind::ClientError(_))
    }
    pub fn is_cluster_not_found_error(&self) -> bool {
        matches!(
            &self.kind,
            UpdateContainerAgentErrorKind::ClusterNotFoundError(_)
        )
    }
    pub fn is_invalid_parameter_error(&self) -> bool {
        matches!(
            &self.kind,
            UpdateContainerAgentErrorKind::InvalidParameterError(_)
        )
    }
    pub fn is_missing_version_error(&self) -> bool {
        matches!(
            &self.kind,
            UpdateContainerAgentErrorKind::MissingVersionError(_)
        )
    }
    pub fn is_no_update_available_error(&self) -> bool {
        matches!(
            &self.kind,
            UpdateContainerAgentErrorKind::NoUpdateAvailableError(_)
        )
    }
    pub fn is_server_error(&self) -> bool {
        matches!(&self.kind, UpdateContainerAgentErrorKind::ServerError(_))
    }
    pub fn is_update_in_progress_error(&self) -> bool {
        matches!(
            &self.kind,
            UpdateContainerAgentErrorKind::UpdateInProgressError(_)
        )
    }
}
impl std::error::Error for UpdateContainerAgentError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateContainerAgentErrorKind::ClientError(_inner) => Some(_inner),
            UpdateContainerAgentErrorKind::ClusterNotFoundError(_inner) => Some(_inner),
            UpdateContainerAgentErrorKind::InvalidParameterError(_inner) => Some(_inner),
            UpdateContainerAgentErrorKind::MissingVersionError(_inner) => Some(_inner),
            UpdateContainerAgentErrorKind::NoUpdateAvailableError(_inner) => Some(_inner),
            UpdateContainerAgentErrorKind::ServerError(_inner) => Some(_inner),
            UpdateContainerAgentErrorKind::UpdateInProgressError(_inner) => Some(_inner),
            UpdateContainerAgentErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateContainerInstancesStateError {
    pub kind: UpdateContainerInstancesStateErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateContainerInstancesStateErrorKind {
    ClientError(crate::error::ClientError),
    ClusterNotFoundError(crate::error::ClusterNotFoundError),
    InvalidParameterError(crate::error::InvalidParameterError),
    ServerError(crate::error::ServerError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateContainerInstancesStateError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateContainerInstancesStateErrorKind::ClientError(_inner) => _inner.fmt(f),
            UpdateContainerInstancesStateErrorKind::ClusterNotFoundError(_inner) => _inner.fmt(f),
            UpdateContainerInstancesStateErrorKind::InvalidParameterError(_inner) => _inner.fmt(f),
            UpdateContainerInstancesStateErrorKind::ServerError(_inner) => _inner.fmt(f),
            UpdateContainerInstancesStateErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateContainerInstancesStateError {
    fn code(&self) -> Option<&str> {
        UpdateContainerInstancesStateError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateContainerInstancesStateError {
    pub fn new(kind: UpdateContainerInstancesStateErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateContainerInstancesStateErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateContainerInstancesStateErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_client_error(&self) -> bool {
        matches!(
            &self.kind,
            UpdateContainerInstancesStateErrorKind::ClientError(_)
        )
    }
    pub fn is_cluster_not_found_error(&self) -> bool {
        matches!(
            &self.kind,
            UpdateContainerInstancesStateErrorKind::ClusterNotFoundError(_)
        )
    }
    pub fn is_invalid_parameter_error(&self) -> bool {
        matches!(
            &self.kind,
            UpdateContainerInstancesStateErrorKind::InvalidParameterError(_)
        )
    }
    pub fn is_server_error(&self) -> bool {
        matches!(
            &self.kind,
            UpdateContainerInstancesStateErrorKind::ServerError(_)
        )
    }
}
impl std::error::Error for UpdateContainerInstancesStateError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateContainerInstancesStateErrorKind::ClientError(_inner) => Some(_inner),
            UpdateContainerInstancesStateErrorKind::ClusterNotFoundError(_inner) => Some(_inner),
            UpdateContainerInstancesStateErrorKind::InvalidParameterError(_inner) => Some(_inner),
            UpdateContainerInstancesStateErrorKind::ServerError(_inner) => Some(_inner),
            UpdateContainerInstancesStateErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateServiceError {
    pub kind: UpdateServiceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateServiceErrorKind {
    AccessDeniedError(crate::error::AccessDeniedError),
    ClientError(crate::error::ClientError),
    ClusterNotFoundError(crate::error::ClusterNotFoundError),
    InvalidParameterError(crate::error::InvalidParameterError),
    PlatformTaskDefinitionIncompatibilityError(
        crate::error::PlatformTaskDefinitionIncompatibilityError,
    ),
    PlatformUnknownError(crate::error::PlatformUnknownError),
    ServerError(crate::error::ServerError),
    ServiceNotActiveError(crate::error::ServiceNotActiveError),
    ServiceNotFoundError(crate::error::ServiceNotFoundError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateServiceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateServiceErrorKind::AccessDeniedError(_inner) => _inner.fmt(f),
            UpdateServiceErrorKind::ClientError(_inner) => _inner.fmt(f),
            UpdateServiceErrorKind::ClusterNotFoundError(_inner) => _inner.fmt(f),
            UpdateServiceErrorKind::InvalidParameterError(_inner) => _inner.fmt(f),
            UpdateServiceErrorKind::PlatformTaskDefinitionIncompatibilityError(_inner) => {
                _inner.fmt(f)
            }
            UpdateServiceErrorKind::PlatformUnknownError(_inner) => _inner.fmt(f),
            UpdateServiceErrorKind::ServerError(_inner) => _inner.fmt(f),
            UpdateServiceErrorKind::ServiceNotActiveError(_inner) => _inner.fmt(f),
            UpdateServiceErrorKind::ServiceNotFoundError(_inner) => _inner.fmt(f),
            UpdateServiceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateServiceError {
    fn code(&self) -> Option<&str> {
        UpdateServiceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateServiceError {
    pub fn new(kind: UpdateServiceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateServiceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateServiceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_error(&self) -> bool {
        matches!(&self.kind, UpdateServiceErrorKind::AccessDeniedError(_))
    }
    pub fn is_client_error(&self) -> bool {
        matches!(&self.kind, UpdateServiceErrorKind::ClientError(_))
    }
    pub fn is_cluster_not_found_error(&self) -> bool {
        matches!(&self.kind, UpdateServiceErrorKind::ClusterNotFoundError(_))
    }
    pub fn is_invalid_parameter_error(&self) -> bool {
        matches!(&self.kind, UpdateServiceErrorKind::InvalidParameterError(_))
    }
    pub fn is_platform_task_definition_incompatibility_error(&self) -> bool {
        matches!(
            &self.kind,
            UpdateServiceErrorKind::PlatformTaskDefinitionIncompatibilityError(_)
        )
    }
    pub fn is_platform_unknown_error(&self) -> bool {
        matches!(&self.kind, UpdateServiceErrorKind::PlatformUnknownError(_))
    }
    pub fn is_server_error(&self) -> bool {
        matches!(&self.kind, UpdateServiceErrorKind::ServerError(_))
    }
    pub fn is_service_not_active_error(&self) -> bool {
        matches!(&self.kind, UpdateServiceErrorKind::ServiceNotActiveError(_))
    }
    pub fn is_service_not_found_error(&self) -> bool {
        matches!(&self.kind, UpdateServiceErrorKind::ServiceNotFoundError(_))
    }
}
impl std::error::Error for UpdateServiceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateServiceErrorKind::AccessDeniedError(_inner) => Some(_inner),
            UpdateServiceErrorKind::ClientError(_inner) => Some(_inner),
            UpdateServiceErrorKind::ClusterNotFoundError(_inner) => Some(_inner),
            UpdateServiceErrorKind::InvalidParameterError(_inner) => Some(_inner),
            UpdateServiceErrorKind::PlatformTaskDefinitionIncompatibilityError(_inner) => {
                Some(_inner)
            }
            UpdateServiceErrorKind::PlatformUnknownError(_inner) => Some(_inner),
            UpdateServiceErrorKind::ServerError(_inner) => Some(_inner),
            UpdateServiceErrorKind::ServiceNotActiveError(_inner) => Some(_inner),
            UpdateServiceErrorKind::ServiceNotFoundError(_inner) => Some(_inner),
            UpdateServiceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateServicePrimaryTaskSetError {
    pub kind: UpdateServicePrimaryTaskSetErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateServicePrimaryTaskSetErrorKind {
    AccessDeniedError(crate::error::AccessDeniedError),
    ClientError(crate::error::ClientError),
    ClusterNotFoundError(crate::error::ClusterNotFoundError),
    InvalidParameterError(crate::error::InvalidParameterError),
    ServerError(crate::error::ServerError),
    ServiceNotActiveError(crate::error::ServiceNotActiveError),
    ServiceNotFoundError(crate::error::ServiceNotFoundError),
    TaskSetNotFoundError(crate::error::TaskSetNotFoundError),
    UnsupportedFeatureError(crate::error::UnsupportedFeatureError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateServicePrimaryTaskSetError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateServicePrimaryTaskSetErrorKind::AccessDeniedError(_inner) => _inner.fmt(f),
            UpdateServicePrimaryTaskSetErrorKind::ClientError(_inner) => _inner.fmt(f),
            UpdateServicePrimaryTaskSetErrorKind::ClusterNotFoundError(_inner) => _inner.fmt(f),
            UpdateServicePrimaryTaskSetErrorKind::InvalidParameterError(_inner) => _inner.fmt(f),
            UpdateServicePrimaryTaskSetErrorKind::ServerError(_inner) => _inner.fmt(f),
            UpdateServicePrimaryTaskSetErrorKind::ServiceNotActiveError(_inner) => _inner.fmt(f),
            UpdateServicePrimaryTaskSetErrorKind::ServiceNotFoundError(_inner) => _inner.fmt(f),
            UpdateServicePrimaryTaskSetErrorKind::TaskSetNotFoundError(_inner) => _inner.fmt(f),
            UpdateServicePrimaryTaskSetErrorKind::UnsupportedFeatureError(_inner) => _inner.fmt(f),
            UpdateServicePrimaryTaskSetErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateServicePrimaryTaskSetError {
    fn code(&self) -> Option<&str> {
        UpdateServicePrimaryTaskSetError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateServicePrimaryTaskSetError {
    pub fn new(kind: UpdateServicePrimaryTaskSetErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateServicePrimaryTaskSetErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateServicePrimaryTaskSetErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_error(&self) -> bool {
        matches!(
            &self.kind,
            UpdateServicePrimaryTaskSetErrorKind::AccessDeniedError(_)
        )
    }
    pub fn is_client_error(&self) -> bool {
        matches!(
            &self.kind,
            UpdateServicePrimaryTaskSetErrorKind::ClientError(_)
        )
    }
    pub fn is_cluster_not_found_error(&self) -> bool {
        matches!(
            &self.kind,
            UpdateServicePrimaryTaskSetErrorKind::ClusterNotFoundError(_)
        )
    }
    pub fn is_invalid_parameter_error(&self) -> bool {
        matches!(
            &self.kind,
            UpdateServicePrimaryTaskSetErrorKind::InvalidParameterError(_)
        )
    }
    pub fn is_server_error(&self) -> bool {
        matches!(
            &self.kind,
            UpdateServicePrimaryTaskSetErrorKind::ServerError(_)
        )
    }
    pub fn is_service_not_active_error(&self) -> bool {
        matches!(
            &self.kind,
            UpdateServicePrimaryTaskSetErrorKind::ServiceNotActiveError(_)
        )
    }
    pub fn is_service_not_found_error(&self) -> bool {
        matches!(
            &self.kind,
            UpdateServicePrimaryTaskSetErrorKind::ServiceNotFoundError(_)
        )
    }
    pub fn is_task_set_not_found_error(&self) -> bool {
        matches!(
            &self.kind,
            UpdateServicePrimaryTaskSetErrorKind::TaskSetNotFoundError(_)
        )
    }
    pub fn is_unsupported_feature_error(&self) -> bool {
        matches!(
            &self.kind,
            UpdateServicePrimaryTaskSetErrorKind::UnsupportedFeatureError(_)
        )
    }
}
impl std::error::Error for UpdateServicePrimaryTaskSetError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateServicePrimaryTaskSetErrorKind::AccessDeniedError(_inner) => Some(_inner),
            UpdateServicePrimaryTaskSetErrorKind::ClientError(_inner) => Some(_inner),
            UpdateServicePrimaryTaskSetErrorKind::ClusterNotFoundError(_inner) => Some(_inner),
            UpdateServicePrimaryTaskSetErrorKind::InvalidParameterError(_inner) => Some(_inner),
            UpdateServicePrimaryTaskSetErrorKind::ServerError(_inner) => Some(_inner),
            UpdateServicePrimaryTaskSetErrorKind::ServiceNotActiveError(_inner) => Some(_inner),
            UpdateServicePrimaryTaskSetErrorKind::ServiceNotFoundError(_inner) => Some(_inner),
            UpdateServicePrimaryTaskSetErrorKind::TaskSetNotFoundError(_inner) => Some(_inner),
            UpdateServicePrimaryTaskSetErrorKind::UnsupportedFeatureError(_inner) => Some(_inner),
            UpdateServicePrimaryTaskSetErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateTaskSetError {
    pub kind: UpdateTaskSetErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateTaskSetErrorKind {
    AccessDeniedError(crate::error::AccessDeniedError),
    ClientError(crate::error::ClientError),
    ClusterNotFoundError(crate::error::ClusterNotFoundError),
    InvalidParameterError(crate::error::InvalidParameterError),
    ServerError(crate::error::ServerError),
    ServiceNotActiveError(crate::error::ServiceNotActiveError),
    ServiceNotFoundError(crate::error::ServiceNotFoundError),
    TaskSetNotFoundError(crate::error::TaskSetNotFoundError),
    UnsupportedFeatureError(crate::error::UnsupportedFeatureError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateTaskSetError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateTaskSetErrorKind::AccessDeniedError(_inner) => _inner.fmt(f),
            UpdateTaskSetErrorKind::ClientError(_inner) => _inner.fmt(f),
            UpdateTaskSetErrorKind::ClusterNotFoundError(_inner) => _inner.fmt(f),
            UpdateTaskSetErrorKind::InvalidParameterError(_inner) => _inner.fmt(f),
            UpdateTaskSetErrorKind::ServerError(_inner) => _inner.fmt(f),
            UpdateTaskSetErrorKind::ServiceNotActiveError(_inner) => _inner.fmt(f),
            UpdateTaskSetErrorKind::ServiceNotFoundError(_inner) => _inner.fmt(f),
            UpdateTaskSetErrorKind::TaskSetNotFoundError(_inner) => _inner.fmt(f),
            UpdateTaskSetErrorKind::UnsupportedFeatureError(_inner) => _inner.fmt(f),
            UpdateTaskSetErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateTaskSetError {
    fn code(&self) -> Option<&str> {
        UpdateTaskSetError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateTaskSetError {
    pub fn new(kind: UpdateTaskSetErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateTaskSetErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateTaskSetErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_error(&self) -> bool {
        matches!(&self.kind, UpdateTaskSetErrorKind::AccessDeniedError(_))
    }
    pub fn is_client_error(&self) -> bool {
        matches!(&self.kind, UpdateTaskSetErrorKind::ClientError(_))
    }
    pub fn is_cluster_not_found_error(&self) -> bool {
        matches!(&self.kind, UpdateTaskSetErrorKind::ClusterNotFoundError(_))
    }
    pub fn is_invalid_parameter_error(&self) -> bool {
        matches!(&self.kind, UpdateTaskSetErrorKind::InvalidParameterError(_))
    }
    pub fn is_server_error(&self) -> bool {
        matches!(&self.kind, UpdateTaskSetErrorKind::ServerError(_))
    }
    pub fn is_service_not_active_error(&self) -> bool {
        matches!(&self.kind, UpdateTaskSetErrorKind::ServiceNotActiveError(_))
    }
    pub fn is_service_not_found_error(&self) -> bool {
        matches!(&self.kind, UpdateTaskSetErrorKind::ServiceNotFoundError(_))
    }
    pub fn is_task_set_not_found_error(&self) -> bool {
        matches!(&self.kind, UpdateTaskSetErrorKind::TaskSetNotFoundError(_))
    }
    pub fn is_unsupported_feature_error(&self) -> bool {
        matches!(
            &self.kind,
            UpdateTaskSetErrorKind::UnsupportedFeatureError(_)
        )
    }
}
impl std::error::Error for UpdateTaskSetError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateTaskSetErrorKind::AccessDeniedError(_inner) => Some(_inner),
            UpdateTaskSetErrorKind::ClientError(_inner) => Some(_inner),
            UpdateTaskSetErrorKind::ClusterNotFoundError(_inner) => Some(_inner),
            UpdateTaskSetErrorKind::InvalidParameterError(_inner) => Some(_inner),
            UpdateTaskSetErrorKind::ServerError(_inner) => Some(_inner),
            UpdateTaskSetErrorKind::ServiceNotActiveError(_inner) => Some(_inner),
            UpdateTaskSetErrorKind::ServiceNotFoundError(_inner) => Some(_inner),
            UpdateTaskSetErrorKind::TaskSetNotFoundError(_inner) => Some(_inner),
            UpdateTaskSetErrorKind::UnsupportedFeatureError(_inner) => Some(_inner),
            UpdateTaskSetErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// <p>The specified task is not supported in this Region.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct UnsupportedFeatureError {
    #[serde(rename = "message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for UnsupportedFeatureError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UnsupportedFeatureError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl UnsupportedFeatureError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for UnsupportedFeatureError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "UnsupportedFeatureError [UnsupportedFeatureException]")?;
        if let Some(inner_1) = &self.message {
            write!(f, ": {}", inner_1)?;
        }
        Ok(())
    }
}
impl std::error::Error for UnsupportedFeatureError {}
/// See [`UnsupportedFeatureError`](crate::error::UnsupportedFeatureError)
pub mod unsupported_feature_error {
    /// A builder for [`UnsupportedFeatureError`](crate::error::UnsupportedFeatureError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`UnsupportedFeatureError`](crate::error::UnsupportedFeatureError)
        pub fn build(self) -> crate::error::UnsupportedFeatureError {
            crate::error::UnsupportedFeatureError {
                message: self.message,
            }
        }
    }
}
impl UnsupportedFeatureError {
    /// Creates a new builder-style object to manufacture [`UnsupportedFeatureError`](crate::error::UnsupportedFeatureError)
    pub fn builder() -> crate::error::unsupported_feature_error::Builder {
        crate::error::unsupported_feature_error::Builder::default()
    }
}

/// <p>The specified task set could not be found. You can view your available task sets with
/// <a>DescribeTaskSets</a>. Task sets are specific to each cluster, service
/// and Region.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct TaskSetNotFoundError {
    #[serde(rename = "message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for TaskSetNotFoundError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TaskSetNotFoundError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl TaskSetNotFoundError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for TaskSetNotFoundError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "TaskSetNotFoundError [TaskSetNotFoundException]")?;
        if let Some(inner_2) = &self.message {
            write!(f, ": {}", inner_2)?;
        }
        Ok(())
    }
}
impl std::error::Error for TaskSetNotFoundError {}
/// See [`TaskSetNotFoundError`](crate::error::TaskSetNotFoundError)
pub mod task_set_not_found_error {
    /// A builder for [`TaskSetNotFoundError`](crate::error::TaskSetNotFoundError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`TaskSetNotFoundError`](crate::error::TaskSetNotFoundError)
        pub fn build(self) -> crate::error::TaskSetNotFoundError {
            crate::error::TaskSetNotFoundError {
                message: self.message,
            }
        }
    }
}
impl TaskSetNotFoundError {
    /// Creates a new builder-style object to manufacture [`TaskSetNotFoundError`](crate::error::TaskSetNotFoundError)
    pub fn builder() -> crate::error::task_set_not_found_error::Builder {
        crate::error::task_set_not_found_error::Builder::default()
    }
}

/// <p>The specified service could not be found. You can view your available services with
/// <a>ListServices</a>. Amazon ECS services are cluster-specific and
/// Region-specific.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct ServiceNotFoundError {
    #[serde(rename = "message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ServiceNotFoundError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ServiceNotFoundError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ServiceNotFoundError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ServiceNotFoundError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ServiceNotFoundError [ServiceNotFoundException]")?;
        if let Some(inner_3) = &self.message {
            write!(f, ": {}", inner_3)?;
        }
        Ok(())
    }
}
impl std::error::Error for ServiceNotFoundError {}
/// See [`ServiceNotFoundError`](crate::error::ServiceNotFoundError)
pub mod service_not_found_error {
    /// A builder for [`ServiceNotFoundError`](crate::error::ServiceNotFoundError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ServiceNotFoundError`](crate::error::ServiceNotFoundError)
        pub fn build(self) -> crate::error::ServiceNotFoundError {
            crate::error::ServiceNotFoundError {
                message: self.message,
            }
        }
    }
}
impl ServiceNotFoundError {
    /// Creates a new builder-style object to manufacture [`ServiceNotFoundError`](crate::error::ServiceNotFoundError)
    pub fn builder() -> crate::error::service_not_found_error::Builder {
        crate::error::service_not_found_error::Builder::default()
    }
}

/// <p>The specified service is not active. You can't update a service that is inactive. If
/// you have previously deleted a service, you can re-create it with <a>CreateService</a>.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct ServiceNotActiveError {
    #[serde(rename = "message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ServiceNotActiveError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ServiceNotActiveError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ServiceNotActiveError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ServiceNotActiveError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ServiceNotActiveError [ServiceNotActiveException]")?;
        if let Some(inner_4) = &self.message {
            write!(f, ": {}", inner_4)?;
        }
        Ok(())
    }
}
impl std::error::Error for ServiceNotActiveError {}
/// See [`ServiceNotActiveError`](crate::error::ServiceNotActiveError)
pub mod service_not_active_error {
    /// A builder for [`ServiceNotActiveError`](crate::error::ServiceNotActiveError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ServiceNotActiveError`](crate::error::ServiceNotActiveError)
        pub fn build(self) -> crate::error::ServiceNotActiveError {
            crate::error::ServiceNotActiveError {
                message: self.message,
            }
        }
    }
}
impl ServiceNotActiveError {
    /// Creates a new builder-style object to manufacture [`ServiceNotActiveError`](crate::error::ServiceNotActiveError)
    pub fn builder() -> crate::error::service_not_active_error::Builder {
        crate::error::service_not_active_error::Builder::default()
    }
}

/// <p>These errors are usually caused by a server issue.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct ServerError {
    #[serde(rename = "message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ServerError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ServerError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ServerError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ServerError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ServerError [ServerException]")?;
        if let Some(inner_5) = &self.message {
            write!(f, ": {}", inner_5)?;
        }
        Ok(())
    }
}
impl std::error::Error for ServerError {}
/// See [`ServerError`](crate::error::ServerError)
pub mod server_error {
    /// A builder for [`ServerError`](crate::error::ServerError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ServerError`](crate::error::ServerError)
        pub fn build(self) -> crate::error::ServerError {
            crate::error::ServerError {
                message: self.message,
            }
        }
    }
}
impl ServerError {
    /// Creates a new builder-style object to manufacture [`ServerError`](crate::error::ServerError)
    pub fn builder() -> crate::error::server_error::Builder {
        crate::error::server_error::Builder::default()
    }
}

/// <p>The specified parameter is invalid. Review the available parameters for the API
/// request.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidParameterError {
    #[serde(rename = "message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidParameterError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidParameterError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidParameterError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidParameterError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidParameterError [InvalidParameterException]")?;
        if let Some(inner_6) = &self.message {
            write!(f, ": {}", inner_6)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidParameterError {}
/// See [`InvalidParameterError`](crate::error::InvalidParameterError)
pub mod invalid_parameter_error {
    /// A builder for [`InvalidParameterError`](crate::error::InvalidParameterError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidParameterError`](crate::error::InvalidParameterError)
        pub fn build(self) -> crate::error::InvalidParameterError {
            crate::error::InvalidParameterError {
                message: self.message,
            }
        }
    }
}
impl InvalidParameterError {
    /// Creates a new builder-style object to manufacture [`InvalidParameterError`](crate::error::InvalidParameterError)
    pub fn builder() -> crate::error::invalid_parameter_error::Builder {
        crate::error::invalid_parameter_error::Builder::default()
    }
}

/// <p>The specified cluster could not be found. You can view your available clusters with
/// <a>ListClusters</a>. Amazon ECS clusters are Region-specific.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct ClusterNotFoundError {
    #[serde(rename = "message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ClusterNotFoundError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ClusterNotFoundError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ClusterNotFoundError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ClusterNotFoundError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ClusterNotFoundError [ClusterNotFoundException]")?;
        if let Some(inner_7) = &self.message {
            write!(f, ": {}", inner_7)?;
        }
        Ok(())
    }
}
impl std::error::Error for ClusterNotFoundError {}
/// See [`ClusterNotFoundError`](crate::error::ClusterNotFoundError)
pub mod cluster_not_found_error {
    /// A builder for [`ClusterNotFoundError`](crate::error::ClusterNotFoundError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ClusterNotFoundError`](crate::error::ClusterNotFoundError)
        pub fn build(self) -> crate::error::ClusterNotFoundError {
            crate::error::ClusterNotFoundError {
                message: self.message,
            }
        }
    }
}
impl ClusterNotFoundError {
    /// Creates a new builder-style object to manufacture [`ClusterNotFoundError`](crate::error::ClusterNotFoundError)
    pub fn builder() -> crate::error::cluster_not_found_error::Builder {
        crate::error::cluster_not_found_error::Builder::default()
    }
}

/// <p>These errors are usually caused by a client action, such as using an action or
/// resource on behalf of a user that doesn't have permissions to use the action or
/// resource, or specifying an identifier that is not valid.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct ClientError {
    #[serde(rename = "message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ClientError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ClientError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ClientError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ClientError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ClientError [ClientException]")?;
        if let Some(inner_8) = &self.message {
            write!(f, ": {}", inner_8)?;
        }
        Ok(())
    }
}
impl std::error::Error for ClientError {}
/// See [`ClientError`](crate::error::ClientError)
pub mod client_error {
    /// A builder for [`ClientError`](crate::error::ClientError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ClientError`](crate::error::ClientError)
        pub fn build(self) -> crate::error::ClientError {
            crate::error::ClientError {
                message: self.message,
            }
        }
    }
}
impl ClientError {
    /// Creates a new builder-style object to manufacture [`ClientError`](crate::error::ClientError)
    pub fn builder() -> crate::error::client_error::Builder {
        crate::error::client_error::Builder::default()
    }
}

/// <p>You do not have authorization to perform the requested action.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct AccessDeniedError {
    #[serde(rename = "message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for AccessDeniedError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AccessDeniedError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl AccessDeniedError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for AccessDeniedError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "AccessDeniedError [AccessDeniedException]")?;
        if let Some(inner_9) = &self.message {
            write!(f, ": {}", inner_9)?;
        }
        Ok(())
    }
}
impl std::error::Error for AccessDeniedError {}
/// See [`AccessDeniedError`](crate::error::AccessDeniedError)
pub mod access_denied_error {
    /// A builder for [`AccessDeniedError`](crate::error::AccessDeniedError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`AccessDeniedError`](crate::error::AccessDeniedError)
        pub fn build(self) -> crate::error::AccessDeniedError {
            crate::error::AccessDeniedError {
                message: self.message,
            }
        }
    }
}
impl AccessDeniedError {
    /// Creates a new builder-style object to manufacture [`AccessDeniedError`](crate::error::AccessDeniedError)
    pub fn builder() -> crate::error::access_denied_error::Builder {
        crate::error::access_denied_error::Builder::default()
    }
}

/// <p>The specified platform version does not exist.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct PlatformUnknownError {
    #[serde(rename = "message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for PlatformUnknownError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PlatformUnknownError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl PlatformUnknownError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for PlatformUnknownError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "PlatformUnknownError [PlatformUnknownException]")?;
        if let Some(inner_10) = &self.message {
            write!(f, ": {}", inner_10)?;
        }
        Ok(())
    }
}
impl std::error::Error for PlatformUnknownError {}
/// See [`PlatformUnknownError`](crate::error::PlatformUnknownError)
pub mod platform_unknown_error {
    /// A builder for [`PlatformUnknownError`](crate::error::PlatformUnknownError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`PlatformUnknownError`](crate::error::PlatformUnknownError)
        pub fn build(self) -> crate::error::PlatformUnknownError {
            crate::error::PlatformUnknownError {
                message: self.message,
            }
        }
    }
}
impl PlatformUnknownError {
    /// Creates a new builder-style object to manufacture [`PlatformUnknownError`](crate::error::PlatformUnknownError)
    pub fn builder() -> crate::error::platform_unknown_error::Builder {
        crate::error::platform_unknown_error::Builder::default()
    }
}

/// <p>The specified platform version does not satisfy the task definition's required
/// capabilities.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct PlatformTaskDefinitionIncompatibilityError {
    #[serde(rename = "message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for PlatformTaskDefinitionIncompatibilityError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PlatformTaskDefinitionIncompatibilityError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl PlatformTaskDefinitionIncompatibilityError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for PlatformTaskDefinitionIncompatibilityError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "PlatformTaskDefinitionIncompatibilityError [PlatformTaskDefinitionIncompatibilityException]")?;
        if let Some(inner_11) = &self.message {
            write!(f, ": {}", inner_11)?;
        }
        Ok(())
    }
}
impl std::error::Error for PlatformTaskDefinitionIncompatibilityError {}
/// See [`PlatformTaskDefinitionIncompatibilityError`](crate::error::PlatformTaskDefinitionIncompatibilityError)
pub mod platform_task_definition_incompatibility_error {
    /// A builder for [`PlatformTaskDefinitionIncompatibilityError`](crate::error::PlatformTaskDefinitionIncompatibilityError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`PlatformTaskDefinitionIncompatibilityError`](crate::error::PlatformTaskDefinitionIncompatibilityError)
        pub fn build(self) -> crate::error::PlatformTaskDefinitionIncompatibilityError {
            crate::error::PlatformTaskDefinitionIncompatibilityError {
                message: self.message,
            }
        }
    }
}
impl PlatformTaskDefinitionIncompatibilityError {
    /// Creates a new builder-style object to manufacture [`PlatformTaskDefinitionIncompatibilityError`](crate::error::PlatformTaskDefinitionIncompatibilityError)
    pub fn builder() -> crate::error::platform_task_definition_incompatibility_error::Builder {
        crate::error::platform_task_definition_incompatibility_error::Builder::default()
    }
}

/// <p>There is already a current Amazon ECS container agent update in progress on the specified
/// container instance. If the container agent becomes disconnected while it is in a
/// transitional stage, such as <code>PENDING</code> or <code>STAGING</code>, the update
/// process can get stuck in that state. However, when the agent reconnects, it resumes
/// where it stopped previously.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateInProgressError {
    #[serde(rename = "message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for UpdateInProgressError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateInProgressError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl UpdateInProgressError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for UpdateInProgressError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "UpdateInProgressError [UpdateInProgressException]")?;
        if let Some(inner_12) = &self.message {
            write!(f, ": {}", inner_12)?;
        }
        Ok(())
    }
}
impl std::error::Error for UpdateInProgressError {}
/// See [`UpdateInProgressError`](crate::error::UpdateInProgressError)
pub mod update_in_progress_error {
    /// A builder for [`UpdateInProgressError`](crate::error::UpdateInProgressError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`UpdateInProgressError`](crate::error::UpdateInProgressError)
        pub fn build(self) -> crate::error::UpdateInProgressError {
            crate::error::UpdateInProgressError {
                message: self.message,
            }
        }
    }
}
impl UpdateInProgressError {
    /// Creates a new builder-style object to manufacture [`UpdateInProgressError`](crate::error::UpdateInProgressError)
    pub fn builder() -> crate::error::update_in_progress_error::Builder {
        crate::error::update_in_progress_error::Builder::default()
    }
}

/// <p>There is no update available for this Amazon ECS container agent. This could be because the
/// agent is already running the latest version, or it is so old that there is no update
/// path to the current version.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct NoUpdateAvailableError {
    #[serde(rename = "message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for NoUpdateAvailableError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("NoUpdateAvailableError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl NoUpdateAvailableError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for NoUpdateAvailableError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "NoUpdateAvailableError [NoUpdateAvailableException]")?;
        if let Some(inner_13) = &self.message {
            write!(f, ": {}", inner_13)?;
        }
        Ok(())
    }
}
impl std::error::Error for NoUpdateAvailableError {}
/// See [`NoUpdateAvailableError`](crate::error::NoUpdateAvailableError)
pub mod no_update_available_error {
    /// A builder for [`NoUpdateAvailableError`](crate::error::NoUpdateAvailableError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`NoUpdateAvailableError`](crate::error::NoUpdateAvailableError)
        pub fn build(self) -> crate::error::NoUpdateAvailableError {
            crate::error::NoUpdateAvailableError {
                message: self.message,
            }
        }
    }
}
impl NoUpdateAvailableError {
    /// Creates a new builder-style object to manufacture [`NoUpdateAvailableError`](crate::error::NoUpdateAvailableError)
    pub fn builder() -> crate::error::no_update_available_error::Builder {
        crate::error::no_update_available_error::Builder::default()
    }
}

/// <p>Amazon ECS is unable to determine the current version of the Amazon ECS container agent on the
/// container instance and does not have enough information to proceed with an update. This
/// could be because the agent running on the container instance is an older or custom
/// version that does not use our version information.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct MissingVersionError {
    #[serde(rename = "message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for MissingVersionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("MissingVersionError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl MissingVersionError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for MissingVersionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "MissingVersionError [MissingVersionException]")?;
        if let Some(inner_14) = &self.message {
            write!(f, ": {}", inner_14)?;
        }
        Ok(())
    }
}
impl std::error::Error for MissingVersionError {}
/// See [`MissingVersionError`](crate::error::MissingVersionError)
pub mod missing_version_error {
    /// A builder for [`MissingVersionError`](crate::error::MissingVersionError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`MissingVersionError`](crate::error::MissingVersionError)
        pub fn build(self) -> crate::error::MissingVersionError {
            crate::error::MissingVersionError {
                message: self.message,
            }
        }
    }
}
impl MissingVersionError {
    /// Creates a new builder-style object to manufacture [`MissingVersionError`](crate::error::MissingVersionError)
    pub fn builder() -> crate::error::missing_version_error::Builder {
        crate::error::missing_version_error::Builder::default()
    }
}

/// <p>The specified resource could not be found.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct ResourceNotFoundError {
    #[serde(rename = "message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ResourceNotFoundError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ResourceNotFoundError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ResourceNotFoundError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ResourceNotFoundError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ResourceNotFoundError [ResourceNotFoundException]")?;
        if let Some(inner_15) = &self.message {
            write!(f, ": {}", inner_15)?;
        }
        Ok(())
    }
}
impl std::error::Error for ResourceNotFoundError {}
/// See [`ResourceNotFoundError`](crate::error::ResourceNotFoundError)
pub mod resource_not_found_error {
    /// A builder for [`ResourceNotFoundError`](crate::error::ResourceNotFoundError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ResourceNotFoundError`](crate::error::ResourceNotFoundError)
        pub fn build(self) -> crate::error::ResourceNotFoundError {
            crate::error::ResourceNotFoundError {
                message: self.message,
            }
        }
    }
}
impl ResourceNotFoundError {
    /// Creates a new builder-style object to manufacture [`ResourceNotFoundError`](crate::error::ResourceNotFoundError)
    pub fn builder() -> crate::error::resource_not_found_error::Builder {
        crate::error::resource_not_found_error::Builder::default()
    }
}

/// <p>Your AWS account has been blocked. For more information, contact <a href="http://aws.amazon.com/contact-us/">AWS Support</a>.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct BlockedError {
    #[serde(rename = "message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for BlockedError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("BlockedError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl BlockedError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for BlockedError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "BlockedError [BlockedException]")?;
        if let Some(inner_16) = &self.message {
            write!(f, ": {}", inner_16)?;
        }
        Ok(())
    }
}
impl std::error::Error for BlockedError {}
/// See [`BlockedError`](crate::error::BlockedError)
pub mod blocked_error {
    /// A builder for [`BlockedError`](crate::error::BlockedError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`BlockedError`](crate::error::BlockedError)
        pub fn build(self) -> crate::error::BlockedError {
            crate::error::BlockedError {
                message: self.message,
            }
        }
    }
}
impl BlockedError {
    /// Creates a new builder-style object to manufacture [`BlockedError`](crate::error::BlockedError)
    pub fn builder() -> crate::error::blocked_error::Builder {
        crate::error::blocked_error::Builder::default()
    }
}

/// <p>The specified resource is in-use and cannot be removed.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct ResourceInUseError {
    #[serde(rename = "message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ResourceInUseError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ResourceInUseError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ResourceInUseError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ResourceInUseError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ResourceInUseError [ResourceInUseException]")?;
        if let Some(inner_17) = &self.message {
            write!(f, ": {}", inner_17)?;
        }
        Ok(())
    }
}
impl std::error::Error for ResourceInUseError {}
/// See [`ResourceInUseError`](crate::error::ResourceInUseError)
pub mod resource_in_use_error {
    /// A builder for [`ResourceInUseError`](crate::error::ResourceInUseError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ResourceInUseError`](crate::error::ResourceInUseError)
        pub fn build(self) -> crate::error::ResourceInUseError {
            crate::error::ResourceInUseError {
                message: self.message,
            }
        }
    }
}
impl ResourceInUseError {
    /// Creates a new builder-style object to manufacture [`ResourceInUseError`](crate::error::ResourceInUseError)
    pub fn builder() -> crate::error::resource_in_use_error::Builder {
        crate::error::resource_in_use_error::Builder::default()
    }
}

/// <p>The specified target could not be found. You can view your available container
/// instances with <a>ListContainerInstances</a>. Amazon ECS container instances are
/// cluster-specific and Region-specific.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct TargetNotFoundError {
    #[serde(rename = "message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for TargetNotFoundError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TargetNotFoundError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl TargetNotFoundError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for TargetNotFoundError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "TargetNotFoundError [TargetNotFoundException]")?;
        if let Some(inner_18) = &self.message {
            write!(f, ": {}", inner_18)?;
        }
        Ok(())
    }
}
impl std::error::Error for TargetNotFoundError {}
/// See [`TargetNotFoundError`](crate::error::TargetNotFoundError)
pub mod target_not_found_error {
    /// A builder for [`TargetNotFoundError`](crate::error::TargetNotFoundError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`TargetNotFoundError`](crate::error::TargetNotFoundError)
        pub fn build(self) -> crate::error::TargetNotFoundError {
            crate::error::TargetNotFoundError {
                message: self.message,
            }
        }
    }
}
impl TargetNotFoundError {
    /// Creates a new builder-style object to manufacture [`TargetNotFoundError`](crate::error::TargetNotFoundError)
    pub fn builder() -> crate::error::target_not_found_error::Builder {
        crate::error::target_not_found_error::Builder::default()
    }
}

/// <p>You can apply up to 10 custom attributes per resource. You can view the attributes of
/// a resource with <a>ListAttributes</a>. You can remove existing attributes on
/// a resource with <a>DeleteAttributes</a>.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct AttributeLimitExceededError {
    #[serde(rename = "message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for AttributeLimitExceededError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AttributeLimitExceededError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl AttributeLimitExceededError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for AttributeLimitExceededError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "AttributeLimitExceededError [AttributeLimitExceededException]"
        )?;
        if let Some(inner_19) = &self.message {
            write!(f, ": {}", inner_19)?;
        }
        Ok(())
    }
}
impl std::error::Error for AttributeLimitExceededError {}
/// See [`AttributeLimitExceededError`](crate::error::AttributeLimitExceededError)
pub mod attribute_limit_exceeded_error {
    /// A builder for [`AttributeLimitExceededError`](crate::error::AttributeLimitExceededError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`AttributeLimitExceededError`](crate::error::AttributeLimitExceededError)
        pub fn build(self) -> crate::error::AttributeLimitExceededError {
            crate::error::AttributeLimitExceededError {
                message: self.message,
            }
        }
    }
}
impl AttributeLimitExceededError {
    /// Creates a new builder-style object to manufacture [`AttributeLimitExceededError`](crate::error::AttributeLimitExceededError)
    pub fn builder() -> crate::error::attribute_limit_exceeded_error::Builder {
        crate::error::attribute_limit_exceeded_error::Builder::default()
    }
}

/// <p>The target container is not properly configured with the execute command agent or the
/// container is no longer active or running.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct TargetNotConnectedError {
    #[serde(rename = "message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for TargetNotConnectedError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TargetNotConnectedError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl TargetNotConnectedError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for TargetNotConnectedError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "TargetNotConnectedError [TargetNotConnectedException]")?;
        if let Some(inner_20) = &self.message {
            write!(f, ": {}", inner_20)?;
        }
        Ok(())
    }
}
impl std::error::Error for TargetNotConnectedError {}
/// See [`TargetNotConnectedError`](crate::error::TargetNotConnectedError)
pub mod target_not_connected_error {
    /// A builder for [`TargetNotConnectedError`](crate::error::TargetNotConnectedError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`TargetNotConnectedError`](crate::error::TargetNotConnectedError)
        pub fn build(self) -> crate::error::TargetNotConnectedError {
            crate::error::TargetNotConnectedError {
                message: self.message,
            }
        }
    }
}
impl TargetNotConnectedError {
    /// Creates a new builder-style object to manufacture [`TargetNotConnectedError`](crate::error::TargetNotConnectedError)
    pub fn builder() -> crate::error::target_not_connected_error::Builder {
        crate::error::target_not_connected_error::Builder::default()
    }
}

/// <p>You cannot delete a cluster that has active tasks.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct ClusterContainsTasksError {
    #[serde(rename = "message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ClusterContainsTasksError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ClusterContainsTasksError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ClusterContainsTasksError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ClusterContainsTasksError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "ClusterContainsTasksError [ClusterContainsTasksException]"
        )?;
        if let Some(inner_21) = &self.message {
            write!(f, ": {}", inner_21)?;
        }
        Ok(())
    }
}
impl std::error::Error for ClusterContainsTasksError {}
/// See [`ClusterContainsTasksError`](crate::error::ClusterContainsTasksError)
pub mod cluster_contains_tasks_error {
    /// A builder for [`ClusterContainsTasksError`](crate::error::ClusterContainsTasksError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ClusterContainsTasksError`](crate::error::ClusterContainsTasksError)
        pub fn build(self) -> crate::error::ClusterContainsTasksError {
            crate::error::ClusterContainsTasksError {
                message: self.message,
            }
        }
    }
}
impl ClusterContainsTasksError {
    /// Creates a new builder-style object to manufacture [`ClusterContainsTasksError`](crate::error::ClusterContainsTasksError)
    pub fn builder() -> crate::error::cluster_contains_tasks_error::Builder {
        crate::error::cluster_contains_tasks_error::Builder::default()
    }
}

/// <p>You cannot delete a cluster that contains services. First, update the service to
/// reduce its desired task count to 0 and then delete the service. For more information,
/// see <a>UpdateService</a> and <a>DeleteService</a>.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct ClusterContainsServicesError {
    #[serde(rename = "message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ClusterContainsServicesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ClusterContainsServicesError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ClusterContainsServicesError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ClusterContainsServicesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "ClusterContainsServicesError [ClusterContainsServicesException]"
        )?;
        if let Some(inner_22) = &self.message {
            write!(f, ": {}", inner_22)?;
        }
        Ok(())
    }
}
impl std::error::Error for ClusterContainsServicesError {}
/// See [`ClusterContainsServicesError`](crate::error::ClusterContainsServicesError)
pub mod cluster_contains_services_error {
    /// A builder for [`ClusterContainsServicesError`](crate::error::ClusterContainsServicesError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ClusterContainsServicesError`](crate::error::ClusterContainsServicesError)
        pub fn build(self) -> crate::error::ClusterContainsServicesError {
            crate::error::ClusterContainsServicesError {
                message: self.message,
            }
        }
    }
}
impl ClusterContainsServicesError {
    /// Creates a new builder-style object to manufacture [`ClusterContainsServicesError`](crate::error::ClusterContainsServicesError)
    pub fn builder() -> crate::error::cluster_contains_services_error::Builder {
        crate::error::cluster_contains_services_error::Builder::default()
    }
}

/// <p>You cannot delete a cluster that has registered container instances. First, deregister
/// the container instances before you can delete the cluster. For more information, see
/// <a>DeregisterContainerInstance</a>.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct ClusterContainsContainerInstancesError {
    #[serde(rename = "message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ClusterContainsContainerInstancesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ClusterContainsContainerInstancesError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ClusterContainsContainerInstancesError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ClusterContainsContainerInstancesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "ClusterContainsContainerInstancesError [ClusterContainsContainerInstancesException]"
        )?;
        if let Some(inner_23) = &self.message {
            write!(f, ": {}", inner_23)?;
        }
        Ok(())
    }
}
impl std::error::Error for ClusterContainsContainerInstancesError {}
/// See [`ClusterContainsContainerInstancesError`](crate::error::ClusterContainsContainerInstancesError)
pub mod cluster_contains_container_instances_error {
    /// A builder for [`ClusterContainsContainerInstancesError`](crate::error::ClusterContainsContainerInstancesError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ClusterContainsContainerInstancesError`](crate::error::ClusterContainsContainerInstancesError)
        pub fn build(self) -> crate::error::ClusterContainsContainerInstancesError {
            crate::error::ClusterContainsContainerInstancesError {
                message: self.message,
            }
        }
    }
}
impl ClusterContainsContainerInstancesError {
    /// Creates a new builder-style object to manufacture [`ClusterContainsContainerInstancesError`](crate::error::ClusterContainsContainerInstancesError)
    pub fn builder() -> crate::error::cluster_contains_container_instances_error::Builder {
        crate::error::cluster_contains_container_instances_error::Builder::default()
    }
}

/// <p>The limit for the resource has been exceeded.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct LimitExceededError {
    #[serde(rename = "message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for LimitExceededError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("LimitExceededError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl LimitExceededError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for LimitExceededError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "LimitExceededError [LimitExceededException]")?;
        if let Some(inner_24) = &self.message {
            write!(f, ": {}", inner_24)?;
        }
        Ok(())
    }
}
impl std::error::Error for LimitExceededError {}
/// See [`LimitExceededError`](crate::error::LimitExceededError)
pub mod limit_exceeded_error {
    /// A builder for [`LimitExceededError`](crate::error::LimitExceededError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`LimitExceededError`](crate::error::LimitExceededError)
        pub fn build(self) -> crate::error::LimitExceededError {
            crate::error::LimitExceededError {
                message: self.message,
            }
        }
    }
}
impl LimitExceededError {
    /// Creates a new builder-style object to manufacture [`LimitExceededError`](crate::error::LimitExceededError)
    pub fn builder() -> crate::error::limit_exceeded_error::Builder {
        crate::error::limit_exceeded_error::Builder::default()
    }
}
