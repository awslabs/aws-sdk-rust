// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateCapacityProviderError {
    pub kind: CreateCapacityProviderErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateCapacityProviderErrorKind {
    ClientException(crate::error::ClientException),
    InvalidParameterException(crate::error::InvalidParameterException),
    LimitExceededException(crate::error::LimitExceededException),
    ServerException(crate::error::ServerException),
    UpdateInProgressException(crate::error::UpdateInProgressException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateCapacityProviderError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateCapacityProviderErrorKind::ClientException(_inner) => _inner.fmt(f),
            CreateCapacityProviderErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            CreateCapacityProviderErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            CreateCapacityProviderErrorKind::ServerException(_inner) => _inner.fmt(f),
            CreateCapacityProviderErrorKind::UpdateInProgressException(_inner) => _inner.fmt(f),
            CreateCapacityProviderErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateCapacityProviderError {
    fn code(&self) -> Option<&str> {
        CreateCapacityProviderError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateCapacityProviderError {
    pub fn new(kind: CreateCapacityProviderErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateCapacityProviderErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateCapacityProviderErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateCapacityProviderErrorKind::ClientException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateCapacityProviderErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateCapacityProviderErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateCapacityProviderErrorKind::ServerException(_)
        )
    }
    pub fn is_update_in_progress_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateCapacityProviderErrorKind::UpdateInProgressException(_)
        )
    }
}
impl std::error::Error for CreateCapacityProviderError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateCapacityProviderErrorKind::ClientException(_inner) => Some(_inner),
            CreateCapacityProviderErrorKind::InvalidParameterException(_inner) => Some(_inner),
            CreateCapacityProviderErrorKind::LimitExceededException(_inner) => Some(_inner),
            CreateCapacityProviderErrorKind::ServerException(_inner) => Some(_inner),
            CreateCapacityProviderErrorKind::UpdateInProgressException(_inner) => Some(_inner),
            CreateCapacityProviderErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateClusterError {
    pub kind: CreateClusterErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateClusterErrorKind {
    ClientException(crate::error::ClientException),
    InvalidParameterException(crate::error::InvalidParameterException),
    ServerException(crate::error::ServerException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateClusterError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateClusterErrorKind::ClientException(_inner) => _inner.fmt(f),
            CreateClusterErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            CreateClusterErrorKind::ServerException(_inner) => _inner.fmt(f),
            CreateClusterErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateClusterError {
    fn code(&self) -> Option<&str> {
        CreateClusterError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateClusterError {
    pub fn new(kind: CreateClusterErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateClusterErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateClusterErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_client_exception(&self) -> bool {
        matches!(&self.kind, CreateClusterErrorKind::ClientException(_))
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateClusterErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_server_exception(&self) -> bool {
        matches!(&self.kind, CreateClusterErrorKind::ServerException(_))
    }
}
impl std::error::Error for CreateClusterError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateClusterErrorKind::ClientException(_inner) => Some(_inner),
            CreateClusterErrorKind::InvalidParameterException(_inner) => Some(_inner),
            CreateClusterErrorKind::ServerException(_inner) => Some(_inner),
            CreateClusterErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateServiceError {
    pub kind: CreateServiceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateServiceErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    ClientException(crate::error::ClientException),
    ClusterNotFoundException(crate::error::ClusterNotFoundException),
    InvalidParameterException(crate::error::InvalidParameterException),
    PlatformTaskDefinitionIncompatibilityException(
        crate::error::PlatformTaskDefinitionIncompatibilityException,
    ),
    PlatformUnknownException(crate::error::PlatformUnknownException),
    ServerException(crate::error::ServerException),
    UnsupportedFeatureException(crate::error::UnsupportedFeatureException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateServiceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateServiceErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            CreateServiceErrorKind::ClientException(_inner) => _inner.fmt(f),
            CreateServiceErrorKind::ClusterNotFoundException(_inner) => _inner.fmt(f),
            CreateServiceErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            CreateServiceErrorKind::PlatformTaskDefinitionIncompatibilityException(_inner) => {
                _inner.fmt(f)
            }
            CreateServiceErrorKind::PlatformUnknownException(_inner) => _inner.fmt(f),
            CreateServiceErrorKind::ServerException(_inner) => _inner.fmt(f),
            CreateServiceErrorKind::UnsupportedFeatureException(_inner) => _inner.fmt(f),
            CreateServiceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateServiceError {
    fn code(&self) -> Option<&str> {
        CreateServiceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateServiceError {
    pub fn new(kind: CreateServiceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateServiceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateServiceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, CreateServiceErrorKind::AccessDeniedException(_))
    }
    pub fn is_client_exception(&self) -> bool {
        matches!(&self.kind, CreateServiceErrorKind::ClientException(_))
    }
    pub fn is_cluster_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateServiceErrorKind::ClusterNotFoundException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateServiceErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_platform_task_definition_incompatibility_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateServiceErrorKind::PlatformTaskDefinitionIncompatibilityException(_)
        )
    }
    pub fn is_platform_unknown_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateServiceErrorKind::PlatformUnknownException(_)
        )
    }
    pub fn is_server_exception(&self) -> bool {
        matches!(&self.kind, CreateServiceErrorKind::ServerException(_))
    }
    pub fn is_unsupported_feature_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateServiceErrorKind::UnsupportedFeatureException(_)
        )
    }
}
impl std::error::Error for CreateServiceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateServiceErrorKind::AccessDeniedException(_inner) => Some(_inner),
            CreateServiceErrorKind::ClientException(_inner) => Some(_inner),
            CreateServiceErrorKind::ClusterNotFoundException(_inner) => Some(_inner),
            CreateServiceErrorKind::InvalidParameterException(_inner) => Some(_inner),
            CreateServiceErrorKind::PlatformTaskDefinitionIncompatibilityException(_inner) => {
                Some(_inner)
            }
            CreateServiceErrorKind::PlatformUnknownException(_inner) => Some(_inner),
            CreateServiceErrorKind::ServerException(_inner) => Some(_inner),
            CreateServiceErrorKind::UnsupportedFeatureException(_inner) => Some(_inner),
            CreateServiceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateTaskSetError {
    pub kind: CreateTaskSetErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateTaskSetErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    ClientException(crate::error::ClientException),
    ClusterNotFoundException(crate::error::ClusterNotFoundException),
    InvalidParameterException(crate::error::InvalidParameterException),
    PlatformTaskDefinitionIncompatibilityException(
        crate::error::PlatformTaskDefinitionIncompatibilityException,
    ),
    PlatformUnknownException(crate::error::PlatformUnknownException),
    ServerException(crate::error::ServerException),
    ServiceNotActiveException(crate::error::ServiceNotActiveException),
    ServiceNotFoundException(crate::error::ServiceNotFoundException),
    UnsupportedFeatureException(crate::error::UnsupportedFeatureException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateTaskSetError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateTaskSetErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            CreateTaskSetErrorKind::ClientException(_inner) => _inner.fmt(f),
            CreateTaskSetErrorKind::ClusterNotFoundException(_inner) => _inner.fmt(f),
            CreateTaskSetErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            CreateTaskSetErrorKind::PlatformTaskDefinitionIncompatibilityException(_inner) => {
                _inner.fmt(f)
            }
            CreateTaskSetErrorKind::PlatformUnknownException(_inner) => _inner.fmt(f),
            CreateTaskSetErrorKind::ServerException(_inner) => _inner.fmt(f),
            CreateTaskSetErrorKind::ServiceNotActiveException(_inner) => _inner.fmt(f),
            CreateTaskSetErrorKind::ServiceNotFoundException(_inner) => _inner.fmt(f),
            CreateTaskSetErrorKind::UnsupportedFeatureException(_inner) => _inner.fmt(f),
            CreateTaskSetErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateTaskSetError {
    fn code(&self) -> Option<&str> {
        CreateTaskSetError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateTaskSetError {
    pub fn new(kind: CreateTaskSetErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateTaskSetErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateTaskSetErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, CreateTaskSetErrorKind::AccessDeniedException(_))
    }
    pub fn is_client_exception(&self) -> bool {
        matches!(&self.kind, CreateTaskSetErrorKind::ClientException(_))
    }
    pub fn is_cluster_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateTaskSetErrorKind::ClusterNotFoundException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateTaskSetErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_platform_task_definition_incompatibility_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateTaskSetErrorKind::PlatformTaskDefinitionIncompatibilityException(_)
        )
    }
    pub fn is_platform_unknown_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateTaskSetErrorKind::PlatformUnknownException(_)
        )
    }
    pub fn is_server_exception(&self) -> bool {
        matches!(&self.kind, CreateTaskSetErrorKind::ServerException(_))
    }
    pub fn is_service_not_active_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateTaskSetErrorKind::ServiceNotActiveException(_)
        )
    }
    pub fn is_service_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateTaskSetErrorKind::ServiceNotFoundException(_)
        )
    }
    pub fn is_unsupported_feature_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateTaskSetErrorKind::UnsupportedFeatureException(_)
        )
    }
}
impl std::error::Error for CreateTaskSetError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateTaskSetErrorKind::AccessDeniedException(_inner) => Some(_inner),
            CreateTaskSetErrorKind::ClientException(_inner) => Some(_inner),
            CreateTaskSetErrorKind::ClusterNotFoundException(_inner) => Some(_inner),
            CreateTaskSetErrorKind::InvalidParameterException(_inner) => Some(_inner),
            CreateTaskSetErrorKind::PlatformTaskDefinitionIncompatibilityException(_inner) => {
                Some(_inner)
            }
            CreateTaskSetErrorKind::PlatformUnknownException(_inner) => Some(_inner),
            CreateTaskSetErrorKind::ServerException(_inner) => Some(_inner),
            CreateTaskSetErrorKind::ServiceNotActiveException(_inner) => Some(_inner),
            CreateTaskSetErrorKind::ServiceNotFoundException(_inner) => Some(_inner),
            CreateTaskSetErrorKind::UnsupportedFeatureException(_inner) => Some(_inner),
            CreateTaskSetErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteAccountSettingError {
    pub kind: DeleteAccountSettingErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteAccountSettingErrorKind {
    ClientException(crate::error::ClientException),
    InvalidParameterException(crate::error::InvalidParameterException),
    ServerException(crate::error::ServerException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteAccountSettingError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteAccountSettingErrorKind::ClientException(_inner) => _inner.fmt(f),
            DeleteAccountSettingErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            DeleteAccountSettingErrorKind::ServerException(_inner) => _inner.fmt(f),
            DeleteAccountSettingErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteAccountSettingError {
    fn code(&self) -> Option<&str> {
        DeleteAccountSettingError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteAccountSettingError {
    pub fn new(kind: DeleteAccountSettingErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteAccountSettingErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteAccountSettingErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteAccountSettingErrorKind::ClientException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteAccountSettingErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteAccountSettingErrorKind::ServerException(_)
        )
    }
}
impl std::error::Error for DeleteAccountSettingError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteAccountSettingErrorKind::ClientException(_inner) => Some(_inner),
            DeleteAccountSettingErrorKind::InvalidParameterException(_inner) => Some(_inner),
            DeleteAccountSettingErrorKind::ServerException(_inner) => Some(_inner),
            DeleteAccountSettingErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteAttributesError {
    pub kind: DeleteAttributesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteAttributesErrorKind {
    ClusterNotFoundException(crate::error::ClusterNotFoundException),
    InvalidParameterException(crate::error::InvalidParameterException),
    TargetNotFoundException(crate::error::TargetNotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteAttributesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteAttributesErrorKind::ClusterNotFoundException(_inner) => _inner.fmt(f),
            DeleteAttributesErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            DeleteAttributesErrorKind::TargetNotFoundException(_inner) => _inner.fmt(f),
            DeleteAttributesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteAttributesError {
    fn code(&self) -> Option<&str> {
        DeleteAttributesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteAttributesError {
    pub fn new(kind: DeleteAttributesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteAttributesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteAttributesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_cluster_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteAttributesErrorKind::ClusterNotFoundException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteAttributesErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_target_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteAttributesErrorKind::TargetNotFoundException(_)
        )
    }
}
impl std::error::Error for DeleteAttributesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteAttributesErrorKind::ClusterNotFoundException(_inner) => Some(_inner),
            DeleteAttributesErrorKind::InvalidParameterException(_inner) => Some(_inner),
            DeleteAttributesErrorKind::TargetNotFoundException(_inner) => Some(_inner),
            DeleteAttributesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteCapacityProviderError {
    pub kind: DeleteCapacityProviderErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteCapacityProviderErrorKind {
    ClientException(crate::error::ClientException),
    InvalidParameterException(crate::error::InvalidParameterException),
    ServerException(crate::error::ServerException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteCapacityProviderError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteCapacityProviderErrorKind::ClientException(_inner) => _inner.fmt(f),
            DeleteCapacityProviderErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            DeleteCapacityProviderErrorKind::ServerException(_inner) => _inner.fmt(f),
            DeleteCapacityProviderErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteCapacityProviderError {
    fn code(&self) -> Option<&str> {
        DeleteCapacityProviderError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteCapacityProviderError {
    pub fn new(kind: DeleteCapacityProviderErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteCapacityProviderErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteCapacityProviderErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteCapacityProviderErrorKind::ClientException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteCapacityProviderErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteCapacityProviderErrorKind::ServerException(_)
        )
    }
}
impl std::error::Error for DeleteCapacityProviderError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteCapacityProviderErrorKind::ClientException(_inner) => Some(_inner),
            DeleteCapacityProviderErrorKind::InvalidParameterException(_inner) => Some(_inner),
            DeleteCapacityProviderErrorKind::ServerException(_inner) => Some(_inner),
            DeleteCapacityProviderErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteClusterError {
    pub kind: DeleteClusterErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteClusterErrorKind {
    ClientException(crate::error::ClientException),
    ClusterContainsContainerInstancesException(
        crate::error::ClusterContainsContainerInstancesException,
    ),
    ClusterContainsServicesException(crate::error::ClusterContainsServicesException),
    ClusterContainsTasksException(crate::error::ClusterContainsTasksException),
    ClusterNotFoundException(crate::error::ClusterNotFoundException),
    InvalidParameterException(crate::error::InvalidParameterException),
    ServerException(crate::error::ServerException),
    UpdateInProgressException(crate::error::UpdateInProgressException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteClusterError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteClusterErrorKind::ClientException(_inner) => _inner.fmt(f),
            DeleteClusterErrorKind::ClusterContainsContainerInstancesException(_inner) => {
                _inner.fmt(f)
            }
            DeleteClusterErrorKind::ClusterContainsServicesException(_inner) => _inner.fmt(f),
            DeleteClusterErrorKind::ClusterContainsTasksException(_inner) => _inner.fmt(f),
            DeleteClusterErrorKind::ClusterNotFoundException(_inner) => _inner.fmt(f),
            DeleteClusterErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            DeleteClusterErrorKind::ServerException(_inner) => _inner.fmt(f),
            DeleteClusterErrorKind::UpdateInProgressException(_inner) => _inner.fmt(f),
            DeleteClusterErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteClusterError {
    fn code(&self) -> Option<&str> {
        DeleteClusterError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteClusterError {
    pub fn new(kind: DeleteClusterErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteClusterErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteClusterErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_client_exception(&self) -> bool {
        matches!(&self.kind, DeleteClusterErrorKind::ClientException(_))
    }
    pub fn is_cluster_contains_container_instances_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteClusterErrorKind::ClusterContainsContainerInstancesException(_)
        )
    }
    pub fn is_cluster_contains_services_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteClusterErrorKind::ClusterContainsServicesException(_)
        )
    }
    pub fn is_cluster_contains_tasks_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteClusterErrorKind::ClusterContainsTasksException(_)
        )
    }
    pub fn is_cluster_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteClusterErrorKind::ClusterNotFoundException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteClusterErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_server_exception(&self) -> bool {
        matches!(&self.kind, DeleteClusterErrorKind::ServerException(_))
    }
    pub fn is_update_in_progress_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteClusterErrorKind::UpdateInProgressException(_)
        )
    }
}
impl std::error::Error for DeleteClusterError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteClusterErrorKind::ClientException(_inner) => Some(_inner),
            DeleteClusterErrorKind::ClusterContainsContainerInstancesException(_inner) => {
                Some(_inner)
            }
            DeleteClusterErrorKind::ClusterContainsServicesException(_inner) => Some(_inner),
            DeleteClusterErrorKind::ClusterContainsTasksException(_inner) => Some(_inner),
            DeleteClusterErrorKind::ClusterNotFoundException(_inner) => Some(_inner),
            DeleteClusterErrorKind::InvalidParameterException(_inner) => Some(_inner),
            DeleteClusterErrorKind::ServerException(_inner) => Some(_inner),
            DeleteClusterErrorKind::UpdateInProgressException(_inner) => Some(_inner),
            DeleteClusterErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteServiceError {
    pub kind: DeleteServiceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteServiceErrorKind {
    ClientException(crate::error::ClientException),
    ClusterNotFoundException(crate::error::ClusterNotFoundException),
    InvalidParameterException(crate::error::InvalidParameterException),
    ServerException(crate::error::ServerException),
    ServiceNotFoundException(crate::error::ServiceNotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteServiceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteServiceErrorKind::ClientException(_inner) => _inner.fmt(f),
            DeleteServiceErrorKind::ClusterNotFoundException(_inner) => _inner.fmt(f),
            DeleteServiceErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            DeleteServiceErrorKind::ServerException(_inner) => _inner.fmt(f),
            DeleteServiceErrorKind::ServiceNotFoundException(_inner) => _inner.fmt(f),
            DeleteServiceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteServiceError {
    fn code(&self) -> Option<&str> {
        DeleteServiceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteServiceError {
    pub fn new(kind: DeleteServiceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteServiceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteServiceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_client_exception(&self) -> bool {
        matches!(&self.kind, DeleteServiceErrorKind::ClientException(_))
    }
    pub fn is_cluster_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteServiceErrorKind::ClusterNotFoundException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteServiceErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_server_exception(&self) -> bool {
        matches!(&self.kind, DeleteServiceErrorKind::ServerException(_))
    }
    pub fn is_service_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteServiceErrorKind::ServiceNotFoundException(_)
        )
    }
}
impl std::error::Error for DeleteServiceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteServiceErrorKind::ClientException(_inner) => Some(_inner),
            DeleteServiceErrorKind::ClusterNotFoundException(_inner) => Some(_inner),
            DeleteServiceErrorKind::InvalidParameterException(_inner) => Some(_inner),
            DeleteServiceErrorKind::ServerException(_inner) => Some(_inner),
            DeleteServiceErrorKind::ServiceNotFoundException(_inner) => Some(_inner),
            DeleteServiceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteTaskSetError {
    pub kind: DeleteTaskSetErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteTaskSetErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    ClientException(crate::error::ClientException),
    ClusterNotFoundException(crate::error::ClusterNotFoundException),
    InvalidParameterException(crate::error::InvalidParameterException),
    ServerException(crate::error::ServerException),
    ServiceNotActiveException(crate::error::ServiceNotActiveException),
    ServiceNotFoundException(crate::error::ServiceNotFoundException),
    TaskSetNotFoundException(crate::error::TaskSetNotFoundException),
    UnsupportedFeatureException(crate::error::UnsupportedFeatureException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteTaskSetError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteTaskSetErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            DeleteTaskSetErrorKind::ClientException(_inner) => _inner.fmt(f),
            DeleteTaskSetErrorKind::ClusterNotFoundException(_inner) => _inner.fmt(f),
            DeleteTaskSetErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            DeleteTaskSetErrorKind::ServerException(_inner) => _inner.fmt(f),
            DeleteTaskSetErrorKind::ServiceNotActiveException(_inner) => _inner.fmt(f),
            DeleteTaskSetErrorKind::ServiceNotFoundException(_inner) => _inner.fmt(f),
            DeleteTaskSetErrorKind::TaskSetNotFoundException(_inner) => _inner.fmt(f),
            DeleteTaskSetErrorKind::UnsupportedFeatureException(_inner) => _inner.fmt(f),
            DeleteTaskSetErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteTaskSetError {
    fn code(&self) -> Option<&str> {
        DeleteTaskSetError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteTaskSetError {
    pub fn new(kind: DeleteTaskSetErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteTaskSetErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteTaskSetErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, DeleteTaskSetErrorKind::AccessDeniedException(_))
    }
    pub fn is_client_exception(&self) -> bool {
        matches!(&self.kind, DeleteTaskSetErrorKind::ClientException(_))
    }
    pub fn is_cluster_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteTaskSetErrorKind::ClusterNotFoundException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteTaskSetErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_server_exception(&self) -> bool {
        matches!(&self.kind, DeleteTaskSetErrorKind::ServerException(_))
    }
    pub fn is_service_not_active_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteTaskSetErrorKind::ServiceNotActiveException(_)
        )
    }
    pub fn is_service_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteTaskSetErrorKind::ServiceNotFoundException(_)
        )
    }
    pub fn is_task_set_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteTaskSetErrorKind::TaskSetNotFoundException(_)
        )
    }
    pub fn is_unsupported_feature_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteTaskSetErrorKind::UnsupportedFeatureException(_)
        )
    }
}
impl std::error::Error for DeleteTaskSetError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteTaskSetErrorKind::AccessDeniedException(_inner) => Some(_inner),
            DeleteTaskSetErrorKind::ClientException(_inner) => Some(_inner),
            DeleteTaskSetErrorKind::ClusterNotFoundException(_inner) => Some(_inner),
            DeleteTaskSetErrorKind::InvalidParameterException(_inner) => Some(_inner),
            DeleteTaskSetErrorKind::ServerException(_inner) => Some(_inner),
            DeleteTaskSetErrorKind::ServiceNotActiveException(_inner) => Some(_inner),
            DeleteTaskSetErrorKind::ServiceNotFoundException(_inner) => Some(_inner),
            DeleteTaskSetErrorKind::TaskSetNotFoundException(_inner) => Some(_inner),
            DeleteTaskSetErrorKind::UnsupportedFeatureException(_inner) => Some(_inner),
            DeleteTaskSetErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeregisterContainerInstanceError {
    pub kind: DeregisterContainerInstanceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeregisterContainerInstanceErrorKind {
    ClientException(crate::error::ClientException),
    ClusterNotFoundException(crate::error::ClusterNotFoundException),
    InvalidParameterException(crate::error::InvalidParameterException),
    ServerException(crate::error::ServerException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeregisterContainerInstanceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeregisterContainerInstanceErrorKind::ClientException(_inner) => _inner.fmt(f),
            DeregisterContainerInstanceErrorKind::ClusterNotFoundException(_inner) => _inner.fmt(f),
            DeregisterContainerInstanceErrorKind::InvalidParameterException(_inner) => {
                _inner.fmt(f)
            }
            DeregisterContainerInstanceErrorKind::ServerException(_inner) => _inner.fmt(f),
            DeregisterContainerInstanceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeregisterContainerInstanceError {
    fn code(&self) -> Option<&str> {
        DeregisterContainerInstanceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeregisterContainerInstanceError {
    pub fn new(kind: DeregisterContainerInstanceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeregisterContainerInstanceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeregisterContainerInstanceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeregisterContainerInstanceErrorKind::ClientException(_)
        )
    }
    pub fn is_cluster_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeregisterContainerInstanceErrorKind::ClusterNotFoundException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeregisterContainerInstanceErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeregisterContainerInstanceErrorKind::ServerException(_)
        )
    }
}
impl std::error::Error for DeregisterContainerInstanceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeregisterContainerInstanceErrorKind::ClientException(_inner) => Some(_inner),
            DeregisterContainerInstanceErrorKind::ClusterNotFoundException(_inner) => Some(_inner),
            DeregisterContainerInstanceErrorKind::InvalidParameterException(_inner) => Some(_inner),
            DeregisterContainerInstanceErrorKind::ServerException(_inner) => Some(_inner),
            DeregisterContainerInstanceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeregisterTaskDefinitionError {
    pub kind: DeregisterTaskDefinitionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeregisterTaskDefinitionErrorKind {
    ClientException(crate::error::ClientException),
    InvalidParameterException(crate::error::InvalidParameterException),
    ServerException(crate::error::ServerException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeregisterTaskDefinitionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeregisterTaskDefinitionErrorKind::ClientException(_inner) => _inner.fmt(f),
            DeregisterTaskDefinitionErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            DeregisterTaskDefinitionErrorKind::ServerException(_inner) => _inner.fmt(f),
            DeregisterTaskDefinitionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeregisterTaskDefinitionError {
    fn code(&self) -> Option<&str> {
        DeregisterTaskDefinitionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeregisterTaskDefinitionError {
    pub fn new(kind: DeregisterTaskDefinitionErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeregisterTaskDefinitionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeregisterTaskDefinitionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeregisterTaskDefinitionErrorKind::ClientException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeregisterTaskDefinitionErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeregisterTaskDefinitionErrorKind::ServerException(_)
        )
    }
}
impl std::error::Error for DeregisterTaskDefinitionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeregisterTaskDefinitionErrorKind::ClientException(_inner) => Some(_inner),
            DeregisterTaskDefinitionErrorKind::InvalidParameterException(_inner) => Some(_inner),
            DeregisterTaskDefinitionErrorKind::ServerException(_inner) => Some(_inner),
            DeregisterTaskDefinitionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeCapacityProvidersError {
    pub kind: DescribeCapacityProvidersErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeCapacityProvidersErrorKind {
    ClientException(crate::error::ClientException),
    InvalidParameterException(crate::error::InvalidParameterException),
    ServerException(crate::error::ServerException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeCapacityProvidersError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeCapacityProvidersErrorKind::ClientException(_inner) => _inner.fmt(f),
            DescribeCapacityProvidersErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            DescribeCapacityProvidersErrorKind::ServerException(_inner) => _inner.fmt(f),
            DescribeCapacityProvidersErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeCapacityProvidersError {
    fn code(&self) -> Option<&str> {
        DescribeCapacityProvidersError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeCapacityProvidersError {
    pub fn new(kind: DescribeCapacityProvidersErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeCapacityProvidersErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeCapacityProvidersErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeCapacityProvidersErrorKind::ClientException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeCapacityProvidersErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeCapacityProvidersErrorKind::ServerException(_)
        )
    }
}
impl std::error::Error for DescribeCapacityProvidersError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeCapacityProvidersErrorKind::ClientException(_inner) => Some(_inner),
            DescribeCapacityProvidersErrorKind::InvalidParameterException(_inner) => Some(_inner),
            DescribeCapacityProvidersErrorKind::ServerException(_inner) => Some(_inner),
            DescribeCapacityProvidersErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeClustersError {
    pub kind: DescribeClustersErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeClustersErrorKind {
    ClientException(crate::error::ClientException),
    InvalidParameterException(crate::error::InvalidParameterException),
    ServerException(crate::error::ServerException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeClustersError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeClustersErrorKind::ClientException(_inner) => _inner.fmt(f),
            DescribeClustersErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            DescribeClustersErrorKind::ServerException(_inner) => _inner.fmt(f),
            DescribeClustersErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeClustersError {
    fn code(&self) -> Option<&str> {
        DescribeClustersError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeClustersError {
    pub fn new(kind: DescribeClustersErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeClustersErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeClustersErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_client_exception(&self) -> bool {
        matches!(&self.kind, DescribeClustersErrorKind::ClientException(_))
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeClustersErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_server_exception(&self) -> bool {
        matches!(&self.kind, DescribeClustersErrorKind::ServerException(_))
    }
}
impl std::error::Error for DescribeClustersError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeClustersErrorKind::ClientException(_inner) => Some(_inner),
            DescribeClustersErrorKind::InvalidParameterException(_inner) => Some(_inner),
            DescribeClustersErrorKind::ServerException(_inner) => Some(_inner),
            DescribeClustersErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeContainerInstancesError {
    pub kind: DescribeContainerInstancesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeContainerInstancesErrorKind {
    ClientException(crate::error::ClientException),
    ClusterNotFoundException(crate::error::ClusterNotFoundException),
    InvalidParameterException(crate::error::InvalidParameterException),
    ServerException(crate::error::ServerException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeContainerInstancesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeContainerInstancesErrorKind::ClientException(_inner) => _inner.fmt(f),
            DescribeContainerInstancesErrorKind::ClusterNotFoundException(_inner) => _inner.fmt(f),
            DescribeContainerInstancesErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            DescribeContainerInstancesErrorKind::ServerException(_inner) => _inner.fmt(f),
            DescribeContainerInstancesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeContainerInstancesError {
    fn code(&self) -> Option<&str> {
        DescribeContainerInstancesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeContainerInstancesError {
    pub fn new(kind: DescribeContainerInstancesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeContainerInstancesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeContainerInstancesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeContainerInstancesErrorKind::ClientException(_)
        )
    }
    pub fn is_cluster_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeContainerInstancesErrorKind::ClusterNotFoundException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeContainerInstancesErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeContainerInstancesErrorKind::ServerException(_)
        )
    }
}
impl std::error::Error for DescribeContainerInstancesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeContainerInstancesErrorKind::ClientException(_inner) => Some(_inner),
            DescribeContainerInstancesErrorKind::ClusterNotFoundException(_inner) => Some(_inner),
            DescribeContainerInstancesErrorKind::InvalidParameterException(_inner) => Some(_inner),
            DescribeContainerInstancesErrorKind::ServerException(_inner) => Some(_inner),
            DescribeContainerInstancesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeServicesError {
    pub kind: DescribeServicesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeServicesErrorKind {
    ClientException(crate::error::ClientException),
    ClusterNotFoundException(crate::error::ClusterNotFoundException),
    InvalidParameterException(crate::error::InvalidParameterException),
    ServerException(crate::error::ServerException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeServicesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeServicesErrorKind::ClientException(_inner) => _inner.fmt(f),
            DescribeServicesErrorKind::ClusterNotFoundException(_inner) => _inner.fmt(f),
            DescribeServicesErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            DescribeServicesErrorKind::ServerException(_inner) => _inner.fmt(f),
            DescribeServicesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeServicesError {
    fn code(&self) -> Option<&str> {
        DescribeServicesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeServicesError {
    pub fn new(kind: DescribeServicesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeServicesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeServicesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_client_exception(&self) -> bool {
        matches!(&self.kind, DescribeServicesErrorKind::ClientException(_))
    }
    pub fn is_cluster_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeServicesErrorKind::ClusterNotFoundException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeServicesErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_server_exception(&self) -> bool {
        matches!(&self.kind, DescribeServicesErrorKind::ServerException(_))
    }
}
impl std::error::Error for DescribeServicesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeServicesErrorKind::ClientException(_inner) => Some(_inner),
            DescribeServicesErrorKind::ClusterNotFoundException(_inner) => Some(_inner),
            DescribeServicesErrorKind::InvalidParameterException(_inner) => Some(_inner),
            DescribeServicesErrorKind::ServerException(_inner) => Some(_inner),
            DescribeServicesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeTaskDefinitionError {
    pub kind: DescribeTaskDefinitionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeTaskDefinitionErrorKind {
    ClientException(crate::error::ClientException),
    InvalidParameterException(crate::error::InvalidParameterException),
    ServerException(crate::error::ServerException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeTaskDefinitionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeTaskDefinitionErrorKind::ClientException(_inner) => _inner.fmt(f),
            DescribeTaskDefinitionErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            DescribeTaskDefinitionErrorKind::ServerException(_inner) => _inner.fmt(f),
            DescribeTaskDefinitionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeTaskDefinitionError {
    fn code(&self) -> Option<&str> {
        DescribeTaskDefinitionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeTaskDefinitionError {
    pub fn new(kind: DescribeTaskDefinitionErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeTaskDefinitionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeTaskDefinitionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeTaskDefinitionErrorKind::ClientException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeTaskDefinitionErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeTaskDefinitionErrorKind::ServerException(_)
        )
    }
}
impl std::error::Error for DescribeTaskDefinitionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeTaskDefinitionErrorKind::ClientException(_inner) => Some(_inner),
            DescribeTaskDefinitionErrorKind::InvalidParameterException(_inner) => Some(_inner),
            DescribeTaskDefinitionErrorKind::ServerException(_inner) => Some(_inner),
            DescribeTaskDefinitionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeTasksError {
    pub kind: DescribeTasksErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeTasksErrorKind {
    ClientException(crate::error::ClientException),
    ClusterNotFoundException(crate::error::ClusterNotFoundException),
    InvalidParameterException(crate::error::InvalidParameterException),
    ServerException(crate::error::ServerException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeTasksError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeTasksErrorKind::ClientException(_inner) => _inner.fmt(f),
            DescribeTasksErrorKind::ClusterNotFoundException(_inner) => _inner.fmt(f),
            DescribeTasksErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            DescribeTasksErrorKind::ServerException(_inner) => _inner.fmt(f),
            DescribeTasksErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeTasksError {
    fn code(&self) -> Option<&str> {
        DescribeTasksError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeTasksError {
    pub fn new(kind: DescribeTasksErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeTasksErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeTasksErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_client_exception(&self) -> bool {
        matches!(&self.kind, DescribeTasksErrorKind::ClientException(_))
    }
    pub fn is_cluster_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeTasksErrorKind::ClusterNotFoundException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeTasksErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_server_exception(&self) -> bool {
        matches!(&self.kind, DescribeTasksErrorKind::ServerException(_))
    }
}
impl std::error::Error for DescribeTasksError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeTasksErrorKind::ClientException(_inner) => Some(_inner),
            DescribeTasksErrorKind::ClusterNotFoundException(_inner) => Some(_inner),
            DescribeTasksErrorKind::InvalidParameterException(_inner) => Some(_inner),
            DescribeTasksErrorKind::ServerException(_inner) => Some(_inner),
            DescribeTasksErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeTaskSetsError {
    pub kind: DescribeTaskSetsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeTaskSetsErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    ClientException(crate::error::ClientException),
    ClusterNotFoundException(crate::error::ClusterNotFoundException),
    InvalidParameterException(crate::error::InvalidParameterException),
    ServerException(crate::error::ServerException),
    ServiceNotActiveException(crate::error::ServiceNotActiveException),
    ServiceNotFoundException(crate::error::ServiceNotFoundException),
    UnsupportedFeatureException(crate::error::UnsupportedFeatureException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeTaskSetsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeTaskSetsErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            DescribeTaskSetsErrorKind::ClientException(_inner) => _inner.fmt(f),
            DescribeTaskSetsErrorKind::ClusterNotFoundException(_inner) => _inner.fmt(f),
            DescribeTaskSetsErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            DescribeTaskSetsErrorKind::ServerException(_inner) => _inner.fmt(f),
            DescribeTaskSetsErrorKind::ServiceNotActiveException(_inner) => _inner.fmt(f),
            DescribeTaskSetsErrorKind::ServiceNotFoundException(_inner) => _inner.fmt(f),
            DescribeTaskSetsErrorKind::UnsupportedFeatureException(_inner) => _inner.fmt(f),
            DescribeTaskSetsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeTaskSetsError {
    fn code(&self) -> Option<&str> {
        DescribeTaskSetsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeTaskSetsError {
    pub fn new(kind: DescribeTaskSetsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeTaskSetsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeTaskSetsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeTaskSetsErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_client_exception(&self) -> bool {
        matches!(&self.kind, DescribeTaskSetsErrorKind::ClientException(_))
    }
    pub fn is_cluster_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeTaskSetsErrorKind::ClusterNotFoundException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeTaskSetsErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_server_exception(&self) -> bool {
        matches!(&self.kind, DescribeTaskSetsErrorKind::ServerException(_))
    }
    pub fn is_service_not_active_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeTaskSetsErrorKind::ServiceNotActiveException(_)
        )
    }
    pub fn is_service_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeTaskSetsErrorKind::ServiceNotFoundException(_)
        )
    }
    pub fn is_unsupported_feature_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeTaskSetsErrorKind::UnsupportedFeatureException(_)
        )
    }
}
impl std::error::Error for DescribeTaskSetsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeTaskSetsErrorKind::AccessDeniedException(_inner) => Some(_inner),
            DescribeTaskSetsErrorKind::ClientException(_inner) => Some(_inner),
            DescribeTaskSetsErrorKind::ClusterNotFoundException(_inner) => Some(_inner),
            DescribeTaskSetsErrorKind::InvalidParameterException(_inner) => Some(_inner),
            DescribeTaskSetsErrorKind::ServerException(_inner) => Some(_inner),
            DescribeTaskSetsErrorKind::ServiceNotActiveException(_inner) => Some(_inner),
            DescribeTaskSetsErrorKind::ServiceNotFoundException(_inner) => Some(_inner),
            DescribeTaskSetsErrorKind::UnsupportedFeatureException(_inner) => Some(_inner),
            DescribeTaskSetsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DiscoverPollEndpointError {
    pub kind: DiscoverPollEndpointErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DiscoverPollEndpointErrorKind {
    ClientException(crate::error::ClientException),
    ServerException(crate::error::ServerException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DiscoverPollEndpointError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DiscoverPollEndpointErrorKind::ClientException(_inner) => _inner.fmt(f),
            DiscoverPollEndpointErrorKind::ServerException(_inner) => _inner.fmt(f),
            DiscoverPollEndpointErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DiscoverPollEndpointError {
    fn code(&self) -> Option<&str> {
        DiscoverPollEndpointError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DiscoverPollEndpointError {
    pub fn new(kind: DiscoverPollEndpointErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DiscoverPollEndpointErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DiscoverPollEndpointErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            DiscoverPollEndpointErrorKind::ClientException(_)
        )
    }
    pub fn is_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            DiscoverPollEndpointErrorKind::ServerException(_)
        )
    }
}
impl std::error::Error for DiscoverPollEndpointError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DiscoverPollEndpointErrorKind::ClientException(_inner) => Some(_inner),
            DiscoverPollEndpointErrorKind::ServerException(_inner) => Some(_inner),
            DiscoverPollEndpointErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ExecuteCommandError {
    pub kind: ExecuteCommandErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ExecuteCommandErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    ClientException(crate::error::ClientException),
    ClusterNotFoundException(crate::error::ClusterNotFoundException),
    InvalidParameterException(crate::error::InvalidParameterException),
    ServerException(crate::error::ServerException),
    TargetNotConnectedException(crate::error::TargetNotConnectedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ExecuteCommandError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ExecuteCommandErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            ExecuteCommandErrorKind::ClientException(_inner) => _inner.fmt(f),
            ExecuteCommandErrorKind::ClusterNotFoundException(_inner) => _inner.fmt(f),
            ExecuteCommandErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            ExecuteCommandErrorKind::ServerException(_inner) => _inner.fmt(f),
            ExecuteCommandErrorKind::TargetNotConnectedException(_inner) => _inner.fmt(f),
            ExecuteCommandErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ExecuteCommandError {
    fn code(&self) -> Option<&str> {
        ExecuteCommandError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ExecuteCommandError {
    pub fn new(kind: ExecuteCommandErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ExecuteCommandErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ExecuteCommandErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            ExecuteCommandErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_client_exception(&self) -> bool {
        matches!(&self.kind, ExecuteCommandErrorKind::ClientException(_))
    }
    pub fn is_cluster_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            ExecuteCommandErrorKind::ClusterNotFoundException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            ExecuteCommandErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_server_exception(&self) -> bool {
        matches!(&self.kind, ExecuteCommandErrorKind::ServerException(_))
    }
    pub fn is_target_not_connected_exception(&self) -> bool {
        matches!(
            &self.kind,
            ExecuteCommandErrorKind::TargetNotConnectedException(_)
        )
    }
}
impl std::error::Error for ExecuteCommandError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ExecuteCommandErrorKind::AccessDeniedException(_inner) => Some(_inner),
            ExecuteCommandErrorKind::ClientException(_inner) => Some(_inner),
            ExecuteCommandErrorKind::ClusterNotFoundException(_inner) => Some(_inner),
            ExecuteCommandErrorKind::InvalidParameterException(_inner) => Some(_inner),
            ExecuteCommandErrorKind::ServerException(_inner) => Some(_inner),
            ExecuteCommandErrorKind::TargetNotConnectedException(_inner) => Some(_inner),
            ExecuteCommandErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListAccountSettingsError {
    pub kind: ListAccountSettingsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListAccountSettingsErrorKind {
    ClientException(crate::error::ClientException),
    InvalidParameterException(crate::error::InvalidParameterException),
    ServerException(crate::error::ServerException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListAccountSettingsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListAccountSettingsErrorKind::ClientException(_inner) => _inner.fmt(f),
            ListAccountSettingsErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            ListAccountSettingsErrorKind::ServerException(_inner) => _inner.fmt(f),
            ListAccountSettingsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListAccountSettingsError {
    fn code(&self) -> Option<&str> {
        ListAccountSettingsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListAccountSettingsError {
    pub fn new(kind: ListAccountSettingsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListAccountSettingsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListAccountSettingsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_client_exception(&self) -> bool {
        matches!(&self.kind, ListAccountSettingsErrorKind::ClientException(_))
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListAccountSettingsErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_server_exception(&self) -> bool {
        matches!(&self.kind, ListAccountSettingsErrorKind::ServerException(_))
    }
}
impl std::error::Error for ListAccountSettingsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListAccountSettingsErrorKind::ClientException(_inner) => Some(_inner),
            ListAccountSettingsErrorKind::InvalidParameterException(_inner) => Some(_inner),
            ListAccountSettingsErrorKind::ServerException(_inner) => Some(_inner),
            ListAccountSettingsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListAttributesError {
    pub kind: ListAttributesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListAttributesErrorKind {
    ClusterNotFoundException(crate::error::ClusterNotFoundException),
    InvalidParameterException(crate::error::InvalidParameterException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListAttributesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListAttributesErrorKind::ClusterNotFoundException(_inner) => _inner.fmt(f),
            ListAttributesErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            ListAttributesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListAttributesError {
    fn code(&self) -> Option<&str> {
        ListAttributesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListAttributesError {
    pub fn new(kind: ListAttributesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListAttributesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListAttributesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_cluster_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListAttributesErrorKind::ClusterNotFoundException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListAttributesErrorKind::InvalidParameterException(_)
        )
    }
}
impl std::error::Error for ListAttributesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListAttributesErrorKind::ClusterNotFoundException(_inner) => Some(_inner),
            ListAttributesErrorKind::InvalidParameterException(_inner) => Some(_inner),
            ListAttributesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListClustersError {
    pub kind: ListClustersErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListClustersErrorKind {
    ClientException(crate::error::ClientException),
    InvalidParameterException(crate::error::InvalidParameterException),
    ServerException(crate::error::ServerException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListClustersError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListClustersErrorKind::ClientException(_inner) => _inner.fmt(f),
            ListClustersErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            ListClustersErrorKind::ServerException(_inner) => _inner.fmt(f),
            ListClustersErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListClustersError {
    fn code(&self) -> Option<&str> {
        ListClustersError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListClustersError {
    pub fn new(kind: ListClustersErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListClustersErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListClustersErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_client_exception(&self) -> bool {
        matches!(&self.kind, ListClustersErrorKind::ClientException(_))
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListClustersErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_server_exception(&self) -> bool {
        matches!(&self.kind, ListClustersErrorKind::ServerException(_))
    }
}
impl std::error::Error for ListClustersError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListClustersErrorKind::ClientException(_inner) => Some(_inner),
            ListClustersErrorKind::InvalidParameterException(_inner) => Some(_inner),
            ListClustersErrorKind::ServerException(_inner) => Some(_inner),
            ListClustersErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListContainerInstancesError {
    pub kind: ListContainerInstancesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListContainerInstancesErrorKind {
    ClientException(crate::error::ClientException),
    ClusterNotFoundException(crate::error::ClusterNotFoundException),
    InvalidParameterException(crate::error::InvalidParameterException),
    ServerException(crate::error::ServerException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListContainerInstancesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListContainerInstancesErrorKind::ClientException(_inner) => _inner.fmt(f),
            ListContainerInstancesErrorKind::ClusterNotFoundException(_inner) => _inner.fmt(f),
            ListContainerInstancesErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            ListContainerInstancesErrorKind::ServerException(_inner) => _inner.fmt(f),
            ListContainerInstancesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListContainerInstancesError {
    fn code(&self) -> Option<&str> {
        ListContainerInstancesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListContainerInstancesError {
    pub fn new(kind: ListContainerInstancesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListContainerInstancesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListContainerInstancesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListContainerInstancesErrorKind::ClientException(_)
        )
    }
    pub fn is_cluster_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListContainerInstancesErrorKind::ClusterNotFoundException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListContainerInstancesErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListContainerInstancesErrorKind::ServerException(_)
        )
    }
}
impl std::error::Error for ListContainerInstancesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListContainerInstancesErrorKind::ClientException(_inner) => Some(_inner),
            ListContainerInstancesErrorKind::ClusterNotFoundException(_inner) => Some(_inner),
            ListContainerInstancesErrorKind::InvalidParameterException(_inner) => Some(_inner),
            ListContainerInstancesErrorKind::ServerException(_inner) => Some(_inner),
            ListContainerInstancesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListServicesError {
    pub kind: ListServicesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListServicesErrorKind {
    ClientException(crate::error::ClientException),
    ClusterNotFoundException(crate::error::ClusterNotFoundException),
    InvalidParameterException(crate::error::InvalidParameterException),
    ServerException(crate::error::ServerException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListServicesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListServicesErrorKind::ClientException(_inner) => _inner.fmt(f),
            ListServicesErrorKind::ClusterNotFoundException(_inner) => _inner.fmt(f),
            ListServicesErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            ListServicesErrorKind::ServerException(_inner) => _inner.fmt(f),
            ListServicesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListServicesError {
    fn code(&self) -> Option<&str> {
        ListServicesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListServicesError {
    pub fn new(kind: ListServicesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListServicesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListServicesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_client_exception(&self) -> bool {
        matches!(&self.kind, ListServicesErrorKind::ClientException(_))
    }
    pub fn is_cluster_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListServicesErrorKind::ClusterNotFoundException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListServicesErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_server_exception(&self) -> bool {
        matches!(&self.kind, ListServicesErrorKind::ServerException(_))
    }
}
impl std::error::Error for ListServicesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListServicesErrorKind::ClientException(_inner) => Some(_inner),
            ListServicesErrorKind::ClusterNotFoundException(_inner) => Some(_inner),
            ListServicesErrorKind::InvalidParameterException(_inner) => Some(_inner),
            ListServicesErrorKind::ServerException(_inner) => Some(_inner),
            ListServicesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListTagsForResourceError {
    pub kind: ListTagsForResourceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListTagsForResourceErrorKind {
    ClientException(crate::error::ClientException),
    ClusterNotFoundException(crate::error::ClusterNotFoundException),
    InvalidParameterException(crate::error::InvalidParameterException),
    ServerException(crate::error::ServerException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListTagsForResourceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListTagsForResourceErrorKind::ClientException(_inner) => _inner.fmt(f),
            ListTagsForResourceErrorKind::ClusterNotFoundException(_inner) => _inner.fmt(f),
            ListTagsForResourceErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            ListTagsForResourceErrorKind::ServerException(_inner) => _inner.fmt(f),
            ListTagsForResourceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListTagsForResourceError {
    fn code(&self) -> Option<&str> {
        ListTagsForResourceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListTagsForResourceError {
    pub fn new(kind: ListTagsForResourceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListTagsForResourceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListTagsForResourceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_client_exception(&self) -> bool {
        matches!(&self.kind, ListTagsForResourceErrorKind::ClientException(_))
    }
    pub fn is_cluster_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListTagsForResourceErrorKind::ClusterNotFoundException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListTagsForResourceErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_server_exception(&self) -> bool {
        matches!(&self.kind, ListTagsForResourceErrorKind::ServerException(_))
    }
}
impl std::error::Error for ListTagsForResourceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListTagsForResourceErrorKind::ClientException(_inner) => Some(_inner),
            ListTagsForResourceErrorKind::ClusterNotFoundException(_inner) => Some(_inner),
            ListTagsForResourceErrorKind::InvalidParameterException(_inner) => Some(_inner),
            ListTagsForResourceErrorKind::ServerException(_inner) => Some(_inner),
            ListTagsForResourceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListTaskDefinitionFamiliesError {
    pub kind: ListTaskDefinitionFamiliesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListTaskDefinitionFamiliesErrorKind {
    ClientException(crate::error::ClientException),
    InvalidParameterException(crate::error::InvalidParameterException),
    ServerException(crate::error::ServerException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListTaskDefinitionFamiliesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListTaskDefinitionFamiliesErrorKind::ClientException(_inner) => _inner.fmt(f),
            ListTaskDefinitionFamiliesErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            ListTaskDefinitionFamiliesErrorKind::ServerException(_inner) => _inner.fmt(f),
            ListTaskDefinitionFamiliesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListTaskDefinitionFamiliesError {
    fn code(&self) -> Option<&str> {
        ListTaskDefinitionFamiliesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListTaskDefinitionFamiliesError {
    pub fn new(kind: ListTaskDefinitionFamiliesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListTaskDefinitionFamiliesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListTaskDefinitionFamiliesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListTaskDefinitionFamiliesErrorKind::ClientException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListTaskDefinitionFamiliesErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListTaskDefinitionFamiliesErrorKind::ServerException(_)
        )
    }
}
impl std::error::Error for ListTaskDefinitionFamiliesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListTaskDefinitionFamiliesErrorKind::ClientException(_inner) => Some(_inner),
            ListTaskDefinitionFamiliesErrorKind::InvalidParameterException(_inner) => Some(_inner),
            ListTaskDefinitionFamiliesErrorKind::ServerException(_inner) => Some(_inner),
            ListTaskDefinitionFamiliesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListTaskDefinitionsError {
    pub kind: ListTaskDefinitionsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListTaskDefinitionsErrorKind {
    ClientException(crate::error::ClientException),
    InvalidParameterException(crate::error::InvalidParameterException),
    ServerException(crate::error::ServerException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListTaskDefinitionsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListTaskDefinitionsErrorKind::ClientException(_inner) => _inner.fmt(f),
            ListTaskDefinitionsErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            ListTaskDefinitionsErrorKind::ServerException(_inner) => _inner.fmt(f),
            ListTaskDefinitionsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListTaskDefinitionsError {
    fn code(&self) -> Option<&str> {
        ListTaskDefinitionsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListTaskDefinitionsError {
    pub fn new(kind: ListTaskDefinitionsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListTaskDefinitionsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListTaskDefinitionsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_client_exception(&self) -> bool {
        matches!(&self.kind, ListTaskDefinitionsErrorKind::ClientException(_))
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListTaskDefinitionsErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_server_exception(&self) -> bool {
        matches!(&self.kind, ListTaskDefinitionsErrorKind::ServerException(_))
    }
}
impl std::error::Error for ListTaskDefinitionsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListTaskDefinitionsErrorKind::ClientException(_inner) => Some(_inner),
            ListTaskDefinitionsErrorKind::InvalidParameterException(_inner) => Some(_inner),
            ListTaskDefinitionsErrorKind::ServerException(_inner) => Some(_inner),
            ListTaskDefinitionsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListTasksError {
    pub kind: ListTasksErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListTasksErrorKind {
    ClientException(crate::error::ClientException),
    ClusterNotFoundException(crate::error::ClusterNotFoundException),
    InvalidParameterException(crate::error::InvalidParameterException),
    ServerException(crate::error::ServerException),
    ServiceNotFoundException(crate::error::ServiceNotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListTasksError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListTasksErrorKind::ClientException(_inner) => _inner.fmt(f),
            ListTasksErrorKind::ClusterNotFoundException(_inner) => _inner.fmt(f),
            ListTasksErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            ListTasksErrorKind::ServerException(_inner) => _inner.fmt(f),
            ListTasksErrorKind::ServiceNotFoundException(_inner) => _inner.fmt(f),
            ListTasksErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListTasksError {
    fn code(&self) -> Option<&str> {
        ListTasksError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListTasksError {
    pub fn new(kind: ListTasksErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListTasksErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListTasksErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_client_exception(&self) -> bool {
        matches!(&self.kind, ListTasksErrorKind::ClientException(_))
    }
    pub fn is_cluster_not_found_exception(&self) -> bool {
        matches!(&self.kind, ListTasksErrorKind::ClusterNotFoundException(_))
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(&self.kind, ListTasksErrorKind::InvalidParameterException(_))
    }
    pub fn is_server_exception(&self) -> bool {
        matches!(&self.kind, ListTasksErrorKind::ServerException(_))
    }
    pub fn is_service_not_found_exception(&self) -> bool {
        matches!(&self.kind, ListTasksErrorKind::ServiceNotFoundException(_))
    }
}
impl std::error::Error for ListTasksError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListTasksErrorKind::ClientException(_inner) => Some(_inner),
            ListTasksErrorKind::ClusterNotFoundException(_inner) => Some(_inner),
            ListTasksErrorKind::InvalidParameterException(_inner) => Some(_inner),
            ListTasksErrorKind::ServerException(_inner) => Some(_inner),
            ListTasksErrorKind::ServiceNotFoundException(_inner) => Some(_inner),
            ListTasksErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct PutAccountSettingError {
    pub kind: PutAccountSettingErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum PutAccountSettingErrorKind {
    ClientException(crate::error::ClientException),
    InvalidParameterException(crate::error::InvalidParameterException),
    ServerException(crate::error::ServerException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for PutAccountSettingError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            PutAccountSettingErrorKind::ClientException(_inner) => _inner.fmt(f),
            PutAccountSettingErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            PutAccountSettingErrorKind::ServerException(_inner) => _inner.fmt(f),
            PutAccountSettingErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for PutAccountSettingError {
    fn code(&self) -> Option<&str> {
        PutAccountSettingError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl PutAccountSettingError {
    pub fn new(kind: PutAccountSettingErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: PutAccountSettingErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: PutAccountSettingErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_client_exception(&self) -> bool {
        matches!(&self.kind, PutAccountSettingErrorKind::ClientException(_))
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutAccountSettingErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_server_exception(&self) -> bool {
        matches!(&self.kind, PutAccountSettingErrorKind::ServerException(_))
    }
}
impl std::error::Error for PutAccountSettingError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            PutAccountSettingErrorKind::ClientException(_inner) => Some(_inner),
            PutAccountSettingErrorKind::InvalidParameterException(_inner) => Some(_inner),
            PutAccountSettingErrorKind::ServerException(_inner) => Some(_inner),
            PutAccountSettingErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct PutAccountSettingDefaultError {
    pub kind: PutAccountSettingDefaultErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum PutAccountSettingDefaultErrorKind {
    ClientException(crate::error::ClientException),
    InvalidParameterException(crate::error::InvalidParameterException),
    ServerException(crate::error::ServerException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for PutAccountSettingDefaultError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            PutAccountSettingDefaultErrorKind::ClientException(_inner) => _inner.fmt(f),
            PutAccountSettingDefaultErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            PutAccountSettingDefaultErrorKind::ServerException(_inner) => _inner.fmt(f),
            PutAccountSettingDefaultErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for PutAccountSettingDefaultError {
    fn code(&self) -> Option<&str> {
        PutAccountSettingDefaultError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl PutAccountSettingDefaultError {
    pub fn new(kind: PutAccountSettingDefaultErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: PutAccountSettingDefaultErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: PutAccountSettingDefaultErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutAccountSettingDefaultErrorKind::ClientException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutAccountSettingDefaultErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutAccountSettingDefaultErrorKind::ServerException(_)
        )
    }
}
impl std::error::Error for PutAccountSettingDefaultError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            PutAccountSettingDefaultErrorKind::ClientException(_inner) => Some(_inner),
            PutAccountSettingDefaultErrorKind::InvalidParameterException(_inner) => Some(_inner),
            PutAccountSettingDefaultErrorKind::ServerException(_inner) => Some(_inner),
            PutAccountSettingDefaultErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct PutAttributesError {
    pub kind: PutAttributesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum PutAttributesErrorKind {
    AttributeLimitExceededException(crate::error::AttributeLimitExceededException),
    ClusterNotFoundException(crate::error::ClusterNotFoundException),
    InvalidParameterException(crate::error::InvalidParameterException),
    TargetNotFoundException(crate::error::TargetNotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for PutAttributesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            PutAttributesErrorKind::AttributeLimitExceededException(_inner) => _inner.fmt(f),
            PutAttributesErrorKind::ClusterNotFoundException(_inner) => _inner.fmt(f),
            PutAttributesErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            PutAttributesErrorKind::TargetNotFoundException(_inner) => _inner.fmt(f),
            PutAttributesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for PutAttributesError {
    fn code(&self) -> Option<&str> {
        PutAttributesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl PutAttributesError {
    pub fn new(kind: PutAttributesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: PutAttributesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: PutAttributesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_attribute_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutAttributesErrorKind::AttributeLimitExceededException(_)
        )
    }
    pub fn is_cluster_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutAttributesErrorKind::ClusterNotFoundException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutAttributesErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_target_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutAttributesErrorKind::TargetNotFoundException(_)
        )
    }
}
impl std::error::Error for PutAttributesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            PutAttributesErrorKind::AttributeLimitExceededException(_inner) => Some(_inner),
            PutAttributesErrorKind::ClusterNotFoundException(_inner) => Some(_inner),
            PutAttributesErrorKind::InvalidParameterException(_inner) => Some(_inner),
            PutAttributesErrorKind::TargetNotFoundException(_inner) => Some(_inner),
            PutAttributesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct PutClusterCapacityProvidersError {
    pub kind: PutClusterCapacityProvidersErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum PutClusterCapacityProvidersErrorKind {
    ClientException(crate::error::ClientException),
    ClusterNotFoundException(crate::error::ClusterNotFoundException),
    InvalidParameterException(crate::error::InvalidParameterException),
    ResourceInUseException(crate::error::ResourceInUseException),
    ServerException(crate::error::ServerException),
    UpdateInProgressException(crate::error::UpdateInProgressException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for PutClusterCapacityProvidersError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            PutClusterCapacityProvidersErrorKind::ClientException(_inner) => _inner.fmt(f),
            PutClusterCapacityProvidersErrorKind::ClusterNotFoundException(_inner) => _inner.fmt(f),
            PutClusterCapacityProvidersErrorKind::InvalidParameterException(_inner) => {
                _inner.fmt(f)
            }
            PutClusterCapacityProvidersErrorKind::ResourceInUseException(_inner) => _inner.fmt(f),
            PutClusterCapacityProvidersErrorKind::ServerException(_inner) => _inner.fmt(f),
            PutClusterCapacityProvidersErrorKind::UpdateInProgressException(_inner) => {
                _inner.fmt(f)
            }
            PutClusterCapacityProvidersErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for PutClusterCapacityProvidersError {
    fn code(&self) -> Option<&str> {
        PutClusterCapacityProvidersError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl PutClusterCapacityProvidersError {
    pub fn new(kind: PutClusterCapacityProvidersErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: PutClusterCapacityProvidersErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: PutClusterCapacityProvidersErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutClusterCapacityProvidersErrorKind::ClientException(_)
        )
    }
    pub fn is_cluster_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutClusterCapacityProvidersErrorKind::ClusterNotFoundException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutClusterCapacityProvidersErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_resource_in_use_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutClusterCapacityProvidersErrorKind::ResourceInUseException(_)
        )
    }
    pub fn is_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutClusterCapacityProvidersErrorKind::ServerException(_)
        )
    }
    pub fn is_update_in_progress_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutClusterCapacityProvidersErrorKind::UpdateInProgressException(_)
        )
    }
}
impl std::error::Error for PutClusterCapacityProvidersError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            PutClusterCapacityProvidersErrorKind::ClientException(_inner) => Some(_inner),
            PutClusterCapacityProvidersErrorKind::ClusterNotFoundException(_inner) => Some(_inner),
            PutClusterCapacityProvidersErrorKind::InvalidParameterException(_inner) => Some(_inner),
            PutClusterCapacityProvidersErrorKind::ResourceInUseException(_inner) => Some(_inner),
            PutClusterCapacityProvidersErrorKind::ServerException(_inner) => Some(_inner),
            PutClusterCapacityProvidersErrorKind::UpdateInProgressException(_inner) => Some(_inner),
            PutClusterCapacityProvidersErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct RegisterContainerInstanceError {
    pub kind: RegisterContainerInstanceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum RegisterContainerInstanceErrorKind {
    ClientException(crate::error::ClientException),
    InvalidParameterException(crate::error::InvalidParameterException),
    ServerException(crate::error::ServerException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for RegisterContainerInstanceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            RegisterContainerInstanceErrorKind::ClientException(_inner) => _inner.fmt(f),
            RegisterContainerInstanceErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            RegisterContainerInstanceErrorKind::ServerException(_inner) => _inner.fmt(f),
            RegisterContainerInstanceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for RegisterContainerInstanceError {
    fn code(&self) -> Option<&str> {
        RegisterContainerInstanceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl RegisterContainerInstanceError {
    pub fn new(kind: RegisterContainerInstanceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: RegisterContainerInstanceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: RegisterContainerInstanceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            RegisterContainerInstanceErrorKind::ClientException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            RegisterContainerInstanceErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            RegisterContainerInstanceErrorKind::ServerException(_)
        )
    }
}
impl std::error::Error for RegisterContainerInstanceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            RegisterContainerInstanceErrorKind::ClientException(_inner) => Some(_inner),
            RegisterContainerInstanceErrorKind::InvalidParameterException(_inner) => Some(_inner),
            RegisterContainerInstanceErrorKind::ServerException(_inner) => Some(_inner),
            RegisterContainerInstanceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct RegisterTaskDefinitionError {
    pub kind: RegisterTaskDefinitionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum RegisterTaskDefinitionErrorKind {
    ClientException(crate::error::ClientException),
    InvalidParameterException(crate::error::InvalidParameterException),
    ServerException(crate::error::ServerException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for RegisterTaskDefinitionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            RegisterTaskDefinitionErrorKind::ClientException(_inner) => _inner.fmt(f),
            RegisterTaskDefinitionErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            RegisterTaskDefinitionErrorKind::ServerException(_inner) => _inner.fmt(f),
            RegisterTaskDefinitionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for RegisterTaskDefinitionError {
    fn code(&self) -> Option<&str> {
        RegisterTaskDefinitionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl RegisterTaskDefinitionError {
    pub fn new(kind: RegisterTaskDefinitionErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: RegisterTaskDefinitionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: RegisterTaskDefinitionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            RegisterTaskDefinitionErrorKind::ClientException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            RegisterTaskDefinitionErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            RegisterTaskDefinitionErrorKind::ServerException(_)
        )
    }
}
impl std::error::Error for RegisterTaskDefinitionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            RegisterTaskDefinitionErrorKind::ClientException(_inner) => Some(_inner),
            RegisterTaskDefinitionErrorKind::InvalidParameterException(_inner) => Some(_inner),
            RegisterTaskDefinitionErrorKind::ServerException(_inner) => Some(_inner),
            RegisterTaskDefinitionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct RunTaskError {
    pub kind: RunTaskErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum RunTaskErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    BlockedException(crate::error::BlockedException),
    ClientException(crate::error::ClientException),
    ClusterNotFoundException(crate::error::ClusterNotFoundException),
    InvalidParameterException(crate::error::InvalidParameterException),
    PlatformTaskDefinitionIncompatibilityException(
        crate::error::PlatformTaskDefinitionIncompatibilityException,
    ),
    PlatformUnknownException(crate::error::PlatformUnknownException),
    ServerException(crate::error::ServerException),
    UnsupportedFeatureException(crate::error::UnsupportedFeatureException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for RunTaskError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            RunTaskErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            RunTaskErrorKind::BlockedException(_inner) => _inner.fmt(f),
            RunTaskErrorKind::ClientException(_inner) => _inner.fmt(f),
            RunTaskErrorKind::ClusterNotFoundException(_inner) => _inner.fmt(f),
            RunTaskErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            RunTaskErrorKind::PlatformTaskDefinitionIncompatibilityException(_inner) => {
                _inner.fmt(f)
            }
            RunTaskErrorKind::PlatformUnknownException(_inner) => _inner.fmt(f),
            RunTaskErrorKind::ServerException(_inner) => _inner.fmt(f),
            RunTaskErrorKind::UnsupportedFeatureException(_inner) => _inner.fmt(f),
            RunTaskErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for RunTaskError {
    fn code(&self) -> Option<&str> {
        RunTaskError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl RunTaskError {
    pub fn new(kind: RunTaskErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: RunTaskErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: RunTaskErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, RunTaskErrorKind::AccessDeniedException(_))
    }
    pub fn is_blocked_exception(&self) -> bool {
        matches!(&self.kind, RunTaskErrorKind::BlockedException(_))
    }
    pub fn is_client_exception(&self) -> bool {
        matches!(&self.kind, RunTaskErrorKind::ClientException(_))
    }
    pub fn is_cluster_not_found_exception(&self) -> bool {
        matches!(&self.kind, RunTaskErrorKind::ClusterNotFoundException(_))
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(&self.kind, RunTaskErrorKind::InvalidParameterException(_))
    }
    pub fn is_platform_task_definition_incompatibility_exception(&self) -> bool {
        matches!(
            &self.kind,
            RunTaskErrorKind::PlatformTaskDefinitionIncompatibilityException(_)
        )
    }
    pub fn is_platform_unknown_exception(&self) -> bool {
        matches!(&self.kind, RunTaskErrorKind::PlatformUnknownException(_))
    }
    pub fn is_server_exception(&self) -> bool {
        matches!(&self.kind, RunTaskErrorKind::ServerException(_))
    }
    pub fn is_unsupported_feature_exception(&self) -> bool {
        matches!(&self.kind, RunTaskErrorKind::UnsupportedFeatureException(_))
    }
}
impl std::error::Error for RunTaskError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            RunTaskErrorKind::AccessDeniedException(_inner) => Some(_inner),
            RunTaskErrorKind::BlockedException(_inner) => Some(_inner),
            RunTaskErrorKind::ClientException(_inner) => Some(_inner),
            RunTaskErrorKind::ClusterNotFoundException(_inner) => Some(_inner),
            RunTaskErrorKind::InvalidParameterException(_inner) => Some(_inner),
            RunTaskErrorKind::PlatformTaskDefinitionIncompatibilityException(_inner) => {
                Some(_inner)
            }
            RunTaskErrorKind::PlatformUnknownException(_inner) => Some(_inner),
            RunTaskErrorKind::ServerException(_inner) => Some(_inner),
            RunTaskErrorKind::UnsupportedFeatureException(_inner) => Some(_inner),
            RunTaskErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct StartTaskError {
    pub kind: StartTaskErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum StartTaskErrorKind {
    ClientException(crate::error::ClientException),
    ClusterNotFoundException(crate::error::ClusterNotFoundException),
    InvalidParameterException(crate::error::InvalidParameterException),
    ServerException(crate::error::ServerException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for StartTaskError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            StartTaskErrorKind::ClientException(_inner) => _inner.fmt(f),
            StartTaskErrorKind::ClusterNotFoundException(_inner) => _inner.fmt(f),
            StartTaskErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            StartTaskErrorKind::ServerException(_inner) => _inner.fmt(f),
            StartTaskErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for StartTaskError {
    fn code(&self) -> Option<&str> {
        StartTaskError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl StartTaskError {
    pub fn new(kind: StartTaskErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: StartTaskErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: StartTaskErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_client_exception(&self) -> bool {
        matches!(&self.kind, StartTaskErrorKind::ClientException(_))
    }
    pub fn is_cluster_not_found_exception(&self) -> bool {
        matches!(&self.kind, StartTaskErrorKind::ClusterNotFoundException(_))
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(&self.kind, StartTaskErrorKind::InvalidParameterException(_))
    }
    pub fn is_server_exception(&self) -> bool {
        matches!(&self.kind, StartTaskErrorKind::ServerException(_))
    }
}
impl std::error::Error for StartTaskError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            StartTaskErrorKind::ClientException(_inner) => Some(_inner),
            StartTaskErrorKind::ClusterNotFoundException(_inner) => Some(_inner),
            StartTaskErrorKind::InvalidParameterException(_inner) => Some(_inner),
            StartTaskErrorKind::ServerException(_inner) => Some(_inner),
            StartTaskErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct StopTaskError {
    pub kind: StopTaskErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum StopTaskErrorKind {
    ClientException(crate::error::ClientException),
    ClusterNotFoundException(crate::error::ClusterNotFoundException),
    InvalidParameterException(crate::error::InvalidParameterException),
    ServerException(crate::error::ServerException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for StopTaskError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            StopTaskErrorKind::ClientException(_inner) => _inner.fmt(f),
            StopTaskErrorKind::ClusterNotFoundException(_inner) => _inner.fmt(f),
            StopTaskErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            StopTaskErrorKind::ServerException(_inner) => _inner.fmt(f),
            StopTaskErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for StopTaskError {
    fn code(&self) -> Option<&str> {
        StopTaskError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl StopTaskError {
    pub fn new(kind: StopTaskErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: StopTaskErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: StopTaskErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_client_exception(&self) -> bool {
        matches!(&self.kind, StopTaskErrorKind::ClientException(_))
    }
    pub fn is_cluster_not_found_exception(&self) -> bool {
        matches!(&self.kind, StopTaskErrorKind::ClusterNotFoundException(_))
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(&self.kind, StopTaskErrorKind::InvalidParameterException(_))
    }
    pub fn is_server_exception(&self) -> bool {
        matches!(&self.kind, StopTaskErrorKind::ServerException(_))
    }
}
impl std::error::Error for StopTaskError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            StopTaskErrorKind::ClientException(_inner) => Some(_inner),
            StopTaskErrorKind::ClusterNotFoundException(_inner) => Some(_inner),
            StopTaskErrorKind::InvalidParameterException(_inner) => Some(_inner),
            StopTaskErrorKind::ServerException(_inner) => Some(_inner),
            StopTaskErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct SubmitAttachmentStateChangesError {
    pub kind: SubmitAttachmentStateChangesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum SubmitAttachmentStateChangesErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    ClientException(crate::error::ClientException),
    InvalidParameterException(crate::error::InvalidParameterException),
    ServerException(crate::error::ServerException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for SubmitAttachmentStateChangesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            SubmitAttachmentStateChangesErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            SubmitAttachmentStateChangesErrorKind::ClientException(_inner) => _inner.fmt(f),
            SubmitAttachmentStateChangesErrorKind::InvalidParameterException(_inner) => {
                _inner.fmt(f)
            }
            SubmitAttachmentStateChangesErrorKind::ServerException(_inner) => _inner.fmt(f),
            SubmitAttachmentStateChangesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for SubmitAttachmentStateChangesError {
    fn code(&self) -> Option<&str> {
        SubmitAttachmentStateChangesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl SubmitAttachmentStateChangesError {
    pub fn new(kind: SubmitAttachmentStateChangesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: SubmitAttachmentStateChangesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: SubmitAttachmentStateChangesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            SubmitAttachmentStateChangesErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            SubmitAttachmentStateChangesErrorKind::ClientException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            SubmitAttachmentStateChangesErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            SubmitAttachmentStateChangesErrorKind::ServerException(_)
        )
    }
}
impl std::error::Error for SubmitAttachmentStateChangesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            SubmitAttachmentStateChangesErrorKind::AccessDeniedException(_inner) => Some(_inner),
            SubmitAttachmentStateChangesErrorKind::ClientException(_inner) => Some(_inner),
            SubmitAttachmentStateChangesErrorKind::InvalidParameterException(_inner) => {
                Some(_inner)
            }
            SubmitAttachmentStateChangesErrorKind::ServerException(_inner) => Some(_inner),
            SubmitAttachmentStateChangesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct SubmitContainerStateChangeError {
    pub kind: SubmitContainerStateChangeErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum SubmitContainerStateChangeErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    ClientException(crate::error::ClientException),
    ServerException(crate::error::ServerException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for SubmitContainerStateChangeError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            SubmitContainerStateChangeErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            SubmitContainerStateChangeErrorKind::ClientException(_inner) => _inner.fmt(f),
            SubmitContainerStateChangeErrorKind::ServerException(_inner) => _inner.fmt(f),
            SubmitContainerStateChangeErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for SubmitContainerStateChangeError {
    fn code(&self) -> Option<&str> {
        SubmitContainerStateChangeError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl SubmitContainerStateChangeError {
    pub fn new(kind: SubmitContainerStateChangeErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: SubmitContainerStateChangeErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: SubmitContainerStateChangeErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            SubmitContainerStateChangeErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            SubmitContainerStateChangeErrorKind::ClientException(_)
        )
    }
    pub fn is_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            SubmitContainerStateChangeErrorKind::ServerException(_)
        )
    }
}
impl std::error::Error for SubmitContainerStateChangeError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            SubmitContainerStateChangeErrorKind::AccessDeniedException(_inner) => Some(_inner),
            SubmitContainerStateChangeErrorKind::ClientException(_inner) => Some(_inner),
            SubmitContainerStateChangeErrorKind::ServerException(_inner) => Some(_inner),
            SubmitContainerStateChangeErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct SubmitTaskStateChangeError {
    pub kind: SubmitTaskStateChangeErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum SubmitTaskStateChangeErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    ClientException(crate::error::ClientException),
    InvalidParameterException(crate::error::InvalidParameterException),
    ServerException(crate::error::ServerException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for SubmitTaskStateChangeError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            SubmitTaskStateChangeErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            SubmitTaskStateChangeErrorKind::ClientException(_inner) => _inner.fmt(f),
            SubmitTaskStateChangeErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            SubmitTaskStateChangeErrorKind::ServerException(_inner) => _inner.fmt(f),
            SubmitTaskStateChangeErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for SubmitTaskStateChangeError {
    fn code(&self) -> Option<&str> {
        SubmitTaskStateChangeError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl SubmitTaskStateChangeError {
    pub fn new(kind: SubmitTaskStateChangeErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: SubmitTaskStateChangeErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: SubmitTaskStateChangeErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            SubmitTaskStateChangeErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            SubmitTaskStateChangeErrorKind::ClientException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            SubmitTaskStateChangeErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            SubmitTaskStateChangeErrorKind::ServerException(_)
        )
    }
}
impl std::error::Error for SubmitTaskStateChangeError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            SubmitTaskStateChangeErrorKind::AccessDeniedException(_inner) => Some(_inner),
            SubmitTaskStateChangeErrorKind::ClientException(_inner) => Some(_inner),
            SubmitTaskStateChangeErrorKind::InvalidParameterException(_inner) => Some(_inner),
            SubmitTaskStateChangeErrorKind::ServerException(_inner) => Some(_inner),
            SubmitTaskStateChangeErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct TagResourceError {
    pub kind: TagResourceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum TagResourceErrorKind {
    ClientException(crate::error::ClientException),
    ClusterNotFoundException(crate::error::ClusterNotFoundException),
    InvalidParameterException(crate::error::InvalidParameterException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServerException(crate::error::ServerException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for TagResourceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            TagResourceErrorKind::ClientException(_inner) => _inner.fmt(f),
            TagResourceErrorKind::ClusterNotFoundException(_inner) => _inner.fmt(f),
            TagResourceErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            TagResourceErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            TagResourceErrorKind::ServerException(_inner) => _inner.fmt(f),
            TagResourceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for TagResourceError {
    fn code(&self) -> Option<&str> {
        TagResourceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl TagResourceError {
    pub fn new(kind: TagResourceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: TagResourceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: TagResourceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_client_exception(&self) -> bool {
        matches!(&self.kind, TagResourceErrorKind::ClientException(_))
    }
    pub fn is_cluster_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            TagResourceErrorKind::ClusterNotFoundException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            TagResourceErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            TagResourceErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_server_exception(&self) -> bool {
        matches!(&self.kind, TagResourceErrorKind::ServerException(_))
    }
}
impl std::error::Error for TagResourceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            TagResourceErrorKind::ClientException(_inner) => Some(_inner),
            TagResourceErrorKind::ClusterNotFoundException(_inner) => Some(_inner),
            TagResourceErrorKind::InvalidParameterException(_inner) => Some(_inner),
            TagResourceErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            TagResourceErrorKind::ServerException(_inner) => Some(_inner),
            TagResourceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UntagResourceError {
    pub kind: UntagResourceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UntagResourceErrorKind {
    ClientException(crate::error::ClientException),
    ClusterNotFoundException(crate::error::ClusterNotFoundException),
    InvalidParameterException(crate::error::InvalidParameterException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServerException(crate::error::ServerException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UntagResourceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UntagResourceErrorKind::ClientException(_inner) => _inner.fmt(f),
            UntagResourceErrorKind::ClusterNotFoundException(_inner) => _inner.fmt(f),
            UntagResourceErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            UntagResourceErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            UntagResourceErrorKind::ServerException(_inner) => _inner.fmt(f),
            UntagResourceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UntagResourceError {
    fn code(&self) -> Option<&str> {
        UntagResourceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UntagResourceError {
    pub fn new(kind: UntagResourceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UntagResourceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UntagResourceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_client_exception(&self) -> bool {
        matches!(&self.kind, UntagResourceErrorKind::ClientException(_))
    }
    pub fn is_cluster_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UntagResourceErrorKind::ClusterNotFoundException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            UntagResourceErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UntagResourceErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_server_exception(&self) -> bool {
        matches!(&self.kind, UntagResourceErrorKind::ServerException(_))
    }
}
impl std::error::Error for UntagResourceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UntagResourceErrorKind::ClientException(_inner) => Some(_inner),
            UntagResourceErrorKind::ClusterNotFoundException(_inner) => Some(_inner),
            UntagResourceErrorKind::InvalidParameterException(_inner) => Some(_inner),
            UntagResourceErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            UntagResourceErrorKind::ServerException(_inner) => Some(_inner),
            UntagResourceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateCapacityProviderError {
    pub kind: UpdateCapacityProviderErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateCapacityProviderErrorKind {
    ClientException(crate::error::ClientException),
    InvalidParameterException(crate::error::InvalidParameterException),
    ServerException(crate::error::ServerException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateCapacityProviderError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateCapacityProviderErrorKind::ClientException(_inner) => _inner.fmt(f),
            UpdateCapacityProviderErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            UpdateCapacityProviderErrorKind::ServerException(_inner) => _inner.fmt(f),
            UpdateCapacityProviderErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateCapacityProviderError {
    fn code(&self) -> Option<&str> {
        UpdateCapacityProviderError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateCapacityProviderError {
    pub fn new(kind: UpdateCapacityProviderErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateCapacityProviderErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateCapacityProviderErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateCapacityProviderErrorKind::ClientException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateCapacityProviderErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateCapacityProviderErrorKind::ServerException(_)
        )
    }
}
impl std::error::Error for UpdateCapacityProviderError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateCapacityProviderErrorKind::ClientException(_inner) => Some(_inner),
            UpdateCapacityProviderErrorKind::InvalidParameterException(_inner) => Some(_inner),
            UpdateCapacityProviderErrorKind::ServerException(_inner) => Some(_inner),
            UpdateCapacityProviderErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateClusterError {
    pub kind: UpdateClusterErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateClusterErrorKind {
    ClientException(crate::error::ClientException),
    ClusterNotFoundException(crate::error::ClusterNotFoundException),
    InvalidParameterException(crate::error::InvalidParameterException),
    ServerException(crate::error::ServerException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateClusterError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateClusterErrorKind::ClientException(_inner) => _inner.fmt(f),
            UpdateClusterErrorKind::ClusterNotFoundException(_inner) => _inner.fmt(f),
            UpdateClusterErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            UpdateClusterErrorKind::ServerException(_inner) => _inner.fmt(f),
            UpdateClusterErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateClusterError {
    fn code(&self) -> Option<&str> {
        UpdateClusterError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateClusterError {
    pub fn new(kind: UpdateClusterErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateClusterErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateClusterErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_client_exception(&self) -> bool {
        matches!(&self.kind, UpdateClusterErrorKind::ClientException(_))
    }
    pub fn is_cluster_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateClusterErrorKind::ClusterNotFoundException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateClusterErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_server_exception(&self) -> bool {
        matches!(&self.kind, UpdateClusterErrorKind::ServerException(_))
    }
}
impl std::error::Error for UpdateClusterError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateClusterErrorKind::ClientException(_inner) => Some(_inner),
            UpdateClusterErrorKind::ClusterNotFoundException(_inner) => Some(_inner),
            UpdateClusterErrorKind::InvalidParameterException(_inner) => Some(_inner),
            UpdateClusterErrorKind::ServerException(_inner) => Some(_inner),
            UpdateClusterErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateClusterSettingsError {
    pub kind: UpdateClusterSettingsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateClusterSettingsErrorKind {
    ClientException(crate::error::ClientException),
    ClusterNotFoundException(crate::error::ClusterNotFoundException),
    InvalidParameterException(crate::error::InvalidParameterException),
    ServerException(crate::error::ServerException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateClusterSettingsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateClusterSettingsErrorKind::ClientException(_inner) => _inner.fmt(f),
            UpdateClusterSettingsErrorKind::ClusterNotFoundException(_inner) => _inner.fmt(f),
            UpdateClusterSettingsErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            UpdateClusterSettingsErrorKind::ServerException(_inner) => _inner.fmt(f),
            UpdateClusterSettingsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateClusterSettingsError {
    fn code(&self) -> Option<&str> {
        UpdateClusterSettingsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateClusterSettingsError {
    pub fn new(kind: UpdateClusterSettingsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateClusterSettingsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateClusterSettingsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateClusterSettingsErrorKind::ClientException(_)
        )
    }
    pub fn is_cluster_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateClusterSettingsErrorKind::ClusterNotFoundException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateClusterSettingsErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateClusterSettingsErrorKind::ServerException(_)
        )
    }
}
impl std::error::Error for UpdateClusterSettingsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateClusterSettingsErrorKind::ClientException(_inner) => Some(_inner),
            UpdateClusterSettingsErrorKind::ClusterNotFoundException(_inner) => Some(_inner),
            UpdateClusterSettingsErrorKind::InvalidParameterException(_inner) => Some(_inner),
            UpdateClusterSettingsErrorKind::ServerException(_inner) => Some(_inner),
            UpdateClusterSettingsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateContainerAgentError {
    pub kind: UpdateContainerAgentErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateContainerAgentErrorKind {
    ClientException(crate::error::ClientException),
    ClusterNotFoundException(crate::error::ClusterNotFoundException),
    InvalidParameterException(crate::error::InvalidParameterException),
    MissingVersionException(crate::error::MissingVersionException),
    NoUpdateAvailableException(crate::error::NoUpdateAvailableException),
    ServerException(crate::error::ServerException),
    UpdateInProgressException(crate::error::UpdateInProgressException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateContainerAgentError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateContainerAgentErrorKind::ClientException(_inner) => _inner.fmt(f),
            UpdateContainerAgentErrorKind::ClusterNotFoundException(_inner) => _inner.fmt(f),
            UpdateContainerAgentErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            UpdateContainerAgentErrorKind::MissingVersionException(_inner) => _inner.fmt(f),
            UpdateContainerAgentErrorKind::NoUpdateAvailableException(_inner) => _inner.fmt(f),
            UpdateContainerAgentErrorKind::ServerException(_inner) => _inner.fmt(f),
            UpdateContainerAgentErrorKind::UpdateInProgressException(_inner) => _inner.fmt(f),
            UpdateContainerAgentErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateContainerAgentError {
    fn code(&self) -> Option<&str> {
        UpdateContainerAgentError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateContainerAgentError {
    pub fn new(kind: UpdateContainerAgentErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateContainerAgentErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateContainerAgentErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateContainerAgentErrorKind::ClientException(_)
        )
    }
    pub fn is_cluster_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateContainerAgentErrorKind::ClusterNotFoundException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateContainerAgentErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_missing_version_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateContainerAgentErrorKind::MissingVersionException(_)
        )
    }
    pub fn is_no_update_available_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateContainerAgentErrorKind::NoUpdateAvailableException(_)
        )
    }
    pub fn is_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateContainerAgentErrorKind::ServerException(_)
        )
    }
    pub fn is_update_in_progress_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateContainerAgentErrorKind::UpdateInProgressException(_)
        )
    }
}
impl std::error::Error for UpdateContainerAgentError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateContainerAgentErrorKind::ClientException(_inner) => Some(_inner),
            UpdateContainerAgentErrorKind::ClusterNotFoundException(_inner) => Some(_inner),
            UpdateContainerAgentErrorKind::InvalidParameterException(_inner) => Some(_inner),
            UpdateContainerAgentErrorKind::MissingVersionException(_inner) => Some(_inner),
            UpdateContainerAgentErrorKind::NoUpdateAvailableException(_inner) => Some(_inner),
            UpdateContainerAgentErrorKind::ServerException(_inner) => Some(_inner),
            UpdateContainerAgentErrorKind::UpdateInProgressException(_inner) => Some(_inner),
            UpdateContainerAgentErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateContainerInstancesStateError {
    pub kind: UpdateContainerInstancesStateErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateContainerInstancesStateErrorKind {
    ClientException(crate::error::ClientException),
    ClusterNotFoundException(crate::error::ClusterNotFoundException),
    InvalidParameterException(crate::error::InvalidParameterException),
    ServerException(crate::error::ServerException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateContainerInstancesStateError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateContainerInstancesStateErrorKind::ClientException(_inner) => _inner.fmt(f),
            UpdateContainerInstancesStateErrorKind::ClusterNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            UpdateContainerInstancesStateErrorKind::InvalidParameterException(_inner) => {
                _inner.fmt(f)
            }
            UpdateContainerInstancesStateErrorKind::ServerException(_inner) => _inner.fmt(f),
            UpdateContainerInstancesStateErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateContainerInstancesStateError {
    fn code(&self) -> Option<&str> {
        UpdateContainerInstancesStateError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateContainerInstancesStateError {
    pub fn new(kind: UpdateContainerInstancesStateErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateContainerInstancesStateErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateContainerInstancesStateErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateContainerInstancesStateErrorKind::ClientException(_)
        )
    }
    pub fn is_cluster_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateContainerInstancesStateErrorKind::ClusterNotFoundException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateContainerInstancesStateErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateContainerInstancesStateErrorKind::ServerException(_)
        )
    }
}
impl std::error::Error for UpdateContainerInstancesStateError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateContainerInstancesStateErrorKind::ClientException(_inner) => Some(_inner),
            UpdateContainerInstancesStateErrorKind::ClusterNotFoundException(_inner) => {
                Some(_inner)
            }
            UpdateContainerInstancesStateErrorKind::InvalidParameterException(_inner) => {
                Some(_inner)
            }
            UpdateContainerInstancesStateErrorKind::ServerException(_inner) => Some(_inner),
            UpdateContainerInstancesStateErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateServiceError {
    pub kind: UpdateServiceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateServiceErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    ClientException(crate::error::ClientException),
    ClusterNotFoundException(crate::error::ClusterNotFoundException),
    InvalidParameterException(crate::error::InvalidParameterException),
    PlatformTaskDefinitionIncompatibilityException(
        crate::error::PlatformTaskDefinitionIncompatibilityException,
    ),
    PlatformUnknownException(crate::error::PlatformUnknownException),
    ServerException(crate::error::ServerException),
    ServiceNotActiveException(crate::error::ServiceNotActiveException),
    ServiceNotFoundException(crate::error::ServiceNotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateServiceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateServiceErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            UpdateServiceErrorKind::ClientException(_inner) => _inner.fmt(f),
            UpdateServiceErrorKind::ClusterNotFoundException(_inner) => _inner.fmt(f),
            UpdateServiceErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            UpdateServiceErrorKind::PlatformTaskDefinitionIncompatibilityException(_inner) => {
                _inner.fmt(f)
            }
            UpdateServiceErrorKind::PlatformUnknownException(_inner) => _inner.fmt(f),
            UpdateServiceErrorKind::ServerException(_inner) => _inner.fmt(f),
            UpdateServiceErrorKind::ServiceNotActiveException(_inner) => _inner.fmt(f),
            UpdateServiceErrorKind::ServiceNotFoundException(_inner) => _inner.fmt(f),
            UpdateServiceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateServiceError {
    fn code(&self) -> Option<&str> {
        UpdateServiceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateServiceError {
    pub fn new(kind: UpdateServiceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateServiceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateServiceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, UpdateServiceErrorKind::AccessDeniedException(_))
    }
    pub fn is_client_exception(&self) -> bool {
        matches!(&self.kind, UpdateServiceErrorKind::ClientException(_))
    }
    pub fn is_cluster_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateServiceErrorKind::ClusterNotFoundException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateServiceErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_platform_task_definition_incompatibility_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateServiceErrorKind::PlatformTaskDefinitionIncompatibilityException(_)
        )
    }
    pub fn is_platform_unknown_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateServiceErrorKind::PlatformUnknownException(_)
        )
    }
    pub fn is_server_exception(&self) -> bool {
        matches!(&self.kind, UpdateServiceErrorKind::ServerException(_))
    }
    pub fn is_service_not_active_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateServiceErrorKind::ServiceNotActiveException(_)
        )
    }
    pub fn is_service_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateServiceErrorKind::ServiceNotFoundException(_)
        )
    }
}
impl std::error::Error for UpdateServiceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateServiceErrorKind::AccessDeniedException(_inner) => Some(_inner),
            UpdateServiceErrorKind::ClientException(_inner) => Some(_inner),
            UpdateServiceErrorKind::ClusterNotFoundException(_inner) => Some(_inner),
            UpdateServiceErrorKind::InvalidParameterException(_inner) => Some(_inner),
            UpdateServiceErrorKind::PlatformTaskDefinitionIncompatibilityException(_inner) => {
                Some(_inner)
            }
            UpdateServiceErrorKind::PlatformUnknownException(_inner) => Some(_inner),
            UpdateServiceErrorKind::ServerException(_inner) => Some(_inner),
            UpdateServiceErrorKind::ServiceNotActiveException(_inner) => Some(_inner),
            UpdateServiceErrorKind::ServiceNotFoundException(_inner) => Some(_inner),
            UpdateServiceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateServicePrimaryTaskSetError {
    pub kind: UpdateServicePrimaryTaskSetErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateServicePrimaryTaskSetErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    ClientException(crate::error::ClientException),
    ClusterNotFoundException(crate::error::ClusterNotFoundException),
    InvalidParameterException(crate::error::InvalidParameterException),
    ServerException(crate::error::ServerException),
    ServiceNotActiveException(crate::error::ServiceNotActiveException),
    ServiceNotFoundException(crate::error::ServiceNotFoundException),
    TaskSetNotFoundException(crate::error::TaskSetNotFoundException),
    UnsupportedFeatureException(crate::error::UnsupportedFeatureException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateServicePrimaryTaskSetError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateServicePrimaryTaskSetErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            UpdateServicePrimaryTaskSetErrorKind::ClientException(_inner) => _inner.fmt(f),
            UpdateServicePrimaryTaskSetErrorKind::ClusterNotFoundException(_inner) => _inner.fmt(f),
            UpdateServicePrimaryTaskSetErrorKind::InvalidParameterException(_inner) => {
                _inner.fmt(f)
            }
            UpdateServicePrimaryTaskSetErrorKind::ServerException(_inner) => _inner.fmt(f),
            UpdateServicePrimaryTaskSetErrorKind::ServiceNotActiveException(_inner) => {
                _inner.fmt(f)
            }
            UpdateServicePrimaryTaskSetErrorKind::ServiceNotFoundException(_inner) => _inner.fmt(f),
            UpdateServicePrimaryTaskSetErrorKind::TaskSetNotFoundException(_inner) => _inner.fmt(f),
            UpdateServicePrimaryTaskSetErrorKind::UnsupportedFeatureException(_inner) => {
                _inner.fmt(f)
            }
            UpdateServicePrimaryTaskSetErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateServicePrimaryTaskSetError {
    fn code(&self) -> Option<&str> {
        UpdateServicePrimaryTaskSetError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateServicePrimaryTaskSetError {
    pub fn new(kind: UpdateServicePrimaryTaskSetErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateServicePrimaryTaskSetErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateServicePrimaryTaskSetErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateServicePrimaryTaskSetErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateServicePrimaryTaskSetErrorKind::ClientException(_)
        )
    }
    pub fn is_cluster_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateServicePrimaryTaskSetErrorKind::ClusterNotFoundException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateServicePrimaryTaskSetErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateServicePrimaryTaskSetErrorKind::ServerException(_)
        )
    }
    pub fn is_service_not_active_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateServicePrimaryTaskSetErrorKind::ServiceNotActiveException(_)
        )
    }
    pub fn is_service_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateServicePrimaryTaskSetErrorKind::ServiceNotFoundException(_)
        )
    }
    pub fn is_task_set_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateServicePrimaryTaskSetErrorKind::TaskSetNotFoundException(_)
        )
    }
    pub fn is_unsupported_feature_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateServicePrimaryTaskSetErrorKind::UnsupportedFeatureException(_)
        )
    }
}
impl std::error::Error for UpdateServicePrimaryTaskSetError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateServicePrimaryTaskSetErrorKind::AccessDeniedException(_inner) => Some(_inner),
            UpdateServicePrimaryTaskSetErrorKind::ClientException(_inner) => Some(_inner),
            UpdateServicePrimaryTaskSetErrorKind::ClusterNotFoundException(_inner) => Some(_inner),
            UpdateServicePrimaryTaskSetErrorKind::InvalidParameterException(_inner) => Some(_inner),
            UpdateServicePrimaryTaskSetErrorKind::ServerException(_inner) => Some(_inner),
            UpdateServicePrimaryTaskSetErrorKind::ServiceNotActiveException(_inner) => Some(_inner),
            UpdateServicePrimaryTaskSetErrorKind::ServiceNotFoundException(_inner) => Some(_inner),
            UpdateServicePrimaryTaskSetErrorKind::TaskSetNotFoundException(_inner) => Some(_inner),
            UpdateServicePrimaryTaskSetErrorKind::UnsupportedFeatureException(_inner) => {
                Some(_inner)
            }
            UpdateServicePrimaryTaskSetErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateTaskSetError {
    pub kind: UpdateTaskSetErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateTaskSetErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    ClientException(crate::error::ClientException),
    ClusterNotFoundException(crate::error::ClusterNotFoundException),
    InvalidParameterException(crate::error::InvalidParameterException),
    ServerException(crate::error::ServerException),
    ServiceNotActiveException(crate::error::ServiceNotActiveException),
    ServiceNotFoundException(crate::error::ServiceNotFoundException),
    TaskSetNotFoundException(crate::error::TaskSetNotFoundException),
    UnsupportedFeatureException(crate::error::UnsupportedFeatureException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateTaskSetError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateTaskSetErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            UpdateTaskSetErrorKind::ClientException(_inner) => _inner.fmt(f),
            UpdateTaskSetErrorKind::ClusterNotFoundException(_inner) => _inner.fmt(f),
            UpdateTaskSetErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            UpdateTaskSetErrorKind::ServerException(_inner) => _inner.fmt(f),
            UpdateTaskSetErrorKind::ServiceNotActiveException(_inner) => _inner.fmt(f),
            UpdateTaskSetErrorKind::ServiceNotFoundException(_inner) => _inner.fmt(f),
            UpdateTaskSetErrorKind::TaskSetNotFoundException(_inner) => _inner.fmt(f),
            UpdateTaskSetErrorKind::UnsupportedFeatureException(_inner) => _inner.fmt(f),
            UpdateTaskSetErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateTaskSetError {
    fn code(&self) -> Option<&str> {
        UpdateTaskSetError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateTaskSetError {
    pub fn new(kind: UpdateTaskSetErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateTaskSetErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateTaskSetErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, UpdateTaskSetErrorKind::AccessDeniedException(_))
    }
    pub fn is_client_exception(&self) -> bool {
        matches!(&self.kind, UpdateTaskSetErrorKind::ClientException(_))
    }
    pub fn is_cluster_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateTaskSetErrorKind::ClusterNotFoundException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateTaskSetErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_server_exception(&self) -> bool {
        matches!(&self.kind, UpdateTaskSetErrorKind::ServerException(_))
    }
    pub fn is_service_not_active_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateTaskSetErrorKind::ServiceNotActiveException(_)
        )
    }
    pub fn is_service_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateTaskSetErrorKind::ServiceNotFoundException(_)
        )
    }
    pub fn is_task_set_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateTaskSetErrorKind::TaskSetNotFoundException(_)
        )
    }
    pub fn is_unsupported_feature_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateTaskSetErrorKind::UnsupportedFeatureException(_)
        )
    }
}
impl std::error::Error for UpdateTaskSetError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateTaskSetErrorKind::AccessDeniedException(_inner) => Some(_inner),
            UpdateTaskSetErrorKind::ClientException(_inner) => Some(_inner),
            UpdateTaskSetErrorKind::ClusterNotFoundException(_inner) => Some(_inner),
            UpdateTaskSetErrorKind::InvalidParameterException(_inner) => Some(_inner),
            UpdateTaskSetErrorKind::ServerException(_inner) => Some(_inner),
            UpdateTaskSetErrorKind::ServiceNotActiveException(_inner) => Some(_inner),
            UpdateTaskSetErrorKind::ServiceNotFoundException(_inner) => Some(_inner),
            UpdateTaskSetErrorKind::TaskSetNotFoundException(_inner) => Some(_inner),
            UpdateTaskSetErrorKind::UnsupportedFeatureException(_inner) => Some(_inner),
            UpdateTaskSetErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// <p>The specified task is not supported in this Region.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UnsupportedFeatureException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for UnsupportedFeatureException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UnsupportedFeatureException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl UnsupportedFeatureException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for UnsupportedFeatureException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "UnsupportedFeatureException")?;
        if let Some(inner_1) = &self.message {
            write!(f, ": {}", inner_1)?;
        }
        Ok(())
    }
}
impl std::error::Error for UnsupportedFeatureException {}
/// See [`UnsupportedFeatureException`](crate::error::UnsupportedFeatureException)
pub mod unsupported_feature_exception {
    /// A builder for [`UnsupportedFeatureException`](crate::error::UnsupportedFeatureException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`UnsupportedFeatureException`](crate::error::UnsupportedFeatureException)
        pub fn build(self) -> crate::error::UnsupportedFeatureException {
            crate::error::UnsupportedFeatureException {
                message: self.message,
            }
        }
    }
}
impl UnsupportedFeatureException {
    /// Creates a new builder-style object to manufacture [`UnsupportedFeatureException`](crate::error::UnsupportedFeatureException)
    pub fn builder() -> crate::error::unsupported_feature_exception::Builder {
        crate::error::unsupported_feature_exception::Builder::default()
    }
}

/// <p>The specified task set could not be found. You can view your available task sets with
/// <a>DescribeTaskSets</a>. Task sets are specific to each cluster, service
/// and Region.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TaskSetNotFoundException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for TaskSetNotFoundException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TaskSetNotFoundException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl TaskSetNotFoundException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for TaskSetNotFoundException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "TaskSetNotFoundException")?;
        if let Some(inner_2) = &self.message {
            write!(f, ": {}", inner_2)?;
        }
        Ok(())
    }
}
impl std::error::Error for TaskSetNotFoundException {}
/// See [`TaskSetNotFoundException`](crate::error::TaskSetNotFoundException)
pub mod task_set_not_found_exception {
    /// A builder for [`TaskSetNotFoundException`](crate::error::TaskSetNotFoundException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`TaskSetNotFoundException`](crate::error::TaskSetNotFoundException)
        pub fn build(self) -> crate::error::TaskSetNotFoundException {
            crate::error::TaskSetNotFoundException {
                message: self.message,
            }
        }
    }
}
impl TaskSetNotFoundException {
    /// Creates a new builder-style object to manufacture [`TaskSetNotFoundException`](crate::error::TaskSetNotFoundException)
    pub fn builder() -> crate::error::task_set_not_found_exception::Builder {
        crate::error::task_set_not_found_exception::Builder::default()
    }
}

/// <p>The specified service could not be found. You can view your available services with
/// <a>ListServices</a>. Amazon ECS services are cluster-specific and
/// Region-specific.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ServiceNotFoundException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ServiceNotFoundException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ServiceNotFoundException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ServiceNotFoundException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ServiceNotFoundException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ServiceNotFoundException")?;
        if let Some(inner_3) = &self.message {
            write!(f, ": {}", inner_3)?;
        }
        Ok(())
    }
}
impl std::error::Error for ServiceNotFoundException {}
/// See [`ServiceNotFoundException`](crate::error::ServiceNotFoundException)
pub mod service_not_found_exception {
    /// A builder for [`ServiceNotFoundException`](crate::error::ServiceNotFoundException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ServiceNotFoundException`](crate::error::ServiceNotFoundException)
        pub fn build(self) -> crate::error::ServiceNotFoundException {
            crate::error::ServiceNotFoundException {
                message: self.message,
            }
        }
    }
}
impl ServiceNotFoundException {
    /// Creates a new builder-style object to manufacture [`ServiceNotFoundException`](crate::error::ServiceNotFoundException)
    pub fn builder() -> crate::error::service_not_found_exception::Builder {
        crate::error::service_not_found_exception::Builder::default()
    }
}

/// <p>The specified service is not active. You can't update a service that is inactive. If
/// you have previously deleted a service, you can re-create it with <a>CreateService</a>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ServiceNotActiveException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ServiceNotActiveException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ServiceNotActiveException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ServiceNotActiveException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ServiceNotActiveException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ServiceNotActiveException")?;
        if let Some(inner_4) = &self.message {
            write!(f, ": {}", inner_4)?;
        }
        Ok(())
    }
}
impl std::error::Error for ServiceNotActiveException {}
/// See [`ServiceNotActiveException`](crate::error::ServiceNotActiveException)
pub mod service_not_active_exception {
    /// A builder for [`ServiceNotActiveException`](crate::error::ServiceNotActiveException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ServiceNotActiveException`](crate::error::ServiceNotActiveException)
        pub fn build(self) -> crate::error::ServiceNotActiveException {
            crate::error::ServiceNotActiveException {
                message: self.message,
            }
        }
    }
}
impl ServiceNotActiveException {
    /// Creates a new builder-style object to manufacture [`ServiceNotActiveException`](crate::error::ServiceNotActiveException)
    pub fn builder() -> crate::error::service_not_active_exception::Builder {
        crate::error::service_not_active_exception::Builder::default()
    }
}

/// <p>These errors are usually caused by a server issue.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ServerException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ServerException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ServerException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ServerException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ServerException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ServerException")?;
        if let Some(inner_5) = &self.message {
            write!(f, ": {}", inner_5)?;
        }
        Ok(())
    }
}
impl std::error::Error for ServerException {}
/// See [`ServerException`](crate::error::ServerException)
pub mod server_exception {
    /// A builder for [`ServerException`](crate::error::ServerException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ServerException`](crate::error::ServerException)
        pub fn build(self) -> crate::error::ServerException {
            crate::error::ServerException {
                message: self.message,
            }
        }
    }
}
impl ServerException {
    /// Creates a new builder-style object to manufacture [`ServerException`](crate::error::ServerException)
    pub fn builder() -> crate::error::server_exception::Builder {
        crate::error::server_exception::Builder::default()
    }
}

/// <p>The specified parameter is invalid. Review the available parameters for the API
/// request.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidParameterException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidParameterException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidParameterException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidParameterException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidParameterException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidParameterException")?;
        if let Some(inner_6) = &self.message {
            write!(f, ": {}", inner_6)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidParameterException {}
/// See [`InvalidParameterException`](crate::error::InvalidParameterException)
pub mod invalid_parameter_exception {
    /// A builder for [`InvalidParameterException`](crate::error::InvalidParameterException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidParameterException`](crate::error::InvalidParameterException)
        pub fn build(self) -> crate::error::InvalidParameterException {
            crate::error::InvalidParameterException {
                message: self.message,
            }
        }
    }
}
impl InvalidParameterException {
    /// Creates a new builder-style object to manufacture [`InvalidParameterException`](crate::error::InvalidParameterException)
    pub fn builder() -> crate::error::invalid_parameter_exception::Builder {
        crate::error::invalid_parameter_exception::Builder::default()
    }
}

/// <p>The specified cluster could not be found. You can view your available clusters with
/// <a>ListClusters</a>. Amazon ECS clusters are Region-specific.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ClusterNotFoundException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ClusterNotFoundException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ClusterNotFoundException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ClusterNotFoundException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ClusterNotFoundException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ClusterNotFoundException")?;
        if let Some(inner_7) = &self.message {
            write!(f, ": {}", inner_7)?;
        }
        Ok(())
    }
}
impl std::error::Error for ClusterNotFoundException {}
/// See [`ClusterNotFoundException`](crate::error::ClusterNotFoundException)
pub mod cluster_not_found_exception {
    /// A builder for [`ClusterNotFoundException`](crate::error::ClusterNotFoundException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ClusterNotFoundException`](crate::error::ClusterNotFoundException)
        pub fn build(self) -> crate::error::ClusterNotFoundException {
            crate::error::ClusterNotFoundException {
                message: self.message,
            }
        }
    }
}
impl ClusterNotFoundException {
    /// Creates a new builder-style object to manufacture [`ClusterNotFoundException`](crate::error::ClusterNotFoundException)
    pub fn builder() -> crate::error::cluster_not_found_exception::Builder {
        crate::error::cluster_not_found_exception::Builder::default()
    }
}

/// <p>These errors are usually caused by a client action, such as using an action or
/// resource on behalf of a user that doesn't have permissions to use the action or
/// resource, or specifying an identifier that is not valid.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ClientException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ClientException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ClientException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ClientException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ClientException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ClientException")?;
        if let Some(inner_8) = &self.message {
            write!(f, ": {}", inner_8)?;
        }
        Ok(())
    }
}
impl std::error::Error for ClientException {}
/// See [`ClientException`](crate::error::ClientException)
pub mod client_exception {
    /// A builder for [`ClientException`](crate::error::ClientException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ClientException`](crate::error::ClientException)
        pub fn build(self) -> crate::error::ClientException {
            crate::error::ClientException {
                message: self.message,
            }
        }
    }
}
impl ClientException {
    /// Creates a new builder-style object to manufacture [`ClientException`](crate::error::ClientException)
    pub fn builder() -> crate::error::client_exception::Builder {
        crate::error::client_exception::Builder::default()
    }
}

/// <p>You do not have authorization to perform the requested action.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AccessDeniedException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for AccessDeniedException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AccessDeniedException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl AccessDeniedException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for AccessDeniedException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "AccessDeniedException")?;
        if let Some(inner_9) = &self.message {
            write!(f, ": {}", inner_9)?;
        }
        Ok(())
    }
}
impl std::error::Error for AccessDeniedException {}
/// See [`AccessDeniedException`](crate::error::AccessDeniedException)
pub mod access_denied_exception {
    /// A builder for [`AccessDeniedException`](crate::error::AccessDeniedException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`AccessDeniedException`](crate::error::AccessDeniedException)
        pub fn build(self) -> crate::error::AccessDeniedException {
            crate::error::AccessDeniedException {
                message: self.message,
            }
        }
    }
}
impl AccessDeniedException {
    /// Creates a new builder-style object to manufacture [`AccessDeniedException`](crate::error::AccessDeniedException)
    pub fn builder() -> crate::error::access_denied_exception::Builder {
        crate::error::access_denied_exception::Builder::default()
    }
}

/// <p>The specified platform version does not exist.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PlatformUnknownException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for PlatformUnknownException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PlatformUnknownException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl PlatformUnknownException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for PlatformUnknownException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "PlatformUnknownException")?;
        if let Some(inner_10) = &self.message {
            write!(f, ": {}", inner_10)?;
        }
        Ok(())
    }
}
impl std::error::Error for PlatformUnknownException {}
/// See [`PlatformUnknownException`](crate::error::PlatformUnknownException)
pub mod platform_unknown_exception {
    /// A builder for [`PlatformUnknownException`](crate::error::PlatformUnknownException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`PlatformUnknownException`](crate::error::PlatformUnknownException)
        pub fn build(self) -> crate::error::PlatformUnknownException {
            crate::error::PlatformUnknownException {
                message: self.message,
            }
        }
    }
}
impl PlatformUnknownException {
    /// Creates a new builder-style object to manufacture [`PlatformUnknownException`](crate::error::PlatformUnknownException)
    pub fn builder() -> crate::error::platform_unknown_exception::Builder {
        crate::error::platform_unknown_exception::Builder::default()
    }
}

/// <p>The specified platform version does not satisfy the task definition's required
/// capabilities.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PlatformTaskDefinitionIncompatibilityException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for PlatformTaskDefinitionIncompatibilityException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PlatformTaskDefinitionIncompatibilityException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl PlatformTaskDefinitionIncompatibilityException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for PlatformTaskDefinitionIncompatibilityException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "PlatformTaskDefinitionIncompatibilityException")?;
        if let Some(inner_11) = &self.message {
            write!(f, ": {}", inner_11)?;
        }
        Ok(())
    }
}
impl std::error::Error for PlatformTaskDefinitionIncompatibilityException {}
/// See [`PlatformTaskDefinitionIncompatibilityException`](crate::error::PlatformTaskDefinitionIncompatibilityException)
pub mod platform_task_definition_incompatibility_exception {
    /// A builder for [`PlatformTaskDefinitionIncompatibilityException`](crate::error::PlatformTaskDefinitionIncompatibilityException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`PlatformTaskDefinitionIncompatibilityException`](crate::error::PlatformTaskDefinitionIncompatibilityException)
        pub fn build(self) -> crate::error::PlatformTaskDefinitionIncompatibilityException {
            crate::error::PlatformTaskDefinitionIncompatibilityException {
                message: self.message,
            }
        }
    }
}
impl PlatformTaskDefinitionIncompatibilityException {
    /// Creates a new builder-style object to manufacture [`PlatformTaskDefinitionIncompatibilityException`](crate::error::PlatformTaskDefinitionIncompatibilityException)
    pub fn builder() -> crate::error::platform_task_definition_incompatibility_exception::Builder {
        crate::error::platform_task_definition_incompatibility_exception::Builder::default()
    }
}

/// <p>There is already a current Amazon ECS container agent update in progress on the specified
/// container instance. If the container agent becomes disconnected while it is in a
/// transitional stage, such as <code>PENDING</code> or <code>STAGING</code>, the update
/// process can get stuck in that state. However, when the agent reconnects, it resumes
/// where it stopped previously.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateInProgressException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for UpdateInProgressException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateInProgressException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl UpdateInProgressException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for UpdateInProgressException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "UpdateInProgressException")?;
        if let Some(inner_12) = &self.message {
            write!(f, ": {}", inner_12)?;
        }
        Ok(())
    }
}
impl std::error::Error for UpdateInProgressException {}
/// See [`UpdateInProgressException`](crate::error::UpdateInProgressException)
pub mod update_in_progress_exception {
    /// A builder for [`UpdateInProgressException`](crate::error::UpdateInProgressException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`UpdateInProgressException`](crate::error::UpdateInProgressException)
        pub fn build(self) -> crate::error::UpdateInProgressException {
            crate::error::UpdateInProgressException {
                message: self.message,
            }
        }
    }
}
impl UpdateInProgressException {
    /// Creates a new builder-style object to manufacture [`UpdateInProgressException`](crate::error::UpdateInProgressException)
    pub fn builder() -> crate::error::update_in_progress_exception::Builder {
        crate::error::update_in_progress_exception::Builder::default()
    }
}

/// <p>There is no update available for this Amazon ECS container agent. This could be because the
/// agent is already running the latest version, or it is so old that there is no update
/// path to the current version.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct NoUpdateAvailableException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for NoUpdateAvailableException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("NoUpdateAvailableException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl NoUpdateAvailableException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for NoUpdateAvailableException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "NoUpdateAvailableException")?;
        if let Some(inner_13) = &self.message {
            write!(f, ": {}", inner_13)?;
        }
        Ok(())
    }
}
impl std::error::Error for NoUpdateAvailableException {}
/// See [`NoUpdateAvailableException`](crate::error::NoUpdateAvailableException)
pub mod no_update_available_exception {
    /// A builder for [`NoUpdateAvailableException`](crate::error::NoUpdateAvailableException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`NoUpdateAvailableException`](crate::error::NoUpdateAvailableException)
        pub fn build(self) -> crate::error::NoUpdateAvailableException {
            crate::error::NoUpdateAvailableException {
                message: self.message,
            }
        }
    }
}
impl NoUpdateAvailableException {
    /// Creates a new builder-style object to manufacture [`NoUpdateAvailableException`](crate::error::NoUpdateAvailableException)
    pub fn builder() -> crate::error::no_update_available_exception::Builder {
        crate::error::no_update_available_exception::Builder::default()
    }
}

/// <p>Amazon ECS is unable to determine the current version of the Amazon ECS container agent on the
/// container instance and does not have enough information to proceed with an update. This
/// could be because the agent running on the container instance is an older or custom
/// version that does not use our version information.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct MissingVersionException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for MissingVersionException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("MissingVersionException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl MissingVersionException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for MissingVersionException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "MissingVersionException")?;
        if let Some(inner_14) = &self.message {
            write!(f, ": {}", inner_14)?;
        }
        Ok(())
    }
}
impl std::error::Error for MissingVersionException {}
/// See [`MissingVersionException`](crate::error::MissingVersionException)
pub mod missing_version_exception {
    /// A builder for [`MissingVersionException`](crate::error::MissingVersionException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`MissingVersionException`](crate::error::MissingVersionException)
        pub fn build(self) -> crate::error::MissingVersionException {
            crate::error::MissingVersionException {
                message: self.message,
            }
        }
    }
}
impl MissingVersionException {
    /// Creates a new builder-style object to manufacture [`MissingVersionException`](crate::error::MissingVersionException)
    pub fn builder() -> crate::error::missing_version_exception::Builder {
        crate::error::missing_version_exception::Builder::default()
    }
}

/// <p>The specified resource could not be found.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ResourceNotFoundException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ResourceNotFoundException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ResourceNotFoundException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ResourceNotFoundException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ResourceNotFoundException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ResourceNotFoundException")?;
        if let Some(inner_15) = &self.message {
            write!(f, ": {}", inner_15)?;
        }
        Ok(())
    }
}
impl std::error::Error for ResourceNotFoundException {}
/// See [`ResourceNotFoundException`](crate::error::ResourceNotFoundException)
pub mod resource_not_found_exception {
    /// A builder for [`ResourceNotFoundException`](crate::error::ResourceNotFoundException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ResourceNotFoundException`](crate::error::ResourceNotFoundException)
        pub fn build(self) -> crate::error::ResourceNotFoundException {
            crate::error::ResourceNotFoundException {
                message: self.message,
            }
        }
    }
}
impl ResourceNotFoundException {
    /// Creates a new builder-style object to manufacture [`ResourceNotFoundException`](crate::error::ResourceNotFoundException)
    pub fn builder() -> crate::error::resource_not_found_exception::Builder {
        crate::error::resource_not_found_exception::Builder::default()
    }
}

/// <p>Your Amazon Web Services account has been blocked. For more information, contact <a href="http://aws.amazon.com/contact-us/">
/// Amazon Web Services Support</a>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct BlockedException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for BlockedException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("BlockedException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl BlockedException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for BlockedException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "BlockedException")?;
        if let Some(inner_16) = &self.message {
            write!(f, ": {}", inner_16)?;
        }
        Ok(())
    }
}
impl std::error::Error for BlockedException {}
/// See [`BlockedException`](crate::error::BlockedException)
pub mod blocked_exception {
    /// A builder for [`BlockedException`](crate::error::BlockedException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`BlockedException`](crate::error::BlockedException)
        pub fn build(self) -> crate::error::BlockedException {
            crate::error::BlockedException {
                message: self.message,
            }
        }
    }
}
impl BlockedException {
    /// Creates a new builder-style object to manufacture [`BlockedException`](crate::error::BlockedException)
    pub fn builder() -> crate::error::blocked_exception::Builder {
        crate::error::blocked_exception::Builder::default()
    }
}

/// <p>The specified resource is in-use and cannot be removed.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ResourceInUseException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ResourceInUseException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ResourceInUseException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ResourceInUseException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ResourceInUseException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ResourceInUseException")?;
        if let Some(inner_17) = &self.message {
            write!(f, ": {}", inner_17)?;
        }
        Ok(())
    }
}
impl std::error::Error for ResourceInUseException {}
/// See [`ResourceInUseException`](crate::error::ResourceInUseException)
pub mod resource_in_use_exception {
    /// A builder for [`ResourceInUseException`](crate::error::ResourceInUseException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ResourceInUseException`](crate::error::ResourceInUseException)
        pub fn build(self) -> crate::error::ResourceInUseException {
            crate::error::ResourceInUseException {
                message: self.message,
            }
        }
    }
}
impl ResourceInUseException {
    /// Creates a new builder-style object to manufacture [`ResourceInUseException`](crate::error::ResourceInUseException)
    pub fn builder() -> crate::error::resource_in_use_exception::Builder {
        crate::error::resource_in_use_exception::Builder::default()
    }
}

/// <p>The specified target could not be found. You can view your available container
/// instances with <a>ListContainerInstances</a>. Amazon ECS container instances are
/// cluster-specific and Region-specific.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TargetNotFoundException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for TargetNotFoundException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TargetNotFoundException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl TargetNotFoundException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for TargetNotFoundException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "TargetNotFoundException")?;
        if let Some(inner_18) = &self.message {
            write!(f, ": {}", inner_18)?;
        }
        Ok(())
    }
}
impl std::error::Error for TargetNotFoundException {}
/// See [`TargetNotFoundException`](crate::error::TargetNotFoundException)
pub mod target_not_found_exception {
    /// A builder for [`TargetNotFoundException`](crate::error::TargetNotFoundException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`TargetNotFoundException`](crate::error::TargetNotFoundException)
        pub fn build(self) -> crate::error::TargetNotFoundException {
            crate::error::TargetNotFoundException {
                message: self.message,
            }
        }
    }
}
impl TargetNotFoundException {
    /// Creates a new builder-style object to manufacture [`TargetNotFoundException`](crate::error::TargetNotFoundException)
    pub fn builder() -> crate::error::target_not_found_exception::Builder {
        crate::error::target_not_found_exception::Builder::default()
    }
}

/// <p>You can apply up to 10 custom attributes per resource. You can view the attributes of
/// a resource with <a>ListAttributes</a>. You can remove existing attributes on
/// a resource with <a>DeleteAttributes</a>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AttributeLimitExceededException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for AttributeLimitExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AttributeLimitExceededException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl AttributeLimitExceededException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for AttributeLimitExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "AttributeLimitExceededException")?;
        if let Some(inner_19) = &self.message {
            write!(f, ": {}", inner_19)?;
        }
        Ok(())
    }
}
impl std::error::Error for AttributeLimitExceededException {}
/// See [`AttributeLimitExceededException`](crate::error::AttributeLimitExceededException)
pub mod attribute_limit_exceeded_exception {
    /// A builder for [`AttributeLimitExceededException`](crate::error::AttributeLimitExceededException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`AttributeLimitExceededException`](crate::error::AttributeLimitExceededException)
        pub fn build(self) -> crate::error::AttributeLimitExceededException {
            crate::error::AttributeLimitExceededException {
                message: self.message,
            }
        }
    }
}
impl AttributeLimitExceededException {
    /// Creates a new builder-style object to manufacture [`AttributeLimitExceededException`](crate::error::AttributeLimitExceededException)
    pub fn builder() -> crate::error::attribute_limit_exceeded_exception::Builder {
        crate::error::attribute_limit_exceeded_exception::Builder::default()
    }
}

/// <p>The target container is not properly configured with the execute command agent or the
/// container is no longer active or running.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TargetNotConnectedException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for TargetNotConnectedException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TargetNotConnectedException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl TargetNotConnectedException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for TargetNotConnectedException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "TargetNotConnectedException")?;
        if let Some(inner_20) = &self.message {
            write!(f, ": {}", inner_20)?;
        }
        Ok(())
    }
}
impl std::error::Error for TargetNotConnectedException {}
/// See [`TargetNotConnectedException`](crate::error::TargetNotConnectedException)
pub mod target_not_connected_exception {
    /// A builder for [`TargetNotConnectedException`](crate::error::TargetNotConnectedException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`TargetNotConnectedException`](crate::error::TargetNotConnectedException)
        pub fn build(self) -> crate::error::TargetNotConnectedException {
            crate::error::TargetNotConnectedException {
                message: self.message,
            }
        }
    }
}
impl TargetNotConnectedException {
    /// Creates a new builder-style object to manufacture [`TargetNotConnectedException`](crate::error::TargetNotConnectedException)
    pub fn builder() -> crate::error::target_not_connected_exception::Builder {
        crate::error::target_not_connected_exception::Builder::default()
    }
}

/// <p>You cannot delete a cluster that has active tasks.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ClusterContainsTasksException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ClusterContainsTasksException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ClusterContainsTasksException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ClusterContainsTasksException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ClusterContainsTasksException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ClusterContainsTasksException")?;
        if let Some(inner_21) = &self.message {
            write!(f, ": {}", inner_21)?;
        }
        Ok(())
    }
}
impl std::error::Error for ClusterContainsTasksException {}
/// See [`ClusterContainsTasksException`](crate::error::ClusterContainsTasksException)
pub mod cluster_contains_tasks_exception {
    /// A builder for [`ClusterContainsTasksException`](crate::error::ClusterContainsTasksException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ClusterContainsTasksException`](crate::error::ClusterContainsTasksException)
        pub fn build(self) -> crate::error::ClusterContainsTasksException {
            crate::error::ClusterContainsTasksException {
                message: self.message,
            }
        }
    }
}
impl ClusterContainsTasksException {
    /// Creates a new builder-style object to manufacture [`ClusterContainsTasksException`](crate::error::ClusterContainsTasksException)
    pub fn builder() -> crate::error::cluster_contains_tasks_exception::Builder {
        crate::error::cluster_contains_tasks_exception::Builder::default()
    }
}

/// <p>You cannot delete a cluster that contains services. First, update the service to
/// reduce its desired task count to 0 and then delete the service. For more information,
/// see <a>UpdateService</a> and <a>DeleteService</a>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ClusterContainsServicesException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ClusterContainsServicesException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ClusterContainsServicesException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ClusterContainsServicesException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ClusterContainsServicesException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ClusterContainsServicesException")?;
        if let Some(inner_22) = &self.message {
            write!(f, ": {}", inner_22)?;
        }
        Ok(())
    }
}
impl std::error::Error for ClusterContainsServicesException {}
/// See [`ClusterContainsServicesException`](crate::error::ClusterContainsServicesException)
pub mod cluster_contains_services_exception {
    /// A builder for [`ClusterContainsServicesException`](crate::error::ClusterContainsServicesException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ClusterContainsServicesException`](crate::error::ClusterContainsServicesException)
        pub fn build(self) -> crate::error::ClusterContainsServicesException {
            crate::error::ClusterContainsServicesException {
                message: self.message,
            }
        }
    }
}
impl ClusterContainsServicesException {
    /// Creates a new builder-style object to manufacture [`ClusterContainsServicesException`](crate::error::ClusterContainsServicesException)
    pub fn builder() -> crate::error::cluster_contains_services_exception::Builder {
        crate::error::cluster_contains_services_exception::Builder::default()
    }
}

/// <p>You cannot delete a cluster that has registered container instances. First, deregister
/// the container instances before you can delete the cluster. For more information, see
/// <a>DeregisterContainerInstance</a>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ClusterContainsContainerInstancesException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ClusterContainsContainerInstancesException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ClusterContainsContainerInstancesException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ClusterContainsContainerInstancesException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ClusterContainsContainerInstancesException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ClusterContainsContainerInstancesException")?;
        if let Some(inner_23) = &self.message {
            write!(f, ": {}", inner_23)?;
        }
        Ok(())
    }
}
impl std::error::Error for ClusterContainsContainerInstancesException {}
/// See [`ClusterContainsContainerInstancesException`](crate::error::ClusterContainsContainerInstancesException)
pub mod cluster_contains_container_instances_exception {
    /// A builder for [`ClusterContainsContainerInstancesException`](crate::error::ClusterContainsContainerInstancesException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ClusterContainsContainerInstancesException`](crate::error::ClusterContainsContainerInstancesException)
        pub fn build(self) -> crate::error::ClusterContainsContainerInstancesException {
            crate::error::ClusterContainsContainerInstancesException {
                message: self.message,
            }
        }
    }
}
impl ClusterContainsContainerInstancesException {
    /// Creates a new builder-style object to manufacture [`ClusterContainsContainerInstancesException`](crate::error::ClusterContainsContainerInstancesException)
    pub fn builder() -> crate::error::cluster_contains_container_instances_exception::Builder {
        crate::error::cluster_contains_container_instances_exception::Builder::default()
    }
}

/// <p>The limit for the resource has been exceeded.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct LimitExceededException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for LimitExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("LimitExceededException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl LimitExceededException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for LimitExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "LimitExceededException")?;
        if let Some(inner_24) = &self.message {
            write!(f, ": {}", inner_24)?;
        }
        Ok(())
    }
}
impl std::error::Error for LimitExceededException {}
/// See [`LimitExceededException`](crate::error::LimitExceededException)
pub mod limit_exceeded_exception {
    /// A builder for [`LimitExceededException`](crate::error::LimitExceededException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`LimitExceededException`](crate::error::LimitExceededException)
        pub fn build(self) -> crate::error::LimitExceededException {
            crate::error::LimitExceededException {
                message: self.message,
            }
        }
    }
}
impl LimitExceededException {
    /// Creates a new builder-style object to manufacture [`LimitExceededException`](crate::error::LimitExceededException)
    pub fn builder() -> crate::error::limit_exceeded_exception::Builder {
        crate::error::limit_exceeded_exception::Builder::default()
    }
}
