// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[derive(std::fmt::Debug)]
pub(crate) struct Handle<C = aws_hyper::DynConnector> {
    client: aws_hyper::Client<C>,
    conf: crate::Config,
}

#[derive(Clone, std::fmt::Debug)]
pub struct Client<C = aws_hyper::DynConnector> {
    handle: std::sync::Arc<Handle<C>>,
}
impl<C> Client<C> {
    pub fn from_conf_conn(conf: crate::Config, conn: C) -> Self {
        let client = aws_hyper::Client::new(conn);
        Self {
            handle: std::sync::Arc::new(Handle { client, conf }),
        }
    }

    pub fn conf(&self) -> &crate::Config {
        &self.handle.conf
    }
}
impl Client {
    #[cfg(any(feature = "rustls", feature = "native-tls"))]
    pub fn from_env() -> Self {
        Self::from_conf(crate::Config::builder().build())
    }

    #[cfg(any(feature = "rustls", feature = "native-tls"))]
    pub fn from_conf(conf: crate::Config) -> Self {
        let client = aws_hyper::Client::https();
        Self {
            handle: std::sync::Arc::new(Handle { client, conf }),
        }
    }
}
impl<C> Client<C>
where
    C: aws_hyper::SmithyConnector,
{
    pub fn associate_custom_domain(&self) -> fluent_builders::AssociateCustomDomain<C> {
        fluent_builders::AssociateCustomDomain::new(self.handle.clone())
    }
    pub fn create_auto_scaling_configuration(
        &self,
    ) -> fluent_builders::CreateAutoScalingConfiguration<C> {
        fluent_builders::CreateAutoScalingConfiguration::new(self.handle.clone())
    }
    pub fn create_connection(&self) -> fluent_builders::CreateConnection<C> {
        fluent_builders::CreateConnection::new(self.handle.clone())
    }
    pub fn create_service(&self) -> fluent_builders::CreateService<C> {
        fluent_builders::CreateService::new(self.handle.clone())
    }
    pub fn delete_auto_scaling_configuration(
        &self,
    ) -> fluent_builders::DeleteAutoScalingConfiguration<C> {
        fluent_builders::DeleteAutoScalingConfiguration::new(self.handle.clone())
    }
    pub fn delete_connection(&self) -> fluent_builders::DeleteConnection<C> {
        fluent_builders::DeleteConnection::new(self.handle.clone())
    }
    pub fn delete_service(&self) -> fluent_builders::DeleteService<C> {
        fluent_builders::DeleteService::new(self.handle.clone())
    }
    pub fn describe_auto_scaling_configuration(
        &self,
    ) -> fluent_builders::DescribeAutoScalingConfiguration<C> {
        fluent_builders::DescribeAutoScalingConfiguration::new(self.handle.clone())
    }
    pub fn describe_custom_domains(&self) -> fluent_builders::DescribeCustomDomains<C> {
        fluent_builders::DescribeCustomDomains::new(self.handle.clone())
    }
    pub fn describe_service(&self) -> fluent_builders::DescribeService<C> {
        fluent_builders::DescribeService::new(self.handle.clone())
    }
    pub fn disassociate_custom_domain(&self) -> fluent_builders::DisassociateCustomDomain<C> {
        fluent_builders::DisassociateCustomDomain::new(self.handle.clone())
    }
    pub fn list_auto_scaling_configurations(
        &self,
    ) -> fluent_builders::ListAutoScalingConfigurations<C> {
        fluent_builders::ListAutoScalingConfigurations::new(self.handle.clone())
    }
    pub fn list_connections(&self) -> fluent_builders::ListConnections<C> {
        fluent_builders::ListConnections::new(self.handle.clone())
    }
    pub fn list_operations(&self) -> fluent_builders::ListOperations<C> {
        fluent_builders::ListOperations::new(self.handle.clone())
    }
    pub fn list_services(&self) -> fluent_builders::ListServices<C> {
        fluent_builders::ListServices::new(self.handle.clone())
    }
    pub fn list_tags_for_resource(&self) -> fluent_builders::ListTagsForResource<C> {
        fluent_builders::ListTagsForResource::new(self.handle.clone())
    }
    pub fn pause_service(&self) -> fluent_builders::PauseService<C> {
        fluent_builders::PauseService::new(self.handle.clone())
    }
    pub fn resume_service(&self) -> fluent_builders::ResumeService<C> {
        fluent_builders::ResumeService::new(self.handle.clone())
    }
    pub fn start_deployment(&self) -> fluent_builders::StartDeployment<C> {
        fluent_builders::StartDeployment::new(self.handle.clone())
    }
    pub fn tag_resource(&self) -> fluent_builders::TagResource<C> {
        fluent_builders::TagResource::new(self.handle.clone())
    }
    pub fn untag_resource(&self) -> fluent_builders::UntagResource<C> {
        fluent_builders::UntagResource::new(self.handle.clone())
    }
    pub fn update_service(&self) -> fluent_builders::UpdateService<C> {
        fluent_builders::UpdateService::new(self.handle.clone())
    }
}
pub mod fluent_builders {
    #[derive(std::fmt::Debug)]
    pub struct AssociateCustomDomain<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::associate_custom_domain_input::Builder,
    }
    impl<C> AssociateCustomDomain<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::AssociateCustomDomainOutput,
            smithy_http::result::SdkError<crate::error::AssociateCustomDomainError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the App Runner service that you want to associate a custom domain name with.</p>
        pub fn service_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.service_arn(input);
            self
        }
        pub fn set_service_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_service_arn(input);
            self
        }
        /// <p>A custom domain endpoint to associate. Specify a root domain (for example, <code>example.com</code>), a subdomain (for example,
        /// <code>login.example.com</code> or <code>admin.login.example.com</code>), or a wildcard (for example, <code>*.example.com</code>).</p>
        pub fn domain_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.domain_name(input);
            self
        }
        pub fn set_domain_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_domain_name(input);
            self
        }
        /// <p>Set to <code>true</code> to associate the subdomain <code>www.<i>DomainName</i>
        /// </code> with the App Runner service in addition to the base
        /// domain.</p>
        /// <p>Default: <code>true</code>
        /// </p>
        pub fn enable_www_subdomain(mut self, input: bool) -> Self {
            self.inner = self.inner.enable_www_subdomain(input);
            self
        }
        pub fn set_enable_www_subdomain(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_enable_www_subdomain(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateAutoScalingConfiguration<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_auto_scaling_configuration_input::Builder,
    }
    impl<C> CreateAutoScalingConfiguration<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateAutoScalingConfigurationOutput,
            smithy_http::result::SdkError<crate::error::CreateAutoScalingConfigurationError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>A name for the auto scaling configuration. When you use it for the first time in an AWS Region, App Runner creates revision number <code>1</code> of this
        /// name. When you use the same name in subsequent calls, App Runner creates incremental revisions of the configuration.</p>
        pub fn auto_scaling_configuration_name(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.auto_scaling_configuration_name(input);
            self
        }
        pub fn set_auto_scaling_configuration_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_auto_scaling_configuration_name(input);
            self
        }
        /// <p>The maximum number of concurrent requests that you want an instance to process. If the number of concurrent requests exceeds this limit, App Runner scales
        /// up your service.</p>
        /// <p>Default: <code>100</code>
        /// </p>
        pub fn max_concurrency(mut self, input: i32) -> Self {
            self.inner = self.inner.max_concurrency(input);
            self
        }
        pub fn set_max_concurrency(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_concurrency(input);
            self
        }
        /// <p>The minimum number of instances that App Runner provisions for your service. The service always has at least <code>MinSize</code> provisioned instances.
        /// Some of them actively serve traffic. The rest of them (provisioned and inactive instances) are a cost-effective compute capacity reserve and are ready to
        /// be quickly activated. You pay for memory usage of all the provisioned instances. You pay for CPU usage of only the active subset.</p>
        /// <p>App Runner temporarily doubles the number of provisioned instances during deployments, to maintain the same capacity for both old and new code.</p>
        /// <p>Default: <code>1</code>
        /// </p>
        pub fn min_size(mut self, input: i32) -> Self {
            self.inner = self.inner.min_size(input);
            self
        }
        pub fn set_min_size(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_min_size(input);
            self
        }
        /// <p>The maximum number of instances that your service scales up to. At most <code>MaxSize</code> instances actively serve traffic for your service.</p>
        /// <p>Default: <code>25</code>
        /// </p>
        pub fn max_size(mut self, input: i32) -> Self {
            self.inner = self.inner.max_size(input);
            self
        }
        pub fn set_max_size(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_size(input);
            self
        }
        /// <p>A list of metadata items that you can associate with your auto scaling configuration resource. A tag is a key-value pair.</p>
        pub fn tags(mut self, inp: impl Into<crate::model::Tag>) -> Self {
            self.inner = self.inner.tags(inp);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateConnection<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_connection_input::Builder,
    }
    impl<C> CreateConnection<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateConnectionOutput,
            smithy_http::result::SdkError<crate::error::CreateConnectionError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>A name for the new connection. It must be unique across all App Runner connections for the AWS account in the AWS Region.</p>
        pub fn connection_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.connection_name(input);
            self
        }
        pub fn set_connection_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_connection_name(input);
            self
        }
        /// <p>The source repository provider.</p>
        pub fn provider_type(mut self, input: crate::model::ProviderType) -> Self {
            self.inner = self.inner.provider_type(input);
            self
        }
        pub fn set_provider_type(
            mut self,
            input: std::option::Option<crate::model::ProviderType>,
        ) -> Self {
            self.inner = self.inner.set_provider_type(input);
            self
        }
        /// <p>A list of metadata items that you can associate with your connection resource. A tag is a key-value pair.</p>
        pub fn tags(mut self, inp: impl Into<crate::model::Tag>) -> Self {
            self.inner = self.inner.tags(inp);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateService<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_service_input::Builder,
    }
    impl<C> CreateService<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateServiceOutput,
            smithy_http::result::SdkError<crate::error::CreateServiceError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>A name for the new service. It must be unique across all the running App Runner services in your AWS account in the AWS Region.</p>
        pub fn service_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.service_name(input);
            self
        }
        pub fn set_service_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_service_name(input);
            self
        }
        /// <p>The source to deploy to the App Runner service. It can be a code or an image repository.</p>
        pub fn source_configuration(mut self, input: crate::model::SourceConfiguration) -> Self {
            self.inner = self.inner.source_configuration(input);
            self
        }
        pub fn set_source_configuration(
            mut self,
            input: std::option::Option<crate::model::SourceConfiguration>,
        ) -> Self {
            self.inner = self.inner.set_source_configuration(input);
            self
        }
        /// <p>The runtime configuration of instances (scaling units) of the App Runner service.</p>
        pub fn instance_configuration(
            mut self,
            input: crate::model::InstanceConfiguration,
        ) -> Self {
            self.inner = self.inner.instance_configuration(input);
            self
        }
        pub fn set_instance_configuration(
            mut self,
            input: std::option::Option<crate::model::InstanceConfiguration>,
        ) -> Self {
            self.inner = self.inner.set_instance_configuration(input);
            self
        }
        /// <p>An optional list of metadata items that you can associate with your service resource. A tag is a key-value pair.</p>
        pub fn tags(mut self, inp: impl Into<crate::model::Tag>) -> Self {
            self.inner = self.inner.tags(inp);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
        /// <p>An optional custom encryption key that App Runner uses to encrypt the copy of your source repository that it maintains and your service logs. By default,
        /// App Runner uses an AWS managed CMK.</p>
        pub fn encryption_configuration(
            mut self,
            input: crate::model::EncryptionConfiguration,
        ) -> Self {
            self.inner = self.inner.encryption_configuration(input);
            self
        }
        pub fn set_encryption_configuration(
            mut self,
            input: std::option::Option<crate::model::EncryptionConfiguration>,
        ) -> Self {
            self.inner = self.inner.set_encryption_configuration(input);
            self
        }
        /// <p>The settings for the health check that AWS App Runner performs to monitor the health of your service.</p>
        pub fn health_check_configuration(
            mut self,
            input: crate::model::HealthCheckConfiguration,
        ) -> Self {
            self.inner = self.inner.health_check_configuration(input);
            self
        }
        pub fn set_health_check_configuration(
            mut self,
            input: std::option::Option<crate::model::HealthCheckConfiguration>,
        ) -> Self {
            self.inner = self.inner.set_health_check_configuration(input);
            self
        }
        /// <p>The Amazon Resource Name (ARN) of an App Runner automatic scaling configuration resource that you want to associate with your service. If not provided, App Runner
        /// associates the latest revision of a default auto scaling configuration.</p>
        pub fn auto_scaling_configuration_arn(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.auto_scaling_configuration_arn(input);
            self
        }
        pub fn set_auto_scaling_configuration_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_auto_scaling_configuration_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteAutoScalingConfiguration<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_auto_scaling_configuration_input::Builder,
    }
    impl<C> DeleteAutoScalingConfiguration<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteAutoScalingConfigurationOutput,
            smithy_http::result::SdkError<crate::error::DeleteAutoScalingConfigurationError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the App Runner auto scaling configuration that you want to delete.</p>
        /// <p>The ARN can be a full auto scaling configuration ARN, or a partial ARN ending with either <code>.../<i>name</i>
        /// </code> or
        /// <code>.../<i>name</i>/<i>revision</i>
        /// </code>. If a revision isn't specified, the latest active revision is deleted.</p>
        pub fn auto_scaling_configuration_arn(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.auto_scaling_configuration_arn(input);
            self
        }
        pub fn set_auto_scaling_configuration_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_auto_scaling_configuration_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteConnection<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_connection_input::Builder,
    }
    impl<C> DeleteConnection<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteConnectionOutput,
            smithy_http::result::SdkError<crate::error::DeleteConnectionError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the App Runner connection that you want to delete.</p>
        pub fn connection_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.connection_arn(input);
            self
        }
        pub fn set_connection_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_connection_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteService<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_service_input::Builder,
    }
    impl<C> DeleteService<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteServiceOutput,
            smithy_http::result::SdkError<crate::error::DeleteServiceError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the App Runner service that you want to delete.</p>
        pub fn service_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.service_arn(input);
            self
        }
        pub fn set_service_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_service_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeAutoScalingConfiguration<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_auto_scaling_configuration_input::Builder,
    }
    impl<C> DescribeAutoScalingConfiguration<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeAutoScalingConfigurationOutput,
            smithy_http::result::SdkError<crate::error::DescribeAutoScalingConfigurationError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the App Runner auto scaling configuration that you want a description for.</p>
        /// <p>The ARN can be a full auto scaling configuration ARN, or a partial ARN ending with either <code>.../<i>name</i>
        /// </code> or
        /// <code>.../<i>name</i>/<i>revision</i>
        /// </code>. If a revision isn't specified, the latest active revision is
        /// described.</p>
        pub fn auto_scaling_configuration_arn(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.auto_scaling_configuration_arn(input);
            self
        }
        pub fn set_auto_scaling_configuration_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_auto_scaling_configuration_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeCustomDomains<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_custom_domains_input::Builder,
    }
    impl<C> DescribeCustomDomains<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeCustomDomainsOutput,
            smithy_http::result::SdkError<crate::error::DescribeCustomDomainsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the App Runner service that you want associated custom domain names to be described for.</p>
        pub fn service_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.service_arn(input);
            self
        }
        pub fn set_service_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_service_arn(input);
            self
        }
        /// <p>A token from a previous result page. It's used for a paginated request. The request retrieves the next result page. All other parameter values must be
        /// identical to the ones that are specified in the initial request.</p>
        /// <p>If you don't specify <code>NextToken</code>, the request retrieves the first result page.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>The maximum number of results that each response (result page) can include. It's used for a paginated request.</p>
        /// <p>If you don't specify <code>MaxResults</code>, the request retrieves all available results in a single response.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeService<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_service_input::Builder,
    }
    impl<C> DescribeService<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeServiceOutput,
            smithy_http::result::SdkError<crate::error::DescribeServiceError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the App Runner service that you want a description for.</p>
        pub fn service_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.service_arn(input);
            self
        }
        pub fn set_service_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_service_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DisassociateCustomDomain<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::disassociate_custom_domain_input::Builder,
    }
    impl<C> DisassociateCustomDomain<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DisassociateCustomDomainOutput,
            smithy_http::result::SdkError<crate::error::DisassociateCustomDomainError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the App Runner service that you want to disassociate a custom domain name from.</p>
        pub fn service_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.service_arn(input);
            self
        }
        pub fn set_service_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_service_arn(input);
            self
        }
        /// <p>The domain name that you want to disassociate from the App Runner service.</p>
        pub fn domain_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.domain_name(input);
            self
        }
        pub fn set_domain_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_domain_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListAutoScalingConfigurations<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_auto_scaling_configurations_input::Builder,
    }
    impl<C> ListAutoScalingConfigurations<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListAutoScalingConfigurationsOutput,
            smithy_http::result::SdkError<crate::error::ListAutoScalingConfigurationsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the App Runner auto scaling configuration that you want to list. If specified, App Runner lists revisions that share this name. If not specified, App Runner
        /// returns revisions of all configurations.</p>
        pub fn auto_scaling_configuration_name(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.auto_scaling_configuration_name(input);
            self
        }
        pub fn set_auto_scaling_configuration_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_auto_scaling_configuration_name(input);
            self
        }
        /// <p>Set to <code>true</code> to list only the latest revision for each requested configuration name.</p>
        /// <p>Keep as <code>false</code> to list all revisions for each requested configuration name.</p>
        /// <p>Default: <code>false</code>
        /// </p>
        pub fn latest_only(mut self, input: bool) -> Self {
            self.inner = self.inner.latest_only(input);
            self
        }
        pub fn set_latest_only(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_latest_only(input);
            self
        }
        /// <p>The maximum number of results to include in each response (result page). It's used for a paginated request.</p>
        /// <p>If you don't specify <code>MaxResults</code>, the request retrieves all available results in a single response.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>A token from a previous result page. It's used for a paginated request. The request retrieves the next result page. All other parameter values must be
        /// identical to the ones that are specified in the initial request.</p>
        /// <p>If you don't specify <code>NextToken</code>, the request retrieves the first result page.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListConnections<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_connections_input::Builder,
    }
    impl<C> ListConnections<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListConnectionsOutput,
            smithy_http::result::SdkError<crate::error::ListConnectionsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>If specified, only this connection is returned. If not specified, the result isn't filtered by name.</p>
        pub fn connection_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.connection_name(input);
            self
        }
        pub fn set_connection_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_connection_name(input);
            self
        }
        /// <p>The maximum number of results to include in each response (result page). Used for a paginated request.</p>
        /// <p>If you don't specify <code>MaxResults</code>, the request retrieves all available results in a single response.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>A token from a previous result page. Used for a paginated request. The request retrieves the next result page. All other parameter values must be
        /// identical to the ones specified in the initial request.</p>
        /// <p>If you don't specify <code>NextToken</code>, the request retrieves the first result page.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListOperations<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_operations_input::Builder,
    }
    impl<C> ListOperations<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListOperationsOutput,
            smithy_http::result::SdkError<crate::error::ListOperationsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the App Runner service that you want a list of operations for.</p>
        pub fn service_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.service_arn(input);
            self
        }
        pub fn set_service_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_service_arn(input);
            self
        }
        /// <p>A token from a previous result page. It's used for a paginated request. The request retrieves the next result page. All other parameter values must be
        /// identical to the ones specified in the initial request.</p>
        /// <p>If you don't specify <code>NextToken</code>, the request retrieves the first result page.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>The maximum number of results to include in each response (result page). It's used for a paginated request.</p>
        /// <p>If you don't specify <code>MaxResults</code>, the request retrieves all available results in a single response.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListServices<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_services_input::Builder,
    }
    impl<C> ListServices<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListServicesOutput,
            smithy_http::result::SdkError<crate::error::ListServicesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>A token from a previous result page. Used for a paginated request. The request retrieves the next result page. All other parameter values must be
        /// identical to the ones specified in the initial request.</p>
        /// <p>If you don't specify <code>NextToken</code>, the request retrieves the first result page.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>The maximum number of results to include in each response (result page). It's used for a paginated request.</p>
        /// <p>If you don't specify <code>MaxResults</code>, the request retrieves all available results in a single response.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListTagsForResource<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_tags_for_resource_input::Builder,
    }
    impl<C> ListTagsForResource<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListTagsForResourceOutput,
            smithy_http::result::SdkError<crate::error::ListTagsForResourceError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the resource that a tag list is requested for.</p>
        /// <p>It must be the ARN of an App Runner resource.</p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resource_arn(input);
            self
        }
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_resource_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct PauseService<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::pause_service_input::Builder,
    }
    impl<C> PauseService<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::PauseServiceOutput,
            smithy_http::result::SdkError<crate::error::PauseServiceError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the App Runner service that you want to pause.</p>
        pub fn service_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.service_arn(input);
            self
        }
        pub fn set_service_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_service_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ResumeService<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::resume_service_input::Builder,
    }
    impl<C> ResumeService<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ResumeServiceOutput,
            smithy_http::result::SdkError<crate::error::ResumeServiceError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the App Runner service that you want to resume.</p>
        pub fn service_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.service_arn(input);
            self
        }
        pub fn set_service_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_service_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct StartDeployment<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::start_deployment_input::Builder,
    }
    impl<C> StartDeployment<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::StartDeploymentOutput,
            smithy_http::result::SdkError<crate::error::StartDeploymentError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the App Runner service that you want to manually deploy to.</p>
        pub fn service_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.service_arn(input);
            self
        }
        pub fn set_service_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_service_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct TagResource<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::tag_resource_input::Builder,
    }
    impl<C> TagResource<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::TagResourceOutput,
            smithy_http::result::SdkError<crate::error::TagResourceError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the resource that you want to update tags for.</p>
        /// <p>It must be the ARN of an App Runner resource.</p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resource_arn(input);
            self
        }
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_resource_arn(input);
            self
        }
        /// <p>A list of tag key-value pairs to add or update. If a key is new to the resource, the tag is added with the provided value. If a key is already
        /// associated with the resource, the value of the tag is updated.</p>
        pub fn tags(mut self, inp: impl Into<crate::model::Tag>) -> Self {
            self.inner = self.inner.tags(inp);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UntagResource<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::untag_resource_input::Builder,
    }
    impl<C> UntagResource<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UntagResourceOutput,
            smithy_http::result::SdkError<crate::error::UntagResourceError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the resource that you want to remove tags from.</p>
        /// <p>It must be the ARN of an App Runner resource.</p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resource_arn(input);
            self
        }
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_resource_arn(input);
            self
        }
        /// <p>A list of tag keys that you want to remove.</p>
        pub fn tag_keys(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.tag_keys(inp);
            self
        }
        pub fn set_tag_keys(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_tag_keys(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateService<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::update_service_input::Builder,
    }
    impl<C> UpdateService<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateServiceOutput,
            smithy_http::result::SdkError<crate::error::UpdateServiceError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the App Runner service that you want to update.</p>
        pub fn service_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.service_arn(input);
            self
        }
        pub fn set_service_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_service_arn(input);
            self
        }
        /// <p>The source configuration to apply to the App Runner service.</p>
        /// <p>You can change the configuration of the code or image repository that the service uses. However, you can't switch from code to image or the other way
        /// around. This means that you must provide the same structure member of <code>SourceConfiguration</code> that you originally included when you created the
        /// service. Specifically, you can include either <code>CodeRepository</code> or <code>ImageRepository</code>. To update the source configuration, set the
        /// values to members of the structure that you include.</p>
        pub fn source_configuration(mut self, input: crate::model::SourceConfiguration) -> Self {
            self.inner = self.inner.source_configuration(input);
            self
        }
        pub fn set_source_configuration(
            mut self,
            input: std::option::Option<crate::model::SourceConfiguration>,
        ) -> Self {
            self.inner = self.inner.set_source_configuration(input);
            self
        }
        /// <p>The runtime configuration to apply to instances (scaling units) of the App Runner service.</p>
        pub fn instance_configuration(
            mut self,
            input: crate::model::InstanceConfiguration,
        ) -> Self {
            self.inner = self.inner.instance_configuration(input);
            self
        }
        pub fn set_instance_configuration(
            mut self,
            input: std::option::Option<crate::model::InstanceConfiguration>,
        ) -> Self {
            self.inner = self.inner.set_instance_configuration(input);
            self
        }
        /// <p>The Amazon Resource Name (ARN) of an App Runner automatic scaling configuration resource that you want to associate with your service.</p>
        pub fn auto_scaling_configuration_arn(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.auto_scaling_configuration_arn(input);
            self
        }
        pub fn set_auto_scaling_configuration_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_auto_scaling_configuration_arn(input);
            self
        }
        /// <p>The settings for the health check that AWS App Runner performs to monitor the health of your service.</p>
        pub fn health_check_configuration(
            mut self,
            input: crate::model::HealthCheckConfiguration,
        ) -> Self {
            self.inner = self.inner.health_check_configuration(input);
            self
        }
        pub fn set_health_check_configuration(
            mut self,
            input: std::option::Option<crate::model::HealthCheckConfiguration>,
        ) -> Self {
            self.inner = self.inner.set_health_check_configuration(input);
            self
        }
    }
}
