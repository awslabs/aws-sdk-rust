// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateGatewayRouteError {
    pub kind: CreateGatewayRouteErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateGatewayRouteErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ConflictException(crate::error::ConflictException),
    ForbiddenException(crate::error::ForbiddenException),
    InternalServerErrorException(crate::error::InternalServerErrorException),
    LimitExceededException(crate::error::LimitExceededException),
    NotFoundException(crate::error::NotFoundException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateGatewayRouteError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateGatewayRouteErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            CreateGatewayRouteErrorKind::ConflictException(_inner) => _inner.fmt(f),
            CreateGatewayRouteErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            CreateGatewayRouteErrorKind::InternalServerErrorException(_inner) => _inner.fmt(f),
            CreateGatewayRouteErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            CreateGatewayRouteErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            CreateGatewayRouteErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            CreateGatewayRouteErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            CreateGatewayRouteErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateGatewayRouteError {
    fn code(&self) -> Option<&str> {
        CreateGatewayRouteError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        match &self.kind {
            CreateGatewayRouteErrorKind::InternalServerErrorException(inner) => {
                Some(inner.retryable_error_kind())
            }
            CreateGatewayRouteErrorKind::ServiceUnavailableException(inner) => {
                Some(inner.retryable_error_kind())
            }
            CreateGatewayRouteErrorKind::TooManyRequestsException(inner) => {
                Some(inner.retryable_error_kind())
            }
            _ => None,
        }
    }
}
impl CreateGatewayRouteError {
    pub fn new(kind: CreateGatewayRouteErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateGatewayRouteErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateGatewayRouteErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateGatewayRouteErrorKind::BadRequestException(_)
        )
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateGatewayRouteErrorKind::ConflictException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateGatewayRouteErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateGatewayRouteErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateGatewayRouteErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateGatewayRouteErrorKind::NotFoundException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateGatewayRouteErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateGatewayRouteErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for CreateGatewayRouteError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateGatewayRouteErrorKind::BadRequestException(_inner) => Some(_inner),
            CreateGatewayRouteErrorKind::ConflictException(_inner) => Some(_inner),
            CreateGatewayRouteErrorKind::ForbiddenException(_inner) => Some(_inner),
            CreateGatewayRouteErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            CreateGatewayRouteErrorKind::LimitExceededException(_inner) => Some(_inner),
            CreateGatewayRouteErrorKind::NotFoundException(_inner) => Some(_inner),
            CreateGatewayRouteErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            CreateGatewayRouteErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            CreateGatewayRouteErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateMeshError {
    pub kind: CreateMeshErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateMeshErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ConflictException(crate::error::ConflictException),
    ForbiddenException(crate::error::ForbiddenException),
    InternalServerErrorException(crate::error::InternalServerErrorException),
    LimitExceededException(crate::error::LimitExceededException),
    NotFoundException(crate::error::NotFoundException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateMeshError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateMeshErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            CreateMeshErrorKind::ConflictException(_inner) => _inner.fmt(f),
            CreateMeshErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            CreateMeshErrorKind::InternalServerErrorException(_inner) => _inner.fmt(f),
            CreateMeshErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            CreateMeshErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            CreateMeshErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            CreateMeshErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            CreateMeshErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateMeshError {
    fn code(&self) -> Option<&str> {
        CreateMeshError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        match &self.kind {
            CreateMeshErrorKind::InternalServerErrorException(inner) => {
                Some(inner.retryable_error_kind())
            }
            CreateMeshErrorKind::ServiceUnavailableException(inner) => {
                Some(inner.retryable_error_kind())
            }
            CreateMeshErrorKind::TooManyRequestsException(inner) => {
                Some(inner.retryable_error_kind())
            }
            _ => None,
        }
    }
}
impl CreateMeshError {
    pub fn new(kind: CreateMeshErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateMeshErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateMeshErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, CreateMeshErrorKind::BadRequestException(_))
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, CreateMeshErrorKind::ConflictException(_))
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, CreateMeshErrorKind::ForbiddenException(_))
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateMeshErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(&self.kind, CreateMeshErrorKind::LimitExceededException(_))
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, CreateMeshErrorKind::NotFoundException(_))
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateMeshErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(&self.kind, CreateMeshErrorKind::TooManyRequestsException(_))
    }
}
impl std::error::Error for CreateMeshError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateMeshErrorKind::BadRequestException(_inner) => Some(_inner),
            CreateMeshErrorKind::ConflictException(_inner) => Some(_inner),
            CreateMeshErrorKind::ForbiddenException(_inner) => Some(_inner),
            CreateMeshErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            CreateMeshErrorKind::LimitExceededException(_inner) => Some(_inner),
            CreateMeshErrorKind::NotFoundException(_inner) => Some(_inner),
            CreateMeshErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            CreateMeshErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            CreateMeshErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateRouteError {
    pub kind: CreateRouteErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateRouteErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ConflictException(crate::error::ConflictException),
    ForbiddenException(crate::error::ForbiddenException),
    InternalServerErrorException(crate::error::InternalServerErrorException),
    LimitExceededException(crate::error::LimitExceededException),
    NotFoundException(crate::error::NotFoundException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateRouteError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateRouteErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            CreateRouteErrorKind::ConflictException(_inner) => _inner.fmt(f),
            CreateRouteErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            CreateRouteErrorKind::InternalServerErrorException(_inner) => _inner.fmt(f),
            CreateRouteErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            CreateRouteErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            CreateRouteErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            CreateRouteErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            CreateRouteErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateRouteError {
    fn code(&self) -> Option<&str> {
        CreateRouteError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        match &self.kind {
            CreateRouteErrorKind::InternalServerErrorException(inner) => {
                Some(inner.retryable_error_kind())
            }
            CreateRouteErrorKind::ServiceUnavailableException(inner) => {
                Some(inner.retryable_error_kind())
            }
            CreateRouteErrorKind::TooManyRequestsException(inner) => {
                Some(inner.retryable_error_kind())
            }
            _ => None,
        }
    }
}
impl CreateRouteError {
    pub fn new(kind: CreateRouteErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateRouteErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateRouteErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, CreateRouteErrorKind::BadRequestException(_))
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, CreateRouteErrorKind::ConflictException(_))
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, CreateRouteErrorKind::ForbiddenException(_))
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateRouteErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(&self.kind, CreateRouteErrorKind::LimitExceededException(_))
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, CreateRouteErrorKind::NotFoundException(_))
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateRouteErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateRouteErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for CreateRouteError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateRouteErrorKind::BadRequestException(_inner) => Some(_inner),
            CreateRouteErrorKind::ConflictException(_inner) => Some(_inner),
            CreateRouteErrorKind::ForbiddenException(_inner) => Some(_inner),
            CreateRouteErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            CreateRouteErrorKind::LimitExceededException(_inner) => Some(_inner),
            CreateRouteErrorKind::NotFoundException(_inner) => Some(_inner),
            CreateRouteErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            CreateRouteErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            CreateRouteErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateVirtualGatewayError {
    pub kind: CreateVirtualGatewayErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateVirtualGatewayErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ConflictException(crate::error::ConflictException),
    ForbiddenException(crate::error::ForbiddenException),
    InternalServerErrorException(crate::error::InternalServerErrorException),
    LimitExceededException(crate::error::LimitExceededException),
    NotFoundException(crate::error::NotFoundException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateVirtualGatewayError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateVirtualGatewayErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            CreateVirtualGatewayErrorKind::ConflictException(_inner) => _inner.fmt(f),
            CreateVirtualGatewayErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            CreateVirtualGatewayErrorKind::InternalServerErrorException(_inner) => _inner.fmt(f),
            CreateVirtualGatewayErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            CreateVirtualGatewayErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            CreateVirtualGatewayErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            CreateVirtualGatewayErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            CreateVirtualGatewayErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateVirtualGatewayError {
    fn code(&self) -> Option<&str> {
        CreateVirtualGatewayError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        match &self.kind {
            CreateVirtualGatewayErrorKind::InternalServerErrorException(inner) => {
                Some(inner.retryable_error_kind())
            }
            CreateVirtualGatewayErrorKind::ServiceUnavailableException(inner) => {
                Some(inner.retryable_error_kind())
            }
            CreateVirtualGatewayErrorKind::TooManyRequestsException(inner) => {
                Some(inner.retryable_error_kind())
            }
            _ => None,
        }
    }
}
impl CreateVirtualGatewayError {
    pub fn new(kind: CreateVirtualGatewayErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateVirtualGatewayErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateVirtualGatewayErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateVirtualGatewayErrorKind::BadRequestException(_)
        )
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateVirtualGatewayErrorKind::ConflictException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateVirtualGatewayErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateVirtualGatewayErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateVirtualGatewayErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateVirtualGatewayErrorKind::NotFoundException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateVirtualGatewayErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateVirtualGatewayErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for CreateVirtualGatewayError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateVirtualGatewayErrorKind::BadRequestException(_inner) => Some(_inner),
            CreateVirtualGatewayErrorKind::ConflictException(_inner) => Some(_inner),
            CreateVirtualGatewayErrorKind::ForbiddenException(_inner) => Some(_inner),
            CreateVirtualGatewayErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            CreateVirtualGatewayErrorKind::LimitExceededException(_inner) => Some(_inner),
            CreateVirtualGatewayErrorKind::NotFoundException(_inner) => Some(_inner),
            CreateVirtualGatewayErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            CreateVirtualGatewayErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            CreateVirtualGatewayErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateVirtualNodeError {
    pub kind: CreateVirtualNodeErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateVirtualNodeErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ConflictException(crate::error::ConflictException),
    ForbiddenException(crate::error::ForbiddenException),
    InternalServerErrorException(crate::error::InternalServerErrorException),
    LimitExceededException(crate::error::LimitExceededException),
    NotFoundException(crate::error::NotFoundException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateVirtualNodeError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateVirtualNodeErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            CreateVirtualNodeErrorKind::ConflictException(_inner) => _inner.fmt(f),
            CreateVirtualNodeErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            CreateVirtualNodeErrorKind::InternalServerErrorException(_inner) => _inner.fmt(f),
            CreateVirtualNodeErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            CreateVirtualNodeErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            CreateVirtualNodeErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            CreateVirtualNodeErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            CreateVirtualNodeErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateVirtualNodeError {
    fn code(&self) -> Option<&str> {
        CreateVirtualNodeError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        match &self.kind {
            CreateVirtualNodeErrorKind::InternalServerErrorException(inner) => {
                Some(inner.retryable_error_kind())
            }
            CreateVirtualNodeErrorKind::ServiceUnavailableException(inner) => {
                Some(inner.retryable_error_kind())
            }
            CreateVirtualNodeErrorKind::TooManyRequestsException(inner) => {
                Some(inner.retryable_error_kind())
            }
            _ => None,
        }
    }
}
impl CreateVirtualNodeError {
    pub fn new(kind: CreateVirtualNodeErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateVirtualNodeErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateVirtualNodeErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateVirtualNodeErrorKind::BadRequestException(_)
        )
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, CreateVirtualNodeErrorKind::ConflictException(_))
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateVirtualNodeErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateVirtualNodeErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateVirtualNodeErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, CreateVirtualNodeErrorKind::NotFoundException(_))
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateVirtualNodeErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateVirtualNodeErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for CreateVirtualNodeError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateVirtualNodeErrorKind::BadRequestException(_inner) => Some(_inner),
            CreateVirtualNodeErrorKind::ConflictException(_inner) => Some(_inner),
            CreateVirtualNodeErrorKind::ForbiddenException(_inner) => Some(_inner),
            CreateVirtualNodeErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            CreateVirtualNodeErrorKind::LimitExceededException(_inner) => Some(_inner),
            CreateVirtualNodeErrorKind::NotFoundException(_inner) => Some(_inner),
            CreateVirtualNodeErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            CreateVirtualNodeErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            CreateVirtualNodeErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateVirtualRouterError {
    pub kind: CreateVirtualRouterErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateVirtualRouterErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ConflictException(crate::error::ConflictException),
    ForbiddenException(crate::error::ForbiddenException),
    InternalServerErrorException(crate::error::InternalServerErrorException),
    LimitExceededException(crate::error::LimitExceededException),
    NotFoundException(crate::error::NotFoundException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateVirtualRouterError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateVirtualRouterErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            CreateVirtualRouterErrorKind::ConflictException(_inner) => _inner.fmt(f),
            CreateVirtualRouterErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            CreateVirtualRouterErrorKind::InternalServerErrorException(_inner) => _inner.fmt(f),
            CreateVirtualRouterErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            CreateVirtualRouterErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            CreateVirtualRouterErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            CreateVirtualRouterErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            CreateVirtualRouterErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateVirtualRouterError {
    fn code(&self) -> Option<&str> {
        CreateVirtualRouterError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        match &self.kind {
            CreateVirtualRouterErrorKind::InternalServerErrorException(inner) => {
                Some(inner.retryable_error_kind())
            }
            CreateVirtualRouterErrorKind::ServiceUnavailableException(inner) => {
                Some(inner.retryable_error_kind())
            }
            CreateVirtualRouterErrorKind::TooManyRequestsException(inner) => {
                Some(inner.retryable_error_kind())
            }
            _ => None,
        }
    }
}
impl CreateVirtualRouterError {
    pub fn new(kind: CreateVirtualRouterErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateVirtualRouterErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateVirtualRouterErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateVirtualRouterErrorKind::BadRequestException(_)
        )
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateVirtualRouterErrorKind::ConflictException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateVirtualRouterErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateVirtualRouterErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateVirtualRouterErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateVirtualRouterErrorKind::NotFoundException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateVirtualRouterErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateVirtualRouterErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for CreateVirtualRouterError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateVirtualRouterErrorKind::BadRequestException(_inner) => Some(_inner),
            CreateVirtualRouterErrorKind::ConflictException(_inner) => Some(_inner),
            CreateVirtualRouterErrorKind::ForbiddenException(_inner) => Some(_inner),
            CreateVirtualRouterErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            CreateVirtualRouterErrorKind::LimitExceededException(_inner) => Some(_inner),
            CreateVirtualRouterErrorKind::NotFoundException(_inner) => Some(_inner),
            CreateVirtualRouterErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            CreateVirtualRouterErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            CreateVirtualRouterErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateVirtualServiceError {
    pub kind: CreateVirtualServiceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateVirtualServiceErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ConflictException(crate::error::ConflictException),
    ForbiddenException(crate::error::ForbiddenException),
    InternalServerErrorException(crate::error::InternalServerErrorException),
    LimitExceededException(crate::error::LimitExceededException),
    NotFoundException(crate::error::NotFoundException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateVirtualServiceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateVirtualServiceErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            CreateVirtualServiceErrorKind::ConflictException(_inner) => _inner.fmt(f),
            CreateVirtualServiceErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            CreateVirtualServiceErrorKind::InternalServerErrorException(_inner) => _inner.fmt(f),
            CreateVirtualServiceErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            CreateVirtualServiceErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            CreateVirtualServiceErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            CreateVirtualServiceErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            CreateVirtualServiceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateVirtualServiceError {
    fn code(&self) -> Option<&str> {
        CreateVirtualServiceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        match &self.kind {
            CreateVirtualServiceErrorKind::InternalServerErrorException(inner) => {
                Some(inner.retryable_error_kind())
            }
            CreateVirtualServiceErrorKind::ServiceUnavailableException(inner) => {
                Some(inner.retryable_error_kind())
            }
            CreateVirtualServiceErrorKind::TooManyRequestsException(inner) => {
                Some(inner.retryable_error_kind())
            }
            _ => None,
        }
    }
}
impl CreateVirtualServiceError {
    pub fn new(kind: CreateVirtualServiceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateVirtualServiceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateVirtualServiceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateVirtualServiceErrorKind::BadRequestException(_)
        )
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateVirtualServiceErrorKind::ConflictException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateVirtualServiceErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateVirtualServiceErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateVirtualServiceErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateVirtualServiceErrorKind::NotFoundException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateVirtualServiceErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateVirtualServiceErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for CreateVirtualServiceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateVirtualServiceErrorKind::BadRequestException(_inner) => Some(_inner),
            CreateVirtualServiceErrorKind::ConflictException(_inner) => Some(_inner),
            CreateVirtualServiceErrorKind::ForbiddenException(_inner) => Some(_inner),
            CreateVirtualServiceErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            CreateVirtualServiceErrorKind::LimitExceededException(_inner) => Some(_inner),
            CreateVirtualServiceErrorKind::NotFoundException(_inner) => Some(_inner),
            CreateVirtualServiceErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            CreateVirtualServiceErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            CreateVirtualServiceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteGatewayRouteError {
    pub kind: DeleteGatewayRouteErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteGatewayRouteErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    InternalServerErrorException(crate::error::InternalServerErrorException),
    NotFoundException(crate::error::NotFoundException),
    ResourceInUseException(crate::error::ResourceInUseException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteGatewayRouteError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteGatewayRouteErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            DeleteGatewayRouteErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            DeleteGatewayRouteErrorKind::InternalServerErrorException(_inner) => _inner.fmt(f),
            DeleteGatewayRouteErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            DeleteGatewayRouteErrorKind::ResourceInUseException(_inner) => _inner.fmt(f),
            DeleteGatewayRouteErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            DeleteGatewayRouteErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            DeleteGatewayRouteErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteGatewayRouteError {
    fn code(&self) -> Option<&str> {
        DeleteGatewayRouteError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        match &self.kind {
            DeleteGatewayRouteErrorKind::InternalServerErrorException(inner) => {
                Some(inner.retryable_error_kind())
            }
            DeleteGatewayRouteErrorKind::ServiceUnavailableException(inner) => {
                Some(inner.retryable_error_kind())
            }
            DeleteGatewayRouteErrorKind::TooManyRequestsException(inner) => {
                Some(inner.retryable_error_kind())
            }
            _ => None,
        }
    }
}
impl DeleteGatewayRouteError {
    pub fn new(kind: DeleteGatewayRouteErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteGatewayRouteErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteGatewayRouteErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteGatewayRouteErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteGatewayRouteErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteGatewayRouteErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteGatewayRouteErrorKind::NotFoundException(_)
        )
    }
    pub fn is_resource_in_use_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteGatewayRouteErrorKind::ResourceInUseException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteGatewayRouteErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteGatewayRouteErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for DeleteGatewayRouteError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteGatewayRouteErrorKind::BadRequestException(_inner) => Some(_inner),
            DeleteGatewayRouteErrorKind::ForbiddenException(_inner) => Some(_inner),
            DeleteGatewayRouteErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            DeleteGatewayRouteErrorKind::NotFoundException(_inner) => Some(_inner),
            DeleteGatewayRouteErrorKind::ResourceInUseException(_inner) => Some(_inner),
            DeleteGatewayRouteErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            DeleteGatewayRouteErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            DeleteGatewayRouteErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteMeshError {
    pub kind: DeleteMeshErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteMeshErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    InternalServerErrorException(crate::error::InternalServerErrorException),
    NotFoundException(crate::error::NotFoundException),
    ResourceInUseException(crate::error::ResourceInUseException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteMeshError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteMeshErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            DeleteMeshErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            DeleteMeshErrorKind::InternalServerErrorException(_inner) => _inner.fmt(f),
            DeleteMeshErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            DeleteMeshErrorKind::ResourceInUseException(_inner) => _inner.fmt(f),
            DeleteMeshErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            DeleteMeshErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            DeleteMeshErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteMeshError {
    fn code(&self) -> Option<&str> {
        DeleteMeshError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        match &self.kind {
            DeleteMeshErrorKind::InternalServerErrorException(inner) => {
                Some(inner.retryable_error_kind())
            }
            DeleteMeshErrorKind::ServiceUnavailableException(inner) => {
                Some(inner.retryable_error_kind())
            }
            DeleteMeshErrorKind::TooManyRequestsException(inner) => {
                Some(inner.retryable_error_kind())
            }
            _ => None,
        }
    }
}
impl DeleteMeshError {
    pub fn new(kind: DeleteMeshErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteMeshErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteMeshErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, DeleteMeshErrorKind::BadRequestException(_))
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, DeleteMeshErrorKind::ForbiddenException(_))
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteMeshErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, DeleteMeshErrorKind::NotFoundException(_))
    }
    pub fn is_resource_in_use_exception(&self) -> bool {
        matches!(&self.kind, DeleteMeshErrorKind::ResourceInUseException(_))
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteMeshErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(&self.kind, DeleteMeshErrorKind::TooManyRequestsException(_))
    }
}
impl std::error::Error for DeleteMeshError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteMeshErrorKind::BadRequestException(_inner) => Some(_inner),
            DeleteMeshErrorKind::ForbiddenException(_inner) => Some(_inner),
            DeleteMeshErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            DeleteMeshErrorKind::NotFoundException(_inner) => Some(_inner),
            DeleteMeshErrorKind::ResourceInUseException(_inner) => Some(_inner),
            DeleteMeshErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            DeleteMeshErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            DeleteMeshErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteRouteError {
    pub kind: DeleteRouteErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteRouteErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    InternalServerErrorException(crate::error::InternalServerErrorException),
    NotFoundException(crate::error::NotFoundException),
    ResourceInUseException(crate::error::ResourceInUseException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteRouteError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteRouteErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            DeleteRouteErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            DeleteRouteErrorKind::InternalServerErrorException(_inner) => _inner.fmt(f),
            DeleteRouteErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            DeleteRouteErrorKind::ResourceInUseException(_inner) => _inner.fmt(f),
            DeleteRouteErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            DeleteRouteErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            DeleteRouteErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteRouteError {
    fn code(&self) -> Option<&str> {
        DeleteRouteError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        match &self.kind {
            DeleteRouteErrorKind::InternalServerErrorException(inner) => {
                Some(inner.retryable_error_kind())
            }
            DeleteRouteErrorKind::ServiceUnavailableException(inner) => {
                Some(inner.retryable_error_kind())
            }
            DeleteRouteErrorKind::TooManyRequestsException(inner) => {
                Some(inner.retryable_error_kind())
            }
            _ => None,
        }
    }
}
impl DeleteRouteError {
    pub fn new(kind: DeleteRouteErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteRouteErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteRouteErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, DeleteRouteErrorKind::BadRequestException(_))
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, DeleteRouteErrorKind::ForbiddenException(_))
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteRouteErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, DeleteRouteErrorKind::NotFoundException(_))
    }
    pub fn is_resource_in_use_exception(&self) -> bool {
        matches!(&self.kind, DeleteRouteErrorKind::ResourceInUseException(_))
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteRouteErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteRouteErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for DeleteRouteError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteRouteErrorKind::BadRequestException(_inner) => Some(_inner),
            DeleteRouteErrorKind::ForbiddenException(_inner) => Some(_inner),
            DeleteRouteErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            DeleteRouteErrorKind::NotFoundException(_inner) => Some(_inner),
            DeleteRouteErrorKind::ResourceInUseException(_inner) => Some(_inner),
            DeleteRouteErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            DeleteRouteErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            DeleteRouteErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteVirtualGatewayError {
    pub kind: DeleteVirtualGatewayErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteVirtualGatewayErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    InternalServerErrorException(crate::error::InternalServerErrorException),
    NotFoundException(crate::error::NotFoundException),
    ResourceInUseException(crate::error::ResourceInUseException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteVirtualGatewayError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteVirtualGatewayErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            DeleteVirtualGatewayErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            DeleteVirtualGatewayErrorKind::InternalServerErrorException(_inner) => _inner.fmt(f),
            DeleteVirtualGatewayErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            DeleteVirtualGatewayErrorKind::ResourceInUseException(_inner) => _inner.fmt(f),
            DeleteVirtualGatewayErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            DeleteVirtualGatewayErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            DeleteVirtualGatewayErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteVirtualGatewayError {
    fn code(&self) -> Option<&str> {
        DeleteVirtualGatewayError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        match &self.kind {
            DeleteVirtualGatewayErrorKind::InternalServerErrorException(inner) => {
                Some(inner.retryable_error_kind())
            }
            DeleteVirtualGatewayErrorKind::ServiceUnavailableException(inner) => {
                Some(inner.retryable_error_kind())
            }
            DeleteVirtualGatewayErrorKind::TooManyRequestsException(inner) => {
                Some(inner.retryable_error_kind())
            }
            _ => None,
        }
    }
}
impl DeleteVirtualGatewayError {
    pub fn new(kind: DeleteVirtualGatewayErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteVirtualGatewayErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteVirtualGatewayErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteVirtualGatewayErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteVirtualGatewayErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteVirtualGatewayErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteVirtualGatewayErrorKind::NotFoundException(_)
        )
    }
    pub fn is_resource_in_use_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteVirtualGatewayErrorKind::ResourceInUseException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteVirtualGatewayErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteVirtualGatewayErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for DeleteVirtualGatewayError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteVirtualGatewayErrorKind::BadRequestException(_inner) => Some(_inner),
            DeleteVirtualGatewayErrorKind::ForbiddenException(_inner) => Some(_inner),
            DeleteVirtualGatewayErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            DeleteVirtualGatewayErrorKind::NotFoundException(_inner) => Some(_inner),
            DeleteVirtualGatewayErrorKind::ResourceInUseException(_inner) => Some(_inner),
            DeleteVirtualGatewayErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            DeleteVirtualGatewayErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            DeleteVirtualGatewayErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteVirtualNodeError {
    pub kind: DeleteVirtualNodeErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteVirtualNodeErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    InternalServerErrorException(crate::error::InternalServerErrorException),
    NotFoundException(crate::error::NotFoundException),
    ResourceInUseException(crate::error::ResourceInUseException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteVirtualNodeError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteVirtualNodeErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            DeleteVirtualNodeErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            DeleteVirtualNodeErrorKind::InternalServerErrorException(_inner) => _inner.fmt(f),
            DeleteVirtualNodeErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            DeleteVirtualNodeErrorKind::ResourceInUseException(_inner) => _inner.fmt(f),
            DeleteVirtualNodeErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            DeleteVirtualNodeErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            DeleteVirtualNodeErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteVirtualNodeError {
    fn code(&self) -> Option<&str> {
        DeleteVirtualNodeError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        match &self.kind {
            DeleteVirtualNodeErrorKind::InternalServerErrorException(inner) => {
                Some(inner.retryable_error_kind())
            }
            DeleteVirtualNodeErrorKind::ServiceUnavailableException(inner) => {
                Some(inner.retryable_error_kind())
            }
            DeleteVirtualNodeErrorKind::TooManyRequestsException(inner) => {
                Some(inner.retryable_error_kind())
            }
            _ => None,
        }
    }
}
impl DeleteVirtualNodeError {
    pub fn new(kind: DeleteVirtualNodeErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteVirtualNodeErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteVirtualNodeErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteVirtualNodeErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteVirtualNodeErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteVirtualNodeErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, DeleteVirtualNodeErrorKind::NotFoundException(_))
    }
    pub fn is_resource_in_use_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteVirtualNodeErrorKind::ResourceInUseException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteVirtualNodeErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteVirtualNodeErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for DeleteVirtualNodeError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteVirtualNodeErrorKind::BadRequestException(_inner) => Some(_inner),
            DeleteVirtualNodeErrorKind::ForbiddenException(_inner) => Some(_inner),
            DeleteVirtualNodeErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            DeleteVirtualNodeErrorKind::NotFoundException(_inner) => Some(_inner),
            DeleteVirtualNodeErrorKind::ResourceInUseException(_inner) => Some(_inner),
            DeleteVirtualNodeErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            DeleteVirtualNodeErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            DeleteVirtualNodeErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteVirtualRouterError {
    pub kind: DeleteVirtualRouterErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteVirtualRouterErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    InternalServerErrorException(crate::error::InternalServerErrorException),
    NotFoundException(crate::error::NotFoundException),
    ResourceInUseException(crate::error::ResourceInUseException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteVirtualRouterError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteVirtualRouterErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            DeleteVirtualRouterErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            DeleteVirtualRouterErrorKind::InternalServerErrorException(_inner) => _inner.fmt(f),
            DeleteVirtualRouterErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            DeleteVirtualRouterErrorKind::ResourceInUseException(_inner) => _inner.fmt(f),
            DeleteVirtualRouterErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            DeleteVirtualRouterErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            DeleteVirtualRouterErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteVirtualRouterError {
    fn code(&self) -> Option<&str> {
        DeleteVirtualRouterError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        match &self.kind {
            DeleteVirtualRouterErrorKind::InternalServerErrorException(inner) => {
                Some(inner.retryable_error_kind())
            }
            DeleteVirtualRouterErrorKind::ServiceUnavailableException(inner) => {
                Some(inner.retryable_error_kind())
            }
            DeleteVirtualRouterErrorKind::TooManyRequestsException(inner) => {
                Some(inner.retryable_error_kind())
            }
            _ => None,
        }
    }
}
impl DeleteVirtualRouterError {
    pub fn new(kind: DeleteVirtualRouterErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteVirtualRouterErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteVirtualRouterErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteVirtualRouterErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteVirtualRouterErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteVirtualRouterErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteVirtualRouterErrorKind::NotFoundException(_)
        )
    }
    pub fn is_resource_in_use_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteVirtualRouterErrorKind::ResourceInUseException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteVirtualRouterErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteVirtualRouterErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for DeleteVirtualRouterError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteVirtualRouterErrorKind::BadRequestException(_inner) => Some(_inner),
            DeleteVirtualRouterErrorKind::ForbiddenException(_inner) => Some(_inner),
            DeleteVirtualRouterErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            DeleteVirtualRouterErrorKind::NotFoundException(_inner) => Some(_inner),
            DeleteVirtualRouterErrorKind::ResourceInUseException(_inner) => Some(_inner),
            DeleteVirtualRouterErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            DeleteVirtualRouterErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            DeleteVirtualRouterErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteVirtualServiceError {
    pub kind: DeleteVirtualServiceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteVirtualServiceErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    InternalServerErrorException(crate::error::InternalServerErrorException),
    NotFoundException(crate::error::NotFoundException),
    ResourceInUseException(crate::error::ResourceInUseException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteVirtualServiceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteVirtualServiceErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            DeleteVirtualServiceErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            DeleteVirtualServiceErrorKind::InternalServerErrorException(_inner) => _inner.fmt(f),
            DeleteVirtualServiceErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            DeleteVirtualServiceErrorKind::ResourceInUseException(_inner) => _inner.fmt(f),
            DeleteVirtualServiceErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            DeleteVirtualServiceErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            DeleteVirtualServiceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteVirtualServiceError {
    fn code(&self) -> Option<&str> {
        DeleteVirtualServiceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        match &self.kind {
            DeleteVirtualServiceErrorKind::InternalServerErrorException(inner) => {
                Some(inner.retryable_error_kind())
            }
            DeleteVirtualServiceErrorKind::ServiceUnavailableException(inner) => {
                Some(inner.retryable_error_kind())
            }
            DeleteVirtualServiceErrorKind::TooManyRequestsException(inner) => {
                Some(inner.retryable_error_kind())
            }
            _ => None,
        }
    }
}
impl DeleteVirtualServiceError {
    pub fn new(kind: DeleteVirtualServiceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteVirtualServiceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteVirtualServiceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteVirtualServiceErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteVirtualServiceErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteVirtualServiceErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteVirtualServiceErrorKind::NotFoundException(_)
        )
    }
    pub fn is_resource_in_use_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteVirtualServiceErrorKind::ResourceInUseException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteVirtualServiceErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteVirtualServiceErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for DeleteVirtualServiceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteVirtualServiceErrorKind::BadRequestException(_inner) => Some(_inner),
            DeleteVirtualServiceErrorKind::ForbiddenException(_inner) => Some(_inner),
            DeleteVirtualServiceErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            DeleteVirtualServiceErrorKind::NotFoundException(_inner) => Some(_inner),
            DeleteVirtualServiceErrorKind::ResourceInUseException(_inner) => Some(_inner),
            DeleteVirtualServiceErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            DeleteVirtualServiceErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            DeleteVirtualServiceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeGatewayRouteError {
    pub kind: DescribeGatewayRouteErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeGatewayRouteErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    InternalServerErrorException(crate::error::InternalServerErrorException),
    NotFoundException(crate::error::NotFoundException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeGatewayRouteError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeGatewayRouteErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            DescribeGatewayRouteErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            DescribeGatewayRouteErrorKind::InternalServerErrorException(_inner) => _inner.fmt(f),
            DescribeGatewayRouteErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            DescribeGatewayRouteErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            DescribeGatewayRouteErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            DescribeGatewayRouteErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeGatewayRouteError {
    fn code(&self) -> Option<&str> {
        DescribeGatewayRouteError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        match &self.kind {
            DescribeGatewayRouteErrorKind::InternalServerErrorException(inner) => {
                Some(inner.retryable_error_kind())
            }
            DescribeGatewayRouteErrorKind::ServiceUnavailableException(inner) => {
                Some(inner.retryable_error_kind())
            }
            DescribeGatewayRouteErrorKind::TooManyRequestsException(inner) => {
                Some(inner.retryable_error_kind())
            }
            _ => None,
        }
    }
}
impl DescribeGatewayRouteError {
    pub fn new(kind: DescribeGatewayRouteErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeGatewayRouteErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeGatewayRouteErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeGatewayRouteErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeGatewayRouteErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeGatewayRouteErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeGatewayRouteErrorKind::NotFoundException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeGatewayRouteErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeGatewayRouteErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for DescribeGatewayRouteError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeGatewayRouteErrorKind::BadRequestException(_inner) => Some(_inner),
            DescribeGatewayRouteErrorKind::ForbiddenException(_inner) => Some(_inner),
            DescribeGatewayRouteErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            DescribeGatewayRouteErrorKind::NotFoundException(_inner) => Some(_inner),
            DescribeGatewayRouteErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            DescribeGatewayRouteErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            DescribeGatewayRouteErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeMeshError {
    pub kind: DescribeMeshErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeMeshErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    InternalServerErrorException(crate::error::InternalServerErrorException),
    NotFoundException(crate::error::NotFoundException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeMeshError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeMeshErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            DescribeMeshErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            DescribeMeshErrorKind::InternalServerErrorException(_inner) => _inner.fmt(f),
            DescribeMeshErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            DescribeMeshErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            DescribeMeshErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            DescribeMeshErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeMeshError {
    fn code(&self) -> Option<&str> {
        DescribeMeshError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        match &self.kind {
            DescribeMeshErrorKind::InternalServerErrorException(inner) => {
                Some(inner.retryable_error_kind())
            }
            DescribeMeshErrorKind::ServiceUnavailableException(inner) => {
                Some(inner.retryable_error_kind())
            }
            DescribeMeshErrorKind::TooManyRequestsException(inner) => {
                Some(inner.retryable_error_kind())
            }
            _ => None,
        }
    }
}
impl DescribeMeshError {
    pub fn new(kind: DescribeMeshErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeMeshErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeMeshErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, DescribeMeshErrorKind::BadRequestException(_))
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, DescribeMeshErrorKind::ForbiddenException(_))
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeMeshErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, DescribeMeshErrorKind::NotFoundException(_))
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeMeshErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeMeshErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for DescribeMeshError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeMeshErrorKind::BadRequestException(_inner) => Some(_inner),
            DescribeMeshErrorKind::ForbiddenException(_inner) => Some(_inner),
            DescribeMeshErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            DescribeMeshErrorKind::NotFoundException(_inner) => Some(_inner),
            DescribeMeshErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            DescribeMeshErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            DescribeMeshErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeRouteError {
    pub kind: DescribeRouteErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeRouteErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    InternalServerErrorException(crate::error::InternalServerErrorException),
    NotFoundException(crate::error::NotFoundException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeRouteError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeRouteErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            DescribeRouteErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            DescribeRouteErrorKind::InternalServerErrorException(_inner) => _inner.fmt(f),
            DescribeRouteErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            DescribeRouteErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            DescribeRouteErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            DescribeRouteErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeRouteError {
    fn code(&self) -> Option<&str> {
        DescribeRouteError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        match &self.kind {
            DescribeRouteErrorKind::InternalServerErrorException(inner) => {
                Some(inner.retryable_error_kind())
            }
            DescribeRouteErrorKind::ServiceUnavailableException(inner) => {
                Some(inner.retryable_error_kind())
            }
            DescribeRouteErrorKind::TooManyRequestsException(inner) => {
                Some(inner.retryable_error_kind())
            }
            _ => None,
        }
    }
}
impl DescribeRouteError {
    pub fn new(kind: DescribeRouteErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeRouteErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeRouteErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, DescribeRouteErrorKind::BadRequestException(_))
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, DescribeRouteErrorKind::ForbiddenException(_))
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeRouteErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, DescribeRouteErrorKind::NotFoundException(_))
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeRouteErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeRouteErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for DescribeRouteError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeRouteErrorKind::BadRequestException(_inner) => Some(_inner),
            DescribeRouteErrorKind::ForbiddenException(_inner) => Some(_inner),
            DescribeRouteErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            DescribeRouteErrorKind::NotFoundException(_inner) => Some(_inner),
            DescribeRouteErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            DescribeRouteErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            DescribeRouteErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeVirtualGatewayError {
    pub kind: DescribeVirtualGatewayErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeVirtualGatewayErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    InternalServerErrorException(crate::error::InternalServerErrorException),
    NotFoundException(crate::error::NotFoundException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeVirtualGatewayError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeVirtualGatewayErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            DescribeVirtualGatewayErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            DescribeVirtualGatewayErrorKind::InternalServerErrorException(_inner) => _inner.fmt(f),
            DescribeVirtualGatewayErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            DescribeVirtualGatewayErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            DescribeVirtualGatewayErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            DescribeVirtualGatewayErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeVirtualGatewayError {
    fn code(&self) -> Option<&str> {
        DescribeVirtualGatewayError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        match &self.kind {
            DescribeVirtualGatewayErrorKind::InternalServerErrorException(inner) => {
                Some(inner.retryable_error_kind())
            }
            DescribeVirtualGatewayErrorKind::ServiceUnavailableException(inner) => {
                Some(inner.retryable_error_kind())
            }
            DescribeVirtualGatewayErrorKind::TooManyRequestsException(inner) => {
                Some(inner.retryable_error_kind())
            }
            _ => None,
        }
    }
}
impl DescribeVirtualGatewayError {
    pub fn new(kind: DescribeVirtualGatewayErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeVirtualGatewayErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeVirtualGatewayErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeVirtualGatewayErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeVirtualGatewayErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeVirtualGatewayErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeVirtualGatewayErrorKind::NotFoundException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeVirtualGatewayErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeVirtualGatewayErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for DescribeVirtualGatewayError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeVirtualGatewayErrorKind::BadRequestException(_inner) => Some(_inner),
            DescribeVirtualGatewayErrorKind::ForbiddenException(_inner) => Some(_inner),
            DescribeVirtualGatewayErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            DescribeVirtualGatewayErrorKind::NotFoundException(_inner) => Some(_inner),
            DescribeVirtualGatewayErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            DescribeVirtualGatewayErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            DescribeVirtualGatewayErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeVirtualNodeError {
    pub kind: DescribeVirtualNodeErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeVirtualNodeErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    InternalServerErrorException(crate::error::InternalServerErrorException),
    NotFoundException(crate::error::NotFoundException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeVirtualNodeError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeVirtualNodeErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            DescribeVirtualNodeErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            DescribeVirtualNodeErrorKind::InternalServerErrorException(_inner) => _inner.fmt(f),
            DescribeVirtualNodeErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            DescribeVirtualNodeErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            DescribeVirtualNodeErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            DescribeVirtualNodeErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeVirtualNodeError {
    fn code(&self) -> Option<&str> {
        DescribeVirtualNodeError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        match &self.kind {
            DescribeVirtualNodeErrorKind::InternalServerErrorException(inner) => {
                Some(inner.retryable_error_kind())
            }
            DescribeVirtualNodeErrorKind::ServiceUnavailableException(inner) => {
                Some(inner.retryable_error_kind())
            }
            DescribeVirtualNodeErrorKind::TooManyRequestsException(inner) => {
                Some(inner.retryable_error_kind())
            }
            _ => None,
        }
    }
}
impl DescribeVirtualNodeError {
    pub fn new(kind: DescribeVirtualNodeErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeVirtualNodeErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeVirtualNodeErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeVirtualNodeErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeVirtualNodeErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeVirtualNodeErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeVirtualNodeErrorKind::NotFoundException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeVirtualNodeErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeVirtualNodeErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for DescribeVirtualNodeError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeVirtualNodeErrorKind::BadRequestException(_inner) => Some(_inner),
            DescribeVirtualNodeErrorKind::ForbiddenException(_inner) => Some(_inner),
            DescribeVirtualNodeErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            DescribeVirtualNodeErrorKind::NotFoundException(_inner) => Some(_inner),
            DescribeVirtualNodeErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            DescribeVirtualNodeErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            DescribeVirtualNodeErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeVirtualRouterError {
    pub kind: DescribeVirtualRouterErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeVirtualRouterErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    InternalServerErrorException(crate::error::InternalServerErrorException),
    NotFoundException(crate::error::NotFoundException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeVirtualRouterError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeVirtualRouterErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            DescribeVirtualRouterErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            DescribeVirtualRouterErrorKind::InternalServerErrorException(_inner) => _inner.fmt(f),
            DescribeVirtualRouterErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            DescribeVirtualRouterErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            DescribeVirtualRouterErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            DescribeVirtualRouterErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeVirtualRouterError {
    fn code(&self) -> Option<&str> {
        DescribeVirtualRouterError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        match &self.kind {
            DescribeVirtualRouterErrorKind::InternalServerErrorException(inner) => {
                Some(inner.retryable_error_kind())
            }
            DescribeVirtualRouterErrorKind::ServiceUnavailableException(inner) => {
                Some(inner.retryable_error_kind())
            }
            DescribeVirtualRouterErrorKind::TooManyRequestsException(inner) => {
                Some(inner.retryable_error_kind())
            }
            _ => None,
        }
    }
}
impl DescribeVirtualRouterError {
    pub fn new(kind: DescribeVirtualRouterErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeVirtualRouterErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeVirtualRouterErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeVirtualRouterErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeVirtualRouterErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeVirtualRouterErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeVirtualRouterErrorKind::NotFoundException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeVirtualRouterErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeVirtualRouterErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for DescribeVirtualRouterError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeVirtualRouterErrorKind::BadRequestException(_inner) => Some(_inner),
            DescribeVirtualRouterErrorKind::ForbiddenException(_inner) => Some(_inner),
            DescribeVirtualRouterErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            DescribeVirtualRouterErrorKind::NotFoundException(_inner) => Some(_inner),
            DescribeVirtualRouterErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            DescribeVirtualRouterErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            DescribeVirtualRouterErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeVirtualServiceError {
    pub kind: DescribeVirtualServiceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeVirtualServiceErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    InternalServerErrorException(crate::error::InternalServerErrorException),
    NotFoundException(crate::error::NotFoundException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeVirtualServiceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeVirtualServiceErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            DescribeVirtualServiceErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            DescribeVirtualServiceErrorKind::InternalServerErrorException(_inner) => _inner.fmt(f),
            DescribeVirtualServiceErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            DescribeVirtualServiceErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            DescribeVirtualServiceErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            DescribeVirtualServiceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeVirtualServiceError {
    fn code(&self) -> Option<&str> {
        DescribeVirtualServiceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        match &self.kind {
            DescribeVirtualServiceErrorKind::InternalServerErrorException(inner) => {
                Some(inner.retryable_error_kind())
            }
            DescribeVirtualServiceErrorKind::ServiceUnavailableException(inner) => {
                Some(inner.retryable_error_kind())
            }
            DescribeVirtualServiceErrorKind::TooManyRequestsException(inner) => {
                Some(inner.retryable_error_kind())
            }
            _ => None,
        }
    }
}
impl DescribeVirtualServiceError {
    pub fn new(kind: DescribeVirtualServiceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeVirtualServiceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeVirtualServiceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeVirtualServiceErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeVirtualServiceErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeVirtualServiceErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeVirtualServiceErrorKind::NotFoundException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeVirtualServiceErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeVirtualServiceErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for DescribeVirtualServiceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeVirtualServiceErrorKind::BadRequestException(_inner) => Some(_inner),
            DescribeVirtualServiceErrorKind::ForbiddenException(_inner) => Some(_inner),
            DescribeVirtualServiceErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            DescribeVirtualServiceErrorKind::NotFoundException(_inner) => Some(_inner),
            DescribeVirtualServiceErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            DescribeVirtualServiceErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            DescribeVirtualServiceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListGatewayRoutesError {
    pub kind: ListGatewayRoutesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListGatewayRoutesErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    InternalServerErrorException(crate::error::InternalServerErrorException),
    NotFoundException(crate::error::NotFoundException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListGatewayRoutesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListGatewayRoutesErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            ListGatewayRoutesErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            ListGatewayRoutesErrorKind::InternalServerErrorException(_inner) => _inner.fmt(f),
            ListGatewayRoutesErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            ListGatewayRoutesErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            ListGatewayRoutesErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            ListGatewayRoutesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListGatewayRoutesError {
    fn code(&self) -> Option<&str> {
        ListGatewayRoutesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        match &self.kind {
            ListGatewayRoutesErrorKind::InternalServerErrorException(inner) => {
                Some(inner.retryable_error_kind())
            }
            ListGatewayRoutesErrorKind::ServiceUnavailableException(inner) => {
                Some(inner.retryable_error_kind())
            }
            ListGatewayRoutesErrorKind::TooManyRequestsException(inner) => {
                Some(inner.retryable_error_kind())
            }
            _ => None,
        }
    }
}
impl ListGatewayRoutesError {
    pub fn new(kind: ListGatewayRoutesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListGatewayRoutesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListGatewayRoutesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListGatewayRoutesErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListGatewayRoutesErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListGatewayRoutesErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, ListGatewayRoutesErrorKind::NotFoundException(_))
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListGatewayRoutesErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListGatewayRoutesErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for ListGatewayRoutesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListGatewayRoutesErrorKind::BadRequestException(_inner) => Some(_inner),
            ListGatewayRoutesErrorKind::ForbiddenException(_inner) => Some(_inner),
            ListGatewayRoutesErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            ListGatewayRoutesErrorKind::NotFoundException(_inner) => Some(_inner),
            ListGatewayRoutesErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            ListGatewayRoutesErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            ListGatewayRoutesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListMeshesError {
    pub kind: ListMeshesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListMeshesErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    InternalServerErrorException(crate::error::InternalServerErrorException),
    NotFoundException(crate::error::NotFoundException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListMeshesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListMeshesErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            ListMeshesErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            ListMeshesErrorKind::InternalServerErrorException(_inner) => _inner.fmt(f),
            ListMeshesErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            ListMeshesErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            ListMeshesErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            ListMeshesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListMeshesError {
    fn code(&self) -> Option<&str> {
        ListMeshesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        match &self.kind {
            ListMeshesErrorKind::InternalServerErrorException(inner) => {
                Some(inner.retryable_error_kind())
            }
            ListMeshesErrorKind::ServiceUnavailableException(inner) => {
                Some(inner.retryable_error_kind())
            }
            ListMeshesErrorKind::TooManyRequestsException(inner) => {
                Some(inner.retryable_error_kind())
            }
            _ => None,
        }
    }
}
impl ListMeshesError {
    pub fn new(kind: ListMeshesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListMeshesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListMeshesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, ListMeshesErrorKind::BadRequestException(_))
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, ListMeshesErrorKind::ForbiddenException(_))
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListMeshesErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, ListMeshesErrorKind::NotFoundException(_))
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListMeshesErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(&self.kind, ListMeshesErrorKind::TooManyRequestsException(_))
    }
}
impl std::error::Error for ListMeshesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListMeshesErrorKind::BadRequestException(_inner) => Some(_inner),
            ListMeshesErrorKind::ForbiddenException(_inner) => Some(_inner),
            ListMeshesErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            ListMeshesErrorKind::NotFoundException(_inner) => Some(_inner),
            ListMeshesErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            ListMeshesErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            ListMeshesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListRoutesError {
    pub kind: ListRoutesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListRoutesErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    InternalServerErrorException(crate::error::InternalServerErrorException),
    NotFoundException(crate::error::NotFoundException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListRoutesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListRoutesErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            ListRoutesErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            ListRoutesErrorKind::InternalServerErrorException(_inner) => _inner.fmt(f),
            ListRoutesErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            ListRoutesErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            ListRoutesErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            ListRoutesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListRoutesError {
    fn code(&self) -> Option<&str> {
        ListRoutesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        match &self.kind {
            ListRoutesErrorKind::InternalServerErrorException(inner) => {
                Some(inner.retryable_error_kind())
            }
            ListRoutesErrorKind::ServiceUnavailableException(inner) => {
                Some(inner.retryable_error_kind())
            }
            ListRoutesErrorKind::TooManyRequestsException(inner) => {
                Some(inner.retryable_error_kind())
            }
            _ => None,
        }
    }
}
impl ListRoutesError {
    pub fn new(kind: ListRoutesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListRoutesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListRoutesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, ListRoutesErrorKind::BadRequestException(_))
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, ListRoutesErrorKind::ForbiddenException(_))
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListRoutesErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, ListRoutesErrorKind::NotFoundException(_))
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListRoutesErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(&self.kind, ListRoutesErrorKind::TooManyRequestsException(_))
    }
}
impl std::error::Error for ListRoutesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListRoutesErrorKind::BadRequestException(_inner) => Some(_inner),
            ListRoutesErrorKind::ForbiddenException(_inner) => Some(_inner),
            ListRoutesErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            ListRoutesErrorKind::NotFoundException(_inner) => Some(_inner),
            ListRoutesErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            ListRoutesErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            ListRoutesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListTagsForResourceError {
    pub kind: ListTagsForResourceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListTagsForResourceErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    InternalServerErrorException(crate::error::InternalServerErrorException),
    NotFoundException(crate::error::NotFoundException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListTagsForResourceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListTagsForResourceErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            ListTagsForResourceErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            ListTagsForResourceErrorKind::InternalServerErrorException(_inner) => _inner.fmt(f),
            ListTagsForResourceErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            ListTagsForResourceErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            ListTagsForResourceErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            ListTagsForResourceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListTagsForResourceError {
    fn code(&self) -> Option<&str> {
        ListTagsForResourceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        match &self.kind {
            ListTagsForResourceErrorKind::InternalServerErrorException(inner) => {
                Some(inner.retryable_error_kind())
            }
            ListTagsForResourceErrorKind::ServiceUnavailableException(inner) => {
                Some(inner.retryable_error_kind())
            }
            ListTagsForResourceErrorKind::TooManyRequestsException(inner) => {
                Some(inner.retryable_error_kind())
            }
            _ => None,
        }
    }
}
impl ListTagsForResourceError {
    pub fn new(kind: ListTagsForResourceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListTagsForResourceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListTagsForResourceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListTagsForResourceErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListTagsForResourceErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListTagsForResourceErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListTagsForResourceErrorKind::NotFoundException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListTagsForResourceErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListTagsForResourceErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for ListTagsForResourceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListTagsForResourceErrorKind::BadRequestException(_inner) => Some(_inner),
            ListTagsForResourceErrorKind::ForbiddenException(_inner) => Some(_inner),
            ListTagsForResourceErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            ListTagsForResourceErrorKind::NotFoundException(_inner) => Some(_inner),
            ListTagsForResourceErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            ListTagsForResourceErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            ListTagsForResourceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListVirtualGatewaysError {
    pub kind: ListVirtualGatewaysErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListVirtualGatewaysErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    InternalServerErrorException(crate::error::InternalServerErrorException),
    NotFoundException(crate::error::NotFoundException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListVirtualGatewaysError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListVirtualGatewaysErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            ListVirtualGatewaysErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            ListVirtualGatewaysErrorKind::InternalServerErrorException(_inner) => _inner.fmt(f),
            ListVirtualGatewaysErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            ListVirtualGatewaysErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            ListVirtualGatewaysErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            ListVirtualGatewaysErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListVirtualGatewaysError {
    fn code(&self) -> Option<&str> {
        ListVirtualGatewaysError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        match &self.kind {
            ListVirtualGatewaysErrorKind::InternalServerErrorException(inner) => {
                Some(inner.retryable_error_kind())
            }
            ListVirtualGatewaysErrorKind::ServiceUnavailableException(inner) => {
                Some(inner.retryable_error_kind())
            }
            ListVirtualGatewaysErrorKind::TooManyRequestsException(inner) => {
                Some(inner.retryable_error_kind())
            }
            _ => None,
        }
    }
}
impl ListVirtualGatewaysError {
    pub fn new(kind: ListVirtualGatewaysErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListVirtualGatewaysErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListVirtualGatewaysErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListVirtualGatewaysErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListVirtualGatewaysErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListVirtualGatewaysErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListVirtualGatewaysErrorKind::NotFoundException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListVirtualGatewaysErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListVirtualGatewaysErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for ListVirtualGatewaysError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListVirtualGatewaysErrorKind::BadRequestException(_inner) => Some(_inner),
            ListVirtualGatewaysErrorKind::ForbiddenException(_inner) => Some(_inner),
            ListVirtualGatewaysErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            ListVirtualGatewaysErrorKind::NotFoundException(_inner) => Some(_inner),
            ListVirtualGatewaysErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            ListVirtualGatewaysErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            ListVirtualGatewaysErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListVirtualNodesError {
    pub kind: ListVirtualNodesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListVirtualNodesErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    InternalServerErrorException(crate::error::InternalServerErrorException),
    NotFoundException(crate::error::NotFoundException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListVirtualNodesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListVirtualNodesErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            ListVirtualNodesErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            ListVirtualNodesErrorKind::InternalServerErrorException(_inner) => _inner.fmt(f),
            ListVirtualNodesErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            ListVirtualNodesErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            ListVirtualNodesErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            ListVirtualNodesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListVirtualNodesError {
    fn code(&self) -> Option<&str> {
        ListVirtualNodesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        match &self.kind {
            ListVirtualNodesErrorKind::InternalServerErrorException(inner) => {
                Some(inner.retryable_error_kind())
            }
            ListVirtualNodesErrorKind::ServiceUnavailableException(inner) => {
                Some(inner.retryable_error_kind())
            }
            ListVirtualNodesErrorKind::TooManyRequestsException(inner) => {
                Some(inner.retryable_error_kind())
            }
            _ => None,
        }
    }
}
impl ListVirtualNodesError {
    pub fn new(kind: ListVirtualNodesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListVirtualNodesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListVirtualNodesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListVirtualNodesErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, ListVirtualNodesErrorKind::ForbiddenException(_))
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListVirtualNodesErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, ListVirtualNodesErrorKind::NotFoundException(_))
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListVirtualNodesErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListVirtualNodesErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for ListVirtualNodesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListVirtualNodesErrorKind::BadRequestException(_inner) => Some(_inner),
            ListVirtualNodesErrorKind::ForbiddenException(_inner) => Some(_inner),
            ListVirtualNodesErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            ListVirtualNodesErrorKind::NotFoundException(_inner) => Some(_inner),
            ListVirtualNodesErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            ListVirtualNodesErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            ListVirtualNodesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListVirtualRoutersError {
    pub kind: ListVirtualRoutersErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListVirtualRoutersErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    InternalServerErrorException(crate::error::InternalServerErrorException),
    NotFoundException(crate::error::NotFoundException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListVirtualRoutersError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListVirtualRoutersErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            ListVirtualRoutersErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            ListVirtualRoutersErrorKind::InternalServerErrorException(_inner) => _inner.fmt(f),
            ListVirtualRoutersErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            ListVirtualRoutersErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            ListVirtualRoutersErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            ListVirtualRoutersErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListVirtualRoutersError {
    fn code(&self) -> Option<&str> {
        ListVirtualRoutersError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        match &self.kind {
            ListVirtualRoutersErrorKind::InternalServerErrorException(inner) => {
                Some(inner.retryable_error_kind())
            }
            ListVirtualRoutersErrorKind::ServiceUnavailableException(inner) => {
                Some(inner.retryable_error_kind())
            }
            ListVirtualRoutersErrorKind::TooManyRequestsException(inner) => {
                Some(inner.retryable_error_kind())
            }
            _ => None,
        }
    }
}
impl ListVirtualRoutersError {
    pub fn new(kind: ListVirtualRoutersErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListVirtualRoutersErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListVirtualRoutersErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListVirtualRoutersErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListVirtualRoutersErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListVirtualRoutersErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListVirtualRoutersErrorKind::NotFoundException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListVirtualRoutersErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListVirtualRoutersErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for ListVirtualRoutersError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListVirtualRoutersErrorKind::BadRequestException(_inner) => Some(_inner),
            ListVirtualRoutersErrorKind::ForbiddenException(_inner) => Some(_inner),
            ListVirtualRoutersErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            ListVirtualRoutersErrorKind::NotFoundException(_inner) => Some(_inner),
            ListVirtualRoutersErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            ListVirtualRoutersErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            ListVirtualRoutersErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListVirtualServicesError {
    pub kind: ListVirtualServicesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListVirtualServicesErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    InternalServerErrorException(crate::error::InternalServerErrorException),
    NotFoundException(crate::error::NotFoundException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListVirtualServicesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListVirtualServicesErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            ListVirtualServicesErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            ListVirtualServicesErrorKind::InternalServerErrorException(_inner) => _inner.fmt(f),
            ListVirtualServicesErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            ListVirtualServicesErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            ListVirtualServicesErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            ListVirtualServicesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListVirtualServicesError {
    fn code(&self) -> Option<&str> {
        ListVirtualServicesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        match &self.kind {
            ListVirtualServicesErrorKind::InternalServerErrorException(inner) => {
                Some(inner.retryable_error_kind())
            }
            ListVirtualServicesErrorKind::ServiceUnavailableException(inner) => {
                Some(inner.retryable_error_kind())
            }
            ListVirtualServicesErrorKind::TooManyRequestsException(inner) => {
                Some(inner.retryable_error_kind())
            }
            _ => None,
        }
    }
}
impl ListVirtualServicesError {
    pub fn new(kind: ListVirtualServicesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListVirtualServicesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListVirtualServicesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListVirtualServicesErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListVirtualServicesErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListVirtualServicesErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListVirtualServicesErrorKind::NotFoundException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListVirtualServicesErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListVirtualServicesErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for ListVirtualServicesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListVirtualServicesErrorKind::BadRequestException(_inner) => Some(_inner),
            ListVirtualServicesErrorKind::ForbiddenException(_inner) => Some(_inner),
            ListVirtualServicesErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            ListVirtualServicesErrorKind::NotFoundException(_inner) => Some(_inner),
            ListVirtualServicesErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            ListVirtualServicesErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            ListVirtualServicesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct TagResourceError {
    pub kind: TagResourceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum TagResourceErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    InternalServerErrorException(crate::error::InternalServerErrorException),
    NotFoundException(crate::error::NotFoundException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    TooManyTagsException(crate::error::TooManyTagsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for TagResourceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            TagResourceErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            TagResourceErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            TagResourceErrorKind::InternalServerErrorException(_inner) => _inner.fmt(f),
            TagResourceErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            TagResourceErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            TagResourceErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            TagResourceErrorKind::TooManyTagsException(_inner) => _inner.fmt(f),
            TagResourceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for TagResourceError {
    fn code(&self) -> Option<&str> {
        TagResourceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        match &self.kind {
            TagResourceErrorKind::InternalServerErrorException(inner) => {
                Some(inner.retryable_error_kind())
            }
            TagResourceErrorKind::ServiceUnavailableException(inner) => {
                Some(inner.retryable_error_kind())
            }
            TagResourceErrorKind::TooManyRequestsException(inner) => {
                Some(inner.retryable_error_kind())
            }
            _ => None,
        }
    }
}
impl TagResourceError {
    pub fn new(kind: TagResourceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: TagResourceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: TagResourceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, TagResourceErrorKind::BadRequestException(_))
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, TagResourceErrorKind::ForbiddenException(_))
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            TagResourceErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, TagResourceErrorKind::NotFoundException(_))
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            TagResourceErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            TagResourceErrorKind::TooManyRequestsException(_)
        )
    }
    pub fn is_too_many_tags_exception(&self) -> bool {
        matches!(&self.kind, TagResourceErrorKind::TooManyTagsException(_))
    }
}
impl std::error::Error for TagResourceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            TagResourceErrorKind::BadRequestException(_inner) => Some(_inner),
            TagResourceErrorKind::ForbiddenException(_inner) => Some(_inner),
            TagResourceErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            TagResourceErrorKind::NotFoundException(_inner) => Some(_inner),
            TagResourceErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            TagResourceErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            TagResourceErrorKind::TooManyTagsException(_inner) => Some(_inner),
            TagResourceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UntagResourceError {
    pub kind: UntagResourceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UntagResourceErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    InternalServerErrorException(crate::error::InternalServerErrorException),
    NotFoundException(crate::error::NotFoundException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UntagResourceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UntagResourceErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            UntagResourceErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            UntagResourceErrorKind::InternalServerErrorException(_inner) => _inner.fmt(f),
            UntagResourceErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            UntagResourceErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            UntagResourceErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            UntagResourceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UntagResourceError {
    fn code(&self) -> Option<&str> {
        UntagResourceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        match &self.kind {
            UntagResourceErrorKind::InternalServerErrorException(inner) => {
                Some(inner.retryable_error_kind())
            }
            UntagResourceErrorKind::ServiceUnavailableException(inner) => {
                Some(inner.retryable_error_kind())
            }
            UntagResourceErrorKind::TooManyRequestsException(inner) => {
                Some(inner.retryable_error_kind())
            }
            _ => None,
        }
    }
}
impl UntagResourceError {
    pub fn new(kind: UntagResourceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UntagResourceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UntagResourceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, UntagResourceErrorKind::BadRequestException(_))
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, UntagResourceErrorKind::ForbiddenException(_))
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            UntagResourceErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, UntagResourceErrorKind::NotFoundException(_))
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            UntagResourceErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            UntagResourceErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for UntagResourceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UntagResourceErrorKind::BadRequestException(_inner) => Some(_inner),
            UntagResourceErrorKind::ForbiddenException(_inner) => Some(_inner),
            UntagResourceErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            UntagResourceErrorKind::NotFoundException(_inner) => Some(_inner),
            UntagResourceErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            UntagResourceErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            UntagResourceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateGatewayRouteError {
    pub kind: UpdateGatewayRouteErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateGatewayRouteErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ConflictException(crate::error::ConflictException),
    ForbiddenException(crate::error::ForbiddenException),
    InternalServerErrorException(crate::error::InternalServerErrorException),
    LimitExceededException(crate::error::LimitExceededException),
    NotFoundException(crate::error::NotFoundException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateGatewayRouteError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateGatewayRouteErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            UpdateGatewayRouteErrorKind::ConflictException(_inner) => _inner.fmt(f),
            UpdateGatewayRouteErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            UpdateGatewayRouteErrorKind::InternalServerErrorException(_inner) => _inner.fmt(f),
            UpdateGatewayRouteErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            UpdateGatewayRouteErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            UpdateGatewayRouteErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            UpdateGatewayRouteErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            UpdateGatewayRouteErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateGatewayRouteError {
    fn code(&self) -> Option<&str> {
        UpdateGatewayRouteError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        match &self.kind {
            UpdateGatewayRouteErrorKind::InternalServerErrorException(inner) => {
                Some(inner.retryable_error_kind())
            }
            UpdateGatewayRouteErrorKind::ServiceUnavailableException(inner) => {
                Some(inner.retryable_error_kind())
            }
            UpdateGatewayRouteErrorKind::TooManyRequestsException(inner) => {
                Some(inner.retryable_error_kind())
            }
            _ => None,
        }
    }
}
impl UpdateGatewayRouteError {
    pub fn new(kind: UpdateGatewayRouteErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateGatewayRouteErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateGatewayRouteErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateGatewayRouteErrorKind::BadRequestException(_)
        )
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateGatewayRouteErrorKind::ConflictException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateGatewayRouteErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateGatewayRouteErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateGatewayRouteErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateGatewayRouteErrorKind::NotFoundException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateGatewayRouteErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateGatewayRouteErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for UpdateGatewayRouteError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateGatewayRouteErrorKind::BadRequestException(_inner) => Some(_inner),
            UpdateGatewayRouteErrorKind::ConflictException(_inner) => Some(_inner),
            UpdateGatewayRouteErrorKind::ForbiddenException(_inner) => Some(_inner),
            UpdateGatewayRouteErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            UpdateGatewayRouteErrorKind::LimitExceededException(_inner) => Some(_inner),
            UpdateGatewayRouteErrorKind::NotFoundException(_inner) => Some(_inner),
            UpdateGatewayRouteErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            UpdateGatewayRouteErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            UpdateGatewayRouteErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateMeshError {
    pub kind: UpdateMeshErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateMeshErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ConflictException(crate::error::ConflictException),
    ForbiddenException(crate::error::ForbiddenException),
    InternalServerErrorException(crate::error::InternalServerErrorException),
    NotFoundException(crate::error::NotFoundException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateMeshError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateMeshErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            UpdateMeshErrorKind::ConflictException(_inner) => _inner.fmt(f),
            UpdateMeshErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            UpdateMeshErrorKind::InternalServerErrorException(_inner) => _inner.fmt(f),
            UpdateMeshErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            UpdateMeshErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            UpdateMeshErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            UpdateMeshErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateMeshError {
    fn code(&self) -> Option<&str> {
        UpdateMeshError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        match &self.kind {
            UpdateMeshErrorKind::InternalServerErrorException(inner) => {
                Some(inner.retryable_error_kind())
            }
            UpdateMeshErrorKind::ServiceUnavailableException(inner) => {
                Some(inner.retryable_error_kind())
            }
            UpdateMeshErrorKind::TooManyRequestsException(inner) => {
                Some(inner.retryable_error_kind())
            }
            _ => None,
        }
    }
}
impl UpdateMeshError {
    pub fn new(kind: UpdateMeshErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateMeshErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateMeshErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, UpdateMeshErrorKind::BadRequestException(_))
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, UpdateMeshErrorKind::ConflictException(_))
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, UpdateMeshErrorKind::ForbiddenException(_))
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateMeshErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, UpdateMeshErrorKind::NotFoundException(_))
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateMeshErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(&self.kind, UpdateMeshErrorKind::TooManyRequestsException(_))
    }
}
impl std::error::Error for UpdateMeshError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateMeshErrorKind::BadRequestException(_inner) => Some(_inner),
            UpdateMeshErrorKind::ConflictException(_inner) => Some(_inner),
            UpdateMeshErrorKind::ForbiddenException(_inner) => Some(_inner),
            UpdateMeshErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            UpdateMeshErrorKind::NotFoundException(_inner) => Some(_inner),
            UpdateMeshErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            UpdateMeshErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            UpdateMeshErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateRouteError {
    pub kind: UpdateRouteErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateRouteErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ConflictException(crate::error::ConflictException),
    ForbiddenException(crate::error::ForbiddenException),
    InternalServerErrorException(crate::error::InternalServerErrorException),
    LimitExceededException(crate::error::LimitExceededException),
    NotFoundException(crate::error::NotFoundException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateRouteError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateRouteErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            UpdateRouteErrorKind::ConflictException(_inner) => _inner.fmt(f),
            UpdateRouteErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            UpdateRouteErrorKind::InternalServerErrorException(_inner) => _inner.fmt(f),
            UpdateRouteErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            UpdateRouteErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            UpdateRouteErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            UpdateRouteErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            UpdateRouteErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateRouteError {
    fn code(&self) -> Option<&str> {
        UpdateRouteError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        match &self.kind {
            UpdateRouteErrorKind::InternalServerErrorException(inner) => {
                Some(inner.retryable_error_kind())
            }
            UpdateRouteErrorKind::ServiceUnavailableException(inner) => {
                Some(inner.retryable_error_kind())
            }
            UpdateRouteErrorKind::TooManyRequestsException(inner) => {
                Some(inner.retryable_error_kind())
            }
            _ => None,
        }
    }
}
impl UpdateRouteError {
    pub fn new(kind: UpdateRouteErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateRouteErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateRouteErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, UpdateRouteErrorKind::BadRequestException(_))
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, UpdateRouteErrorKind::ConflictException(_))
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, UpdateRouteErrorKind::ForbiddenException(_))
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateRouteErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(&self.kind, UpdateRouteErrorKind::LimitExceededException(_))
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, UpdateRouteErrorKind::NotFoundException(_))
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateRouteErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateRouteErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for UpdateRouteError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateRouteErrorKind::BadRequestException(_inner) => Some(_inner),
            UpdateRouteErrorKind::ConflictException(_inner) => Some(_inner),
            UpdateRouteErrorKind::ForbiddenException(_inner) => Some(_inner),
            UpdateRouteErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            UpdateRouteErrorKind::LimitExceededException(_inner) => Some(_inner),
            UpdateRouteErrorKind::NotFoundException(_inner) => Some(_inner),
            UpdateRouteErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            UpdateRouteErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            UpdateRouteErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateVirtualGatewayError {
    pub kind: UpdateVirtualGatewayErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateVirtualGatewayErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ConflictException(crate::error::ConflictException),
    ForbiddenException(crate::error::ForbiddenException),
    InternalServerErrorException(crate::error::InternalServerErrorException),
    LimitExceededException(crate::error::LimitExceededException),
    NotFoundException(crate::error::NotFoundException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateVirtualGatewayError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateVirtualGatewayErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            UpdateVirtualGatewayErrorKind::ConflictException(_inner) => _inner.fmt(f),
            UpdateVirtualGatewayErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            UpdateVirtualGatewayErrorKind::InternalServerErrorException(_inner) => _inner.fmt(f),
            UpdateVirtualGatewayErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            UpdateVirtualGatewayErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            UpdateVirtualGatewayErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            UpdateVirtualGatewayErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            UpdateVirtualGatewayErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateVirtualGatewayError {
    fn code(&self) -> Option<&str> {
        UpdateVirtualGatewayError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        match &self.kind {
            UpdateVirtualGatewayErrorKind::InternalServerErrorException(inner) => {
                Some(inner.retryable_error_kind())
            }
            UpdateVirtualGatewayErrorKind::ServiceUnavailableException(inner) => {
                Some(inner.retryable_error_kind())
            }
            UpdateVirtualGatewayErrorKind::TooManyRequestsException(inner) => {
                Some(inner.retryable_error_kind())
            }
            _ => None,
        }
    }
}
impl UpdateVirtualGatewayError {
    pub fn new(kind: UpdateVirtualGatewayErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateVirtualGatewayErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateVirtualGatewayErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateVirtualGatewayErrorKind::BadRequestException(_)
        )
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateVirtualGatewayErrorKind::ConflictException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateVirtualGatewayErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateVirtualGatewayErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateVirtualGatewayErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateVirtualGatewayErrorKind::NotFoundException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateVirtualGatewayErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateVirtualGatewayErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for UpdateVirtualGatewayError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateVirtualGatewayErrorKind::BadRequestException(_inner) => Some(_inner),
            UpdateVirtualGatewayErrorKind::ConflictException(_inner) => Some(_inner),
            UpdateVirtualGatewayErrorKind::ForbiddenException(_inner) => Some(_inner),
            UpdateVirtualGatewayErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            UpdateVirtualGatewayErrorKind::LimitExceededException(_inner) => Some(_inner),
            UpdateVirtualGatewayErrorKind::NotFoundException(_inner) => Some(_inner),
            UpdateVirtualGatewayErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            UpdateVirtualGatewayErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            UpdateVirtualGatewayErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateVirtualNodeError {
    pub kind: UpdateVirtualNodeErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateVirtualNodeErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ConflictException(crate::error::ConflictException),
    ForbiddenException(crate::error::ForbiddenException),
    InternalServerErrorException(crate::error::InternalServerErrorException),
    LimitExceededException(crate::error::LimitExceededException),
    NotFoundException(crate::error::NotFoundException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateVirtualNodeError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateVirtualNodeErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            UpdateVirtualNodeErrorKind::ConflictException(_inner) => _inner.fmt(f),
            UpdateVirtualNodeErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            UpdateVirtualNodeErrorKind::InternalServerErrorException(_inner) => _inner.fmt(f),
            UpdateVirtualNodeErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            UpdateVirtualNodeErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            UpdateVirtualNodeErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            UpdateVirtualNodeErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            UpdateVirtualNodeErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateVirtualNodeError {
    fn code(&self) -> Option<&str> {
        UpdateVirtualNodeError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        match &self.kind {
            UpdateVirtualNodeErrorKind::InternalServerErrorException(inner) => {
                Some(inner.retryable_error_kind())
            }
            UpdateVirtualNodeErrorKind::ServiceUnavailableException(inner) => {
                Some(inner.retryable_error_kind())
            }
            UpdateVirtualNodeErrorKind::TooManyRequestsException(inner) => {
                Some(inner.retryable_error_kind())
            }
            _ => None,
        }
    }
}
impl UpdateVirtualNodeError {
    pub fn new(kind: UpdateVirtualNodeErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateVirtualNodeErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateVirtualNodeErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateVirtualNodeErrorKind::BadRequestException(_)
        )
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, UpdateVirtualNodeErrorKind::ConflictException(_))
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateVirtualNodeErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateVirtualNodeErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateVirtualNodeErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, UpdateVirtualNodeErrorKind::NotFoundException(_))
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateVirtualNodeErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateVirtualNodeErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for UpdateVirtualNodeError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateVirtualNodeErrorKind::BadRequestException(_inner) => Some(_inner),
            UpdateVirtualNodeErrorKind::ConflictException(_inner) => Some(_inner),
            UpdateVirtualNodeErrorKind::ForbiddenException(_inner) => Some(_inner),
            UpdateVirtualNodeErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            UpdateVirtualNodeErrorKind::LimitExceededException(_inner) => Some(_inner),
            UpdateVirtualNodeErrorKind::NotFoundException(_inner) => Some(_inner),
            UpdateVirtualNodeErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            UpdateVirtualNodeErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            UpdateVirtualNodeErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateVirtualRouterError {
    pub kind: UpdateVirtualRouterErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateVirtualRouterErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ConflictException(crate::error::ConflictException),
    ForbiddenException(crate::error::ForbiddenException),
    InternalServerErrorException(crate::error::InternalServerErrorException),
    LimitExceededException(crate::error::LimitExceededException),
    NotFoundException(crate::error::NotFoundException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateVirtualRouterError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateVirtualRouterErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            UpdateVirtualRouterErrorKind::ConflictException(_inner) => _inner.fmt(f),
            UpdateVirtualRouterErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            UpdateVirtualRouterErrorKind::InternalServerErrorException(_inner) => _inner.fmt(f),
            UpdateVirtualRouterErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            UpdateVirtualRouterErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            UpdateVirtualRouterErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            UpdateVirtualRouterErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            UpdateVirtualRouterErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateVirtualRouterError {
    fn code(&self) -> Option<&str> {
        UpdateVirtualRouterError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        match &self.kind {
            UpdateVirtualRouterErrorKind::InternalServerErrorException(inner) => {
                Some(inner.retryable_error_kind())
            }
            UpdateVirtualRouterErrorKind::ServiceUnavailableException(inner) => {
                Some(inner.retryable_error_kind())
            }
            UpdateVirtualRouterErrorKind::TooManyRequestsException(inner) => {
                Some(inner.retryable_error_kind())
            }
            _ => None,
        }
    }
}
impl UpdateVirtualRouterError {
    pub fn new(kind: UpdateVirtualRouterErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateVirtualRouterErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateVirtualRouterErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateVirtualRouterErrorKind::BadRequestException(_)
        )
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateVirtualRouterErrorKind::ConflictException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateVirtualRouterErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateVirtualRouterErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateVirtualRouterErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateVirtualRouterErrorKind::NotFoundException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateVirtualRouterErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateVirtualRouterErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for UpdateVirtualRouterError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateVirtualRouterErrorKind::BadRequestException(_inner) => Some(_inner),
            UpdateVirtualRouterErrorKind::ConflictException(_inner) => Some(_inner),
            UpdateVirtualRouterErrorKind::ForbiddenException(_inner) => Some(_inner),
            UpdateVirtualRouterErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            UpdateVirtualRouterErrorKind::LimitExceededException(_inner) => Some(_inner),
            UpdateVirtualRouterErrorKind::NotFoundException(_inner) => Some(_inner),
            UpdateVirtualRouterErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            UpdateVirtualRouterErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            UpdateVirtualRouterErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateVirtualServiceError {
    pub kind: UpdateVirtualServiceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateVirtualServiceErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ConflictException(crate::error::ConflictException),
    ForbiddenException(crate::error::ForbiddenException),
    InternalServerErrorException(crate::error::InternalServerErrorException),
    LimitExceededException(crate::error::LimitExceededException),
    NotFoundException(crate::error::NotFoundException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateVirtualServiceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateVirtualServiceErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            UpdateVirtualServiceErrorKind::ConflictException(_inner) => _inner.fmt(f),
            UpdateVirtualServiceErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            UpdateVirtualServiceErrorKind::InternalServerErrorException(_inner) => _inner.fmt(f),
            UpdateVirtualServiceErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            UpdateVirtualServiceErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            UpdateVirtualServiceErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            UpdateVirtualServiceErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            UpdateVirtualServiceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateVirtualServiceError {
    fn code(&self) -> Option<&str> {
        UpdateVirtualServiceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        match &self.kind {
            UpdateVirtualServiceErrorKind::InternalServerErrorException(inner) => {
                Some(inner.retryable_error_kind())
            }
            UpdateVirtualServiceErrorKind::ServiceUnavailableException(inner) => {
                Some(inner.retryable_error_kind())
            }
            UpdateVirtualServiceErrorKind::TooManyRequestsException(inner) => {
                Some(inner.retryable_error_kind())
            }
            _ => None,
        }
    }
}
impl UpdateVirtualServiceError {
    pub fn new(kind: UpdateVirtualServiceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateVirtualServiceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateVirtualServiceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateVirtualServiceErrorKind::BadRequestException(_)
        )
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateVirtualServiceErrorKind::ConflictException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateVirtualServiceErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateVirtualServiceErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateVirtualServiceErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateVirtualServiceErrorKind::NotFoundException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateVirtualServiceErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateVirtualServiceErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for UpdateVirtualServiceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateVirtualServiceErrorKind::BadRequestException(_inner) => Some(_inner),
            UpdateVirtualServiceErrorKind::ConflictException(_inner) => Some(_inner),
            UpdateVirtualServiceErrorKind::ForbiddenException(_inner) => Some(_inner),
            UpdateVirtualServiceErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            UpdateVirtualServiceErrorKind::LimitExceededException(_inner) => Some(_inner),
            UpdateVirtualServiceErrorKind::NotFoundException(_inner) => Some(_inner),
            UpdateVirtualServiceErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            UpdateVirtualServiceErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            UpdateVirtualServiceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// <p>The maximum request rate permitted by the App Mesh APIs has been exceeded for your
/// account. For best results, use an increasing or variable sleep interval between
/// requests.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TooManyRequestsException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for TooManyRequestsException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TooManyRequestsException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl TooManyRequestsException {
    pub fn retryable_error_kind(&self) -> smithy_types::retry::ErrorKind {
        smithy_types::retry::ErrorKind::ThrottlingError
    }
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for TooManyRequestsException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "TooManyRequestsException")?;
        if let Some(inner_1) = &self.message {
            write!(f, ": {}", inner_1)?;
        }
        Ok(())
    }
}
impl std::error::Error for TooManyRequestsException {}
/// See [`TooManyRequestsException`](crate::error::TooManyRequestsException)
pub mod too_many_requests_exception {
    /// A builder for [`TooManyRequestsException`](crate::error::TooManyRequestsException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`TooManyRequestsException`](crate::error::TooManyRequestsException)
        pub fn build(self) -> crate::error::TooManyRequestsException {
            crate::error::TooManyRequestsException {
                message: self.message,
            }
        }
    }
}
impl TooManyRequestsException {
    /// Creates a new builder-style object to manufacture [`TooManyRequestsException`](crate::error::TooManyRequestsException)
    pub fn builder() -> crate::error::too_many_requests_exception::Builder {
        crate::error::too_many_requests_exception::Builder::default()
    }
}

/// <p>The request has failed due to a temporary failure of the service.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ServiceUnavailableException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ServiceUnavailableException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ServiceUnavailableException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ServiceUnavailableException {
    pub fn retryable_error_kind(&self) -> smithy_types::retry::ErrorKind {
        smithy_types::retry::ErrorKind::ServerError
    }
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ServiceUnavailableException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ServiceUnavailableException")?;
        if let Some(inner_2) = &self.message {
            write!(f, ": {}", inner_2)?;
        }
        Ok(())
    }
}
impl std::error::Error for ServiceUnavailableException {}
/// See [`ServiceUnavailableException`](crate::error::ServiceUnavailableException)
pub mod service_unavailable_exception {
    /// A builder for [`ServiceUnavailableException`](crate::error::ServiceUnavailableException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ServiceUnavailableException`](crate::error::ServiceUnavailableException)
        pub fn build(self) -> crate::error::ServiceUnavailableException {
            crate::error::ServiceUnavailableException {
                message: self.message,
            }
        }
    }
}
impl ServiceUnavailableException {
    /// Creates a new builder-style object to manufacture [`ServiceUnavailableException`](crate::error::ServiceUnavailableException)
    pub fn builder() -> crate::error::service_unavailable_exception::Builder {
        crate::error::service_unavailable_exception::Builder::default()
    }
}

/// <p>The specified resource doesn't exist. Check your request syntax and try again.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct NotFoundException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for NotFoundException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("NotFoundException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl NotFoundException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for NotFoundException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "NotFoundException")?;
        if let Some(inner_3) = &self.message {
            write!(f, ": {}", inner_3)?;
        }
        Ok(())
    }
}
impl std::error::Error for NotFoundException {}
/// See [`NotFoundException`](crate::error::NotFoundException)
pub mod not_found_exception {
    /// A builder for [`NotFoundException`](crate::error::NotFoundException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`NotFoundException`](crate::error::NotFoundException)
        pub fn build(self) -> crate::error::NotFoundException {
            crate::error::NotFoundException {
                message: self.message,
            }
        }
    }
}
impl NotFoundException {
    /// Creates a new builder-style object to manufacture [`NotFoundException`](crate::error::NotFoundException)
    pub fn builder() -> crate::error::not_found_exception::Builder {
        crate::error::not_found_exception::Builder::default()
    }
}

/// <p>The request processing has failed because of an unknown error, exception, or
/// failure.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InternalServerErrorException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InternalServerErrorException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InternalServerErrorException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InternalServerErrorException {
    pub fn retryable_error_kind(&self) -> smithy_types::retry::ErrorKind {
        smithy_types::retry::ErrorKind::ServerError
    }
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InternalServerErrorException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InternalServerErrorException")?;
        if let Some(inner_4) = &self.message {
            write!(f, ": {}", inner_4)?;
        }
        Ok(())
    }
}
impl std::error::Error for InternalServerErrorException {}
/// See [`InternalServerErrorException`](crate::error::InternalServerErrorException)
pub mod internal_server_error_exception {
    /// A builder for [`InternalServerErrorException`](crate::error::InternalServerErrorException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InternalServerErrorException`](crate::error::InternalServerErrorException)
        pub fn build(self) -> crate::error::InternalServerErrorException {
            crate::error::InternalServerErrorException {
                message: self.message,
            }
        }
    }
}
impl InternalServerErrorException {
    /// Creates a new builder-style object to manufacture [`InternalServerErrorException`](crate::error::InternalServerErrorException)
    pub fn builder() -> crate::error::internal_server_error_exception::Builder {
        crate::error::internal_server_error_exception::Builder::default()
    }
}

/// <p>You don't have permissions to perform this action.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ForbiddenException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ForbiddenException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ForbiddenException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ForbiddenException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ForbiddenException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ForbiddenException")?;
        if let Some(inner_5) = &self.message {
            write!(f, ": {}", inner_5)?;
        }
        Ok(())
    }
}
impl std::error::Error for ForbiddenException {}
/// See [`ForbiddenException`](crate::error::ForbiddenException)
pub mod forbidden_exception {
    /// A builder for [`ForbiddenException`](crate::error::ForbiddenException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ForbiddenException`](crate::error::ForbiddenException)
        pub fn build(self) -> crate::error::ForbiddenException {
            crate::error::ForbiddenException {
                message: self.message,
            }
        }
    }
}
impl ForbiddenException {
    /// Creates a new builder-style object to manufacture [`ForbiddenException`](crate::error::ForbiddenException)
    pub fn builder() -> crate::error::forbidden_exception::Builder {
        crate::error::forbidden_exception::Builder::default()
    }
}

/// <p>The request syntax was malformed. Check your request syntax and try again.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct BadRequestException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for BadRequestException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("BadRequestException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl BadRequestException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for BadRequestException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "BadRequestException")?;
        if let Some(inner_6) = &self.message {
            write!(f, ": {}", inner_6)?;
        }
        Ok(())
    }
}
impl std::error::Error for BadRequestException {}
/// See [`BadRequestException`](crate::error::BadRequestException)
pub mod bad_request_exception {
    /// A builder for [`BadRequestException`](crate::error::BadRequestException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`BadRequestException`](crate::error::BadRequestException)
        pub fn build(self) -> crate::error::BadRequestException {
            crate::error::BadRequestException {
                message: self.message,
            }
        }
    }
}
impl BadRequestException {
    /// Creates a new builder-style object to manufacture [`BadRequestException`](crate::error::BadRequestException)
    pub fn builder() -> crate::error::bad_request_exception::Builder {
        crate::error::bad_request_exception::Builder::default()
    }
}

/// <p>You have exceeded a service limit for your account. For more information, see <a href="https://docs.aws.amazon.com/app-mesh/latest/userguide/service-quotas.html">Service
/// Limits</a> in the <i>AWS App Mesh User Guide</i>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct LimitExceededException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for LimitExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("LimitExceededException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl LimitExceededException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for LimitExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "LimitExceededException")?;
        if let Some(inner_7) = &self.message {
            write!(f, ": {}", inner_7)?;
        }
        Ok(())
    }
}
impl std::error::Error for LimitExceededException {}
/// See [`LimitExceededException`](crate::error::LimitExceededException)
pub mod limit_exceeded_exception {
    /// A builder for [`LimitExceededException`](crate::error::LimitExceededException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`LimitExceededException`](crate::error::LimitExceededException)
        pub fn build(self) -> crate::error::LimitExceededException {
            crate::error::LimitExceededException {
                message: self.message,
            }
        }
    }
}
impl LimitExceededException {
    /// Creates a new builder-style object to manufacture [`LimitExceededException`](crate::error::LimitExceededException)
    pub fn builder() -> crate::error::limit_exceeded_exception::Builder {
        crate::error::limit_exceeded_exception::Builder::default()
    }
}

/// <p>The request contains a client token that was used for a previous update resource call
/// with different specifications. Try the request again with a new client token.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ConflictException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ConflictException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ConflictException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ConflictException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ConflictException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ConflictException")?;
        if let Some(inner_8) = &self.message {
            write!(f, ": {}", inner_8)?;
        }
        Ok(())
    }
}
impl std::error::Error for ConflictException {}
/// See [`ConflictException`](crate::error::ConflictException)
pub mod conflict_exception {
    /// A builder for [`ConflictException`](crate::error::ConflictException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ConflictException`](crate::error::ConflictException)
        pub fn build(self) -> crate::error::ConflictException {
            crate::error::ConflictException {
                message: self.message,
            }
        }
    }
}
impl ConflictException {
    /// Creates a new builder-style object to manufacture [`ConflictException`](crate::error::ConflictException)
    pub fn builder() -> crate::error::conflict_exception::Builder {
        crate::error::conflict_exception::Builder::default()
    }
}

/// <p>You can't delete the specified resource because it's in use or required by another
/// resource.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ResourceInUseException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ResourceInUseException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ResourceInUseException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ResourceInUseException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ResourceInUseException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ResourceInUseException")?;
        if let Some(inner_9) = &self.message {
            write!(f, ": {}", inner_9)?;
        }
        Ok(())
    }
}
impl std::error::Error for ResourceInUseException {}
/// See [`ResourceInUseException`](crate::error::ResourceInUseException)
pub mod resource_in_use_exception {
    /// A builder for [`ResourceInUseException`](crate::error::ResourceInUseException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ResourceInUseException`](crate::error::ResourceInUseException)
        pub fn build(self) -> crate::error::ResourceInUseException {
            crate::error::ResourceInUseException {
                message: self.message,
            }
        }
    }
}
impl ResourceInUseException {
    /// Creates a new builder-style object to manufacture [`ResourceInUseException`](crate::error::ResourceInUseException)
    pub fn builder() -> crate::error::resource_in_use_exception::Builder {
        crate::error::resource_in_use_exception::Builder::default()
    }
}

/// <p>The request exceeds the maximum allowed number of tags allowed per resource. The current
/// limit is 50 user tags per resource. You must reduce the number of tags in the request. None
/// of the tags in this request were applied.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TooManyTagsException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for TooManyTagsException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TooManyTagsException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl TooManyTagsException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for TooManyTagsException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "TooManyTagsException")?;
        if let Some(inner_10) = &self.message {
            write!(f, ": {}", inner_10)?;
        }
        Ok(())
    }
}
impl std::error::Error for TooManyTagsException {}
/// See [`TooManyTagsException`](crate::error::TooManyTagsException)
pub mod too_many_tags_exception {
    /// A builder for [`TooManyTagsException`](crate::error::TooManyTagsException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`TooManyTagsException`](crate::error::TooManyTagsException)
        pub fn build(self) -> crate::error::TooManyTagsException {
            crate::error::TooManyTagsException {
                message: self.message,
            }
        }
    }
}
impl TooManyTagsException {
    /// Creates a new builder-style object to manufacture [`TooManyTagsException`](crate::error::TooManyTagsException)
    pub fn builder() -> crate::error::too_many_tags_exception::Builder {
        crate::error::too_many_tags_exception::Builder::default()
    }
}
