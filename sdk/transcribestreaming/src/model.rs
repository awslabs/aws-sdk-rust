// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// When writing a match expression against `LanguageCode`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let languagecode = unimplemented!();
/// match languagecode {
///     LanguageCode::DeDe => { /* ... */ },
///     LanguageCode::EnAu => { /* ... */ },
///     LanguageCode::EnGb => { /* ... */ },
///     LanguageCode::EnUs => { /* ... */ },
///     LanguageCode::EsUs => { /* ... */ },
///     LanguageCode::FrCa => { /* ... */ },
///     LanguageCode::FrFr => { /* ... */ },
///     LanguageCode::HiIn => { /* ... */ },
///     LanguageCode::ItIt => { /* ... */ },
///     LanguageCode::JaJp => { /* ... */ },
///     LanguageCode::KoKr => { /* ... */ },
///     LanguageCode::PtBr => { /* ... */ },
///     LanguageCode::ThTh => { /* ... */ },
///     LanguageCode::ZhCn => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `languagecode` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `LanguageCode::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `LanguageCode::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `LanguageCode::NewFeature` is defined.
/// Specifically, when `languagecode` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `LanguageCode::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum LanguageCode {
    #[allow(missing_docs)] // documentation missing in model
    DeDe,
    #[allow(missing_docs)] // documentation missing in model
    EnAu,
    #[allow(missing_docs)] // documentation missing in model
    EnGb,
    #[allow(missing_docs)] // documentation missing in model
    EnUs,
    #[allow(missing_docs)] // documentation missing in model
    EsUs,
    #[allow(missing_docs)] // documentation missing in model
    FrCa,
    #[allow(missing_docs)] // documentation missing in model
    FrFr,
    #[allow(missing_docs)] // documentation missing in model
    HiIn,
    #[allow(missing_docs)] // documentation missing in model
    ItIt,
    #[allow(missing_docs)] // documentation missing in model
    JaJp,
    #[allow(missing_docs)] // documentation missing in model
    KoKr,
    #[allow(missing_docs)] // documentation missing in model
    PtBr,
    #[allow(missing_docs)] // documentation missing in model
    ThTh,
    #[allow(missing_docs)] // documentation missing in model
    ZhCn,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for LanguageCode {
    fn from(s: &str) -> Self {
        match s {
            "de-DE" => LanguageCode::DeDe,
            "en-AU" => LanguageCode::EnAu,
            "en-GB" => LanguageCode::EnGb,
            "en-US" => LanguageCode::EnUs,
            "es-US" => LanguageCode::EsUs,
            "fr-CA" => LanguageCode::FrCa,
            "fr-FR" => LanguageCode::FrFr,
            "hi-IN" => LanguageCode::HiIn,
            "it-IT" => LanguageCode::ItIt,
            "ja-JP" => LanguageCode::JaJp,
            "ko-KR" => LanguageCode::KoKr,
            "pt-BR" => LanguageCode::PtBr,
            "th-TH" => LanguageCode::ThTh,
            "zh-CN" => LanguageCode::ZhCn,
            other => LanguageCode::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for LanguageCode {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(LanguageCode::from(s))
    }
}
impl LanguageCode {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            LanguageCode::DeDe => "de-DE",
            LanguageCode::EnAu => "en-AU",
            LanguageCode::EnGb => "en-GB",
            LanguageCode::EnUs => "en-US",
            LanguageCode::EsUs => "es-US",
            LanguageCode::FrCa => "fr-CA",
            LanguageCode::FrFr => "fr-FR",
            LanguageCode::HiIn => "hi-IN",
            LanguageCode::ItIt => "it-IT",
            LanguageCode::JaJp => "ja-JP",
            LanguageCode::KoKr => "ko-KR",
            LanguageCode::PtBr => "pt-BR",
            LanguageCode::ThTh => "th-TH",
            LanguageCode::ZhCn => "zh-CN",
            LanguageCode::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "de-DE", "en-AU", "en-GB", "en-US", "es-US", "fr-CA", "fr-FR", "hi-IN", "it-IT",
            "ja-JP", "ko-KR", "pt-BR", "th-TH", "zh-CN",
        ]
    }
}
impl AsRef<str> for LanguageCode {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `ContentRedactionType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let contentredactiontype = unimplemented!();
/// match contentredactiontype {
///     ContentRedactionType::Pii => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `contentredactiontype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ContentRedactionType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ContentRedactionType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ContentRedactionType::NewFeature` is defined.
/// Specifically, when `contentredactiontype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ContentRedactionType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ContentRedactionType {
    #[allow(missing_docs)] // documentation missing in model
    Pii,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ContentRedactionType {
    fn from(s: &str) -> Self {
        match s {
            "PII" => ContentRedactionType::Pii,
            other => {
                ContentRedactionType::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for ContentRedactionType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ContentRedactionType::from(s))
    }
}
impl ContentRedactionType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ContentRedactionType::Pii => "PII",
            ContentRedactionType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["PII"]
    }
}
impl AsRef<str> for ContentRedactionType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `ContentIdentificationType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let contentidentificationtype = unimplemented!();
/// match contentidentificationtype {
///     ContentIdentificationType::Pii => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `contentidentificationtype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ContentIdentificationType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ContentIdentificationType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ContentIdentificationType::NewFeature` is defined.
/// Specifically, when `contentidentificationtype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ContentIdentificationType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ContentIdentificationType {
    #[allow(missing_docs)] // documentation missing in model
    Pii,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ContentIdentificationType {
    fn from(s: &str) -> Self {
        match s {
            "PII" => ContentIdentificationType::Pii,
            other => ContentIdentificationType::Unknown(crate::types::UnknownVariantValue(
                other.to_owned(),
            )),
        }
    }
}
impl std::str::FromStr for ContentIdentificationType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ContentIdentificationType::from(s))
    }
}
impl ContentIdentificationType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ContentIdentificationType::Pii => "PII",
            ContentIdentificationType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["PII"]
    }
}
impl AsRef<str> for ContentIdentificationType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `PartialResultsStability`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let partialresultsstability = unimplemented!();
/// match partialresultsstability {
///     PartialResultsStability::High => { /* ... */ },
///     PartialResultsStability::Low => { /* ... */ },
///     PartialResultsStability::Medium => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `partialresultsstability` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `PartialResultsStability::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `PartialResultsStability::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `PartialResultsStability::NewFeature` is defined.
/// Specifically, when `partialresultsstability` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `PartialResultsStability::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum PartialResultsStability {
    #[allow(missing_docs)] // documentation missing in model
    High,
    #[allow(missing_docs)] // documentation missing in model
    Low,
    #[allow(missing_docs)] // documentation missing in model
    Medium,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for PartialResultsStability {
    fn from(s: &str) -> Self {
        match s {
            "high" => PartialResultsStability::High,
            "low" => PartialResultsStability::Low,
            "medium" => PartialResultsStability::Medium,
            other => PartialResultsStability::Unknown(crate::types::UnknownVariantValue(
                other.to_owned(),
            )),
        }
    }
}
impl std::str::FromStr for PartialResultsStability {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(PartialResultsStability::from(s))
    }
}
impl PartialResultsStability {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            PartialResultsStability::High => "high",
            PartialResultsStability::Low => "low",
            PartialResultsStability::Medium => "medium",
            PartialResultsStability::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["high", "low", "medium"]
    }
}
impl AsRef<str> for PartialResultsStability {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `VocabularyFilterMethod`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let vocabularyfiltermethod = unimplemented!();
/// match vocabularyfiltermethod {
///     VocabularyFilterMethod::Mask => { /* ... */ },
///     VocabularyFilterMethod::Remove => { /* ... */ },
///     VocabularyFilterMethod::Tag => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `vocabularyfiltermethod` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `VocabularyFilterMethod::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `VocabularyFilterMethod::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `VocabularyFilterMethod::NewFeature` is defined.
/// Specifically, when `vocabularyfiltermethod` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `VocabularyFilterMethod::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum VocabularyFilterMethod {
    #[allow(missing_docs)] // documentation missing in model
    Mask,
    #[allow(missing_docs)] // documentation missing in model
    Remove,
    #[allow(missing_docs)] // documentation missing in model
    Tag,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for VocabularyFilterMethod {
    fn from(s: &str) -> Self {
        match s {
            "mask" => VocabularyFilterMethod::Mask,
            "remove" => VocabularyFilterMethod::Remove,
            "tag" => VocabularyFilterMethod::Tag,
            other => {
                VocabularyFilterMethod::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for VocabularyFilterMethod {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(VocabularyFilterMethod::from(s))
    }
}
impl VocabularyFilterMethod {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            VocabularyFilterMethod::Mask => "mask",
            VocabularyFilterMethod::Remove => "remove",
            VocabularyFilterMethod::Tag => "tag",
            VocabularyFilterMethod::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["mask", "remove", "tag"]
    }
}
impl AsRef<str> for VocabularyFilterMethod {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Contains detailed information about your streaming session.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub enum TranscriptResultStream {
    /// <p>Contains <code>Transcript</code>, which contains <code>Results</code>. The <code></code> object contains a set of transcription results from one or more audio segments, along with additional information per your request parameters.</p>
    TranscriptEvent(crate::model::TranscriptEvent),
    /// The `Unknown` variant represents cases where new union variant was received. Consider upgrading the SDK to the latest available version.
    /// An unknown enum variant
    ///
    /// _Note: If you encounter this error, consider upgrading your SDK to the latest version._
    /// The `Unknown` variant represents cases where the server sent a value that wasn't recognized
    /// by the client. This can happen when the server adds new functionality, but the client has not been updated.
    /// To investigate this, consider turning on debug logging to print the raw HTTP response.
    #[non_exhaustive]
    Unknown,
}
impl TranscriptResultStream {
    #[allow(irrefutable_let_patterns)]
    /// Tries to convert the enum instance into [`TranscriptEvent`](crate::model::TranscriptResultStream::TranscriptEvent), extracting the inner [`TranscriptEvent`](crate::model::TranscriptEvent).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_transcript_event(
        &self,
    ) -> std::result::Result<&crate::model::TranscriptEvent, &Self> {
        if let TranscriptResultStream::TranscriptEvent(val) = &self {
            Ok(val)
        } else {
            Err(self)
        }
    }
    /// Returns true if this is a [`TranscriptEvent`](crate::model::TranscriptResultStream::TranscriptEvent).
    pub fn is_transcript_event(&self) -> bool {
        self.as_transcript_event().is_ok()
    }
    /// Returns true if the enum instance is the `Unknown` variant.
    pub fn is_unknown(&self) -> bool {
        matches!(self, Self::Unknown)
    }
}

/// <p>The <code>TranscriptEvent</code> associated with a <code>TranscriptResultStream</code>.</p>
/// <p>Contains a set of transcription results from one or more audio segments, along with additional information per your request parameters.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TranscriptEvent {
    /// <p>Contains <code>Results</code>, which contains a set of transcription results from one or more audio segments, along with additional information per your request parameters. This can include information relating to alternative transcriptions, channel identification, partial result stabilization, language identification, and other transcription-related data.</p>
    #[doc(hidden)]
    pub transcript: std::option::Option<crate::model::Transcript>,
}
impl TranscriptEvent {
    /// <p>Contains <code>Results</code>, which contains a set of transcription results from one or more audio segments, along with additional information per your request parameters. This can include information relating to alternative transcriptions, channel identification, partial result stabilization, language identification, and other transcription-related data.</p>
    pub fn transcript(&self) -> std::option::Option<&crate::model::Transcript> {
        self.transcript.as_ref()
    }
}
/// See [`TranscriptEvent`](crate::model::TranscriptEvent).
pub mod transcript_event {

    /// A builder for [`TranscriptEvent`](crate::model::TranscriptEvent).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) transcript: std::option::Option<crate::model::Transcript>,
    }
    impl Builder {
        /// <p>Contains <code>Results</code>, which contains a set of transcription results from one or more audio segments, along with additional information per your request parameters. This can include information relating to alternative transcriptions, channel identification, partial result stabilization, language identification, and other transcription-related data.</p>
        pub fn transcript(mut self, input: crate::model::Transcript) -> Self {
            self.transcript = Some(input);
            self
        }
        /// <p>Contains <code>Results</code>, which contains a set of transcription results from one or more audio segments, along with additional information per your request parameters. This can include information relating to alternative transcriptions, channel identification, partial result stabilization, language identification, and other transcription-related data.</p>
        pub fn set_transcript(
            mut self,
            input: std::option::Option<crate::model::Transcript>,
        ) -> Self {
            self.transcript = input;
            self
        }
        /// Consumes the builder and constructs a [`TranscriptEvent`](crate::model::TranscriptEvent).
        pub fn build(self) -> crate::model::TranscriptEvent {
            crate::model::TranscriptEvent {
                transcript: self.transcript,
            }
        }
    }
}
impl TranscriptEvent {
    /// Creates a new builder-style object to manufacture [`TranscriptEvent`](crate::model::TranscriptEvent).
    pub fn builder() -> crate::model::transcript_event::Builder {
        crate::model::transcript_event::Builder::default()
    }
}

/// <p>The <code>Transcript</code> associated with a <code></code>.</p>
/// <p> <code>Transcript</code> contains <code>Results</code>, which contains a set of transcription results from one or more audio segments, along with additional information per your request parameters.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Transcript {
    /// <p>Contains a set of transcription results from one or more audio segments, along with additional information per your request parameters. This can include information relating to alternative transcriptions, channel identification, partial result stabilization, language identification, and other transcription-related data.</p>
    #[doc(hidden)]
    pub results: std::option::Option<std::vec::Vec<crate::model::Result>>,
}
impl Transcript {
    /// <p>Contains a set of transcription results from one or more audio segments, along with additional information per your request parameters. This can include information relating to alternative transcriptions, channel identification, partial result stabilization, language identification, and other transcription-related data.</p>
    pub fn results(&self) -> std::option::Option<&[crate::model::Result]> {
        self.results.as_deref()
    }
}
/// See [`Transcript`](crate::model::Transcript).
pub mod transcript {

    /// A builder for [`Transcript`](crate::model::Transcript).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) results: std::option::Option<std::vec::Vec<crate::model::Result>>,
    }
    impl Builder {
        /// Appends an item to `results`.
        ///
        /// To override the contents of this collection use [`set_results`](Self::set_results).
        ///
        /// <p>Contains a set of transcription results from one or more audio segments, along with additional information per your request parameters. This can include information relating to alternative transcriptions, channel identification, partial result stabilization, language identification, and other transcription-related data.</p>
        pub fn results(mut self, input: crate::model::Result) -> Self {
            let mut v = self.results.unwrap_or_default();
            v.push(input);
            self.results = Some(v);
            self
        }
        /// <p>Contains a set of transcription results from one or more audio segments, along with additional information per your request parameters. This can include information relating to alternative transcriptions, channel identification, partial result stabilization, language identification, and other transcription-related data.</p>
        pub fn set_results(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Result>>,
        ) -> Self {
            self.results = input;
            self
        }
        /// Consumes the builder and constructs a [`Transcript`](crate::model::Transcript).
        pub fn build(self) -> crate::model::Transcript {
            crate::model::Transcript {
                results: self.results,
            }
        }
    }
}
impl Transcript {
    /// Creates a new builder-style object to manufacture [`Transcript`](crate::model::Transcript).
    pub fn builder() -> crate::model::transcript::Builder {
        crate::model::transcript::Builder::default()
    }
}

/// <p>The <code>Result</code> associated with a <code></code>.</p>
/// <p>Contains a set of transcription results from one or more audio segments, along with additional information per your request parameters. This can include information relating to alternative transcriptions, channel identification, partial result stabilization, language identification, and other transcription-related data.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Result {
    /// <p>Provides a unique identifier for the <code>Result</code>.</p>
    #[doc(hidden)]
    pub result_id: std::option::Option<std::string::String>,
    /// <p>The start time, in milliseconds, of the <code>Result</code>.</p>
    #[doc(hidden)]
    pub start_time: f64,
    /// <p>The end time, in milliseconds, of the <code>Result</code>.</p>
    #[doc(hidden)]
    pub end_time: f64,
    /// <p>Indicates if the segment is complete.</p>
    /// <p>If <code>IsPartial</code> is <code>true</code>, the segment is not complete. If <code>IsPartial</code> is <code>false</code>, the segment is complete.</p>
    #[doc(hidden)]
    pub is_partial: bool,
    /// <p>A list of possible alternative transcriptions for the input audio. Each alternative may contain one or more of <code>Items</code>, <code>Entities</code>, or <code>Transcript</code>.</p>
    #[doc(hidden)]
    pub alternatives: std::option::Option<std::vec::Vec<crate::model::Alternative>>,
    /// <p>Indicates which audio channel is associated with the <code>Result</code>.</p>
    #[doc(hidden)]
    pub channel_id: std::option::Option<std::string::String>,
    /// <p>The language code that represents the language spoken in your audio stream.</p>
    #[doc(hidden)]
    pub language_code: std::option::Option<crate::model::LanguageCode>,
    /// <p>The language code of the dominant language identified in your stream.</p>
    /// <p>If you enabled channel identification and each channel of your audio contains a different language, you may have more than one result.</p>
    #[doc(hidden)]
    pub language_identification:
        std::option::Option<std::vec::Vec<crate::model::LanguageWithScore>>,
}
impl Result {
    /// <p>Provides a unique identifier for the <code>Result</code>.</p>
    pub fn result_id(&self) -> std::option::Option<&str> {
        self.result_id.as_deref()
    }
    /// <p>The start time, in milliseconds, of the <code>Result</code>.</p>
    pub fn start_time(&self) -> f64 {
        self.start_time
    }
    /// <p>The end time, in milliseconds, of the <code>Result</code>.</p>
    pub fn end_time(&self) -> f64 {
        self.end_time
    }
    /// <p>Indicates if the segment is complete.</p>
    /// <p>If <code>IsPartial</code> is <code>true</code>, the segment is not complete. If <code>IsPartial</code> is <code>false</code>, the segment is complete.</p>
    pub fn is_partial(&self) -> bool {
        self.is_partial
    }
    /// <p>A list of possible alternative transcriptions for the input audio. Each alternative may contain one or more of <code>Items</code>, <code>Entities</code>, or <code>Transcript</code>.</p>
    pub fn alternatives(&self) -> std::option::Option<&[crate::model::Alternative]> {
        self.alternatives.as_deref()
    }
    /// <p>Indicates which audio channel is associated with the <code>Result</code>.</p>
    pub fn channel_id(&self) -> std::option::Option<&str> {
        self.channel_id.as_deref()
    }
    /// <p>The language code that represents the language spoken in your audio stream.</p>
    pub fn language_code(&self) -> std::option::Option<&crate::model::LanguageCode> {
        self.language_code.as_ref()
    }
    /// <p>The language code of the dominant language identified in your stream.</p>
    /// <p>If you enabled channel identification and each channel of your audio contains a different language, you may have more than one result.</p>
    pub fn language_identification(
        &self,
    ) -> std::option::Option<&[crate::model::LanguageWithScore]> {
        self.language_identification.as_deref()
    }
}
/// See [`Result`](crate::model::Result).
pub mod result {

    /// A builder for [`Result`](crate::model::Result).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) result_id: std::option::Option<std::string::String>,
        pub(crate) start_time: std::option::Option<f64>,
        pub(crate) end_time: std::option::Option<f64>,
        pub(crate) is_partial: std::option::Option<bool>,
        pub(crate) alternatives: std::option::Option<std::vec::Vec<crate::model::Alternative>>,
        pub(crate) channel_id: std::option::Option<std::string::String>,
        pub(crate) language_code: std::option::Option<crate::model::LanguageCode>,
        pub(crate) language_identification:
            std::option::Option<std::vec::Vec<crate::model::LanguageWithScore>>,
    }
    impl Builder {
        /// <p>Provides a unique identifier for the <code>Result</code>.</p>
        pub fn result_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.result_id = Some(input.into());
            self
        }
        /// <p>Provides a unique identifier for the <code>Result</code>.</p>
        pub fn set_result_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.result_id = input;
            self
        }
        /// <p>The start time, in milliseconds, of the <code>Result</code>.</p>
        pub fn start_time(mut self, input: f64) -> Self {
            self.start_time = Some(input);
            self
        }
        /// <p>The start time, in milliseconds, of the <code>Result</code>.</p>
        pub fn set_start_time(mut self, input: std::option::Option<f64>) -> Self {
            self.start_time = input;
            self
        }
        /// <p>The end time, in milliseconds, of the <code>Result</code>.</p>
        pub fn end_time(mut self, input: f64) -> Self {
            self.end_time = Some(input);
            self
        }
        /// <p>The end time, in milliseconds, of the <code>Result</code>.</p>
        pub fn set_end_time(mut self, input: std::option::Option<f64>) -> Self {
            self.end_time = input;
            self
        }
        /// <p>Indicates if the segment is complete.</p>
        /// <p>If <code>IsPartial</code> is <code>true</code>, the segment is not complete. If <code>IsPartial</code> is <code>false</code>, the segment is complete.</p>
        pub fn is_partial(mut self, input: bool) -> Self {
            self.is_partial = Some(input);
            self
        }
        /// <p>Indicates if the segment is complete.</p>
        /// <p>If <code>IsPartial</code> is <code>true</code>, the segment is not complete. If <code>IsPartial</code> is <code>false</code>, the segment is complete.</p>
        pub fn set_is_partial(mut self, input: std::option::Option<bool>) -> Self {
            self.is_partial = input;
            self
        }
        /// Appends an item to `alternatives`.
        ///
        /// To override the contents of this collection use [`set_alternatives`](Self::set_alternatives).
        ///
        /// <p>A list of possible alternative transcriptions for the input audio. Each alternative may contain one or more of <code>Items</code>, <code>Entities</code>, or <code>Transcript</code>.</p>
        pub fn alternatives(mut self, input: crate::model::Alternative) -> Self {
            let mut v = self.alternatives.unwrap_or_default();
            v.push(input);
            self.alternatives = Some(v);
            self
        }
        /// <p>A list of possible alternative transcriptions for the input audio. Each alternative may contain one or more of <code>Items</code>, <code>Entities</code>, or <code>Transcript</code>.</p>
        pub fn set_alternatives(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Alternative>>,
        ) -> Self {
            self.alternatives = input;
            self
        }
        /// <p>Indicates which audio channel is associated with the <code>Result</code>.</p>
        pub fn channel_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.channel_id = Some(input.into());
            self
        }
        /// <p>Indicates which audio channel is associated with the <code>Result</code>.</p>
        pub fn set_channel_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.channel_id = input;
            self
        }
        /// <p>The language code that represents the language spoken in your audio stream.</p>
        pub fn language_code(mut self, input: crate::model::LanguageCode) -> Self {
            self.language_code = Some(input);
            self
        }
        /// <p>The language code that represents the language spoken in your audio stream.</p>
        pub fn set_language_code(
            mut self,
            input: std::option::Option<crate::model::LanguageCode>,
        ) -> Self {
            self.language_code = input;
            self
        }
        /// Appends an item to `language_identification`.
        ///
        /// To override the contents of this collection use [`set_language_identification`](Self::set_language_identification).
        ///
        /// <p>The language code of the dominant language identified in your stream.</p>
        /// <p>If you enabled channel identification and each channel of your audio contains a different language, you may have more than one result.</p>
        pub fn language_identification(mut self, input: crate::model::LanguageWithScore) -> Self {
            let mut v = self.language_identification.unwrap_or_default();
            v.push(input);
            self.language_identification = Some(v);
            self
        }
        /// <p>The language code of the dominant language identified in your stream.</p>
        /// <p>If you enabled channel identification and each channel of your audio contains a different language, you may have more than one result.</p>
        pub fn set_language_identification(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::LanguageWithScore>>,
        ) -> Self {
            self.language_identification = input;
            self
        }
        /// Consumes the builder and constructs a [`Result`](crate::model::Result).
        pub fn build(self) -> crate::model::Result {
            crate::model::Result {
                result_id: self.result_id,
                start_time: self.start_time.unwrap_or_default(),
                end_time: self.end_time.unwrap_or_default(),
                is_partial: self.is_partial.unwrap_or_default(),
                alternatives: self.alternatives,
                channel_id: self.channel_id,
                language_code: self.language_code,
                language_identification: self.language_identification,
            }
        }
    }
}
impl Result {
    /// Creates a new builder-style object to manufacture [`Result`](crate::model::Result).
    pub fn builder() -> crate::model::result::Builder {
        crate::model::result::Builder::default()
    }
}

/// <p>The language code that represents the language identified in your audio, including the associated confidence score. If you enabled channel identification in your request and each channel contained a different language, you will have more than one <code>LanguageWithScore</code> result.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct LanguageWithScore {
    /// <p>The language code of the identified language.</p>
    #[doc(hidden)]
    pub language_code: std::option::Option<crate::model::LanguageCode>,
    /// <p>The confidence score associated with the identified language code. Confidence scores are values between zero and one; larger values indicate a higher confidence in the identified language.</p>
    #[doc(hidden)]
    pub score: f64,
}
impl LanguageWithScore {
    /// <p>The language code of the identified language.</p>
    pub fn language_code(&self) -> std::option::Option<&crate::model::LanguageCode> {
        self.language_code.as_ref()
    }
    /// <p>The confidence score associated with the identified language code. Confidence scores are values between zero and one; larger values indicate a higher confidence in the identified language.</p>
    pub fn score(&self) -> f64 {
        self.score
    }
}
/// See [`LanguageWithScore`](crate::model::LanguageWithScore).
pub mod language_with_score {

    /// A builder for [`LanguageWithScore`](crate::model::LanguageWithScore).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) language_code: std::option::Option<crate::model::LanguageCode>,
        pub(crate) score: std::option::Option<f64>,
    }
    impl Builder {
        /// <p>The language code of the identified language.</p>
        pub fn language_code(mut self, input: crate::model::LanguageCode) -> Self {
            self.language_code = Some(input);
            self
        }
        /// <p>The language code of the identified language.</p>
        pub fn set_language_code(
            mut self,
            input: std::option::Option<crate::model::LanguageCode>,
        ) -> Self {
            self.language_code = input;
            self
        }
        /// <p>The confidence score associated with the identified language code. Confidence scores are values between zero and one; larger values indicate a higher confidence in the identified language.</p>
        pub fn score(mut self, input: f64) -> Self {
            self.score = Some(input);
            self
        }
        /// <p>The confidence score associated with the identified language code. Confidence scores are values between zero and one; larger values indicate a higher confidence in the identified language.</p>
        pub fn set_score(mut self, input: std::option::Option<f64>) -> Self {
            self.score = input;
            self
        }
        /// Consumes the builder and constructs a [`LanguageWithScore`](crate::model::LanguageWithScore).
        pub fn build(self) -> crate::model::LanguageWithScore {
            crate::model::LanguageWithScore {
                language_code: self.language_code,
                score: self.score.unwrap_or_default(),
            }
        }
    }
}
impl LanguageWithScore {
    /// Creates a new builder-style object to manufacture [`LanguageWithScore`](crate::model::LanguageWithScore).
    pub fn builder() -> crate::model::language_with_score::Builder {
        crate::model::language_with_score::Builder::default()
    }
}

/// <p>A list of possible alternative transcriptions for the input audio. Each alternative may contain one or more of <code>Items</code>, <code>Entities</code>, or <code>Transcript</code>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Alternative {
    /// <p>Contains transcribed text.</p>
    #[doc(hidden)]
    pub transcript: std::option::Option<std::string::String>,
    /// <p>Contains words, phrases, or punctuation marks in your transcription output.</p>
    #[doc(hidden)]
    pub items: std::option::Option<std::vec::Vec<crate::model::Item>>,
    /// <p>Contains entities identified as personally identifiable information (PII) in your transcription output.</p>
    #[doc(hidden)]
    pub entities: std::option::Option<std::vec::Vec<crate::model::Entity>>,
}
impl Alternative {
    /// <p>Contains transcribed text.</p>
    pub fn transcript(&self) -> std::option::Option<&str> {
        self.transcript.as_deref()
    }
    /// <p>Contains words, phrases, or punctuation marks in your transcription output.</p>
    pub fn items(&self) -> std::option::Option<&[crate::model::Item]> {
        self.items.as_deref()
    }
    /// <p>Contains entities identified as personally identifiable information (PII) in your transcription output.</p>
    pub fn entities(&self) -> std::option::Option<&[crate::model::Entity]> {
        self.entities.as_deref()
    }
}
/// See [`Alternative`](crate::model::Alternative).
pub mod alternative {

    /// A builder for [`Alternative`](crate::model::Alternative).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) transcript: std::option::Option<std::string::String>,
        pub(crate) items: std::option::Option<std::vec::Vec<crate::model::Item>>,
        pub(crate) entities: std::option::Option<std::vec::Vec<crate::model::Entity>>,
    }
    impl Builder {
        /// <p>Contains transcribed text.</p>
        pub fn transcript(mut self, input: impl Into<std::string::String>) -> Self {
            self.transcript = Some(input.into());
            self
        }
        /// <p>Contains transcribed text.</p>
        pub fn set_transcript(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.transcript = input;
            self
        }
        /// Appends an item to `items`.
        ///
        /// To override the contents of this collection use [`set_items`](Self::set_items).
        ///
        /// <p>Contains words, phrases, or punctuation marks in your transcription output.</p>
        pub fn items(mut self, input: crate::model::Item) -> Self {
            let mut v = self.items.unwrap_or_default();
            v.push(input);
            self.items = Some(v);
            self
        }
        /// <p>Contains words, phrases, or punctuation marks in your transcription output.</p>
        pub fn set_items(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Item>>,
        ) -> Self {
            self.items = input;
            self
        }
        /// Appends an item to `entities`.
        ///
        /// To override the contents of this collection use [`set_entities`](Self::set_entities).
        ///
        /// <p>Contains entities identified as personally identifiable information (PII) in your transcription output.</p>
        pub fn entities(mut self, input: crate::model::Entity) -> Self {
            let mut v = self.entities.unwrap_or_default();
            v.push(input);
            self.entities = Some(v);
            self
        }
        /// <p>Contains entities identified as personally identifiable information (PII) in your transcription output.</p>
        pub fn set_entities(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Entity>>,
        ) -> Self {
            self.entities = input;
            self
        }
        /// Consumes the builder and constructs a [`Alternative`](crate::model::Alternative).
        pub fn build(self) -> crate::model::Alternative {
            crate::model::Alternative {
                transcript: self.transcript,
                items: self.items,
                entities: self.entities,
            }
        }
    }
}
impl Alternative {
    /// Creates a new builder-style object to manufacture [`Alternative`](crate::model::Alternative).
    pub fn builder() -> crate::model::alternative::Builder {
        crate::model::alternative::Builder::default()
    }
}

/// <p>Contains entities identified as personally identifiable information (PII) in your transcription output, along with various associated attributes. Examples include category, confidence score, type, stability score, and start and end times.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Entity {
    /// <p>The start time, in milliseconds, of the utterance that was identified as PII.</p>
    #[doc(hidden)]
    pub start_time: f64,
    /// <p>The end time, in milliseconds, of the utterance that was identified as PII.</p>
    #[doc(hidden)]
    pub end_time: f64,
    /// <p>The category of information identified. The only category is <code>PII</code>.</p>
    #[doc(hidden)]
    pub category: std::option::Option<std::string::String>,
    /// <p>The type of PII identified. For example, <code>NAME</code> or <code>CREDIT_DEBIT_NUMBER</code>.</p>
    #[doc(hidden)]
    pub r#type: std::option::Option<std::string::String>,
    /// <p>The word or words identified as PII.</p>
    #[doc(hidden)]
    pub content: std::option::Option<std::string::String>,
    /// <p>The confidence score associated with the identified PII entity in your audio.</p>
    /// <p>Confidence scores are values between 0 and 1. A larger value indicates a higher probability that the identified entity correctly matches the entity spoken in your media.</p>
    #[doc(hidden)]
    pub confidence: std::option::Option<f64>,
}
impl Entity {
    /// <p>The start time, in milliseconds, of the utterance that was identified as PII.</p>
    pub fn start_time(&self) -> f64 {
        self.start_time
    }
    /// <p>The end time, in milliseconds, of the utterance that was identified as PII.</p>
    pub fn end_time(&self) -> f64 {
        self.end_time
    }
    /// <p>The category of information identified. The only category is <code>PII</code>.</p>
    pub fn category(&self) -> std::option::Option<&str> {
        self.category.as_deref()
    }
    /// <p>The type of PII identified. For example, <code>NAME</code> or <code>CREDIT_DEBIT_NUMBER</code>.</p>
    pub fn r#type(&self) -> std::option::Option<&str> {
        self.r#type.as_deref()
    }
    /// <p>The word or words identified as PII.</p>
    pub fn content(&self) -> std::option::Option<&str> {
        self.content.as_deref()
    }
    /// <p>The confidence score associated with the identified PII entity in your audio.</p>
    /// <p>Confidence scores are values between 0 and 1. A larger value indicates a higher probability that the identified entity correctly matches the entity spoken in your media.</p>
    pub fn confidence(&self) -> std::option::Option<f64> {
        self.confidence
    }
}
/// See [`Entity`](crate::model::Entity).
pub mod entity {

    /// A builder for [`Entity`](crate::model::Entity).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) start_time: std::option::Option<f64>,
        pub(crate) end_time: std::option::Option<f64>,
        pub(crate) category: std::option::Option<std::string::String>,
        pub(crate) r#type: std::option::Option<std::string::String>,
        pub(crate) content: std::option::Option<std::string::String>,
        pub(crate) confidence: std::option::Option<f64>,
    }
    impl Builder {
        /// <p>The start time, in milliseconds, of the utterance that was identified as PII.</p>
        pub fn start_time(mut self, input: f64) -> Self {
            self.start_time = Some(input);
            self
        }
        /// <p>The start time, in milliseconds, of the utterance that was identified as PII.</p>
        pub fn set_start_time(mut self, input: std::option::Option<f64>) -> Self {
            self.start_time = input;
            self
        }
        /// <p>The end time, in milliseconds, of the utterance that was identified as PII.</p>
        pub fn end_time(mut self, input: f64) -> Self {
            self.end_time = Some(input);
            self
        }
        /// <p>The end time, in milliseconds, of the utterance that was identified as PII.</p>
        pub fn set_end_time(mut self, input: std::option::Option<f64>) -> Self {
            self.end_time = input;
            self
        }
        /// <p>The category of information identified. The only category is <code>PII</code>.</p>
        pub fn category(mut self, input: impl Into<std::string::String>) -> Self {
            self.category = Some(input.into());
            self
        }
        /// <p>The category of information identified. The only category is <code>PII</code>.</p>
        pub fn set_category(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.category = input;
            self
        }
        /// <p>The type of PII identified. For example, <code>NAME</code> or <code>CREDIT_DEBIT_NUMBER</code>.</p>
        pub fn r#type(mut self, input: impl Into<std::string::String>) -> Self {
            self.r#type = Some(input.into());
            self
        }
        /// <p>The type of PII identified. For example, <code>NAME</code> or <code>CREDIT_DEBIT_NUMBER</code>.</p>
        pub fn set_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.r#type = input;
            self
        }
        /// <p>The word or words identified as PII.</p>
        pub fn content(mut self, input: impl Into<std::string::String>) -> Self {
            self.content = Some(input.into());
            self
        }
        /// <p>The word or words identified as PII.</p>
        pub fn set_content(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.content = input;
            self
        }
        /// <p>The confidence score associated with the identified PII entity in your audio.</p>
        /// <p>Confidence scores are values between 0 and 1. A larger value indicates a higher probability that the identified entity correctly matches the entity spoken in your media.</p>
        pub fn confidence(mut self, input: f64) -> Self {
            self.confidence = Some(input);
            self
        }
        /// <p>The confidence score associated with the identified PII entity in your audio.</p>
        /// <p>Confidence scores are values between 0 and 1. A larger value indicates a higher probability that the identified entity correctly matches the entity spoken in your media.</p>
        pub fn set_confidence(mut self, input: std::option::Option<f64>) -> Self {
            self.confidence = input;
            self
        }
        /// Consumes the builder and constructs a [`Entity`](crate::model::Entity).
        pub fn build(self) -> crate::model::Entity {
            crate::model::Entity {
                start_time: self.start_time.unwrap_or_default(),
                end_time: self.end_time.unwrap_or_default(),
                category: self.category,
                r#type: self.r#type,
                content: self.content,
                confidence: self.confidence,
            }
        }
    }
}
impl Entity {
    /// Creates a new builder-style object to manufacture [`Entity`](crate::model::Entity).
    pub fn builder() -> crate::model::entity::Builder {
        crate::model::entity::Builder::default()
    }
}

/// <p>A word, phrase, or punctuation mark in your transcription output, along with various associated attributes, such as confidence score, type, and start and end times.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Item {
    /// <p>The start time, in milliseconds, of the transcribed item.</p>
    #[doc(hidden)]
    pub start_time: f64,
    /// <p>The end time, in milliseconds, of the transcribed item.</p>
    #[doc(hidden)]
    pub end_time: f64,
    /// <p>The type of item identified. Options are: <code>PRONUNCIATION</code> (spoken words) and <code>PUNCTUATION</code>.</p>
    #[doc(hidden)]
    pub r#type: std::option::Option<crate::model::ItemType>,
    /// <p>The word or punctuation that was transcribed.</p>
    #[doc(hidden)]
    pub content: std::option::Option<std::string::String>,
    /// <p>Indicates whether the specified item matches a word in the vocabulary filter included in your request. If <code>true</code>, there is a vocabulary filter match.</p>
    #[doc(hidden)]
    pub vocabulary_filter_match: bool,
    /// <p>If speaker partitioning is enabled, <code>Speaker</code> labels the speaker of the specified item.</p>
    #[doc(hidden)]
    pub speaker: std::option::Option<std::string::String>,
    /// <p>The confidence score associated with a word or phrase in your transcript.</p>
    /// <p>Confidence scores are values between 0 and 1. A larger value indicates a higher probability that the identified item correctly matches the item spoken in your media.</p>
    #[doc(hidden)]
    pub confidence: std::option::Option<f64>,
    /// <p>If partial result stabilization is enabled, <code>Stable</code> indicates whether the specified item is stable (<code>true</code>) or if it may change when the segment is complete (<code>false</code>).</p>
    #[doc(hidden)]
    pub stable: std::option::Option<bool>,
}
impl Item {
    /// <p>The start time, in milliseconds, of the transcribed item.</p>
    pub fn start_time(&self) -> f64 {
        self.start_time
    }
    /// <p>The end time, in milliseconds, of the transcribed item.</p>
    pub fn end_time(&self) -> f64 {
        self.end_time
    }
    /// <p>The type of item identified. Options are: <code>PRONUNCIATION</code> (spoken words) and <code>PUNCTUATION</code>.</p>
    pub fn r#type(&self) -> std::option::Option<&crate::model::ItemType> {
        self.r#type.as_ref()
    }
    /// <p>The word or punctuation that was transcribed.</p>
    pub fn content(&self) -> std::option::Option<&str> {
        self.content.as_deref()
    }
    /// <p>Indicates whether the specified item matches a word in the vocabulary filter included in your request. If <code>true</code>, there is a vocabulary filter match.</p>
    pub fn vocabulary_filter_match(&self) -> bool {
        self.vocabulary_filter_match
    }
    /// <p>If speaker partitioning is enabled, <code>Speaker</code> labels the speaker of the specified item.</p>
    pub fn speaker(&self) -> std::option::Option<&str> {
        self.speaker.as_deref()
    }
    /// <p>The confidence score associated with a word or phrase in your transcript.</p>
    /// <p>Confidence scores are values between 0 and 1. A larger value indicates a higher probability that the identified item correctly matches the item spoken in your media.</p>
    pub fn confidence(&self) -> std::option::Option<f64> {
        self.confidence
    }
    /// <p>If partial result stabilization is enabled, <code>Stable</code> indicates whether the specified item is stable (<code>true</code>) or if it may change when the segment is complete (<code>false</code>).</p>
    pub fn stable(&self) -> std::option::Option<bool> {
        self.stable
    }
}
/// See [`Item`](crate::model::Item).
pub mod item {

    /// A builder for [`Item`](crate::model::Item).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) start_time: std::option::Option<f64>,
        pub(crate) end_time: std::option::Option<f64>,
        pub(crate) r#type: std::option::Option<crate::model::ItemType>,
        pub(crate) content: std::option::Option<std::string::String>,
        pub(crate) vocabulary_filter_match: std::option::Option<bool>,
        pub(crate) speaker: std::option::Option<std::string::String>,
        pub(crate) confidence: std::option::Option<f64>,
        pub(crate) stable: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>The start time, in milliseconds, of the transcribed item.</p>
        pub fn start_time(mut self, input: f64) -> Self {
            self.start_time = Some(input);
            self
        }
        /// <p>The start time, in milliseconds, of the transcribed item.</p>
        pub fn set_start_time(mut self, input: std::option::Option<f64>) -> Self {
            self.start_time = input;
            self
        }
        /// <p>The end time, in milliseconds, of the transcribed item.</p>
        pub fn end_time(mut self, input: f64) -> Self {
            self.end_time = Some(input);
            self
        }
        /// <p>The end time, in milliseconds, of the transcribed item.</p>
        pub fn set_end_time(mut self, input: std::option::Option<f64>) -> Self {
            self.end_time = input;
            self
        }
        /// <p>The type of item identified. Options are: <code>PRONUNCIATION</code> (spoken words) and <code>PUNCTUATION</code>.</p>
        pub fn r#type(mut self, input: crate::model::ItemType) -> Self {
            self.r#type = Some(input);
            self
        }
        /// <p>The type of item identified. Options are: <code>PRONUNCIATION</code> (spoken words) and <code>PUNCTUATION</code>.</p>
        pub fn set_type(mut self, input: std::option::Option<crate::model::ItemType>) -> Self {
            self.r#type = input;
            self
        }
        /// <p>The word or punctuation that was transcribed.</p>
        pub fn content(mut self, input: impl Into<std::string::String>) -> Self {
            self.content = Some(input.into());
            self
        }
        /// <p>The word or punctuation that was transcribed.</p>
        pub fn set_content(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.content = input;
            self
        }
        /// <p>Indicates whether the specified item matches a word in the vocabulary filter included in your request. If <code>true</code>, there is a vocabulary filter match.</p>
        pub fn vocabulary_filter_match(mut self, input: bool) -> Self {
            self.vocabulary_filter_match = Some(input);
            self
        }
        /// <p>Indicates whether the specified item matches a word in the vocabulary filter included in your request. If <code>true</code>, there is a vocabulary filter match.</p>
        pub fn set_vocabulary_filter_match(mut self, input: std::option::Option<bool>) -> Self {
            self.vocabulary_filter_match = input;
            self
        }
        /// <p>If speaker partitioning is enabled, <code>Speaker</code> labels the speaker of the specified item.</p>
        pub fn speaker(mut self, input: impl Into<std::string::String>) -> Self {
            self.speaker = Some(input.into());
            self
        }
        /// <p>If speaker partitioning is enabled, <code>Speaker</code> labels the speaker of the specified item.</p>
        pub fn set_speaker(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.speaker = input;
            self
        }
        /// <p>The confidence score associated with a word or phrase in your transcript.</p>
        /// <p>Confidence scores are values between 0 and 1. A larger value indicates a higher probability that the identified item correctly matches the item spoken in your media.</p>
        pub fn confidence(mut self, input: f64) -> Self {
            self.confidence = Some(input);
            self
        }
        /// <p>The confidence score associated with a word or phrase in your transcript.</p>
        /// <p>Confidence scores are values between 0 and 1. A larger value indicates a higher probability that the identified item correctly matches the item spoken in your media.</p>
        pub fn set_confidence(mut self, input: std::option::Option<f64>) -> Self {
            self.confidence = input;
            self
        }
        /// <p>If partial result stabilization is enabled, <code>Stable</code> indicates whether the specified item is stable (<code>true</code>) or if it may change when the segment is complete (<code>false</code>).</p>
        pub fn stable(mut self, input: bool) -> Self {
            self.stable = Some(input);
            self
        }
        /// <p>If partial result stabilization is enabled, <code>Stable</code> indicates whether the specified item is stable (<code>true</code>) or if it may change when the segment is complete (<code>false</code>).</p>
        pub fn set_stable(mut self, input: std::option::Option<bool>) -> Self {
            self.stable = input;
            self
        }
        /// Consumes the builder and constructs a [`Item`](crate::model::Item).
        pub fn build(self) -> crate::model::Item {
            crate::model::Item {
                start_time: self.start_time.unwrap_or_default(),
                end_time: self.end_time.unwrap_or_default(),
                r#type: self.r#type,
                content: self.content,
                vocabulary_filter_match: self.vocabulary_filter_match.unwrap_or_default(),
                speaker: self.speaker,
                confidence: self.confidence,
                stable: self.stable,
            }
        }
    }
}
impl Item {
    /// Creates a new builder-style object to manufacture [`Item`](crate::model::Item).
    pub fn builder() -> crate::model::item::Builder {
        crate::model::item::Builder::default()
    }
}

/// When writing a match expression against `ItemType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let itemtype = unimplemented!();
/// match itemtype {
///     ItemType::Pronunciation => { /* ... */ },
///     ItemType::Punctuation => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `itemtype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ItemType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ItemType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ItemType::NewFeature` is defined.
/// Specifically, when `itemtype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ItemType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ItemType {
    #[allow(missing_docs)] // documentation missing in model
    Pronunciation,
    #[allow(missing_docs)] // documentation missing in model
    Punctuation,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ItemType {
    fn from(s: &str) -> Self {
        match s {
            "pronunciation" => ItemType::Pronunciation,
            "punctuation" => ItemType::Punctuation,
            other => ItemType::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for ItemType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ItemType::from(s))
    }
}
impl ItemType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ItemType::Pronunciation => "pronunciation",
            ItemType::Punctuation => "punctuation",
            ItemType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["pronunciation", "punctuation"]
    }
}
impl AsRef<str> for ItemType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `MediaEncoding`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let mediaencoding = unimplemented!();
/// match mediaencoding {
///     MediaEncoding::Flac => { /* ... */ },
///     MediaEncoding::OggOpus => { /* ... */ },
///     MediaEncoding::Pcm => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `mediaencoding` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `MediaEncoding::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `MediaEncoding::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `MediaEncoding::NewFeature` is defined.
/// Specifically, when `mediaencoding` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `MediaEncoding::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum MediaEncoding {
    #[allow(missing_docs)] // documentation missing in model
    Flac,
    #[allow(missing_docs)] // documentation missing in model
    OggOpus,
    #[allow(missing_docs)] // documentation missing in model
    Pcm,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for MediaEncoding {
    fn from(s: &str) -> Self {
        match s {
            "flac" => MediaEncoding::Flac,
            "ogg-opus" => MediaEncoding::OggOpus,
            "pcm" => MediaEncoding::Pcm,
            other => MediaEncoding::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for MediaEncoding {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(MediaEncoding::from(s))
    }
}
impl MediaEncoding {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            MediaEncoding::Flac => "flac",
            MediaEncoding::OggOpus => "ogg-opus",
            MediaEncoding::Pcm => "pcm",
            MediaEncoding::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["flac", "ogg-opus", "pcm"]
    }
}
impl AsRef<str> for MediaEncoding {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>An encoded stream of audio blobs. Audio streams are encoded as either HTTP/2 or WebSocket data frames.</p>
/// <p>For more information, see <a href="https://docs.aws.amazon.com/transcribe/latest/dg/streaming.html">Transcribing streaming audio</a>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub enum AudioStream {
    /// <p>A blob of audio from your application. Your audio stream consists of one or more audio events.</p>
    /// <p>For more information, see <a href="https://docs.aws.amazon.com/transcribe/latest/dg/event-stream.html">Event stream encoding</a>.</p>
    AudioEvent(crate::model::AudioEvent),
    /// <p>Contains audio channel definitions and post-call analytics settings.</p>
    ConfigurationEvent(crate::model::ConfigurationEvent),
    /// The `Unknown` variant represents cases where new union variant was received. Consider upgrading the SDK to the latest available version.
    /// An unknown enum variant
    ///
    /// _Note: If you encounter this error, consider upgrading your SDK to the latest version._
    /// The `Unknown` variant represents cases where the server sent a value that wasn't recognized
    /// by the client. This can happen when the server adds new functionality, but the client has not been updated.
    /// To investigate this, consider turning on debug logging to print the raw HTTP response.
    #[non_exhaustive]
    Unknown,
}
impl AudioStream {
    /// Tries to convert the enum instance into [`AudioEvent`](crate::model::AudioStream::AudioEvent), extracting the inner [`AudioEvent`](crate::model::AudioEvent).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_audio_event(&self) -> std::result::Result<&crate::model::AudioEvent, &Self> {
        if let AudioStream::AudioEvent(val) = &self {
            Ok(val)
        } else {
            Err(self)
        }
    }
    /// Returns true if this is a [`AudioEvent`](crate::model::AudioStream::AudioEvent).
    pub fn is_audio_event(&self) -> bool {
        self.as_audio_event().is_ok()
    }
    /// Tries to convert the enum instance into [`ConfigurationEvent`](crate::model::AudioStream::ConfigurationEvent), extracting the inner [`ConfigurationEvent`](crate::model::ConfigurationEvent).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_configuration_event(
        &self,
    ) -> std::result::Result<&crate::model::ConfigurationEvent, &Self> {
        if let AudioStream::ConfigurationEvent(val) = &self {
            Ok(val)
        } else {
            Err(self)
        }
    }
    /// Returns true if this is a [`ConfigurationEvent`](crate::model::AudioStream::ConfigurationEvent).
    pub fn is_configuration_event(&self) -> bool {
        self.as_configuration_event().is_ok()
    }
    /// Returns true if the enum instance is the `Unknown` variant.
    pub fn is_unknown(&self) -> bool {
        matches!(self, Self::Unknown)
    }
}

/// <p>Allows you to set audio channel definitions and post-call analytics settings.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ConfigurationEvent {
    /// <p>Indicates which speaker is on which audio channel.</p>
    #[doc(hidden)]
    pub channel_definitions: std::option::Option<std::vec::Vec<crate::model::ChannelDefinition>>,
    /// <p>Provides additional optional settings for your Call Analytics post-call request, including encryption and output locations for your redacted and unredacted transcript.</p>
    #[doc(hidden)]
    pub post_call_analytics_settings: std::option::Option<crate::model::PostCallAnalyticsSettings>,
}
impl ConfigurationEvent {
    /// <p>Indicates which speaker is on which audio channel.</p>
    pub fn channel_definitions(&self) -> std::option::Option<&[crate::model::ChannelDefinition]> {
        self.channel_definitions.as_deref()
    }
    /// <p>Provides additional optional settings for your Call Analytics post-call request, including encryption and output locations for your redacted and unredacted transcript.</p>
    pub fn post_call_analytics_settings(
        &self,
    ) -> std::option::Option<&crate::model::PostCallAnalyticsSettings> {
        self.post_call_analytics_settings.as_ref()
    }
}
/// See [`ConfigurationEvent`](crate::model::ConfigurationEvent).
pub mod configuration_event {

    /// A builder for [`ConfigurationEvent`](crate::model::ConfigurationEvent).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) channel_definitions:
            std::option::Option<std::vec::Vec<crate::model::ChannelDefinition>>,
        pub(crate) post_call_analytics_settings:
            std::option::Option<crate::model::PostCallAnalyticsSettings>,
    }
    impl Builder {
        /// Appends an item to `channel_definitions`.
        ///
        /// To override the contents of this collection use [`set_channel_definitions`](Self::set_channel_definitions).
        ///
        /// <p>Indicates which speaker is on which audio channel.</p>
        pub fn channel_definitions(mut self, input: crate::model::ChannelDefinition) -> Self {
            let mut v = self.channel_definitions.unwrap_or_default();
            v.push(input);
            self.channel_definitions = Some(v);
            self
        }
        /// <p>Indicates which speaker is on which audio channel.</p>
        pub fn set_channel_definitions(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ChannelDefinition>>,
        ) -> Self {
            self.channel_definitions = input;
            self
        }
        /// <p>Provides additional optional settings for your Call Analytics post-call request, including encryption and output locations for your redacted and unredacted transcript.</p>
        pub fn post_call_analytics_settings(
            mut self,
            input: crate::model::PostCallAnalyticsSettings,
        ) -> Self {
            self.post_call_analytics_settings = Some(input);
            self
        }
        /// <p>Provides additional optional settings for your Call Analytics post-call request, including encryption and output locations for your redacted and unredacted transcript.</p>
        pub fn set_post_call_analytics_settings(
            mut self,
            input: std::option::Option<crate::model::PostCallAnalyticsSettings>,
        ) -> Self {
            self.post_call_analytics_settings = input;
            self
        }
        /// Consumes the builder and constructs a [`ConfigurationEvent`](crate::model::ConfigurationEvent).
        pub fn build(self) -> crate::model::ConfigurationEvent {
            crate::model::ConfigurationEvent {
                channel_definitions: self.channel_definitions,
                post_call_analytics_settings: self.post_call_analytics_settings,
            }
        }
    }
}
impl ConfigurationEvent {
    /// Creates a new builder-style object to manufacture [`ConfigurationEvent`](crate::model::ConfigurationEvent).
    pub fn builder() -> crate::model::configuration_event::Builder {
        crate::model::configuration_event::Builder::default()
    }
}

/// <p>Allows you to specify additional settings for your streaming Call Analytics post-call request, including output locations for your redacted and unredacted transcript, which IAM role to use, and, optionally, which encryption key to use.</p>
/// <p> <code>ContentRedactionOutput</code>, <code>DataAccessRoleArn</code>, and <code>OutputLocation</code> are required fields.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct PostCallAnalyticsSettings {
    /// <p>The Amazon S3 location where you want your Call Analytics post-call transcription output stored. You can use any of the following formats to specify the output location:</p>
    /// <ol>
    /// <li> <p>s3://DOC-EXAMPLE-BUCKET</p> </li>
    /// <li> <p>s3://DOC-EXAMPLE-BUCKET/my-output-folder/</p> </li>
    /// <li> <p>s3://DOC-EXAMPLE-BUCKET/my-output-folder/my-call-analytics-job.json</p> </li>
    /// </ol>
    #[doc(hidden)]
    pub output_location: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of an IAM role that has permissions to access the Amazon S3 bucket that contains your input files. If the role that you specify doesn’t have the appropriate permissions to access the specified Amazon S3 location, your request fails.</p>
    /// <p>IAM role ARNs have the format <code>arn:partition:iam::account:role/role-name-with-path</code>. For example: <code>arn:aws:iam::111122223333:role/Admin</code>. For more information, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_identifiers.html#identifiers-arns">IAM ARNs</a>.</p>
    #[doc(hidden)]
    pub data_access_role_arn: std::option::Option<std::string::String>,
    /// <p>Specify whether you want only a redacted transcript or both a redacted and an unredacted transcript. If you choose redacted and unredacted, two JSON files are generated and stored in the Amazon S3 output location you specify.</p>
    /// <p>Note that to include <code>ContentRedactionOutput</code> in your request, you must enable content redaction (<code>ContentRedactionType</code>).</p>
    #[doc(hidden)]
    pub content_redaction_output: std::option::Option<crate::model::ContentRedactionOutput>,
    /// <p>The KMS key you want to use to encrypt your Call Analytics post-call output.</p>
    /// <p>If using a key located in the <b>current</b> Amazon Web Services account, you can specify your KMS key in one of four ways:</p>
    /// <ol>
    /// <li> <p>Use the KMS key ID itself. For example, <code>1234abcd-12ab-34cd-56ef-1234567890ab</code>.</p> </li>
    /// <li> <p>Use an alias for the KMS key ID. For example, <code>alias/ExampleAlias</code>.</p> </li>
    /// <li> <p>Use the Amazon Resource Name (ARN) for the KMS key ID. For example, <code>arn:aws:kms:region:account-ID:key/1234abcd-12ab-34cd-56ef-1234567890ab</code>.</p> </li>
    /// <li> <p>Use the ARN for the KMS key alias. For example, <code>arn:aws:kms:region:account-ID:alias/ExampleAlias</code>.</p> </li>
    /// </ol>
    /// <p>If using a key located in a <b>different</b> Amazon Web Services account than the current Amazon Web Services account, you can specify your KMS key in one of two ways:</p>
    /// <ol>
    /// <li> <p>Use the ARN for the KMS key ID. For example, <code>arn:aws:kms:region:account-ID:key/1234abcd-12ab-34cd-56ef-1234567890ab</code>.</p> </li>
    /// <li> <p>Use the ARN for the KMS key alias. For example, <code>arn:aws:kms:region:account-ID:alias/ExampleAlias</code>.</p> </li>
    /// </ol>
    /// <p>Note that the user making the request must have permission to use the specified KMS key.</p>
    #[doc(hidden)]
    pub output_encryption_kms_key_id: std::option::Option<std::string::String>,
}
impl PostCallAnalyticsSettings {
    /// <p>The Amazon S3 location where you want your Call Analytics post-call transcription output stored. You can use any of the following formats to specify the output location:</p>
    /// <ol>
    /// <li> <p>s3://DOC-EXAMPLE-BUCKET</p> </li>
    /// <li> <p>s3://DOC-EXAMPLE-BUCKET/my-output-folder/</p> </li>
    /// <li> <p>s3://DOC-EXAMPLE-BUCKET/my-output-folder/my-call-analytics-job.json</p> </li>
    /// </ol>
    pub fn output_location(&self) -> std::option::Option<&str> {
        self.output_location.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of an IAM role that has permissions to access the Amazon S3 bucket that contains your input files. If the role that you specify doesn’t have the appropriate permissions to access the specified Amazon S3 location, your request fails.</p>
    /// <p>IAM role ARNs have the format <code>arn:partition:iam::account:role/role-name-with-path</code>. For example: <code>arn:aws:iam::111122223333:role/Admin</code>. For more information, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_identifiers.html#identifiers-arns">IAM ARNs</a>.</p>
    pub fn data_access_role_arn(&self) -> std::option::Option<&str> {
        self.data_access_role_arn.as_deref()
    }
    /// <p>Specify whether you want only a redacted transcript or both a redacted and an unredacted transcript. If you choose redacted and unredacted, two JSON files are generated and stored in the Amazon S3 output location you specify.</p>
    /// <p>Note that to include <code>ContentRedactionOutput</code> in your request, you must enable content redaction (<code>ContentRedactionType</code>).</p>
    pub fn content_redaction_output(
        &self,
    ) -> std::option::Option<&crate::model::ContentRedactionOutput> {
        self.content_redaction_output.as_ref()
    }
    /// <p>The KMS key you want to use to encrypt your Call Analytics post-call output.</p>
    /// <p>If using a key located in the <b>current</b> Amazon Web Services account, you can specify your KMS key in one of four ways:</p>
    /// <ol>
    /// <li> <p>Use the KMS key ID itself. For example, <code>1234abcd-12ab-34cd-56ef-1234567890ab</code>.</p> </li>
    /// <li> <p>Use an alias for the KMS key ID. For example, <code>alias/ExampleAlias</code>.</p> </li>
    /// <li> <p>Use the Amazon Resource Name (ARN) for the KMS key ID. For example, <code>arn:aws:kms:region:account-ID:key/1234abcd-12ab-34cd-56ef-1234567890ab</code>.</p> </li>
    /// <li> <p>Use the ARN for the KMS key alias. For example, <code>arn:aws:kms:region:account-ID:alias/ExampleAlias</code>.</p> </li>
    /// </ol>
    /// <p>If using a key located in a <b>different</b> Amazon Web Services account than the current Amazon Web Services account, you can specify your KMS key in one of two ways:</p>
    /// <ol>
    /// <li> <p>Use the ARN for the KMS key ID. For example, <code>arn:aws:kms:region:account-ID:key/1234abcd-12ab-34cd-56ef-1234567890ab</code>.</p> </li>
    /// <li> <p>Use the ARN for the KMS key alias. For example, <code>arn:aws:kms:region:account-ID:alias/ExampleAlias</code>.</p> </li>
    /// </ol>
    /// <p>Note that the user making the request must have permission to use the specified KMS key.</p>
    pub fn output_encryption_kms_key_id(&self) -> std::option::Option<&str> {
        self.output_encryption_kms_key_id.as_deref()
    }
}
/// See [`PostCallAnalyticsSettings`](crate::model::PostCallAnalyticsSettings).
pub mod post_call_analytics_settings {

    /// A builder for [`PostCallAnalyticsSettings`](crate::model::PostCallAnalyticsSettings).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) output_location: std::option::Option<std::string::String>,
        pub(crate) data_access_role_arn: std::option::Option<std::string::String>,
        pub(crate) content_redaction_output:
            std::option::Option<crate::model::ContentRedactionOutput>,
        pub(crate) output_encryption_kms_key_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon S3 location where you want your Call Analytics post-call transcription output stored. You can use any of the following formats to specify the output location:</p>
        /// <ol>
        /// <li> <p>s3://DOC-EXAMPLE-BUCKET</p> </li>
        /// <li> <p>s3://DOC-EXAMPLE-BUCKET/my-output-folder/</p> </li>
        /// <li> <p>s3://DOC-EXAMPLE-BUCKET/my-output-folder/my-call-analytics-job.json</p> </li>
        /// </ol>
        pub fn output_location(mut self, input: impl Into<std::string::String>) -> Self {
            self.output_location = Some(input.into());
            self
        }
        /// <p>The Amazon S3 location where you want your Call Analytics post-call transcription output stored. You can use any of the following formats to specify the output location:</p>
        /// <ol>
        /// <li> <p>s3://DOC-EXAMPLE-BUCKET</p> </li>
        /// <li> <p>s3://DOC-EXAMPLE-BUCKET/my-output-folder/</p> </li>
        /// <li> <p>s3://DOC-EXAMPLE-BUCKET/my-output-folder/my-call-analytics-job.json</p> </li>
        /// </ol>
        pub fn set_output_location(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.output_location = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of an IAM role that has permissions to access the Amazon S3 bucket that contains your input files. If the role that you specify doesn’t have the appropriate permissions to access the specified Amazon S3 location, your request fails.</p>
        /// <p>IAM role ARNs have the format <code>arn:partition:iam::account:role/role-name-with-path</code>. For example: <code>arn:aws:iam::111122223333:role/Admin</code>. For more information, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_identifiers.html#identifiers-arns">IAM ARNs</a>.</p>
        pub fn data_access_role_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.data_access_role_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of an IAM role that has permissions to access the Amazon S3 bucket that contains your input files. If the role that you specify doesn’t have the appropriate permissions to access the specified Amazon S3 location, your request fails.</p>
        /// <p>IAM role ARNs have the format <code>arn:partition:iam::account:role/role-name-with-path</code>. For example: <code>arn:aws:iam::111122223333:role/Admin</code>. For more information, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_identifiers.html#identifiers-arns">IAM ARNs</a>.</p>
        pub fn set_data_access_role_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.data_access_role_arn = input;
            self
        }
        /// <p>Specify whether you want only a redacted transcript or both a redacted and an unredacted transcript. If you choose redacted and unredacted, two JSON files are generated and stored in the Amazon S3 output location you specify.</p>
        /// <p>Note that to include <code>ContentRedactionOutput</code> in your request, you must enable content redaction (<code>ContentRedactionType</code>).</p>
        pub fn content_redaction_output(
            mut self,
            input: crate::model::ContentRedactionOutput,
        ) -> Self {
            self.content_redaction_output = Some(input);
            self
        }
        /// <p>Specify whether you want only a redacted transcript or both a redacted and an unredacted transcript. If you choose redacted and unredacted, two JSON files are generated and stored in the Amazon S3 output location you specify.</p>
        /// <p>Note that to include <code>ContentRedactionOutput</code> in your request, you must enable content redaction (<code>ContentRedactionType</code>).</p>
        pub fn set_content_redaction_output(
            mut self,
            input: std::option::Option<crate::model::ContentRedactionOutput>,
        ) -> Self {
            self.content_redaction_output = input;
            self
        }
        /// <p>The KMS key you want to use to encrypt your Call Analytics post-call output.</p>
        /// <p>If using a key located in the <b>current</b> Amazon Web Services account, you can specify your KMS key in one of four ways:</p>
        /// <ol>
        /// <li> <p>Use the KMS key ID itself. For example, <code>1234abcd-12ab-34cd-56ef-1234567890ab</code>.</p> </li>
        /// <li> <p>Use an alias for the KMS key ID. For example, <code>alias/ExampleAlias</code>.</p> </li>
        /// <li> <p>Use the Amazon Resource Name (ARN) for the KMS key ID. For example, <code>arn:aws:kms:region:account-ID:key/1234abcd-12ab-34cd-56ef-1234567890ab</code>.</p> </li>
        /// <li> <p>Use the ARN for the KMS key alias. For example, <code>arn:aws:kms:region:account-ID:alias/ExampleAlias</code>.</p> </li>
        /// </ol>
        /// <p>If using a key located in a <b>different</b> Amazon Web Services account than the current Amazon Web Services account, you can specify your KMS key in one of two ways:</p>
        /// <ol>
        /// <li> <p>Use the ARN for the KMS key ID. For example, <code>arn:aws:kms:region:account-ID:key/1234abcd-12ab-34cd-56ef-1234567890ab</code>.</p> </li>
        /// <li> <p>Use the ARN for the KMS key alias. For example, <code>arn:aws:kms:region:account-ID:alias/ExampleAlias</code>.</p> </li>
        /// </ol>
        /// <p>Note that the user making the request must have permission to use the specified KMS key.</p>
        pub fn output_encryption_kms_key_id(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.output_encryption_kms_key_id = Some(input.into());
            self
        }
        /// <p>The KMS key you want to use to encrypt your Call Analytics post-call output.</p>
        /// <p>If using a key located in the <b>current</b> Amazon Web Services account, you can specify your KMS key in one of four ways:</p>
        /// <ol>
        /// <li> <p>Use the KMS key ID itself. For example, <code>1234abcd-12ab-34cd-56ef-1234567890ab</code>.</p> </li>
        /// <li> <p>Use an alias for the KMS key ID. For example, <code>alias/ExampleAlias</code>.</p> </li>
        /// <li> <p>Use the Amazon Resource Name (ARN) for the KMS key ID. For example, <code>arn:aws:kms:region:account-ID:key/1234abcd-12ab-34cd-56ef-1234567890ab</code>.</p> </li>
        /// <li> <p>Use the ARN for the KMS key alias. For example, <code>arn:aws:kms:region:account-ID:alias/ExampleAlias</code>.</p> </li>
        /// </ol>
        /// <p>If using a key located in a <b>different</b> Amazon Web Services account than the current Amazon Web Services account, you can specify your KMS key in one of two ways:</p>
        /// <ol>
        /// <li> <p>Use the ARN for the KMS key ID. For example, <code>arn:aws:kms:region:account-ID:key/1234abcd-12ab-34cd-56ef-1234567890ab</code>.</p> </li>
        /// <li> <p>Use the ARN for the KMS key alias. For example, <code>arn:aws:kms:region:account-ID:alias/ExampleAlias</code>.</p> </li>
        /// </ol>
        /// <p>Note that the user making the request must have permission to use the specified KMS key.</p>
        pub fn set_output_encryption_kms_key_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.output_encryption_kms_key_id = input;
            self
        }
        /// Consumes the builder and constructs a [`PostCallAnalyticsSettings`](crate::model::PostCallAnalyticsSettings).
        pub fn build(self) -> crate::model::PostCallAnalyticsSettings {
            crate::model::PostCallAnalyticsSettings {
                output_location: self.output_location,
                data_access_role_arn: self.data_access_role_arn,
                content_redaction_output: self.content_redaction_output,
                output_encryption_kms_key_id: self.output_encryption_kms_key_id,
            }
        }
    }
}
impl PostCallAnalyticsSettings {
    /// Creates a new builder-style object to manufacture [`PostCallAnalyticsSettings`](crate::model::PostCallAnalyticsSettings).
    pub fn builder() -> crate::model::post_call_analytics_settings::Builder {
        crate::model::post_call_analytics_settings::Builder::default()
    }
}

/// When writing a match expression against `ContentRedactionOutput`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let contentredactionoutput = unimplemented!();
/// match contentredactionoutput {
///     ContentRedactionOutput::Redacted => { /* ... */ },
///     ContentRedactionOutput::RedactedAndUnredacted => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `contentredactionoutput` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ContentRedactionOutput::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ContentRedactionOutput::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ContentRedactionOutput::NewFeature` is defined.
/// Specifically, when `contentredactionoutput` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ContentRedactionOutput::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ContentRedactionOutput {
    #[allow(missing_docs)] // documentation missing in model
    Redacted,
    #[allow(missing_docs)] // documentation missing in model
    RedactedAndUnredacted,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ContentRedactionOutput {
    fn from(s: &str) -> Self {
        match s {
            "redacted" => ContentRedactionOutput::Redacted,
            "redacted_and_unredacted" => ContentRedactionOutput::RedactedAndUnredacted,
            other => {
                ContentRedactionOutput::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for ContentRedactionOutput {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ContentRedactionOutput::from(s))
    }
}
impl ContentRedactionOutput {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ContentRedactionOutput::Redacted => "redacted",
            ContentRedactionOutput::RedactedAndUnredacted => "redacted_and_unredacted",
            ContentRedactionOutput::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["redacted", "redacted_and_unredacted"]
    }
}
impl AsRef<str> for ContentRedactionOutput {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Makes it possible to specify which speaker is on which audio channel. For example, if your agent is the first participant to speak, you would set <code>ChannelId</code> to <code>0</code> (to indicate the first channel) and <code>ParticipantRole</code> to <code>AGENT</code> (to indicate that it's the agent speaking).</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ChannelDefinition {
    /// <p>Specify the audio channel you want to define.</p>
    #[doc(hidden)]
    pub channel_id: i32,
    /// <p>Specify the speaker you want to define. Omitting this parameter is equivalent to specifying both participants.</p>
    #[doc(hidden)]
    pub participant_role: std::option::Option<crate::model::ParticipantRole>,
}
impl ChannelDefinition {
    /// <p>Specify the audio channel you want to define.</p>
    pub fn channel_id(&self) -> i32 {
        self.channel_id
    }
    /// <p>Specify the speaker you want to define. Omitting this parameter is equivalent to specifying both participants.</p>
    pub fn participant_role(&self) -> std::option::Option<&crate::model::ParticipantRole> {
        self.participant_role.as_ref()
    }
}
/// See [`ChannelDefinition`](crate::model::ChannelDefinition).
pub mod channel_definition {

    /// A builder for [`ChannelDefinition`](crate::model::ChannelDefinition).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) channel_id: std::option::Option<i32>,
        pub(crate) participant_role: std::option::Option<crate::model::ParticipantRole>,
    }
    impl Builder {
        /// <p>Specify the audio channel you want to define.</p>
        pub fn channel_id(mut self, input: i32) -> Self {
            self.channel_id = Some(input);
            self
        }
        /// <p>Specify the audio channel you want to define.</p>
        pub fn set_channel_id(mut self, input: std::option::Option<i32>) -> Self {
            self.channel_id = input;
            self
        }
        /// <p>Specify the speaker you want to define. Omitting this parameter is equivalent to specifying both participants.</p>
        pub fn participant_role(mut self, input: crate::model::ParticipantRole) -> Self {
            self.participant_role = Some(input);
            self
        }
        /// <p>Specify the speaker you want to define. Omitting this parameter is equivalent to specifying both participants.</p>
        pub fn set_participant_role(
            mut self,
            input: std::option::Option<crate::model::ParticipantRole>,
        ) -> Self {
            self.participant_role = input;
            self
        }
        /// Consumes the builder and constructs a [`ChannelDefinition`](crate::model::ChannelDefinition).
        pub fn build(self) -> crate::model::ChannelDefinition {
            crate::model::ChannelDefinition {
                channel_id: self.channel_id.unwrap_or_default(),
                participant_role: self.participant_role,
            }
        }
    }
}
impl ChannelDefinition {
    /// Creates a new builder-style object to manufacture [`ChannelDefinition`](crate::model::ChannelDefinition).
    pub fn builder() -> crate::model::channel_definition::Builder {
        crate::model::channel_definition::Builder::default()
    }
}

/// When writing a match expression against `ParticipantRole`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let participantrole = unimplemented!();
/// match participantrole {
///     ParticipantRole::Agent => { /* ... */ },
///     ParticipantRole::Customer => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `participantrole` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ParticipantRole::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ParticipantRole::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ParticipantRole::NewFeature` is defined.
/// Specifically, when `participantrole` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ParticipantRole::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ParticipantRole {
    #[allow(missing_docs)] // documentation missing in model
    Agent,
    #[allow(missing_docs)] // documentation missing in model
    Customer,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ParticipantRole {
    fn from(s: &str) -> Self {
        match s {
            "AGENT" => ParticipantRole::Agent,
            "CUSTOMER" => ParticipantRole::Customer,
            other => ParticipantRole::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for ParticipantRole {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ParticipantRole::from(s))
    }
}
impl ParticipantRole {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ParticipantRole::Agent => "AGENT",
            ParticipantRole::Customer => "CUSTOMER",
            ParticipantRole::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["AGENT", "CUSTOMER"]
    }
}
impl AsRef<str> for ParticipantRole {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>A wrapper for your audio chunks. Your audio stream consists of one or more audio events, which consist of one or more audio chunks.</p>
/// <p>For more information, see <a href="https://docs.aws.amazon.com/transcribe/latest/dg/event-stream.html">Event stream encoding</a>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AudioEvent {
    /// <p>An audio blob that contains the next part of the audio that you want to transcribe. The maximum audio chunk size is 32 KB.</p>
    #[doc(hidden)]
    pub audio_chunk: std::option::Option<aws_smithy_types::Blob>,
}
impl AudioEvent {
    /// <p>An audio blob that contains the next part of the audio that you want to transcribe. The maximum audio chunk size is 32 KB.</p>
    pub fn audio_chunk(&self) -> std::option::Option<&aws_smithy_types::Blob> {
        self.audio_chunk.as_ref()
    }
}
/// See [`AudioEvent`](crate::model::AudioEvent).
pub mod audio_event {

    /// A builder for [`AudioEvent`](crate::model::AudioEvent).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) audio_chunk: std::option::Option<aws_smithy_types::Blob>,
    }
    impl Builder {
        /// <p>An audio blob that contains the next part of the audio that you want to transcribe. The maximum audio chunk size is 32 KB.</p>
        pub fn audio_chunk(mut self, input: aws_smithy_types::Blob) -> Self {
            self.audio_chunk = Some(input);
            self
        }
        /// <p>An audio blob that contains the next part of the audio that you want to transcribe. The maximum audio chunk size is 32 KB.</p>
        pub fn set_audio_chunk(
            mut self,
            input: std::option::Option<aws_smithy_types::Blob>,
        ) -> Self {
            self.audio_chunk = input;
            self
        }
        /// Consumes the builder and constructs a [`AudioEvent`](crate::model::AudioEvent).
        pub fn build(self) -> crate::model::AudioEvent {
            crate::model::AudioEvent {
                audio_chunk: self.audio_chunk,
            }
        }
    }
}
impl AudioEvent {
    /// Creates a new builder-style object to manufacture [`AudioEvent`](crate::model::AudioEvent).
    pub fn builder() -> crate::model::audio_event::Builder {
        crate::model::audio_event::Builder::default()
    }
}

/// When writing a match expression against `MedicalContentIdentificationType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let medicalcontentidentificationtype = unimplemented!();
/// match medicalcontentidentificationtype {
///     MedicalContentIdentificationType::Phi => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `medicalcontentidentificationtype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `MedicalContentIdentificationType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `MedicalContentIdentificationType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `MedicalContentIdentificationType::NewFeature` is defined.
/// Specifically, when `medicalcontentidentificationtype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `MedicalContentIdentificationType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum MedicalContentIdentificationType {
    #[allow(missing_docs)] // documentation missing in model
    Phi,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for MedicalContentIdentificationType {
    fn from(s: &str) -> Self {
        match s {
            "PHI" => MedicalContentIdentificationType::Phi,
            other => MedicalContentIdentificationType::Unknown(crate::types::UnknownVariantValue(
                other.to_owned(),
            )),
        }
    }
}
impl std::str::FromStr for MedicalContentIdentificationType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(MedicalContentIdentificationType::from(s))
    }
}
impl MedicalContentIdentificationType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            MedicalContentIdentificationType::Phi => "PHI",
            MedicalContentIdentificationType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["PHI"]
    }
}
impl AsRef<str> for MedicalContentIdentificationType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Contains detailed information about your streaming session.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub enum MedicalTranscriptResultStream {
    /// <p>The <code>MedicalTranscriptEvent</code> associated with a <code>MedicalTranscriptResultStream</code>.</p>
    /// <p>Contains a set of transcription results from one or more audio segments, along with additional information per your request parameters. This can include information relating to alternative transcriptions, channel identification, partial result stabilization, language identification, and other transcription-related data.</p>
    TranscriptEvent(crate::model::MedicalTranscriptEvent),
    /// The `Unknown` variant represents cases where new union variant was received. Consider upgrading the SDK to the latest available version.
    /// An unknown enum variant
    ///
    /// _Note: If you encounter this error, consider upgrading your SDK to the latest version._
    /// The `Unknown` variant represents cases where the server sent a value that wasn't recognized
    /// by the client. This can happen when the server adds new functionality, but the client has not been updated.
    /// To investigate this, consider turning on debug logging to print the raw HTTP response.
    #[non_exhaustive]
    Unknown,
}
impl MedicalTranscriptResultStream {
    #[allow(irrefutable_let_patterns)]
    /// Tries to convert the enum instance into [`TranscriptEvent`](crate::model::MedicalTranscriptResultStream::TranscriptEvent), extracting the inner [`MedicalTranscriptEvent`](crate::model::MedicalTranscriptEvent).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_transcript_event(
        &self,
    ) -> std::result::Result<&crate::model::MedicalTranscriptEvent, &Self> {
        if let MedicalTranscriptResultStream::TranscriptEvent(val) = &self {
            Ok(val)
        } else {
            Err(self)
        }
    }
    /// Returns true if this is a [`TranscriptEvent`](crate::model::MedicalTranscriptResultStream::TranscriptEvent).
    pub fn is_transcript_event(&self) -> bool {
        self.as_transcript_event().is_ok()
    }
    /// Returns true if the enum instance is the `Unknown` variant.
    pub fn is_unknown(&self) -> bool {
        matches!(self, Self::Unknown)
    }
}

/// <p>The <code>MedicalTranscriptEvent</code> associated with a <code>MedicalTranscriptResultStream</code>.</p>
/// <p>Contains a set of transcription results from one or more audio segments, along with additional information per your request parameters.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct MedicalTranscriptEvent {
    /// <p>Contains <code>Results</code>, which contains a set of transcription results from one or more audio segments, along with additional information per your request parameters. This can include information relating to alternative transcriptions, channel identification, partial result stabilization, language identification, and other transcription-related data.</p>
    #[doc(hidden)]
    pub transcript: std::option::Option<crate::model::MedicalTranscript>,
}
impl MedicalTranscriptEvent {
    /// <p>Contains <code>Results</code>, which contains a set of transcription results from one or more audio segments, along with additional information per your request parameters. This can include information relating to alternative transcriptions, channel identification, partial result stabilization, language identification, and other transcription-related data.</p>
    pub fn transcript(&self) -> std::option::Option<&crate::model::MedicalTranscript> {
        self.transcript.as_ref()
    }
}
/// See [`MedicalTranscriptEvent`](crate::model::MedicalTranscriptEvent).
pub mod medical_transcript_event {

    /// A builder for [`MedicalTranscriptEvent`](crate::model::MedicalTranscriptEvent).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) transcript: std::option::Option<crate::model::MedicalTranscript>,
    }
    impl Builder {
        /// <p>Contains <code>Results</code>, which contains a set of transcription results from one or more audio segments, along with additional information per your request parameters. This can include information relating to alternative transcriptions, channel identification, partial result stabilization, language identification, and other transcription-related data.</p>
        pub fn transcript(mut self, input: crate::model::MedicalTranscript) -> Self {
            self.transcript = Some(input);
            self
        }
        /// <p>Contains <code>Results</code>, which contains a set of transcription results from one or more audio segments, along with additional information per your request parameters. This can include information relating to alternative transcriptions, channel identification, partial result stabilization, language identification, and other transcription-related data.</p>
        pub fn set_transcript(
            mut self,
            input: std::option::Option<crate::model::MedicalTranscript>,
        ) -> Self {
            self.transcript = input;
            self
        }
        /// Consumes the builder and constructs a [`MedicalTranscriptEvent`](crate::model::MedicalTranscriptEvent).
        pub fn build(self) -> crate::model::MedicalTranscriptEvent {
            crate::model::MedicalTranscriptEvent {
                transcript: self.transcript,
            }
        }
    }
}
impl MedicalTranscriptEvent {
    /// Creates a new builder-style object to manufacture [`MedicalTranscriptEvent`](crate::model::MedicalTranscriptEvent).
    pub fn builder() -> crate::model::medical_transcript_event::Builder {
        crate::model::medical_transcript_event::Builder::default()
    }
}

/// <p>The <code>MedicalTranscript</code> associated with a <code></code>.</p>
/// <p> <code>MedicalTranscript</code> contains <code>Results</code>, which contains a set of transcription results from one or more audio segments, along with additional information per your request parameters.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct MedicalTranscript {
    /// <p>Contains a set of transcription results from one or more audio segments, along with additional information per your request parameters. This can include information relating to alternative transcriptions, channel identification, partial result stabilization, language identification, and other transcription-related data.</p>
    #[doc(hidden)]
    pub results: std::option::Option<std::vec::Vec<crate::model::MedicalResult>>,
}
impl MedicalTranscript {
    /// <p>Contains a set of transcription results from one or more audio segments, along with additional information per your request parameters. This can include information relating to alternative transcriptions, channel identification, partial result stabilization, language identification, and other transcription-related data.</p>
    pub fn results(&self) -> std::option::Option<&[crate::model::MedicalResult]> {
        self.results.as_deref()
    }
}
/// See [`MedicalTranscript`](crate::model::MedicalTranscript).
pub mod medical_transcript {

    /// A builder for [`MedicalTranscript`](crate::model::MedicalTranscript).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) results: std::option::Option<std::vec::Vec<crate::model::MedicalResult>>,
    }
    impl Builder {
        /// Appends an item to `results`.
        ///
        /// To override the contents of this collection use [`set_results`](Self::set_results).
        ///
        /// <p>Contains a set of transcription results from one or more audio segments, along with additional information per your request parameters. This can include information relating to alternative transcriptions, channel identification, partial result stabilization, language identification, and other transcription-related data.</p>
        pub fn results(mut self, input: crate::model::MedicalResult) -> Self {
            let mut v = self.results.unwrap_or_default();
            v.push(input);
            self.results = Some(v);
            self
        }
        /// <p>Contains a set of transcription results from one or more audio segments, along with additional information per your request parameters. This can include information relating to alternative transcriptions, channel identification, partial result stabilization, language identification, and other transcription-related data.</p>
        pub fn set_results(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::MedicalResult>>,
        ) -> Self {
            self.results = input;
            self
        }
        /// Consumes the builder and constructs a [`MedicalTranscript`](crate::model::MedicalTranscript).
        pub fn build(self) -> crate::model::MedicalTranscript {
            crate::model::MedicalTranscript {
                results: self.results,
            }
        }
    }
}
impl MedicalTranscript {
    /// Creates a new builder-style object to manufacture [`MedicalTranscript`](crate::model::MedicalTranscript).
    pub fn builder() -> crate::model::medical_transcript::Builder {
        crate::model::medical_transcript::Builder::default()
    }
}

/// <p>The <code>Result</code> associated with a <code></code>.</p>
/// <p>Contains a set of transcription results from one or more audio segments, along with additional information per your request parameters. This can include information relating to alternative transcriptions, channel identification, partial result stabilization, language identification, and other transcription-related data.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct MedicalResult {
    /// <p>Provides a unique identifier for the <code>Result</code>.</p>
    #[doc(hidden)]
    pub result_id: std::option::Option<std::string::String>,
    /// <p>The start time, in milliseconds, of the <code>Result</code>.</p>
    #[doc(hidden)]
    pub start_time: f64,
    /// <p>The end time, in milliseconds, of the <code>Result</code>.</p>
    #[doc(hidden)]
    pub end_time: f64,
    /// <p>Indicates if the segment is complete.</p>
    /// <p>If <code>IsPartial</code> is <code>true</code>, the segment is not complete. If <code>IsPartial</code> is <code>false</code>, the segment is complete.</p>
    #[doc(hidden)]
    pub is_partial: bool,
    /// <p>A list of possible alternative transcriptions for the input audio. Each alternative may contain one or more of <code>Items</code>, <code>Entities</code>, or <code>Transcript</code>.</p>
    #[doc(hidden)]
    pub alternatives: std::option::Option<std::vec::Vec<crate::model::MedicalAlternative>>,
    /// <p>Indicates the channel identified for the <code>Result</code>.</p>
    #[doc(hidden)]
    pub channel_id: std::option::Option<std::string::String>,
}
impl MedicalResult {
    /// <p>Provides a unique identifier for the <code>Result</code>.</p>
    pub fn result_id(&self) -> std::option::Option<&str> {
        self.result_id.as_deref()
    }
    /// <p>The start time, in milliseconds, of the <code>Result</code>.</p>
    pub fn start_time(&self) -> f64 {
        self.start_time
    }
    /// <p>The end time, in milliseconds, of the <code>Result</code>.</p>
    pub fn end_time(&self) -> f64 {
        self.end_time
    }
    /// <p>Indicates if the segment is complete.</p>
    /// <p>If <code>IsPartial</code> is <code>true</code>, the segment is not complete. If <code>IsPartial</code> is <code>false</code>, the segment is complete.</p>
    pub fn is_partial(&self) -> bool {
        self.is_partial
    }
    /// <p>A list of possible alternative transcriptions for the input audio. Each alternative may contain one or more of <code>Items</code>, <code>Entities</code>, or <code>Transcript</code>.</p>
    pub fn alternatives(&self) -> std::option::Option<&[crate::model::MedicalAlternative]> {
        self.alternatives.as_deref()
    }
    /// <p>Indicates the channel identified for the <code>Result</code>.</p>
    pub fn channel_id(&self) -> std::option::Option<&str> {
        self.channel_id.as_deref()
    }
}
/// See [`MedicalResult`](crate::model::MedicalResult).
pub mod medical_result {

    /// A builder for [`MedicalResult`](crate::model::MedicalResult).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) result_id: std::option::Option<std::string::String>,
        pub(crate) start_time: std::option::Option<f64>,
        pub(crate) end_time: std::option::Option<f64>,
        pub(crate) is_partial: std::option::Option<bool>,
        pub(crate) alternatives:
            std::option::Option<std::vec::Vec<crate::model::MedicalAlternative>>,
        pub(crate) channel_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Provides a unique identifier for the <code>Result</code>.</p>
        pub fn result_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.result_id = Some(input.into());
            self
        }
        /// <p>Provides a unique identifier for the <code>Result</code>.</p>
        pub fn set_result_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.result_id = input;
            self
        }
        /// <p>The start time, in milliseconds, of the <code>Result</code>.</p>
        pub fn start_time(mut self, input: f64) -> Self {
            self.start_time = Some(input);
            self
        }
        /// <p>The start time, in milliseconds, of the <code>Result</code>.</p>
        pub fn set_start_time(mut self, input: std::option::Option<f64>) -> Self {
            self.start_time = input;
            self
        }
        /// <p>The end time, in milliseconds, of the <code>Result</code>.</p>
        pub fn end_time(mut self, input: f64) -> Self {
            self.end_time = Some(input);
            self
        }
        /// <p>The end time, in milliseconds, of the <code>Result</code>.</p>
        pub fn set_end_time(mut self, input: std::option::Option<f64>) -> Self {
            self.end_time = input;
            self
        }
        /// <p>Indicates if the segment is complete.</p>
        /// <p>If <code>IsPartial</code> is <code>true</code>, the segment is not complete. If <code>IsPartial</code> is <code>false</code>, the segment is complete.</p>
        pub fn is_partial(mut self, input: bool) -> Self {
            self.is_partial = Some(input);
            self
        }
        /// <p>Indicates if the segment is complete.</p>
        /// <p>If <code>IsPartial</code> is <code>true</code>, the segment is not complete. If <code>IsPartial</code> is <code>false</code>, the segment is complete.</p>
        pub fn set_is_partial(mut self, input: std::option::Option<bool>) -> Self {
            self.is_partial = input;
            self
        }
        /// Appends an item to `alternatives`.
        ///
        /// To override the contents of this collection use [`set_alternatives`](Self::set_alternatives).
        ///
        /// <p>A list of possible alternative transcriptions for the input audio. Each alternative may contain one or more of <code>Items</code>, <code>Entities</code>, or <code>Transcript</code>.</p>
        pub fn alternatives(mut self, input: crate::model::MedicalAlternative) -> Self {
            let mut v = self.alternatives.unwrap_or_default();
            v.push(input);
            self.alternatives = Some(v);
            self
        }
        /// <p>A list of possible alternative transcriptions for the input audio. Each alternative may contain one or more of <code>Items</code>, <code>Entities</code>, or <code>Transcript</code>.</p>
        pub fn set_alternatives(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::MedicalAlternative>>,
        ) -> Self {
            self.alternatives = input;
            self
        }
        /// <p>Indicates the channel identified for the <code>Result</code>.</p>
        pub fn channel_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.channel_id = Some(input.into());
            self
        }
        /// <p>Indicates the channel identified for the <code>Result</code>.</p>
        pub fn set_channel_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.channel_id = input;
            self
        }
        /// Consumes the builder and constructs a [`MedicalResult`](crate::model::MedicalResult).
        pub fn build(self) -> crate::model::MedicalResult {
            crate::model::MedicalResult {
                result_id: self.result_id,
                start_time: self.start_time.unwrap_or_default(),
                end_time: self.end_time.unwrap_or_default(),
                is_partial: self.is_partial.unwrap_or_default(),
                alternatives: self.alternatives,
                channel_id: self.channel_id,
            }
        }
    }
}
impl MedicalResult {
    /// Creates a new builder-style object to manufacture [`MedicalResult`](crate::model::MedicalResult).
    pub fn builder() -> crate::model::medical_result::Builder {
        crate::model::medical_result::Builder::default()
    }
}

/// <p>A list of possible alternative transcriptions for the input audio. Each alternative may contain one or more of <code>Items</code>, <code>Entities</code>, or <code>Transcript</code>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct MedicalAlternative {
    /// <p>Contains transcribed text.</p>
    #[doc(hidden)]
    pub transcript: std::option::Option<std::string::String>,
    /// <p>Contains words, phrases, or punctuation marks in your transcription output.</p>
    #[doc(hidden)]
    pub items: std::option::Option<std::vec::Vec<crate::model::MedicalItem>>,
    /// <p>Contains entities identified as personal health information (PHI) in your transcription output.</p>
    #[doc(hidden)]
    pub entities: std::option::Option<std::vec::Vec<crate::model::MedicalEntity>>,
}
impl MedicalAlternative {
    /// <p>Contains transcribed text.</p>
    pub fn transcript(&self) -> std::option::Option<&str> {
        self.transcript.as_deref()
    }
    /// <p>Contains words, phrases, or punctuation marks in your transcription output.</p>
    pub fn items(&self) -> std::option::Option<&[crate::model::MedicalItem]> {
        self.items.as_deref()
    }
    /// <p>Contains entities identified as personal health information (PHI) in your transcription output.</p>
    pub fn entities(&self) -> std::option::Option<&[crate::model::MedicalEntity]> {
        self.entities.as_deref()
    }
}
/// See [`MedicalAlternative`](crate::model::MedicalAlternative).
pub mod medical_alternative {

    /// A builder for [`MedicalAlternative`](crate::model::MedicalAlternative).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) transcript: std::option::Option<std::string::String>,
        pub(crate) items: std::option::Option<std::vec::Vec<crate::model::MedicalItem>>,
        pub(crate) entities: std::option::Option<std::vec::Vec<crate::model::MedicalEntity>>,
    }
    impl Builder {
        /// <p>Contains transcribed text.</p>
        pub fn transcript(mut self, input: impl Into<std::string::String>) -> Self {
            self.transcript = Some(input.into());
            self
        }
        /// <p>Contains transcribed text.</p>
        pub fn set_transcript(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.transcript = input;
            self
        }
        /// Appends an item to `items`.
        ///
        /// To override the contents of this collection use [`set_items`](Self::set_items).
        ///
        /// <p>Contains words, phrases, or punctuation marks in your transcription output.</p>
        pub fn items(mut self, input: crate::model::MedicalItem) -> Self {
            let mut v = self.items.unwrap_or_default();
            v.push(input);
            self.items = Some(v);
            self
        }
        /// <p>Contains words, phrases, or punctuation marks in your transcription output.</p>
        pub fn set_items(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::MedicalItem>>,
        ) -> Self {
            self.items = input;
            self
        }
        /// Appends an item to `entities`.
        ///
        /// To override the contents of this collection use [`set_entities`](Self::set_entities).
        ///
        /// <p>Contains entities identified as personal health information (PHI) in your transcription output.</p>
        pub fn entities(mut self, input: crate::model::MedicalEntity) -> Self {
            let mut v = self.entities.unwrap_or_default();
            v.push(input);
            self.entities = Some(v);
            self
        }
        /// <p>Contains entities identified as personal health information (PHI) in your transcription output.</p>
        pub fn set_entities(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::MedicalEntity>>,
        ) -> Self {
            self.entities = input;
            self
        }
        /// Consumes the builder and constructs a [`MedicalAlternative`](crate::model::MedicalAlternative).
        pub fn build(self) -> crate::model::MedicalAlternative {
            crate::model::MedicalAlternative {
                transcript: self.transcript,
                items: self.items,
                entities: self.entities,
            }
        }
    }
}
impl MedicalAlternative {
    /// Creates a new builder-style object to manufacture [`MedicalAlternative`](crate::model::MedicalAlternative).
    pub fn builder() -> crate::model::medical_alternative::Builder {
        crate::model::medical_alternative::Builder::default()
    }
}

/// <p>Contains entities identified as personal health information (PHI) in your transcription output, along with various associated attributes. Examples include category, confidence score, type, stability score, and start and end times.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct MedicalEntity {
    /// <p>The start time, in milliseconds, of the utterance that was identified as PHI.</p>
    #[doc(hidden)]
    pub start_time: f64,
    /// <p>The end time, in milliseconds, of the utterance that was identified as PHI.</p>
    #[doc(hidden)]
    pub end_time: f64,
    /// <p>The category of information identified. The only category is <code>PHI</code>.</p>
    #[doc(hidden)]
    pub category: std::option::Option<std::string::String>,
    /// <p>The word or words identified as PHI.</p>
    #[doc(hidden)]
    pub content: std::option::Option<std::string::String>,
    /// <p>The confidence score associated with the identified PHI entity in your audio.</p>
    /// <p>Confidence scores are values between 0 and 1. A larger value indicates a higher probability that the identified entity correctly matches the entity spoken in your media.</p>
    #[doc(hidden)]
    pub confidence: std::option::Option<f64>,
}
impl MedicalEntity {
    /// <p>The start time, in milliseconds, of the utterance that was identified as PHI.</p>
    pub fn start_time(&self) -> f64 {
        self.start_time
    }
    /// <p>The end time, in milliseconds, of the utterance that was identified as PHI.</p>
    pub fn end_time(&self) -> f64 {
        self.end_time
    }
    /// <p>The category of information identified. The only category is <code>PHI</code>.</p>
    pub fn category(&self) -> std::option::Option<&str> {
        self.category.as_deref()
    }
    /// <p>The word or words identified as PHI.</p>
    pub fn content(&self) -> std::option::Option<&str> {
        self.content.as_deref()
    }
    /// <p>The confidence score associated with the identified PHI entity in your audio.</p>
    /// <p>Confidence scores are values between 0 and 1. A larger value indicates a higher probability that the identified entity correctly matches the entity spoken in your media.</p>
    pub fn confidence(&self) -> std::option::Option<f64> {
        self.confidence
    }
}
/// See [`MedicalEntity`](crate::model::MedicalEntity).
pub mod medical_entity {

    /// A builder for [`MedicalEntity`](crate::model::MedicalEntity).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) start_time: std::option::Option<f64>,
        pub(crate) end_time: std::option::Option<f64>,
        pub(crate) category: std::option::Option<std::string::String>,
        pub(crate) content: std::option::Option<std::string::String>,
        pub(crate) confidence: std::option::Option<f64>,
    }
    impl Builder {
        /// <p>The start time, in milliseconds, of the utterance that was identified as PHI.</p>
        pub fn start_time(mut self, input: f64) -> Self {
            self.start_time = Some(input);
            self
        }
        /// <p>The start time, in milliseconds, of the utterance that was identified as PHI.</p>
        pub fn set_start_time(mut self, input: std::option::Option<f64>) -> Self {
            self.start_time = input;
            self
        }
        /// <p>The end time, in milliseconds, of the utterance that was identified as PHI.</p>
        pub fn end_time(mut self, input: f64) -> Self {
            self.end_time = Some(input);
            self
        }
        /// <p>The end time, in milliseconds, of the utterance that was identified as PHI.</p>
        pub fn set_end_time(mut self, input: std::option::Option<f64>) -> Self {
            self.end_time = input;
            self
        }
        /// <p>The category of information identified. The only category is <code>PHI</code>.</p>
        pub fn category(mut self, input: impl Into<std::string::String>) -> Self {
            self.category = Some(input.into());
            self
        }
        /// <p>The category of information identified. The only category is <code>PHI</code>.</p>
        pub fn set_category(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.category = input;
            self
        }
        /// <p>The word or words identified as PHI.</p>
        pub fn content(mut self, input: impl Into<std::string::String>) -> Self {
            self.content = Some(input.into());
            self
        }
        /// <p>The word or words identified as PHI.</p>
        pub fn set_content(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.content = input;
            self
        }
        /// <p>The confidence score associated with the identified PHI entity in your audio.</p>
        /// <p>Confidence scores are values between 0 and 1. A larger value indicates a higher probability that the identified entity correctly matches the entity spoken in your media.</p>
        pub fn confidence(mut self, input: f64) -> Self {
            self.confidence = Some(input);
            self
        }
        /// <p>The confidence score associated with the identified PHI entity in your audio.</p>
        /// <p>Confidence scores are values between 0 and 1. A larger value indicates a higher probability that the identified entity correctly matches the entity spoken in your media.</p>
        pub fn set_confidence(mut self, input: std::option::Option<f64>) -> Self {
            self.confidence = input;
            self
        }
        /// Consumes the builder and constructs a [`MedicalEntity`](crate::model::MedicalEntity).
        pub fn build(self) -> crate::model::MedicalEntity {
            crate::model::MedicalEntity {
                start_time: self.start_time.unwrap_or_default(),
                end_time: self.end_time.unwrap_or_default(),
                category: self.category,
                content: self.content,
                confidence: self.confidence,
            }
        }
    }
}
impl MedicalEntity {
    /// Creates a new builder-style object to manufacture [`MedicalEntity`](crate::model::MedicalEntity).
    pub fn builder() -> crate::model::medical_entity::Builder {
        crate::model::medical_entity::Builder::default()
    }
}

/// <p>A word, phrase, or punctuation mark in your transcription output, along with various associated attributes, such as confidence score, type, and start and end times.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct MedicalItem {
    /// <p>The start time, in milliseconds, of the transcribed item.</p>
    #[doc(hidden)]
    pub start_time: f64,
    /// <p>The end time, in milliseconds, of the transcribed item.</p>
    #[doc(hidden)]
    pub end_time: f64,
    /// <p>The type of item identified. Options are: <code>PRONUNCIATION</code> (spoken words) and <code>PUNCTUATION</code>.</p>
    #[doc(hidden)]
    pub r#type: std::option::Option<crate::model::ItemType>,
    /// <p>The word or punctuation that was transcribed.</p>
    #[doc(hidden)]
    pub content: std::option::Option<std::string::String>,
    /// <p>The confidence score associated with a word or phrase in your transcript.</p>
    /// <p>Confidence scores are values between 0 and 1. A larger value indicates a higher probability that the identified item correctly matches the item spoken in your media.</p>
    #[doc(hidden)]
    pub confidence: std::option::Option<f64>,
    /// <p>If speaker partitioning is enabled, <code>Speaker</code> labels the speaker of the specified item.</p>
    #[doc(hidden)]
    pub speaker: std::option::Option<std::string::String>,
}
impl MedicalItem {
    /// <p>The start time, in milliseconds, of the transcribed item.</p>
    pub fn start_time(&self) -> f64 {
        self.start_time
    }
    /// <p>The end time, in milliseconds, of the transcribed item.</p>
    pub fn end_time(&self) -> f64 {
        self.end_time
    }
    /// <p>The type of item identified. Options are: <code>PRONUNCIATION</code> (spoken words) and <code>PUNCTUATION</code>.</p>
    pub fn r#type(&self) -> std::option::Option<&crate::model::ItemType> {
        self.r#type.as_ref()
    }
    /// <p>The word or punctuation that was transcribed.</p>
    pub fn content(&self) -> std::option::Option<&str> {
        self.content.as_deref()
    }
    /// <p>The confidence score associated with a word or phrase in your transcript.</p>
    /// <p>Confidence scores are values between 0 and 1. A larger value indicates a higher probability that the identified item correctly matches the item spoken in your media.</p>
    pub fn confidence(&self) -> std::option::Option<f64> {
        self.confidence
    }
    /// <p>If speaker partitioning is enabled, <code>Speaker</code> labels the speaker of the specified item.</p>
    pub fn speaker(&self) -> std::option::Option<&str> {
        self.speaker.as_deref()
    }
}
/// See [`MedicalItem`](crate::model::MedicalItem).
pub mod medical_item {

    /// A builder for [`MedicalItem`](crate::model::MedicalItem).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) start_time: std::option::Option<f64>,
        pub(crate) end_time: std::option::Option<f64>,
        pub(crate) r#type: std::option::Option<crate::model::ItemType>,
        pub(crate) content: std::option::Option<std::string::String>,
        pub(crate) confidence: std::option::Option<f64>,
        pub(crate) speaker: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The start time, in milliseconds, of the transcribed item.</p>
        pub fn start_time(mut self, input: f64) -> Self {
            self.start_time = Some(input);
            self
        }
        /// <p>The start time, in milliseconds, of the transcribed item.</p>
        pub fn set_start_time(mut self, input: std::option::Option<f64>) -> Self {
            self.start_time = input;
            self
        }
        /// <p>The end time, in milliseconds, of the transcribed item.</p>
        pub fn end_time(mut self, input: f64) -> Self {
            self.end_time = Some(input);
            self
        }
        /// <p>The end time, in milliseconds, of the transcribed item.</p>
        pub fn set_end_time(mut self, input: std::option::Option<f64>) -> Self {
            self.end_time = input;
            self
        }
        /// <p>The type of item identified. Options are: <code>PRONUNCIATION</code> (spoken words) and <code>PUNCTUATION</code>.</p>
        pub fn r#type(mut self, input: crate::model::ItemType) -> Self {
            self.r#type = Some(input);
            self
        }
        /// <p>The type of item identified. Options are: <code>PRONUNCIATION</code> (spoken words) and <code>PUNCTUATION</code>.</p>
        pub fn set_type(mut self, input: std::option::Option<crate::model::ItemType>) -> Self {
            self.r#type = input;
            self
        }
        /// <p>The word or punctuation that was transcribed.</p>
        pub fn content(mut self, input: impl Into<std::string::String>) -> Self {
            self.content = Some(input.into());
            self
        }
        /// <p>The word or punctuation that was transcribed.</p>
        pub fn set_content(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.content = input;
            self
        }
        /// <p>The confidence score associated with a word or phrase in your transcript.</p>
        /// <p>Confidence scores are values between 0 and 1. A larger value indicates a higher probability that the identified item correctly matches the item spoken in your media.</p>
        pub fn confidence(mut self, input: f64) -> Self {
            self.confidence = Some(input);
            self
        }
        /// <p>The confidence score associated with a word or phrase in your transcript.</p>
        /// <p>Confidence scores are values between 0 and 1. A larger value indicates a higher probability that the identified item correctly matches the item spoken in your media.</p>
        pub fn set_confidence(mut self, input: std::option::Option<f64>) -> Self {
            self.confidence = input;
            self
        }
        /// <p>If speaker partitioning is enabled, <code>Speaker</code> labels the speaker of the specified item.</p>
        pub fn speaker(mut self, input: impl Into<std::string::String>) -> Self {
            self.speaker = Some(input.into());
            self
        }
        /// <p>If speaker partitioning is enabled, <code>Speaker</code> labels the speaker of the specified item.</p>
        pub fn set_speaker(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.speaker = input;
            self
        }
        /// Consumes the builder and constructs a [`MedicalItem`](crate::model::MedicalItem).
        pub fn build(self) -> crate::model::MedicalItem {
            crate::model::MedicalItem {
                start_time: self.start_time.unwrap_or_default(),
                end_time: self.end_time.unwrap_or_default(),
                r#type: self.r#type,
                content: self.content,
                confidence: self.confidence,
                speaker: self.speaker,
            }
        }
    }
}
impl MedicalItem {
    /// Creates a new builder-style object to manufacture [`MedicalItem`](crate::model::MedicalItem).
    pub fn builder() -> crate::model::medical_item::Builder {
        crate::model::medical_item::Builder::default()
    }
}

/// When writing a match expression against `Type`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let type = unimplemented!();
/// match type {
///     Type::Conversation => { /* ... */ },
///     Type::Dictation => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `type` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `Type::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `Type::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `Type::NewFeature` is defined.
/// Specifically, when `type` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `Type::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum Type {
    #[allow(missing_docs)] // documentation missing in model
    Conversation,
    #[allow(missing_docs)] // documentation missing in model
    Dictation,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for Type {
    fn from(s: &str) -> Self {
        match s {
            "CONVERSATION" => Type::Conversation,
            "DICTATION" => Type::Dictation,
            other => Type::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for Type {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(Type::from(s))
    }
}
impl Type {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            Type::Conversation => "CONVERSATION",
            Type::Dictation => "DICTATION",
            Type::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["CONVERSATION", "DICTATION"]
    }
}
impl AsRef<str> for Type {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `Specialty`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let specialty = unimplemented!();
/// match specialty {
///     Specialty::Cardiology => { /* ... */ },
///     Specialty::Neurology => { /* ... */ },
///     Specialty::Oncology => { /* ... */ },
///     Specialty::Primarycare => { /* ... */ },
///     Specialty::Radiology => { /* ... */ },
///     Specialty::Urology => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `specialty` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `Specialty::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `Specialty::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `Specialty::NewFeature` is defined.
/// Specifically, when `specialty` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `Specialty::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum Specialty {
    #[allow(missing_docs)] // documentation missing in model
    Cardiology,
    #[allow(missing_docs)] // documentation missing in model
    Neurology,
    #[allow(missing_docs)] // documentation missing in model
    Oncology,
    #[allow(missing_docs)] // documentation missing in model
    Primarycare,
    #[allow(missing_docs)] // documentation missing in model
    Radiology,
    #[allow(missing_docs)] // documentation missing in model
    Urology,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for Specialty {
    fn from(s: &str) -> Self {
        match s {
            "CARDIOLOGY" => Specialty::Cardiology,
            "NEUROLOGY" => Specialty::Neurology,
            "ONCOLOGY" => Specialty::Oncology,
            "PRIMARYCARE" => Specialty::Primarycare,
            "RADIOLOGY" => Specialty::Radiology,
            "UROLOGY" => Specialty::Urology,
            other => Specialty::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for Specialty {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(Specialty::from(s))
    }
}
impl Specialty {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            Specialty::Cardiology => "CARDIOLOGY",
            Specialty::Neurology => "NEUROLOGY",
            Specialty::Oncology => "ONCOLOGY",
            Specialty::Primarycare => "PRIMARYCARE",
            Specialty::Radiology => "RADIOLOGY",
            Specialty::Urology => "UROLOGY",
            Specialty::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "CARDIOLOGY",
            "NEUROLOGY",
            "ONCOLOGY",
            "PRIMARYCARE",
            "RADIOLOGY",
            "UROLOGY",
        ]
    }
}
impl AsRef<str> for Specialty {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Contains detailed information about your Call Analytics streaming session. These details are provided in the <code>UtteranceEvent</code> and <code>CategoryEvent</code> objects.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub enum CallAnalyticsTranscriptResultStream {
    /// <p>Provides information on matched categories that were used to generate real-time supervisor alerts.</p>
    CategoryEvent(crate::model::CategoryEvent),
    /// <p>Contains set of transcription results from one or more audio segments, along with additional information per your request parameters. This can include information relating to channel definitions, partial result stabilization, sentiment, issue detection, and other transcription-related data.</p>
    UtteranceEvent(crate::model::UtteranceEvent),
    /// The `Unknown` variant represents cases where new union variant was received. Consider upgrading the SDK to the latest available version.
    /// An unknown enum variant
    ///
    /// _Note: If you encounter this error, consider upgrading your SDK to the latest version._
    /// The `Unknown` variant represents cases where the server sent a value that wasn't recognized
    /// by the client. This can happen when the server adds new functionality, but the client has not been updated.
    /// To investigate this, consider turning on debug logging to print the raw HTTP response.
    #[non_exhaustive]
    Unknown,
}
impl CallAnalyticsTranscriptResultStream {
    /// Tries to convert the enum instance into [`CategoryEvent`](crate::model::CallAnalyticsTranscriptResultStream::CategoryEvent), extracting the inner [`CategoryEvent`](crate::model::CategoryEvent).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_category_event(&self) -> std::result::Result<&crate::model::CategoryEvent, &Self> {
        if let CallAnalyticsTranscriptResultStream::CategoryEvent(val) = &self {
            Ok(val)
        } else {
            Err(self)
        }
    }
    /// Returns true if this is a [`CategoryEvent`](crate::model::CallAnalyticsTranscriptResultStream::CategoryEvent).
    pub fn is_category_event(&self) -> bool {
        self.as_category_event().is_ok()
    }
    /// Tries to convert the enum instance into [`UtteranceEvent`](crate::model::CallAnalyticsTranscriptResultStream::UtteranceEvent), extracting the inner [`UtteranceEvent`](crate::model::UtteranceEvent).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_utterance_event(&self) -> std::result::Result<&crate::model::UtteranceEvent, &Self> {
        if let CallAnalyticsTranscriptResultStream::UtteranceEvent(val) = &self {
            Ok(val)
        } else {
            Err(self)
        }
    }
    /// Returns true if this is a [`UtteranceEvent`](crate::model::CallAnalyticsTranscriptResultStream::UtteranceEvent).
    pub fn is_utterance_event(&self) -> bool {
        self.as_utterance_event().is_ok()
    }
    /// Returns true if the enum instance is the `Unknown` variant.
    pub fn is_unknown(&self) -> bool {
        matches!(self, Self::Unknown)
    }
}

/// <p>Provides information on any <code>TranscriptFilterType</code> categories that matched your transcription output. Matches are identified for each segment upon completion of that segment.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CategoryEvent {
    /// <p>Lists the categories that were matched in your audio segment.</p>
    #[doc(hidden)]
    pub matched_categories: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>Contains information about the matched categories, including category names and timestamps.</p>
    #[doc(hidden)]
    pub matched_details: std::option::Option<
        std::collections::HashMap<std::string::String, crate::model::PointsOfInterest>,
    >,
}
impl CategoryEvent {
    /// <p>Lists the categories that were matched in your audio segment.</p>
    pub fn matched_categories(&self) -> std::option::Option<&[std::string::String]> {
        self.matched_categories.as_deref()
    }
    /// <p>Contains information about the matched categories, including category names and timestamps.</p>
    pub fn matched_details(
        &self,
    ) -> std::option::Option<
        &std::collections::HashMap<std::string::String, crate::model::PointsOfInterest>,
    > {
        self.matched_details.as_ref()
    }
}
/// See [`CategoryEvent`](crate::model::CategoryEvent).
pub mod category_event {

    /// A builder for [`CategoryEvent`](crate::model::CategoryEvent).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) matched_categories: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) matched_details: std::option::Option<
            std::collections::HashMap<std::string::String, crate::model::PointsOfInterest>,
        >,
    }
    impl Builder {
        /// Appends an item to `matched_categories`.
        ///
        /// To override the contents of this collection use [`set_matched_categories`](Self::set_matched_categories).
        ///
        /// <p>Lists the categories that were matched in your audio segment.</p>
        pub fn matched_categories(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.matched_categories.unwrap_or_default();
            v.push(input.into());
            self.matched_categories = Some(v);
            self
        }
        /// <p>Lists the categories that were matched in your audio segment.</p>
        pub fn set_matched_categories(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.matched_categories = input;
            self
        }
        /// Adds a key-value pair to `matched_details`.
        ///
        /// To override the contents of this collection use [`set_matched_details`](Self::set_matched_details).
        ///
        /// <p>Contains information about the matched categories, including category names and timestamps.</p>
        pub fn matched_details(
            mut self,
            k: impl Into<std::string::String>,
            v: crate::model::PointsOfInterest,
        ) -> Self {
            let mut hash_map = self.matched_details.unwrap_or_default();
            hash_map.insert(k.into(), v);
            self.matched_details = Some(hash_map);
            self
        }
        /// <p>Contains information about the matched categories, including category names and timestamps.</p>
        pub fn set_matched_details(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, crate::model::PointsOfInterest>,
            >,
        ) -> Self {
            self.matched_details = input;
            self
        }
        /// Consumes the builder and constructs a [`CategoryEvent`](crate::model::CategoryEvent).
        pub fn build(self) -> crate::model::CategoryEvent {
            crate::model::CategoryEvent {
                matched_categories: self.matched_categories,
                matched_details: self.matched_details,
            }
        }
    }
}
impl CategoryEvent {
    /// Creates a new builder-style object to manufacture [`CategoryEvent`](crate::model::CategoryEvent).
    pub fn builder() -> crate::model::category_event::Builder {
        crate::model::category_event::Builder::default()
    }
}

/// <p>Contains the timestamps of matched categories.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct PointsOfInterest {
    /// <p>Contains the timestamp ranges (start time through end time) of matched categories and rules.</p>
    #[doc(hidden)]
    pub timestamp_ranges: std::option::Option<std::vec::Vec<crate::model::TimestampRange>>,
}
impl PointsOfInterest {
    /// <p>Contains the timestamp ranges (start time through end time) of matched categories and rules.</p>
    pub fn timestamp_ranges(&self) -> std::option::Option<&[crate::model::TimestampRange]> {
        self.timestamp_ranges.as_deref()
    }
}
/// See [`PointsOfInterest`](crate::model::PointsOfInterest).
pub mod points_of_interest {

    /// A builder for [`PointsOfInterest`](crate::model::PointsOfInterest).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) timestamp_ranges:
            std::option::Option<std::vec::Vec<crate::model::TimestampRange>>,
    }
    impl Builder {
        /// Appends an item to `timestamp_ranges`.
        ///
        /// To override the contents of this collection use [`set_timestamp_ranges`](Self::set_timestamp_ranges).
        ///
        /// <p>Contains the timestamp ranges (start time through end time) of matched categories and rules.</p>
        pub fn timestamp_ranges(mut self, input: crate::model::TimestampRange) -> Self {
            let mut v = self.timestamp_ranges.unwrap_or_default();
            v.push(input);
            self.timestamp_ranges = Some(v);
            self
        }
        /// <p>Contains the timestamp ranges (start time through end time) of matched categories and rules.</p>
        pub fn set_timestamp_ranges(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::TimestampRange>>,
        ) -> Self {
            self.timestamp_ranges = input;
            self
        }
        /// Consumes the builder and constructs a [`PointsOfInterest`](crate::model::PointsOfInterest).
        pub fn build(self) -> crate::model::PointsOfInterest {
            crate::model::PointsOfInterest {
                timestamp_ranges: self.timestamp_ranges,
            }
        }
    }
}
impl PointsOfInterest {
    /// Creates a new builder-style object to manufacture [`PointsOfInterest`](crate::model::PointsOfInterest).
    pub fn builder() -> crate::model::points_of_interest::Builder {
        crate::model::points_of_interest::Builder::default()
    }
}

/// <p>Contains the timestamp range (start time through end time) of a matched category.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TimestampRange {
    /// <p>The time, in milliseconds, from the beginning of the audio stream to the start of the category match.</p>
    #[doc(hidden)]
    pub begin_offset_millis: std::option::Option<i64>,
    /// <p>The time, in milliseconds, from the beginning of the audio stream to the end of the category match.</p>
    #[doc(hidden)]
    pub end_offset_millis: std::option::Option<i64>,
}
impl TimestampRange {
    /// <p>The time, in milliseconds, from the beginning of the audio stream to the start of the category match.</p>
    pub fn begin_offset_millis(&self) -> std::option::Option<i64> {
        self.begin_offset_millis
    }
    /// <p>The time, in milliseconds, from the beginning of the audio stream to the end of the category match.</p>
    pub fn end_offset_millis(&self) -> std::option::Option<i64> {
        self.end_offset_millis
    }
}
/// See [`TimestampRange`](crate::model::TimestampRange).
pub mod timestamp_range {

    /// A builder for [`TimestampRange`](crate::model::TimestampRange).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) begin_offset_millis: std::option::Option<i64>,
        pub(crate) end_offset_millis: std::option::Option<i64>,
    }
    impl Builder {
        /// <p>The time, in milliseconds, from the beginning of the audio stream to the start of the category match.</p>
        pub fn begin_offset_millis(mut self, input: i64) -> Self {
            self.begin_offset_millis = Some(input);
            self
        }
        /// <p>The time, in milliseconds, from the beginning of the audio stream to the start of the category match.</p>
        pub fn set_begin_offset_millis(mut self, input: std::option::Option<i64>) -> Self {
            self.begin_offset_millis = input;
            self
        }
        /// <p>The time, in milliseconds, from the beginning of the audio stream to the end of the category match.</p>
        pub fn end_offset_millis(mut self, input: i64) -> Self {
            self.end_offset_millis = Some(input);
            self
        }
        /// <p>The time, in milliseconds, from the beginning of the audio stream to the end of the category match.</p>
        pub fn set_end_offset_millis(mut self, input: std::option::Option<i64>) -> Self {
            self.end_offset_millis = input;
            self
        }
        /// Consumes the builder and constructs a [`TimestampRange`](crate::model::TimestampRange).
        pub fn build(self) -> crate::model::TimestampRange {
            crate::model::TimestampRange {
                begin_offset_millis: self.begin_offset_millis,
                end_offset_millis: self.end_offset_millis,
            }
        }
    }
}
impl TimestampRange {
    /// Creates a new builder-style object to manufacture [`TimestampRange`](crate::model::TimestampRange).
    pub fn builder() -> crate::model::timestamp_range::Builder {
        crate::model::timestamp_range::Builder::default()
    }
}

/// <p>Contains set of transcription results from one or more audio segments, along with additional information about the parameters included in your request. For example, channel definitions, partial result stabilization, sentiment, and issue detection.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct UtteranceEvent {
    /// <p>The unique identifier that is associated with the specified <code>UtteranceEvent</code>.</p>
    #[doc(hidden)]
    pub utterance_id: std::option::Option<std::string::String>,
    /// <p>Indicates whether the segment in the <code>UtteranceEvent</code> is complete (<code>FALSE</code>) or partial (<code>TRUE</code>).</p>
    #[doc(hidden)]
    pub is_partial: bool,
    /// <p>Provides the role of the speaker for each audio channel, either <code>CUSTOMER</code> or <code>AGENT</code>.</p>
    #[doc(hidden)]
    pub participant_role: std::option::Option<crate::model::ParticipantRole>,
    /// <p>The time, in milliseconds, from the beginning of the audio stream to the start of the <code>UtteranceEvent</code>.</p>
    #[doc(hidden)]
    pub begin_offset_millis: std::option::Option<i64>,
    /// <p>The time, in milliseconds, from the beginning of the audio stream to the start of the <code>UtteranceEvent</code>.</p>
    #[doc(hidden)]
    pub end_offset_millis: std::option::Option<i64>,
    /// <p>Contains transcribed text.</p>
    #[doc(hidden)]
    pub transcript: std::option::Option<std::string::String>,
    /// <p>Contains words, phrases, or punctuation marks that are associated with the specified <code>UtteranceEvent</code>.</p>
    #[doc(hidden)]
    pub items: std::option::Option<std::vec::Vec<crate::model::CallAnalyticsItem>>,
    /// <p>Contains entities identified as personally identifiable information (PII) in your transcription output.</p>
    #[doc(hidden)]
    pub entities: std::option::Option<std::vec::Vec<crate::model::CallAnalyticsEntity>>,
    /// <p>Provides the sentiment that was detected in the specified segment.</p>
    #[doc(hidden)]
    pub sentiment: std::option::Option<crate::model::Sentiment>,
    /// <p>Provides the issue that was detected in the specified segment.</p>
    #[doc(hidden)]
    pub issues_detected: std::option::Option<std::vec::Vec<crate::model::IssueDetected>>,
}
impl UtteranceEvent {
    /// <p>The unique identifier that is associated with the specified <code>UtteranceEvent</code>.</p>
    pub fn utterance_id(&self) -> std::option::Option<&str> {
        self.utterance_id.as_deref()
    }
    /// <p>Indicates whether the segment in the <code>UtteranceEvent</code> is complete (<code>FALSE</code>) or partial (<code>TRUE</code>).</p>
    pub fn is_partial(&self) -> bool {
        self.is_partial
    }
    /// <p>Provides the role of the speaker for each audio channel, either <code>CUSTOMER</code> or <code>AGENT</code>.</p>
    pub fn participant_role(&self) -> std::option::Option<&crate::model::ParticipantRole> {
        self.participant_role.as_ref()
    }
    /// <p>The time, in milliseconds, from the beginning of the audio stream to the start of the <code>UtteranceEvent</code>.</p>
    pub fn begin_offset_millis(&self) -> std::option::Option<i64> {
        self.begin_offset_millis
    }
    /// <p>The time, in milliseconds, from the beginning of the audio stream to the start of the <code>UtteranceEvent</code>.</p>
    pub fn end_offset_millis(&self) -> std::option::Option<i64> {
        self.end_offset_millis
    }
    /// <p>Contains transcribed text.</p>
    pub fn transcript(&self) -> std::option::Option<&str> {
        self.transcript.as_deref()
    }
    /// <p>Contains words, phrases, or punctuation marks that are associated with the specified <code>UtteranceEvent</code>.</p>
    pub fn items(&self) -> std::option::Option<&[crate::model::CallAnalyticsItem]> {
        self.items.as_deref()
    }
    /// <p>Contains entities identified as personally identifiable information (PII) in your transcription output.</p>
    pub fn entities(&self) -> std::option::Option<&[crate::model::CallAnalyticsEntity]> {
        self.entities.as_deref()
    }
    /// <p>Provides the sentiment that was detected in the specified segment.</p>
    pub fn sentiment(&self) -> std::option::Option<&crate::model::Sentiment> {
        self.sentiment.as_ref()
    }
    /// <p>Provides the issue that was detected in the specified segment.</p>
    pub fn issues_detected(&self) -> std::option::Option<&[crate::model::IssueDetected]> {
        self.issues_detected.as_deref()
    }
}
/// See [`UtteranceEvent`](crate::model::UtteranceEvent).
pub mod utterance_event {

    /// A builder for [`UtteranceEvent`](crate::model::UtteranceEvent).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) utterance_id: std::option::Option<std::string::String>,
        pub(crate) is_partial: std::option::Option<bool>,
        pub(crate) participant_role: std::option::Option<crate::model::ParticipantRole>,
        pub(crate) begin_offset_millis: std::option::Option<i64>,
        pub(crate) end_offset_millis: std::option::Option<i64>,
        pub(crate) transcript: std::option::Option<std::string::String>,
        pub(crate) items: std::option::Option<std::vec::Vec<crate::model::CallAnalyticsItem>>,
        pub(crate) entities: std::option::Option<std::vec::Vec<crate::model::CallAnalyticsEntity>>,
        pub(crate) sentiment: std::option::Option<crate::model::Sentiment>,
        pub(crate) issues_detected: std::option::Option<std::vec::Vec<crate::model::IssueDetected>>,
    }
    impl Builder {
        /// <p>The unique identifier that is associated with the specified <code>UtteranceEvent</code>.</p>
        pub fn utterance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.utterance_id = Some(input.into());
            self
        }
        /// <p>The unique identifier that is associated with the specified <code>UtteranceEvent</code>.</p>
        pub fn set_utterance_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.utterance_id = input;
            self
        }
        /// <p>Indicates whether the segment in the <code>UtteranceEvent</code> is complete (<code>FALSE</code>) or partial (<code>TRUE</code>).</p>
        pub fn is_partial(mut self, input: bool) -> Self {
            self.is_partial = Some(input);
            self
        }
        /// <p>Indicates whether the segment in the <code>UtteranceEvent</code> is complete (<code>FALSE</code>) or partial (<code>TRUE</code>).</p>
        pub fn set_is_partial(mut self, input: std::option::Option<bool>) -> Self {
            self.is_partial = input;
            self
        }
        /// <p>Provides the role of the speaker for each audio channel, either <code>CUSTOMER</code> or <code>AGENT</code>.</p>
        pub fn participant_role(mut self, input: crate::model::ParticipantRole) -> Self {
            self.participant_role = Some(input);
            self
        }
        /// <p>Provides the role of the speaker for each audio channel, either <code>CUSTOMER</code> or <code>AGENT</code>.</p>
        pub fn set_participant_role(
            mut self,
            input: std::option::Option<crate::model::ParticipantRole>,
        ) -> Self {
            self.participant_role = input;
            self
        }
        /// <p>The time, in milliseconds, from the beginning of the audio stream to the start of the <code>UtteranceEvent</code>.</p>
        pub fn begin_offset_millis(mut self, input: i64) -> Self {
            self.begin_offset_millis = Some(input);
            self
        }
        /// <p>The time, in milliseconds, from the beginning of the audio stream to the start of the <code>UtteranceEvent</code>.</p>
        pub fn set_begin_offset_millis(mut self, input: std::option::Option<i64>) -> Self {
            self.begin_offset_millis = input;
            self
        }
        /// <p>The time, in milliseconds, from the beginning of the audio stream to the start of the <code>UtteranceEvent</code>.</p>
        pub fn end_offset_millis(mut self, input: i64) -> Self {
            self.end_offset_millis = Some(input);
            self
        }
        /// <p>The time, in milliseconds, from the beginning of the audio stream to the start of the <code>UtteranceEvent</code>.</p>
        pub fn set_end_offset_millis(mut self, input: std::option::Option<i64>) -> Self {
            self.end_offset_millis = input;
            self
        }
        /// <p>Contains transcribed text.</p>
        pub fn transcript(mut self, input: impl Into<std::string::String>) -> Self {
            self.transcript = Some(input.into());
            self
        }
        /// <p>Contains transcribed text.</p>
        pub fn set_transcript(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.transcript = input;
            self
        }
        /// Appends an item to `items`.
        ///
        /// To override the contents of this collection use [`set_items`](Self::set_items).
        ///
        /// <p>Contains words, phrases, or punctuation marks that are associated with the specified <code>UtteranceEvent</code>.</p>
        pub fn items(mut self, input: crate::model::CallAnalyticsItem) -> Self {
            let mut v = self.items.unwrap_or_default();
            v.push(input);
            self.items = Some(v);
            self
        }
        /// <p>Contains words, phrases, or punctuation marks that are associated with the specified <code>UtteranceEvent</code>.</p>
        pub fn set_items(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::CallAnalyticsItem>>,
        ) -> Self {
            self.items = input;
            self
        }
        /// Appends an item to `entities`.
        ///
        /// To override the contents of this collection use [`set_entities`](Self::set_entities).
        ///
        /// <p>Contains entities identified as personally identifiable information (PII) in your transcription output.</p>
        pub fn entities(mut self, input: crate::model::CallAnalyticsEntity) -> Self {
            let mut v = self.entities.unwrap_or_default();
            v.push(input);
            self.entities = Some(v);
            self
        }
        /// <p>Contains entities identified as personally identifiable information (PII) in your transcription output.</p>
        pub fn set_entities(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::CallAnalyticsEntity>>,
        ) -> Self {
            self.entities = input;
            self
        }
        /// <p>Provides the sentiment that was detected in the specified segment.</p>
        pub fn sentiment(mut self, input: crate::model::Sentiment) -> Self {
            self.sentiment = Some(input);
            self
        }
        /// <p>Provides the sentiment that was detected in the specified segment.</p>
        pub fn set_sentiment(
            mut self,
            input: std::option::Option<crate::model::Sentiment>,
        ) -> Self {
            self.sentiment = input;
            self
        }
        /// Appends an item to `issues_detected`.
        ///
        /// To override the contents of this collection use [`set_issues_detected`](Self::set_issues_detected).
        ///
        /// <p>Provides the issue that was detected in the specified segment.</p>
        pub fn issues_detected(mut self, input: crate::model::IssueDetected) -> Self {
            let mut v = self.issues_detected.unwrap_or_default();
            v.push(input);
            self.issues_detected = Some(v);
            self
        }
        /// <p>Provides the issue that was detected in the specified segment.</p>
        pub fn set_issues_detected(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::IssueDetected>>,
        ) -> Self {
            self.issues_detected = input;
            self
        }
        /// Consumes the builder and constructs a [`UtteranceEvent`](crate::model::UtteranceEvent).
        pub fn build(self) -> crate::model::UtteranceEvent {
            crate::model::UtteranceEvent {
                utterance_id: self.utterance_id,
                is_partial: self.is_partial.unwrap_or_default(),
                participant_role: self.participant_role,
                begin_offset_millis: self.begin_offset_millis,
                end_offset_millis: self.end_offset_millis,
                transcript: self.transcript,
                items: self.items,
                entities: self.entities,
                sentiment: self.sentiment,
                issues_detected: self.issues_detected,
            }
        }
    }
}
impl UtteranceEvent {
    /// Creates a new builder-style object to manufacture [`UtteranceEvent`](crate::model::UtteranceEvent).
    pub fn builder() -> crate::model::utterance_event::Builder {
        crate::model::utterance_event::Builder::default()
    }
}

/// <p>Lists the issues that were identified in your audio segment.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct IssueDetected {
    /// <p>Provides the timestamps that identify when in an audio segment the specified issue occurs.</p>
    #[doc(hidden)]
    pub character_offsets: std::option::Option<crate::model::CharacterOffsets>,
}
impl IssueDetected {
    /// <p>Provides the timestamps that identify when in an audio segment the specified issue occurs.</p>
    pub fn character_offsets(&self) -> std::option::Option<&crate::model::CharacterOffsets> {
        self.character_offsets.as_ref()
    }
}
/// See [`IssueDetected`](crate::model::IssueDetected).
pub mod issue_detected {

    /// A builder for [`IssueDetected`](crate::model::IssueDetected).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) character_offsets: std::option::Option<crate::model::CharacterOffsets>,
    }
    impl Builder {
        /// <p>Provides the timestamps that identify when in an audio segment the specified issue occurs.</p>
        pub fn character_offsets(mut self, input: crate::model::CharacterOffsets) -> Self {
            self.character_offsets = Some(input);
            self
        }
        /// <p>Provides the timestamps that identify when in an audio segment the specified issue occurs.</p>
        pub fn set_character_offsets(
            mut self,
            input: std::option::Option<crate::model::CharacterOffsets>,
        ) -> Self {
            self.character_offsets = input;
            self
        }
        /// Consumes the builder and constructs a [`IssueDetected`](crate::model::IssueDetected).
        pub fn build(self) -> crate::model::IssueDetected {
            crate::model::IssueDetected {
                character_offsets: self.character_offsets,
            }
        }
    }
}
impl IssueDetected {
    /// Creates a new builder-style object to manufacture [`IssueDetected`](crate::model::IssueDetected).
    pub fn builder() -> crate::model::issue_detected::Builder {
        crate::model::issue_detected::Builder::default()
    }
}

/// <p>Provides the location, using character count, in your transcript where a match is identified. For example, the location of an issue or a category match within a segment.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CharacterOffsets {
    /// <p>Provides the character count of the first character where a match is identified. For example, the first character associated with an issue or a category match in a segment transcript.</p>
    #[doc(hidden)]
    pub begin: std::option::Option<i32>,
    /// <p>Provides the character count of the last character where a match is identified. For example, the last character associated with an issue or a category match in a segment transcript.</p>
    #[doc(hidden)]
    pub end: std::option::Option<i32>,
}
impl CharacterOffsets {
    /// <p>Provides the character count of the first character where a match is identified. For example, the first character associated with an issue or a category match in a segment transcript.</p>
    pub fn begin(&self) -> std::option::Option<i32> {
        self.begin
    }
    /// <p>Provides the character count of the last character where a match is identified. For example, the last character associated with an issue or a category match in a segment transcript.</p>
    pub fn end(&self) -> std::option::Option<i32> {
        self.end
    }
}
/// See [`CharacterOffsets`](crate::model::CharacterOffsets).
pub mod character_offsets {

    /// A builder for [`CharacterOffsets`](crate::model::CharacterOffsets).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) begin: std::option::Option<i32>,
        pub(crate) end: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>Provides the character count of the first character where a match is identified. For example, the first character associated with an issue or a category match in a segment transcript.</p>
        pub fn begin(mut self, input: i32) -> Self {
            self.begin = Some(input);
            self
        }
        /// <p>Provides the character count of the first character where a match is identified. For example, the first character associated with an issue or a category match in a segment transcript.</p>
        pub fn set_begin(mut self, input: std::option::Option<i32>) -> Self {
            self.begin = input;
            self
        }
        /// <p>Provides the character count of the last character where a match is identified. For example, the last character associated with an issue or a category match in a segment transcript.</p>
        pub fn end(mut self, input: i32) -> Self {
            self.end = Some(input);
            self
        }
        /// <p>Provides the character count of the last character where a match is identified. For example, the last character associated with an issue or a category match in a segment transcript.</p>
        pub fn set_end(mut self, input: std::option::Option<i32>) -> Self {
            self.end = input;
            self
        }
        /// Consumes the builder and constructs a [`CharacterOffsets`](crate::model::CharacterOffsets).
        pub fn build(self) -> crate::model::CharacterOffsets {
            crate::model::CharacterOffsets {
                begin: self.begin,
                end: self.end,
            }
        }
    }
}
impl CharacterOffsets {
    /// Creates a new builder-style object to manufacture [`CharacterOffsets`](crate::model::CharacterOffsets).
    pub fn builder() -> crate::model::character_offsets::Builder {
        crate::model::character_offsets::Builder::default()
    }
}

/// When writing a match expression against `Sentiment`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let sentiment = unimplemented!();
/// match sentiment {
///     Sentiment::Mixed => { /* ... */ },
///     Sentiment::Negative => { /* ... */ },
///     Sentiment::Neutral => { /* ... */ },
///     Sentiment::Positive => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `sentiment` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `Sentiment::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `Sentiment::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `Sentiment::NewFeature` is defined.
/// Specifically, when `sentiment` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `Sentiment::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum Sentiment {
    #[allow(missing_docs)] // documentation missing in model
    Mixed,
    #[allow(missing_docs)] // documentation missing in model
    Negative,
    #[allow(missing_docs)] // documentation missing in model
    Neutral,
    #[allow(missing_docs)] // documentation missing in model
    Positive,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for Sentiment {
    fn from(s: &str) -> Self {
        match s {
            "MIXED" => Sentiment::Mixed,
            "NEGATIVE" => Sentiment::Negative,
            "NEUTRAL" => Sentiment::Neutral,
            "POSITIVE" => Sentiment::Positive,
            other => Sentiment::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for Sentiment {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(Sentiment::from(s))
    }
}
impl Sentiment {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            Sentiment::Mixed => "MIXED",
            Sentiment::Negative => "NEGATIVE",
            Sentiment::Neutral => "NEUTRAL",
            Sentiment::Positive => "POSITIVE",
            Sentiment::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["MIXED", "NEGATIVE", "NEUTRAL", "POSITIVE"]
    }
}
impl AsRef<str> for Sentiment {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Contains entities identified as personally identifiable information (PII) in your transcription output, along with various associated attributes. Examples include category, confidence score, content, type, and start and end times.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CallAnalyticsEntity {
    /// <p>The time, in milliseconds, from the beginning of the audio stream to the start of the identified entity.</p>
    #[doc(hidden)]
    pub begin_offset_millis: std::option::Option<i64>,
    /// <p>The time, in milliseconds, from the beginning of the audio stream to the end of the identified entity.</p>
    #[doc(hidden)]
    pub end_offset_millis: std::option::Option<i64>,
    /// <p>The category of information identified. For example, <code>PII</code>.</p>
    #[doc(hidden)]
    pub category: std::option::Option<std::string::String>,
    /// <p>The type of PII identified. For example, <code>NAME</code> or <code>CREDIT_DEBIT_NUMBER</code>.</p>
    #[doc(hidden)]
    pub r#type: std::option::Option<std::string::String>,
    /// <p>The word or words that represent the identified entity.</p>
    #[doc(hidden)]
    pub content: std::option::Option<std::string::String>,
    /// <p>The confidence score associated with the identification of an entity in your transcript.</p>
    /// <p>Confidence scores are values between 0 and 1. A larger value indicates a higher probability that the identified entity correctly matches the entity spoken in your media.</p>
    #[doc(hidden)]
    pub confidence: std::option::Option<f64>,
}
impl CallAnalyticsEntity {
    /// <p>The time, in milliseconds, from the beginning of the audio stream to the start of the identified entity.</p>
    pub fn begin_offset_millis(&self) -> std::option::Option<i64> {
        self.begin_offset_millis
    }
    /// <p>The time, in milliseconds, from the beginning of the audio stream to the end of the identified entity.</p>
    pub fn end_offset_millis(&self) -> std::option::Option<i64> {
        self.end_offset_millis
    }
    /// <p>The category of information identified. For example, <code>PII</code>.</p>
    pub fn category(&self) -> std::option::Option<&str> {
        self.category.as_deref()
    }
    /// <p>The type of PII identified. For example, <code>NAME</code> or <code>CREDIT_DEBIT_NUMBER</code>.</p>
    pub fn r#type(&self) -> std::option::Option<&str> {
        self.r#type.as_deref()
    }
    /// <p>The word or words that represent the identified entity.</p>
    pub fn content(&self) -> std::option::Option<&str> {
        self.content.as_deref()
    }
    /// <p>The confidence score associated with the identification of an entity in your transcript.</p>
    /// <p>Confidence scores are values between 0 and 1. A larger value indicates a higher probability that the identified entity correctly matches the entity spoken in your media.</p>
    pub fn confidence(&self) -> std::option::Option<f64> {
        self.confidence
    }
}
/// See [`CallAnalyticsEntity`](crate::model::CallAnalyticsEntity).
pub mod call_analytics_entity {

    /// A builder for [`CallAnalyticsEntity`](crate::model::CallAnalyticsEntity).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) begin_offset_millis: std::option::Option<i64>,
        pub(crate) end_offset_millis: std::option::Option<i64>,
        pub(crate) category: std::option::Option<std::string::String>,
        pub(crate) r#type: std::option::Option<std::string::String>,
        pub(crate) content: std::option::Option<std::string::String>,
        pub(crate) confidence: std::option::Option<f64>,
    }
    impl Builder {
        /// <p>The time, in milliseconds, from the beginning of the audio stream to the start of the identified entity.</p>
        pub fn begin_offset_millis(mut self, input: i64) -> Self {
            self.begin_offset_millis = Some(input);
            self
        }
        /// <p>The time, in milliseconds, from the beginning of the audio stream to the start of the identified entity.</p>
        pub fn set_begin_offset_millis(mut self, input: std::option::Option<i64>) -> Self {
            self.begin_offset_millis = input;
            self
        }
        /// <p>The time, in milliseconds, from the beginning of the audio stream to the end of the identified entity.</p>
        pub fn end_offset_millis(mut self, input: i64) -> Self {
            self.end_offset_millis = Some(input);
            self
        }
        /// <p>The time, in milliseconds, from the beginning of the audio stream to the end of the identified entity.</p>
        pub fn set_end_offset_millis(mut self, input: std::option::Option<i64>) -> Self {
            self.end_offset_millis = input;
            self
        }
        /// <p>The category of information identified. For example, <code>PII</code>.</p>
        pub fn category(mut self, input: impl Into<std::string::String>) -> Self {
            self.category = Some(input.into());
            self
        }
        /// <p>The category of information identified. For example, <code>PII</code>.</p>
        pub fn set_category(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.category = input;
            self
        }
        /// <p>The type of PII identified. For example, <code>NAME</code> or <code>CREDIT_DEBIT_NUMBER</code>.</p>
        pub fn r#type(mut self, input: impl Into<std::string::String>) -> Self {
            self.r#type = Some(input.into());
            self
        }
        /// <p>The type of PII identified. For example, <code>NAME</code> or <code>CREDIT_DEBIT_NUMBER</code>.</p>
        pub fn set_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.r#type = input;
            self
        }
        /// <p>The word or words that represent the identified entity.</p>
        pub fn content(mut self, input: impl Into<std::string::String>) -> Self {
            self.content = Some(input.into());
            self
        }
        /// <p>The word or words that represent the identified entity.</p>
        pub fn set_content(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.content = input;
            self
        }
        /// <p>The confidence score associated with the identification of an entity in your transcript.</p>
        /// <p>Confidence scores are values between 0 and 1. A larger value indicates a higher probability that the identified entity correctly matches the entity spoken in your media.</p>
        pub fn confidence(mut self, input: f64) -> Self {
            self.confidence = Some(input);
            self
        }
        /// <p>The confidence score associated with the identification of an entity in your transcript.</p>
        /// <p>Confidence scores are values between 0 and 1. A larger value indicates a higher probability that the identified entity correctly matches the entity spoken in your media.</p>
        pub fn set_confidence(mut self, input: std::option::Option<f64>) -> Self {
            self.confidence = input;
            self
        }
        /// Consumes the builder and constructs a [`CallAnalyticsEntity`](crate::model::CallAnalyticsEntity).
        pub fn build(self) -> crate::model::CallAnalyticsEntity {
            crate::model::CallAnalyticsEntity {
                begin_offset_millis: self.begin_offset_millis,
                end_offset_millis: self.end_offset_millis,
                category: self.category,
                r#type: self.r#type,
                content: self.content,
                confidence: self.confidence,
            }
        }
    }
}
impl CallAnalyticsEntity {
    /// Creates a new builder-style object to manufacture [`CallAnalyticsEntity`](crate::model::CallAnalyticsEntity).
    pub fn builder() -> crate::model::call_analytics_entity::Builder {
        crate::model::call_analytics_entity::Builder::default()
    }
}

/// <p>A word, phrase, or punctuation mark in your Call Analytics transcription output, along with various associated attributes, such as confidence score, type, and start and end times.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CallAnalyticsItem {
    /// <p>The time, in milliseconds, from the beginning of the audio stream to the start of the identified item.</p>
    #[doc(hidden)]
    pub begin_offset_millis: std::option::Option<i64>,
    /// <p>The time, in milliseconds, from the beginning of the audio stream to the end of the identified item.</p>
    #[doc(hidden)]
    pub end_offset_millis: std::option::Option<i64>,
    /// <p>The type of item identified. Options are: <code>PRONUNCIATION</code> (spoken words) and <code>PUNCTUATION</code>.</p>
    #[doc(hidden)]
    pub r#type: std::option::Option<crate::model::ItemType>,
    /// <p>The word or punctuation that was transcribed.</p>
    #[doc(hidden)]
    pub content: std::option::Option<std::string::String>,
    /// <p>The confidence score associated with a word or phrase in your transcript.</p>
    /// <p>Confidence scores are values between 0 and 1. A larger value indicates a higher probability that the identified item correctly matches the item spoken in your media.</p>
    #[doc(hidden)]
    pub confidence: std::option::Option<f64>,
    /// <p>Indicates whether the specified item matches a word in the vocabulary filter included in your Call Analytics request. If <code>true</code>, there is a vocabulary filter match.</p>
    #[doc(hidden)]
    pub vocabulary_filter_match: bool,
    /// <p>If partial result stabilization is enabled, <code>Stable</code> indicates whether the specified item is stable (<code>true</code>) or if it may change when the segment is complete (<code>false</code>).</p>
    #[doc(hidden)]
    pub stable: std::option::Option<bool>,
}
impl CallAnalyticsItem {
    /// <p>The time, in milliseconds, from the beginning of the audio stream to the start of the identified item.</p>
    pub fn begin_offset_millis(&self) -> std::option::Option<i64> {
        self.begin_offset_millis
    }
    /// <p>The time, in milliseconds, from the beginning of the audio stream to the end of the identified item.</p>
    pub fn end_offset_millis(&self) -> std::option::Option<i64> {
        self.end_offset_millis
    }
    /// <p>The type of item identified. Options are: <code>PRONUNCIATION</code> (spoken words) and <code>PUNCTUATION</code>.</p>
    pub fn r#type(&self) -> std::option::Option<&crate::model::ItemType> {
        self.r#type.as_ref()
    }
    /// <p>The word or punctuation that was transcribed.</p>
    pub fn content(&self) -> std::option::Option<&str> {
        self.content.as_deref()
    }
    /// <p>The confidence score associated with a word or phrase in your transcript.</p>
    /// <p>Confidence scores are values between 0 and 1. A larger value indicates a higher probability that the identified item correctly matches the item spoken in your media.</p>
    pub fn confidence(&self) -> std::option::Option<f64> {
        self.confidence
    }
    /// <p>Indicates whether the specified item matches a word in the vocabulary filter included in your Call Analytics request. If <code>true</code>, there is a vocabulary filter match.</p>
    pub fn vocabulary_filter_match(&self) -> bool {
        self.vocabulary_filter_match
    }
    /// <p>If partial result stabilization is enabled, <code>Stable</code> indicates whether the specified item is stable (<code>true</code>) or if it may change when the segment is complete (<code>false</code>).</p>
    pub fn stable(&self) -> std::option::Option<bool> {
        self.stable
    }
}
/// See [`CallAnalyticsItem`](crate::model::CallAnalyticsItem).
pub mod call_analytics_item {

    /// A builder for [`CallAnalyticsItem`](crate::model::CallAnalyticsItem).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) begin_offset_millis: std::option::Option<i64>,
        pub(crate) end_offset_millis: std::option::Option<i64>,
        pub(crate) r#type: std::option::Option<crate::model::ItemType>,
        pub(crate) content: std::option::Option<std::string::String>,
        pub(crate) confidence: std::option::Option<f64>,
        pub(crate) vocabulary_filter_match: std::option::Option<bool>,
        pub(crate) stable: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>The time, in milliseconds, from the beginning of the audio stream to the start of the identified item.</p>
        pub fn begin_offset_millis(mut self, input: i64) -> Self {
            self.begin_offset_millis = Some(input);
            self
        }
        /// <p>The time, in milliseconds, from the beginning of the audio stream to the start of the identified item.</p>
        pub fn set_begin_offset_millis(mut self, input: std::option::Option<i64>) -> Self {
            self.begin_offset_millis = input;
            self
        }
        /// <p>The time, in milliseconds, from the beginning of the audio stream to the end of the identified item.</p>
        pub fn end_offset_millis(mut self, input: i64) -> Self {
            self.end_offset_millis = Some(input);
            self
        }
        /// <p>The time, in milliseconds, from the beginning of the audio stream to the end of the identified item.</p>
        pub fn set_end_offset_millis(mut self, input: std::option::Option<i64>) -> Self {
            self.end_offset_millis = input;
            self
        }
        /// <p>The type of item identified. Options are: <code>PRONUNCIATION</code> (spoken words) and <code>PUNCTUATION</code>.</p>
        pub fn r#type(mut self, input: crate::model::ItemType) -> Self {
            self.r#type = Some(input);
            self
        }
        /// <p>The type of item identified. Options are: <code>PRONUNCIATION</code> (spoken words) and <code>PUNCTUATION</code>.</p>
        pub fn set_type(mut self, input: std::option::Option<crate::model::ItemType>) -> Self {
            self.r#type = input;
            self
        }
        /// <p>The word or punctuation that was transcribed.</p>
        pub fn content(mut self, input: impl Into<std::string::String>) -> Self {
            self.content = Some(input.into());
            self
        }
        /// <p>The word or punctuation that was transcribed.</p>
        pub fn set_content(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.content = input;
            self
        }
        /// <p>The confidence score associated with a word or phrase in your transcript.</p>
        /// <p>Confidence scores are values between 0 and 1. A larger value indicates a higher probability that the identified item correctly matches the item spoken in your media.</p>
        pub fn confidence(mut self, input: f64) -> Self {
            self.confidence = Some(input);
            self
        }
        /// <p>The confidence score associated with a word or phrase in your transcript.</p>
        /// <p>Confidence scores are values between 0 and 1. A larger value indicates a higher probability that the identified item correctly matches the item spoken in your media.</p>
        pub fn set_confidence(mut self, input: std::option::Option<f64>) -> Self {
            self.confidence = input;
            self
        }
        /// <p>Indicates whether the specified item matches a word in the vocabulary filter included in your Call Analytics request. If <code>true</code>, there is a vocabulary filter match.</p>
        pub fn vocabulary_filter_match(mut self, input: bool) -> Self {
            self.vocabulary_filter_match = Some(input);
            self
        }
        /// <p>Indicates whether the specified item matches a word in the vocabulary filter included in your Call Analytics request. If <code>true</code>, there is a vocabulary filter match.</p>
        pub fn set_vocabulary_filter_match(mut self, input: std::option::Option<bool>) -> Self {
            self.vocabulary_filter_match = input;
            self
        }
        /// <p>If partial result stabilization is enabled, <code>Stable</code> indicates whether the specified item is stable (<code>true</code>) or if it may change when the segment is complete (<code>false</code>).</p>
        pub fn stable(mut self, input: bool) -> Self {
            self.stable = Some(input);
            self
        }
        /// <p>If partial result stabilization is enabled, <code>Stable</code> indicates whether the specified item is stable (<code>true</code>) or if it may change when the segment is complete (<code>false</code>).</p>
        pub fn set_stable(mut self, input: std::option::Option<bool>) -> Self {
            self.stable = input;
            self
        }
        /// Consumes the builder and constructs a [`CallAnalyticsItem`](crate::model::CallAnalyticsItem).
        pub fn build(self) -> crate::model::CallAnalyticsItem {
            crate::model::CallAnalyticsItem {
                begin_offset_millis: self.begin_offset_millis,
                end_offset_millis: self.end_offset_millis,
                r#type: self.r#type,
                content: self.content,
                confidence: self.confidence,
                vocabulary_filter_match: self.vocabulary_filter_match.unwrap_or_default(),
                stable: self.stable,
            }
        }
    }
}
impl CallAnalyticsItem {
    /// Creates a new builder-style object to manufacture [`CallAnalyticsItem`](crate::model::CallAnalyticsItem).
    pub fn builder() -> crate::model::call_analytics_item::Builder {
        crate::model::call_analytics_item::Builder::default()
    }
}

/// When writing a match expression against `CallAnalyticsLanguageCode`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let callanalyticslanguagecode = unimplemented!();
/// match callanalyticslanguagecode {
///     CallAnalyticsLanguageCode::DeDe => { /* ... */ },
///     CallAnalyticsLanguageCode::EnAu => { /* ... */ },
///     CallAnalyticsLanguageCode::EnGb => { /* ... */ },
///     CallAnalyticsLanguageCode::EnUs => { /* ... */ },
///     CallAnalyticsLanguageCode::EsUs => { /* ... */ },
///     CallAnalyticsLanguageCode::FrCa => { /* ... */ },
///     CallAnalyticsLanguageCode::FrFr => { /* ... */ },
///     CallAnalyticsLanguageCode::ItIt => { /* ... */ },
///     CallAnalyticsLanguageCode::PtBr => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `callanalyticslanguagecode` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `CallAnalyticsLanguageCode::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `CallAnalyticsLanguageCode::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `CallAnalyticsLanguageCode::NewFeature` is defined.
/// Specifically, when `callanalyticslanguagecode` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `CallAnalyticsLanguageCode::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum CallAnalyticsLanguageCode {
    #[allow(missing_docs)] // documentation missing in model
    DeDe,
    #[allow(missing_docs)] // documentation missing in model
    EnAu,
    #[allow(missing_docs)] // documentation missing in model
    EnGb,
    #[allow(missing_docs)] // documentation missing in model
    EnUs,
    #[allow(missing_docs)] // documentation missing in model
    EsUs,
    #[allow(missing_docs)] // documentation missing in model
    FrCa,
    #[allow(missing_docs)] // documentation missing in model
    FrFr,
    #[allow(missing_docs)] // documentation missing in model
    ItIt,
    #[allow(missing_docs)] // documentation missing in model
    PtBr,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for CallAnalyticsLanguageCode {
    fn from(s: &str) -> Self {
        match s {
            "de-DE" => CallAnalyticsLanguageCode::DeDe,
            "en-AU" => CallAnalyticsLanguageCode::EnAu,
            "en-GB" => CallAnalyticsLanguageCode::EnGb,
            "en-US" => CallAnalyticsLanguageCode::EnUs,
            "es-US" => CallAnalyticsLanguageCode::EsUs,
            "fr-CA" => CallAnalyticsLanguageCode::FrCa,
            "fr-FR" => CallAnalyticsLanguageCode::FrFr,
            "it-IT" => CallAnalyticsLanguageCode::ItIt,
            "pt-BR" => CallAnalyticsLanguageCode::PtBr,
            other => CallAnalyticsLanguageCode::Unknown(crate::types::UnknownVariantValue(
                other.to_owned(),
            )),
        }
    }
}
impl std::str::FromStr for CallAnalyticsLanguageCode {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(CallAnalyticsLanguageCode::from(s))
    }
}
impl CallAnalyticsLanguageCode {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            CallAnalyticsLanguageCode::DeDe => "de-DE",
            CallAnalyticsLanguageCode::EnAu => "en-AU",
            CallAnalyticsLanguageCode::EnGb => "en-GB",
            CallAnalyticsLanguageCode::EnUs => "en-US",
            CallAnalyticsLanguageCode::EsUs => "es-US",
            CallAnalyticsLanguageCode::FrCa => "fr-CA",
            CallAnalyticsLanguageCode::FrFr => "fr-FR",
            CallAnalyticsLanguageCode::ItIt => "it-IT",
            CallAnalyticsLanguageCode::PtBr => "pt-BR",
            CallAnalyticsLanguageCode::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "de-DE", "en-AU", "en-GB", "en-US", "es-US", "fr-CA", "fr-FR", "it-IT", "pt-BR",
        ]
    }
}
impl AsRef<str> for CallAnalyticsLanguageCode {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}
