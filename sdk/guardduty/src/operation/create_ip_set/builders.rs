// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
pub use crate::operation::create_ip_set::_create_ip_set_output::CreateIpSetOutputBuilder;

pub use crate::operation::create_ip_set::_create_ip_set_input::CreateIpSetInputBuilder;

impl CreateIpSetInputBuilder {
    /// Sends a request with this input using the given client.
    pub async fn send_with(
        self,
        client: &crate::Client,
    ) -> ::std::result::Result<
        crate::operation::create_ip_set::CreateIpSetOutput,
        ::aws_smithy_runtime_api::client::result::SdkError<
            crate::operation::create_ip_set::CreateIPSetError,
            ::aws_smithy_runtime_api::client::orchestrator::HttpResponse,
        >,
    > {
        let mut fluent_builder = client.create_ip_set();
        fluent_builder.inner = self;
        fluent_builder.send().await
    }
}
/// Fluent builder constructing a request to `CreateIPSet`.
///
/// <p>Creates a new IPSet, which is called a trusted IP list in the console user interface. An IPSet is a list of IP addresses that are trusted for secure communication with Amazon Web Services infrastructure and applications. GuardDuty doesn't generate findings for IP addresses that are included in IPSets. Only users from the administrator account can use this operation.</p>
#[derive(::std::clone::Clone, ::std::fmt::Debug)]
pub struct CreateIPSetFluentBuilder {
    handle: ::std::sync::Arc<crate::client::Handle>,
    inner: crate::operation::create_ip_set::builders::CreateIpSetInputBuilder,
    config_override: ::std::option::Option<crate::config::Builder>,
}
impl
    crate::client::customize::internal::CustomizableSend<
        crate::operation::create_ip_set::CreateIpSetOutput,
        crate::operation::create_ip_set::CreateIPSetError,
    > for CreateIPSetFluentBuilder
{
    fn send(
        self,
        config_override: crate::config::Builder,
    ) -> crate::client::customize::internal::BoxFuture<
        crate::client::customize::internal::SendResult<
            crate::operation::create_ip_set::CreateIpSetOutput,
            crate::operation::create_ip_set::CreateIPSetError,
        >,
    > {
        ::std::boxed::Box::pin(async move { self.config_override(config_override).send().await })
    }
}
impl CreateIPSetFluentBuilder {
    /// Creates a new `CreateIPSet`.
    pub(crate) fn new(handle: ::std::sync::Arc<crate::client::Handle>) -> Self {
        Self {
            handle,
            inner: ::std::default::Default::default(),
            config_override: ::std::option::Option::None,
        }
    }
    /// Access the CreateIPSet as a reference.
    pub fn as_input(&self) -> &crate::operation::create_ip_set::builders::CreateIpSetInputBuilder {
        &self.inner
    }
    /// Sends the request and returns the response.
    ///
    /// If an error occurs, an `SdkError` will be returned with additional details that
    /// can be matched against.
    ///
    /// By default, any retryable failures will be retried twice. Retry behavior
    /// is configurable with the [RetryConfig](aws_smithy_types::retry::RetryConfig), which can be
    /// set when configuring the client.
    pub async fn send(
        self,
    ) -> ::std::result::Result<
        crate::operation::create_ip_set::CreateIpSetOutput,
        ::aws_smithy_runtime_api::client::result::SdkError<
            crate::operation::create_ip_set::CreateIPSetError,
            ::aws_smithy_runtime_api::client::orchestrator::HttpResponse,
        >,
    > {
        let input = self
            .inner
            .build()
            .map_err(::aws_smithy_runtime_api::client::result::SdkError::construction_failure)?;
        let runtime_plugins = crate::operation::create_ip_set::CreateIPSet::operation_runtime_plugins(
            self.handle.runtime_plugins.clone(),
            &self.handle.conf,
            self.config_override,
        );
        crate::operation::create_ip_set::CreateIPSet::orchestrate(&runtime_plugins, input).await
    }

    /// Consumes this builder, creating a customizable operation that can be modified before being sent.
    pub fn customize(
        self,
    ) -> crate::client::customize::CustomizableOperation<
        crate::operation::create_ip_set::CreateIpSetOutput,
        crate::operation::create_ip_set::CreateIPSetError,
        Self,
    > {
        crate::client::customize::CustomizableOperation::new(self)
    }
    pub(crate) fn config_override(mut self, config_override: impl Into<crate::config::Builder>) -> Self {
        self.set_config_override(Some(config_override.into()));
        self
    }

    pub(crate) fn set_config_override(&mut self, config_override: Option<crate::config::Builder>) -> &mut Self {
        self.config_override = config_override;
        self
    }
    /// <p>The unique ID of the detector of the GuardDuty account that you want to create an IPSet for.</p>
    pub fn detector_id(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.inner = self.inner.detector_id(input.into());
        self
    }
    /// <p>The unique ID of the detector of the GuardDuty account that you want to create an IPSet for.</p>
    pub fn set_detector_id(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.inner = self.inner.set_detector_id(input);
        self
    }
    /// <p>The unique ID of the detector of the GuardDuty account that you want to create an IPSet for.</p>
    pub fn get_detector_id(&self) -> &::std::option::Option<::std::string::String> {
        self.inner.get_detector_id()
    }
    /// <p>The user-friendly name to identify the IPSet.</p>
    /// <p>Allowed characters are alphanumeric, whitespace, dash (-), and underscores (_).</p>
    pub fn name(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.inner = self.inner.name(input.into());
        self
    }
    /// <p>The user-friendly name to identify the IPSet.</p>
    /// <p>Allowed characters are alphanumeric, whitespace, dash (-), and underscores (_).</p>
    pub fn set_name(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.inner = self.inner.set_name(input);
        self
    }
    /// <p>The user-friendly name to identify the IPSet.</p>
    /// <p>Allowed characters are alphanumeric, whitespace, dash (-), and underscores (_).</p>
    pub fn get_name(&self) -> &::std::option::Option<::std::string::String> {
        self.inner.get_name()
    }
    /// <p>The format of the file that contains the IPSet.</p>
    pub fn format(mut self, input: crate::types::IpSetFormat) -> Self {
        self.inner = self.inner.format(input);
        self
    }
    /// <p>The format of the file that contains the IPSet.</p>
    pub fn set_format(mut self, input: ::std::option::Option<crate::types::IpSetFormat>) -> Self {
        self.inner = self.inner.set_format(input);
        self
    }
    /// <p>The format of the file that contains the IPSet.</p>
    pub fn get_format(&self) -> &::std::option::Option<crate::types::IpSetFormat> {
        self.inner.get_format()
    }
    /// <p>The URI of the file that contains the IPSet.</p>
    pub fn location(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.inner = self.inner.location(input.into());
        self
    }
    /// <p>The URI of the file that contains the IPSet.</p>
    pub fn set_location(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.inner = self.inner.set_location(input);
        self
    }
    /// <p>The URI of the file that contains the IPSet.</p>
    pub fn get_location(&self) -> &::std::option::Option<::std::string::String> {
        self.inner.get_location()
    }
    /// <p>A Boolean value that indicates whether GuardDuty is to start using the uploaded IPSet.</p>
    pub fn activate(mut self, input: bool) -> Self {
        self.inner = self.inner.activate(input);
        self
    }
    /// <p>A Boolean value that indicates whether GuardDuty is to start using the uploaded IPSet.</p>
    pub fn set_activate(mut self, input: ::std::option::Option<bool>) -> Self {
        self.inner = self.inner.set_activate(input);
        self
    }
    /// <p>A Boolean value that indicates whether GuardDuty is to start using the uploaded IPSet.</p>
    pub fn get_activate(&self) -> &::std::option::Option<bool> {
        self.inner.get_activate()
    }
    /// <p>The idempotency token for the create request.</p>
    pub fn client_token(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.inner = self.inner.client_token(input.into());
        self
    }
    /// <p>The idempotency token for the create request.</p>
    pub fn set_client_token(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.inner = self.inner.set_client_token(input);
        self
    }
    /// <p>The idempotency token for the create request.</p>
    pub fn get_client_token(&self) -> &::std::option::Option<::std::string::String> {
        self.inner.get_client_token()
    }
    /// Adds a key-value pair to `Tags`.
    ///
    /// To override the contents of this collection use [`set_tags`](Self::set_tags).
    ///
    /// <p>The tags to be added to a new IP set resource.</p>
    pub fn tags(mut self, k: impl ::std::convert::Into<::std::string::String>, v: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.inner = self.inner.tags(k.into(), v.into());
        self
    }
    /// <p>The tags to be added to a new IP set resource.</p>
    pub fn set_tags(mut self, input: ::std::option::Option<::std::collections::HashMap<::std::string::String, ::std::string::String>>) -> Self {
        self.inner = self.inner.set_tags(input);
        self
    }
    /// <p>The tags to be added to a new IP set resource.</p>
    pub fn get_tags(&self) -> &::std::option::Option<::std::collections::HashMap<::std::string::String, ::std::string::String>> {
        self.inner.get_tags()
    }
}
