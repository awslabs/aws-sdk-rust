// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CreateFilterInput {
    /// <p>The ID of the detector belonging to the GuardDuty account that you want to create a filter for.</p>
    #[doc(hidden)]
    pub detector_id: std::option::Option<std::string::String>,
    /// <p>The name of the filter. Valid characters include period (.), underscore (_), dash (-), and alphanumeric characters. A whitespace is considered to be an invalid character.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The description of the filter. Valid special characters include period (.), underscore (_), dash (-), and whitespace. The new line character is considered to be an invalid input for description.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p>Specifies the action that is to be applied to the findings that match the filter.</p>
    #[doc(hidden)]
    pub action: std::option::Option<crate::types::FilterAction>,
    /// <p>Specifies the position of the filter in the list of current filters. Also specifies the order in which this filter is applied to the findings.</p>
    #[doc(hidden)]
    pub rank: i32,
    /// <p>Represents the criteria to be used in the filter for querying findings.</p>
    /// <p>You can only use the following attributes to query findings:</p>
    /// <ul>
    /// <li> <p>accountId</p> </li>
    /// <li> <p>region</p> </li>
    /// <li> <p>confidence</p> </li>
    /// <li> <p>id</p> </li>
    /// <li> <p>resource.accessKeyDetails.accessKeyId</p> </li>
    /// <li> <p>resource.accessKeyDetails.principalId</p> </li>
    /// <li> <p>resource.accessKeyDetails.userName</p> </li>
    /// <li> <p>resource.accessKeyDetails.userType</p> </li>
    /// <li> <p>resource.instanceDetails.iamInstanceProfile.id</p> </li>
    /// <li> <p>resource.instanceDetails.imageId</p> </li>
    /// <li> <p>resource.instanceDetails.instanceId</p> </li>
    /// <li> <p>resource.instanceDetails.outpostArn</p> </li>
    /// <li> <p>resource.instanceDetails.networkInterfaces.ipv6Addresses</p> </li>
    /// <li> <p>resource.instanceDetails.networkInterfaces.privateIpAddresses.privateIpAddress</p> </li>
    /// <li> <p>resource.instanceDetails.networkInterfaces.publicDnsName</p> </li>
    /// <li> <p>resource.instanceDetails.networkInterfaces.publicIp</p> </li>
    /// <li> <p>resource.instanceDetails.networkInterfaces.securityGroups.groupId</p> </li>
    /// <li> <p>resource.instanceDetails.networkInterfaces.securityGroups.groupName</p> </li>
    /// <li> <p>resource.instanceDetails.networkInterfaces.subnetId</p> </li>
    /// <li> <p>resource.instanceDetails.networkInterfaces.vpcId</p> </li>
    /// <li> <p>resource.instanceDetails.tags.key</p> </li>
    /// <li> <p>resource.instanceDetails.tags.value</p> </li>
    /// <li> <p>resource.resourceType</p> </li>
    /// <li> <p>service.action.actionType</p> </li>
    /// <li> <p>service.action.awsApiCallAction.api</p> </li>
    /// <li> <p>service.action.awsApiCallAction.callerType</p> </li>
    /// <li> <p>service.action.awsApiCallAction.errorCode</p> </li>
    /// <li> <p>service.action.awsApiCallAction.userAgent</p> </li>
    /// <li> <p>service.action.awsApiCallAction.remoteIpDetails.city.cityName</p> </li>
    /// <li> <p>service.action.awsApiCallAction.remoteIpDetails.country.countryName</p> </li>
    /// <li> <p>service.action.awsApiCallAction.remoteIpDetails.ipAddressV4</p> </li>
    /// <li> <p>service.action.awsApiCallAction.remoteIpDetails.organization.asn</p> </li>
    /// <li> <p>service.action.awsApiCallAction.remoteIpDetails.organization.asnOrg</p> </li>
    /// <li> <p>service.action.awsApiCallAction.serviceName</p> </li>
    /// <li> <p>service.action.dnsRequestAction.domain</p> </li>
    /// <li> <p>service.action.networkConnectionAction.blocked</p> </li>
    /// <li> <p>service.action.networkConnectionAction.connectionDirection</p> </li>
    /// <li> <p>service.action.networkConnectionAction.localPortDetails.port</p> </li>
    /// <li> <p>service.action.networkConnectionAction.protocol</p> </li>
    /// <li> <p>service.action.networkConnectionAction.localIpDetails.ipAddressV4</p> </li>
    /// <li> <p>service.action.networkConnectionAction.remoteIpDetails.city.cityName</p> </li>
    /// <li> <p>service.action.networkConnectionAction.remoteIpDetails.country.countryName</p> </li>
    /// <li> <p>service.action.networkConnectionAction.remoteIpDetails.ipAddressV4</p> </li>
    /// <li> <p>service.action.networkConnectionAction.remoteIpDetails.organization.asn</p> </li>
    /// <li> <p>service.action.networkConnectionAction.remoteIpDetails.organization.asnOrg</p> </li>
    /// <li> <p>service.action.networkConnectionAction.remotePortDetails.port</p> </li>
    /// <li> <p>service.additionalInfo.threatListName</p> </li>
    /// <li> <p>resource.s3BucketDetails.publicAccess.effectivePermissions</p> </li>
    /// <li> <p>resource.s3BucketDetails.name</p> </li>
    /// <li> <p>resource.s3BucketDetails.tags.key</p> </li>
    /// <li> <p>resource.s3BucketDetails.tags.value</p> </li>
    /// <li> <p>resource.s3BucketDetails.type</p> </li>
    /// <li> <p>service.archived</p> <p>When this attribute is set to TRUE, only archived findings are listed. When it's set to FALSE, only unarchived findings are listed. When this attribute is not set, all existing findings are listed.</p> </li>
    /// <li> <p>service.resourceRole</p> </li>
    /// <li> <p>severity</p> </li>
    /// <li> <p>type</p> </li>
    /// <li> <p>updatedAt</p> <p>Type: ISO 8601 string format: YYYY-MM-DDTHH:MM:SS.SSSZ or YYYY-MM-DDTHH:MM:SSZ depending on whether the value contains milliseconds.</p> </li>
    /// </ul>
    #[doc(hidden)]
    pub finding_criteria: std::option::Option<crate::types::FindingCriteria>,
    /// <p>The idempotency token for the create request.</p>
    #[doc(hidden)]
    pub client_token: std::option::Option<std::string::String>,
    /// <p>The tags to be added to a new filter resource.</p>
    #[doc(hidden)]
    pub tags:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
}
impl CreateFilterInput {
    /// <p>The ID of the detector belonging to the GuardDuty account that you want to create a filter for.</p>
    pub fn detector_id(&self) -> std::option::Option<&str> {
        self.detector_id.as_deref()
    }
    /// <p>The name of the filter. Valid characters include period (.), underscore (_), dash (-), and alphanumeric characters. A whitespace is considered to be an invalid character.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The description of the filter. Valid special characters include period (.), underscore (_), dash (-), and whitespace. The new line character is considered to be an invalid input for description.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>Specifies the action that is to be applied to the findings that match the filter.</p>
    pub fn action(&self) -> std::option::Option<&crate::types::FilterAction> {
        self.action.as_ref()
    }
    /// <p>Specifies the position of the filter in the list of current filters. Also specifies the order in which this filter is applied to the findings.</p>
    pub fn rank(&self) -> i32 {
        self.rank
    }
    /// <p>Represents the criteria to be used in the filter for querying findings.</p>
    /// <p>You can only use the following attributes to query findings:</p>
    /// <ul>
    /// <li> <p>accountId</p> </li>
    /// <li> <p>region</p> </li>
    /// <li> <p>confidence</p> </li>
    /// <li> <p>id</p> </li>
    /// <li> <p>resource.accessKeyDetails.accessKeyId</p> </li>
    /// <li> <p>resource.accessKeyDetails.principalId</p> </li>
    /// <li> <p>resource.accessKeyDetails.userName</p> </li>
    /// <li> <p>resource.accessKeyDetails.userType</p> </li>
    /// <li> <p>resource.instanceDetails.iamInstanceProfile.id</p> </li>
    /// <li> <p>resource.instanceDetails.imageId</p> </li>
    /// <li> <p>resource.instanceDetails.instanceId</p> </li>
    /// <li> <p>resource.instanceDetails.outpostArn</p> </li>
    /// <li> <p>resource.instanceDetails.networkInterfaces.ipv6Addresses</p> </li>
    /// <li> <p>resource.instanceDetails.networkInterfaces.privateIpAddresses.privateIpAddress</p> </li>
    /// <li> <p>resource.instanceDetails.networkInterfaces.publicDnsName</p> </li>
    /// <li> <p>resource.instanceDetails.networkInterfaces.publicIp</p> </li>
    /// <li> <p>resource.instanceDetails.networkInterfaces.securityGroups.groupId</p> </li>
    /// <li> <p>resource.instanceDetails.networkInterfaces.securityGroups.groupName</p> </li>
    /// <li> <p>resource.instanceDetails.networkInterfaces.subnetId</p> </li>
    /// <li> <p>resource.instanceDetails.networkInterfaces.vpcId</p> </li>
    /// <li> <p>resource.instanceDetails.tags.key</p> </li>
    /// <li> <p>resource.instanceDetails.tags.value</p> </li>
    /// <li> <p>resource.resourceType</p> </li>
    /// <li> <p>service.action.actionType</p> </li>
    /// <li> <p>service.action.awsApiCallAction.api</p> </li>
    /// <li> <p>service.action.awsApiCallAction.callerType</p> </li>
    /// <li> <p>service.action.awsApiCallAction.errorCode</p> </li>
    /// <li> <p>service.action.awsApiCallAction.userAgent</p> </li>
    /// <li> <p>service.action.awsApiCallAction.remoteIpDetails.city.cityName</p> </li>
    /// <li> <p>service.action.awsApiCallAction.remoteIpDetails.country.countryName</p> </li>
    /// <li> <p>service.action.awsApiCallAction.remoteIpDetails.ipAddressV4</p> </li>
    /// <li> <p>service.action.awsApiCallAction.remoteIpDetails.organization.asn</p> </li>
    /// <li> <p>service.action.awsApiCallAction.remoteIpDetails.organization.asnOrg</p> </li>
    /// <li> <p>service.action.awsApiCallAction.serviceName</p> </li>
    /// <li> <p>service.action.dnsRequestAction.domain</p> </li>
    /// <li> <p>service.action.networkConnectionAction.blocked</p> </li>
    /// <li> <p>service.action.networkConnectionAction.connectionDirection</p> </li>
    /// <li> <p>service.action.networkConnectionAction.localPortDetails.port</p> </li>
    /// <li> <p>service.action.networkConnectionAction.protocol</p> </li>
    /// <li> <p>service.action.networkConnectionAction.localIpDetails.ipAddressV4</p> </li>
    /// <li> <p>service.action.networkConnectionAction.remoteIpDetails.city.cityName</p> </li>
    /// <li> <p>service.action.networkConnectionAction.remoteIpDetails.country.countryName</p> </li>
    /// <li> <p>service.action.networkConnectionAction.remoteIpDetails.ipAddressV4</p> </li>
    /// <li> <p>service.action.networkConnectionAction.remoteIpDetails.organization.asn</p> </li>
    /// <li> <p>service.action.networkConnectionAction.remoteIpDetails.organization.asnOrg</p> </li>
    /// <li> <p>service.action.networkConnectionAction.remotePortDetails.port</p> </li>
    /// <li> <p>service.additionalInfo.threatListName</p> </li>
    /// <li> <p>resource.s3BucketDetails.publicAccess.effectivePermissions</p> </li>
    /// <li> <p>resource.s3BucketDetails.name</p> </li>
    /// <li> <p>resource.s3BucketDetails.tags.key</p> </li>
    /// <li> <p>resource.s3BucketDetails.tags.value</p> </li>
    /// <li> <p>resource.s3BucketDetails.type</p> </li>
    /// <li> <p>service.archived</p> <p>When this attribute is set to TRUE, only archived findings are listed. When it's set to FALSE, only unarchived findings are listed. When this attribute is not set, all existing findings are listed.</p> </li>
    /// <li> <p>service.resourceRole</p> </li>
    /// <li> <p>severity</p> </li>
    /// <li> <p>type</p> </li>
    /// <li> <p>updatedAt</p> <p>Type: ISO 8601 string format: YYYY-MM-DDTHH:MM:SS.SSSZ or YYYY-MM-DDTHH:MM:SSZ depending on whether the value contains milliseconds.</p> </li>
    /// </ul>
    pub fn finding_criteria(&self) -> std::option::Option<&crate::types::FindingCriteria> {
        self.finding_criteria.as_ref()
    }
    /// <p>The idempotency token for the create request.</p>
    pub fn client_token(&self) -> std::option::Option<&str> {
        self.client_token.as_deref()
    }
    /// <p>The tags to be added to a new filter resource.</p>
    pub fn tags(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.tags.as_ref()
    }
}
impl CreateFilterInput {
    /// Creates a new builder-style object to manufacture [`CreateFilterInput`](crate::operation::create_filter::CreateFilterInput).
    pub fn builder() -> crate::operation::create_filter::builders::CreateFilterInputBuilder {
        crate::operation::create_filter::builders::CreateFilterInputBuilder::default()
    }
}

/// A builder for [`CreateFilterInput`](crate::operation::create_filter::CreateFilterInput).
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
pub struct CreateFilterInputBuilder {
    pub(crate) detector_id: std::option::Option<std::string::String>,
    pub(crate) name: std::option::Option<std::string::String>,
    pub(crate) description: std::option::Option<std::string::String>,
    pub(crate) action: std::option::Option<crate::types::FilterAction>,
    pub(crate) rank: std::option::Option<i32>,
    pub(crate) finding_criteria: std::option::Option<crate::types::FindingCriteria>,
    pub(crate) client_token: std::option::Option<std::string::String>,
    pub(crate) tags:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
}
impl CreateFilterInputBuilder {
    /// <p>The ID of the detector belonging to the GuardDuty account that you want to create a filter for.</p>
    pub fn detector_id(mut self, input: impl Into<std::string::String>) -> Self {
        self.detector_id = Some(input.into());
        self
    }
    /// <p>The ID of the detector belonging to the GuardDuty account that you want to create a filter for.</p>
    pub fn set_detector_id(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.detector_id = input;
        self
    }
    /// <p>The name of the filter. Valid characters include period (.), underscore (_), dash (-), and alphanumeric characters. A whitespace is considered to be an invalid character.</p>
    pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
        self.name = Some(input.into());
        self
    }
    /// <p>The name of the filter. Valid characters include period (.), underscore (_), dash (-), and alphanumeric characters. A whitespace is considered to be an invalid character.</p>
    pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.name = input;
        self
    }
    /// <p>The description of the filter. Valid special characters include period (.), underscore (_), dash (-), and whitespace. The new line character is considered to be an invalid input for description.</p>
    pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
        self.description = Some(input.into());
        self
    }
    /// <p>The description of the filter. Valid special characters include period (.), underscore (_), dash (-), and whitespace. The new line character is considered to be an invalid input for description.</p>
    pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.description = input;
        self
    }
    /// <p>Specifies the action that is to be applied to the findings that match the filter.</p>
    pub fn action(mut self, input: crate::types::FilterAction) -> Self {
        self.action = Some(input);
        self
    }
    /// <p>Specifies the action that is to be applied to the findings that match the filter.</p>
    pub fn set_action(mut self, input: std::option::Option<crate::types::FilterAction>) -> Self {
        self.action = input;
        self
    }
    /// <p>Specifies the position of the filter in the list of current filters. Also specifies the order in which this filter is applied to the findings.</p>
    pub fn rank(mut self, input: i32) -> Self {
        self.rank = Some(input);
        self
    }
    /// <p>Specifies the position of the filter in the list of current filters. Also specifies the order in which this filter is applied to the findings.</p>
    pub fn set_rank(mut self, input: std::option::Option<i32>) -> Self {
        self.rank = input;
        self
    }
    /// <p>Represents the criteria to be used in the filter for querying findings.</p>
    /// <p>You can only use the following attributes to query findings:</p>
    /// <ul>
    /// <li> <p>accountId</p> </li>
    /// <li> <p>region</p> </li>
    /// <li> <p>confidence</p> </li>
    /// <li> <p>id</p> </li>
    /// <li> <p>resource.accessKeyDetails.accessKeyId</p> </li>
    /// <li> <p>resource.accessKeyDetails.principalId</p> </li>
    /// <li> <p>resource.accessKeyDetails.userName</p> </li>
    /// <li> <p>resource.accessKeyDetails.userType</p> </li>
    /// <li> <p>resource.instanceDetails.iamInstanceProfile.id</p> </li>
    /// <li> <p>resource.instanceDetails.imageId</p> </li>
    /// <li> <p>resource.instanceDetails.instanceId</p> </li>
    /// <li> <p>resource.instanceDetails.outpostArn</p> </li>
    /// <li> <p>resource.instanceDetails.networkInterfaces.ipv6Addresses</p> </li>
    /// <li> <p>resource.instanceDetails.networkInterfaces.privateIpAddresses.privateIpAddress</p> </li>
    /// <li> <p>resource.instanceDetails.networkInterfaces.publicDnsName</p> </li>
    /// <li> <p>resource.instanceDetails.networkInterfaces.publicIp</p> </li>
    /// <li> <p>resource.instanceDetails.networkInterfaces.securityGroups.groupId</p> </li>
    /// <li> <p>resource.instanceDetails.networkInterfaces.securityGroups.groupName</p> </li>
    /// <li> <p>resource.instanceDetails.networkInterfaces.subnetId</p> </li>
    /// <li> <p>resource.instanceDetails.networkInterfaces.vpcId</p> </li>
    /// <li> <p>resource.instanceDetails.tags.key</p> </li>
    /// <li> <p>resource.instanceDetails.tags.value</p> </li>
    /// <li> <p>resource.resourceType</p> </li>
    /// <li> <p>service.action.actionType</p> </li>
    /// <li> <p>service.action.awsApiCallAction.api</p> </li>
    /// <li> <p>service.action.awsApiCallAction.callerType</p> </li>
    /// <li> <p>service.action.awsApiCallAction.errorCode</p> </li>
    /// <li> <p>service.action.awsApiCallAction.userAgent</p> </li>
    /// <li> <p>service.action.awsApiCallAction.remoteIpDetails.city.cityName</p> </li>
    /// <li> <p>service.action.awsApiCallAction.remoteIpDetails.country.countryName</p> </li>
    /// <li> <p>service.action.awsApiCallAction.remoteIpDetails.ipAddressV4</p> </li>
    /// <li> <p>service.action.awsApiCallAction.remoteIpDetails.organization.asn</p> </li>
    /// <li> <p>service.action.awsApiCallAction.remoteIpDetails.organization.asnOrg</p> </li>
    /// <li> <p>service.action.awsApiCallAction.serviceName</p> </li>
    /// <li> <p>service.action.dnsRequestAction.domain</p> </li>
    /// <li> <p>service.action.networkConnectionAction.blocked</p> </li>
    /// <li> <p>service.action.networkConnectionAction.connectionDirection</p> </li>
    /// <li> <p>service.action.networkConnectionAction.localPortDetails.port</p> </li>
    /// <li> <p>service.action.networkConnectionAction.protocol</p> </li>
    /// <li> <p>service.action.networkConnectionAction.localIpDetails.ipAddressV4</p> </li>
    /// <li> <p>service.action.networkConnectionAction.remoteIpDetails.city.cityName</p> </li>
    /// <li> <p>service.action.networkConnectionAction.remoteIpDetails.country.countryName</p> </li>
    /// <li> <p>service.action.networkConnectionAction.remoteIpDetails.ipAddressV4</p> </li>
    /// <li> <p>service.action.networkConnectionAction.remoteIpDetails.organization.asn</p> </li>
    /// <li> <p>service.action.networkConnectionAction.remoteIpDetails.organization.asnOrg</p> </li>
    /// <li> <p>service.action.networkConnectionAction.remotePortDetails.port</p> </li>
    /// <li> <p>service.additionalInfo.threatListName</p> </li>
    /// <li> <p>resource.s3BucketDetails.publicAccess.effectivePermissions</p> </li>
    /// <li> <p>resource.s3BucketDetails.name</p> </li>
    /// <li> <p>resource.s3BucketDetails.tags.key</p> </li>
    /// <li> <p>resource.s3BucketDetails.tags.value</p> </li>
    /// <li> <p>resource.s3BucketDetails.type</p> </li>
    /// <li> <p>service.archived</p> <p>When this attribute is set to TRUE, only archived findings are listed. When it's set to FALSE, only unarchived findings are listed. When this attribute is not set, all existing findings are listed.</p> </li>
    /// <li> <p>service.resourceRole</p> </li>
    /// <li> <p>severity</p> </li>
    /// <li> <p>type</p> </li>
    /// <li> <p>updatedAt</p> <p>Type: ISO 8601 string format: YYYY-MM-DDTHH:MM:SS.SSSZ or YYYY-MM-DDTHH:MM:SSZ depending on whether the value contains milliseconds.</p> </li>
    /// </ul>
    pub fn finding_criteria(mut self, input: crate::types::FindingCriteria) -> Self {
        self.finding_criteria = Some(input);
        self
    }
    /// <p>Represents the criteria to be used in the filter for querying findings.</p>
    /// <p>You can only use the following attributes to query findings:</p>
    /// <ul>
    /// <li> <p>accountId</p> </li>
    /// <li> <p>region</p> </li>
    /// <li> <p>confidence</p> </li>
    /// <li> <p>id</p> </li>
    /// <li> <p>resource.accessKeyDetails.accessKeyId</p> </li>
    /// <li> <p>resource.accessKeyDetails.principalId</p> </li>
    /// <li> <p>resource.accessKeyDetails.userName</p> </li>
    /// <li> <p>resource.accessKeyDetails.userType</p> </li>
    /// <li> <p>resource.instanceDetails.iamInstanceProfile.id</p> </li>
    /// <li> <p>resource.instanceDetails.imageId</p> </li>
    /// <li> <p>resource.instanceDetails.instanceId</p> </li>
    /// <li> <p>resource.instanceDetails.outpostArn</p> </li>
    /// <li> <p>resource.instanceDetails.networkInterfaces.ipv6Addresses</p> </li>
    /// <li> <p>resource.instanceDetails.networkInterfaces.privateIpAddresses.privateIpAddress</p> </li>
    /// <li> <p>resource.instanceDetails.networkInterfaces.publicDnsName</p> </li>
    /// <li> <p>resource.instanceDetails.networkInterfaces.publicIp</p> </li>
    /// <li> <p>resource.instanceDetails.networkInterfaces.securityGroups.groupId</p> </li>
    /// <li> <p>resource.instanceDetails.networkInterfaces.securityGroups.groupName</p> </li>
    /// <li> <p>resource.instanceDetails.networkInterfaces.subnetId</p> </li>
    /// <li> <p>resource.instanceDetails.networkInterfaces.vpcId</p> </li>
    /// <li> <p>resource.instanceDetails.tags.key</p> </li>
    /// <li> <p>resource.instanceDetails.tags.value</p> </li>
    /// <li> <p>resource.resourceType</p> </li>
    /// <li> <p>service.action.actionType</p> </li>
    /// <li> <p>service.action.awsApiCallAction.api</p> </li>
    /// <li> <p>service.action.awsApiCallAction.callerType</p> </li>
    /// <li> <p>service.action.awsApiCallAction.errorCode</p> </li>
    /// <li> <p>service.action.awsApiCallAction.userAgent</p> </li>
    /// <li> <p>service.action.awsApiCallAction.remoteIpDetails.city.cityName</p> </li>
    /// <li> <p>service.action.awsApiCallAction.remoteIpDetails.country.countryName</p> </li>
    /// <li> <p>service.action.awsApiCallAction.remoteIpDetails.ipAddressV4</p> </li>
    /// <li> <p>service.action.awsApiCallAction.remoteIpDetails.organization.asn</p> </li>
    /// <li> <p>service.action.awsApiCallAction.remoteIpDetails.organization.asnOrg</p> </li>
    /// <li> <p>service.action.awsApiCallAction.serviceName</p> </li>
    /// <li> <p>service.action.dnsRequestAction.domain</p> </li>
    /// <li> <p>service.action.networkConnectionAction.blocked</p> </li>
    /// <li> <p>service.action.networkConnectionAction.connectionDirection</p> </li>
    /// <li> <p>service.action.networkConnectionAction.localPortDetails.port</p> </li>
    /// <li> <p>service.action.networkConnectionAction.protocol</p> </li>
    /// <li> <p>service.action.networkConnectionAction.localIpDetails.ipAddressV4</p> </li>
    /// <li> <p>service.action.networkConnectionAction.remoteIpDetails.city.cityName</p> </li>
    /// <li> <p>service.action.networkConnectionAction.remoteIpDetails.country.countryName</p> </li>
    /// <li> <p>service.action.networkConnectionAction.remoteIpDetails.ipAddressV4</p> </li>
    /// <li> <p>service.action.networkConnectionAction.remoteIpDetails.organization.asn</p> </li>
    /// <li> <p>service.action.networkConnectionAction.remoteIpDetails.organization.asnOrg</p> </li>
    /// <li> <p>service.action.networkConnectionAction.remotePortDetails.port</p> </li>
    /// <li> <p>service.additionalInfo.threatListName</p> </li>
    /// <li> <p>resource.s3BucketDetails.publicAccess.effectivePermissions</p> </li>
    /// <li> <p>resource.s3BucketDetails.name</p> </li>
    /// <li> <p>resource.s3BucketDetails.tags.key</p> </li>
    /// <li> <p>resource.s3BucketDetails.tags.value</p> </li>
    /// <li> <p>resource.s3BucketDetails.type</p> </li>
    /// <li> <p>service.archived</p> <p>When this attribute is set to TRUE, only archived findings are listed. When it's set to FALSE, only unarchived findings are listed. When this attribute is not set, all existing findings are listed.</p> </li>
    /// <li> <p>service.resourceRole</p> </li>
    /// <li> <p>severity</p> </li>
    /// <li> <p>type</p> </li>
    /// <li> <p>updatedAt</p> <p>Type: ISO 8601 string format: YYYY-MM-DDTHH:MM:SS.SSSZ or YYYY-MM-DDTHH:MM:SSZ depending on whether the value contains milliseconds.</p> </li>
    /// </ul>
    pub fn set_finding_criteria(
        mut self,
        input: std::option::Option<crate::types::FindingCriteria>,
    ) -> Self {
        self.finding_criteria = input;
        self
    }
    /// <p>The idempotency token for the create request.</p>
    pub fn client_token(mut self, input: impl Into<std::string::String>) -> Self {
        self.client_token = Some(input.into());
        self
    }
    /// <p>The idempotency token for the create request.</p>
    pub fn set_client_token(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.client_token = input;
        self
    }
    /// Adds a key-value pair to `tags`.
    ///
    /// To override the contents of this collection use [`set_tags`](Self::set_tags).
    ///
    /// <p>The tags to be added to a new filter resource.</p>
    pub fn tags(
        mut self,
        k: impl Into<std::string::String>,
        v: impl Into<std::string::String>,
    ) -> Self {
        let mut hash_map = self.tags.unwrap_or_default();
        hash_map.insert(k.into(), v.into());
        self.tags = Some(hash_map);
        self
    }
    /// <p>The tags to be added to a new filter resource.</p>
    pub fn set_tags(
        mut self,
        input: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
    ) -> Self {
        self.tags = input;
        self
    }
    /// Consumes the builder and constructs a [`CreateFilterInput`](crate::operation::create_filter::CreateFilterInput).
    pub fn build(
        self,
    ) -> Result<
        crate::operation::create_filter::CreateFilterInput,
        aws_smithy_http::operation::error::BuildError,
    > {
        Ok(crate::operation::create_filter::CreateFilterInput {
            detector_id: self.detector_id,
            name: self.name,
            description: self.description,
            action: self.action,
            rank: self.rank.unwrap_or_default(),
            finding_criteria: self.finding_criteria,
            client_token: self.client_token,
            tags: self.tags,
        })
    }
}
