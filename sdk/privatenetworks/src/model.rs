// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>Information about a field that failed validation.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ValidationExceptionField {
    /// <p>The field name that failed validation.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The message about the validation failure.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
}
impl ValidationExceptionField {
    /// <p>The field name that failed validation.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The message about the validation failure.</p>
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
/// See [`ValidationExceptionField`](crate::model::ValidationExceptionField).
pub mod validation_exception_field {

    /// A builder for [`ValidationExceptionField`](crate::model::ValidationExceptionField).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The field name that failed validation.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The field name that failed validation.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The message about the validation failure.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>The message about the validation failure.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ValidationExceptionField`](crate::model::ValidationExceptionField).
        pub fn build(self) -> crate::model::ValidationExceptionField {
            crate::model::ValidationExceptionField {
                name: self.name,
                message: self.message,
            }
        }
    }
}
impl ValidationExceptionField {
    /// Creates a new builder-style object to manufacture [`ValidationExceptionField`](crate::model::ValidationExceptionField).
    pub fn builder() -> crate::model::validation_exception_field::Builder {
        crate::model::validation_exception_field::Builder::default()
    }
}

/// When writing a match expression against `ValidationExceptionReason`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let validationexceptionreason = unimplemented!();
/// match validationexceptionreason {
///     ValidationExceptionReason::CannotAssumeRole => { /* ... */ },
///     ValidationExceptionReason::CannotParse => { /* ... */ },
///     ValidationExceptionReason::FieldValidationFailed => { /* ... */ },
///     ValidationExceptionReason::Other => { /* ... */ },
///     ValidationExceptionReason::UnknownOperation => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `validationexceptionreason` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ValidationExceptionReason::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ValidationExceptionReason::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ValidationExceptionReason::NewFeature` is defined.
/// Specifically, when `validationexceptionreason` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ValidationExceptionReason::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ValidationExceptionReason {
    #[allow(missing_docs)] // documentation missing in model
    CannotAssumeRole,
    #[allow(missing_docs)] // documentation missing in model
    CannotParse,
    #[allow(missing_docs)] // documentation missing in model
    FieldValidationFailed,
    #[allow(missing_docs)] // documentation missing in model
    Other,
    #[allow(missing_docs)] // documentation missing in model
    UnknownOperation,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ValidationExceptionReason {
    fn from(s: &str) -> Self {
        match s {
            "CANNOT_ASSUME_ROLE" => ValidationExceptionReason::CannotAssumeRole,
            "CANNOT_PARSE" => ValidationExceptionReason::CannotParse,
            "FIELD_VALIDATION_FAILED" => ValidationExceptionReason::FieldValidationFailed,
            "OTHER" => ValidationExceptionReason::Other,
            "UNKNOWN_OPERATION" => ValidationExceptionReason::UnknownOperation,
            other => ValidationExceptionReason::Unknown(crate::types::UnknownVariantValue(
                other.to_owned(),
            )),
        }
    }
}
impl std::str::FromStr for ValidationExceptionReason {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ValidationExceptionReason::from(s))
    }
}
impl ValidationExceptionReason {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ValidationExceptionReason::CannotAssumeRole => "CANNOT_ASSUME_ROLE",
            ValidationExceptionReason::CannotParse => "CANNOT_PARSE",
            ValidationExceptionReason::FieldValidationFailed => "FIELD_VALIDATION_FAILED",
            ValidationExceptionReason::Other => "OTHER",
            ValidationExceptionReason::UnknownOperation => "UNKNOWN_OPERATION",
            ValidationExceptionReason::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "CANNOT_ASSUME_ROLE",
            "CANNOT_PARSE",
            "FIELD_VALIDATION_FAILED",
            "OTHER",
            "UNKNOWN_OPERATION",
        ]
    }
}
impl AsRef<str> for ValidationExceptionReason {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Information about a network site.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct NetworkSite {
    /// <p>The Amazon Resource Name (ARN) of the network site.</p>
    #[doc(hidden)]
    pub network_site_arn: std::option::Option<std::string::String>,
    /// <p>The name of the network site.</p>
    #[doc(hidden)]
    pub network_site_name: std::option::Option<std::string::String>,
    /// <p>The description of the network site.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p>The status of the network site.</p>
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::NetworkSiteStatus>,
    /// <p>The status reason of the network site.</p>
    #[doc(hidden)]
    pub status_reason: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the network to which the network site belongs.</p>
    #[doc(hidden)]
    pub network_arn: std::option::Option<std::string::String>,
    /// <p>The pending plan of the network site.</p>
    #[doc(hidden)]
    pub pending_plan: std::option::Option<crate::model::SitePlan>,
    /// <p>The current plan of the network site.</p>
    #[doc(hidden)]
    pub current_plan: std::option::Option<crate::model::SitePlan>,
    /// <p>The creation time of the network site.</p>
    #[doc(hidden)]
    pub created_at: std::option::Option<aws_smithy_types::DateTime>,
    /// <p> The parent Availability Zone for the network site. </p>
    #[doc(hidden)]
    pub availability_zone: std::option::Option<std::string::String>,
    /// <p> The parent Availability Zone ID for the network site. </p>
    #[doc(hidden)]
    pub availability_zone_id: std::option::Option<std::string::String>,
}
impl NetworkSite {
    /// <p>The Amazon Resource Name (ARN) of the network site.</p>
    pub fn network_site_arn(&self) -> std::option::Option<&str> {
        self.network_site_arn.as_deref()
    }
    /// <p>The name of the network site.</p>
    pub fn network_site_name(&self) -> std::option::Option<&str> {
        self.network_site_name.as_deref()
    }
    /// <p>The description of the network site.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>The status of the network site.</p>
    pub fn status(&self) -> std::option::Option<&crate::model::NetworkSiteStatus> {
        self.status.as_ref()
    }
    /// <p>The status reason of the network site.</p>
    pub fn status_reason(&self) -> std::option::Option<&str> {
        self.status_reason.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the network to which the network site belongs.</p>
    pub fn network_arn(&self) -> std::option::Option<&str> {
        self.network_arn.as_deref()
    }
    /// <p>The pending plan of the network site.</p>
    pub fn pending_plan(&self) -> std::option::Option<&crate::model::SitePlan> {
        self.pending_plan.as_ref()
    }
    /// <p>The current plan of the network site.</p>
    pub fn current_plan(&self) -> std::option::Option<&crate::model::SitePlan> {
        self.current_plan.as_ref()
    }
    /// <p>The creation time of the network site.</p>
    pub fn created_at(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.created_at.as_ref()
    }
    /// <p> The parent Availability Zone for the network site. </p>
    pub fn availability_zone(&self) -> std::option::Option<&str> {
        self.availability_zone.as_deref()
    }
    /// <p> The parent Availability Zone ID for the network site. </p>
    pub fn availability_zone_id(&self) -> std::option::Option<&str> {
        self.availability_zone_id.as_deref()
    }
}
/// See [`NetworkSite`](crate::model::NetworkSite).
pub mod network_site {

    /// A builder for [`NetworkSite`](crate::model::NetworkSite).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) network_site_arn: std::option::Option<std::string::String>,
        pub(crate) network_site_name: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) status: std::option::Option<crate::model::NetworkSiteStatus>,
        pub(crate) status_reason: std::option::Option<std::string::String>,
        pub(crate) network_arn: std::option::Option<std::string::String>,
        pub(crate) pending_plan: std::option::Option<crate::model::SitePlan>,
        pub(crate) current_plan: std::option::Option<crate::model::SitePlan>,
        pub(crate) created_at: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) availability_zone: std::option::Option<std::string::String>,
        pub(crate) availability_zone_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the network site.</p>
        pub fn network_site_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.network_site_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the network site.</p>
        pub fn set_network_site_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.network_site_arn = input;
            self
        }
        /// <p>The name of the network site.</p>
        pub fn network_site_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.network_site_name = Some(input.into());
            self
        }
        /// <p>The name of the network site.</p>
        pub fn set_network_site_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.network_site_name = input;
            self
        }
        /// <p>The description of the network site.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>The description of the network site.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>The status of the network site.</p>
        pub fn status(mut self, input: crate::model::NetworkSiteStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The status of the network site.</p>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::NetworkSiteStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// <p>The status reason of the network site.</p>
        pub fn status_reason(mut self, input: impl Into<std::string::String>) -> Self {
            self.status_reason = Some(input.into());
            self
        }
        /// <p>The status reason of the network site.</p>
        pub fn set_status_reason(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.status_reason = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the network to which the network site belongs.</p>
        pub fn network_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.network_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the network to which the network site belongs.</p>
        pub fn set_network_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.network_arn = input;
            self
        }
        /// <p>The pending plan of the network site.</p>
        pub fn pending_plan(mut self, input: crate::model::SitePlan) -> Self {
            self.pending_plan = Some(input);
            self
        }
        /// <p>The pending plan of the network site.</p>
        pub fn set_pending_plan(
            mut self,
            input: std::option::Option<crate::model::SitePlan>,
        ) -> Self {
            self.pending_plan = input;
            self
        }
        /// <p>The current plan of the network site.</p>
        pub fn current_plan(mut self, input: crate::model::SitePlan) -> Self {
            self.current_plan = Some(input);
            self
        }
        /// <p>The current plan of the network site.</p>
        pub fn set_current_plan(
            mut self,
            input: std::option::Option<crate::model::SitePlan>,
        ) -> Self {
            self.current_plan = input;
            self
        }
        /// <p>The creation time of the network site.</p>
        pub fn created_at(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.created_at = Some(input);
            self
        }
        /// <p>The creation time of the network site.</p>
        pub fn set_created_at(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.created_at = input;
            self
        }
        /// <p> The parent Availability Zone for the network site. </p>
        pub fn availability_zone(mut self, input: impl Into<std::string::String>) -> Self {
            self.availability_zone = Some(input.into());
            self
        }
        /// <p> The parent Availability Zone for the network site. </p>
        pub fn set_availability_zone(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.availability_zone = input;
            self
        }
        /// <p> The parent Availability Zone ID for the network site. </p>
        pub fn availability_zone_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.availability_zone_id = Some(input.into());
            self
        }
        /// <p> The parent Availability Zone ID for the network site. </p>
        pub fn set_availability_zone_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.availability_zone_id = input;
            self
        }
        /// Consumes the builder and constructs a [`NetworkSite`](crate::model::NetworkSite).
        pub fn build(self) -> crate::model::NetworkSite {
            crate::model::NetworkSite {
                network_site_arn: self.network_site_arn,
                network_site_name: self.network_site_name,
                description: self.description,
                status: self.status,
                status_reason: self.status_reason,
                network_arn: self.network_arn,
                pending_plan: self.pending_plan,
                current_plan: self.current_plan,
                created_at: self.created_at,
                availability_zone: self.availability_zone,
                availability_zone_id: self.availability_zone_id,
            }
        }
    }
}
impl NetworkSite {
    /// Creates a new builder-style object to manufacture [`NetworkSite`](crate::model::NetworkSite).
    pub fn builder() -> crate::model::network_site::Builder {
        crate::model::network_site::Builder::default()
    }
}

/// <p>Information about a site plan.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct SitePlan {
    /// <p>The resource definitions of the plan.</p>
    #[doc(hidden)]
    pub resource_definitions:
        std::option::Option<std::vec::Vec<crate::model::NetworkResourceDefinition>>,
    /// <p>The options of the plan.</p>
    #[doc(hidden)]
    pub options: std::option::Option<std::vec::Vec<crate::model::NameValuePair>>,
}
impl SitePlan {
    /// <p>The resource definitions of the plan.</p>
    pub fn resource_definitions(
        &self,
    ) -> std::option::Option<&[crate::model::NetworkResourceDefinition]> {
        self.resource_definitions.as_deref()
    }
    /// <p>The options of the plan.</p>
    pub fn options(&self) -> std::option::Option<&[crate::model::NameValuePair]> {
        self.options.as_deref()
    }
}
/// See [`SitePlan`](crate::model::SitePlan).
pub mod site_plan {

    /// A builder for [`SitePlan`](crate::model::SitePlan).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) resource_definitions:
            std::option::Option<std::vec::Vec<crate::model::NetworkResourceDefinition>>,
        pub(crate) options: std::option::Option<std::vec::Vec<crate::model::NameValuePair>>,
    }
    impl Builder {
        /// Appends an item to `resource_definitions`.
        ///
        /// To override the contents of this collection use [`set_resource_definitions`](Self::set_resource_definitions).
        ///
        /// <p>The resource definitions of the plan.</p>
        pub fn resource_definitions(
            mut self,
            input: crate::model::NetworkResourceDefinition,
        ) -> Self {
            let mut v = self.resource_definitions.unwrap_or_default();
            v.push(input);
            self.resource_definitions = Some(v);
            self
        }
        /// <p>The resource definitions of the plan.</p>
        pub fn set_resource_definitions(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::NetworkResourceDefinition>>,
        ) -> Self {
            self.resource_definitions = input;
            self
        }
        /// Appends an item to `options`.
        ///
        /// To override the contents of this collection use [`set_options`](Self::set_options).
        ///
        /// <p>The options of the plan.</p>
        pub fn options(mut self, input: crate::model::NameValuePair) -> Self {
            let mut v = self.options.unwrap_or_default();
            v.push(input);
            self.options = Some(v);
            self
        }
        /// <p>The options of the plan.</p>
        pub fn set_options(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::NameValuePair>>,
        ) -> Self {
            self.options = input;
            self
        }
        /// Consumes the builder and constructs a [`SitePlan`](crate::model::SitePlan).
        pub fn build(self) -> crate::model::SitePlan {
            crate::model::SitePlan {
                resource_definitions: self.resource_definitions,
                options: self.options,
            }
        }
    }
}
impl SitePlan {
    /// Creates a new builder-style object to manufacture [`SitePlan`](crate::model::SitePlan).
    pub fn builder() -> crate::model::site_plan::Builder {
        crate::model::site_plan::Builder::default()
    }
}

/// <p>Information about a name/value pair.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct NameValuePair {
    /// <p>The name of the pair.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The value of the pair.</p>
    #[doc(hidden)]
    pub value: std::option::Option<std::string::String>,
}
impl NameValuePair {
    /// <p>The name of the pair.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The value of the pair.</p>
    pub fn value(&self) -> std::option::Option<&str> {
        self.value.as_deref()
    }
}
/// See [`NameValuePair`](crate::model::NameValuePair).
pub mod name_value_pair {

    /// A builder for [`NameValuePair`](crate::model::NameValuePair).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) value: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the pair.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the pair.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The value of the pair.</p>
        pub fn value(mut self, input: impl Into<std::string::String>) -> Self {
            self.value = Some(input.into());
            self
        }
        /// <p>The value of the pair.</p>
        pub fn set_value(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.value = input;
            self
        }
        /// Consumes the builder and constructs a [`NameValuePair`](crate::model::NameValuePair).
        pub fn build(self) -> crate::model::NameValuePair {
            crate::model::NameValuePair {
                name: self.name,
                value: self.value,
            }
        }
    }
}
impl NameValuePair {
    /// Creates a new builder-style object to manufacture [`NameValuePair`](crate::model::NameValuePair).
    pub fn builder() -> crate::model::name_value_pair::Builder {
        crate::model::name_value_pair::Builder::default()
    }
}

/// <p>Information about a network resource definition.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct NetworkResourceDefinition {
    /// <p>The type in the network resource definition.</p>
    #[doc(hidden)]
    pub r#type: std::option::Option<crate::model::NetworkResourceDefinitionType>,
    /// <p>The options in the network resource definition.</p>
    #[doc(hidden)]
    pub options: std::option::Option<std::vec::Vec<crate::model::NameValuePair>>,
    /// <p>The count in the network resource definition.</p>
    #[doc(hidden)]
    pub count: std::option::Option<i32>,
}
impl NetworkResourceDefinition {
    /// <p>The type in the network resource definition.</p>
    pub fn r#type(&self) -> std::option::Option<&crate::model::NetworkResourceDefinitionType> {
        self.r#type.as_ref()
    }
    /// <p>The options in the network resource definition.</p>
    pub fn options(&self) -> std::option::Option<&[crate::model::NameValuePair]> {
        self.options.as_deref()
    }
    /// <p>The count in the network resource definition.</p>
    pub fn count(&self) -> std::option::Option<i32> {
        self.count
    }
}
/// See [`NetworkResourceDefinition`](crate::model::NetworkResourceDefinition).
pub mod network_resource_definition {

    /// A builder for [`NetworkResourceDefinition`](crate::model::NetworkResourceDefinition).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) r#type: std::option::Option<crate::model::NetworkResourceDefinitionType>,
        pub(crate) options: std::option::Option<std::vec::Vec<crate::model::NameValuePair>>,
        pub(crate) count: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The type in the network resource definition.</p>
        pub fn r#type(mut self, input: crate::model::NetworkResourceDefinitionType) -> Self {
            self.r#type = Some(input);
            self
        }
        /// <p>The type in the network resource definition.</p>
        pub fn set_type(
            mut self,
            input: std::option::Option<crate::model::NetworkResourceDefinitionType>,
        ) -> Self {
            self.r#type = input;
            self
        }
        /// Appends an item to `options`.
        ///
        /// To override the contents of this collection use [`set_options`](Self::set_options).
        ///
        /// <p>The options in the network resource definition.</p>
        pub fn options(mut self, input: crate::model::NameValuePair) -> Self {
            let mut v = self.options.unwrap_or_default();
            v.push(input);
            self.options = Some(v);
            self
        }
        /// <p>The options in the network resource definition.</p>
        pub fn set_options(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::NameValuePair>>,
        ) -> Self {
            self.options = input;
            self
        }
        /// <p>The count in the network resource definition.</p>
        pub fn count(mut self, input: i32) -> Self {
            self.count = Some(input);
            self
        }
        /// <p>The count in the network resource definition.</p>
        pub fn set_count(mut self, input: std::option::Option<i32>) -> Self {
            self.count = input;
            self
        }
        /// Consumes the builder and constructs a [`NetworkResourceDefinition`](crate::model::NetworkResourceDefinition).
        pub fn build(self) -> crate::model::NetworkResourceDefinition {
            crate::model::NetworkResourceDefinition {
                r#type: self.r#type,
                options: self.options,
                count: self.count,
            }
        }
    }
}
impl NetworkResourceDefinition {
    /// Creates a new builder-style object to manufacture [`NetworkResourceDefinition`](crate::model::NetworkResourceDefinition).
    pub fn builder() -> crate::model::network_resource_definition::Builder {
        crate::model::network_resource_definition::Builder::default()
    }
}

/// When writing a match expression against `NetworkResourceDefinitionType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let networkresourcedefinitiontype = unimplemented!();
/// match networkresourcedefinitiontype {
///     NetworkResourceDefinitionType::DeviceIdentifier => { /* ... */ },
///     NetworkResourceDefinitionType::RadioUnit => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `networkresourcedefinitiontype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `NetworkResourceDefinitionType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `NetworkResourceDefinitionType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `NetworkResourceDefinitionType::NewFeature` is defined.
/// Specifically, when `networkresourcedefinitiontype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `NetworkResourceDefinitionType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum NetworkResourceDefinitionType {
    #[allow(missing_docs)] // documentation missing in model
    DeviceIdentifier,
    #[allow(missing_docs)] // documentation missing in model
    RadioUnit,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for NetworkResourceDefinitionType {
    fn from(s: &str) -> Self {
        match s {
            "DEVICE_IDENTIFIER" => NetworkResourceDefinitionType::DeviceIdentifier,
            "RADIO_UNIT" => NetworkResourceDefinitionType::RadioUnit,
            other => NetworkResourceDefinitionType::Unknown(crate::types::UnknownVariantValue(
                other.to_owned(),
            )),
        }
    }
}
impl std::str::FromStr for NetworkResourceDefinitionType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(NetworkResourceDefinitionType::from(s))
    }
}
impl NetworkResourceDefinitionType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            NetworkResourceDefinitionType::DeviceIdentifier => "DEVICE_IDENTIFIER",
            NetworkResourceDefinitionType::RadioUnit => "RADIO_UNIT",
            NetworkResourceDefinitionType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["DEVICE_IDENTIFIER", "RADIO_UNIT"]
    }
}
impl AsRef<str> for NetworkResourceDefinitionType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `NetworkSiteStatus`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let networksitestatus = unimplemented!();
/// match networksitestatus {
///     NetworkSiteStatus::Available => { /* ... */ },
///     NetworkSiteStatus::Created => { /* ... */ },
///     NetworkSiteStatus::Deleted => { /* ... */ },
///     NetworkSiteStatus::Deprovisioning => { /* ... */ },
///     NetworkSiteStatus::Provisioning => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `networksitestatus` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `NetworkSiteStatus::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `NetworkSiteStatus::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `NetworkSiteStatus::NewFeature` is defined.
/// Specifically, when `networksitestatus` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `NetworkSiteStatus::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum NetworkSiteStatus {
    #[allow(missing_docs)] // documentation missing in model
    Available,
    #[allow(missing_docs)] // documentation missing in model
    Created,
    #[allow(missing_docs)] // documentation missing in model
    Deleted,
    #[allow(missing_docs)] // documentation missing in model
    Deprovisioning,
    #[allow(missing_docs)] // documentation missing in model
    Provisioning,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for NetworkSiteStatus {
    fn from(s: &str) -> Self {
        match s {
            "AVAILABLE" => NetworkSiteStatus::Available,
            "CREATED" => NetworkSiteStatus::Created,
            "DELETED" => NetworkSiteStatus::Deleted,
            "DEPROVISIONING" => NetworkSiteStatus::Deprovisioning,
            "PROVISIONING" => NetworkSiteStatus::Provisioning,
            other => {
                NetworkSiteStatus::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for NetworkSiteStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(NetworkSiteStatus::from(s))
    }
}
impl NetworkSiteStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            NetworkSiteStatus::Available => "AVAILABLE",
            NetworkSiteStatus::Created => "CREATED",
            NetworkSiteStatus::Deleted => "DELETED",
            NetworkSiteStatus::Deprovisioning => "DEPROVISIONING",
            NetworkSiteStatus::Provisioning => "PROVISIONING",
            NetworkSiteStatus::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "AVAILABLE",
            "CREATED",
            "DELETED",
            "DEPROVISIONING",
            "PROVISIONING",
        ]
    }
}
impl AsRef<str> for NetworkSiteStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Information about an order.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Order {
    /// <p>The Amazon Resource Name (ARN) of the order.</p>
    #[doc(hidden)]
    pub order_arn: std::option::Option<std::string::String>,
    /// <p>The shipping address of the order.</p>
    #[doc(hidden)]
    pub shipping_address: std::option::Option<crate::model::Address>,
    /// <p>The Amazon Resource Name (ARN) of the network associated with this order.</p>
    #[doc(hidden)]
    pub network_arn: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the network site associated with this order.</p>
    #[doc(hidden)]
    pub network_site_arn: std::option::Option<std::string::String>,
    /// <p>The tracking information of the order.</p>
    #[doc(hidden)]
    pub tracking_information: std::option::Option<std::vec::Vec<crate::model::TrackingInformation>>,
    /// <p>The acknowledgement status of the order.</p>
    #[doc(hidden)]
    pub acknowledgment_status: std::option::Option<crate::model::AcknowledgmentStatus>,
    /// <p>The creation time of the order.</p>
    #[doc(hidden)]
    pub created_at: std::option::Option<aws_smithy_types::DateTime>,
}
impl Order {
    /// <p>The Amazon Resource Name (ARN) of the order.</p>
    pub fn order_arn(&self) -> std::option::Option<&str> {
        self.order_arn.as_deref()
    }
    /// <p>The shipping address of the order.</p>
    pub fn shipping_address(&self) -> std::option::Option<&crate::model::Address> {
        self.shipping_address.as_ref()
    }
    /// <p>The Amazon Resource Name (ARN) of the network associated with this order.</p>
    pub fn network_arn(&self) -> std::option::Option<&str> {
        self.network_arn.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the network site associated with this order.</p>
    pub fn network_site_arn(&self) -> std::option::Option<&str> {
        self.network_site_arn.as_deref()
    }
    /// <p>The tracking information of the order.</p>
    pub fn tracking_information(
        &self,
    ) -> std::option::Option<&[crate::model::TrackingInformation]> {
        self.tracking_information.as_deref()
    }
    /// <p>The acknowledgement status of the order.</p>
    pub fn acknowledgment_status(
        &self,
    ) -> std::option::Option<&crate::model::AcknowledgmentStatus> {
        self.acknowledgment_status.as_ref()
    }
    /// <p>The creation time of the order.</p>
    pub fn created_at(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.created_at.as_ref()
    }
}
/// See [`Order`](crate::model::Order).
pub mod order {

    /// A builder for [`Order`](crate::model::Order).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) order_arn: std::option::Option<std::string::String>,
        pub(crate) shipping_address: std::option::Option<crate::model::Address>,
        pub(crate) network_arn: std::option::Option<std::string::String>,
        pub(crate) network_site_arn: std::option::Option<std::string::String>,
        pub(crate) tracking_information:
            std::option::Option<std::vec::Vec<crate::model::TrackingInformation>>,
        pub(crate) acknowledgment_status: std::option::Option<crate::model::AcknowledgmentStatus>,
        pub(crate) created_at: std::option::Option<aws_smithy_types::DateTime>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the order.</p>
        pub fn order_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.order_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the order.</p>
        pub fn set_order_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.order_arn = input;
            self
        }
        /// <p>The shipping address of the order.</p>
        pub fn shipping_address(mut self, input: crate::model::Address) -> Self {
            self.shipping_address = Some(input);
            self
        }
        /// <p>The shipping address of the order.</p>
        pub fn set_shipping_address(
            mut self,
            input: std::option::Option<crate::model::Address>,
        ) -> Self {
            self.shipping_address = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the network associated with this order.</p>
        pub fn network_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.network_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the network associated with this order.</p>
        pub fn set_network_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.network_arn = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the network site associated with this order.</p>
        pub fn network_site_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.network_site_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the network site associated with this order.</p>
        pub fn set_network_site_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.network_site_arn = input;
            self
        }
        /// Appends an item to `tracking_information`.
        ///
        /// To override the contents of this collection use [`set_tracking_information`](Self::set_tracking_information).
        ///
        /// <p>The tracking information of the order.</p>
        pub fn tracking_information(mut self, input: crate::model::TrackingInformation) -> Self {
            let mut v = self.tracking_information.unwrap_or_default();
            v.push(input);
            self.tracking_information = Some(v);
            self
        }
        /// <p>The tracking information of the order.</p>
        pub fn set_tracking_information(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::TrackingInformation>>,
        ) -> Self {
            self.tracking_information = input;
            self
        }
        /// <p>The acknowledgement status of the order.</p>
        pub fn acknowledgment_status(mut self, input: crate::model::AcknowledgmentStatus) -> Self {
            self.acknowledgment_status = Some(input);
            self
        }
        /// <p>The acknowledgement status of the order.</p>
        pub fn set_acknowledgment_status(
            mut self,
            input: std::option::Option<crate::model::AcknowledgmentStatus>,
        ) -> Self {
            self.acknowledgment_status = input;
            self
        }
        /// <p>The creation time of the order.</p>
        pub fn created_at(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.created_at = Some(input);
            self
        }
        /// <p>The creation time of the order.</p>
        pub fn set_created_at(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.created_at = input;
            self
        }
        /// Consumes the builder and constructs a [`Order`](crate::model::Order).
        pub fn build(self) -> crate::model::Order {
            crate::model::Order {
                order_arn: self.order_arn,
                shipping_address: self.shipping_address,
                network_arn: self.network_arn,
                network_site_arn: self.network_site_arn,
                tracking_information: self.tracking_information,
                acknowledgment_status: self.acknowledgment_status,
                created_at: self.created_at,
            }
        }
    }
}
impl Order {
    /// Creates a new builder-style object to manufacture [`Order`](crate::model::Order).
    pub fn builder() -> crate::model::order::Builder {
        crate::model::order::Builder::default()
    }
}

/// When writing a match expression against `AcknowledgmentStatus`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let acknowledgmentstatus = unimplemented!();
/// match acknowledgmentstatus {
///     AcknowledgmentStatus::Acknowledged => { /* ... */ },
///     AcknowledgmentStatus::Acknowledging => { /* ... */ },
///     AcknowledgmentStatus::Unacknowledged => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `acknowledgmentstatus` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `AcknowledgmentStatus::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `AcknowledgmentStatus::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `AcknowledgmentStatus::NewFeature` is defined.
/// Specifically, when `acknowledgmentstatus` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `AcknowledgmentStatus::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum AcknowledgmentStatus {
    #[allow(missing_docs)] // documentation missing in model
    Acknowledged,
    #[allow(missing_docs)] // documentation missing in model
    Acknowledging,
    #[allow(missing_docs)] // documentation missing in model
    Unacknowledged,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for AcknowledgmentStatus {
    fn from(s: &str) -> Self {
        match s {
            "ACKNOWLEDGED" => AcknowledgmentStatus::Acknowledged,
            "ACKNOWLEDGING" => AcknowledgmentStatus::Acknowledging,
            "UNACKNOWLEDGED" => AcknowledgmentStatus::Unacknowledged,
            other => {
                AcknowledgmentStatus::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for AcknowledgmentStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(AcknowledgmentStatus::from(s))
    }
}
impl AcknowledgmentStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            AcknowledgmentStatus::Acknowledged => "ACKNOWLEDGED",
            AcknowledgmentStatus::Acknowledging => "ACKNOWLEDGING",
            AcknowledgmentStatus::Unacknowledged => "UNACKNOWLEDGED",
            AcknowledgmentStatus::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["ACKNOWLEDGED", "ACKNOWLEDGING", "UNACKNOWLEDGED"]
    }
}
impl AsRef<str> for AcknowledgmentStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Information about tracking a shipment.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TrackingInformation {
    /// <p>The tracking number of the shipment.</p>
    #[doc(hidden)]
    pub tracking_number: std::option::Option<std::string::String>,
}
impl TrackingInformation {
    /// <p>The tracking number of the shipment.</p>
    pub fn tracking_number(&self) -> std::option::Option<&str> {
        self.tracking_number.as_deref()
    }
}
/// See [`TrackingInformation`](crate::model::TrackingInformation).
pub mod tracking_information {

    /// A builder for [`TrackingInformation`](crate::model::TrackingInformation).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) tracking_number: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The tracking number of the shipment.</p>
        pub fn tracking_number(mut self, input: impl Into<std::string::String>) -> Self {
            self.tracking_number = Some(input.into());
            self
        }
        /// <p>The tracking number of the shipment.</p>
        pub fn set_tracking_number(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.tracking_number = input;
            self
        }
        /// Consumes the builder and constructs a [`TrackingInformation`](crate::model::TrackingInformation).
        pub fn build(self) -> crate::model::TrackingInformation {
            crate::model::TrackingInformation {
                tracking_number: self.tracking_number,
            }
        }
    }
}
impl TrackingInformation {
    /// Creates a new builder-style object to manufacture [`TrackingInformation`](crate::model::TrackingInformation).
    pub fn builder() -> crate::model::tracking_information::Builder {
        crate::model::tracking_information::Builder::default()
    }
}

/// <p>Information about an address.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Address {
    /// <p>The city for this address.</p>
    #[doc(hidden)]
    pub city: std::option::Option<std::string::String>,
    /// <p>The company name for this address.</p>
    #[doc(hidden)]
    pub company: std::option::Option<std::string::String>,
    /// <p>The country for this address.</p>
    #[doc(hidden)]
    pub country: std::option::Option<std::string::String>,
    /// <p>The recipient's name for this address.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The phone number for this address.</p>
    #[doc(hidden)]
    pub phone_number: std::option::Option<std::string::String>,
    /// <p>The postal code for this address.</p>
    #[doc(hidden)]
    pub postal_code: std::option::Option<std::string::String>,
    /// <p>The state or province for this address.</p>
    #[doc(hidden)]
    pub state_or_province: std::option::Option<std::string::String>,
    /// <p>The first line of the street address.</p>
    #[doc(hidden)]
    pub street1: std::option::Option<std::string::String>,
    /// <p>The second line of the street address.</p>
    #[doc(hidden)]
    pub street2: std::option::Option<std::string::String>,
    /// <p>The third line of the street address.</p>
    #[doc(hidden)]
    pub street3: std::option::Option<std::string::String>,
}
impl Address {
    /// <p>The city for this address.</p>
    pub fn city(&self) -> std::option::Option<&str> {
        self.city.as_deref()
    }
    /// <p>The company name for this address.</p>
    pub fn company(&self) -> std::option::Option<&str> {
        self.company.as_deref()
    }
    /// <p>The country for this address.</p>
    pub fn country(&self) -> std::option::Option<&str> {
        self.country.as_deref()
    }
    /// <p>The recipient's name for this address.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The phone number for this address.</p>
    pub fn phone_number(&self) -> std::option::Option<&str> {
        self.phone_number.as_deref()
    }
    /// <p>The postal code for this address.</p>
    pub fn postal_code(&self) -> std::option::Option<&str> {
        self.postal_code.as_deref()
    }
    /// <p>The state or province for this address.</p>
    pub fn state_or_province(&self) -> std::option::Option<&str> {
        self.state_or_province.as_deref()
    }
    /// <p>The first line of the street address.</p>
    pub fn street1(&self) -> std::option::Option<&str> {
        self.street1.as_deref()
    }
    /// <p>The second line of the street address.</p>
    pub fn street2(&self) -> std::option::Option<&str> {
        self.street2.as_deref()
    }
    /// <p>The third line of the street address.</p>
    pub fn street3(&self) -> std::option::Option<&str> {
        self.street3.as_deref()
    }
}
impl std::fmt::Debug for Address {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Address");
        formatter.field("city", &"*** Sensitive Data Redacted ***");
        formatter.field("company", &"*** Sensitive Data Redacted ***");
        formatter.field("country", &"*** Sensitive Data Redacted ***");
        formatter.field("name", &"*** Sensitive Data Redacted ***");
        formatter.field("phone_number", &"*** Sensitive Data Redacted ***");
        formatter.field("postal_code", &"*** Sensitive Data Redacted ***");
        formatter.field("state_or_province", &"*** Sensitive Data Redacted ***");
        formatter.field("street1", &"*** Sensitive Data Redacted ***");
        formatter.field("street2", &"*** Sensitive Data Redacted ***");
        formatter.field("street3", &"*** Sensitive Data Redacted ***");
        formatter.finish()
    }
}
/// See [`Address`](crate::model::Address).
pub mod address {

    /// A builder for [`Address`](crate::model::Address).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default)]
    pub struct Builder {
        pub(crate) city: std::option::Option<std::string::String>,
        pub(crate) company: std::option::Option<std::string::String>,
        pub(crate) country: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) phone_number: std::option::Option<std::string::String>,
        pub(crate) postal_code: std::option::Option<std::string::String>,
        pub(crate) state_or_province: std::option::Option<std::string::String>,
        pub(crate) street1: std::option::Option<std::string::String>,
        pub(crate) street2: std::option::Option<std::string::String>,
        pub(crate) street3: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The city for this address.</p>
        pub fn city(mut self, input: impl Into<std::string::String>) -> Self {
            self.city = Some(input.into());
            self
        }
        /// <p>The city for this address.</p>
        pub fn set_city(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.city = input;
            self
        }
        /// <p>The company name for this address.</p>
        pub fn company(mut self, input: impl Into<std::string::String>) -> Self {
            self.company = Some(input.into());
            self
        }
        /// <p>The company name for this address.</p>
        pub fn set_company(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.company = input;
            self
        }
        /// <p>The country for this address.</p>
        pub fn country(mut self, input: impl Into<std::string::String>) -> Self {
            self.country = Some(input.into());
            self
        }
        /// <p>The country for this address.</p>
        pub fn set_country(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.country = input;
            self
        }
        /// <p>The recipient's name for this address.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The recipient's name for this address.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The phone number for this address.</p>
        pub fn phone_number(mut self, input: impl Into<std::string::String>) -> Self {
            self.phone_number = Some(input.into());
            self
        }
        /// <p>The phone number for this address.</p>
        pub fn set_phone_number(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.phone_number = input;
            self
        }
        /// <p>The postal code for this address.</p>
        pub fn postal_code(mut self, input: impl Into<std::string::String>) -> Self {
            self.postal_code = Some(input.into());
            self
        }
        /// <p>The postal code for this address.</p>
        pub fn set_postal_code(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.postal_code = input;
            self
        }
        /// <p>The state or province for this address.</p>
        pub fn state_or_province(mut self, input: impl Into<std::string::String>) -> Self {
            self.state_or_province = Some(input.into());
            self
        }
        /// <p>The state or province for this address.</p>
        pub fn set_state_or_province(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.state_or_province = input;
            self
        }
        /// <p>The first line of the street address.</p>
        pub fn street1(mut self, input: impl Into<std::string::String>) -> Self {
            self.street1 = Some(input.into());
            self
        }
        /// <p>The first line of the street address.</p>
        pub fn set_street1(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.street1 = input;
            self
        }
        /// <p>The second line of the street address.</p>
        pub fn street2(mut self, input: impl Into<std::string::String>) -> Self {
            self.street2 = Some(input.into());
            self
        }
        /// <p>The second line of the street address.</p>
        pub fn set_street2(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.street2 = input;
            self
        }
        /// <p>The third line of the street address.</p>
        pub fn street3(mut self, input: impl Into<std::string::String>) -> Self {
            self.street3 = Some(input.into());
            self
        }
        /// <p>The third line of the street address.</p>
        pub fn set_street3(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.street3 = input;
            self
        }
        /// Consumes the builder and constructs a [`Address`](crate::model::Address).
        pub fn build(self) -> crate::model::Address {
            crate::model::Address {
                city: self.city,
                company: self.company,
                country: self.country,
                name: self.name,
                phone_number: self.phone_number,
                postal_code: self.postal_code,
                state_or_province: self.state_or_province,
                street1: self.street1,
                street2: self.street2,
                street3: self.street3,
            }
        }
    }
    impl std::fmt::Debug for Builder {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut formatter = f.debug_struct("Builder");
            formatter.field("city", &"*** Sensitive Data Redacted ***");
            formatter.field("company", &"*** Sensitive Data Redacted ***");
            formatter.field("country", &"*** Sensitive Data Redacted ***");
            formatter.field("name", &"*** Sensitive Data Redacted ***");
            formatter.field("phone_number", &"*** Sensitive Data Redacted ***");
            formatter.field("postal_code", &"*** Sensitive Data Redacted ***");
            formatter.field("state_or_province", &"*** Sensitive Data Redacted ***");
            formatter.field("street1", &"*** Sensitive Data Redacted ***");
            formatter.field("street2", &"*** Sensitive Data Redacted ***");
            formatter.field("street3", &"*** Sensitive Data Redacted ***");
            formatter.finish()
        }
    }
}
impl Address {
    /// Creates a new builder-style object to manufacture [`Address`](crate::model::Address).
    pub fn builder() -> crate::model::address::Builder {
        crate::model::address::Builder::default()
    }
}

/// When writing a match expression against `OrderFilterKeys`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let orderfilterkeys = unimplemented!();
/// match orderfilterkeys {
///     OrderFilterKeys::NetworkSite => { /* ... */ },
///     OrderFilterKeys::Status => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `orderfilterkeys` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `OrderFilterKeys::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `OrderFilterKeys::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `OrderFilterKeys::NewFeature` is defined.
/// Specifically, when `orderfilterkeys` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `OrderFilterKeys::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum OrderFilterKeys {
    #[allow(missing_docs)] // documentation missing in model
    NetworkSite,
    #[allow(missing_docs)] // documentation missing in model
    Status,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for OrderFilterKeys {
    fn from(s: &str) -> Self {
        match s {
            "NETWORK_SITE" => OrderFilterKeys::NetworkSite,
            "STATUS" => OrderFilterKeys::Status,
            other => OrderFilterKeys::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for OrderFilterKeys {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(OrderFilterKeys::from(s))
    }
}
impl OrderFilterKeys {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            OrderFilterKeys::NetworkSite => "NETWORK_SITE",
            OrderFilterKeys::Status => "STATUS",
            OrderFilterKeys::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["NETWORK_SITE", "STATUS"]
    }
}
impl AsRef<str> for OrderFilterKeys {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `NetworkSiteFilterKeys`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let networksitefilterkeys = unimplemented!();
/// match networksitefilterkeys {
///     NetworkSiteFilterKeys::Status => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `networksitefilterkeys` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `NetworkSiteFilterKeys::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `NetworkSiteFilterKeys::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `NetworkSiteFilterKeys::NewFeature` is defined.
/// Specifically, when `networksitefilterkeys` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `NetworkSiteFilterKeys::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum NetworkSiteFilterKeys {
    #[allow(missing_docs)] // documentation missing in model
    Status,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for NetworkSiteFilterKeys {
    fn from(s: &str) -> Self {
        match s {
            "STATUS" => NetworkSiteFilterKeys::Status,
            other => {
                NetworkSiteFilterKeys::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for NetworkSiteFilterKeys {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(NetworkSiteFilterKeys::from(s))
    }
}
impl NetworkSiteFilterKeys {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            NetworkSiteFilterKeys::Status => "STATUS",
            NetworkSiteFilterKeys::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["STATUS"]
    }
}
impl AsRef<str> for NetworkSiteFilterKeys {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Information about a network.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Network {
    /// <p>The Amazon Resource Name (ARN) of the network.</p>
    #[doc(hidden)]
    pub network_arn: std::option::Option<std::string::String>,
    /// <p>The name of the network.</p>
    #[doc(hidden)]
    pub network_name: std::option::Option<std::string::String>,
    /// <p>The description of the network.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p>The status of the network.</p>
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::NetworkStatus>,
    /// <p>The status reason of the network.</p>
    #[doc(hidden)]
    pub status_reason: std::option::Option<std::string::String>,
    /// <p>The creation time of the network.</p>
    #[doc(hidden)]
    pub created_at: std::option::Option<aws_smithy_types::DateTime>,
}
impl Network {
    /// <p>The Amazon Resource Name (ARN) of the network.</p>
    pub fn network_arn(&self) -> std::option::Option<&str> {
        self.network_arn.as_deref()
    }
    /// <p>The name of the network.</p>
    pub fn network_name(&self) -> std::option::Option<&str> {
        self.network_name.as_deref()
    }
    /// <p>The description of the network.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>The status of the network.</p>
    pub fn status(&self) -> std::option::Option<&crate::model::NetworkStatus> {
        self.status.as_ref()
    }
    /// <p>The status reason of the network.</p>
    pub fn status_reason(&self) -> std::option::Option<&str> {
        self.status_reason.as_deref()
    }
    /// <p>The creation time of the network.</p>
    pub fn created_at(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.created_at.as_ref()
    }
}
/// See [`Network`](crate::model::Network).
pub mod network {

    /// A builder for [`Network`](crate::model::Network).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) network_arn: std::option::Option<std::string::String>,
        pub(crate) network_name: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) status: std::option::Option<crate::model::NetworkStatus>,
        pub(crate) status_reason: std::option::Option<std::string::String>,
        pub(crate) created_at: std::option::Option<aws_smithy_types::DateTime>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the network.</p>
        pub fn network_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.network_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the network.</p>
        pub fn set_network_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.network_arn = input;
            self
        }
        /// <p>The name of the network.</p>
        pub fn network_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.network_name = Some(input.into());
            self
        }
        /// <p>The name of the network.</p>
        pub fn set_network_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.network_name = input;
            self
        }
        /// <p>The description of the network.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>The description of the network.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>The status of the network.</p>
        pub fn status(mut self, input: crate::model::NetworkStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The status of the network.</p>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::NetworkStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// <p>The status reason of the network.</p>
        pub fn status_reason(mut self, input: impl Into<std::string::String>) -> Self {
            self.status_reason = Some(input.into());
            self
        }
        /// <p>The status reason of the network.</p>
        pub fn set_status_reason(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.status_reason = input;
            self
        }
        /// <p>The creation time of the network.</p>
        pub fn created_at(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.created_at = Some(input);
            self
        }
        /// <p>The creation time of the network.</p>
        pub fn set_created_at(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.created_at = input;
            self
        }
        /// Consumes the builder and constructs a [`Network`](crate::model::Network).
        pub fn build(self) -> crate::model::Network {
            crate::model::Network {
                network_arn: self.network_arn,
                network_name: self.network_name,
                description: self.description,
                status: self.status,
                status_reason: self.status_reason,
                created_at: self.created_at,
            }
        }
    }
}
impl Network {
    /// Creates a new builder-style object to manufacture [`Network`](crate::model::Network).
    pub fn builder() -> crate::model::network::Builder {
        crate::model::network::Builder::default()
    }
}

/// When writing a match expression against `NetworkStatus`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let networkstatus = unimplemented!();
/// match networkstatus {
///     NetworkStatus::Available => { /* ... */ },
///     NetworkStatus::Created => { /* ... */ },
///     NetworkStatus::Deleted => { /* ... */ },
///     NetworkStatus::Deprovisioning => { /* ... */ },
///     NetworkStatus::Provisioning => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `networkstatus` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `NetworkStatus::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `NetworkStatus::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `NetworkStatus::NewFeature` is defined.
/// Specifically, when `networkstatus` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `NetworkStatus::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum NetworkStatus {
    #[allow(missing_docs)] // documentation missing in model
    Available,
    #[allow(missing_docs)] // documentation missing in model
    Created,
    #[allow(missing_docs)] // documentation missing in model
    Deleted,
    #[allow(missing_docs)] // documentation missing in model
    Deprovisioning,
    #[allow(missing_docs)] // documentation missing in model
    Provisioning,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for NetworkStatus {
    fn from(s: &str) -> Self {
        match s {
            "AVAILABLE" => NetworkStatus::Available,
            "CREATED" => NetworkStatus::Created,
            "DELETED" => NetworkStatus::Deleted,
            "DEPROVISIONING" => NetworkStatus::Deprovisioning,
            "PROVISIONING" => NetworkStatus::Provisioning,
            other => NetworkStatus::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for NetworkStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(NetworkStatus::from(s))
    }
}
impl NetworkStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            NetworkStatus::Available => "AVAILABLE",
            NetworkStatus::Created => "CREATED",
            NetworkStatus::Deleted => "DELETED",
            NetworkStatus::Deprovisioning => "DEPROVISIONING",
            NetworkStatus::Provisioning => "PROVISIONING",
            NetworkStatus::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "AVAILABLE",
            "CREATED",
            "DELETED",
            "DEPROVISIONING",
            "PROVISIONING",
        ]
    }
}
impl AsRef<str> for NetworkStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `NetworkFilterKeys`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let networkfilterkeys = unimplemented!();
/// match networkfilterkeys {
///     NetworkFilterKeys::Status => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `networkfilterkeys` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `NetworkFilterKeys::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `NetworkFilterKeys::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `NetworkFilterKeys::NewFeature` is defined.
/// Specifically, when `networkfilterkeys` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `NetworkFilterKeys::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum NetworkFilterKeys {
    #[allow(missing_docs)] // documentation missing in model
    Status,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for NetworkFilterKeys {
    fn from(s: &str) -> Self {
        match s {
            "STATUS" => NetworkFilterKeys::Status,
            other => {
                NetworkFilterKeys::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for NetworkFilterKeys {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(NetworkFilterKeys::from(s))
    }
}
impl NetworkFilterKeys {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            NetworkFilterKeys::Status => "STATUS",
            NetworkFilterKeys::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["STATUS"]
    }
}
impl AsRef<str> for NetworkFilterKeys {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Information about a network resource.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct NetworkResource {
    /// <p>The Amazon Resource Name (ARN) of the network resource.</p>
    #[doc(hidden)]
    pub network_resource_arn: std::option::Option<std::string::String>,
    /// <p>The description of the network resource.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p>The type of the network resource.</p>
    #[doc(hidden)]
    pub r#type: std::option::Option<crate::model::NetworkResourceType>,
    /// <p>The status of the network resource.</p>
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::NetworkResourceStatus>,
    /// <p>The status reason of the network resource.</p>
    #[doc(hidden)]
    pub status_reason: std::option::Option<std::string::String>,
    /// <p>The vendor of the network resource.</p>
    #[doc(hidden)]
    pub vendor: std::option::Option<std::string::String>,
    /// <p>The model of the network resource.</p>
    #[doc(hidden)]
    pub model: std::option::Option<std::string::String>,
    /// <p>The serial number of the network resource.</p>
    #[doc(hidden)]
    pub serial_number: std::option::Option<std::string::String>,
    /// <p>The health of the network resource.</p>
    #[doc(hidden)]
    pub health: std::option::Option<crate::model::HealthStatus>,
    /// <p>The Amazon Resource Name (ARN) of the network on which this network resource appears.</p>
    #[doc(hidden)]
    pub network_arn: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the network site on which this network resource appears.</p>
    #[doc(hidden)]
    pub network_site_arn: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the order used to purchase this network resource.</p>
    #[doc(hidden)]
    pub order_arn: std::option::Option<std::string::String>,
    /// <p>The attributes of the network resource.</p>
    #[doc(hidden)]
    pub attributes: std::option::Option<std::vec::Vec<crate::model::NameValuePair>>,
    /// <p>The position of the network resource.</p>
    #[doc(hidden)]
    pub position: std::option::Option<crate::model::Position>,
    /// <p>The creation time of the network resource.</p>
    #[doc(hidden)]
    pub created_at: std::option::Option<aws_smithy_types::DateTime>,
}
impl NetworkResource {
    /// <p>The Amazon Resource Name (ARN) of the network resource.</p>
    pub fn network_resource_arn(&self) -> std::option::Option<&str> {
        self.network_resource_arn.as_deref()
    }
    /// <p>The description of the network resource.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>The type of the network resource.</p>
    pub fn r#type(&self) -> std::option::Option<&crate::model::NetworkResourceType> {
        self.r#type.as_ref()
    }
    /// <p>The status of the network resource.</p>
    pub fn status(&self) -> std::option::Option<&crate::model::NetworkResourceStatus> {
        self.status.as_ref()
    }
    /// <p>The status reason of the network resource.</p>
    pub fn status_reason(&self) -> std::option::Option<&str> {
        self.status_reason.as_deref()
    }
    /// <p>The vendor of the network resource.</p>
    pub fn vendor(&self) -> std::option::Option<&str> {
        self.vendor.as_deref()
    }
    /// <p>The model of the network resource.</p>
    pub fn model(&self) -> std::option::Option<&str> {
        self.model.as_deref()
    }
    /// <p>The serial number of the network resource.</p>
    pub fn serial_number(&self) -> std::option::Option<&str> {
        self.serial_number.as_deref()
    }
    /// <p>The health of the network resource.</p>
    pub fn health(&self) -> std::option::Option<&crate::model::HealthStatus> {
        self.health.as_ref()
    }
    /// <p>The Amazon Resource Name (ARN) of the network on which this network resource appears.</p>
    pub fn network_arn(&self) -> std::option::Option<&str> {
        self.network_arn.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the network site on which this network resource appears.</p>
    pub fn network_site_arn(&self) -> std::option::Option<&str> {
        self.network_site_arn.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the order used to purchase this network resource.</p>
    pub fn order_arn(&self) -> std::option::Option<&str> {
        self.order_arn.as_deref()
    }
    /// <p>The attributes of the network resource.</p>
    pub fn attributes(&self) -> std::option::Option<&[crate::model::NameValuePair]> {
        self.attributes.as_deref()
    }
    /// <p>The position of the network resource.</p>
    pub fn position(&self) -> std::option::Option<&crate::model::Position> {
        self.position.as_ref()
    }
    /// <p>The creation time of the network resource.</p>
    pub fn created_at(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.created_at.as_ref()
    }
}
/// See [`NetworkResource`](crate::model::NetworkResource).
pub mod network_resource {

    /// A builder for [`NetworkResource`](crate::model::NetworkResource).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) network_resource_arn: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) r#type: std::option::Option<crate::model::NetworkResourceType>,
        pub(crate) status: std::option::Option<crate::model::NetworkResourceStatus>,
        pub(crate) status_reason: std::option::Option<std::string::String>,
        pub(crate) vendor: std::option::Option<std::string::String>,
        pub(crate) model: std::option::Option<std::string::String>,
        pub(crate) serial_number: std::option::Option<std::string::String>,
        pub(crate) health: std::option::Option<crate::model::HealthStatus>,
        pub(crate) network_arn: std::option::Option<std::string::String>,
        pub(crate) network_site_arn: std::option::Option<std::string::String>,
        pub(crate) order_arn: std::option::Option<std::string::String>,
        pub(crate) attributes: std::option::Option<std::vec::Vec<crate::model::NameValuePair>>,
        pub(crate) position: std::option::Option<crate::model::Position>,
        pub(crate) created_at: std::option::Option<aws_smithy_types::DateTime>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the network resource.</p>
        pub fn network_resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.network_resource_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the network resource.</p>
        pub fn set_network_resource_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.network_resource_arn = input;
            self
        }
        /// <p>The description of the network resource.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>The description of the network resource.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>The type of the network resource.</p>
        pub fn r#type(mut self, input: crate::model::NetworkResourceType) -> Self {
            self.r#type = Some(input);
            self
        }
        /// <p>The type of the network resource.</p>
        pub fn set_type(
            mut self,
            input: std::option::Option<crate::model::NetworkResourceType>,
        ) -> Self {
            self.r#type = input;
            self
        }
        /// <p>The status of the network resource.</p>
        pub fn status(mut self, input: crate::model::NetworkResourceStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The status of the network resource.</p>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::NetworkResourceStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// <p>The status reason of the network resource.</p>
        pub fn status_reason(mut self, input: impl Into<std::string::String>) -> Self {
            self.status_reason = Some(input.into());
            self
        }
        /// <p>The status reason of the network resource.</p>
        pub fn set_status_reason(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.status_reason = input;
            self
        }
        /// <p>The vendor of the network resource.</p>
        pub fn vendor(mut self, input: impl Into<std::string::String>) -> Self {
            self.vendor = Some(input.into());
            self
        }
        /// <p>The vendor of the network resource.</p>
        pub fn set_vendor(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.vendor = input;
            self
        }
        /// <p>The model of the network resource.</p>
        pub fn model(mut self, input: impl Into<std::string::String>) -> Self {
            self.model = Some(input.into());
            self
        }
        /// <p>The model of the network resource.</p>
        pub fn set_model(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.model = input;
            self
        }
        /// <p>The serial number of the network resource.</p>
        pub fn serial_number(mut self, input: impl Into<std::string::String>) -> Self {
            self.serial_number = Some(input.into());
            self
        }
        /// <p>The serial number of the network resource.</p>
        pub fn set_serial_number(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.serial_number = input;
            self
        }
        /// <p>The health of the network resource.</p>
        pub fn health(mut self, input: crate::model::HealthStatus) -> Self {
            self.health = Some(input);
            self
        }
        /// <p>The health of the network resource.</p>
        pub fn set_health(
            mut self,
            input: std::option::Option<crate::model::HealthStatus>,
        ) -> Self {
            self.health = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the network on which this network resource appears.</p>
        pub fn network_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.network_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the network on which this network resource appears.</p>
        pub fn set_network_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.network_arn = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the network site on which this network resource appears.</p>
        pub fn network_site_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.network_site_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the network site on which this network resource appears.</p>
        pub fn set_network_site_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.network_site_arn = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the order used to purchase this network resource.</p>
        pub fn order_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.order_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the order used to purchase this network resource.</p>
        pub fn set_order_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.order_arn = input;
            self
        }
        /// Appends an item to `attributes`.
        ///
        /// To override the contents of this collection use [`set_attributes`](Self::set_attributes).
        ///
        /// <p>The attributes of the network resource.</p>
        pub fn attributes(mut self, input: crate::model::NameValuePair) -> Self {
            let mut v = self.attributes.unwrap_or_default();
            v.push(input);
            self.attributes = Some(v);
            self
        }
        /// <p>The attributes of the network resource.</p>
        pub fn set_attributes(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::NameValuePair>>,
        ) -> Self {
            self.attributes = input;
            self
        }
        /// <p>The position of the network resource.</p>
        pub fn position(mut self, input: crate::model::Position) -> Self {
            self.position = Some(input);
            self
        }
        /// <p>The position of the network resource.</p>
        pub fn set_position(mut self, input: std::option::Option<crate::model::Position>) -> Self {
            self.position = input;
            self
        }
        /// <p>The creation time of the network resource.</p>
        pub fn created_at(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.created_at = Some(input);
            self
        }
        /// <p>The creation time of the network resource.</p>
        pub fn set_created_at(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.created_at = input;
            self
        }
        /// Consumes the builder and constructs a [`NetworkResource`](crate::model::NetworkResource).
        pub fn build(self) -> crate::model::NetworkResource {
            crate::model::NetworkResource {
                network_resource_arn: self.network_resource_arn,
                description: self.description,
                r#type: self.r#type,
                status: self.status,
                status_reason: self.status_reason,
                vendor: self.vendor,
                model: self.model,
                serial_number: self.serial_number,
                health: self.health,
                network_arn: self.network_arn,
                network_site_arn: self.network_site_arn,
                order_arn: self.order_arn,
                attributes: self.attributes,
                position: self.position,
                created_at: self.created_at,
            }
        }
    }
}
impl NetworkResource {
    /// Creates a new builder-style object to manufacture [`NetworkResource`](crate::model::NetworkResource).
    pub fn builder() -> crate::model::network_resource::Builder {
        crate::model::network_resource::Builder::default()
    }
}

/// <p>Information about a position.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Position {
    /// <p>The latitude of the position.</p>
    #[doc(hidden)]
    pub latitude: std::option::Option<f64>,
    /// <p>The longitude of the position.</p>
    #[doc(hidden)]
    pub longitude: std::option::Option<f64>,
    /// <p>The elevation of the equipment at this position.</p>
    #[doc(hidden)]
    pub elevation: std::option::Option<f64>,
    /// <p>The units used to measure the elevation of the position.</p>
    #[doc(hidden)]
    pub elevation_unit: std::option::Option<crate::model::ElevationUnit>,
    /// <p>The reference point from which elevation is reported.</p>
    #[doc(hidden)]
    pub elevation_reference: std::option::Option<crate::model::ElevationReference>,
}
impl Position {
    /// <p>The latitude of the position.</p>
    pub fn latitude(&self) -> std::option::Option<f64> {
        self.latitude
    }
    /// <p>The longitude of the position.</p>
    pub fn longitude(&self) -> std::option::Option<f64> {
        self.longitude
    }
    /// <p>The elevation of the equipment at this position.</p>
    pub fn elevation(&self) -> std::option::Option<f64> {
        self.elevation
    }
    /// <p>The units used to measure the elevation of the position.</p>
    pub fn elevation_unit(&self) -> std::option::Option<&crate::model::ElevationUnit> {
        self.elevation_unit.as_ref()
    }
    /// <p>The reference point from which elevation is reported.</p>
    pub fn elevation_reference(&self) -> std::option::Option<&crate::model::ElevationReference> {
        self.elevation_reference.as_ref()
    }
}
/// See [`Position`](crate::model::Position).
pub mod position {

    /// A builder for [`Position`](crate::model::Position).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) latitude: std::option::Option<f64>,
        pub(crate) longitude: std::option::Option<f64>,
        pub(crate) elevation: std::option::Option<f64>,
        pub(crate) elevation_unit: std::option::Option<crate::model::ElevationUnit>,
        pub(crate) elevation_reference: std::option::Option<crate::model::ElevationReference>,
    }
    impl Builder {
        /// <p>The latitude of the position.</p>
        pub fn latitude(mut self, input: f64) -> Self {
            self.latitude = Some(input);
            self
        }
        /// <p>The latitude of the position.</p>
        pub fn set_latitude(mut self, input: std::option::Option<f64>) -> Self {
            self.latitude = input;
            self
        }
        /// <p>The longitude of the position.</p>
        pub fn longitude(mut self, input: f64) -> Self {
            self.longitude = Some(input);
            self
        }
        /// <p>The longitude of the position.</p>
        pub fn set_longitude(mut self, input: std::option::Option<f64>) -> Self {
            self.longitude = input;
            self
        }
        /// <p>The elevation of the equipment at this position.</p>
        pub fn elevation(mut self, input: f64) -> Self {
            self.elevation = Some(input);
            self
        }
        /// <p>The elevation of the equipment at this position.</p>
        pub fn set_elevation(mut self, input: std::option::Option<f64>) -> Self {
            self.elevation = input;
            self
        }
        /// <p>The units used to measure the elevation of the position.</p>
        pub fn elevation_unit(mut self, input: crate::model::ElevationUnit) -> Self {
            self.elevation_unit = Some(input);
            self
        }
        /// <p>The units used to measure the elevation of the position.</p>
        pub fn set_elevation_unit(
            mut self,
            input: std::option::Option<crate::model::ElevationUnit>,
        ) -> Self {
            self.elevation_unit = input;
            self
        }
        /// <p>The reference point from which elevation is reported.</p>
        pub fn elevation_reference(mut self, input: crate::model::ElevationReference) -> Self {
            self.elevation_reference = Some(input);
            self
        }
        /// <p>The reference point from which elevation is reported.</p>
        pub fn set_elevation_reference(
            mut self,
            input: std::option::Option<crate::model::ElevationReference>,
        ) -> Self {
            self.elevation_reference = input;
            self
        }
        /// Consumes the builder and constructs a [`Position`](crate::model::Position).
        pub fn build(self) -> crate::model::Position {
            crate::model::Position {
                latitude: self.latitude,
                longitude: self.longitude,
                elevation: self.elevation,
                elevation_unit: self.elevation_unit,
                elevation_reference: self.elevation_reference,
            }
        }
    }
}
impl Position {
    /// Creates a new builder-style object to manufacture [`Position`](crate::model::Position).
    pub fn builder() -> crate::model::position::Builder {
        crate::model::position::Builder::default()
    }
}

/// When writing a match expression against `ElevationReference`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let elevationreference = unimplemented!();
/// match elevationreference {
///     ElevationReference::Agl => { /* ... */ },
///     ElevationReference::Amsl => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `elevationreference` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ElevationReference::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ElevationReference::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ElevationReference::NewFeature` is defined.
/// Specifically, when `elevationreference` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ElevationReference::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ElevationReference {
    #[allow(missing_docs)] // documentation missing in model
    Agl,
    #[allow(missing_docs)] // documentation missing in model
    Amsl,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ElevationReference {
    fn from(s: &str) -> Self {
        match s {
            "AGL" => ElevationReference::Agl,
            "AMSL" => ElevationReference::Amsl,
            other => {
                ElevationReference::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for ElevationReference {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ElevationReference::from(s))
    }
}
impl ElevationReference {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ElevationReference::Agl => "AGL",
            ElevationReference::Amsl => "AMSL",
            ElevationReference::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["AGL", "AMSL"]
    }
}
impl AsRef<str> for ElevationReference {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `ElevationUnit`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let elevationunit = unimplemented!();
/// match elevationunit {
///     ElevationUnit::Feet => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `elevationunit` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ElevationUnit::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ElevationUnit::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ElevationUnit::NewFeature` is defined.
/// Specifically, when `elevationunit` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ElevationUnit::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ElevationUnit {
    /// Feet.
    Feet,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ElevationUnit {
    fn from(s: &str) -> Self {
        match s {
            "FEET" => ElevationUnit::Feet,
            other => ElevationUnit::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for ElevationUnit {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ElevationUnit::from(s))
    }
}
impl ElevationUnit {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ElevationUnit::Feet => "FEET",
            ElevationUnit::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["FEET"]
    }
}
impl AsRef<str> for ElevationUnit {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `HealthStatus`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let healthstatus = unimplemented!();
/// match healthstatus {
///     HealthStatus::Healthy => { /* ... */ },
///     HealthStatus::Initial => { /* ... */ },
///     HealthStatus::Unhealthy => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `healthstatus` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `HealthStatus::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `HealthStatus::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `HealthStatus::NewFeature` is defined.
/// Specifically, when `healthstatus` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `HealthStatus::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum HealthStatus {
    #[allow(missing_docs)] // documentation missing in model
    Healthy,
    #[allow(missing_docs)] // documentation missing in model
    Initial,
    #[allow(missing_docs)] // documentation missing in model
    Unhealthy,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for HealthStatus {
    fn from(s: &str) -> Self {
        match s {
            "HEALTHY" => HealthStatus::Healthy,
            "INITIAL" => HealthStatus::Initial,
            "UNHEALTHY" => HealthStatus::Unhealthy,
            other => HealthStatus::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for HealthStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(HealthStatus::from(s))
    }
}
impl HealthStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            HealthStatus::Healthy => "HEALTHY",
            HealthStatus::Initial => "INITIAL",
            HealthStatus::Unhealthy => "UNHEALTHY",
            HealthStatus::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["HEALTHY", "INITIAL", "UNHEALTHY"]
    }
}
impl AsRef<str> for HealthStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `NetworkResourceStatus`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let networkresourcestatus = unimplemented!();
/// match networkresourcestatus {
///     NetworkResourceStatus::Available => { /* ... */ },
///     NetworkResourceStatus::Deleted => { /* ... */ },
///     NetworkResourceStatus::Deleting => { /* ... */ },
///     NetworkResourceStatus::Pending => { /* ... */ },
///     NetworkResourceStatus::PendingReturn => { /* ... */ },
///     NetworkResourceStatus::Provisioned => { /* ... */ },
///     NetworkResourceStatus::Provisioning => { /* ... */ },
///     NetworkResourceStatus::Shipped => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `networkresourcestatus` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `NetworkResourceStatus::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `NetworkResourceStatus::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `NetworkResourceStatus::NewFeature` is defined.
/// Specifically, when `networkresourcestatus` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `NetworkResourceStatus::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum NetworkResourceStatus {
    #[allow(missing_docs)] // documentation missing in model
    Available,
    #[allow(missing_docs)] // documentation missing in model
    Deleted,
    #[allow(missing_docs)] // documentation missing in model
    Deleting,
    #[allow(missing_docs)] // documentation missing in model
    Pending,
    #[allow(missing_docs)] // documentation missing in model
    PendingReturn,
    #[allow(missing_docs)] // documentation missing in model
    Provisioned,
    #[allow(missing_docs)] // documentation missing in model
    Provisioning,
    #[allow(missing_docs)] // documentation missing in model
    Shipped,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for NetworkResourceStatus {
    fn from(s: &str) -> Self {
        match s {
            "AVAILABLE" => NetworkResourceStatus::Available,
            "DELETED" => NetworkResourceStatus::Deleted,
            "DELETING" => NetworkResourceStatus::Deleting,
            "PENDING" => NetworkResourceStatus::Pending,
            "PENDING_RETURN" => NetworkResourceStatus::PendingReturn,
            "PROVISIONED" => NetworkResourceStatus::Provisioned,
            "PROVISIONING" => NetworkResourceStatus::Provisioning,
            "SHIPPED" => NetworkResourceStatus::Shipped,
            other => {
                NetworkResourceStatus::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for NetworkResourceStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(NetworkResourceStatus::from(s))
    }
}
impl NetworkResourceStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            NetworkResourceStatus::Available => "AVAILABLE",
            NetworkResourceStatus::Deleted => "DELETED",
            NetworkResourceStatus::Deleting => "DELETING",
            NetworkResourceStatus::Pending => "PENDING",
            NetworkResourceStatus::PendingReturn => "PENDING_RETURN",
            NetworkResourceStatus::Provisioned => "PROVISIONED",
            NetworkResourceStatus::Provisioning => "PROVISIONING",
            NetworkResourceStatus::Shipped => "SHIPPED",
            NetworkResourceStatus::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "AVAILABLE",
            "DELETED",
            "DELETING",
            "PENDING",
            "PENDING_RETURN",
            "PROVISIONED",
            "PROVISIONING",
            "SHIPPED",
        ]
    }
}
impl AsRef<str> for NetworkResourceStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `NetworkResourceType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let networkresourcetype = unimplemented!();
/// match networkresourcetype {
///     NetworkResourceType::RadioUnit => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `networkresourcetype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `NetworkResourceType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `NetworkResourceType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `NetworkResourceType::NewFeature` is defined.
/// Specifically, when `networkresourcetype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `NetworkResourceType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum NetworkResourceType {
    #[allow(missing_docs)] // documentation missing in model
    RadioUnit,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for NetworkResourceType {
    fn from(s: &str) -> Self {
        match s {
            "RADIO_UNIT" => NetworkResourceType::RadioUnit,
            other => {
                NetworkResourceType::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for NetworkResourceType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(NetworkResourceType::from(s))
    }
}
impl NetworkResourceType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            NetworkResourceType::RadioUnit => "RADIO_UNIT",
            NetworkResourceType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["RADIO_UNIT"]
    }
}
impl AsRef<str> for NetworkResourceType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `NetworkResourceFilterKeys`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let networkresourcefilterkeys = unimplemented!();
/// match networkresourcefilterkeys {
///     NetworkResourceFilterKeys::Order => { /* ... */ },
///     NetworkResourceFilterKeys::Status => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `networkresourcefilterkeys` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `NetworkResourceFilterKeys::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `NetworkResourceFilterKeys::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `NetworkResourceFilterKeys::NewFeature` is defined.
/// Specifically, when `networkresourcefilterkeys` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `NetworkResourceFilterKeys::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum NetworkResourceFilterKeys {
    #[allow(missing_docs)] // documentation missing in model
    Order,
    #[allow(missing_docs)] // documentation missing in model
    Status,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for NetworkResourceFilterKeys {
    fn from(s: &str) -> Self {
        match s {
            "ORDER" => NetworkResourceFilterKeys::Order,
            "STATUS" => NetworkResourceFilterKeys::Status,
            other => NetworkResourceFilterKeys::Unknown(crate::types::UnknownVariantValue(
                other.to_owned(),
            )),
        }
    }
}
impl std::str::FromStr for NetworkResourceFilterKeys {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(NetworkResourceFilterKeys::from(s))
    }
}
impl NetworkResourceFilterKeys {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            NetworkResourceFilterKeys::Order => "ORDER",
            NetworkResourceFilterKeys::Status => "STATUS",
            NetworkResourceFilterKeys::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["ORDER", "STATUS"]
    }
}
impl AsRef<str> for NetworkResourceFilterKeys {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Information about a subscriber of a device that can use a network.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeviceIdentifier {
    /// <p>The Amazon Resource Name (ARN) of the device identifier.</p>
    #[doc(hidden)]
    pub device_identifier_arn: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the traffic group to which the device identifier belongs.</p>
    #[doc(hidden)]
    pub traffic_group_arn: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the network on which the device identifier appears.</p>
    #[doc(hidden)]
    pub network_arn: std::option::Option<std::string::String>,
    /// <p>The International Mobile Subscriber Identity of the device identifier.</p>
    #[doc(hidden)]
    pub imsi: std::option::Option<std::string::String>,
    /// <p>The Integrated Circuit Card Identifier of the device identifier.</p>
    #[doc(hidden)]
    pub iccid: std::option::Option<std::string::String>,
    /// <p>The vendor of the device identifier.</p>
    #[doc(hidden)]
    pub vendor: std::option::Option<std::string::String>,
    /// <p>The status of the device identifier.</p>
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::DeviceIdentifierStatus>,
    /// <p>The Amazon Resource Name (ARN) of the order used to purchase the device identifier.</p>
    #[doc(hidden)]
    pub order_arn: std::option::Option<std::string::String>,
    /// <p>The creation time of this device identifier.</p>
    #[doc(hidden)]
    pub created_at: std::option::Option<aws_smithy_types::DateTime>,
}
impl DeviceIdentifier {
    /// <p>The Amazon Resource Name (ARN) of the device identifier.</p>
    pub fn device_identifier_arn(&self) -> std::option::Option<&str> {
        self.device_identifier_arn.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the traffic group to which the device identifier belongs.</p>
    pub fn traffic_group_arn(&self) -> std::option::Option<&str> {
        self.traffic_group_arn.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the network on which the device identifier appears.</p>
    pub fn network_arn(&self) -> std::option::Option<&str> {
        self.network_arn.as_deref()
    }
    /// <p>The International Mobile Subscriber Identity of the device identifier.</p>
    pub fn imsi(&self) -> std::option::Option<&str> {
        self.imsi.as_deref()
    }
    /// <p>The Integrated Circuit Card Identifier of the device identifier.</p>
    pub fn iccid(&self) -> std::option::Option<&str> {
        self.iccid.as_deref()
    }
    /// <p>The vendor of the device identifier.</p>
    pub fn vendor(&self) -> std::option::Option<&str> {
        self.vendor.as_deref()
    }
    /// <p>The status of the device identifier.</p>
    pub fn status(&self) -> std::option::Option<&crate::model::DeviceIdentifierStatus> {
        self.status.as_ref()
    }
    /// <p>The Amazon Resource Name (ARN) of the order used to purchase the device identifier.</p>
    pub fn order_arn(&self) -> std::option::Option<&str> {
        self.order_arn.as_deref()
    }
    /// <p>The creation time of this device identifier.</p>
    pub fn created_at(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.created_at.as_ref()
    }
}
impl std::fmt::Debug for DeviceIdentifier {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeviceIdentifier");
        formatter.field("device_identifier_arn", &self.device_identifier_arn);
        formatter.field("traffic_group_arn", &self.traffic_group_arn);
        formatter.field("network_arn", &self.network_arn);
        formatter.field("imsi", &"*** Sensitive Data Redacted ***");
        formatter.field("iccid", &self.iccid);
        formatter.field("vendor", &self.vendor);
        formatter.field("status", &self.status);
        formatter.field("order_arn", &self.order_arn);
        formatter.field("created_at", &self.created_at);
        formatter.finish()
    }
}
/// See [`DeviceIdentifier`](crate::model::DeviceIdentifier).
pub mod device_identifier {

    /// A builder for [`DeviceIdentifier`](crate::model::DeviceIdentifier).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default)]
    pub struct Builder {
        pub(crate) device_identifier_arn: std::option::Option<std::string::String>,
        pub(crate) traffic_group_arn: std::option::Option<std::string::String>,
        pub(crate) network_arn: std::option::Option<std::string::String>,
        pub(crate) imsi: std::option::Option<std::string::String>,
        pub(crate) iccid: std::option::Option<std::string::String>,
        pub(crate) vendor: std::option::Option<std::string::String>,
        pub(crate) status: std::option::Option<crate::model::DeviceIdentifierStatus>,
        pub(crate) order_arn: std::option::Option<std::string::String>,
        pub(crate) created_at: std::option::Option<aws_smithy_types::DateTime>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the device identifier.</p>
        pub fn device_identifier_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.device_identifier_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the device identifier.</p>
        pub fn set_device_identifier_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.device_identifier_arn = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the traffic group to which the device identifier belongs.</p>
        pub fn traffic_group_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.traffic_group_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the traffic group to which the device identifier belongs.</p>
        pub fn set_traffic_group_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.traffic_group_arn = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the network on which the device identifier appears.</p>
        pub fn network_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.network_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the network on which the device identifier appears.</p>
        pub fn set_network_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.network_arn = input;
            self
        }
        /// <p>The International Mobile Subscriber Identity of the device identifier.</p>
        pub fn imsi(mut self, input: impl Into<std::string::String>) -> Self {
            self.imsi = Some(input.into());
            self
        }
        /// <p>The International Mobile Subscriber Identity of the device identifier.</p>
        pub fn set_imsi(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.imsi = input;
            self
        }
        /// <p>The Integrated Circuit Card Identifier of the device identifier.</p>
        pub fn iccid(mut self, input: impl Into<std::string::String>) -> Self {
            self.iccid = Some(input.into());
            self
        }
        /// <p>The Integrated Circuit Card Identifier of the device identifier.</p>
        pub fn set_iccid(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.iccid = input;
            self
        }
        /// <p>The vendor of the device identifier.</p>
        pub fn vendor(mut self, input: impl Into<std::string::String>) -> Self {
            self.vendor = Some(input.into());
            self
        }
        /// <p>The vendor of the device identifier.</p>
        pub fn set_vendor(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.vendor = input;
            self
        }
        /// <p>The status of the device identifier.</p>
        pub fn status(mut self, input: crate::model::DeviceIdentifierStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The status of the device identifier.</p>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::DeviceIdentifierStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the order used to purchase the device identifier.</p>
        pub fn order_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.order_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the order used to purchase the device identifier.</p>
        pub fn set_order_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.order_arn = input;
            self
        }
        /// <p>The creation time of this device identifier.</p>
        pub fn created_at(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.created_at = Some(input);
            self
        }
        /// <p>The creation time of this device identifier.</p>
        pub fn set_created_at(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.created_at = input;
            self
        }
        /// Consumes the builder and constructs a [`DeviceIdentifier`](crate::model::DeviceIdentifier).
        pub fn build(self) -> crate::model::DeviceIdentifier {
            crate::model::DeviceIdentifier {
                device_identifier_arn: self.device_identifier_arn,
                traffic_group_arn: self.traffic_group_arn,
                network_arn: self.network_arn,
                imsi: self.imsi,
                iccid: self.iccid,
                vendor: self.vendor,
                status: self.status,
                order_arn: self.order_arn,
                created_at: self.created_at,
            }
        }
    }
    impl std::fmt::Debug for Builder {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut formatter = f.debug_struct("Builder");
            formatter.field("device_identifier_arn", &self.device_identifier_arn);
            formatter.field("traffic_group_arn", &self.traffic_group_arn);
            formatter.field("network_arn", &self.network_arn);
            formatter.field("imsi", &"*** Sensitive Data Redacted ***");
            formatter.field("iccid", &self.iccid);
            formatter.field("vendor", &self.vendor);
            formatter.field("status", &self.status);
            formatter.field("order_arn", &self.order_arn);
            formatter.field("created_at", &self.created_at);
            formatter.finish()
        }
    }
}
impl DeviceIdentifier {
    /// Creates a new builder-style object to manufacture [`DeviceIdentifier`](crate::model::DeviceIdentifier).
    pub fn builder() -> crate::model::device_identifier::Builder {
        crate::model::device_identifier::Builder::default()
    }
}

/// When writing a match expression against `DeviceIdentifierStatus`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let deviceidentifierstatus = unimplemented!();
/// match deviceidentifierstatus {
///     DeviceIdentifierStatus::Active => { /* ... */ },
///     DeviceIdentifierStatus::Inactive => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `deviceidentifierstatus` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `DeviceIdentifierStatus::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `DeviceIdentifierStatus::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `DeviceIdentifierStatus::NewFeature` is defined.
/// Specifically, when `deviceidentifierstatus` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `DeviceIdentifierStatus::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum DeviceIdentifierStatus {
    #[allow(missing_docs)] // documentation missing in model
    Active,
    #[allow(missing_docs)] // documentation missing in model
    Inactive,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for DeviceIdentifierStatus {
    fn from(s: &str) -> Self {
        match s {
            "ACTIVE" => DeviceIdentifierStatus::Active,
            "INACTIVE" => DeviceIdentifierStatus::Inactive,
            other => {
                DeviceIdentifierStatus::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for DeviceIdentifierStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(DeviceIdentifierStatus::from(s))
    }
}
impl DeviceIdentifierStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            DeviceIdentifierStatus::Active => "ACTIVE",
            DeviceIdentifierStatus::Inactive => "INACTIVE",
            DeviceIdentifierStatus::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["ACTIVE", "INACTIVE"]
    }
}
impl AsRef<str> for DeviceIdentifierStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `DeviceIdentifierFilterKeys`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let deviceidentifierfilterkeys = unimplemented!();
/// match deviceidentifierfilterkeys {
///     DeviceIdentifierFilterKeys::Order => { /* ... */ },
///     DeviceIdentifierFilterKeys::Status => { /* ... */ },
///     DeviceIdentifierFilterKeys::TrafficGroup => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `deviceidentifierfilterkeys` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `DeviceIdentifierFilterKeys::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `DeviceIdentifierFilterKeys::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `DeviceIdentifierFilterKeys::NewFeature` is defined.
/// Specifically, when `deviceidentifierfilterkeys` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `DeviceIdentifierFilterKeys::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum DeviceIdentifierFilterKeys {
    #[allow(missing_docs)] // documentation missing in model
    Order,
    #[allow(missing_docs)] // documentation missing in model
    Status,
    #[allow(missing_docs)] // documentation missing in model
    TrafficGroup,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for DeviceIdentifierFilterKeys {
    fn from(s: &str) -> Self {
        match s {
            "ORDER" => DeviceIdentifierFilterKeys::Order,
            "STATUS" => DeviceIdentifierFilterKeys::Status,
            "TRAFFIC_GROUP" => DeviceIdentifierFilterKeys::TrafficGroup,
            other => DeviceIdentifierFilterKeys::Unknown(crate::types::UnknownVariantValue(
                other.to_owned(),
            )),
        }
    }
}
impl std::str::FromStr for DeviceIdentifierFilterKeys {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(DeviceIdentifierFilterKeys::from(s))
    }
}
impl DeviceIdentifierFilterKeys {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            DeviceIdentifierFilterKeys::Order => "ORDER",
            DeviceIdentifierFilterKeys::Status => "STATUS",
            DeviceIdentifierFilterKeys::TrafficGroup => "TRAFFIC_GROUP",
            DeviceIdentifierFilterKeys::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["ORDER", "STATUS", "TRAFFIC_GROUP"]
    }
}
impl AsRef<str> for DeviceIdentifierFilterKeys {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}
