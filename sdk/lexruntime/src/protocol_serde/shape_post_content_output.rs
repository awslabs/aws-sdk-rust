// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
pub(crate) fn de_active_contexts_header(
    header_map: &::http::HeaderMap,
) -> std::result::Result<::std::option::Option<::std::string::String>, ::aws_smithy_http::header::ParseError> {
    let headers = header_map.get_all("x-amz-lex-active-contexts").iter();
    let var_1: Vec<::std::string::String> = ::aws_smithy_http::header::read_many_from_str(headers)?;
    let var_1: std::result::Result<Vec<_>, _> = var_1
        .iter()
        .map(|s| {
            ::aws_smithy_types::base64::decode(s)
                .map_err(|_| ::aws_smithy_http::header::ParseError::new("failed to decode base64"))
                .and_then(|bytes| {
                    String::from_utf8(bytes).map_err(|_| ::aws_smithy_http::header::ParseError::new("base64 encoded data was not valid utf-8"))
                })
        })
        .collect();
    let var_1 = var_1?;
    if var_1.len() > 1 {
        Err(::aws_smithy_http::header::ParseError::new(format!(
            "expected one item but found {}",
            var_1.len()
        )))
    } else {
        let mut var_1 = var_1;
        Ok(var_1.pop())
    }
}

pub(crate) fn de_alternative_intents_header(
    header_map: &::http::HeaderMap,
) -> std::result::Result<::std::option::Option<::std::string::String>, ::aws_smithy_http::header::ParseError> {
    let headers = header_map.get_all("x-amz-lex-alternative-intents").iter();
    let var_2: Vec<::std::string::String> = ::aws_smithy_http::header::read_many_from_str(headers)?;
    let var_2: std::result::Result<Vec<_>, _> = var_2
        .iter()
        .map(|s| {
            ::aws_smithy_types::base64::decode(s)
                .map_err(|_| ::aws_smithy_http::header::ParseError::new("failed to decode base64"))
                .and_then(|bytes| {
                    String::from_utf8(bytes).map_err(|_| ::aws_smithy_http::header::ParseError::new("base64 encoded data was not valid utf-8"))
                })
        })
        .collect();
    let var_2 = var_2?;
    if var_2.len() > 1 {
        Err(::aws_smithy_http::header::ParseError::new(format!(
            "expected one item but found {}",
            var_2.len()
        )))
    } else {
        let mut var_2 = var_2;
        Ok(var_2.pop())
    }
}

pub fn de_audio_stream_payload(
    body: &mut ::aws_smithy_types::body::SdkBody,
) -> std::result::Result<::aws_smithy_types::byte_stream::ByteStream, crate::operation::post_content::PostContentError> {
    // replace the body with an empty body
    let body = std::mem::replace(body, ::aws_smithy_types::body::SdkBody::taken());
    Ok(::aws_smithy_types::byte_stream::ByteStream::new(body))
}

pub(crate) fn de_bot_version_header(
    header_map: &::http::HeaderMap,
) -> std::result::Result<::std::option::Option<::std::string::String>, ::aws_smithy_http::header::ParseError> {
    let headers = header_map.get_all("x-amz-lex-bot-version").iter();
    ::aws_smithy_http::header::one_or_none(headers)
}

pub(crate) fn de_content_type_header(
    header_map: &::http::HeaderMap,
) -> std::result::Result<::std::option::Option<::std::string::String>, ::aws_smithy_http::header::ParseError> {
    let headers = header_map.get_all("Content-Type").iter();
    ::aws_smithy_http::header::one_or_none(headers)
}

pub(crate) fn de_dialog_state_header(
    header_map: &::http::HeaderMap,
) -> std::result::Result<::std::option::Option<crate::types::DialogState>, ::aws_smithy_http::header::ParseError> {
    let headers = header_map.get_all("x-amz-lex-dialog-state").iter();
    ::aws_smithy_http::header::one_or_none(headers)
}

pub(crate) fn de_encoded_input_transcript_header(
    header_map: &::http::HeaderMap,
) -> std::result::Result<::std::option::Option<::std::string::String>, ::aws_smithy_http::header::ParseError> {
    let headers = header_map.get_all("x-amz-lex-encoded-input-transcript").iter();
    ::aws_smithy_http::header::one_or_none(headers)
}

pub(crate) fn de_encoded_message_header(
    header_map: &::http::HeaderMap,
) -> std::result::Result<::std::option::Option<::std::string::String>, ::aws_smithy_http::header::ParseError> {
    let headers = header_map.get_all("x-amz-lex-encoded-message").iter();
    ::aws_smithy_http::header::one_or_none(headers)
}

pub(crate) fn de_input_transcript_header(
    header_map: &::http::HeaderMap,
) -> std::result::Result<::std::option::Option<::std::string::String>, ::aws_smithy_http::header::ParseError> {
    let headers = header_map.get_all("x-amz-lex-input-transcript").iter();
    ::aws_smithy_http::header::one_or_none(headers)
}

pub(crate) fn de_intent_name_header(
    header_map: &::http::HeaderMap,
) -> std::result::Result<::std::option::Option<::std::string::String>, ::aws_smithy_http::header::ParseError> {
    let headers = header_map.get_all("x-amz-lex-intent-name").iter();
    ::aws_smithy_http::header::one_or_none(headers)
}

pub(crate) fn de_message_header(
    header_map: &::http::HeaderMap,
) -> std::result::Result<::std::option::Option<::std::string::String>, ::aws_smithy_http::header::ParseError> {
    let headers = header_map.get_all("x-amz-lex-message").iter();
    ::aws_smithy_http::header::one_or_none(headers)
}

pub(crate) fn de_message_format_header(
    header_map: &::http::HeaderMap,
) -> std::result::Result<::std::option::Option<crate::types::MessageFormatType>, ::aws_smithy_http::header::ParseError> {
    let headers = header_map.get_all("x-amz-lex-message-format").iter();
    ::aws_smithy_http::header::one_or_none(headers)
}

pub(crate) fn de_nlu_intent_confidence_header(
    header_map: &::http::HeaderMap,
) -> std::result::Result<::std::option::Option<::std::string::String>, ::aws_smithy_http::header::ParseError> {
    let headers = header_map.get_all("x-amz-lex-nlu-intent-confidence").iter();
    let var_3: Vec<::std::string::String> = ::aws_smithy_http::header::read_many_from_str(headers)?;
    let var_3: std::result::Result<Vec<_>, _> = var_3
        .iter()
        .map(|s| {
            ::aws_smithy_types::base64::decode(s)
                .map_err(|_| ::aws_smithy_http::header::ParseError::new("failed to decode base64"))
                .and_then(|bytes| {
                    String::from_utf8(bytes).map_err(|_| ::aws_smithy_http::header::ParseError::new("base64 encoded data was not valid utf-8"))
                })
        })
        .collect();
    let var_3 = var_3?;
    if var_3.len() > 1 {
        Err(::aws_smithy_http::header::ParseError::new(format!(
            "expected one item but found {}",
            var_3.len()
        )))
    } else {
        let mut var_3 = var_3;
        Ok(var_3.pop())
    }
}

pub(crate) fn de_sentiment_response_header(
    header_map: &::http::HeaderMap,
) -> std::result::Result<::std::option::Option<::std::string::String>, ::aws_smithy_http::header::ParseError> {
    let headers = header_map.get_all("x-amz-lex-sentiment").iter();
    ::aws_smithy_http::header::one_or_none(headers)
}

pub(crate) fn de_session_attributes_header(
    header_map: &::http::HeaderMap,
) -> std::result::Result<::std::option::Option<::std::string::String>, ::aws_smithy_http::header::ParseError> {
    let headers = header_map.get_all("x-amz-lex-session-attributes").iter();
    let var_4: Vec<::std::string::String> = ::aws_smithy_http::header::read_many_from_str(headers)?;
    let var_4: std::result::Result<Vec<_>, _> = var_4
        .iter()
        .map(|s| {
            ::aws_smithy_types::base64::decode(s)
                .map_err(|_| ::aws_smithy_http::header::ParseError::new("failed to decode base64"))
                .and_then(|bytes| {
                    String::from_utf8(bytes).map_err(|_| ::aws_smithy_http::header::ParseError::new("base64 encoded data was not valid utf-8"))
                })
        })
        .collect();
    let var_4 = var_4?;
    if var_4.len() > 1 {
        Err(::aws_smithy_http::header::ParseError::new(format!(
            "expected one item but found {}",
            var_4.len()
        )))
    } else {
        let mut var_4 = var_4;
        Ok(var_4.pop())
    }
}

pub(crate) fn de_session_id_header(
    header_map: &::http::HeaderMap,
) -> std::result::Result<::std::option::Option<::std::string::String>, ::aws_smithy_http::header::ParseError> {
    let headers = header_map.get_all("x-amz-lex-session-id").iter();
    ::aws_smithy_http::header::one_or_none(headers)
}

pub(crate) fn de_slot_to_elicit_header(
    header_map: &::http::HeaderMap,
) -> std::result::Result<::std::option::Option<::std::string::String>, ::aws_smithy_http::header::ParseError> {
    let headers = header_map.get_all("x-amz-lex-slot-to-elicit").iter();
    ::aws_smithy_http::header::one_or_none(headers)
}

pub(crate) fn de_slots_header(
    header_map: &::http::HeaderMap,
) -> std::result::Result<::std::option::Option<::std::string::String>, ::aws_smithy_http::header::ParseError> {
    let headers = header_map.get_all("x-amz-lex-slots").iter();
    let var_5: Vec<::std::string::String> = ::aws_smithy_http::header::read_many_from_str(headers)?;
    let var_5: std::result::Result<Vec<_>, _> = var_5
        .iter()
        .map(|s| {
            ::aws_smithy_types::base64::decode(s)
                .map_err(|_| ::aws_smithy_http::header::ParseError::new("failed to decode base64"))
                .and_then(|bytes| {
                    String::from_utf8(bytes).map_err(|_| ::aws_smithy_http::header::ParseError::new("base64 encoded data was not valid utf-8"))
                })
        })
        .collect();
    let var_5 = var_5?;
    if var_5.len() > 1 {
        Err(::aws_smithy_http::header::ParseError::new(format!(
            "expected one item but found {}",
            var_5.len()
        )))
    } else {
        let mut var_5 = var_5;
        Ok(var_5.pop())
    }
}
