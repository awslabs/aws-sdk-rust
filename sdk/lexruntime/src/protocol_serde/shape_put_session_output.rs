// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
pub(crate) fn de_active_contexts_header(header_map: &http::HeaderMap) -> std::result::Result<std::option::Option<std::string::String>, aws_smithy_http::header::ParseError> {
    let headers = header_map.get_all("x-amz-lex-active-contexts").iter();
    let var_1: Vec<std::string::String> = aws_smithy_http::header::read_many_from_str(headers)?;
    let var_1: std::result::Result<Vec<_>, _> = var_1
                            .iter().map(|s|
                                aws_smithy_types::base64::decode(s).map_err(|_|aws_smithy_http::header::ParseError::new("failed to decode base64"))
                                .and_then(|bytes|String::from_utf8(bytes).map_err(|_|aws_smithy_http::header::ParseError::new("base64 encoded data was not valid utf-8")))
                            ).collect();
    let var_1 = var_1?;
    if var_1.len() > 1 {
                                Err(aws_smithy_http::header::ParseError::new(format!("expected one item but found {}", var_1.len())))
                            } else {
                                let mut var_1 = var_1;
                                Ok(var_1.pop())
                            }
}

pub fn de_audio_stream_payload(body: &mut aws_smithy_http::body::SdkBody) -> std::result::Result<aws_smithy_http::byte_stream::ByteStream, crate::operation::put_session::PutSessionError> {
    // replace the body with an empty body
                let body = std::mem::replace(body, aws_smithy_http::body::SdkBody::taken());
                Ok(aws_smithy_http::byte_stream::ByteStream::new(body))
}

pub(crate) fn de_content_type_header(header_map: &http::HeaderMap) -> std::result::Result<std::option::Option<std::string::String>, aws_smithy_http::header::ParseError> {
    let headers = header_map.get_all("Content-Type").iter();
    aws_smithy_http::header::one_or_none(headers)
}

pub(crate) fn de_dialog_state_header(header_map: &http::HeaderMap) -> std::result::Result<std::option::Option<crate::types::DialogState>, aws_smithy_http::header::ParseError> {
    let headers = header_map.get_all("x-amz-lex-dialog-state").iter();
    aws_smithy_http::header::one_or_none(headers)
}

pub(crate) fn de_encoded_message_header(header_map: &http::HeaderMap) -> std::result::Result<std::option::Option<std::string::String>, aws_smithy_http::header::ParseError> {
    let headers = header_map.get_all("x-amz-lex-encoded-message").iter();
    aws_smithy_http::header::one_or_none(headers)
}

pub(crate) fn de_intent_name_header(header_map: &http::HeaderMap) -> std::result::Result<std::option::Option<std::string::String>, aws_smithy_http::header::ParseError> {
    let headers = header_map.get_all("x-amz-lex-intent-name").iter();
    aws_smithy_http::header::one_or_none(headers)
}

pub(crate) fn de_message_header(header_map: &http::HeaderMap) -> std::result::Result<std::option::Option<std::string::String>, aws_smithy_http::header::ParseError> {
    let headers = header_map.get_all("x-amz-lex-message").iter();
    aws_smithy_http::header::one_or_none(headers)
}

pub(crate) fn de_message_format_header(header_map: &http::HeaderMap) -> std::result::Result<std::option::Option<crate::types::MessageFormatType>, aws_smithy_http::header::ParseError> {
    let headers = header_map.get_all("x-amz-lex-message-format").iter();
    aws_smithy_http::header::one_or_none(headers)
}

pub(crate) fn de_session_attributes_header(header_map: &http::HeaderMap) -> std::result::Result<std::option::Option<std::string::String>, aws_smithy_http::header::ParseError> {
    let headers = header_map.get_all("x-amz-lex-session-attributes").iter();
    let var_2: Vec<std::string::String> = aws_smithy_http::header::read_many_from_str(headers)?;
    let var_2: std::result::Result<Vec<_>, _> = var_2
                            .iter().map(|s|
                                aws_smithy_types::base64::decode(s).map_err(|_|aws_smithy_http::header::ParseError::new("failed to decode base64"))
                                .and_then(|bytes|String::from_utf8(bytes).map_err(|_|aws_smithy_http::header::ParseError::new("base64 encoded data was not valid utf-8")))
                            ).collect();
    let var_2 = var_2?;
    if var_2.len() > 1 {
                                Err(aws_smithy_http::header::ParseError::new(format!("expected one item but found {}", var_2.len())))
                            } else {
                                let mut var_2 = var_2;
                                Ok(var_2.pop())
                            }
}

pub(crate) fn de_session_id_header(header_map: &http::HeaderMap) -> std::result::Result<std::option::Option<std::string::String>, aws_smithy_http::header::ParseError> {
    let headers = header_map.get_all("x-amz-lex-session-id").iter();
    aws_smithy_http::header::one_or_none(headers)
}

pub(crate) fn de_slot_to_elicit_header(header_map: &http::HeaderMap) -> std::result::Result<std::option::Option<std::string::String>, aws_smithy_http::header::ParseError> {
    let headers = header_map.get_all("x-amz-lex-slot-to-elicit").iter();
    aws_smithy_http::header::one_or_none(headers)
}

pub(crate) fn de_slots_header(header_map: &http::HeaderMap) -> std::result::Result<std::option::Option<std::string::String>, aws_smithy_http::header::ParseError> {
    let headers = header_map.get_all("x-amz-lex-slots").iter();
    let var_3: Vec<std::string::String> = aws_smithy_http::header::read_many_from_str(headers)?;
    let var_3: std::result::Result<Vec<_>, _> = var_3
                            .iter().map(|s|
                                aws_smithy_types::base64::decode(s).map_err(|_|aws_smithy_http::header::ParseError::new("failed to decode base64"))
                                .and_then(|bytes|String::from_utf8(bytes).map_err(|_|aws_smithy_http::header::ParseError::new("base64 encoded data was not valid utf-8")))
                            ).collect();
    let var_3 = var_3?;
    if var_3.len() > 1 {
                                Err(aws_smithy_http::header::ParseError::new(format!("expected one item but found {}", var_3.len())))
                            } else {
                                let mut var_3 = var_3;
                                Ok(var_3.pop())
                            }
}

