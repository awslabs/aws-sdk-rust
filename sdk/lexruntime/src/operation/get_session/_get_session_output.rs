// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetSessionOutput  {
    /// <p>An array of information about the intents used in the session. The array can contain a maximum of three summaries. If more than three intents are used in the session, the <code>recentIntentSummaryView</code> operation contains information about the last three intents used.</p> 
    /// <p>If you set the <code>checkpointLabelFilter</code> parameter in the request, the array contains only the intents with the specified label.</p>
    #[doc(hidden)]
    pub recent_intent_summary_view: std::option::Option<std::vec::Vec<crate::types::IntentSummary>>,
    /// <p>Map of key/value pairs representing the session-specific context information. It contains application information passed between Amazon Lex and a client application.</p>
    #[doc(hidden)]
    pub session_attributes: std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>A unique identifier for the session.</p>
    #[doc(hidden)]
    pub session_id: std::option::Option<std::string::String>,
    /// <p>Describes the current state of the bot.</p>
    #[doc(hidden)]
    pub dialog_action: std::option::Option<crate::types::DialogAction>,
    /// <p>A list of active contexts for the session. A context can be set when an intent is fulfilled or by calling the <code>PostContent</code>, <code>PostText</code>, or <code>PutSession</code> operation.</p> 
    /// <p>You can use a context to control the intents that can follow up an intent, or to modify the operation of your application.</p>
    #[doc(hidden)]
    pub active_contexts: std::option::Option<std::vec::Vec<crate::types::ActiveContext>>,
    _request_id: Option<String>,
}
impl GetSessionOutput {
    /// <p>An array of information about the intents used in the session. The array can contain a maximum of three summaries. If more than three intents are used in the session, the <code>recentIntentSummaryView</code> operation contains information about the last three intents used.</p> 
    /// <p>If you set the <code>checkpointLabelFilter</code> parameter in the request, the array contains only the intents with the specified label.</p>
    pub fn recent_intent_summary_view(&self) -> std::option::Option<& [crate::types::IntentSummary]> {
        self.recent_intent_summary_view.as_deref()
    }
    /// <p>Map of key/value pairs representing the session-specific context information. It contains application information passed between Amazon Lex and a client application.</p>
    pub fn session_attributes(&self) -> std::option::Option<& std::collections::HashMap<std::string::String, std::string::String>> {
        self.session_attributes.as_ref()
    }
    /// <p>A unique identifier for the session.</p>
    pub fn session_id(&self) -> std::option::Option<& str> {
        self.session_id.as_deref()
    }
    /// <p>Describes the current state of the bot.</p>
    pub fn dialog_action(&self) -> std::option::Option<& crate::types::DialogAction> {
        self.dialog_action.as_ref()
    }
    /// <p>A list of active contexts for the session. A context can be set when an intent is fulfilled or by calling the <code>PostContent</code>, <code>PostText</code>, or <code>PutSession</code> operation.</p> 
    /// <p>You can use a context to control the intents that can follow up an intent, or to modify the operation of your application.</p>
    pub fn active_contexts(&self) -> std::option::Option<& [crate::types::ActiveContext]> {
        self.active_contexts.as_deref()
    }
}
impl  std::fmt::Debug for GetSessionOutput  {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetSessionOutput");
        formatter.field("recent_intent_summary_view", &self.recent_intent_summary_view);
        formatter.field("session_attributes", &"*** Sensitive Data Redacted ***");
        formatter.field("session_id", &self.session_id);
        formatter.field("dialog_action", &self.dialog_action);
        formatter.field("active_contexts", &"*** Sensitive Data Redacted ***");
        formatter.field("_request_id", &self._request_id);
        formatter.finish()
    }
}
impl aws_http::request_id::RequestId for GetSessionOutput {
                                fn request_id(&self) -> Option<&str> {
                                    self._request_id.as_deref()
                                }
                            }
impl GetSessionOutput {
    /// Creates a new builder-style object to manufacture [`GetSessionOutput`](crate::operation::get_session::GetSessionOutput).
    pub fn builder() -> crate::operation::get_session::builders::GetSessionOutputBuilder {
        crate::operation::get_session::builders::GetSessionOutputBuilder::default()
    }
}

/// A builder for [`GetSessionOutput`](crate::operation::get_session::GetSessionOutput).
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default)]
pub struct GetSessionOutputBuilder {
    pub(crate) recent_intent_summary_view: std::option::Option<std::vec::Vec<crate::types::IntentSummary>>,
    pub(crate) session_attributes: std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    pub(crate) session_id: std::option::Option<std::string::String>,
    pub(crate) dialog_action: std::option::Option<crate::types::DialogAction>,
    pub(crate) active_contexts: std::option::Option<std::vec::Vec<crate::types::ActiveContext>>,
    _request_id: Option<String>,
}
impl GetSessionOutputBuilder {
    /// Appends an item to `recent_intent_summary_view`.
    ///
    /// To override the contents of this collection use [`set_recent_intent_summary_view`](Self::set_recent_intent_summary_view).
    ///
    /// <p>An array of information about the intents used in the session. The array can contain a maximum of three summaries. If more than three intents are used in the session, the <code>recentIntentSummaryView</code> operation contains information about the last three intents used.</p> 
    /// <p>If you set the <code>checkpointLabelFilter</code> parameter in the request, the array contains only the intents with the specified label.</p>
    pub fn recent_intent_summary_view(mut self, input: crate::types::IntentSummary) -> Self {
        let mut v = self.recent_intent_summary_view.unwrap_or_default();
                        v.push(input);
                        self.recent_intent_summary_view = Some(v);
                        self
    }
    /// <p>An array of information about the intents used in the session. The array can contain a maximum of three summaries. If more than three intents are used in the session, the <code>recentIntentSummaryView</code> operation contains information about the last three intents used.</p> 
    /// <p>If you set the <code>checkpointLabelFilter</code> parameter in the request, the array contains only the intents with the specified label.</p>
    pub fn set_recent_intent_summary_view(mut self, input: std::option::Option<std::vec::Vec<crate::types::IntentSummary>>) -> Self {
        self.recent_intent_summary_view = input; self
    }
    /// Adds a key-value pair to `session_attributes`.
    ///
    /// To override the contents of this collection use [`set_session_attributes`](Self::set_session_attributes).
    ///
    /// <p>Map of key/value pairs representing the session-specific context information. It contains application information passed between Amazon Lex and a client application.</p>
    pub fn session_attributes(mut self, k: impl Into<std::string::String>, v: impl Into<std::string::String>) -> Self {
        let mut hash_map = self.session_attributes.unwrap_or_default();
                        hash_map.insert(k.into(), v.into());
                        self.session_attributes = Some(hash_map);
                        self
    }
    /// <p>Map of key/value pairs representing the session-specific context information. It contains application information passed between Amazon Lex and a client application.</p>
    pub fn set_session_attributes(mut self, input: std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>) -> Self {
        self.session_attributes = input; self
    }
    /// <p>A unique identifier for the session.</p>
    pub fn session_id(mut self, input: impl Into<std::string::String>) -> Self {
        self.session_id = Some(input.into());
        self
    }
    /// <p>A unique identifier for the session.</p>
    pub fn set_session_id(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.session_id = input; self
    }
    /// <p>Describes the current state of the bot.</p>
    pub fn dialog_action(mut self, input: crate::types::DialogAction) -> Self {
        self.dialog_action = Some(input);
        self
    }
    /// <p>Describes the current state of the bot.</p>
    pub fn set_dialog_action(mut self, input: std::option::Option<crate::types::DialogAction>) -> Self {
        self.dialog_action = input; self
    }
    /// Appends an item to `active_contexts`.
    ///
    /// To override the contents of this collection use [`set_active_contexts`](Self::set_active_contexts).
    ///
    /// <p>A list of active contexts for the session. A context can be set when an intent is fulfilled or by calling the <code>PostContent</code>, <code>PostText</code>, or <code>PutSession</code> operation.</p> 
    /// <p>You can use a context to control the intents that can follow up an intent, or to modify the operation of your application.</p>
    pub fn active_contexts(mut self, input: crate::types::ActiveContext) -> Self {
        let mut v = self.active_contexts.unwrap_or_default();
                        v.push(input);
                        self.active_contexts = Some(v);
                        self
    }
    /// <p>A list of active contexts for the session. A context can be set when an intent is fulfilled or by calling the <code>PostContent</code>, <code>PostText</code>, or <code>PutSession</code> operation.</p> 
    /// <p>You can use a context to control the intents that can follow up an intent, or to modify the operation of your application.</p>
    pub fn set_active_contexts(mut self, input: std::option::Option<std::vec::Vec<crate::types::ActiveContext>>) -> Self {
        self.active_contexts = input; self
    }
    pub(crate) fn _request_id(mut self, request_id: impl Into<String>) -> Self {
                                    self._request_id = Some(request_id.into());
                                    self
                                }
    
                                pub(crate) fn _set_request_id(&mut self, request_id: Option<String>) -> &mut Self {
                                    self._request_id = request_id;
                                    self
                                }
    /// Consumes the builder and constructs a [`GetSessionOutput`](crate::operation::get_session::GetSessionOutput).
    pub fn build(self) -> crate::operation::get_session::GetSessionOutput {
        crate::operation::get_session::GetSessionOutput {
            recent_intent_summary_view: self.recent_intent_summary_view
            ,
            session_attributes: self.session_attributes
            ,
            session_id: self.session_id
            ,
            dialog_action: self.dialog_action
            ,
            active_contexts: self.active_contexts
            ,
            _request_id: self._request_id,
        }
    }
}
impl std::fmt::Debug for GetSessionOutputBuilder {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetSessionOutputBuilder");
        formatter.field("recent_intent_summary_view", &self.recent_intent_summary_view);
        formatter.field("session_attributes", &"*** Sensitive Data Redacted ***");
        formatter.field("session_id", &self.session_id);
        formatter.field("dialog_action", &self.dialog_action);
        formatter.field("active_contexts", &"*** Sensitive Data Redacted ***");
        formatter.field("_request_id", &self._request_id);
        formatter.finish()
    }
}

