// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PostTextInput  {
    /// <p>The name of the Amazon Lex bot.</p>
    #[doc(hidden)]
    pub bot_name: std::option::Option<std::string::String>,
    /// <p>The alias of the Amazon Lex bot.</p>
    #[doc(hidden)]
    pub bot_alias: std::option::Option<std::string::String>,
    /// <p>The ID of the client application user. Amazon Lex uses this to identify a user's conversation with your bot. At runtime, each request must contain the <code>userID</code> field.</p> 
    /// <p>To decide the user ID to use for your application, consider the following factors.</p> 
    /// <ul> 
    /// <li> <p>The <code>userID</code> field must not contain any personally identifiable information of the user, for example, name, personal identification numbers, or other end user personal information.</p> </li> 
    /// <li> <p>If you want a user to start a conversation on one device and continue on another device, use a user-specific identifier.</p> </li> 
    /// <li> <p>If you want the same user to be able to have two independent conversations on two different devices, choose a device-specific identifier.</p> </li> 
    /// <li> <p>A user can't have two independent conversations with two different versions of the same bot. For example, a user can't have a conversation with the PROD and BETA versions of the same bot. If you anticipate that a user will need to have conversation with two different versions, for example, while testing, include the bot alias in the user ID to separate the two conversations.</p> </li> 
    /// </ul>
    #[doc(hidden)]
    pub user_id: std::option::Option<std::string::String>,
    /// <p>Application-specific information passed between Amazon Lex and a client application.</p> 
    /// <p>For more information, see <a href="https://docs.aws.amazon.com/lex/latest/dg/context-mgmt.html#context-mgmt-session-attribs">Setting Session Attributes</a>.</p>
    #[doc(hidden)]
    pub session_attributes: std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>Request-specific information passed between Amazon Lex and a client application.</p> 
    /// <p>The namespace <code>x-amz-lex:</code> is reserved for special attributes. Don't create any request attributes with the prefix <code>x-amz-lex:</code>.</p> 
    /// <p>For more information, see <a href="https://docs.aws.amazon.com/lex/latest/dg/context-mgmt.html#context-mgmt-request-attribs">Setting Request Attributes</a>.</p>
    #[doc(hidden)]
    pub request_attributes: std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>The text that the user entered (Amazon Lex interprets this text).</p>
    #[doc(hidden)]
    pub input_text: std::option::Option<std::string::String>,
    /// <p>A list of contexts active for the request. A context can be activated when a previous intent is fulfilled, or by including the context in the request,</p> 
    /// <p>If you don't specify a list of contexts, Amazon Lex will use the current list of contexts for the session. If you specify an empty list, all contexts for the session are cleared.</p>
    #[doc(hidden)]
    pub active_contexts: std::option::Option<std::vec::Vec<crate::types::ActiveContext>>,
}
impl PostTextInput {
    /// <p>The name of the Amazon Lex bot.</p>
    pub fn bot_name(&self) -> std::option::Option<& str> {
        self.bot_name.as_deref()
    }
    /// <p>The alias of the Amazon Lex bot.</p>
    pub fn bot_alias(&self) -> std::option::Option<& str> {
        self.bot_alias.as_deref()
    }
    /// <p>The ID of the client application user. Amazon Lex uses this to identify a user's conversation with your bot. At runtime, each request must contain the <code>userID</code> field.</p> 
    /// <p>To decide the user ID to use for your application, consider the following factors.</p> 
    /// <ul> 
    /// <li> <p>The <code>userID</code> field must not contain any personally identifiable information of the user, for example, name, personal identification numbers, or other end user personal information.</p> </li> 
    /// <li> <p>If you want a user to start a conversation on one device and continue on another device, use a user-specific identifier.</p> </li> 
    /// <li> <p>If you want the same user to be able to have two independent conversations on two different devices, choose a device-specific identifier.</p> </li> 
    /// <li> <p>A user can't have two independent conversations with two different versions of the same bot. For example, a user can't have a conversation with the PROD and BETA versions of the same bot. If you anticipate that a user will need to have conversation with two different versions, for example, while testing, include the bot alias in the user ID to separate the two conversations.</p> </li> 
    /// </ul>
    pub fn user_id(&self) -> std::option::Option<& str> {
        self.user_id.as_deref()
    }
    /// <p>Application-specific information passed between Amazon Lex and a client application.</p> 
    /// <p>For more information, see <a href="https://docs.aws.amazon.com/lex/latest/dg/context-mgmt.html#context-mgmt-session-attribs">Setting Session Attributes</a>.</p>
    pub fn session_attributes(&self) -> std::option::Option<& std::collections::HashMap<std::string::String, std::string::String>> {
        self.session_attributes.as_ref()
    }
    /// <p>Request-specific information passed between Amazon Lex and a client application.</p> 
    /// <p>The namespace <code>x-amz-lex:</code> is reserved for special attributes. Don't create any request attributes with the prefix <code>x-amz-lex:</code>.</p> 
    /// <p>For more information, see <a href="https://docs.aws.amazon.com/lex/latest/dg/context-mgmt.html#context-mgmt-request-attribs">Setting Request Attributes</a>.</p>
    pub fn request_attributes(&self) -> std::option::Option<& std::collections::HashMap<std::string::String, std::string::String>> {
        self.request_attributes.as_ref()
    }
    /// <p>The text that the user entered (Amazon Lex interprets this text).</p>
    pub fn input_text(&self) -> std::option::Option<& str> {
        self.input_text.as_deref()
    }
    /// <p>A list of contexts active for the request. A context can be activated when a previous intent is fulfilled, or by including the context in the request,</p> 
    /// <p>If you don't specify a list of contexts, Amazon Lex will use the current list of contexts for the session. If you specify an empty list, all contexts for the session are cleared.</p>
    pub fn active_contexts(&self) -> std::option::Option<& [crate::types::ActiveContext]> {
        self.active_contexts.as_deref()
    }
}
impl  std::fmt::Debug for PostTextInput  {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PostTextInput");
        formatter.field("bot_name", &self.bot_name);
        formatter.field("bot_alias", &self.bot_alias);
        formatter.field("user_id", &self.user_id);
        formatter.field("session_attributes", &"*** Sensitive Data Redacted ***");
        formatter.field("request_attributes", &"*** Sensitive Data Redacted ***");
        formatter.field("input_text", &"*** Sensitive Data Redacted ***");
        formatter.field("active_contexts", &"*** Sensitive Data Redacted ***");
        formatter.finish()
    }
}
impl PostTextInput {
    /// Creates a new builder-style object to manufacture [`PostTextInput`](crate::operation::post_text::PostTextInput).
    pub fn builder() -> crate::operation::post_text::builders::PostTextInputBuilder {
        crate::operation::post_text::builders::PostTextInputBuilder::default()
    }
}

/// A builder for [`PostTextInput`](crate::operation::post_text::PostTextInput).
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default)]
pub struct PostTextInputBuilder {
    pub(crate) bot_name: std::option::Option<std::string::String>,
    pub(crate) bot_alias: std::option::Option<std::string::String>,
    pub(crate) user_id: std::option::Option<std::string::String>,
    pub(crate) session_attributes: std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    pub(crate) request_attributes: std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    pub(crate) input_text: std::option::Option<std::string::String>,
    pub(crate) active_contexts: std::option::Option<std::vec::Vec<crate::types::ActiveContext>>,
}
impl PostTextInputBuilder {
    /// <p>The name of the Amazon Lex bot.</p>
    pub fn bot_name(mut self, input: impl Into<std::string::String>) -> Self {
        self.bot_name = Some(input.into());
        self
    }
    /// <p>The name of the Amazon Lex bot.</p>
    pub fn set_bot_name(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.bot_name = input; self
    }
    /// <p>The alias of the Amazon Lex bot.</p>
    pub fn bot_alias(mut self, input: impl Into<std::string::String>) -> Self {
        self.bot_alias = Some(input.into());
        self
    }
    /// <p>The alias of the Amazon Lex bot.</p>
    pub fn set_bot_alias(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.bot_alias = input; self
    }
    /// <p>The ID of the client application user. Amazon Lex uses this to identify a user's conversation with your bot. At runtime, each request must contain the <code>userID</code> field.</p> 
    /// <p>To decide the user ID to use for your application, consider the following factors.</p> 
    /// <ul> 
    /// <li> <p>The <code>userID</code> field must not contain any personally identifiable information of the user, for example, name, personal identification numbers, or other end user personal information.</p> </li> 
    /// <li> <p>If you want a user to start a conversation on one device and continue on another device, use a user-specific identifier.</p> </li> 
    /// <li> <p>If you want the same user to be able to have two independent conversations on two different devices, choose a device-specific identifier.</p> </li> 
    /// <li> <p>A user can't have two independent conversations with two different versions of the same bot. For example, a user can't have a conversation with the PROD and BETA versions of the same bot. If you anticipate that a user will need to have conversation with two different versions, for example, while testing, include the bot alias in the user ID to separate the two conversations.</p> </li> 
    /// </ul>
    pub fn user_id(mut self, input: impl Into<std::string::String>) -> Self {
        self.user_id = Some(input.into());
        self
    }
    /// <p>The ID of the client application user. Amazon Lex uses this to identify a user's conversation with your bot. At runtime, each request must contain the <code>userID</code> field.</p> 
    /// <p>To decide the user ID to use for your application, consider the following factors.</p> 
    /// <ul> 
    /// <li> <p>The <code>userID</code> field must not contain any personally identifiable information of the user, for example, name, personal identification numbers, or other end user personal information.</p> </li> 
    /// <li> <p>If you want a user to start a conversation on one device and continue on another device, use a user-specific identifier.</p> </li> 
    /// <li> <p>If you want the same user to be able to have two independent conversations on two different devices, choose a device-specific identifier.</p> </li> 
    /// <li> <p>A user can't have two independent conversations with two different versions of the same bot. For example, a user can't have a conversation with the PROD and BETA versions of the same bot. If you anticipate that a user will need to have conversation with two different versions, for example, while testing, include the bot alias in the user ID to separate the two conversations.</p> </li> 
    /// </ul>
    pub fn set_user_id(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.user_id = input; self
    }
    /// Adds a key-value pair to `session_attributes`.
    ///
    /// To override the contents of this collection use [`set_session_attributes`](Self::set_session_attributes).
    ///
    /// <p>Application-specific information passed between Amazon Lex and a client application.</p> 
    /// <p>For more information, see <a href="https://docs.aws.amazon.com/lex/latest/dg/context-mgmt.html#context-mgmt-session-attribs">Setting Session Attributes</a>.</p>
    pub fn session_attributes(mut self, k: impl Into<std::string::String>, v: impl Into<std::string::String>) -> Self {
        let mut hash_map = self.session_attributes.unwrap_or_default();
                        hash_map.insert(k.into(), v.into());
                        self.session_attributes = Some(hash_map);
                        self
    }
    /// <p>Application-specific information passed between Amazon Lex and a client application.</p> 
    /// <p>For more information, see <a href="https://docs.aws.amazon.com/lex/latest/dg/context-mgmt.html#context-mgmt-session-attribs">Setting Session Attributes</a>.</p>
    pub fn set_session_attributes(mut self, input: std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>) -> Self {
        self.session_attributes = input; self
    }
    /// Adds a key-value pair to `request_attributes`.
    ///
    /// To override the contents of this collection use [`set_request_attributes`](Self::set_request_attributes).
    ///
    /// <p>Request-specific information passed between Amazon Lex and a client application.</p> 
    /// <p>The namespace <code>x-amz-lex:</code> is reserved for special attributes. Don't create any request attributes with the prefix <code>x-amz-lex:</code>.</p> 
    /// <p>For more information, see <a href="https://docs.aws.amazon.com/lex/latest/dg/context-mgmt.html#context-mgmt-request-attribs">Setting Request Attributes</a>.</p>
    pub fn request_attributes(mut self, k: impl Into<std::string::String>, v: impl Into<std::string::String>) -> Self {
        let mut hash_map = self.request_attributes.unwrap_or_default();
                        hash_map.insert(k.into(), v.into());
                        self.request_attributes = Some(hash_map);
                        self
    }
    /// <p>Request-specific information passed between Amazon Lex and a client application.</p> 
    /// <p>The namespace <code>x-amz-lex:</code> is reserved for special attributes. Don't create any request attributes with the prefix <code>x-amz-lex:</code>.</p> 
    /// <p>For more information, see <a href="https://docs.aws.amazon.com/lex/latest/dg/context-mgmt.html#context-mgmt-request-attribs">Setting Request Attributes</a>.</p>
    pub fn set_request_attributes(mut self, input: std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>) -> Self {
        self.request_attributes = input; self
    }
    /// <p>The text that the user entered (Amazon Lex interprets this text).</p>
    pub fn input_text(mut self, input: impl Into<std::string::String>) -> Self {
        self.input_text = Some(input.into());
        self
    }
    /// <p>The text that the user entered (Amazon Lex interprets this text).</p>
    pub fn set_input_text(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.input_text = input; self
    }
    /// Appends an item to `active_contexts`.
    ///
    /// To override the contents of this collection use [`set_active_contexts`](Self::set_active_contexts).
    ///
    /// <p>A list of contexts active for the request. A context can be activated when a previous intent is fulfilled, or by including the context in the request,</p> 
    /// <p>If you don't specify a list of contexts, Amazon Lex will use the current list of contexts for the session. If you specify an empty list, all contexts for the session are cleared.</p>
    pub fn active_contexts(mut self, input: crate::types::ActiveContext) -> Self {
        let mut v = self.active_contexts.unwrap_or_default();
                        v.push(input);
                        self.active_contexts = Some(v);
                        self
    }
    /// <p>A list of contexts active for the request. A context can be activated when a previous intent is fulfilled, or by including the context in the request,</p> 
    /// <p>If you don't specify a list of contexts, Amazon Lex will use the current list of contexts for the session. If you specify an empty list, all contexts for the session are cleared.</p>
    pub fn set_active_contexts(mut self, input: std::option::Option<std::vec::Vec<crate::types::ActiveContext>>) -> Self {
        self.active_contexts = input; self
    }
    /// Consumes the builder and constructs a [`PostTextInput`](crate::operation::post_text::PostTextInput).
    pub fn build(self) -> Result<crate::operation::post_text::PostTextInput, aws_smithy_http::operation::error::BuildError> {
        Ok(
            crate::operation::post_text::PostTextInput {
                bot_name: self.bot_name
                ,
                bot_alias: self.bot_alias
                ,
                user_id: self.user_id
                ,
                session_attributes: self.session_attributes
                ,
                request_attributes: self.request_attributes
                ,
                input_text: self.input_text
                ,
                active_contexts: self.active_contexts
                ,
            }
        )
    }
}
impl std::fmt::Debug for PostTextInputBuilder {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PostTextInputBuilder");
        formatter.field("bot_name", &self.bot_name);
        formatter.field("bot_alias", &self.bot_alias);
        formatter.field("user_id", &self.user_id);
        formatter.field("session_attributes", &"*** Sensitive Data Redacted ***");
        formatter.field("request_attributes", &"*** Sensitive Data Redacted ***");
        formatter.field("input_text", &"*** Sensitive Data Redacted ***");
        formatter.field("active_contexts", &"*** Sensitive Data Redacted ***");
        formatter.finish()
    }
}

