// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PostTextInput {
    /// <p>The name of the Amazon Lex bot.</p>
    #[doc(hidden)]
    pub bot_name: std::option::Option<std::string::String>,
    /// <p>The alias of the Amazon Lex bot.</p>
    #[doc(hidden)]
    pub bot_alias: std::option::Option<std::string::String>,
    /// <p>The ID of the client application user. Amazon Lex uses this to identify a user's conversation with your bot. At runtime, each request must contain the <code>userID</code> field.</p>
    /// <p>To decide the user ID to use for your application, consider the following factors.</p>
    /// <ul>
    /// <li> <p>The <code>userID</code> field must not contain any personally identifiable information of the user, for example, name, personal identification numbers, or other end user personal information.</p> </li>
    /// <li> <p>If you want a user to start a conversation on one device and continue on another device, use a user-specific identifier.</p> </li>
    /// <li> <p>If you want the same user to be able to have two independent conversations on two different devices, choose a device-specific identifier.</p> </li>
    /// <li> <p>A user can't have two independent conversations with two different versions of the same bot. For example, a user can't have a conversation with the PROD and BETA versions of the same bot. If you anticipate that a user will need to have conversation with two different versions, for example, while testing, include the bot alias in the user ID to separate the two conversations.</p> </li>
    /// </ul>
    #[doc(hidden)]
    pub user_id: std::option::Option<std::string::String>,
    /// <p>Application-specific information passed between Amazon Lex and a client application.</p>
    /// <p>For more information, see <a href="https://docs.aws.amazon.com/lex/latest/dg/context-mgmt.html#context-mgmt-session-attribs">Setting Session Attributes</a>.</p>
    #[doc(hidden)]
    pub session_attributes:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>Request-specific information passed between Amazon Lex and a client application.</p>
    /// <p>The namespace <code>x-amz-lex:</code> is reserved for special attributes. Don't create any request attributes with the prefix <code>x-amz-lex:</code>.</p>
    /// <p>For more information, see <a href="https://docs.aws.amazon.com/lex/latest/dg/context-mgmt.html#context-mgmt-request-attribs">Setting Request Attributes</a>.</p>
    #[doc(hidden)]
    pub request_attributes:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>The text that the user entered (Amazon Lex interprets this text).</p>
    #[doc(hidden)]
    pub input_text: std::option::Option<std::string::String>,
    /// <p>A list of contexts active for the request. A context can be activated when a previous intent is fulfilled, or by including the context in the request,</p>
    /// <p>If you don't specify a list of contexts, Amazon Lex will use the current list of contexts for the session. If you specify an empty list, all contexts for the session are cleared.</p>
    #[doc(hidden)]
    pub active_contexts: std::option::Option<std::vec::Vec<crate::types::ActiveContext>>,
}
impl PostTextInput {
    /// <p>The name of the Amazon Lex bot.</p>
    pub fn bot_name(&self) -> std::option::Option<&str> {
        self.bot_name.as_deref()
    }
    /// <p>The alias of the Amazon Lex bot.</p>
    pub fn bot_alias(&self) -> std::option::Option<&str> {
        self.bot_alias.as_deref()
    }
    /// <p>The ID of the client application user. Amazon Lex uses this to identify a user's conversation with your bot. At runtime, each request must contain the <code>userID</code> field.</p>
    /// <p>To decide the user ID to use for your application, consider the following factors.</p>
    /// <ul>
    /// <li> <p>The <code>userID</code> field must not contain any personally identifiable information of the user, for example, name, personal identification numbers, or other end user personal information.</p> </li>
    /// <li> <p>If you want a user to start a conversation on one device and continue on another device, use a user-specific identifier.</p> </li>
    /// <li> <p>If you want the same user to be able to have two independent conversations on two different devices, choose a device-specific identifier.</p> </li>
    /// <li> <p>A user can't have two independent conversations with two different versions of the same bot. For example, a user can't have a conversation with the PROD and BETA versions of the same bot. If you anticipate that a user will need to have conversation with two different versions, for example, while testing, include the bot alias in the user ID to separate the two conversations.</p> </li>
    /// </ul>
    pub fn user_id(&self) -> std::option::Option<&str> {
        self.user_id.as_deref()
    }
    /// <p>Application-specific information passed between Amazon Lex and a client application.</p>
    /// <p>For more information, see <a href="https://docs.aws.amazon.com/lex/latest/dg/context-mgmt.html#context-mgmt-session-attribs">Setting Session Attributes</a>.</p>
    pub fn session_attributes(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.session_attributes.as_ref()
    }
    /// <p>Request-specific information passed between Amazon Lex and a client application.</p>
    /// <p>The namespace <code>x-amz-lex:</code> is reserved for special attributes. Don't create any request attributes with the prefix <code>x-amz-lex:</code>.</p>
    /// <p>For more information, see <a href="https://docs.aws.amazon.com/lex/latest/dg/context-mgmt.html#context-mgmt-request-attribs">Setting Request Attributes</a>.</p>
    pub fn request_attributes(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.request_attributes.as_ref()
    }
    /// <p>The text that the user entered (Amazon Lex interprets this text).</p>
    pub fn input_text(&self) -> std::option::Option<&str> {
        self.input_text.as_deref()
    }
    /// <p>A list of contexts active for the request. A context can be activated when a previous intent is fulfilled, or by including the context in the request,</p>
    /// <p>If you don't specify a list of contexts, Amazon Lex will use the current list of contexts for the session. If you specify an empty list, all contexts for the session are cleared.</p>
    pub fn active_contexts(&self) -> std::option::Option<&[crate::types::ActiveContext]> {
        self.active_contexts.as_deref()
    }
}
impl std::fmt::Debug for PostTextInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PostTextInput");
        formatter.field("bot_name", &self.bot_name);
        formatter.field("bot_alias", &self.bot_alias);
        formatter.field("user_id", &self.user_id);
        formatter.field("session_attributes", &"*** Sensitive Data Redacted ***");
        formatter.field("request_attributes", &"*** Sensitive Data Redacted ***");
        formatter.field("input_text", &"*** Sensitive Data Redacted ***");
        formatter.field("active_contexts", &"*** Sensitive Data Redacted ***");
        formatter.finish()
    }
}
impl PostTextInput {
    /// Creates a new builder-style object to manufacture [`PostTextInput`](crate::operation::post_text::PostTextInput).
    pub fn builder() -> crate::operation::post_text::builders::PostTextInputBuilder {
        crate::operation::post_text::builders::PostTextInputBuilder::default()
    }
}

/// A builder for [`PostTextInput`](crate::operation::post_text::PostTextInput).
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default)]
pub struct PostTextInputBuilder {
    pub(crate) bot_name: std::option::Option<std::string::String>,
    pub(crate) bot_alias: std::option::Option<std::string::String>,
    pub(crate) user_id: std::option::Option<std::string::String>,
    pub(crate) session_attributes:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    pub(crate) request_attributes:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    pub(crate) input_text: std::option::Option<std::string::String>,
    pub(crate) active_contexts: std::option::Option<std::vec::Vec<crate::types::ActiveContext>>,
}
impl PostTextInputBuilder {
    /// <p>The name of the Amazon Lex bot.</p>
    pub fn bot_name(mut self, input: impl Into<std::string::String>) -> Self {
        self.bot_name = Some(input.into());
        self
    }
    /// <p>The name of the Amazon Lex bot.</p>
    pub fn set_bot_name(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.bot_name = input;
        self
    }
    /// <p>The alias of the Amazon Lex bot.</p>
    pub fn bot_alias(mut self, input: impl Into<std::string::String>) -> Self {
        self.bot_alias = Some(input.into());
        self
    }
    /// <p>The alias of the Amazon Lex bot.</p>
    pub fn set_bot_alias(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.bot_alias = input;
        self
    }
    /// <p>The ID of the client application user. Amazon Lex uses this to identify a user's conversation with your bot. At runtime, each request must contain the <code>userID</code> field.</p>
    /// <p>To decide the user ID to use for your application, consider the following factors.</p>
    /// <ul>
    /// <li> <p>The <code>userID</code> field must not contain any personally identifiable information of the user, for example, name, personal identification numbers, or other end user personal information.</p> </li>
    /// <li> <p>If you want a user to start a conversation on one device and continue on another device, use a user-specific identifier.</p> </li>
    /// <li> <p>If you want the same user to be able to have two independent conversations on two different devices, choose a device-specific identifier.</p> </li>
    /// <li> <p>A user can't have two independent conversations with two different versions of the same bot. For example, a user can't have a conversation with the PROD and BETA versions of the same bot. If you anticipate that a user will need to have conversation with two different versions, for example, while testing, include the bot alias in the user ID to separate the two conversations.</p> </li>
    /// </ul>
    pub fn user_id(mut self, input: impl Into<std::string::String>) -> Self {
        self.user_id = Some(input.into());
        self
    }
    /// <p>The ID of the client application user. Amazon Lex uses this to identify a user's conversation with your bot. At runtime, each request must contain the <code>userID</code> field.</p>
    /// <p>To decide the user ID to use for your application, consider the following factors.</p>
    /// <ul>
    /// <li> <p>The <code>userID</code> field must not contain any personally identifiable information of the user, for example, name, personal identification numbers, or other end user personal information.</p> </li>
    /// <li> <p>If you want a user to start a conversation on one device and continue on another device, use a user-specific identifier.</p> </li>
    /// <li> <p>If you want the same user to be able to have two independent conversations on two different devices, choose a device-specific identifier.</p> </li>
    /// <li> <p>A user can't have two independent conversations with two different versions of the same bot. For example, a user can't have a conversation with the PROD and BETA versions of the same bot. If you anticipate that a user will need to have conversation with two different versions, for example, while testing, include the bot alias in the user ID to separate the two conversations.</p> </li>
    /// </ul>
    pub fn set_user_id(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.user_id = input;
        self
    }
    /// Adds a key-value pair to `session_attributes`.
    ///
    /// To override the contents of this collection use [`set_session_attributes`](Self::set_session_attributes).
    ///
    /// <p>Application-specific information passed between Amazon Lex and a client application.</p>
    /// <p>For more information, see <a href="https://docs.aws.amazon.com/lex/latest/dg/context-mgmt.html#context-mgmt-session-attribs">Setting Session Attributes</a>.</p>
    pub fn session_attributes(
        mut self,
        k: impl Into<std::string::String>,
        v: impl Into<std::string::String>,
    ) -> Self {
        let mut hash_map = self.session_attributes.unwrap_or_default();
        hash_map.insert(k.into(), v.into());
        self.session_attributes = Some(hash_map);
        self
    }
    /// <p>Application-specific information passed between Amazon Lex and a client application.</p>
    /// <p>For more information, see <a href="https://docs.aws.amazon.com/lex/latest/dg/context-mgmt.html#context-mgmt-session-attribs">Setting Session Attributes</a>.</p>
    pub fn set_session_attributes(
        mut self,
        input: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
    ) -> Self {
        self.session_attributes = input;
        self
    }
    /// Adds a key-value pair to `request_attributes`.
    ///
    /// To override the contents of this collection use [`set_request_attributes`](Self::set_request_attributes).
    ///
    /// <p>Request-specific information passed between Amazon Lex and a client application.</p>
    /// <p>The namespace <code>x-amz-lex:</code> is reserved for special attributes. Don't create any request attributes with the prefix <code>x-amz-lex:</code>.</p>
    /// <p>For more information, see <a href="https://docs.aws.amazon.com/lex/latest/dg/context-mgmt.html#context-mgmt-request-attribs">Setting Request Attributes</a>.</p>
    pub fn request_attributes(
        mut self,
        k: impl Into<std::string::String>,
        v: impl Into<std::string::String>,
    ) -> Self {
        let mut hash_map = self.request_attributes.unwrap_or_default();
        hash_map.insert(k.into(), v.into());
        self.request_attributes = Some(hash_map);
        self
    }
    /// <p>Request-specific information passed between Amazon Lex and a client application.</p>
    /// <p>The namespace <code>x-amz-lex:</code> is reserved for special attributes. Don't create any request attributes with the prefix <code>x-amz-lex:</code>.</p>
    /// <p>For more information, see <a href="https://docs.aws.amazon.com/lex/latest/dg/context-mgmt.html#context-mgmt-request-attribs">Setting Request Attributes</a>.</p>
    pub fn set_request_attributes(
        mut self,
        input: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
    ) -> Self {
        self.request_attributes = input;
        self
    }
    /// <p>The text that the user entered (Amazon Lex interprets this text).</p>
    pub fn input_text(mut self, input: impl Into<std::string::String>) -> Self {
        self.input_text = Some(input.into());
        self
    }
    /// <p>The text that the user entered (Amazon Lex interprets this text).</p>
    pub fn set_input_text(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.input_text = input;
        self
    }
    /// Appends an item to `active_contexts`.
    ///
    /// To override the contents of this collection use [`set_active_contexts`](Self::set_active_contexts).
    ///
    /// <p>A list of contexts active for the request. A context can be activated when a previous intent is fulfilled, or by including the context in the request,</p>
    /// <p>If you don't specify a list of contexts, Amazon Lex will use the current list of contexts for the session. If you specify an empty list, all contexts for the session are cleared.</p>
    pub fn active_contexts(mut self, input: crate::types::ActiveContext) -> Self {
        let mut v = self.active_contexts.unwrap_or_default();
        v.push(input);
        self.active_contexts = Some(v);
        self
    }
    /// <p>A list of contexts active for the request. A context can be activated when a previous intent is fulfilled, or by including the context in the request,</p>
    /// <p>If you don't specify a list of contexts, Amazon Lex will use the current list of contexts for the session. If you specify an empty list, all contexts for the session are cleared.</p>
    pub fn set_active_contexts(
        mut self,
        input: std::option::Option<std::vec::Vec<crate::types::ActiveContext>>,
    ) -> Self {
        self.active_contexts = input;
        self
    }
    /// Consumes the builder and constructs a [`PostTextInput`](crate::operation::post_text::PostTextInput).
    pub fn build(
        self,
    ) -> Result<
        crate::operation::post_text::PostTextInput,
        aws_smithy_http::operation::error::BuildError,
    > {
        Ok(crate::operation::post_text::PostTextInput {
            bot_name: self.bot_name,
            bot_alias: self.bot_alias,
            user_id: self.user_id,
            session_attributes: self.session_attributes,
            request_attributes: self.request_attributes,
            input_text: self.input_text,
            active_contexts: self.active_contexts,
        })
    }
}
impl std::fmt::Debug for PostTextInputBuilder {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PostTextInputBuilder");
        formatter.field("bot_name", &self.bot_name);
        formatter.field("bot_alias", &self.bot_alias);
        formatter.field("user_id", &self.user_id);
        formatter.field("session_attributes", &"*** Sensitive Data Redacted ***");
        formatter.field("request_attributes", &"*** Sensitive Data Redacted ***");
        formatter.field("input_text", &"*** Sensitive Data Redacted ***");
        formatter.field("active_contexts", &"*** Sensitive Data Redacted ***");
        formatter.finish()
    }
}
