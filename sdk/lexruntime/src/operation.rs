// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
/// <p>Removes session information for a specified bot, alias, and user ID.
/// </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteSession {
    _private: (),
}
impl DeleteSession {
    /// Creates a new builder-style object to manufacture [`DeleteSessionInput`](crate::input::DeleteSessionInput)
    pub fn builder() -> crate::input::delete_session_input::Builder {
        crate::input::delete_session_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteSession {
    type Output =
        std::result::Result<crate::output::DeleteSessionOutput, crate::error::DeleteSessionError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_session_error(response)
        } else {
            crate::operation_deser::parse_delete_session_response(response)
        }
    }
}

/// <p>Returns session information for a specified bot, alias, and user
/// ID.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetSession {
    _private: (),
}
impl GetSession {
    /// Creates a new builder-style object to manufacture [`GetSessionInput`](crate::input::GetSessionInput)
    pub fn builder() -> crate::input::get_session_input::Builder {
        crate::input::get_session_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetSession {
    type Output =
        std::result::Result<crate::output::GetSessionOutput, crate::error::GetSessionError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_session_error(response)
        } else {
            crate::operation_deser::parse_get_session_response(response)
        }
    }
}

/// <p> Sends user input (text or speech) to Amazon Lex. Clients use this API to
/// send text and audio requests to Amazon Lex at runtime. Amazon Lex interprets the
/// user input using the machine learning model that it built for the bot. </p>
/// <p>The <code>PostContent</code> operation supports audio input at 8kHz
/// and 16kHz. You can use 8kHz audio to achieve higher speech recognition
/// accuracy in telephone audio applications. </p>
/// <p> In response, Amazon Lex returns the next message to convey to the user.
/// Consider the following example messages: </p>
/// <ul>
/// <li>
/// <p> For a user input "I would like a pizza," Amazon Lex might return a
/// response with a message eliciting slot data (for example,
/// <code>PizzaSize</code>): "What size pizza would you like?". </p>
/// </li>
/// <li>
/// <p> After the user provides all of the pizza order information, Amazon Lex
/// might return a response with a message to get user confirmation:
/// "Order the pizza?". </p>
/// </li>
/// <li>
/// <p> After the user replies "Yes" to the confirmation prompt, Amazon Lex
/// might return a conclusion statement: "Thank you, your cheese pizza has
/// been ordered.". </p>
/// </li>
/// </ul>
/// <p> Not all Amazon Lex messages require a response from the user. For example,
/// conclusion statements do not require a response. Some messages require
/// only a yes or no response. In addition to the <code>message</code>, Amazon Lex
/// provides additional context about the message in the response that you can
/// use to enhance client behavior, such as displaying the appropriate client
/// user interface. Consider the following examples: </p>
/// <ul>
/// <li>
/// <p> If the message is to elicit slot data, Amazon Lex returns the
/// following context information: </p>
/// <ul>
/// <li>
/// <p>
/// <code>x-amz-lex-dialog-state</code> header set to
/// <code>ElicitSlot</code>
/// </p>
/// </li>
/// <li>
/// <p>
/// <code>x-amz-lex-intent-name</code> header set to the intent name
/// in the current context </p>
/// </li>
/// <li>
/// <p>
/// <code>x-amz-lex-slot-to-elicit</code> header set to the slot name
/// for which the <code>message</code> is eliciting information
/// </p>
/// </li>
/// <li>
/// <p>
/// <code>x-amz-lex-slots</code> header set to a map of slots
/// configured for the intent with their current values </p>
/// </li>
/// </ul>
/// </li>
/// <li>
/// <p> If the message is a confirmation prompt, the
/// <code>x-amz-lex-dialog-state</code> header is set to
/// <code>Confirmation</code> and the
/// <code>x-amz-lex-slot-to-elicit</code> header is omitted. </p>
/// </li>
/// <li>
/// <p> If the message is a clarification prompt configured for the
/// intent, indicating that the user intent is not understood, the
/// <code>x-amz-dialog-state</code> header is set to
/// <code>ElicitIntent</code> and the <code>x-amz-slot-to-elicit</code>
/// header is omitted. </p>
/// </li>
/// </ul>
/// <p> In addition, Amazon Lex also returns your application-specific
/// <code>sessionAttributes</code>. For more information, see <a href="https://docs.aws.amazon.com/lex/latest/dg/context-mgmt.html">Managing
/// Conversation Context</a>. </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct PostContent {
    _private: (),
}
impl PostContent {
    /// Creates a new builder-style object to manufacture [`PostContentInput`](crate::input::PostContentInput)
    pub fn builder() -> crate::input::post_content_input::Builder {
        crate::input::post_content_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseHttpResponse<smithy_http::body::SdkBody> for PostContent {
    type Output =
        std::result::Result<crate::output::PostContentOutput, crate::error::PostContentError>;
    fn parse_unloaded(
        &self,
        response: &mut http::Response<smithy_http::body::SdkBody>,
    ) -> Option<Self::Output> {
        // This is an error, defer to the non-streaming parser
        if !response.status().is_success() && response.status().as_u16() != 200 {
            return None;
        }
        Some(crate::operation_deser::parse_post_content(response))
    }
    fn parse_loaded(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        // if streaming, we only hit this case if its an error
        crate::operation_deser::parse_post_content_error(response)
    }
}

/// <p>Sends user input to Amazon Lex. Client applications can use this API to
/// send requests to Amazon Lex at runtime. Amazon Lex then interprets the user input
/// using the machine learning model it built for the bot. </p>
/// <p> In response, Amazon Lex returns the next <code>message</code> to convey to
/// the user an optional <code>responseCard</code> to display. Consider the
/// following example messages: </p>
/// <ul>
/// <li>
/// <p> For a user input "I would like a pizza", Amazon Lex might return a
/// response with a message eliciting slot data (for example, PizzaSize):
/// "What size pizza would you like?" </p>
/// </li>
/// <li>
/// <p> After the user provides all of the pizza order information,
/// Amazon Lex might return a response with a message to obtain user
/// confirmation "Proceed with the pizza order?". </p>
/// </li>
/// <li>
/// <p> After the user replies to a confirmation prompt with a "yes",
/// Amazon Lex might return a conclusion statement: "Thank you, your cheese
/// pizza has been ordered.". </p>
/// </li>
/// </ul>
/// <p> Not all Amazon Lex messages require a user response. For example, a
/// conclusion statement does not require a response. Some messages require
/// only a "yes" or "no" user response. In addition to the
/// <code>message</code>, Amazon Lex provides additional context about the
/// message in the response that you might use to enhance client behavior, for
/// example, to display the appropriate client user interface. These are the
/// <code>slotToElicit</code>, <code>dialogState</code>,
/// <code>intentName</code>, and <code>slots</code> fields in the response.
/// Consider the following examples: </p>
/// <ul>
/// <li>
/// <p>If the message is to elicit slot data, Amazon Lex returns the
/// following context information:</p>
/// <ul>
/// <li>
/// <p>
/// <code>dialogState</code> set to ElicitSlot </p>
/// </li>
/// <li>
/// <p>
/// <code>intentName</code> set to the intent name in the current
/// context </p>
/// </li>
/// <li>
/// <p>
/// <code>slotToElicit</code> set to the slot name for which the
/// <code>message</code> is eliciting information </p>
/// </li>
/// <li>
/// <p>
/// <code>slots</code> set to a map of slots, configured for the
/// intent, with currently known values </p>
/// </li>
/// </ul>
/// </li>
/// <li>
/// <p> If the message is a confirmation prompt, the
/// <code>dialogState</code> is set to ConfirmIntent and
/// <code>SlotToElicit</code> is set to null. </p>
/// </li>
/// <li>
/// <p>If the message is a clarification prompt (configured for the
/// intent) that indicates that user intent is not understood, the
/// <code>dialogState</code> is set to ElicitIntent and
/// <code>slotToElicit</code> is set to null. </p>
/// </li>
/// </ul>
/// <p> In addition, Amazon Lex also returns your application-specific
/// <code>sessionAttributes</code>. For more information, see <a href="https://docs.aws.amazon.com/lex/latest/dg/context-mgmt.html">Managing
/// Conversation Context</a>. </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct PostText {
    _private: (),
}
impl PostText {
    /// Creates a new builder-style object to manufacture [`PostTextInput`](crate::input::PostTextInput)
    pub fn builder() -> crate::input::post_text_input::Builder {
        crate::input::post_text_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for PostText {
    type Output = std::result::Result<crate::output::PostTextOutput, crate::error::PostTextError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_post_text_error(response)
        } else {
            crate::operation_deser::parse_post_text_response(response)
        }
    }
}

/// <p>Creates a new session or modifies an existing session with an Amazon Lex
/// bot. Use this operation to enable your application to set the state of the
/// bot.</p>
/// <p>For more information, see <a href="https://docs.aws.amazon.com/lex/latest/dg/how-session-api.html">Managing
/// Sessions</a>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct PutSession {
    _private: (),
}
impl PutSession {
    /// Creates a new builder-style object to manufacture [`PutSessionInput`](crate::input::PutSessionInput)
    pub fn builder() -> crate::input::put_session_input::Builder {
        crate::input::put_session_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseHttpResponse<smithy_http::body::SdkBody> for PutSession {
    type Output =
        std::result::Result<crate::output::PutSessionOutput, crate::error::PutSessionError>;
    fn parse_unloaded(
        &self,
        response: &mut http::Response<smithy_http::body::SdkBody>,
    ) -> Option<Self::Output> {
        // This is an error, defer to the non-streaming parser
        if !response.status().is_success() && response.status().as_u16() != 200 {
            return None;
        }
        Some(crate::operation_deser::parse_put_session(response))
    }
    fn parse_loaded(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        // if streaming, we only hit this case if its an error
        crate::operation_deser::parse_put_session_error(response)
    }
}
