// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// When writing a match expression against `ValidationExceptionReason`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let validationexceptionreason = unimplemented!();
/// match validationexceptionreason {
///     ValidationExceptionReason::InvalidAz => { /* ... */ },
///     ValidationExceptionReason::InvalidExpiresIn => { /* ... */ },
///     ValidationExceptionReason::InvalidResourceIdentifier => { /* ... */ },
///     ValidationExceptionReason::InvalidStatus => { /* ... */ },
///     ValidationExceptionReason::InvalidToken => { /* ... */ },
///     ValidationExceptionReason::MissingValue => { /* ... */ },
///     ValidationExceptionReason::UnsupportedAz => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `validationexceptionreason` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ValidationExceptionReason::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ValidationExceptionReason::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ValidationExceptionReason::NewFeature` is defined.
/// Specifically, when `validationexceptionreason` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ValidationExceptionReason::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ValidationExceptionReason {
    #[allow(missing_docs)] // documentation missing in model
    InvalidAz,
    #[allow(missing_docs)] // documentation missing in model
    InvalidExpiresIn,
    #[allow(missing_docs)] // documentation missing in model
    InvalidResourceIdentifier,
    #[allow(missing_docs)] // documentation missing in model
    InvalidStatus,
    #[allow(missing_docs)] // documentation missing in model
    InvalidToken,
    #[allow(missing_docs)] // documentation missing in model
    MissingValue,
    #[allow(missing_docs)] // documentation missing in model
    UnsupportedAz,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ValidationExceptionReason {
    fn from(s: &str) -> Self {
        match s {
            "InvalidAz" => ValidationExceptionReason::InvalidAz,
            "InvalidExpiresIn" => ValidationExceptionReason::InvalidExpiresIn,
            "InvalidResourceIdentifier" => ValidationExceptionReason::InvalidResourceIdentifier,
            "InvalidStatus" => ValidationExceptionReason::InvalidStatus,
            "InvalidToken" => ValidationExceptionReason::InvalidToken,
            "MissingValue" => ValidationExceptionReason::MissingValue,
            "UnsupportedAz" => ValidationExceptionReason::UnsupportedAz,
            other => ValidationExceptionReason::Unknown(crate::types::UnknownVariantValue(
                other.to_owned(),
            )),
        }
    }
}
impl std::str::FromStr for ValidationExceptionReason {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ValidationExceptionReason::from(s))
    }
}
impl ValidationExceptionReason {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ValidationExceptionReason::InvalidAz => "InvalidAz",
            ValidationExceptionReason::InvalidExpiresIn => "InvalidExpiresIn",
            ValidationExceptionReason::InvalidResourceIdentifier => "InvalidResourceIdentifier",
            ValidationExceptionReason::InvalidStatus => "InvalidStatus",
            ValidationExceptionReason::InvalidToken => "InvalidToken",
            ValidationExceptionReason::MissingValue => "MissingValue",
            ValidationExceptionReason::UnsupportedAz => "UnsupportedAz",
            ValidationExceptionReason::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "InvalidAz",
            "InvalidExpiresIn",
            "InvalidResourceIdentifier",
            "InvalidStatus",
            "InvalidToken",
            "MissingValue",
            "UnsupportedAz",
        ]
    }
}
impl AsRef<str> for ValidationExceptionReason {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `ConflictExceptionReason`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let conflictexceptionreason = unimplemented!();
/// match conflictexceptionreason {
///     ConflictExceptionReason::SimultaneousZonalShiftsConflict => { /* ... */ },
///     ConflictExceptionReason::ZonalShiftAlreadyExists => { /* ... */ },
///     ConflictExceptionReason::ZonalShiftStatusNotActive => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `conflictexceptionreason` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ConflictExceptionReason::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ConflictExceptionReason::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ConflictExceptionReason::NewFeature` is defined.
/// Specifically, when `conflictexceptionreason` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ConflictExceptionReason::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ConflictExceptionReason {
    #[allow(missing_docs)] // documentation missing in model
    SimultaneousZonalShiftsConflict,
    #[allow(missing_docs)] // documentation missing in model
    ZonalShiftAlreadyExists,
    #[allow(missing_docs)] // documentation missing in model
    ZonalShiftStatusNotActive,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ConflictExceptionReason {
    fn from(s: &str) -> Self {
        match s {
            "SimultaneousZonalShiftsConflict" => {
                ConflictExceptionReason::SimultaneousZonalShiftsConflict
            }
            "ZonalShiftAlreadyExists" => ConflictExceptionReason::ZonalShiftAlreadyExists,
            "ZonalShiftStatusNotActive" => ConflictExceptionReason::ZonalShiftStatusNotActive,
            other => ConflictExceptionReason::Unknown(crate::types::UnknownVariantValue(
                other.to_owned(),
            )),
        }
    }
}
impl std::str::FromStr for ConflictExceptionReason {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ConflictExceptionReason::from(s))
    }
}
impl ConflictExceptionReason {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ConflictExceptionReason::SimultaneousZonalShiftsConflict => {
                "SimultaneousZonalShiftsConflict"
            }
            ConflictExceptionReason::ZonalShiftAlreadyExists => "ZonalShiftAlreadyExists",
            ConflictExceptionReason::ZonalShiftStatusNotActive => "ZonalShiftStatusNotActive",
            ConflictExceptionReason::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "SimultaneousZonalShiftsConflict",
            "ZonalShiftAlreadyExists",
            "ZonalShiftStatusNotActive",
        ]
    }
}
impl AsRef<str> for ConflictExceptionReason {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `ZonalShiftStatus`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let zonalshiftstatus = unimplemented!();
/// match zonalshiftstatus {
///     ZonalShiftStatus::Active => { /* ... */ },
///     ZonalShiftStatus::Canceled => { /* ... */ },
///     ZonalShiftStatus::Expired => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `zonalshiftstatus` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ZonalShiftStatus::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ZonalShiftStatus::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ZonalShiftStatus::NewFeature` is defined.
/// Specifically, when `zonalshiftstatus` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ZonalShiftStatus::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ZonalShiftStatus {
    #[allow(missing_docs)] // documentation missing in model
    Active,
    #[allow(missing_docs)] // documentation missing in model
    Canceled,
    #[allow(missing_docs)] // documentation missing in model
    Expired,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ZonalShiftStatus {
    fn from(s: &str) -> Self {
        match s {
            "ACTIVE" => ZonalShiftStatus::Active,
            "CANCELED" => ZonalShiftStatus::Canceled,
            "EXPIRED" => ZonalShiftStatus::Expired,
            other => ZonalShiftStatus::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for ZonalShiftStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ZonalShiftStatus::from(s))
    }
}
impl ZonalShiftStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ZonalShiftStatus::Active => "ACTIVE",
            ZonalShiftStatus::Canceled => "CANCELED",
            ZonalShiftStatus::Expired => "EXPIRED",
            ZonalShiftStatus::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["ACTIVE", "CANCELED", "EXPIRED"]
    }
}
impl AsRef<str> for ZonalShiftStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>You start a zonal shift to temporarily move load balancer traffic away from an Availability Zone in a AWS Region. A zonal shift helps your application recover immediately, for example, from a developer's bad code deployment or from an AWS infrastructure failure in a single Availability Zone. You can start a zonal shift in Route 53 ARC only for managed resources in your account in an AWS Region. Supported AWS resources are automatically registered with Route 53 ARC.</p>
/// <p>Zonal shifts are temporary. A zonal shift can be active for up to three days (72 hours).</p>
/// <p>When you start a zonal shift, you specify how long you want it to be active, which Amazon Route 53 Application Recovery Controller converts to an expiry time (expiration time). You can cancel a zonal shift, for example, if you're ready to restore traffic to the Availability Zone. Or you can extend the zonal shift by updating the expiration so the zonal shift is active longer.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ZonalShiftSummary {
    /// <p>The identifier of a zonal shift.</p>
    #[doc(hidden)]
    pub zonal_shift_id: std::option::Option<std::string::String>,
    /// <p>The identifier for the resource to include in a zonal shift. The identifier is the Amazon Resource Name (ARN) for the resource.</p>
    /// <p>At this time, you can only start a zonal shift for Network Load Balancers and Application Load Balancers with cross-zone load balancing turned off.</p>
    #[doc(hidden)]
    pub resource_identifier: std::option::Option<std::string::String>,
    /// <p>The Availability Zone that traffic is moved away from for a resource when you start a zonal shift. Until the zonal shift expires or you cancel it, traffic for the resource is instead moved to other Availability Zones in the AWS Region.</p>
    #[doc(hidden)]
    pub away_from: std::option::Option<std::string::String>,
    /// <p>The expiry time (expiration time) for the zonal shift. A zonal shift is temporary and must be set to expire when you start the zonal shift. You can initially set a zonal shift to expire in a maximum of three days (72 hours). However, you can update a zonal shift to set a new expiration at any time. </p>
    /// <p>When you start a zonal shift, you specify how long you want it to be active, which Route 53 ARC converts to an expiry time (expiration time). You can cancel a zonal shift, for example, if you're ready to restore traffic to the Availability Zone. Or you can update the zonal shift to specify another length of time to expire in.</p>
    #[doc(hidden)]
    pub expiry_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The time (UTC) when the zonal shift is started.</p>
    #[doc(hidden)]
    pub start_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>A status for a zonal shift.</p>
    /// <p>The <code>Status</code> for a zonal shift can have one of the following values:</p>
    /// <ul>
    /// <li> <p> <b>ACTIVE:</b> The zonal shift is started and active.</p> </li>
    /// <li> <p> <b>EXPIRED:</b> The zonal shift has expired (the expiry time was exceeded).</p> </li>
    /// <li> <p> <b>CANCELED:</b> The zonal shift was canceled.</p> </li>
    /// </ul>
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::ZonalShiftStatus>,
    /// <p>A comment that you enter about the zonal shift. Only the latest comment is retained; no comment history is maintained. That is, a new comment overwrites any existing comment string.</p>
    #[doc(hidden)]
    pub comment: std::option::Option<std::string::String>,
}
impl ZonalShiftSummary {
    /// <p>The identifier of a zonal shift.</p>
    pub fn zonal_shift_id(&self) -> std::option::Option<&str> {
        self.zonal_shift_id.as_deref()
    }
    /// <p>The identifier for the resource to include in a zonal shift. The identifier is the Amazon Resource Name (ARN) for the resource.</p>
    /// <p>At this time, you can only start a zonal shift for Network Load Balancers and Application Load Balancers with cross-zone load balancing turned off.</p>
    pub fn resource_identifier(&self) -> std::option::Option<&str> {
        self.resource_identifier.as_deref()
    }
    /// <p>The Availability Zone that traffic is moved away from for a resource when you start a zonal shift. Until the zonal shift expires or you cancel it, traffic for the resource is instead moved to other Availability Zones in the AWS Region.</p>
    pub fn away_from(&self) -> std::option::Option<&str> {
        self.away_from.as_deref()
    }
    /// <p>The expiry time (expiration time) for the zonal shift. A zonal shift is temporary and must be set to expire when you start the zonal shift. You can initially set a zonal shift to expire in a maximum of three days (72 hours). However, you can update a zonal shift to set a new expiration at any time. </p>
    /// <p>When you start a zonal shift, you specify how long you want it to be active, which Route 53 ARC converts to an expiry time (expiration time). You can cancel a zonal shift, for example, if you're ready to restore traffic to the Availability Zone. Or you can update the zonal shift to specify another length of time to expire in.</p>
    pub fn expiry_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.expiry_time.as_ref()
    }
    /// <p>The time (UTC) when the zonal shift is started.</p>
    pub fn start_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.start_time.as_ref()
    }
    /// <p>A status for a zonal shift.</p>
    /// <p>The <code>Status</code> for a zonal shift can have one of the following values:</p>
    /// <ul>
    /// <li> <p> <b>ACTIVE:</b> The zonal shift is started and active.</p> </li>
    /// <li> <p> <b>EXPIRED:</b> The zonal shift has expired (the expiry time was exceeded).</p> </li>
    /// <li> <p> <b>CANCELED:</b> The zonal shift was canceled.</p> </li>
    /// </ul>
    pub fn status(&self) -> std::option::Option<&crate::model::ZonalShiftStatus> {
        self.status.as_ref()
    }
    /// <p>A comment that you enter about the zonal shift. Only the latest comment is retained; no comment history is maintained. That is, a new comment overwrites any existing comment string.</p>
    pub fn comment(&self) -> std::option::Option<&str> {
        self.comment.as_deref()
    }
}
impl ZonalShiftSummary {
    /// Creates a new builder-style object to manufacture [`ZonalShiftSummary`](crate::model::ZonalShiftSummary).
    pub fn builder() -> crate::model::zonal_shift_summary::Builder {
        crate::model::zonal_shift_summary::Builder::default()
    }
}

/// See [`ZonalShiftSummary`](crate::model::ZonalShiftSummary).
pub mod zonal_shift_summary {

    /// A builder for [`ZonalShiftSummary`](crate::model::ZonalShiftSummary).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) zonal_shift_id: std::option::Option<std::string::String>,
        pub(crate) resource_identifier: std::option::Option<std::string::String>,
        pub(crate) away_from: std::option::Option<std::string::String>,
        pub(crate) expiry_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) start_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) status: std::option::Option<crate::model::ZonalShiftStatus>,
        pub(crate) comment: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The identifier of a zonal shift.</p>
        pub fn zonal_shift_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.zonal_shift_id = Some(input.into());
            self
        }
        /// <p>The identifier of a zonal shift.</p>
        pub fn set_zonal_shift_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.zonal_shift_id = input;
            self
        }
        /// <p>The identifier for the resource to include in a zonal shift. The identifier is the Amazon Resource Name (ARN) for the resource.</p>
        /// <p>At this time, you can only start a zonal shift for Network Load Balancers and Application Load Balancers with cross-zone load balancing turned off.</p>
        pub fn resource_identifier(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_identifier = Some(input.into());
            self
        }
        /// <p>The identifier for the resource to include in a zonal shift. The identifier is the Amazon Resource Name (ARN) for the resource.</p>
        /// <p>At this time, you can only start a zonal shift for Network Load Balancers and Application Load Balancers with cross-zone load balancing turned off.</p>
        pub fn set_resource_identifier(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.resource_identifier = input;
            self
        }
        /// <p>The Availability Zone that traffic is moved away from for a resource when you start a zonal shift. Until the zonal shift expires or you cancel it, traffic for the resource is instead moved to other Availability Zones in the AWS Region.</p>
        pub fn away_from(mut self, input: impl Into<std::string::String>) -> Self {
            self.away_from = Some(input.into());
            self
        }
        /// <p>The Availability Zone that traffic is moved away from for a resource when you start a zonal shift. Until the zonal shift expires or you cancel it, traffic for the resource is instead moved to other Availability Zones in the AWS Region.</p>
        pub fn set_away_from(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.away_from = input;
            self
        }
        /// <p>The expiry time (expiration time) for the zonal shift. A zonal shift is temporary and must be set to expire when you start the zonal shift. You can initially set a zonal shift to expire in a maximum of three days (72 hours). However, you can update a zonal shift to set a new expiration at any time. </p>
        /// <p>When you start a zonal shift, you specify how long you want it to be active, which Route 53 ARC converts to an expiry time (expiration time). You can cancel a zonal shift, for example, if you're ready to restore traffic to the Availability Zone. Or you can update the zonal shift to specify another length of time to expire in.</p>
        pub fn expiry_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.expiry_time = Some(input);
            self
        }
        /// <p>The expiry time (expiration time) for the zonal shift. A zonal shift is temporary and must be set to expire when you start the zonal shift. You can initially set a zonal shift to expire in a maximum of three days (72 hours). However, you can update a zonal shift to set a new expiration at any time. </p>
        /// <p>When you start a zonal shift, you specify how long you want it to be active, which Route 53 ARC converts to an expiry time (expiration time). You can cancel a zonal shift, for example, if you're ready to restore traffic to the Availability Zone. Or you can update the zonal shift to specify another length of time to expire in.</p>
        pub fn set_expiry_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.expiry_time = input;
            self
        }
        /// <p>The time (UTC) when the zonal shift is started.</p>
        pub fn start_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.start_time = Some(input);
            self
        }
        /// <p>The time (UTC) when the zonal shift is started.</p>
        pub fn set_start_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.start_time = input;
            self
        }
        /// <p>A status for a zonal shift.</p>
        /// <p>The <code>Status</code> for a zonal shift can have one of the following values:</p>
        /// <ul>
        /// <li> <p> <b>ACTIVE:</b> The zonal shift is started and active.</p> </li>
        /// <li> <p> <b>EXPIRED:</b> The zonal shift has expired (the expiry time was exceeded).</p> </li>
        /// <li> <p> <b>CANCELED:</b> The zonal shift was canceled.</p> </li>
        /// </ul>
        pub fn status(mut self, input: crate::model::ZonalShiftStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>A status for a zonal shift.</p>
        /// <p>The <code>Status</code> for a zonal shift can have one of the following values:</p>
        /// <ul>
        /// <li> <p> <b>ACTIVE:</b> The zonal shift is started and active.</p> </li>
        /// <li> <p> <b>EXPIRED:</b> The zonal shift has expired (the expiry time was exceeded).</p> </li>
        /// <li> <p> <b>CANCELED:</b> The zonal shift was canceled.</p> </li>
        /// </ul>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::ZonalShiftStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// <p>A comment that you enter about the zonal shift. Only the latest comment is retained; no comment history is maintained. That is, a new comment overwrites any existing comment string.</p>
        pub fn comment(mut self, input: impl Into<std::string::String>) -> Self {
            self.comment = Some(input.into());
            self
        }
        /// <p>A comment that you enter about the zonal shift. Only the latest comment is retained; no comment history is maintained. That is, a new comment overwrites any existing comment string.</p>
        pub fn set_comment(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.comment = input;
            self
        }
        /// Consumes the builder and constructs a [`ZonalShiftSummary`](crate::model::ZonalShiftSummary).
        pub fn build(self) -> crate::model::ZonalShiftSummary {
            crate::model::ZonalShiftSummary {
                zonal_shift_id: self.zonal_shift_id,
                resource_identifier: self.resource_identifier,
                away_from: self.away_from,
                expiry_time: self.expiry_time,
                start_time: self.start_time,
                status: self.status,
                comment: self.comment,
            }
        }
    }
}

/// <p>A complex structure for a managed resource in an account.</p>
/// <p>A managed resource is a Network Load Balancer or Application Load Balancer that has been registered with Route 53 ARC by Elastic Load Balancing. You can start a zonal shift in Route 53 ARC for a managed resource to temporarily move traffic for the resource away from an Availability Zone in an AWS Region.</p> <note>
/// <p>At this time, you can only start a zonal shift for Network Load Balancers and Application Load Balancers with cross-zone load balancing turned off.</p>
/// </note>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ManagedResourceSummary {
    /// <p>The Amazon Resource Name (ARN) for the managed resource.</p>
    #[doc(hidden)]
    pub arn: std::option::Option<std::string::String>,
    /// <p>The name of the managed resource.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The Availability Zones that a resource is deployed in.</p>
    #[doc(hidden)]
    pub availability_zones: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl ManagedResourceSummary {
    /// <p>The Amazon Resource Name (ARN) for the managed resource.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>The name of the managed resource.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The Availability Zones that a resource is deployed in.</p>
    pub fn availability_zones(&self) -> std::option::Option<&[std::string::String]> {
        self.availability_zones.as_deref()
    }
}
impl ManagedResourceSummary {
    /// Creates a new builder-style object to manufacture [`ManagedResourceSummary`](crate::model::ManagedResourceSummary).
    pub fn builder() -> crate::model::managed_resource_summary::Builder {
        crate::model::managed_resource_summary::Builder::default()
    }
}

/// See [`ManagedResourceSummary`](crate::model::ManagedResourceSummary).
pub mod managed_resource_summary {

    /// A builder for [`ManagedResourceSummary`](crate::model::ManagedResourceSummary).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) availability_zones: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) for the managed resource.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) for the managed resource.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>The name of the managed resource.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the managed resource.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// Appends an item to `availability_zones`.
        ///
        /// To override the contents of this collection use [`set_availability_zones`](Self::set_availability_zones).
        ///
        /// <p>The Availability Zones that a resource is deployed in.</p>
        pub fn availability_zones(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.availability_zones.unwrap_or_default();
            v.push(input.into());
            self.availability_zones = Some(v);
            self
        }
        /// <p>The Availability Zones that a resource is deployed in.</p>
        pub fn set_availability_zones(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.availability_zones = input;
            self
        }
        /// Consumes the builder and constructs a [`ManagedResourceSummary`](crate::model::ManagedResourceSummary).
        pub fn build(self) -> crate::model::ManagedResourceSummary {
            crate::model::ManagedResourceSummary {
                arn: self.arn,
                name: self.name,
                availability_zones: self.availability_zones,
            }
        }
    }
}

/// <p>A complex structure that lists the zonal shifts for a managed resource and their statuses for the resource.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ZonalShiftInResource {
    /// <p>An <code>appliedStatus</code> for a zonal shift for a resource can have one of two values: <code>APPLIED</code> or <code>NOT_APPLIED</code>. </p>
    #[doc(hidden)]
    pub applied_status: std::option::Option<crate::model::AppliedStatus>,
    /// <p>The identifier of a zonal shift.</p>
    #[doc(hidden)]
    pub zonal_shift_id: std::option::Option<std::string::String>,
    /// <p>The identifier for the resource to include in a zonal shift. The identifier is the Amazon Resource Name (ARN) for the resource.</p>
    /// <p>At this time, you can only start a zonal shift for Network Load Balancers and Application Load Balancers with cross-zone load balancing turned off.</p>
    #[doc(hidden)]
    pub resource_identifier: std::option::Option<std::string::String>,
    /// <p>The Availability Zone that traffic is moved away from for a resource when you start a zonal shift. Until the zonal shift expires or you cancel it, traffic for the resource is instead moved to other Availability Zones in the AWS Region.</p>
    #[doc(hidden)]
    pub away_from: std::option::Option<std::string::String>,
    /// <p>The expiry time (expiration time) for the zonal shift. A zonal shift is temporary and must be set to expire when you start the zonal shift. You can initially set a zonal shift to expire in a maximum of three days (72 hours). However, you can update a zonal shift to set a new expiration at any time. </p>
    /// <p>When you start a zonal shift, you specify how long you want it to be active, which Route 53 ARC converts to an expiry time (expiration time). You can cancel a zonal shift, for example, if you're ready to restore traffic to the Availability Zone. Or you can update the zonal shift to specify another length of time to expire in.</p>
    #[doc(hidden)]
    pub expiry_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The time (UTC) when the zonal shift is started.</p>
    #[doc(hidden)]
    pub start_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>A comment that you enter about the zonal shift. Only the latest comment is retained; no comment history is maintained. That is, a new comment overwrites any existing comment string.</p>
    #[doc(hidden)]
    pub comment: std::option::Option<std::string::String>,
}
impl ZonalShiftInResource {
    /// <p>An <code>appliedStatus</code> for a zonal shift for a resource can have one of two values: <code>APPLIED</code> or <code>NOT_APPLIED</code>. </p>
    pub fn applied_status(&self) -> std::option::Option<&crate::model::AppliedStatus> {
        self.applied_status.as_ref()
    }
    /// <p>The identifier of a zonal shift.</p>
    pub fn zonal_shift_id(&self) -> std::option::Option<&str> {
        self.zonal_shift_id.as_deref()
    }
    /// <p>The identifier for the resource to include in a zonal shift. The identifier is the Amazon Resource Name (ARN) for the resource.</p>
    /// <p>At this time, you can only start a zonal shift for Network Load Balancers and Application Load Balancers with cross-zone load balancing turned off.</p>
    pub fn resource_identifier(&self) -> std::option::Option<&str> {
        self.resource_identifier.as_deref()
    }
    /// <p>The Availability Zone that traffic is moved away from for a resource when you start a zonal shift. Until the zonal shift expires or you cancel it, traffic for the resource is instead moved to other Availability Zones in the AWS Region.</p>
    pub fn away_from(&self) -> std::option::Option<&str> {
        self.away_from.as_deref()
    }
    /// <p>The expiry time (expiration time) for the zonal shift. A zonal shift is temporary and must be set to expire when you start the zonal shift. You can initially set a zonal shift to expire in a maximum of three days (72 hours). However, you can update a zonal shift to set a new expiration at any time. </p>
    /// <p>When you start a zonal shift, you specify how long you want it to be active, which Route 53 ARC converts to an expiry time (expiration time). You can cancel a zonal shift, for example, if you're ready to restore traffic to the Availability Zone. Or you can update the zonal shift to specify another length of time to expire in.</p>
    pub fn expiry_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.expiry_time.as_ref()
    }
    /// <p>The time (UTC) when the zonal shift is started.</p>
    pub fn start_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.start_time.as_ref()
    }
    /// <p>A comment that you enter about the zonal shift. Only the latest comment is retained; no comment history is maintained. That is, a new comment overwrites any existing comment string.</p>
    pub fn comment(&self) -> std::option::Option<&str> {
        self.comment.as_deref()
    }
}
impl ZonalShiftInResource {
    /// Creates a new builder-style object to manufacture [`ZonalShiftInResource`](crate::model::ZonalShiftInResource).
    pub fn builder() -> crate::model::zonal_shift_in_resource::Builder {
        crate::model::zonal_shift_in_resource::Builder::default()
    }
}

/// See [`ZonalShiftInResource`](crate::model::ZonalShiftInResource).
pub mod zonal_shift_in_resource {

    /// A builder for [`ZonalShiftInResource`](crate::model::ZonalShiftInResource).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) applied_status: std::option::Option<crate::model::AppliedStatus>,
        pub(crate) zonal_shift_id: std::option::Option<std::string::String>,
        pub(crate) resource_identifier: std::option::Option<std::string::String>,
        pub(crate) away_from: std::option::Option<std::string::String>,
        pub(crate) expiry_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) start_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) comment: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>An <code>appliedStatus</code> for a zonal shift for a resource can have one of two values: <code>APPLIED</code> or <code>NOT_APPLIED</code>. </p>
        pub fn applied_status(mut self, input: crate::model::AppliedStatus) -> Self {
            self.applied_status = Some(input);
            self
        }
        /// <p>An <code>appliedStatus</code> for a zonal shift for a resource can have one of two values: <code>APPLIED</code> or <code>NOT_APPLIED</code>. </p>
        pub fn set_applied_status(
            mut self,
            input: std::option::Option<crate::model::AppliedStatus>,
        ) -> Self {
            self.applied_status = input;
            self
        }
        /// <p>The identifier of a zonal shift.</p>
        pub fn zonal_shift_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.zonal_shift_id = Some(input.into());
            self
        }
        /// <p>The identifier of a zonal shift.</p>
        pub fn set_zonal_shift_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.zonal_shift_id = input;
            self
        }
        /// <p>The identifier for the resource to include in a zonal shift. The identifier is the Amazon Resource Name (ARN) for the resource.</p>
        /// <p>At this time, you can only start a zonal shift for Network Load Balancers and Application Load Balancers with cross-zone load balancing turned off.</p>
        pub fn resource_identifier(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_identifier = Some(input.into());
            self
        }
        /// <p>The identifier for the resource to include in a zonal shift. The identifier is the Amazon Resource Name (ARN) for the resource.</p>
        /// <p>At this time, you can only start a zonal shift for Network Load Balancers and Application Load Balancers with cross-zone load balancing turned off.</p>
        pub fn set_resource_identifier(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.resource_identifier = input;
            self
        }
        /// <p>The Availability Zone that traffic is moved away from for a resource when you start a zonal shift. Until the zonal shift expires or you cancel it, traffic for the resource is instead moved to other Availability Zones in the AWS Region.</p>
        pub fn away_from(mut self, input: impl Into<std::string::String>) -> Self {
            self.away_from = Some(input.into());
            self
        }
        /// <p>The Availability Zone that traffic is moved away from for a resource when you start a zonal shift. Until the zonal shift expires or you cancel it, traffic for the resource is instead moved to other Availability Zones in the AWS Region.</p>
        pub fn set_away_from(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.away_from = input;
            self
        }
        /// <p>The expiry time (expiration time) for the zonal shift. A zonal shift is temporary and must be set to expire when you start the zonal shift. You can initially set a zonal shift to expire in a maximum of three days (72 hours). However, you can update a zonal shift to set a new expiration at any time. </p>
        /// <p>When you start a zonal shift, you specify how long you want it to be active, which Route 53 ARC converts to an expiry time (expiration time). You can cancel a zonal shift, for example, if you're ready to restore traffic to the Availability Zone. Or you can update the zonal shift to specify another length of time to expire in.</p>
        pub fn expiry_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.expiry_time = Some(input);
            self
        }
        /// <p>The expiry time (expiration time) for the zonal shift. A zonal shift is temporary and must be set to expire when you start the zonal shift. You can initially set a zonal shift to expire in a maximum of three days (72 hours). However, you can update a zonal shift to set a new expiration at any time. </p>
        /// <p>When you start a zonal shift, you specify how long you want it to be active, which Route 53 ARC converts to an expiry time (expiration time). You can cancel a zonal shift, for example, if you're ready to restore traffic to the Availability Zone. Or you can update the zonal shift to specify another length of time to expire in.</p>
        pub fn set_expiry_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.expiry_time = input;
            self
        }
        /// <p>The time (UTC) when the zonal shift is started.</p>
        pub fn start_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.start_time = Some(input);
            self
        }
        /// <p>The time (UTC) when the zonal shift is started.</p>
        pub fn set_start_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.start_time = input;
            self
        }
        /// <p>A comment that you enter about the zonal shift. Only the latest comment is retained; no comment history is maintained. That is, a new comment overwrites any existing comment string.</p>
        pub fn comment(mut self, input: impl Into<std::string::String>) -> Self {
            self.comment = Some(input.into());
            self
        }
        /// <p>A comment that you enter about the zonal shift. Only the latest comment is retained; no comment history is maintained. That is, a new comment overwrites any existing comment string.</p>
        pub fn set_comment(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.comment = input;
            self
        }
        /// Consumes the builder and constructs a [`ZonalShiftInResource`](crate::model::ZonalShiftInResource).
        pub fn build(self) -> crate::model::ZonalShiftInResource {
            crate::model::ZonalShiftInResource {
                applied_status: self.applied_status,
                zonal_shift_id: self.zonal_shift_id,
                resource_identifier: self.resource_identifier,
                away_from: self.away_from,
                expiry_time: self.expiry_time,
                start_time: self.start_time,
                comment: self.comment,
            }
        }
    }
}

/// When writing a match expression against `AppliedStatus`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let appliedstatus = unimplemented!();
/// match appliedstatus {
///     AppliedStatus::Applied => { /* ... */ },
///     AppliedStatus::NotApplied => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `appliedstatus` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `AppliedStatus::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `AppliedStatus::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `AppliedStatus::NewFeature` is defined.
/// Specifically, when `appliedstatus` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `AppliedStatus::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum AppliedStatus {
    #[allow(missing_docs)] // documentation missing in model
    Applied,
    #[allow(missing_docs)] // documentation missing in model
    NotApplied,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for AppliedStatus {
    fn from(s: &str) -> Self {
        match s {
            "APPLIED" => AppliedStatus::Applied,
            "NOT_APPLIED" => AppliedStatus::NotApplied,
            other => AppliedStatus::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for AppliedStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(AppliedStatus::from(s))
    }
}
impl AppliedStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            AppliedStatus::Applied => "APPLIED",
            AppliedStatus::NotApplied => "NOT_APPLIED",
            AppliedStatus::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["APPLIED", "NOT_APPLIED"]
    }
}
impl AsRef<str> for AppliedStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}
