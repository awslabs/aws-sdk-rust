// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct UpdatePracticeRunConfigurationInput {
    /// <p>The identifier for the resource that you want to update the practice run configuration for. The identifier is the Amazon Resource Name (ARN) for the resource.</p>
    pub resource_identifier: ::std::option::Option<::std::string::String>,
    /// <p>Add, change, or remove windows of days and times for when you can, optionally, block ARC from starting a practice run for a resource.</p>
    /// <p>The format for blocked windows is: DAY:HH:SS-DAY:HH:SS. Keep in mind, when you specify dates, that dates and times for practice runs are in UTC. Also, be aware of potential time adjustments that might be required for daylight saving time differences. Separate multiple blocked windows with spaces.</p>
    /// <p>For example, say you run business report summaries three days a week. For this scenario, you might set the following recurring days and times as blocked windows, for example: <code>MON-20:30-21:30 WED-20:30-21:30 FRI-20:30-21:30</code>.</p>
    pub blocked_windows: ::std::option::Option<::std::vec::Vec<::std::string::String>>,
    /// <p>Add, change, or remove blocked dates for a practice run in zonal autoshift.</p>
    /// <p>Optionally, you can block practice runs for specific calendar dates. The format for blocked dates is: YYYY-MM-DD. Keep in mind, when you specify dates, that dates and times for practice runs are in UTC. Separate multiple blocked dates with spaces.</p>
    /// <p>For example, if you have an application update scheduled to launch on May 1, 2024, and you don't want practice runs to shift traffic away at that time, you could set a blocked date for <code>2024-05-01</code>.</p>
    pub blocked_dates: ::std::option::Option<::std::vec::Vec<::std::string::String>>,
    /// <p>Add, change, or remove the Amazon CloudWatch alarms that you optionally specify as the blocking alarms for practice runs.</p>
    pub blocking_alarms: ::std::option::Option<::std::vec::Vec<crate::types::ControlCondition>>,
    /// <p>Add, change, or remove windows of days and times for when you can, optionally, allow ARC to start a practice run for a resource.</p>
    /// <p>The format for allowed windows is: DAY:HH:SS-DAY:HH:SS. Keep in mind, when you specify dates, that dates and times for practice runs are in UTC. Also, be aware of potential time adjustments that might be required for daylight saving time differences. Separate multiple allowed windows with spaces.</p>
    /// <p>For example, say you want to allow practice runs only on Wednesdays and Fridays from noon to 5 p.m. For this scenario, you could set the following recurring days and times as allowed windows, for example: <code>Wed-12:00-Wed:17:00 Fri-12:00-Fri:17:00</code>.</p><important>
    /// <p>The <code>allowedWindows</code> have to start and end on the same day. Windows that span multiple days aren't supported.</p>
    /// </important>
    pub allowed_windows: ::std::option::Option<::std::vec::Vec<::std::string::String>>,
    /// <p>Specify one or more Amazon CloudWatch alarms as the outcome alarms for practice runs.</p>
    pub outcome_alarms: ::std::option::Option<::std::vec::Vec<crate::types::ControlCondition>>,
}
impl UpdatePracticeRunConfigurationInput {
    /// <p>The identifier for the resource that you want to update the practice run configuration for. The identifier is the Amazon Resource Name (ARN) for the resource.</p>
    pub fn resource_identifier(&self) -> ::std::option::Option<&str> {
        self.resource_identifier.as_deref()
    }
    /// <p>Add, change, or remove windows of days and times for when you can, optionally, block ARC from starting a practice run for a resource.</p>
    /// <p>The format for blocked windows is: DAY:HH:SS-DAY:HH:SS. Keep in mind, when you specify dates, that dates and times for practice runs are in UTC. Also, be aware of potential time adjustments that might be required for daylight saving time differences. Separate multiple blocked windows with spaces.</p>
    /// <p>For example, say you run business report summaries three days a week. For this scenario, you might set the following recurring days and times as blocked windows, for example: <code>MON-20:30-21:30 WED-20:30-21:30 FRI-20:30-21:30</code>.</p>
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.blocked_windows.is_none()`.
    pub fn blocked_windows(&self) -> &[::std::string::String] {
        self.blocked_windows.as_deref().unwrap_or_default()
    }
    /// <p>Add, change, or remove blocked dates for a practice run in zonal autoshift.</p>
    /// <p>Optionally, you can block practice runs for specific calendar dates. The format for blocked dates is: YYYY-MM-DD. Keep in mind, when you specify dates, that dates and times for practice runs are in UTC. Separate multiple blocked dates with spaces.</p>
    /// <p>For example, if you have an application update scheduled to launch on May 1, 2024, and you don't want practice runs to shift traffic away at that time, you could set a blocked date for <code>2024-05-01</code>.</p>
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.blocked_dates.is_none()`.
    pub fn blocked_dates(&self) -> &[::std::string::String] {
        self.blocked_dates.as_deref().unwrap_or_default()
    }
    /// <p>Add, change, or remove the Amazon CloudWatch alarms that you optionally specify as the blocking alarms for practice runs.</p>
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.blocking_alarms.is_none()`.
    pub fn blocking_alarms(&self) -> &[crate::types::ControlCondition] {
        self.blocking_alarms.as_deref().unwrap_or_default()
    }
    /// <p>Add, change, or remove windows of days and times for when you can, optionally, allow ARC to start a practice run for a resource.</p>
    /// <p>The format for allowed windows is: DAY:HH:SS-DAY:HH:SS. Keep in mind, when you specify dates, that dates and times for practice runs are in UTC. Also, be aware of potential time adjustments that might be required for daylight saving time differences. Separate multiple allowed windows with spaces.</p>
    /// <p>For example, say you want to allow practice runs only on Wednesdays and Fridays from noon to 5 p.m. For this scenario, you could set the following recurring days and times as allowed windows, for example: <code>Wed-12:00-Wed:17:00 Fri-12:00-Fri:17:00</code>.</p><important>
    /// <p>The <code>allowedWindows</code> have to start and end on the same day. Windows that span multiple days aren't supported.</p>
    /// </important>
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.allowed_windows.is_none()`.
    pub fn allowed_windows(&self) -> &[::std::string::String] {
        self.allowed_windows.as_deref().unwrap_or_default()
    }
    /// <p>Specify one or more Amazon CloudWatch alarms as the outcome alarms for practice runs.</p>
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.outcome_alarms.is_none()`.
    pub fn outcome_alarms(&self) -> &[crate::types::ControlCondition] {
        self.outcome_alarms.as_deref().unwrap_or_default()
    }
}
impl UpdatePracticeRunConfigurationInput {
    /// Creates a new builder-style object to manufacture [`UpdatePracticeRunConfigurationInput`](crate::operation::update_practice_run_configuration::UpdatePracticeRunConfigurationInput).
    pub fn builder() -> crate::operation::update_practice_run_configuration::builders::UpdatePracticeRunConfigurationInputBuilder {
        crate::operation::update_practice_run_configuration::builders::UpdatePracticeRunConfigurationInputBuilder::default()
    }
}

/// A builder for [`UpdatePracticeRunConfigurationInput`](crate::operation::update_practice_run_configuration::UpdatePracticeRunConfigurationInput).
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::default::Default, ::std::fmt::Debug)]
#[non_exhaustive]
pub struct UpdatePracticeRunConfigurationInputBuilder {
    pub(crate) resource_identifier: ::std::option::Option<::std::string::String>,
    pub(crate) blocked_windows: ::std::option::Option<::std::vec::Vec<::std::string::String>>,
    pub(crate) blocked_dates: ::std::option::Option<::std::vec::Vec<::std::string::String>>,
    pub(crate) blocking_alarms: ::std::option::Option<::std::vec::Vec<crate::types::ControlCondition>>,
    pub(crate) allowed_windows: ::std::option::Option<::std::vec::Vec<::std::string::String>>,
    pub(crate) outcome_alarms: ::std::option::Option<::std::vec::Vec<crate::types::ControlCondition>>,
}
impl UpdatePracticeRunConfigurationInputBuilder {
    /// <p>The identifier for the resource that you want to update the practice run configuration for. The identifier is the Amazon Resource Name (ARN) for the resource.</p>
    /// This field is required.
    pub fn resource_identifier(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.resource_identifier = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The identifier for the resource that you want to update the practice run configuration for. The identifier is the Amazon Resource Name (ARN) for the resource.</p>
    pub fn set_resource_identifier(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.resource_identifier = input;
        self
    }
    /// <p>The identifier for the resource that you want to update the practice run configuration for. The identifier is the Amazon Resource Name (ARN) for the resource.</p>
    pub fn get_resource_identifier(&self) -> &::std::option::Option<::std::string::String> {
        &self.resource_identifier
    }
    /// Appends an item to `blocked_windows`.
    ///
    /// To override the contents of this collection use [`set_blocked_windows`](Self::set_blocked_windows).
    ///
    /// <p>Add, change, or remove windows of days and times for when you can, optionally, block ARC from starting a practice run for a resource.</p>
    /// <p>The format for blocked windows is: DAY:HH:SS-DAY:HH:SS. Keep in mind, when you specify dates, that dates and times for practice runs are in UTC. Also, be aware of potential time adjustments that might be required for daylight saving time differences. Separate multiple blocked windows with spaces.</p>
    /// <p>For example, say you run business report summaries three days a week. For this scenario, you might set the following recurring days and times as blocked windows, for example: <code>MON-20:30-21:30 WED-20:30-21:30 FRI-20:30-21:30</code>.</p>
    pub fn blocked_windows(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        let mut v = self.blocked_windows.unwrap_or_default();
        v.push(input.into());
        self.blocked_windows = ::std::option::Option::Some(v);
        self
    }
    /// <p>Add, change, or remove windows of days and times for when you can, optionally, block ARC from starting a practice run for a resource.</p>
    /// <p>The format for blocked windows is: DAY:HH:SS-DAY:HH:SS. Keep in mind, when you specify dates, that dates and times for practice runs are in UTC. Also, be aware of potential time adjustments that might be required for daylight saving time differences. Separate multiple blocked windows with spaces.</p>
    /// <p>For example, say you run business report summaries three days a week. For this scenario, you might set the following recurring days and times as blocked windows, for example: <code>MON-20:30-21:30 WED-20:30-21:30 FRI-20:30-21:30</code>.</p>
    pub fn set_blocked_windows(mut self, input: ::std::option::Option<::std::vec::Vec<::std::string::String>>) -> Self {
        self.blocked_windows = input;
        self
    }
    /// <p>Add, change, or remove windows of days and times for when you can, optionally, block ARC from starting a practice run for a resource.</p>
    /// <p>The format for blocked windows is: DAY:HH:SS-DAY:HH:SS. Keep in mind, when you specify dates, that dates and times for practice runs are in UTC. Also, be aware of potential time adjustments that might be required for daylight saving time differences. Separate multiple blocked windows with spaces.</p>
    /// <p>For example, say you run business report summaries three days a week. For this scenario, you might set the following recurring days and times as blocked windows, for example: <code>MON-20:30-21:30 WED-20:30-21:30 FRI-20:30-21:30</code>.</p>
    pub fn get_blocked_windows(&self) -> &::std::option::Option<::std::vec::Vec<::std::string::String>> {
        &self.blocked_windows
    }
    /// Appends an item to `blocked_dates`.
    ///
    /// To override the contents of this collection use [`set_blocked_dates`](Self::set_blocked_dates).
    ///
    /// <p>Add, change, or remove blocked dates for a practice run in zonal autoshift.</p>
    /// <p>Optionally, you can block practice runs for specific calendar dates. The format for blocked dates is: YYYY-MM-DD. Keep in mind, when you specify dates, that dates and times for practice runs are in UTC. Separate multiple blocked dates with spaces.</p>
    /// <p>For example, if you have an application update scheduled to launch on May 1, 2024, and you don't want practice runs to shift traffic away at that time, you could set a blocked date for <code>2024-05-01</code>.</p>
    pub fn blocked_dates(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        let mut v = self.blocked_dates.unwrap_or_default();
        v.push(input.into());
        self.blocked_dates = ::std::option::Option::Some(v);
        self
    }
    /// <p>Add, change, or remove blocked dates for a practice run in zonal autoshift.</p>
    /// <p>Optionally, you can block practice runs for specific calendar dates. The format for blocked dates is: YYYY-MM-DD. Keep in mind, when you specify dates, that dates and times for practice runs are in UTC. Separate multiple blocked dates with spaces.</p>
    /// <p>For example, if you have an application update scheduled to launch on May 1, 2024, and you don't want practice runs to shift traffic away at that time, you could set a blocked date for <code>2024-05-01</code>.</p>
    pub fn set_blocked_dates(mut self, input: ::std::option::Option<::std::vec::Vec<::std::string::String>>) -> Self {
        self.blocked_dates = input;
        self
    }
    /// <p>Add, change, or remove blocked dates for a practice run in zonal autoshift.</p>
    /// <p>Optionally, you can block practice runs for specific calendar dates. The format for blocked dates is: YYYY-MM-DD. Keep in mind, when you specify dates, that dates and times for practice runs are in UTC. Separate multiple blocked dates with spaces.</p>
    /// <p>For example, if you have an application update scheduled to launch on May 1, 2024, and you don't want practice runs to shift traffic away at that time, you could set a blocked date for <code>2024-05-01</code>.</p>
    pub fn get_blocked_dates(&self) -> &::std::option::Option<::std::vec::Vec<::std::string::String>> {
        &self.blocked_dates
    }
    /// Appends an item to `blocking_alarms`.
    ///
    /// To override the contents of this collection use [`set_blocking_alarms`](Self::set_blocking_alarms).
    ///
    /// <p>Add, change, or remove the Amazon CloudWatch alarms that you optionally specify as the blocking alarms for practice runs.</p>
    pub fn blocking_alarms(mut self, input: crate::types::ControlCondition) -> Self {
        let mut v = self.blocking_alarms.unwrap_or_default();
        v.push(input);
        self.blocking_alarms = ::std::option::Option::Some(v);
        self
    }
    /// <p>Add, change, or remove the Amazon CloudWatch alarms that you optionally specify as the blocking alarms for practice runs.</p>
    pub fn set_blocking_alarms(mut self, input: ::std::option::Option<::std::vec::Vec<crate::types::ControlCondition>>) -> Self {
        self.blocking_alarms = input;
        self
    }
    /// <p>Add, change, or remove the Amazon CloudWatch alarms that you optionally specify as the blocking alarms for practice runs.</p>
    pub fn get_blocking_alarms(&self) -> &::std::option::Option<::std::vec::Vec<crate::types::ControlCondition>> {
        &self.blocking_alarms
    }
    /// Appends an item to `allowed_windows`.
    ///
    /// To override the contents of this collection use [`set_allowed_windows`](Self::set_allowed_windows).
    ///
    /// <p>Add, change, or remove windows of days and times for when you can, optionally, allow ARC to start a practice run for a resource.</p>
    /// <p>The format for allowed windows is: DAY:HH:SS-DAY:HH:SS. Keep in mind, when you specify dates, that dates and times for practice runs are in UTC. Also, be aware of potential time adjustments that might be required for daylight saving time differences. Separate multiple allowed windows with spaces.</p>
    /// <p>For example, say you want to allow practice runs only on Wednesdays and Fridays from noon to 5 p.m. For this scenario, you could set the following recurring days and times as allowed windows, for example: <code>Wed-12:00-Wed:17:00 Fri-12:00-Fri:17:00</code>.</p><important>
    /// <p>The <code>allowedWindows</code> have to start and end on the same day. Windows that span multiple days aren't supported.</p>
    /// </important>
    pub fn allowed_windows(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        let mut v = self.allowed_windows.unwrap_or_default();
        v.push(input.into());
        self.allowed_windows = ::std::option::Option::Some(v);
        self
    }
    /// <p>Add, change, or remove windows of days and times for when you can, optionally, allow ARC to start a practice run for a resource.</p>
    /// <p>The format for allowed windows is: DAY:HH:SS-DAY:HH:SS. Keep in mind, when you specify dates, that dates and times for practice runs are in UTC. Also, be aware of potential time adjustments that might be required for daylight saving time differences. Separate multiple allowed windows with spaces.</p>
    /// <p>For example, say you want to allow practice runs only on Wednesdays and Fridays from noon to 5 p.m. For this scenario, you could set the following recurring days and times as allowed windows, for example: <code>Wed-12:00-Wed:17:00 Fri-12:00-Fri:17:00</code>.</p><important>
    /// <p>The <code>allowedWindows</code> have to start and end on the same day. Windows that span multiple days aren't supported.</p>
    /// </important>
    pub fn set_allowed_windows(mut self, input: ::std::option::Option<::std::vec::Vec<::std::string::String>>) -> Self {
        self.allowed_windows = input;
        self
    }
    /// <p>Add, change, or remove windows of days and times for when you can, optionally, allow ARC to start a practice run for a resource.</p>
    /// <p>The format for allowed windows is: DAY:HH:SS-DAY:HH:SS. Keep in mind, when you specify dates, that dates and times for practice runs are in UTC. Also, be aware of potential time adjustments that might be required for daylight saving time differences. Separate multiple allowed windows with spaces.</p>
    /// <p>For example, say you want to allow practice runs only on Wednesdays and Fridays from noon to 5 p.m. For this scenario, you could set the following recurring days and times as allowed windows, for example: <code>Wed-12:00-Wed:17:00 Fri-12:00-Fri:17:00</code>.</p><important>
    /// <p>The <code>allowedWindows</code> have to start and end on the same day. Windows that span multiple days aren't supported.</p>
    /// </important>
    pub fn get_allowed_windows(&self) -> &::std::option::Option<::std::vec::Vec<::std::string::String>> {
        &self.allowed_windows
    }
    /// Appends an item to `outcome_alarms`.
    ///
    /// To override the contents of this collection use [`set_outcome_alarms`](Self::set_outcome_alarms).
    ///
    /// <p>Specify one or more Amazon CloudWatch alarms as the outcome alarms for practice runs.</p>
    pub fn outcome_alarms(mut self, input: crate::types::ControlCondition) -> Self {
        let mut v = self.outcome_alarms.unwrap_or_default();
        v.push(input);
        self.outcome_alarms = ::std::option::Option::Some(v);
        self
    }
    /// <p>Specify one or more Amazon CloudWatch alarms as the outcome alarms for practice runs.</p>
    pub fn set_outcome_alarms(mut self, input: ::std::option::Option<::std::vec::Vec<crate::types::ControlCondition>>) -> Self {
        self.outcome_alarms = input;
        self
    }
    /// <p>Specify one or more Amazon CloudWatch alarms as the outcome alarms for practice runs.</p>
    pub fn get_outcome_alarms(&self) -> &::std::option::Option<::std::vec::Vec<crate::types::ControlCondition>> {
        &self.outcome_alarms
    }
    /// Consumes the builder and constructs a [`UpdatePracticeRunConfigurationInput`](crate::operation::update_practice_run_configuration::UpdatePracticeRunConfigurationInput).
    pub fn build(
        self,
    ) -> ::std::result::Result<
        crate::operation::update_practice_run_configuration::UpdatePracticeRunConfigurationInput,
        ::aws_smithy_types::error::operation::BuildError,
    > {
        ::std::result::Result::Ok(crate::operation::update_practice_run_configuration::UpdatePracticeRunConfigurationInput {
            resource_identifier: self.resource_identifier,
            blocked_windows: self.blocked_windows,
            blocked_dates: self.blocked_dates,
            blocking_alarms: self.blocking_alarms,
            allowed_windows: self.allowed_windows,
            outcome_alarms: self.outcome_alarms,
        })
    }
}
