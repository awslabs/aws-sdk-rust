// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
pub use crate::operation::create_simulation_job::_create_simulation_job_output::CreateSimulationJobOutputBuilder;

pub use crate::operation::create_simulation_job::_create_simulation_job_input::CreateSimulationJobInputBuilder;

impl CreateSimulationJobInputBuilder {
    /// Sends a request with this input using the given client.
    pub async fn send_with(
        self,
        client: &crate::Client,
    ) -> ::std::result::Result<
        crate::operation::create_simulation_job::CreateSimulationJobOutput,
        ::aws_smithy_runtime_api::client::result::SdkError<
            crate::operation::create_simulation_job::CreateSimulationJobError,
            ::aws_smithy_runtime_api::client::orchestrator::HttpResponse,
        >,
    > {
        let mut fluent_builder = client.create_simulation_job();
        fluent_builder.inner = self;
        fluent_builder.send().await
    }
}
/// Fluent builder constructing a request to `CreateSimulationJob`.
///
/// <p>Creates a simulation job.</p><note>
/// <p>After 90 days, simulation jobs expire and will be deleted. They will no longer be accessible.</p>
/// </note>
#[derive(::std::clone::Clone, ::std::fmt::Debug)]
pub struct CreateSimulationJobFluentBuilder {
    handle: ::std::sync::Arc<crate::client::Handle>,
    inner: crate::operation::create_simulation_job::builders::CreateSimulationJobInputBuilder,
    config_override: ::std::option::Option<crate::config::Builder>,
}
impl
    crate::client::customize::internal::CustomizableSend<
        crate::operation::create_simulation_job::CreateSimulationJobOutput,
        crate::operation::create_simulation_job::CreateSimulationJobError,
    > for CreateSimulationJobFluentBuilder
{
    fn send(
        self,
        config_override: crate::config::Builder,
    ) -> crate::client::customize::internal::BoxFuture<
        crate::client::customize::internal::SendResult<
            crate::operation::create_simulation_job::CreateSimulationJobOutput,
            crate::operation::create_simulation_job::CreateSimulationJobError,
        >,
    > {
        ::std::boxed::Box::pin(async move { self.config_override(config_override).send().await })
    }
}
impl CreateSimulationJobFluentBuilder {
    /// Creates a new `CreateSimulationJob`.
    pub(crate) fn new(handle: ::std::sync::Arc<crate::client::Handle>) -> Self {
        Self {
            handle,
            inner: ::std::default::Default::default(),
            config_override: ::std::option::Option::None,
        }
    }
    /// Access the CreateSimulationJob as a reference.
    pub fn as_input(&self) -> &crate::operation::create_simulation_job::builders::CreateSimulationJobInputBuilder {
        &self.inner
    }
    /// Sends the request and returns the response.
    ///
    /// If an error occurs, an `SdkError` will be returned with additional details that
    /// can be matched against.
    ///
    /// By default, any retryable failures will be retried twice. Retry behavior
    /// is configurable with the [RetryConfig](aws_smithy_types::retry::RetryConfig), which can be
    /// set when configuring the client.
    pub async fn send(
        self,
    ) -> ::std::result::Result<
        crate::operation::create_simulation_job::CreateSimulationJobOutput,
        ::aws_smithy_runtime_api::client::result::SdkError<
            crate::operation::create_simulation_job::CreateSimulationJobError,
            ::aws_smithy_runtime_api::client::orchestrator::HttpResponse,
        >,
    > {
        let input = self
            .inner
            .build()
            .map_err(::aws_smithy_runtime_api::client::result::SdkError::construction_failure)?;
        let runtime_plugins = crate::operation::create_simulation_job::CreateSimulationJob::operation_runtime_plugins(
            self.handle.runtime_plugins.clone(),
            &self.handle.conf,
            self.config_override,
        );
        crate::operation::create_simulation_job::CreateSimulationJob::orchestrate(&runtime_plugins, input).await
    }

    /// Consumes this builder, creating a customizable operation that can be modified before being sent.
    pub fn customize(
        self,
    ) -> crate::client::customize::CustomizableOperation<
        crate::operation::create_simulation_job::CreateSimulationJobOutput,
        crate::operation::create_simulation_job::CreateSimulationJobError,
        Self,
    > {
        crate::client::customize::CustomizableOperation::new(self)
    }
    pub(crate) fn config_override(mut self, config_override: impl Into<crate::config::Builder>) -> Self {
        self.set_config_override(Some(config_override.into()));
        self
    }

    pub(crate) fn set_config_override(&mut self, config_override: Option<crate::config::Builder>) -> &mut Self {
        self.config_override = config_override;
        self
    }
    /// <p>Unique, case-sensitive identifier that you provide to ensure the idempotency of the request.</p>
    pub fn client_request_token(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.inner = self.inner.client_request_token(input.into());
        self
    }
    /// <p>Unique, case-sensitive identifier that you provide to ensure the idempotency of the request.</p>
    pub fn set_client_request_token(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.inner = self.inner.set_client_request_token(input);
        self
    }
    /// <p>Unique, case-sensitive identifier that you provide to ensure the idempotency of the request.</p>
    pub fn get_client_request_token(&self) -> &::std::option::Option<::std::string::String> {
        self.inner.get_client_request_token()
    }
    /// <p>Location for output files generated by the simulation job.</p>
    pub fn output_location(mut self, input: crate::types::OutputLocation) -> Self {
        self.inner = self.inner.output_location(input);
        self
    }
    /// <p>Location for output files generated by the simulation job.</p>
    pub fn set_output_location(mut self, input: ::std::option::Option<crate::types::OutputLocation>) -> Self {
        self.inner = self.inner.set_output_location(input);
        self
    }
    /// <p>Location for output files generated by the simulation job.</p>
    pub fn get_output_location(&self) -> &::std::option::Option<crate::types::OutputLocation> {
        self.inner.get_output_location()
    }
    /// <p>The logging configuration.</p>
    pub fn logging_config(mut self, input: crate::types::LoggingConfig) -> Self {
        self.inner = self.inner.logging_config(input);
        self
    }
    /// <p>The logging configuration.</p>
    pub fn set_logging_config(mut self, input: ::std::option::Option<crate::types::LoggingConfig>) -> Self {
        self.inner = self.inner.set_logging_config(input);
        self
    }
    /// <p>The logging configuration.</p>
    pub fn get_logging_config(&self) -> &::std::option::Option<crate::types::LoggingConfig> {
        self.inner.get_logging_config()
    }
    /// <p>The maximum simulation job duration in seconds (up to 14 days or 1,209,600 seconds. When <code>maxJobDurationInSeconds</code> is reached, the simulation job will status will transition to <code>Completed</code>.</p>
    pub fn max_job_duration_in_seconds(mut self, input: i64) -> Self {
        self.inner = self.inner.max_job_duration_in_seconds(input);
        self
    }
    /// <p>The maximum simulation job duration in seconds (up to 14 days or 1,209,600 seconds. When <code>maxJobDurationInSeconds</code> is reached, the simulation job will status will transition to <code>Completed</code>.</p>
    pub fn set_max_job_duration_in_seconds(mut self, input: ::std::option::Option<i64>) -> Self {
        self.inner = self.inner.set_max_job_duration_in_seconds(input);
        self
    }
    /// <p>The maximum simulation job duration in seconds (up to 14 days or 1,209,600 seconds. When <code>maxJobDurationInSeconds</code> is reached, the simulation job will status will transition to <code>Completed</code>.</p>
    pub fn get_max_job_duration_in_seconds(&self) -> &::std::option::Option<i64> {
        self.inner.get_max_job_duration_in_seconds()
    }
    /// <p>The IAM role name that allows the simulation instance to call the AWS APIs that are specified in its associated policies on your behalf. This is how credentials are passed in to your simulation job.</p>
    pub fn iam_role(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.inner = self.inner.iam_role(input.into());
        self
    }
    /// <p>The IAM role name that allows the simulation instance to call the AWS APIs that are specified in its associated policies on your behalf. This is how credentials are passed in to your simulation job.</p>
    pub fn set_iam_role(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.inner = self.inner.set_iam_role(input);
        self
    }
    /// <p>The IAM role name that allows the simulation instance to call the AWS APIs that are specified in its associated policies on your behalf. This is how credentials are passed in to your simulation job.</p>
    pub fn get_iam_role(&self) -> &::std::option::Option<::std::string::String> {
        self.inner.get_iam_role()
    }
    /// <p>The failure behavior the simulation job.</p>
    /// <dl>
    /// <dt>
    /// Continue
    /// </dt>
    /// <dd>
    /// <p>Leaves the instance running for its maximum timeout duration after a <code>4XX</code> error code.</p>
    /// </dd>
    /// <dt>
    /// Fail
    /// </dt>
    /// <dd>
    /// <p>Stop the simulation job and terminate the instance.</p>
    /// </dd>
    /// </dl>
    pub fn failure_behavior(mut self, input: crate::types::FailureBehavior) -> Self {
        self.inner = self.inner.failure_behavior(input);
        self
    }
    /// <p>The failure behavior the simulation job.</p>
    /// <dl>
    /// <dt>
    /// Continue
    /// </dt>
    /// <dd>
    /// <p>Leaves the instance running for its maximum timeout duration after a <code>4XX</code> error code.</p>
    /// </dd>
    /// <dt>
    /// Fail
    /// </dt>
    /// <dd>
    /// <p>Stop the simulation job and terminate the instance.</p>
    /// </dd>
    /// </dl>
    pub fn set_failure_behavior(mut self, input: ::std::option::Option<crate::types::FailureBehavior>) -> Self {
        self.inner = self.inner.set_failure_behavior(input);
        self
    }
    /// <p>The failure behavior the simulation job.</p>
    /// <dl>
    /// <dt>
    /// Continue
    /// </dt>
    /// <dd>
    /// <p>Leaves the instance running for its maximum timeout duration after a <code>4XX</code> error code.</p>
    /// </dd>
    /// <dt>
    /// Fail
    /// </dt>
    /// <dd>
    /// <p>Stop the simulation job and terminate the instance.</p>
    /// </dd>
    /// </dl>
    pub fn get_failure_behavior(&self) -> &::std::option::Option<crate::types::FailureBehavior> {
        self.inner.get_failure_behavior()
    }
    /// Appends an item to `robotApplications`.
    ///
    /// To override the contents of this collection use [`set_robot_applications`](Self::set_robot_applications).
    ///
    /// <p>The robot application to use in the simulation job.</p>
    pub fn robot_applications(mut self, input: crate::types::RobotApplicationConfig) -> Self {
        self.inner = self.inner.robot_applications(input);
        self
    }
    /// <p>The robot application to use in the simulation job.</p>
    pub fn set_robot_applications(mut self, input: ::std::option::Option<::std::vec::Vec<crate::types::RobotApplicationConfig>>) -> Self {
        self.inner = self.inner.set_robot_applications(input);
        self
    }
    /// <p>The robot application to use in the simulation job.</p>
    pub fn get_robot_applications(&self) -> &::std::option::Option<::std::vec::Vec<crate::types::RobotApplicationConfig>> {
        self.inner.get_robot_applications()
    }
    /// Appends an item to `simulationApplications`.
    ///
    /// To override the contents of this collection use [`set_simulation_applications`](Self::set_simulation_applications).
    ///
    /// <p>The simulation application to use in the simulation job.</p>
    pub fn simulation_applications(mut self, input: crate::types::SimulationApplicationConfig) -> Self {
        self.inner = self.inner.simulation_applications(input);
        self
    }
    /// <p>The simulation application to use in the simulation job.</p>
    pub fn set_simulation_applications(mut self, input: ::std::option::Option<::std::vec::Vec<crate::types::SimulationApplicationConfig>>) -> Self {
        self.inner = self.inner.set_simulation_applications(input);
        self
    }
    /// <p>The simulation application to use in the simulation job.</p>
    pub fn get_simulation_applications(&self) -> &::std::option::Option<::std::vec::Vec<crate::types::SimulationApplicationConfig>> {
        self.inner.get_simulation_applications()
    }
    /// Appends an item to `dataSources`.
    ///
    /// To override the contents of this collection use [`set_data_sources`](Self::set_data_sources).
    ///
    /// <p>Specify data sources to mount read-only files from S3 into your simulation. These files are available under <code>/opt/robomaker/datasources/data_source_name</code>.</p><note>
    /// <p>There is a limit of 100 files and a combined size of 25GB for all <code>DataSourceConfig</code> objects.</p>
    /// </note>
    pub fn data_sources(mut self, input: crate::types::DataSourceConfig) -> Self {
        self.inner = self.inner.data_sources(input);
        self
    }
    /// <p>Specify data sources to mount read-only files from S3 into your simulation. These files are available under <code>/opt/robomaker/datasources/data_source_name</code>.</p><note>
    /// <p>There is a limit of 100 files and a combined size of 25GB for all <code>DataSourceConfig</code> objects.</p>
    /// </note>
    pub fn set_data_sources(mut self, input: ::std::option::Option<::std::vec::Vec<crate::types::DataSourceConfig>>) -> Self {
        self.inner = self.inner.set_data_sources(input);
        self
    }
    /// <p>Specify data sources to mount read-only files from S3 into your simulation. These files are available under <code>/opt/robomaker/datasources/data_source_name</code>.</p><note>
    /// <p>There is a limit of 100 files and a combined size of 25GB for all <code>DataSourceConfig</code> objects.</p>
    /// </note>
    pub fn get_data_sources(&self) -> &::std::option::Option<::std::vec::Vec<crate::types::DataSourceConfig>> {
        self.inner.get_data_sources()
    }
    /// Adds a key-value pair to `tags`.
    ///
    /// To override the contents of this collection use [`set_tags`](Self::set_tags).
    ///
    /// <p>A map that contains tag keys and tag values that are attached to the simulation job.</p>
    pub fn tags(mut self, k: impl ::std::convert::Into<::std::string::String>, v: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.inner = self.inner.tags(k.into(), v.into());
        self
    }
    /// <p>A map that contains tag keys and tag values that are attached to the simulation job.</p>
    pub fn set_tags(mut self, input: ::std::option::Option<::std::collections::HashMap<::std::string::String, ::std::string::String>>) -> Self {
        self.inner = self.inner.set_tags(input);
        self
    }
    /// <p>A map that contains tag keys and tag values that are attached to the simulation job.</p>
    pub fn get_tags(&self) -> &::std::option::Option<::std::collections::HashMap<::std::string::String, ::std::string::String>> {
        self.inner.get_tags()
    }
    /// <p>If your simulation job accesses resources in a VPC, you provide this parameter identifying the list of security group IDs and subnet IDs. These must belong to the same VPC. You must provide at least one security group and one subnet ID.</p>
    pub fn vpc_config(mut self, input: crate::types::VpcConfig) -> Self {
        self.inner = self.inner.vpc_config(input);
        self
    }
    /// <p>If your simulation job accesses resources in a VPC, you provide this parameter identifying the list of security group IDs and subnet IDs. These must belong to the same VPC. You must provide at least one security group and one subnet ID.</p>
    pub fn set_vpc_config(mut self, input: ::std::option::Option<crate::types::VpcConfig>) -> Self {
        self.inner = self.inner.set_vpc_config(input);
        self
    }
    /// <p>If your simulation job accesses resources in a VPC, you provide this parameter identifying the list of security group IDs and subnet IDs. These must belong to the same VPC. You must provide at least one security group and one subnet ID.</p>
    pub fn get_vpc_config(&self) -> &::std::option::Option<crate::types::VpcConfig> {
        self.inner.get_vpc_config()
    }
    /// <p>Compute information for the simulation job.</p>
    pub fn compute(mut self, input: crate::types::Compute) -> Self {
        self.inner = self.inner.compute(input);
        self
    }
    /// <p>Compute information for the simulation job.</p>
    pub fn set_compute(mut self, input: ::std::option::Option<crate::types::Compute>) -> Self {
        self.inner = self.inner.set_compute(input);
        self
    }
    /// <p>Compute information for the simulation job.</p>
    pub fn get_compute(&self) -> &::std::option::Option<crate::types::Compute> {
        self.inner.get_compute()
    }
}
