// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
/// <p>Information about a template location.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TemplateLocation {
    /// <p>The Amazon S3 bucket name.</p>
    pub s3_bucket: std::option::Option<std::string::String>,
    /// <p>The list of S3 keys identifying the data source files.</p>
    pub s3_key: std::option::Option<std::string::String>,
}
impl TemplateLocation {
    /// <p>The Amazon S3 bucket name.</p>
    pub fn s3_bucket(&self) -> std::option::Option<&str> {
        self.s3_bucket.as_deref()
    }
    /// <p>The list of S3 keys identifying the data source files.</p>
    pub fn s3_key(&self) -> std::option::Option<&str> {
        self.s3_key.as_deref()
    }
}
impl std::fmt::Debug for TemplateLocation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TemplateLocation");
        formatter.field("s3_bucket", &self.s3_bucket);
        formatter.field("s3_key", &self.s3_key);
        formatter.finish()
    }
}
/// See [`TemplateLocation`](crate::model::TemplateLocation)
pub mod template_location {
    /// A builder for [`TemplateLocation`](crate::model::TemplateLocation)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) s3_bucket: std::option::Option<std::string::String>,
        pub(crate) s3_key: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon S3 bucket name.</p>
        pub fn s3_bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.s3_bucket = Some(input.into());
            self
        }
        /// <p>The Amazon S3 bucket name.</p>
        pub fn set_s3_bucket(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.s3_bucket = input;
            self
        }
        /// <p>The list of S3 keys identifying the data source files.</p>
        pub fn s3_key(mut self, input: impl Into<std::string::String>) -> Self {
            self.s3_key = Some(input.into());
            self
        }
        /// <p>The list of S3 keys identifying the data source files.</p>
        pub fn set_s3_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.s3_key = input;
            self
        }
        /// Consumes the builder and constructs a [`TemplateLocation`](crate::model::TemplateLocation)
        pub fn build(self) -> crate::model::TemplateLocation {
            crate::model::TemplateLocation {
                s3_bucket: self.s3_bucket,
                s3_key: self.s3_key,
            }
        }
    }
}
impl TemplateLocation {
    /// Creates a new builder-style object to manufacture [`TemplateLocation`](crate::model::TemplateLocation)
    pub fn builder() -> crate::model::template_location::Builder {
        crate::model::template_location::Builder::default()
    }
}

/// <p>The object that contains the Docker image URI for either your robot or simulation
/// applications.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Environment {
    /// <p>The Docker image URI for either your robot or simulation applications.</p>
    pub uri: std::option::Option<std::string::String>,
}
impl Environment {
    /// <p>The Docker image URI for either your robot or simulation applications.</p>
    pub fn uri(&self) -> std::option::Option<&str> {
        self.uri.as_deref()
    }
}
impl std::fmt::Debug for Environment {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Environment");
        formatter.field("uri", &self.uri);
        formatter.finish()
    }
}
/// See [`Environment`](crate::model::Environment)
pub mod environment {
    /// A builder for [`Environment`](crate::model::Environment)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) uri: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Docker image URI for either your robot or simulation applications.</p>
        pub fn uri(mut self, input: impl Into<std::string::String>) -> Self {
            self.uri = Some(input.into());
            self
        }
        /// <p>The Docker image URI for either your robot or simulation applications.</p>
        pub fn set_uri(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.uri = input;
            self
        }
        /// Consumes the builder and constructs a [`Environment`](crate::model::Environment)
        pub fn build(self) -> crate::model::Environment {
            crate::model::Environment { uri: self.uri }
        }
    }
}
impl Environment {
    /// Creates a new builder-style object to manufacture [`Environment`](crate::model::Environment)
    pub fn builder() -> crate::model::environment::Builder {
        crate::model::environment::Builder::default()
    }
}

/// <p>Information about a rendering engine.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct RenderingEngine {
    /// <p>The name of the rendering engine.</p>
    pub name: std::option::Option<crate::model::RenderingEngineType>,
    /// <p>The version of the rendering engine.</p>
    pub version: std::option::Option<std::string::String>,
}
impl RenderingEngine {
    /// <p>The name of the rendering engine.</p>
    pub fn name(&self) -> std::option::Option<&crate::model::RenderingEngineType> {
        self.name.as_ref()
    }
    /// <p>The version of the rendering engine.</p>
    pub fn version(&self) -> std::option::Option<&str> {
        self.version.as_deref()
    }
}
impl std::fmt::Debug for RenderingEngine {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("RenderingEngine");
        formatter.field("name", &self.name);
        formatter.field("version", &self.version);
        formatter.finish()
    }
}
/// See [`RenderingEngine`](crate::model::RenderingEngine)
pub mod rendering_engine {
    /// A builder for [`RenderingEngine`](crate::model::RenderingEngine)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<crate::model::RenderingEngineType>,
        pub(crate) version: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the rendering engine.</p>
        pub fn name(mut self, input: crate::model::RenderingEngineType) -> Self {
            self.name = Some(input);
            self
        }
        /// <p>The name of the rendering engine.</p>
        pub fn set_name(
            mut self,
            input: std::option::Option<crate::model::RenderingEngineType>,
        ) -> Self {
            self.name = input;
            self
        }
        /// <p>The version of the rendering engine.</p>
        pub fn version(mut self, input: impl Into<std::string::String>) -> Self {
            self.version = Some(input.into());
            self
        }
        /// <p>The version of the rendering engine.</p>
        pub fn set_version(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.version = input;
            self
        }
        /// Consumes the builder and constructs a [`RenderingEngine`](crate::model::RenderingEngine)
        pub fn build(self) -> crate::model::RenderingEngine {
            crate::model::RenderingEngine {
                name: self.name,
                version: self.version,
            }
        }
    }
}
impl RenderingEngine {
    /// Creates a new builder-style object to manufacture [`RenderingEngine`](crate::model::RenderingEngine)
    pub fn builder() -> crate::model::rendering_engine::Builder {
        crate::model::rendering_engine::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum RenderingEngineType {
    #[allow(missing_docs)] // documentation missing in model
    Ogre,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for RenderingEngineType {
    fn from(s: &str) -> Self {
        match s {
            "OGRE" => RenderingEngineType::Ogre,
            other => RenderingEngineType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for RenderingEngineType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(RenderingEngineType::from(s))
    }
}
impl RenderingEngineType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            RenderingEngineType::Ogre => "OGRE",
            RenderingEngineType::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["OGRE"]
    }
}
impl AsRef<str> for RenderingEngineType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Information about a robot software suite (ROS distribution).</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct RobotSoftwareSuite {
    /// <p>The name of the robot software suite (ROS distribution).</p>
    pub name: std::option::Option<crate::model::RobotSoftwareSuiteType>,
    /// <p>The version of the robot software suite (ROS distribution).</p>
    pub version: std::option::Option<crate::model::RobotSoftwareSuiteVersionType>,
}
impl RobotSoftwareSuite {
    /// <p>The name of the robot software suite (ROS distribution).</p>
    pub fn name(&self) -> std::option::Option<&crate::model::RobotSoftwareSuiteType> {
        self.name.as_ref()
    }
    /// <p>The version of the robot software suite (ROS distribution).</p>
    pub fn version(&self) -> std::option::Option<&crate::model::RobotSoftwareSuiteVersionType> {
        self.version.as_ref()
    }
}
impl std::fmt::Debug for RobotSoftwareSuite {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("RobotSoftwareSuite");
        formatter.field("name", &self.name);
        formatter.field("version", &self.version);
        formatter.finish()
    }
}
/// See [`RobotSoftwareSuite`](crate::model::RobotSoftwareSuite)
pub mod robot_software_suite {
    /// A builder for [`RobotSoftwareSuite`](crate::model::RobotSoftwareSuite)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<crate::model::RobotSoftwareSuiteType>,
        pub(crate) version: std::option::Option<crate::model::RobotSoftwareSuiteVersionType>,
    }
    impl Builder {
        /// <p>The name of the robot software suite (ROS distribution).</p>
        pub fn name(mut self, input: crate::model::RobotSoftwareSuiteType) -> Self {
            self.name = Some(input);
            self
        }
        /// <p>The name of the robot software suite (ROS distribution).</p>
        pub fn set_name(
            mut self,
            input: std::option::Option<crate::model::RobotSoftwareSuiteType>,
        ) -> Self {
            self.name = input;
            self
        }
        /// <p>The version of the robot software suite (ROS distribution).</p>
        pub fn version(mut self, input: crate::model::RobotSoftwareSuiteVersionType) -> Self {
            self.version = Some(input);
            self
        }
        /// <p>The version of the robot software suite (ROS distribution).</p>
        pub fn set_version(
            mut self,
            input: std::option::Option<crate::model::RobotSoftwareSuiteVersionType>,
        ) -> Self {
            self.version = input;
            self
        }
        /// Consumes the builder and constructs a [`RobotSoftwareSuite`](crate::model::RobotSoftwareSuite)
        pub fn build(self) -> crate::model::RobotSoftwareSuite {
            crate::model::RobotSoftwareSuite {
                name: self.name,
                version: self.version,
            }
        }
    }
}
impl RobotSoftwareSuite {
    /// Creates a new builder-style object to manufacture [`RobotSoftwareSuite`](crate::model::RobotSoftwareSuite)
    pub fn builder() -> crate::model::robot_software_suite::Builder {
        crate::model::robot_software_suite::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum RobotSoftwareSuiteVersionType {
    #[allow(missing_docs)] // documentation missing in model
    Dashing,
    #[allow(missing_docs)] // documentation missing in model
    Foxy,
    #[allow(missing_docs)] // documentation missing in model
    Kinetic,
    #[allow(missing_docs)] // documentation missing in model
    Melodic,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for RobotSoftwareSuiteVersionType {
    fn from(s: &str) -> Self {
        match s {
            "Dashing" => RobotSoftwareSuiteVersionType::Dashing,
            "Foxy" => RobotSoftwareSuiteVersionType::Foxy,
            "Kinetic" => RobotSoftwareSuiteVersionType::Kinetic,
            "Melodic" => RobotSoftwareSuiteVersionType::Melodic,
            other => RobotSoftwareSuiteVersionType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for RobotSoftwareSuiteVersionType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(RobotSoftwareSuiteVersionType::from(s))
    }
}
impl RobotSoftwareSuiteVersionType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            RobotSoftwareSuiteVersionType::Dashing => "Dashing",
            RobotSoftwareSuiteVersionType::Foxy => "Foxy",
            RobotSoftwareSuiteVersionType::Kinetic => "Kinetic",
            RobotSoftwareSuiteVersionType::Melodic => "Melodic",
            RobotSoftwareSuiteVersionType::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["Dashing", "Foxy", "Kinetic", "Melodic"]
    }
}
impl AsRef<str> for RobotSoftwareSuiteVersionType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum RobotSoftwareSuiteType {
    #[allow(missing_docs)] // documentation missing in model
    General,
    #[allow(missing_docs)] // documentation missing in model
    Ros,
    #[allow(missing_docs)] // documentation missing in model
    Ros2,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for RobotSoftwareSuiteType {
    fn from(s: &str) -> Self {
        match s {
            "General" => RobotSoftwareSuiteType::General,
            "ROS" => RobotSoftwareSuiteType::Ros,
            "ROS2" => RobotSoftwareSuiteType::Ros2,
            other => RobotSoftwareSuiteType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for RobotSoftwareSuiteType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(RobotSoftwareSuiteType::from(s))
    }
}
impl RobotSoftwareSuiteType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            RobotSoftwareSuiteType::General => "General",
            RobotSoftwareSuiteType::Ros => "ROS",
            RobotSoftwareSuiteType::Ros2 => "ROS2",
            RobotSoftwareSuiteType::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["General", "ROS", "ROS2"]
    }
}
impl AsRef<str> for RobotSoftwareSuiteType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Information about a simulation software suite.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SimulationSoftwareSuite {
    /// <p>The name of the simulation software suite.</p>
    pub name: std::option::Option<crate::model::SimulationSoftwareSuiteType>,
    /// <p>The version of the simulation software suite.</p>
    pub version: std::option::Option<std::string::String>,
}
impl SimulationSoftwareSuite {
    /// <p>The name of the simulation software suite.</p>
    pub fn name(&self) -> std::option::Option<&crate::model::SimulationSoftwareSuiteType> {
        self.name.as_ref()
    }
    /// <p>The version of the simulation software suite.</p>
    pub fn version(&self) -> std::option::Option<&str> {
        self.version.as_deref()
    }
}
impl std::fmt::Debug for SimulationSoftwareSuite {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SimulationSoftwareSuite");
        formatter.field("name", &self.name);
        formatter.field("version", &self.version);
        formatter.finish()
    }
}
/// See [`SimulationSoftwareSuite`](crate::model::SimulationSoftwareSuite)
pub mod simulation_software_suite {
    /// A builder for [`SimulationSoftwareSuite`](crate::model::SimulationSoftwareSuite)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<crate::model::SimulationSoftwareSuiteType>,
        pub(crate) version: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the simulation software suite.</p>
        pub fn name(mut self, input: crate::model::SimulationSoftwareSuiteType) -> Self {
            self.name = Some(input);
            self
        }
        /// <p>The name of the simulation software suite.</p>
        pub fn set_name(
            mut self,
            input: std::option::Option<crate::model::SimulationSoftwareSuiteType>,
        ) -> Self {
            self.name = input;
            self
        }
        /// <p>The version of the simulation software suite.</p>
        pub fn version(mut self, input: impl Into<std::string::String>) -> Self {
            self.version = Some(input.into());
            self
        }
        /// <p>The version of the simulation software suite.</p>
        pub fn set_version(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.version = input;
            self
        }
        /// Consumes the builder and constructs a [`SimulationSoftwareSuite`](crate::model::SimulationSoftwareSuite)
        pub fn build(self) -> crate::model::SimulationSoftwareSuite {
            crate::model::SimulationSoftwareSuite {
                name: self.name,
                version: self.version,
            }
        }
    }
}
impl SimulationSoftwareSuite {
    /// Creates a new builder-style object to manufacture [`SimulationSoftwareSuite`](crate::model::SimulationSoftwareSuite)
    pub fn builder() -> crate::model::simulation_software_suite::Builder {
        crate::model::simulation_software_suite::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum SimulationSoftwareSuiteType {
    #[allow(missing_docs)] // documentation missing in model
    Gazebo,
    #[allow(missing_docs)] // documentation missing in model
    RosbagPlay,
    #[allow(missing_docs)] // documentation missing in model
    SimulationRuntime,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for SimulationSoftwareSuiteType {
    fn from(s: &str) -> Self {
        match s {
            "Gazebo" => SimulationSoftwareSuiteType::Gazebo,
            "RosbagPlay" => SimulationSoftwareSuiteType::RosbagPlay,
            "SimulationRuntime" => SimulationSoftwareSuiteType::SimulationRuntime,
            other => SimulationSoftwareSuiteType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for SimulationSoftwareSuiteType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(SimulationSoftwareSuiteType::from(s))
    }
}
impl SimulationSoftwareSuiteType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            SimulationSoftwareSuiteType::Gazebo => "Gazebo",
            SimulationSoftwareSuiteType::RosbagPlay => "RosbagPlay",
            SimulationSoftwareSuiteType::SimulationRuntime => "SimulationRuntime",
            SimulationSoftwareSuiteType::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["Gazebo", "RosbagPlay", "SimulationRuntime"]
    }
}
impl AsRef<str> for SimulationSoftwareSuiteType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Information about a source.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Source {
    /// <p>The s3 bucket name.</p>
    pub s3_bucket: std::option::Option<std::string::String>,
    /// <p>The s3 object key.</p>
    pub s3_key: std::option::Option<std::string::String>,
    /// <p>A hash of the object specified by <code>s3Bucket</code> and <code>s3Key</code>.</p>
    pub etag: std::option::Option<std::string::String>,
    /// <p>The taget processor architecture for the application.</p>
    pub architecture: std::option::Option<crate::model::Architecture>,
}
impl Source {
    /// <p>The s3 bucket name.</p>
    pub fn s3_bucket(&self) -> std::option::Option<&str> {
        self.s3_bucket.as_deref()
    }
    /// <p>The s3 object key.</p>
    pub fn s3_key(&self) -> std::option::Option<&str> {
        self.s3_key.as_deref()
    }
    /// <p>A hash of the object specified by <code>s3Bucket</code> and <code>s3Key</code>.</p>
    pub fn etag(&self) -> std::option::Option<&str> {
        self.etag.as_deref()
    }
    /// <p>The taget processor architecture for the application.</p>
    pub fn architecture(&self) -> std::option::Option<&crate::model::Architecture> {
        self.architecture.as_ref()
    }
}
impl std::fmt::Debug for Source {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Source");
        formatter.field("s3_bucket", &self.s3_bucket);
        formatter.field("s3_key", &self.s3_key);
        formatter.field("etag", &self.etag);
        formatter.field("architecture", &self.architecture);
        formatter.finish()
    }
}
/// See [`Source`](crate::model::Source)
pub mod source {
    /// A builder for [`Source`](crate::model::Source)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) s3_bucket: std::option::Option<std::string::String>,
        pub(crate) s3_key: std::option::Option<std::string::String>,
        pub(crate) etag: std::option::Option<std::string::String>,
        pub(crate) architecture: std::option::Option<crate::model::Architecture>,
    }
    impl Builder {
        /// <p>The s3 bucket name.</p>
        pub fn s3_bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.s3_bucket = Some(input.into());
            self
        }
        /// <p>The s3 bucket name.</p>
        pub fn set_s3_bucket(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.s3_bucket = input;
            self
        }
        /// <p>The s3 object key.</p>
        pub fn s3_key(mut self, input: impl Into<std::string::String>) -> Self {
            self.s3_key = Some(input.into());
            self
        }
        /// <p>The s3 object key.</p>
        pub fn set_s3_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.s3_key = input;
            self
        }
        /// <p>A hash of the object specified by <code>s3Bucket</code> and <code>s3Key</code>.</p>
        pub fn etag(mut self, input: impl Into<std::string::String>) -> Self {
            self.etag = Some(input.into());
            self
        }
        /// <p>A hash of the object specified by <code>s3Bucket</code> and <code>s3Key</code>.</p>
        pub fn set_etag(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.etag = input;
            self
        }
        /// <p>The taget processor architecture for the application.</p>
        pub fn architecture(mut self, input: crate::model::Architecture) -> Self {
            self.architecture = Some(input);
            self
        }
        /// <p>The taget processor architecture for the application.</p>
        pub fn set_architecture(
            mut self,
            input: std::option::Option<crate::model::Architecture>,
        ) -> Self {
            self.architecture = input;
            self
        }
        /// Consumes the builder and constructs a [`Source`](crate::model::Source)
        pub fn build(self) -> crate::model::Source {
            crate::model::Source {
                s3_bucket: self.s3_bucket,
                s3_key: self.s3_key,
                etag: self.etag,
                architecture: self.architecture,
            }
        }
    }
}
impl Source {
    /// Creates a new builder-style object to manufacture [`Source`](crate::model::Source)
    pub fn builder() -> crate::model::source::Builder {
        crate::model::source::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum Architecture {
    #[allow(missing_docs)] // documentation missing in model
    Arm64,
    #[allow(missing_docs)] // documentation missing in model
    Armhf,
    #[allow(missing_docs)] // documentation missing in model
    X8664,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for Architecture {
    fn from(s: &str) -> Self {
        match s {
            "ARM64" => Architecture::Arm64,
            "ARMHF" => Architecture::Armhf,
            "X86_64" => Architecture::X8664,
            other => Architecture::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for Architecture {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(Architecture::from(s))
    }
}
impl Architecture {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            Architecture::Arm64 => "ARM64",
            Architecture::Armhf => "ARMHF",
            Architecture::X8664 => "X86_64",
            Architecture::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["ARM64", "ARMHF", "X86_64"]
    }
}
impl AsRef<str> for Architecture {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Information about a source configuration.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SourceConfig {
    /// <p>The Amazon S3 bucket name.</p>
    pub s3_bucket: std::option::Option<std::string::String>,
    /// <p>The s3 object key.</p>
    pub s3_key: std::option::Option<std::string::String>,
    /// <p>The target processor architecture for the application.</p>
    pub architecture: std::option::Option<crate::model::Architecture>,
}
impl SourceConfig {
    /// <p>The Amazon S3 bucket name.</p>
    pub fn s3_bucket(&self) -> std::option::Option<&str> {
        self.s3_bucket.as_deref()
    }
    /// <p>The s3 object key.</p>
    pub fn s3_key(&self) -> std::option::Option<&str> {
        self.s3_key.as_deref()
    }
    /// <p>The target processor architecture for the application.</p>
    pub fn architecture(&self) -> std::option::Option<&crate::model::Architecture> {
        self.architecture.as_ref()
    }
}
impl std::fmt::Debug for SourceConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SourceConfig");
        formatter.field("s3_bucket", &self.s3_bucket);
        formatter.field("s3_key", &self.s3_key);
        formatter.field("architecture", &self.architecture);
        formatter.finish()
    }
}
/// See [`SourceConfig`](crate::model::SourceConfig)
pub mod source_config {
    /// A builder for [`SourceConfig`](crate::model::SourceConfig)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) s3_bucket: std::option::Option<std::string::String>,
        pub(crate) s3_key: std::option::Option<std::string::String>,
        pub(crate) architecture: std::option::Option<crate::model::Architecture>,
    }
    impl Builder {
        /// <p>The Amazon S3 bucket name.</p>
        pub fn s3_bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.s3_bucket = Some(input.into());
            self
        }
        /// <p>The Amazon S3 bucket name.</p>
        pub fn set_s3_bucket(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.s3_bucket = input;
            self
        }
        /// <p>The s3 object key.</p>
        pub fn s3_key(mut self, input: impl Into<std::string::String>) -> Self {
            self.s3_key = Some(input.into());
            self
        }
        /// <p>The s3 object key.</p>
        pub fn set_s3_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.s3_key = input;
            self
        }
        /// <p>The target processor architecture for the application.</p>
        pub fn architecture(mut self, input: crate::model::Architecture) -> Self {
            self.architecture = Some(input);
            self
        }
        /// <p>The target processor architecture for the application.</p>
        pub fn set_architecture(
            mut self,
            input: std::option::Option<crate::model::Architecture>,
        ) -> Self {
            self.architecture = input;
            self
        }
        /// Consumes the builder and constructs a [`SourceConfig`](crate::model::SourceConfig)
        pub fn build(self) -> crate::model::SourceConfig {
            crate::model::SourceConfig {
                s3_bucket: self.s3_bucket,
                s3_key: self.s3_key,
                architecture: self.architecture,
            }
        }
    }
}
impl SourceConfig {
    /// Creates a new builder-style object to manufacture [`SourceConfig`](crate::model::SourceConfig)
    pub fn builder() -> crate::model::source_config::Builder {
        crate::model::source_config::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum DeploymentJobErrorCode {
    #[allow(missing_docs)] // documentation missing in model
    BadLambdaAssociated,
    #[allow(missing_docs)] // documentation missing in model
    BadPermissionError,
    #[allow(missing_docs)] // documentation missing in model
    DeploymentFleetDoesNotExist,
    #[allow(missing_docs)] // documentation missing in model
    DownloadConditionFailed,
    #[allow(missing_docs)] // documentation missing in model
    EnvironmentSetupError,
    #[allow(missing_docs)] // documentation missing in model
    EtagMismatch,
    #[allow(missing_docs)] // documentation missing in model
    ExtractingBundleFailure,
    #[allow(missing_docs)] // documentation missing in model
    FailureThresholdBreached,
    #[allow(missing_docs)] // documentation missing in model
    FleetDeploymentTimeout,
    #[allow(missing_docs)] // documentation missing in model
    GreengrassDeploymentFailed,
    #[allow(missing_docs)] // documentation missing in model
    GreengrassGroupVersionDoesNotExist,
    #[allow(missing_docs)] // documentation missing in model
    InternalServerError,
    #[allow(missing_docs)] // documentation missing in model
    InvalidGreengrassGroup,
    #[allow(missing_docs)] // documentation missing in model
    LambdaDeleted,
    #[allow(missing_docs)] // documentation missing in model
    MissingRobotApplicationArchitecture,
    #[allow(missing_docs)] // documentation missing in model
    MissingRobotArchitecture,
    #[allow(missing_docs)] // documentation missing in model
    MissingRobotDeploymentResource,
    #[allow(missing_docs)] // documentation missing in model
    PostLaunchFileFailure,
    #[allow(missing_docs)] // documentation missing in model
    PreLaunchFileFailure,
    #[allow(missing_docs)] // documentation missing in model
    ResourceNotFound,
    #[allow(missing_docs)] // documentation missing in model
    RobotAgentConnectionTimeout,
    #[allow(missing_docs)] // documentation missing in model
    RobotApplicationDoesNotExist,
    #[allow(missing_docs)] // documentation missing in model
    RobotDeploymentAborted,
    #[allow(missing_docs)] // documentation missing in model
    RobotDeploymentNoResponse,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for DeploymentJobErrorCode {
    fn from(s: &str) -> Self {
        match s {
            "BadLambdaAssociated" => DeploymentJobErrorCode::BadLambdaAssociated,
            "BadPermissionError" => DeploymentJobErrorCode::BadPermissionError,
            "DeploymentFleetDoesNotExist" => DeploymentJobErrorCode::DeploymentFleetDoesNotExist,
            "DownloadConditionFailed" => DeploymentJobErrorCode::DownloadConditionFailed,
            "EnvironmentSetupError" => DeploymentJobErrorCode::EnvironmentSetupError,
            "EtagMismatch" => DeploymentJobErrorCode::EtagMismatch,
            "ExtractingBundleFailure" => DeploymentJobErrorCode::ExtractingBundleFailure,
            "FailureThresholdBreached" => DeploymentJobErrorCode::FailureThresholdBreached,
            "FleetDeploymentTimeout" => DeploymentJobErrorCode::FleetDeploymentTimeout,
            "GreengrassDeploymentFailed" => DeploymentJobErrorCode::GreengrassDeploymentFailed,
            "GreengrassGroupVersionDoesNotExist" => {
                DeploymentJobErrorCode::GreengrassGroupVersionDoesNotExist
            }
            "InternalServerError" => DeploymentJobErrorCode::InternalServerError,
            "InvalidGreengrassGroup" => DeploymentJobErrorCode::InvalidGreengrassGroup,
            "LambdaDeleted" => DeploymentJobErrorCode::LambdaDeleted,
            "MissingRobotApplicationArchitecture" => {
                DeploymentJobErrorCode::MissingRobotApplicationArchitecture
            }
            "MissingRobotArchitecture" => DeploymentJobErrorCode::MissingRobotArchitecture,
            "MissingRobotDeploymentResource" => {
                DeploymentJobErrorCode::MissingRobotDeploymentResource
            }
            "PostLaunchFileFailure" => DeploymentJobErrorCode::PostLaunchFileFailure,
            "PreLaunchFileFailure" => DeploymentJobErrorCode::PreLaunchFileFailure,
            "ResourceNotFound" => DeploymentJobErrorCode::ResourceNotFound,
            "RobotAgentConnectionTimeout" => DeploymentJobErrorCode::RobotAgentConnectionTimeout,
            "RobotApplicationDoesNotExist" => DeploymentJobErrorCode::RobotApplicationDoesNotExist,
            "RobotDeploymentAborted" => DeploymentJobErrorCode::RobotDeploymentAborted,
            "RobotDeploymentNoResponse" => DeploymentJobErrorCode::RobotDeploymentNoResponse,
            other => DeploymentJobErrorCode::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for DeploymentJobErrorCode {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(DeploymentJobErrorCode::from(s))
    }
}
impl DeploymentJobErrorCode {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            DeploymentJobErrorCode::BadLambdaAssociated => "BadLambdaAssociated",
            DeploymentJobErrorCode::BadPermissionError => "BadPermissionError",
            DeploymentJobErrorCode::DeploymentFleetDoesNotExist => "DeploymentFleetDoesNotExist",
            DeploymentJobErrorCode::DownloadConditionFailed => "DownloadConditionFailed",
            DeploymentJobErrorCode::EnvironmentSetupError => "EnvironmentSetupError",
            DeploymentJobErrorCode::EtagMismatch => "EtagMismatch",
            DeploymentJobErrorCode::ExtractingBundleFailure => "ExtractingBundleFailure",
            DeploymentJobErrorCode::FailureThresholdBreached => "FailureThresholdBreached",
            DeploymentJobErrorCode::FleetDeploymentTimeout => "FleetDeploymentTimeout",
            DeploymentJobErrorCode::GreengrassDeploymentFailed => "GreengrassDeploymentFailed",
            DeploymentJobErrorCode::GreengrassGroupVersionDoesNotExist => {
                "GreengrassGroupVersionDoesNotExist"
            }
            DeploymentJobErrorCode::InternalServerError => "InternalServerError",
            DeploymentJobErrorCode::InvalidGreengrassGroup => "InvalidGreengrassGroup",
            DeploymentJobErrorCode::LambdaDeleted => "LambdaDeleted",
            DeploymentJobErrorCode::MissingRobotApplicationArchitecture => {
                "MissingRobotApplicationArchitecture"
            }
            DeploymentJobErrorCode::MissingRobotArchitecture => "MissingRobotArchitecture",
            DeploymentJobErrorCode::MissingRobotDeploymentResource => {
                "MissingRobotDeploymentResource"
            }
            DeploymentJobErrorCode::PostLaunchFileFailure => "PostLaunchFileFailure",
            DeploymentJobErrorCode::PreLaunchFileFailure => "PreLaunchFileFailure",
            DeploymentJobErrorCode::ResourceNotFound => "ResourceNotFound",
            DeploymentJobErrorCode::RobotAgentConnectionTimeout => "RobotAgentConnectionTimeout",
            DeploymentJobErrorCode::RobotApplicationDoesNotExist => "RobotApplicationDoesNotExist",
            DeploymentJobErrorCode::RobotDeploymentAborted => "RobotDeploymentAborted",
            DeploymentJobErrorCode::RobotDeploymentNoResponse => "RobotDeploymentNoResponse",
            DeploymentJobErrorCode::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &[
            "BadLambdaAssociated",
            "BadPermissionError",
            "DeploymentFleetDoesNotExist",
            "DownloadConditionFailed",
            "EnvironmentSetupError",
            "EtagMismatch",
            "ExtractingBundleFailure",
            "FailureThresholdBreached",
            "FleetDeploymentTimeout",
            "GreengrassDeploymentFailed",
            "GreengrassGroupVersionDoesNotExist",
            "InternalServerError",
            "InvalidGreengrassGroup",
            "LambdaDeleted",
            "MissingRobotApplicationArchitecture",
            "MissingRobotArchitecture",
            "MissingRobotDeploymentResource",
            "PostLaunchFileFailure",
            "PreLaunchFileFailure",
            "ResourceNotFound",
            "RobotAgentConnectionTimeout",
            "RobotApplicationDoesNotExist",
            "RobotDeploymentAborted",
            "RobotDeploymentNoResponse",
        ]
    }
}
impl AsRef<str> for DeploymentJobErrorCode {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Information about a deployment application configuration.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeploymentApplicationConfig {
    /// <p>The Amazon Resource Name (ARN) of the robot application.</p>
    pub application: std::option::Option<std::string::String>,
    /// <p>The version of the application.</p>
    pub application_version: std::option::Option<std::string::String>,
    /// <p>The launch configuration.</p>
    pub launch_config: std::option::Option<crate::model::DeploymentLaunchConfig>,
}
impl DeploymentApplicationConfig {
    /// <p>The Amazon Resource Name (ARN) of the robot application.</p>
    pub fn application(&self) -> std::option::Option<&str> {
        self.application.as_deref()
    }
    /// <p>The version of the application.</p>
    pub fn application_version(&self) -> std::option::Option<&str> {
        self.application_version.as_deref()
    }
    /// <p>The launch configuration.</p>
    pub fn launch_config(&self) -> std::option::Option<&crate::model::DeploymentLaunchConfig> {
        self.launch_config.as_ref()
    }
}
impl std::fmt::Debug for DeploymentApplicationConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeploymentApplicationConfig");
        formatter.field("application", &self.application);
        formatter.field("application_version", &self.application_version);
        formatter.field("launch_config", &self.launch_config);
        formatter.finish()
    }
}
/// See [`DeploymentApplicationConfig`](crate::model::DeploymentApplicationConfig)
pub mod deployment_application_config {
    /// A builder for [`DeploymentApplicationConfig`](crate::model::DeploymentApplicationConfig)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) application: std::option::Option<std::string::String>,
        pub(crate) application_version: std::option::Option<std::string::String>,
        pub(crate) launch_config: std::option::Option<crate::model::DeploymentLaunchConfig>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the robot application.</p>
        pub fn application(mut self, input: impl Into<std::string::String>) -> Self {
            self.application = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the robot application.</p>
        pub fn set_application(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.application = input;
            self
        }
        /// <p>The version of the application.</p>
        pub fn application_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.application_version = Some(input.into());
            self
        }
        /// <p>The version of the application.</p>
        pub fn set_application_version(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.application_version = input;
            self
        }
        /// <p>The launch configuration.</p>
        pub fn launch_config(mut self, input: crate::model::DeploymentLaunchConfig) -> Self {
            self.launch_config = Some(input);
            self
        }
        /// <p>The launch configuration.</p>
        pub fn set_launch_config(
            mut self,
            input: std::option::Option<crate::model::DeploymentLaunchConfig>,
        ) -> Self {
            self.launch_config = input;
            self
        }
        /// Consumes the builder and constructs a [`DeploymentApplicationConfig`](crate::model::DeploymentApplicationConfig)
        pub fn build(self) -> crate::model::DeploymentApplicationConfig {
            crate::model::DeploymentApplicationConfig {
                application: self.application,
                application_version: self.application_version,
                launch_config: self.launch_config,
            }
        }
    }
}
impl DeploymentApplicationConfig {
    /// Creates a new builder-style object to manufacture [`DeploymentApplicationConfig`](crate::model::DeploymentApplicationConfig)
    pub fn builder() -> crate::model::deployment_application_config::Builder {
        crate::model::deployment_application_config::Builder::default()
    }
}

/// <p>Configuration information for a deployment launch.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeploymentLaunchConfig {
    /// <p>The package name.</p>
    pub package_name: std::option::Option<std::string::String>,
    /// <p>The deployment pre-launch file. This file will be executed prior to the launch
    /// file.</p>
    pub pre_launch_file: std::option::Option<std::string::String>,
    /// <p>The launch file name.</p>
    pub launch_file: std::option::Option<std::string::String>,
    /// <p>The deployment post-launch file. This file will be executed after the launch
    /// file.</p>
    pub post_launch_file: std::option::Option<std::string::String>,
    /// <p>An array of key/value pairs specifying environment variables for the robot
    /// application</p>
    pub environment_variables:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
}
impl DeploymentLaunchConfig {
    /// <p>The package name.</p>
    pub fn package_name(&self) -> std::option::Option<&str> {
        self.package_name.as_deref()
    }
    /// <p>The deployment pre-launch file. This file will be executed prior to the launch
    /// file.</p>
    pub fn pre_launch_file(&self) -> std::option::Option<&str> {
        self.pre_launch_file.as_deref()
    }
    /// <p>The launch file name.</p>
    pub fn launch_file(&self) -> std::option::Option<&str> {
        self.launch_file.as_deref()
    }
    /// <p>The deployment post-launch file. This file will be executed after the launch
    /// file.</p>
    pub fn post_launch_file(&self) -> std::option::Option<&str> {
        self.post_launch_file.as_deref()
    }
    /// <p>An array of key/value pairs specifying environment variables for the robot
    /// application</p>
    pub fn environment_variables(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.environment_variables.as_ref()
    }
}
impl std::fmt::Debug for DeploymentLaunchConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeploymentLaunchConfig");
        formatter.field("package_name", &self.package_name);
        formatter.field("pre_launch_file", &self.pre_launch_file);
        formatter.field("launch_file", &self.launch_file);
        formatter.field("post_launch_file", &self.post_launch_file);
        formatter.field("environment_variables", &self.environment_variables);
        formatter.finish()
    }
}
/// See [`DeploymentLaunchConfig`](crate::model::DeploymentLaunchConfig)
pub mod deployment_launch_config {
    /// A builder for [`DeploymentLaunchConfig`](crate::model::DeploymentLaunchConfig)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) package_name: std::option::Option<std::string::String>,
        pub(crate) pre_launch_file: std::option::Option<std::string::String>,
        pub(crate) launch_file: std::option::Option<std::string::String>,
        pub(crate) post_launch_file: std::option::Option<std::string::String>,
        pub(crate) environment_variables: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
    }
    impl Builder {
        /// <p>The package name.</p>
        pub fn package_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.package_name = Some(input.into());
            self
        }
        /// <p>The package name.</p>
        pub fn set_package_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.package_name = input;
            self
        }
        /// <p>The deployment pre-launch file. This file will be executed prior to the launch
        /// file.</p>
        pub fn pre_launch_file(mut self, input: impl Into<std::string::String>) -> Self {
            self.pre_launch_file = Some(input.into());
            self
        }
        /// <p>The deployment pre-launch file. This file will be executed prior to the launch
        /// file.</p>
        pub fn set_pre_launch_file(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.pre_launch_file = input;
            self
        }
        /// <p>The launch file name.</p>
        pub fn launch_file(mut self, input: impl Into<std::string::String>) -> Self {
            self.launch_file = Some(input.into());
            self
        }
        /// <p>The launch file name.</p>
        pub fn set_launch_file(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.launch_file = input;
            self
        }
        /// <p>The deployment post-launch file. This file will be executed after the launch
        /// file.</p>
        pub fn post_launch_file(mut self, input: impl Into<std::string::String>) -> Self {
            self.post_launch_file = Some(input.into());
            self
        }
        /// <p>The deployment post-launch file. This file will be executed after the launch
        /// file.</p>
        pub fn set_post_launch_file(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.post_launch_file = input;
            self
        }
        /// Adds a key-value pair to `environment_variables`.
        ///
        /// To override the contents of this collection use [`set_environment_variables`](Self::set_environment_variables).
        ///
        /// <p>An array of key/value pairs specifying environment variables for the robot
        /// application</p>
        pub fn environment_variables(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.environment_variables.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.environment_variables = Some(hash_map);
            self
        }
        /// <p>An array of key/value pairs specifying environment variables for the robot
        /// application</p>
        pub fn set_environment_variables(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.environment_variables = input;
            self
        }
        /// Consumes the builder and constructs a [`DeploymentLaunchConfig`](crate::model::DeploymentLaunchConfig)
        pub fn build(self) -> crate::model::DeploymentLaunchConfig {
            crate::model::DeploymentLaunchConfig {
                package_name: self.package_name,
                pre_launch_file: self.pre_launch_file,
                launch_file: self.launch_file,
                post_launch_file: self.post_launch_file,
                environment_variables: self.environment_variables,
            }
        }
    }
}
impl DeploymentLaunchConfig {
    /// Creates a new builder-style object to manufacture [`DeploymentLaunchConfig`](crate::model::DeploymentLaunchConfig)
    pub fn builder() -> crate::model::deployment_launch_config::Builder {
        crate::model::deployment_launch_config::Builder::default()
    }
}

/// <p>Information about a deployment configuration.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeploymentConfig {
    /// <p>The percentage of robots receiving the deployment at the same time.</p>
    pub concurrent_deployment_percentage: std::option::Option<i32>,
    /// <p>The percentage of deployments that need to fail before stopping deployment.</p>
    pub failure_threshold_percentage: std::option::Option<i32>,
    /// <p>The amount of time, in seconds, to wait for deployment to a single robot to complete.
    /// Choose a time between 1 minute and 7 days. The default is 5 hours.</p>
    pub robot_deployment_timeout_in_seconds: std::option::Option<i64>,
    /// <p>The download condition file.</p>
    pub download_condition_file: std::option::Option<crate::model::S3Object>,
}
impl DeploymentConfig {
    /// <p>The percentage of robots receiving the deployment at the same time.</p>
    pub fn concurrent_deployment_percentage(&self) -> std::option::Option<i32> {
        self.concurrent_deployment_percentage
    }
    /// <p>The percentage of deployments that need to fail before stopping deployment.</p>
    pub fn failure_threshold_percentage(&self) -> std::option::Option<i32> {
        self.failure_threshold_percentage
    }
    /// <p>The amount of time, in seconds, to wait for deployment to a single robot to complete.
    /// Choose a time between 1 minute and 7 days. The default is 5 hours.</p>
    pub fn robot_deployment_timeout_in_seconds(&self) -> std::option::Option<i64> {
        self.robot_deployment_timeout_in_seconds
    }
    /// <p>The download condition file.</p>
    pub fn download_condition_file(&self) -> std::option::Option<&crate::model::S3Object> {
        self.download_condition_file.as_ref()
    }
}
impl std::fmt::Debug for DeploymentConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeploymentConfig");
        formatter.field(
            "concurrent_deployment_percentage",
            &self.concurrent_deployment_percentage,
        );
        formatter.field(
            "failure_threshold_percentage",
            &self.failure_threshold_percentage,
        );
        formatter.field(
            "robot_deployment_timeout_in_seconds",
            &self.robot_deployment_timeout_in_seconds,
        );
        formatter.field("download_condition_file", &self.download_condition_file);
        formatter.finish()
    }
}
/// See [`DeploymentConfig`](crate::model::DeploymentConfig)
pub mod deployment_config {
    /// A builder for [`DeploymentConfig`](crate::model::DeploymentConfig)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) concurrent_deployment_percentage: std::option::Option<i32>,
        pub(crate) failure_threshold_percentage: std::option::Option<i32>,
        pub(crate) robot_deployment_timeout_in_seconds: std::option::Option<i64>,
        pub(crate) download_condition_file: std::option::Option<crate::model::S3Object>,
    }
    impl Builder {
        /// <p>The percentage of robots receiving the deployment at the same time.</p>
        pub fn concurrent_deployment_percentage(mut self, input: i32) -> Self {
            self.concurrent_deployment_percentage = Some(input);
            self
        }
        /// <p>The percentage of robots receiving the deployment at the same time.</p>
        pub fn set_concurrent_deployment_percentage(
            mut self,
            input: std::option::Option<i32>,
        ) -> Self {
            self.concurrent_deployment_percentage = input;
            self
        }
        /// <p>The percentage of deployments that need to fail before stopping deployment.</p>
        pub fn failure_threshold_percentage(mut self, input: i32) -> Self {
            self.failure_threshold_percentage = Some(input);
            self
        }
        /// <p>The percentage of deployments that need to fail before stopping deployment.</p>
        pub fn set_failure_threshold_percentage(mut self, input: std::option::Option<i32>) -> Self {
            self.failure_threshold_percentage = input;
            self
        }
        /// <p>The amount of time, in seconds, to wait for deployment to a single robot to complete.
        /// Choose a time between 1 minute and 7 days. The default is 5 hours.</p>
        pub fn robot_deployment_timeout_in_seconds(mut self, input: i64) -> Self {
            self.robot_deployment_timeout_in_seconds = Some(input);
            self
        }
        /// <p>The amount of time, in seconds, to wait for deployment to a single robot to complete.
        /// Choose a time between 1 minute and 7 days. The default is 5 hours.</p>
        pub fn set_robot_deployment_timeout_in_seconds(
            mut self,
            input: std::option::Option<i64>,
        ) -> Self {
            self.robot_deployment_timeout_in_seconds = input;
            self
        }
        /// <p>The download condition file.</p>
        pub fn download_condition_file(mut self, input: crate::model::S3Object) -> Self {
            self.download_condition_file = Some(input);
            self
        }
        /// <p>The download condition file.</p>
        pub fn set_download_condition_file(
            mut self,
            input: std::option::Option<crate::model::S3Object>,
        ) -> Self {
            self.download_condition_file = input;
            self
        }
        /// Consumes the builder and constructs a [`DeploymentConfig`](crate::model::DeploymentConfig)
        pub fn build(self) -> crate::model::DeploymentConfig {
            crate::model::DeploymentConfig {
                concurrent_deployment_percentage: self.concurrent_deployment_percentage,
                failure_threshold_percentage: self.failure_threshold_percentage,
                robot_deployment_timeout_in_seconds: self.robot_deployment_timeout_in_seconds,
                download_condition_file: self.download_condition_file,
            }
        }
    }
}
impl DeploymentConfig {
    /// Creates a new builder-style object to manufacture [`DeploymentConfig`](crate::model::DeploymentConfig)
    pub fn builder() -> crate::model::deployment_config::Builder {
        crate::model::deployment_config::Builder::default()
    }
}

/// <p>Information about an S3 object.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct S3Object {
    /// <p>The bucket containing the object.</p>
    pub bucket: std::option::Option<std::string::String>,
    /// <p>The key of the object.</p>
    pub key: std::option::Option<std::string::String>,
    /// <p>The etag of the object.</p>
    pub etag: std::option::Option<std::string::String>,
}
impl S3Object {
    /// <p>The bucket containing the object.</p>
    pub fn bucket(&self) -> std::option::Option<&str> {
        self.bucket.as_deref()
    }
    /// <p>The key of the object.</p>
    pub fn key(&self) -> std::option::Option<&str> {
        self.key.as_deref()
    }
    /// <p>The etag of the object.</p>
    pub fn etag(&self) -> std::option::Option<&str> {
        self.etag.as_deref()
    }
}
impl std::fmt::Debug for S3Object {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("S3Object");
        formatter.field("bucket", &self.bucket);
        formatter.field("key", &self.key);
        formatter.field("etag", &self.etag);
        formatter.finish()
    }
}
/// See [`S3Object`](crate::model::S3Object)
pub mod s3_object {
    /// A builder for [`S3Object`](crate::model::S3Object)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) bucket: std::option::Option<std::string::String>,
        pub(crate) key: std::option::Option<std::string::String>,
        pub(crate) etag: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The bucket containing the object.</p>
        pub fn bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.bucket = Some(input.into());
            self
        }
        /// <p>The bucket containing the object.</p>
        pub fn set_bucket(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.bucket = input;
            self
        }
        /// <p>The key of the object.</p>
        pub fn key(mut self, input: impl Into<std::string::String>) -> Self {
            self.key = Some(input.into());
            self
        }
        /// <p>The key of the object.</p>
        pub fn set_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.key = input;
            self
        }
        /// <p>The etag of the object.</p>
        pub fn etag(mut self, input: impl Into<std::string::String>) -> Self {
            self.etag = Some(input.into());
            self
        }
        /// <p>The etag of the object.</p>
        pub fn set_etag(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.etag = input;
            self
        }
        /// Consumes the builder and constructs a [`S3Object`](crate::model::S3Object)
        pub fn build(self) -> crate::model::S3Object {
            crate::model::S3Object {
                bucket: self.bucket,
                key: self.key,
                etag: self.etag,
            }
        }
    }
}
impl S3Object {
    /// Creates a new builder-style object to manufacture [`S3Object`](crate::model::S3Object)
    pub fn builder() -> crate::model::s3_object::Builder {
        crate::model::s3_object::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum DeploymentStatus {
    #[allow(missing_docs)] // documentation missing in model
    Canceled,
    #[allow(missing_docs)] // documentation missing in model
    Failed,
    #[allow(missing_docs)] // documentation missing in model
    InProgress,
    #[allow(missing_docs)] // documentation missing in model
    Pending,
    #[allow(missing_docs)] // documentation missing in model
    Preparing,
    #[allow(missing_docs)] // documentation missing in model
    Succeeded,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for DeploymentStatus {
    fn from(s: &str) -> Self {
        match s {
            "Canceled" => DeploymentStatus::Canceled,
            "Failed" => DeploymentStatus::Failed,
            "InProgress" => DeploymentStatus::InProgress,
            "Pending" => DeploymentStatus::Pending,
            "Preparing" => DeploymentStatus::Preparing,
            "Succeeded" => DeploymentStatus::Succeeded,
            other => DeploymentStatus::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for DeploymentStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(DeploymentStatus::from(s))
    }
}
impl DeploymentStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            DeploymentStatus::Canceled => "Canceled",
            DeploymentStatus::Failed => "Failed",
            DeploymentStatus::InProgress => "InProgress",
            DeploymentStatus::Pending => "Pending",
            DeploymentStatus::Preparing => "Preparing",
            DeploymentStatus::Succeeded => "Succeeded",
            DeploymentStatus::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &[
            "Canceled",
            "Failed",
            "InProgress",
            "Pending",
            "Preparing",
            "Succeeded",
        ]
    }
}
impl AsRef<str> for DeploymentStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Summary information for a simulation job.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SimulationJobSummary {
    /// <p>The Amazon Resource Name (ARN) of the simulation job.</p>
    pub arn: std::option::Option<std::string::String>,
    /// <p>The time, in milliseconds since the epoch, when the simulation job was last
    /// updated.</p>
    pub last_updated_at: std::option::Option<aws_smithy_types::Instant>,
    /// <p>The name of the simulation job.</p>
    pub name: std::option::Option<std::string::String>,
    /// <p>The status of the simulation job.</p>
    pub status: std::option::Option<crate::model::SimulationJobStatus>,
    /// <p>A list of simulation job simulation application names.</p>
    pub simulation_application_names: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>A list of simulation job robot application names.</p>
    pub robot_application_names: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The names of the data sources.</p>
    pub data_source_names: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The compute type for the simulation job summary.</p>
    pub compute_type: std::option::Option<crate::model::ComputeType>,
}
impl SimulationJobSummary {
    /// <p>The Amazon Resource Name (ARN) of the simulation job.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>The time, in milliseconds since the epoch, when the simulation job was last
    /// updated.</p>
    pub fn last_updated_at(&self) -> std::option::Option<&aws_smithy_types::Instant> {
        self.last_updated_at.as_ref()
    }
    /// <p>The name of the simulation job.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The status of the simulation job.</p>
    pub fn status(&self) -> std::option::Option<&crate::model::SimulationJobStatus> {
        self.status.as_ref()
    }
    /// <p>A list of simulation job simulation application names.</p>
    pub fn simulation_application_names(&self) -> std::option::Option<&[std::string::String]> {
        self.simulation_application_names.as_deref()
    }
    /// <p>A list of simulation job robot application names.</p>
    pub fn robot_application_names(&self) -> std::option::Option<&[std::string::String]> {
        self.robot_application_names.as_deref()
    }
    /// <p>The names of the data sources.</p>
    pub fn data_source_names(&self) -> std::option::Option<&[std::string::String]> {
        self.data_source_names.as_deref()
    }
    /// <p>The compute type for the simulation job summary.</p>
    pub fn compute_type(&self) -> std::option::Option<&crate::model::ComputeType> {
        self.compute_type.as_ref()
    }
}
impl std::fmt::Debug for SimulationJobSummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SimulationJobSummary");
        formatter.field("arn", &self.arn);
        formatter.field("last_updated_at", &self.last_updated_at);
        formatter.field("name", &self.name);
        formatter.field("status", &self.status);
        formatter.field(
            "simulation_application_names",
            &self.simulation_application_names,
        );
        formatter.field("robot_application_names", &self.robot_application_names);
        formatter.field("data_source_names", &self.data_source_names);
        formatter.field("compute_type", &self.compute_type);
        formatter.finish()
    }
}
/// See [`SimulationJobSummary`](crate::model::SimulationJobSummary)
pub mod simulation_job_summary {
    /// A builder for [`SimulationJobSummary`](crate::model::SimulationJobSummary)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) last_updated_at: std::option::Option<aws_smithy_types::Instant>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) status: std::option::Option<crate::model::SimulationJobStatus>,
        pub(crate) simulation_application_names:
            std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) robot_application_names: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) data_source_names: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) compute_type: std::option::Option<crate::model::ComputeType>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the simulation job.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the simulation job.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>The time, in milliseconds since the epoch, when the simulation job was last
        /// updated.</p>
        pub fn last_updated_at(mut self, input: aws_smithy_types::Instant) -> Self {
            self.last_updated_at = Some(input);
            self
        }
        /// <p>The time, in milliseconds since the epoch, when the simulation job was last
        /// updated.</p>
        pub fn set_last_updated_at(
            mut self,
            input: std::option::Option<aws_smithy_types::Instant>,
        ) -> Self {
            self.last_updated_at = input;
            self
        }
        /// <p>The name of the simulation job.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the simulation job.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The status of the simulation job.</p>
        pub fn status(mut self, input: crate::model::SimulationJobStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The status of the simulation job.</p>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::SimulationJobStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// Appends an item to `simulation_application_names`.
        ///
        /// To override the contents of this collection use [`set_simulation_application_names`](Self::set_simulation_application_names).
        ///
        /// <p>A list of simulation job simulation application names.</p>
        pub fn simulation_application_names(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            let mut v = self.simulation_application_names.unwrap_or_default();
            v.push(input.into());
            self.simulation_application_names = Some(v);
            self
        }
        /// <p>A list of simulation job simulation application names.</p>
        pub fn set_simulation_application_names(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.simulation_application_names = input;
            self
        }
        /// Appends an item to `robot_application_names`.
        ///
        /// To override the contents of this collection use [`set_robot_application_names`](Self::set_robot_application_names).
        ///
        /// <p>A list of simulation job robot application names.</p>
        pub fn robot_application_names(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.robot_application_names.unwrap_or_default();
            v.push(input.into());
            self.robot_application_names = Some(v);
            self
        }
        /// <p>A list of simulation job robot application names.</p>
        pub fn set_robot_application_names(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.robot_application_names = input;
            self
        }
        /// Appends an item to `data_source_names`.
        ///
        /// To override the contents of this collection use [`set_data_source_names`](Self::set_data_source_names).
        ///
        /// <p>The names of the data sources.</p>
        pub fn data_source_names(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.data_source_names.unwrap_or_default();
            v.push(input.into());
            self.data_source_names = Some(v);
            self
        }
        /// <p>The names of the data sources.</p>
        pub fn set_data_source_names(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.data_source_names = input;
            self
        }
        /// <p>The compute type for the simulation job summary.</p>
        pub fn compute_type(mut self, input: crate::model::ComputeType) -> Self {
            self.compute_type = Some(input);
            self
        }
        /// <p>The compute type for the simulation job summary.</p>
        pub fn set_compute_type(
            mut self,
            input: std::option::Option<crate::model::ComputeType>,
        ) -> Self {
            self.compute_type = input;
            self
        }
        /// Consumes the builder and constructs a [`SimulationJobSummary`](crate::model::SimulationJobSummary)
        pub fn build(self) -> crate::model::SimulationJobSummary {
            crate::model::SimulationJobSummary {
                arn: self.arn,
                last_updated_at: self.last_updated_at,
                name: self.name,
                status: self.status,
                simulation_application_names: self.simulation_application_names,
                robot_application_names: self.robot_application_names,
                data_source_names: self.data_source_names,
                compute_type: self.compute_type,
            }
        }
    }
}
impl SimulationJobSummary {
    /// Creates a new builder-style object to manufacture [`SimulationJobSummary`](crate::model::SimulationJobSummary)
    pub fn builder() -> crate::model::simulation_job_summary::Builder {
        crate::model::simulation_job_summary::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ComputeType {
    #[allow(missing_docs)] // documentation missing in model
    Cpu,
    #[allow(missing_docs)] // documentation missing in model
    GpuAndCpu,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for ComputeType {
    fn from(s: &str) -> Self {
        match s {
            "CPU" => ComputeType::Cpu,
            "GPU_AND_CPU" => ComputeType::GpuAndCpu,
            other => ComputeType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for ComputeType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ComputeType::from(s))
    }
}
impl ComputeType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ComputeType::Cpu => "CPU",
            ComputeType::GpuAndCpu => "GPU_AND_CPU",
            ComputeType::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["CPU", "GPU_AND_CPU"]
    }
}
impl AsRef<str> for ComputeType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum SimulationJobStatus {
    #[allow(missing_docs)] // documentation missing in model
    Canceled,
    #[allow(missing_docs)] // documentation missing in model
    Completed,
    #[allow(missing_docs)] // documentation missing in model
    Failed,
    #[allow(missing_docs)] // documentation missing in model
    Pending,
    #[allow(missing_docs)] // documentation missing in model
    Preparing,
    #[allow(missing_docs)] // documentation missing in model
    Restarting,
    #[allow(missing_docs)] // documentation missing in model
    Running,
    #[allow(missing_docs)] // documentation missing in model
    RunningFailed,
    #[allow(missing_docs)] // documentation missing in model
    Terminated,
    #[allow(missing_docs)] // documentation missing in model
    Terminating,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for SimulationJobStatus {
    fn from(s: &str) -> Self {
        match s {
            "Canceled" => SimulationJobStatus::Canceled,
            "Completed" => SimulationJobStatus::Completed,
            "Failed" => SimulationJobStatus::Failed,
            "Pending" => SimulationJobStatus::Pending,
            "Preparing" => SimulationJobStatus::Preparing,
            "Restarting" => SimulationJobStatus::Restarting,
            "Running" => SimulationJobStatus::Running,
            "RunningFailed" => SimulationJobStatus::RunningFailed,
            "Terminated" => SimulationJobStatus::Terminated,
            "Terminating" => SimulationJobStatus::Terminating,
            other => SimulationJobStatus::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for SimulationJobStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(SimulationJobStatus::from(s))
    }
}
impl SimulationJobStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            SimulationJobStatus::Canceled => "Canceled",
            SimulationJobStatus::Completed => "Completed",
            SimulationJobStatus::Failed => "Failed",
            SimulationJobStatus::Pending => "Pending",
            SimulationJobStatus::Preparing => "Preparing",
            SimulationJobStatus::Restarting => "Restarting",
            SimulationJobStatus::Running => "Running",
            SimulationJobStatus::RunningFailed => "RunningFailed",
            SimulationJobStatus::Terminated => "Terminated",
            SimulationJobStatus::Terminating => "Terminating",
            SimulationJobStatus::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &[
            "Canceled",
            "Completed",
            "Failed",
            "Pending",
            "Preparing",
            "Restarting",
            "Running",
            "RunningFailed",
            "Terminated",
            "Terminating",
        ]
    }
}
impl AsRef<str> for SimulationJobStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Information about a simulation job request.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SimulationJobRequest {
    /// <p>The output location.</p>
    pub output_location: std::option::Option<crate::model::OutputLocation>,
    /// <p>The logging configuration.</p>
    pub logging_config: std::option::Option<crate::model::LoggingConfig>,
    /// <p>The maximum simulation job duration in seconds. The value must be 8 days (691,200
    /// seconds) or less.</p>
    pub max_job_duration_in_seconds: i64,
    /// <p>The IAM role name that allows the simulation instance to call the AWS APIs that are
    /// specified in its associated policies on your behalf. This is how credentials are passed in
    /// to your simulation job. </p>
    pub iam_role: std::option::Option<std::string::String>,
    /// <p>The failure behavior the simulation job.</p>
    /// <dl>
    /// <dt>Continue</dt>
    /// <dd>
    /// <p>Leaves the host running for its maximum timeout duration after a
    /// <code>4XX</code> error code.</p>
    /// </dd>
    /// <dt>Fail</dt>
    /// <dd>
    /// <p>Stop the simulation job and terminate the instance.</p>
    /// </dd>
    /// </dl>
    pub failure_behavior: std::option::Option<crate::model::FailureBehavior>,
    /// <p>A Boolean indicating whether to use default applications in the simulation job. Default
    /// applications include Gazebo, rqt, rviz and terminal access. </p>
    pub use_default_applications: std::option::Option<bool>,
    /// <p>The robot applications to use in the simulation job.</p>
    pub robot_applications:
        std::option::Option<std::vec::Vec<crate::model::RobotApplicationConfig>>,
    /// <p>The simulation applications to use in the simulation job.</p>
    pub simulation_applications:
        std::option::Option<std::vec::Vec<crate::model::SimulationApplicationConfig>>,
    /// <p>Specify data sources to mount read-only files from S3 into your simulation. These files
    /// are available under <code>/opt/robomaker/datasources/data_source_name</code>. </p>
    /// <note>
    /// <p>There is a limit of 100 files and a combined size of 25GB for all
    /// <code>DataSourceConfig</code> objects. </p>
    /// </note>
    pub data_sources: std::option::Option<std::vec::Vec<crate::model::DataSourceConfig>>,
    /// <p>If your simulation job accesses resources in a VPC, you provide this parameter
    /// identifying the list of security group IDs and subnet IDs. These must belong to the same
    /// VPC. You must provide at least one security group and two subnet IDs.</p>
    pub vpc_config: std::option::Option<crate::model::VpcConfig>,
    /// <p>Compute information for the simulation job</p>
    pub compute: std::option::Option<crate::model::Compute>,
    /// <p>A map that contains tag keys and tag values that are attached to the simulation job
    /// request.</p>
    pub tags:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
}
impl SimulationJobRequest {
    /// <p>The output location.</p>
    pub fn output_location(&self) -> std::option::Option<&crate::model::OutputLocation> {
        self.output_location.as_ref()
    }
    /// <p>The logging configuration.</p>
    pub fn logging_config(&self) -> std::option::Option<&crate::model::LoggingConfig> {
        self.logging_config.as_ref()
    }
    /// <p>The maximum simulation job duration in seconds. The value must be 8 days (691,200
    /// seconds) or less.</p>
    pub fn max_job_duration_in_seconds(&self) -> i64 {
        self.max_job_duration_in_seconds
    }
    /// <p>The IAM role name that allows the simulation instance to call the AWS APIs that are
    /// specified in its associated policies on your behalf. This is how credentials are passed in
    /// to your simulation job. </p>
    pub fn iam_role(&self) -> std::option::Option<&str> {
        self.iam_role.as_deref()
    }
    /// <p>The failure behavior the simulation job.</p>
    /// <dl>
    /// <dt>Continue</dt>
    /// <dd>
    /// <p>Leaves the host running for its maximum timeout duration after a
    /// <code>4XX</code> error code.</p>
    /// </dd>
    /// <dt>Fail</dt>
    /// <dd>
    /// <p>Stop the simulation job and terminate the instance.</p>
    /// </dd>
    /// </dl>
    pub fn failure_behavior(&self) -> std::option::Option<&crate::model::FailureBehavior> {
        self.failure_behavior.as_ref()
    }
    /// <p>A Boolean indicating whether to use default applications in the simulation job. Default
    /// applications include Gazebo, rqt, rviz and terminal access. </p>
    pub fn use_default_applications(&self) -> std::option::Option<bool> {
        self.use_default_applications
    }
    /// <p>The robot applications to use in the simulation job.</p>
    pub fn robot_applications(
        &self,
    ) -> std::option::Option<&[crate::model::RobotApplicationConfig]> {
        self.robot_applications.as_deref()
    }
    /// <p>The simulation applications to use in the simulation job.</p>
    pub fn simulation_applications(
        &self,
    ) -> std::option::Option<&[crate::model::SimulationApplicationConfig]> {
        self.simulation_applications.as_deref()
    }
    /// <p>Specify data sources to mount read-only files from S3 into your simulation. These files
    /// are available under <code>/opt/robomaker/datasources/data_source_name</code>. </p>
    /// <note>
    /// <p>There is a limit of 100 files and a combined size of 25GB for all
    /// <code>DataSourceConfig</code> objects. </p>
    /// </note>
    pub fn data_sources(&self) -> std::option::Option<&[crate::model::DataSourceConfig]> {
        self.data_sources.as_deref()
    }
    /// <p>If your simulation job accesses resources in a VPC, you provide this parameter
    /// identifying the list of security group IDs and subnet IDs. These must belong to the same
    /// VPC. You must provide at least one security group and two subnet IDs.</p>
    pub fn vpc_config(&self) -> std::option::Option<&crate::model::VpcConfig> {
        self.vpc_config.as_ref()
    }
    /// <p>Compute information for the simulation job</p>
    pub fn compute(&self) -> std::option::Option<&crate::model::Compute> {
        self.compute.as_ref()
    }
    /// <p>A map that contains tag keys and tag values that are attached to the simulation job
    /// request.</p>
    pub fn tags(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.tags.as_ref()
    }
}
impl std::fmt::Debug for SimulationJobRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SimulationJobRequest");
        formatter.field("output_location", &self.output_location);
        formatter.field("logging_config", &self.logging_config);
        formatter.field(
            "max_job_duration_in_seconds",
            &self.max_job_duration_in_seconds,
        );
        formatter.field("iam_role", &self.iam_role);
        formatter.field("failure_behavior", &self.failure_behavior);
        formatter.field("use_default_applications", &self.use_default_applications);
        formatter.field("robot_applications", &self.robot_applications);
        formatter.field("simulation_applications", &self.simulation_applications);
        formatter.field("data_sources", &self.data_sources);
        formatter.field("vpc_config", &self.vpc_config);
        formatter.field("compute", &self.compute);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}
/// See [`SimulationJobRequest`](crate::model::SimulationJobRequest)
pub mod simulation_job_request {
    /// A builder for [`SimulationJobRequest`](crate::model::SimulationJobRequest)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) output_location: std::option::Option<crate::model::OutputLocation>,
        pub(crate) logging_config: std::option::Option<crate::model::LoggingConfig>,
        pub(crate) max_job_duration_in_seconds: std::option::Option<i64>,
        pub(crate) iam_role: std::option::Option<std::string::String>,
        pub(crate) failure_behavior: std::option::Option<crate::model::FailureBehavior>,
        pub(crate) use_default_applications: std::option::Option<bool>,
        pub(crate) robot_applications:
            std::option::Option<std::vec::Vec<crate::model::RobotApplicationConfig>>,
        pub(crate) simulation_applications:
            std::option::Option<std::vec::Vec<crate::model::SimulationApplicationConfig>>,
        pub(crate) data_sources: std::option::Option<std::vec::Vec<crate::model::DataSourceConfig>>,
        pub(crate) vpc_config: std::option::Option<crate::model::VpcConfig>,
        pub(crate) compute: std::option::Option<crate::model::Compute>,
        pub(crate) tags: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
    }
    impl Builder {
        /// <p>The output location.</p>
        pub fn output_location(mut self, input: crate::model::OutputLocation) -> Self {
            self.output_location = Some(input);
            self
        }
        /// <p>The output location.</p>
        pub fn set_output_location(
            mut self,
            input: std::option::Option<crate::model::OutputLocation>,
        ) -> Self {
            self.output_location = input;
            self
        }
        /// <p>The logging configuration.</p>
        pub fn logging_config(mut self, input: crate::model::LoggingConfig) -> Self {
            self.logging_config = Some(input);
            self
        }
        /// <p>The logging configuration.</p>
        pub fn set_logging_config(
            mut self,
            input: std::option::Option<crate::model::LoggingConfig>,
        ) -> Self {
            self.logging_config = input;
            self
        }
        /// <p>The maximum simulation job duration in seconds. The value must be 8 days (691,200
        /// seconds) or less.</p>
        pub fn max_job_duration_in_seconds(mut self, input: i64) -> Self {
            self.max_job_duration_in_seconds = Some(input);
            self
        }
        /// <p>The maximum simulation job duration in seconds. The value must be 8 days (691,200
        /// seconds) or less.</p>
        pub fn set_max_job_duration_in_seconds(mut self, input: std::option::Option<i64>) -> Self {
            self.max_job_duration_in_seconds = input;
            self
        }
        /// <p>The IAM role name that allows the simulation instance to call the AWS APIs that are
        /// specified in its associated policies on your behalf. This is how credentials are passed in
        /// to your simulation job. </p>
        pub fn iam_role(mut self, input: impl Into<std::string::String>) -> Self {
            self.iam_role = Some(input.into());
            self
        }
        /// <p>The IAM role name that allows the simulation instance to call the AWS APIs that are
        /// specified in its associated policies on your behalf. This is how credentials are passed in
        /// to your simulation job. </p>
        pub fn set_iam_role(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.iam_role = input;
            self
        }
        /// <p>The failure behavior the simulation job.</p>
        /// <dl>
        /// <dt>Continue</dt>
        /// <dd>
        /// <p>Leaves the host running for its maximum timeout duration after a
        /// <code>4XX</code> error code.</p>
        /// </dd>
        /// <dt>Fail</dt>
        /// <dd>
        /// <p>Stop the simulation job and terminate the instance.</p>
        /// </dd>
        /// </dl>
        pub fn failure_behavior(mut self, input: crate::model::FailureBehavior) -> Self {
            self.failure_behavior = Some(input);
            self
        }
        /// <p>The failure behavior the simulation job.</p>
        /// <dl>
        /// <dt>Continue</dt>
        /// <dd>
        /// <p>Leaves the host running for its maximum timeout duration after a
        /// <code>4XX</code> error code.</p>
        /// </dd>
        /// <dt>Fail</dt>
        /// <dd>
        /// <p>Stop the simulation job and terminate the instance.</p>
        /// </dd>
        /// </dl>
        pub fn set_failure_behavior(
            mut self,
            input: std::option::Option<crate::model::FailureBehavior>,
        ) -> Self {
            self.failure_behavior = input;
            self
        }
        /// <p>A Boolean indicating whether to use default applications in the simulation job. Default
        /// applications include Gazebo, rqt, rviz and terminal access. </p>
        pub fn use_default_applications(mut self, input: bool) -> Self {
            self.use_default_applications = Some(input);
            self
        }
        /// <p>A Boolean indicating whether to use default applications in the simulation job. Default
        /// applications include Gazebo, rqt, rviz and terminal access. </p>
        pub fn set_use_default_applications(mut self, input: std::option::Option<bool>) -> Self {
            self.use_default_applications = input;
            self
        }
        /// Appends an item to `robot_applications`.
        ///
        /// To override the contents of this collection use [`set_robot_applications`](Self::set_robot_applications).
        ///
        /// <p>The robot applications to use in the simulation job.</p>
        pub fn robot_applications(
            mut self,
            input: impl Into<crate::model::RobotApplicationConfig>,
        ) -> Self {
            let mut v = self.robot_applications.unwrap_or_default();
            v.push(input.into());
            self.robot_applications = Some(v);
            self
        }
        /// <p>The robot applications to use in the simulation job.</p>
        pub fn set_robot_applications(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::RobotApplicationConfig>>,
        ) -> Self {
            self.robot_applications = input;
            self
        }
        /// Appends an item to `simulation_applications`.
        ///
        /// To override the contents of this collection use [`set_simulation_applications`](Self::set_simulation_applications).
        ///
        /// <p>The simulation applications to use in the simulation job.</p>
        pub fn simulation_applications(
            mut self,
            input: impl Into<crate::model::SimulationApplicationConfig>,
        ) -> Self {
            let mut v = self.simulation_applications.unwrap_or_default();
            v.push(input.into());
            self.simulation_applications = Some(v);
            self
        }
        /// <p>The simulation applications to use in the simulation job.</p>
        pub fn set_simulation_applications(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::SimulationApplicationConfig>>,
        ) -> Self {
            self.simulation_applications = input;
            self
        }
        /// Appends an item to `data_sources`.
        ///
        /// To override the contents of this collection use [`set_data_sources`](Self::set_data_sources).
        ///
        /// <p>Specify data sources to mount read-only files from S3 into your simulation. These files
        /// are available under <code>/opt/robomaker/datasources/data_source_name</code>. </p>
        /// <note>
        /// <p>There is a limit of 100 files and a combined size of 25GB for all
        /// <code>DataSourceConfig</code> objects. </p>
        /// </note>
        pub fn data_sources(mut self, input: impl Into<crate::model::DataSourceConfig>) -> Self {
            let mut v = self.data_sources.unwrap_or_default();
            v.push(input.into());
            self.data_sources = Some(v);
            self
        }
        /// <p>Specify data sources to mount read-only files from S3 into your simulation. These files
        /// are available under <code>/opt/robomaker/datasources/data_source_name</code>. </p>
        /// <note>
        /// <p>There is a limit of 100 files and a combined size of 25GB for all
        /// <code>DataSourceConfig</code> objects. </p>
        /// </note>
        pub fn set_data_sources(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::DataSourceConfig>>,
        ) -> Self {
            self.data_sources = input;
            self
        }
        /// <p>If your simulation job accesses resources in a VPC, you provide this parameter
        /// identifying the list of security group IDs and subnet IDs. These must belong to the same
        /// VPC. You must provide at least one security group and two subnet IDs.</p>
        pub fn vpc_config(mut self, input: crate::model::VpcConfig) -> Self {
            self.vpc_config = Some(input);
            self
        }
        /// <p>If your simulation job accesses resources in a VPC, you provide this parameter
        /// identifying the list of security group IDs and subnet IDs. These must belong to the same
        /// VPC. You must provide at least one security group and two subnet IDs.</p>
        pub fn set_vpc_config(
            mut self,
            input: std::option::Option<crate::model::VpcConfig>,
        ) -> Self {
            self.vpc_config = input;
            self
        }
        /// <p>Compute information for the simulation job</p>
        pub fn compute(mut self, input: crate::model::Compute) -> Self {
            self.compute = Some(input);
            self
        }
        /// <p>Compute information for the simulation job</p>
        pub fn set_compute(mut self, input: std::option::Option<crate::model::Compute>) -> Self {
            self.compute = input;
            self
        }
        /// Adds a key-value pair to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>A map that contains tag keys and tag values that are attached to the simulation job
        /// request.</p>
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.tags.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.tags = Some(hash_map);
            self
        }
        /// <p>A map that contains tag keys and tag values that are attached to the simulation job
        /// request.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`SimulationJobRequest`](crate::model::SimulationJobRequest)
        pub fn build(self) -> crate::model::SimulationJobRequest {
            crate::model::SimulationJobRequest {
                output_location: self.output_location,
                logging_config: self.logging_config,
                max_job_duration_in_seconds: self.max_job_duration_in_seconds.unwrap_or_default(),
                iam_role: self.iam_role,
                failure_behavior: self.failure_behavior,
                use_default_applications: self.use_default_applications,
                robot_applications: self.robot_applications,
                simulation_applications: self.simulation_applications,
                data_sources: self.data_sources,
                vpc_config: self.vpc_config,
                compute: self.compute,
                tags: self.tags,
            }
        }
    }
}
impl SimulationJobRequest {
    /// Creates a new builder-style object to manufacture [`SimulationJobRequest`](crate::model::SimulationJobRequest)
    pub fn builder() -> crate::model::simulation_job_request::Builder {
        crate::model::simulation_job_request::Builder::default()
    }
}

/// <p>Compute information for the simulation job.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Compute {
    /// <p>The simulation unit limit. Your simulation is allocated CPU and memory proportional to
    /// the supplied simulation unit limit. A simulation unit is 1 vcpu and 2GB of memory. You are
    /// only billed for the SU utilization you consume up to the maximum value provided. The
    /// default is 15. </p>
    pub simulation_unit_limit: std::option::Option<i32>,
    /// <p>Compute type information for the simulation job.</p>
    pub compute_type: std::option::Option<crate::model::ComputeType>,
    /// <p>Compute GPU unit limit for the simulation job. It is the same as the number of GPUs
    /// allocated to the SimulationJob.</p>
    pub gpu_unit_limit: std::option::Option<i32>,
}
impl Compute {
    /// <p>The simulation unit limit. Your simulation is allocated CPU and memory proportional to
    /// the supplied simulation unit limit. A simulation unit is 1 vcpu and 2GB of memory. You are
    /// only billed for the SU utilization you consume up to the maximum value provided. The
    /// default is 15. </p>
    pub fn simulation_unit_limit(&self) -> std::option::Option<i32> {
        self.simulation_unit_limit
    }
    /// <p>Compute type information for the simulation job.</p>
    pub fn compute_type(&self) -> std::option::Option<&crate::model::ComputeType> {
        self.compute_type.as_ref()
    }
    /// <p>Compute GPU unit limit for the simulation job. It is the same as the number of GPUs
    /// allocated to the SimulationJob.</p>
    pub fn gpu_unit_limit(&self) -> std::option::Option<i32> {
        self.gpu_unit_limit
    }
}
impl std::fmt::Debug for Compute {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Compute");
        formatter.field("simulation_unit_limit", &self.simulation_unit_limit);
        formatter.field("compute_type", &self.compute_type);
        formatter.field("gpu_unit_limit", &self.gpu_unit_limit);
        formatter.finish()
    }
}
/// See [`Compute`](crate::model::Compute)
pub mod compute {
    /// A builder for [`Compute`](crate::model::Compute)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) simulation_unit_limit: std::option::Option<i32>,
        pub(crate) compute_type: std::option::Option<crate::model::ComputeType>,
        pub(crate) gpu_unit_limit: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The simulation unit limit. Your simulation is allocated CPU and memory proportional to
        /// the supplied simulation unit limit. A simulation unit is 1 vcpu and 2GB of memory. You are
        /// only billed for the SU utilization you consume up to the maximum value provided. The
        /// default is 15. </p>
        pub fn simulation_unit_limit(mut self, input: i32) -> Self {
            self.simulation_unit_limit = Some(input);
            self
        }
        /// <p>The simulation unit limit. Your simulation is allocated CPU and memory proportional to
        /// the supplied simulation unit limit. A simulation unit is 1 vcpu and 2GB of memory. You are
        /// only billed for the SU utilization you consume up to the maximum value provided. The
        /// default is 15. </p>
        pub fn set_simulation_unit_limit(mut self, input: std::option::Option<i32>) -> Self {
            self.simulation_unit_limit = input;
            self
        }
        /// <p>Compute type information for the simulation job.</p>
        pub fn compute_type(mut self, input: crate::model::ComputeType) -> Self {
            self.compute_type = Some(input);
            self
        }
        /// <p>Compute type information for the simulation job.</p>
        pub fn set_compute_type(
            mut self,
            input: std::option::Option<crate::model::ComputeType>,
        ) -> Self {
            self.compute_type = input;
            self
        }
        /// <p>Compute GPU unit limit for the simulation job. It is the same as the number of GPUs
        /// allocated to the SimulationJob.</p>
        pub fn gpu_unit_limit(mut self, input: i32) -> Self {
            self.gpu_unit_limit = Some(input);
            self
        }
        /// <p>Compute GPU unit limit for the simulation job. It is the same as the number of GPUs
        /// allocated to the SimulationJob.</p>
        pub fn set_gpu_unit_limit(mut self, input: std::option::Option<i32>) -> Self {
            self.gpu_unit_limit = input;
            self
        }
        /// Consumes the builder and constructs a [`Compute`](crate::model::Compute)
        pub fn build(self) -> crate::model::Compute {
            crate::model::Compute {
                simulation_unit_limit: self.simulation_unit_limit,
                compute_type: self.compute_type,
                gpu_unit_limit: self.gpu_unit_limit,
            }
        }
    }
}
impl Compute {
    /// Creates a new builder-style object to manufacture [`Compute`](crate::model::Compute)
    pub fn builder() -> crate::model::compute::Builder {
        crate::model::compute::Builder::default()
    }
}

/// <p>If your simulation job accesses resources in a VPC, you provide this parameter
/// identifying the list of security group IDs and subnet IDs. These must belong to the same
/// VPC. You must provide at least one security group and two subnet IDs.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct VpcConfig {
    /// <p>A list of one or more subnet IDs in your VPC.</p>
    pub subnets: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>A list of one or more security groups IDs in your VPC.</p>
    pub security_groups: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>A boolean indicating whether to assign a public IP address.</p>
    pub assign_public_ip: bool,
}
impl VpcConfig {
    /// <p>A list of one or more subnet IDs in your VPC.</p>
    pub fn subnets(&self) -> std::option::Option<&[std::string::String]> {
        self.subnets.as_deref()
    }
    /// <p>A list of one or more security groups IDs in your VPC.</p>
    pub fn security_groups(&self) -> std::option::Option<&[std::string::String]> {
        self.security_groups.as_deref()
    }
    /// <p>A boolean indicating whether to assign a public IP address.</p>
    pub fn assign_public_ip(&self) -> bool {
        self.assign_public_ip
    }
}
impl std::fmt::Debug for VpcConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("VpcConfig");
        formatter.field("subnets", &self.subnets);
        formatter.field("security_groups", &self.security_groups);
        formatter.field("assign_public_ip", &self.assign_public_ip);
        formatter.finish()
    }
}
/// See [`VpcConfig`](crate::model::VpcConfig)
pub mod vpc_config {
    /// A builder for [`VpcConfig`](crate::model::VpcConfig)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) subnets: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) security_groups: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) assign_public_ip: std::option::Option<bool>,
    }
    impl Builder {
        /// Appends an item to `subnets`.
        ///
        /// To override the contents of this collection use [`set_subnets`](Self::set_subnets).
        ///
        /// <p>A list of one or more subnet IDs in your VPC.</p>
        pub fn subnets(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.subnets.unwrap_or_default();
            v.push(input.into());
            self.subnets = Some(v);
            self
        }
        /// <p>A list of one or more subnet IDs in your VPC.</p>
        pub fn set_subnets(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.subnets = input;
            self
        }
        /// Appends an item to `security_groups`.
        ///
        /// To override the contents of this collection use [`set_security_groups`](Self::set_security_groups).
        ///
        /// <p>A list of one or more security groups IDs in your VPC.</p>
        pub fn security_groups(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.security_groups.unwrap_or_default();
            v.push(input.into());
            self.security_groups = Some(v);
            self
        }
        /// <p>A list of one or more security groups IDs in your VPC.</p>
        pub fn set_security_groups(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.security_groups = input;
            self
        }
        /// <p>A boolean indicating whether to assign a public IP address.</p>
        pub fn assign_public_ip(mut self, input: bool) -> Self {
            self.assign_public_ip = Some(input);
            self
        }
        /// <p>A boolean indicating whether to assign a public IP address.</p>
        pub fn set_assign_public_ip(mut self, input: std::option::Option<bool>) -> Self {
            self.assign_public_ip = input;
            self
        }
        /// Consumes the builder and constructs a [`VpcConfig`](crate::model::VpcConfig)
        pub fn build(self) -> crate::model::VpcConfig {
            crate::model::VpcConfig {
                subnets: self.subnets,
                security_groups: self.security_groups,
                assign_public_ip: self.assign_public_ip.unwrap_or_default(),
            }
        }
    }
}
impl VpcConfig {
    /// Creates a new builder-style object to manufacture [`VpcConfig`](crate::model::VpcConfig)
    pub fn builder() -> crate::model::vpc_config::Builder {
        crate::model::vpc_config::Builder::default()
    }
}

/// <p>Information about a data source.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DataSourceConfig {
    /// <p>The name of the data source.</p>
    pub name: std::option::Option<std::string::String>,
    /// <p>The S3 bucket where the data files are located.</p>
    pub s3_bucket: std::option::Option<std::string::String>,
    /// <p>The list of S3 keys identifying the data source files.</p>
    pub s3_keys: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The data type for the data source that you're using for your container image or
    /// simulation job. You can use this field to specify whether your data source is an Archive,
    /// an Amazon S3 prefix, or a file.</p>
    /// <p>If you don't specify a field, the default value is <code>File</code>.</p>
    pub r#type: std::option::Option<crate::model::DataSourceType>,
    /// <p>The location where your files are mounted in the container image.</p>
    /// <p>If you've specified the <code>type</code> of the data source as an <code>Archive</code>,
    /// you must provide an Amazon S3 object key to your archive. The object key must point to
    /// either a <code>.zip</code> or <code>.tar.gz</code> file.</p>
    /// <p>If you've specified the <code>type</code> of the data source as a <code>Prefix</code>,
    /// you provide the Amazon S3 prefix that points to the files that you are using for your data
    /// source.</p>
    /// <p>If you've specified the <code>type</code> of the data source as a <code>File</code>, you
    /// provide the Amazon S3 path to the file that you're using as your data source.</p>
    pub destination: std::option::Option<std::string::String>,
}
impl DataSourceConfig {
    /// <p>The name of the data source.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The S3 bucket where the data files are located.</p>
    pub fn s3_bucket(&self) -> std::option::Option<&str> {
        self.s3_bucket.as_deref()
    }
    /// <p>The list of S3 keys identifying the data source files.</p>
    pub fn s3_keys(&self) -> std::option::Option<&[std::string::String]> {
        self.s3_keys.as_deref()
    }
    /// <p>The data type for the data source that you're using for your container image or
    /// simulation job. You can use this field to specify whether your data source is an Archive,
    /// an Amazon S3 prefix, or a file.</p>
    /// <p>If you don't specify a field, the default value is <code>File</code>.</p>
    pub fn r#type(&self) -> std::option::Option<&crate::model::DataSourceType> {
        self.r#type.as_ref()
    }
    /// <p>The location where your files are mounted in the container image.</p>
    /// <p>If you've specified the <code>type</code> of the data source as an <code>Archive</code>,
    /// you must provide an Amazon S3 object key to your archive. The object key must point to
    /// either a <code>.zip</code> or <code>.tar.gz</code> file.</p>
    /// <p>If you've specified the <code>type</code> of the data source as a <code>Prefix</code>,
    /// you provide the Amazon S3 prefix that points to the files that you are using for your data
    /// source.</p>
    /// <p>If you've specified the <code>type</code> of the data source as a <code>File</code>, you
    /// provide the Amazon S3 path to the file that you're using as your data source.</p>
    pub fn destination(&self) -> std::option::Option<&str> {
        self.destination.as_deref()
    }
}
impl std::fmt::Debug for DataSourceConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DataSourceConfig");
        formatter.field("name", &self.name);
        formatter.field("s3_bucket", &self.s3_bucket);
        formatter.field("s3_keys", &self.s3_keys);
        formatter.field("r#type", &self.r#type);
        formatter.field("destination", &self.destination);
        formatter.finish()
    }
}
/// See [`DataSourceConfig`](crate::model::DataSourceConfig)
pub mod data_source_config {
    /// A builder for [`DataSourceConfig`](crate::model::DataSourceConfig)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) s3_bucket: std::option::Option<std::string::String>,
        pub(crate) s3_keys: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) r#type: std::option::Option<crate::model::DataSourceType>,
        pub(crate) destination: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the data source.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the data source.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The S3 bucket where the data files are located.</p>
        pub fn s3_bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.s3_bucket = Some(input.into());
            self
        }
        /// <p>The S3 bucket where the data files are located.</p>
        pub fn set_s3_bucket(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.s3_bucket = input;
            self
        }
        /// Appends an item to `s3_keys`.
        ///
        /// To override the contents of this collection use [`set_s3_keys`](Self::set_s3_keys).
        ///
        /// <p>The list of S3 keys identifying the data source files.</p>
        pub fn s3_keys(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.s3_keys.unwrap_or_default();
            v.push(input.into());
            self.s3_keys = Some(v);
            self
        }
        /// <p>The list of S3 keys identifying the data source files.</p>
        pub fn set_s3_keys(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.s3_keys = input;
            self
        }
        /// <p>The data type for the data source that you're using for your container image or
        /// simulation job. You can use this field to specify whether your data source is an Archive,
        /// an Amazon S3 prefix, or a file.</p>
        /// <p>If you don't specify a field, the default value is <code>File</code>.</p>
        pub fn r#type(mut self, input: crate::model::DataSourceType) -> Self {
            self.r#type = Some(input);
            self
        }
        /// <p>The data type for the data source that you're using for your container image or
        /// simulation job. You can use this field to specify whether your data source is an Archive,
        /// an Amazon S3 prefix, or a file.</p>
        /// <p>If you don't specify a field, the default value is <code>File</code>.</p>
        pub fn set_type(
            mut self,
            input: std::option::Option<crate::model::DataSourceType>,
        ) -> Self {
            self.r#type = input;
            self
        }
        /// <p>The location where your files are mounted in the container image.</p>
        /// <p>If you've specified the <code>type</code> of the data source as an <code>Archive</code>,
        /// you must provide an Amazon S3 object key to your archive. The object key must point to
        /// either a <code>.zip</code> or <code>.tar.gz</code> file.</p>
        /// <p>If you've specified the <code>type</code> of the data source as a <code>Prefix</code>,
        /// you provide the Amazon S3 prefix that points to the files that you are using for your data
        /// source.</p>
        /// <p>If you've specified the <code>type</code> of the data source as a <code>File</code>, you
        /// provide the Amazon S3 path to the file that you're using as your data source.</p>
        pub fn destination(mut self, input: impl Into<std::string::String>) -> Self {
            self.destination = Some(input.into());
            self
        }
        /// <p>The location where your files are mounted in the container image.</p>
        /// <p>If you've specified the <code>type</code> of the data source as an <code>Archive</code>,
        /// you must provide an Amazon S3 object key to your archive. The object key must point to
        /// either a <code>.zip</code> or <code>.tar.gz</code> file.</p>
        /// <p>If you've specified the <code>type</code> of the data source as a <code>Prefix</code>,
        /// you provide the Amazon S3 prefix that points to the files that you are using for your data
        /// source.</p>
        /// <p>If you've specified the <code>type</code> of the data source as a <code>File</code>, you
        /// provide the Amazon S3 path to the file that you're using as your data source.</p>
        pub fn set_destination(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.destination = input;
            self
        }
        /// Consumes the builder and constructs a [`DataSourceConfig`](crate::model::DataSourceConfig)
        pub fn build(self) -> crate::model::DataSourceConfig {
            crate::model::DataSourceConfig {
                name: self.name,
                s3_bucket: self.s3_bucket,
                s3_keys: self.s3_keys,
                r#type: self.r#type,
                destination: self.destination,
            }
        }
    }
}
impl DataSourceConfig {
    /// Creates a new builder-style object to manufacture [`DataSourceConfig`](crate::model::DataSourceConfig)
    pub fn builder() -> crate::model::data_source_config::Builder {
        crate::model::data_source_config::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum DataSourceType {
    #[allow(missing_docs)] // documentation missing in model
    Archive,
    #[allow(missing_docs)] // documentation missing in model
    File,
    #[allow(missing_docs)] // documentation missing in model
    Prefix,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for DataSourceType {
    fn from(s: &str) -> Self {
        match s {
            "Archive" => DataSourceType::Archive,
            "File" => DataSourceType::File,
            "Prefix" => DataSourceType::Prefix,
            other => DataSourceType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for DataSourceType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(DataSourceType::from(s))
    }
}
impl DataSourceType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            DataSourceType::Archive => "Archive",
            DataSourceType::File => "File",
            DataSourceType::Prefix => "Prefix",
            DataSourceType::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["Archive", "File", "Prefix"]
    }
}
impl AsRef<str> for DataSourceType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Information about a simulation application configuration.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SimulationApplicationConfig {
    /// <p>The application information for the simulation application.</p>
    pub application: std::option::Option<std::string::String>,
    /// <p>The version of the simulation application.</p>
    pub application_version: std::option::Option<std::string::String>,
    /// <p>The launch configuration for the simulation application.</p>
    pub launch_config: std::option::Option<crate::model::LaunchConfig>,
    /// <p>Information about upload configurations for the simulation application.</p>
    pub upload_configurations:
        std::option::Option<std::vec::Vec<crate::model::UploadConfiguration>>,
    /// <p>A list of world configurations.</p>
    pub world_configs: std::option::Option<std::vec::Vec<crate::model::WorldConfig>>,
    /// <p>A Boolean indicating whether to use default upload configurations. By default,
    /// <code>.ros</code> and <code>.gazebo</code> files are uploaded when the application
    /// terminates and all ROS topics will be recorded.</p>
    /// <p>If you set this value, you must specify an <code>outputLocation</code>. </p>
    pub use_default_upload_configurations: std::option::Option<bool>,
    /// <p>Information about tools configured for the simulation application.</p>
    pub tools: std::option::Option<std::vec::Vec<crate::model::Tool>>,
    /// <p>A Boolean indicating whether to use default simulation application tools. The default
    /// tools are rviz, rqt, terminal and rosbag record. The default is <code>False</code>. </p>
    pub use_default_tools: std::option::Option<bool>,
}
impl SimulationApplicationConfig {
    /// <p>The application information for the simulation application.</p>
    pub fn application(&self) -> std::option::Option<&str> {
        self.application.as_deref()
    }
    /// <p>The version of the simulation application.</p>
    pub fn application_version(&self) -> std::option::Option<&str> {
        self.application_version.as_deref()
    }
    /// <p>The launch configuration for the simulation application.</p>
    pub fn launch_config(&self) -> std::option::Option<&crate::model::LaunchConfig> {
        self.launch_config.as_ref()
    }
    /// <p>Information about upload configurations for the simulation application.</p>
    pub fn upload_configurations(
        &self,
    ) -> std::option::Option<&[crate::model::UploadConfiguration]> {
        self.upload_configurations.as_deref()
    }
    /// <p>A list of world configurations.</p>
    pub fn world_configs(&self) -> std::option::Option<&[crate::model::WorldConfig]> {
        self.world_configs.as_deref()
    }
    /// <p>A Boolean indicating whether to use default upload configurations. By default,
    /// <code>.ros</code> and <code>.gazebo</code> files are uploaded when the application
    /// terminates and all ROS topics will be recorded.</p>
    /// <p>If you set this value, you must specify an <code>outputLocation</code>. </p>
    pub fn use_default_upload_configurations(&self) -> std::option::Option<bool> {
        self.use_default_upload_configurations
    }
    /// <p>Information about tools configured for the simulation application.</p>
    pub fn tools(&self) -> std::option::Option<&[crate::model::Tool]> {
        self.tools.as_deref()
    }
    /// <p>A Boolean indicating whether to use default simulation application tools. The default
    /// tools are rviz, rqt, terminal and rosbag record. The default is <code>False</code>. </p>
    pub fn use_default_tools(&self) -> std::option::Option<bool> {
        self.use_default_tools
    }
}
impl std::fmt::Debug for SimulationApplicationConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SimulationApplicationConfig");
        formatter.field("application", &self.application);
        formatter.field("application_version", &self.application_version);
        formatter.field("launch_config", &self.launch_config);
        formatter.field("upload_configurations", &self.upload_configurations);
        formatter.field("world_configs", &self.world_configs);
        formatter.field(
            "use_default_upload_configurations",
            &self.use_default_upload_configurations,
        );
        formatter.field("tools", &self.tools);
        formatter.field("use_default_tools", &self.use_default_tools);
        formatter.finish()
    }
}
/// See [`SimulationApplicationConfig`](crate::model::SimulationApplicationConfig)
pub mod simulation_application_config {
    /// A builder for [`SimulationApplicationConfig`](crate::model::SimulationApplicationConfig)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) application: std::option::Option<std::string::String>,
        pub(crate) application_version: std::option::Option<std::string::String>,
        pub(crate) launch_config: std::option::Option<crate::model::LaunchConfig>,
        pub(crate) upload_configurations:
            std::option::Option<std::vec::Vec<crate::model::UploadConfiguration>>,
        pub(crate) world_configs: std::option::Option<std::vec::Vec<crate::model::WorldConfig>>,
        pub(crate) use_default_upload_configurations: std::option::Option<bool>,
        pub(crate) tools: std::option::Option<std::vec::Vec<crate::model::Tool>>,
        pub(crate) use_default_tools: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>The application information for the simulation application.</p>
        pub fn application(mut self, input: impl Into<std::string::String>) -> Self {
            self.application = Some(input.into());
            self
        }
        /// <p>The application information for the simulation application.</p>
        pub fn set_application(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.application = input;
            self
        }
        /// <p>The version of the simulation application.</p>
        pub fn application_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.application_version = Some(input.into());
            self
        }
        /// <p>The version of the simulation application.</p>
        pub fn set_application_version(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.application_version = input;
            self
        }
        /// <p>The launch configuration for the simulation application.</p>
        pub fn launch_config(mut self, input: crate::model::LaunchConfig) -> Self {
            self.launch_config = Some(input);
            self
        }
        /// <p>The launch configuration for the simulation application.</p>
        pub fn set_launch_config(
            mut self,
            input: std::option::Option<crate::model::LaunchConfig>,
        ) -> Self {
            self.launch_config = input;
            self
        }
        /// Appends an item to `upload_configurations`.
        ///
        /// To override the contents of this collection use [`set_upload_configurations`](Self::set_upload_configurations).
        ///
        /// <p>Information about upload configurations for the simulation application.</p>
        pub fn upload_configurations(
            mut self,
            input: impl Into<crate::model::UploadConfiguration>,
        ) -> Self {
            let mut v = self.upload_configurations.unwrap_or_default();
            v.push(input.into());
            self.upload_configurations = Some(v);
            self
        }
        /// <p>Information about upload configurations for the simulation application.</p>
        pub fn set_upload_configurations(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::UploadConfiguration>>,
        ) -> Self {
            self.upload_configurations = input;
            self
        }
        /// Appends an item to `world_configs`.
        ///
        /// To override the contents of this collection use [`set_world_configs`](Self::set_world_configs).
        ///
        /// <p>A list of world configurations.</p>
        pub fn world_configs(mut self, input: impl Into<crate::model::WorldConfig>) -> Self {
            let mut v = self.world_configs.unwrap_or_default();
            v.push(input.into());
            self.world_configs = Some(v);
            self
        }
        /// <p>A list of world configurations.</p>
        pub fn set_world_configs(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::WorldConfig>>,
        ) -> Self {
            self.world_configs = input;
            self
        }
        /// <p>A Boolean indicating whether to use default upload configurations. By default,
        /// <code>.ros</code> and <code>.gazebo</code> files are uploaded when the application
        /// terminates and all ROS topics will be recorded.</p>
        /// <p>If you set this value, you must specify an <code>outputLocation</code>. </p>
        pub fn use_default_upload_configurations(mut self, input: bool) -> Self {
            self.use_default_upload_configurations = Some(input);
            self
        }
        /// <p>A Boolean indicating whether to use default upload configurations. By default,
        /// <code>.ros</code> and <code>.gazebo</code> files are uploaded when the application
        /// terminates and all ROS topics will be recorded.</p>
        /// <p>If you set this value, you must specify an <code>outputLocation</code>. </p>
        pub fn set_use_default_upload_configurations(
            mut self,
            input: std::option::Option<bool>,
        ) -> Self {
            self.use_default_upload_configurations = input;
            self
        }
        /// Appends an item to `tools`.
        ///
        /// To override the contents of this collection use [`set_tools`](Self::set_tools).
        ///
        /// <p>Information about tools configured for the simulation application.</p>
        pub fn tools(mut self, input: impl Into<crate::model::Tool>) -> Self {
            let mut v = self.tools.unwrap_or_default();
            v.push(input.into());
            self.tools = Some(v);
            self
        }
        /// <p>Information about tools configured for the simulation application.</p>
        pub fn set_tools(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tool>>,
        ) -> Self {
            self.tools = input;
            self
        }
        /// <p>A Boolean indicating whether to use default simulation application tools. The default
        /// tools are rviz, rqt, terminal and rosbag record. The default is <code>False</code>. </p>
        pub fn use_default_tools(mut self, input: bool) -> Self {
            self.use_default_tools = Some(input);
            self
        }
        /// <p>A Boolean indicating whether to use default simulation application tools. The default
        /// tools are rviz, rqt, terminal and rosbag record. The default is <code>False</code>. </p>
        pub fn set_use_default_tools(mut self, input: std::option::Option<bool>) -> Self {
            self.use_default_tools = input;
            self
        }
        /// Consumes the builder and constructs a [`SimulationApplicationConfig`](crate::model::SimulationApplicationConfig)
        pub fn build(self) -> crate::model::SimulationApplicationConfig {
            crate::model::SimulationApplicationConfig {
                application: self.application,
                application_version: self.application_version,
                launch_config: self.launch_config,
                upload_configurations: self.upload_configurations,
                world_configs: self.world_configs,
                use_default_upload_configurations: self.use_default_upload_configurations,
                tools: self.tools,
                use_default_tools: self.use_default_tools,
            }
        }
    }
}
impl SimulationApplicationConfig {
    /// Creates a new builder-style object to manufacture [`SimulationApplicationConfig`](crate::model::SimulationApplicationConfig)
    pub fn builder() -> crate::model::simulation_application_config::Builder {
        crate::model::simulation_application_config::Builder::default()
    }
}

/// <p>Information about a tool. Tools are used in a simulation job.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Tool {
    /// <p>Boolean indicating whether a streaming session will be configured for the tool. If
    /// <code>True</code>, AWS RoboMaker will configure a connection so you can interact with
    /// the tool as it is running in the simulation. It must have a graphical user interface. The
    /// default is <code>False</code>. </p>
    pub stream_ui: std::option::Option<bool>,
    /// <p>The name of the tool.</p>
    pub name: std::option::Option<std::string::String>,
    /// <p>Command-line arguments for the tool. It must include the tool executable name.</p>
    pub command: std::option::Option<std::string::String>,
    /// <p>Boolean indicating whether logs will be recorded in CloudWatch for the tool. The default
    /// is <code>False</code>. </p>
    pub stream_output_to_cloud_watch: std::option::Option<bool>,
    /// <p>Exit behavior determines what happens when your tool quits running. <code>RESTART</code>
    /// will cause your tool to be restarted. <code>FAIL</code> will cause your job to exit. The
    /// default is <code>RESTART</code>. </p>
    pub exit_behavior: std::option::Option<crate::model::ExitBehavior>,
}
impl Tool {
    /// <p>Boolean indicating whether a streaming session will be configured for the tool. If
    /// <code>True</code>, AWS RoboMaker will configure a connection so you can interact with
    /// the tool as it is running in the simulation. It must have a graphical user interface. The
    /// default is <code>False</code>. </p>
    pub fn stream_ui(&self) -> std::option::Option<bool> {
        self.stream_ui
    }
    /// <p>The name of the tool.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>Command-line arguments for the tool. It must include the tool executable name.</p>
    pub fn command(&self) -> std::option::Option<&str> {
        self.command.as_deref()
    }
    /// <p>Boolean indicating whether logs will be recorded in CloudWatch for the tool. The default
    /// is <code>False</code>. </p>
    pub fn stream_output_to_cloud_watch(&self) -> std::option::Option<bool> {
        self.stream_output_to_cloud_watch
    }
    /// <p>Exit behavior determines what happens when your tool quits running. <code>RESTART</code>
    /// will cause your tool to be restarted. <code>FAIL</code> will cause your job to exit. The
    /// default is <code>RESTART</code>. </p>
    pub fn exit_behavior(&self) -> std::option::Option<&crate::model::ExitBehavior> {
        self.exit_behavior.as_ref()
    }
}
impl std::fmt::Debug for Tool {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Tool");
        formatter.field("stream_ui", &self.stream_ui);
        formatter.field("name", &self.name);
        formatter.field("command", &self.command);
        formatter.field(
            "stream_output_to_cloud_watch",
            &self.stream_output_to_cloud_watch,
        );
        formatter.field("exit_behavior", &self.exit_behavior);
        formatter.finish()
    }
}
/// See [`Tool`](crate::model::Tool)
pub mod tool {
    /// A builder for [`Tool`](crate::model::Tool)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) stream_ui: std::option::Option<bool>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) command: std::option::Option<std::string::String>,
        pub(crate) stream_output_to_cloud_watch: std::option::Option<bool>,
        pub(crate) exit_behavior: std::option::Option<crate::model::ExitBehavior>,
    }
    impl Builder {
        /// <p>Boolean indicating whether a streaming session will be configured for the tool. If
        /// <code>True</code>, AWS RoboMaker will configure a connection so you can interact with
        /// the tool as it is running in the simulation. It must have a graphical user interface. The
        /// default is <code>False</code>. </p>
        pub fn stream_ui(mut self, input: bool) -> Self {
            self.stream_ui = Some(input);
            self
        }
        /// <p>Boolean indicating whether a streaming session will be configured for the tool. If
        /// <code>True</code>, AWS RoboMaker will configure a connection so you can interact with
        /// the tool as it is running in the simulation. It must have a graphical user interface. The
        /// default is <code>False</code>. </p>
        pub fn set_stream_ui(mut self, input: std::option::Option<bool>) -> Self {
            self.stream_ui = input;
            self
        }
        /// <p>The name of the tool.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the tool.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>Command-line arguments for the tool. It must include the tool executable name.</p>
        pub fn command(mut self, input: impl Into<std::string::String>) -> Self {
            self.command = Some(input.into());
            self
        }
        /// <p>Command-line arguments for the tool. It must include the tool executable name.</p>
        pub fn set_command(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.command = input;
            self
        }
        /// <p>Boolean indicating whether logs will be recorded in CloudWatch for the tool. The default
        /// is <code>False</code>. </p>
        pub fn stream_output_to_cloud_watch(mut self, input: bool) -> Self {
            self.stream_output_to_cloud_watch = Some(input);
            self
        }
        /// <p>Boolean indicating whether logs will be recorded in CloudWatch for the tool. The default
        /// is <code>False</code>. </p>
        pub fn set_stream_output_to_cloud_watch(
            mut self,
            input: std::option::Option<bool>,
        ) -> Self {
            self.stream_output_to_cloud_watch = input;
            self
        }
        /// <p>Exit behavior determines what happens when your tool quits running. <code>RESTART</code>
        /// will cause your tool to be restarted. <code>FAIL</code> will cause your job to exit. The
        /// default is <code>RESTART</code>. </p>
        pub fn exit_behavior(mut self, input: crate::model::ExitBehavior) -> Self {
            self.exit_behavior = Some(input);
            self
        }
        /// <p>Exit behavior determines what happens when your tool quits running. <code>RESTART</code>
        /// will cause your tool to be restarted. <code>FAIL</code> will cause your job to exit. The
        /// default is <code>RESTART</code>. </p>
        pub fn set_exit_behavior(
            mut self,
            input: std::option::Option<crate::model::ExitBehavior>,
        ) -> Self {
            self.exit_behavior = input;
            self
        }
        /// Consumes the builder and constructs a [`Tool`](crate::model::Tool)
        pub fn build(self) -> crate::model::Tool {
            crate::model::Tool {
                stream_ui: self.stream_ui,
                name: self.name,
                command: self.command,
                stream_output_to_cloud_watch: self.stream_output_to_cloud_watch,
                exit_behavior: self.exit_behavior,
            }
        }
    }
}
impl Tool {
    /// Creates a new builder-style object to manufacture [`Tool`](crate::model::Tool)
    pub fn builder() -> crate::model::tool::Builder {
        crate::model::tool::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ExitBehavior {
    #[allow(missing_docs)] // documentation missing in model
    Fail,
    #[allow(missing_docs)] // documentation missing in model
    Restart,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for ExitBehavior {
    fn from(s: &str) -> Self {
        match s {
            "FAIL" => ExitBehavior::Fail,
            "RESTART" => ExitBehavior::Restart,
            other => ExitBehavior::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for ExitBehavior {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ExitBehavior::from(s))
    }
}
impl ExitBehavior {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ExitBehavior::Fail => "FAIL",
            ExitBehavior::Restart => "RESTART",
            ExitBehavior::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["FAIL", "RESTART"]
    }
}
impl AsRef<str> for ExitBehavior {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Configuration information for a world.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct WorldConfig {
    /// <p>The world generated by Simulation WorldForge.</p>
    pub world: std::option::Option<std::string::String>,
}
impl WorldConfig {
    /// <p>The world generated by Simulation WorldForge.</p>
    pub fn world(&self) -> std::option::Option<&str> {
        self.world.as_deref()
    }
}
impl std::fmt::Debug for WorldConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("WorldConfig");
        formatter.field("world", &self.world);
        formatter.finish()
    }
}
/// See [`WorldConfig`](crate::model::WorldConfig)
pub mod world_config {
    /// A builder for [`WorldConfig`](crate::model::WorldConfig)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) world: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The world generated by Simulation WorldForge.</p>
        pub fn world(mut self, input: impl Into<std::string::String>) -> Self {
            self.world = Some(input.into());
            self
        }
        /// <p>The world generated by Simulation WorldForge.</p>
        pub fn set_world(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.world = input;
            self
        }
        /// Consumes the builder and constructs a [`WorldConfig`](crate::model::WorldConfig)
        pub fn build(self) -> crate::model::WorldConfig {
            crate::model::WorldConfig { world: self.world }
        }
    }
}
impl WorldConfig {
    /// Creates a new builder-style object to manufacture [`WorldConfig`](crate::model::WorldConfig)
    pub fn builder() -> crate::model::world_config::Builder {
        crate::model::world_config::Builder::default()
    }
}

/// <p>Provides upload configuration information. Files are uploaded from the simulation job to
/// a location you specify. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UploadConfiguration {
    /// <p>A prefix that specifies where files will be uploaded in Amazon S3. It is appended to the
    /// simulation output location to determine the final path. </p>
    /// <p> For example, if your simulation output location is <code>s3://my-bucket</code> and your
    /// upload configuration name is <code>robot-test</code>, your files will be uploaded to
    /// <code>s3://my-bucket/<simid>/<runid>/robot-test</code>. </p>
    pub name: std::option::Option<std::string::String>,
    /// <p> Specifies the path of the file(s) to upload. Standard Unix glob matching rules are
    /// accepted, with the addition of <code>**</code> as a <i>super asterisk</i>.
    /// For example, specifying <code>/var/log/**.log</code> causes all .log files in the
    /// <code>/var/log</code> directory tree to be collected. For more examples, see <a href="https://github.com/gobwas/glob">Glob Library</a>. </p>
    pub path: std::option::Option<std::string::String>,
    /// <p>Specifies when to upload the files:</p>
    /// <dl>
    /// <dt>UPLOAD_ON_TERMINATE</dt>
    /// <dd>
    /// <p>Matching files are uploaded once the simulation enters the
    /// <code>TERMINATING</code> state. Matching files are not uploaded until all of
    /// your code (including tools) have stopped. </p>
    /// <p>If there is a problem uploading a file, the upload is retried. If problems
    /// persist, no further upload attempts will be made.</p>
    /// </dd>
    /// <dt>UPLOAD_ROLLING_AUTO_REMOVE</dt>
    /// <dd>
    /// <p>Matching files are uploaded as they are created. They are deleted after they
    /// are uploaded. The specified path is checked every 5 seconds. A final check is made
    /// when all of your code (including tools) have stopped. </p>
    /// </dd>
    /// </dl>
    pub upload_behavior: std::option::Option<crate::model::UploadBehavior>,
}
impl UploadConfiguration {
    /// <p>A prefix that specifies where files will be uploaded in Amazon S3. It is appended to the
    /// simulation output location to determine the final path. </p>
    /// <p> For example, if your simulation output location is <code>s3://my-bucket</code> and your
    /// upload configuration name is <code>robot-test</code>, your files will be uploaded to
    /// <code>s3://my-bucket/<simid>/<runid>/robot-test</code>. </p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p> Specifies the path of the file(s) to upload. Standard Unix glob matching rules are
    /// accepted, with the addition of <code>**</code> as a <i>super asterisk</i>.
    /// For example, specifying <code>/var/log/**.log</code> causes all .log files in the
    /// <code>/var/log</code> directory tree to be collected. For more examples, see <a href="https://github.com/gobwas/glob">Glob Library</a>. </p>
    pub fn path(&self) -> std::option::Option<&str> {
        self.path.as_deref()
    }
    /// <p>Specifies when to upload the files:</p>
    /// <dl>
    /// <dt>UPLOAD_ON_TERMINATE</dt>
    /// <dd>
    /// <p>Matching files are uploaded once the simulation enters the
    /// <code>TERMINATING</code> state. Matching files are not uploaded until all of
    /// your code (including tools) have stopped. </p>
    /// <p>If there is a problem uploading a file, the upload is retried. If problems
    /// persist, no further upload attempts will be made.</p>
    /// </dd>
    /// <dt>UPLOAD_ROLLING_AUTO_REMOVE</dt>
    /// <dd>
    /// <p>Matching files are uploaded as they are created. They are deleted after they
    /// are uploaded. The specified path is checked every 5 seconds. A final check is made
    /// when all of your code (including tools) have stopped. </p>
    /// </dd>
    /// </dl>
    pub fn upload_behavior(&self) -> std::option::Option<&crate::model::UploadBehavior> {
        self.upload_behavior.as_ref()
    }
}
impl std::fmt::Debug for UploadConfiguration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UploadConfiguration");
        formatter.field("name", &self.name);
        formatter.field("path", &self.path);
        formatter.field("upload_behavior", &self.upload_behavior);
        formatter.finish()
    }
}
/// See [`UploadConfiguration`](crate::model::UploadConfiguration)
pub mod upload_configuration {
    /// A builder for [`UploadConfiguration`](crate::model::UploadConfiguration)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) path: std::option::Option<std::string::String>,
        pub(crate) upload_behavior: std::option::Option<crate::model::UploadBehavior>,
    }
    impl Builder {
        /// <p>A prefix that specifies where files will be uploaded in Amazon S3. It is appended to the
        /// simulation output location to determine the final path. </p>
        /// <p> For example, if your simulation output location is <code>s3://my-bucket</code> and your
        /// upload configuration name is <code>robot-test</code>, your files will be uploaded to
        /// <code>s3://my-bucket/<simid>/<runid>/robot-test</code>. </p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>A prefix that specifies where files will be uploaded in Amazon S3. It is appended to the
        /// simulation output location to determine the final path. </p>
        /// <p> For example, if your simulation output location is <code>s3://my-bucket</code> and your
        /// upload configuration name is <code>robot-test</code>, your files will be uploaded to
        /// <code>s3://my-bucket/<simid>/<runid>/robot-test</code>. </p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p> Specifies the path of the file(s) to upload. Standard Unix glob matching rules are
        /// accepted, with the addition of <code>**</code> as a <i>super asterisk</i>.
        /// For example, specifying <code>/var/log/**.log</code> causes all .log files in the
        /// <code>/var/log</code> directory tree to be collected. For more examples, see <a href="https://github.com/gobwas/glob">Glob Library</a>. </p>
        pub fn path(mut self, input: impl Into<std::string::String>) -> Self {
            self.path = Some(input.into());
            self
        }
        /// <p> Specifies the path of the file(s) to upload. Standard Unix glob matching rules are
        /// accepted, with the addition of <code>**</code> as a <i>super asterisk</i>.
        /// For example, specifying <code>/var/log/**.log</code> causes all .log files in the
        /// <code>/var/log</code> directory tree to be collected. For more examples, see <a href="https://github.com/gobwas/glob">Glob Library</a>. </p>
        pub fn set_path(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.path = input;
            self
        }
        /// <p>Specifies when to upload the files:</p>
        /// <dl>
        /// <dt>UPLOAD_ON_TERMINATE</dt>
        /// <dd>
        /// <p>Matching files are uploaded once the simulation enters the
        /// <code>TERMINATING</code> state. Matching files are not uploaded until all of
        /// your code (including tools) have stopped. </p>
        /// <p>If there is a problem uploading a file, the upload is retried. If problems
        /// persist, no further upload attempts will be made.</p>
        /// </dd>
        /// <dt>UPLOAD_ROLLING_AUTO_REMOVE</dt>
        /// <dd>
        /// <p>Matching files are uploaded as they are created. They are deleted after they
        /// are uploaded. The specified path is checked every 5 seconds. A final check is made
        /// when all of your code (including tools) have stopped. </p>
        /// </dd>
        /// </dl>
        pub fn upload_behavior(mut self, input: crate::model::UploadBehavior) -> Self {
            self.upload_behavior = Some(input);
            self
        }
        /// <p>Specifies when to upload the files:</p>
        /// <dl>
        /// <dt>UPLOAD_ON_TERMINATE</dt>
        /// <dd>
        /// <p>Matching files are uploaded once the simulation enters the
        /// <code>TERMINATING</code> state. Matching files are not uploaded until all of
        /// your code (including tools) have stopped. </p>
        /// <p>If there is a problem uploading a file, the upload is retried. If problems
        /// persist, no further upload attempts will be made.</p>
        /// </dd>
        /// <dt>UPLOAD_ROLLING_AUTO_REMOVE</dt>
        /// <dd>
        /// <p>Matching files are uploaded as they are created. They are deleted after they
        /// are uploaded. The specified path is checked every 5 seconds. A final check is made
        /// when all of your code (including tools) have stopped. </p>
        /// </dd>
        /// </dl>
        pub fn set_upload_behavior(
            mut self,
            input: std::option::Option<crate::model::UploadBehavior>,
        ) -> Self {
            self.upload_behavior = input;
            self
        }
        /// Consumes the builder and constructs a [`UploadConfiguration`](crate::model::UploadConfiguration)
        pub fn build(self) -> crate::model::UploadConfiguration {
            crate::model::UploadConfiguration {
                name: self.name,
                path: self.path,
                upload_behavior: self.upload_behavior,
            }
        }
    }
}
impl UploadConfiguration {
    /// Creates a new builder-style object to manufacture [`UploadConfiguration`](crate::model::UploadConfiguration)
    pub fn builder() -> crate::model::upload_configuration::Builder {
        crate::model::upload_configuration::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum UploadBehavior {
    #[allow(missing_docs)] // documentation missing in model
    UploadOnTerminate,
    #[allow(missing_docs)] // documentation missing in model
    UploadRollingAutoRemove,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for UploadBehavior {
    fn from(s: &str) -> Self {
        match s {
            "UPLOAD_ON_TERMINATE" => UploadBehavior::UploadOnTerminate,
            "UPLOAD_ROLLING_AUTO_REMOVE" => UploadBehavior::UploadRollingAutoRemove,
            other => UploadBehavior::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for UploadBehavior {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(UploadBehavior::from(s))
    }
}
impl UploadBehavior {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            UploadBehavior::UploadOnTerminate => "UPLOAD_ON_TERMINATE",
            UploadBehavior::UploadRollingAutoRemove => "UPLOAD_ROLLING_AUTO_REMOVE",
            UploadBehavior::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["UPLOAD_ON_TERMINATE", "UPLOAD_ROLLING_AUTO_REMOVE"]
    }
}
impl AsRef<str> for UploadBehavior {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Information about a launch configuration.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct LaunchConfig {
    /// <p>The package name.</p>
    pub package_name: std::option::Option<std::string::String>,
    /// <p>The launch file name.</p>
    pub launch_file: std::option::Option<std::string::String>,
    /// <p>The environment variables for the application launch.</p>
    pub environment_variables:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>The port forwarding configuration.</p>
    pub port_forwarding_config: std::option::Option<crate::model::PortForwardingConfig>,
    /// <p>Boolean indicating whether a streaming session will be configured for the application.
    /// If <code>True</code>, AWS RoboMaker will configure a connection so you can interact with
    /// your application as it is running in the simulation. You must configure and launch the
    /// component. It must have a graphical user interface. </p>
    pub stream_ui: bool,
    /// <p>If you've specified <code>General</code> as the value for your <code>RobotSoftwareSuite</code>, you can use this field to specify a list of commands for your container image.</p>
    /// <p>If you've specified <code>SimulationRuntime</code> as the value for your <code>SimulationSoftwareSuite</code>, you can use this field to specify a list of commands for your container image.</p>
    pub command: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl LaunchConfig {
    /// <p>The package name.</p>
    pub fn package_name(&self) -> std::option::Option<&str> {
        self.package_name.as_deref()
    }
    /// <p>The launch file name.</p>
    pub fn launch_file(&self) -> std::option::Option<&str> {
        self.launch_file.as_deref()
    }
    /// <p>The environment variables for the application launch.</p>
    pub fn environment_variables(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.environment_variables.as_ref()
    }
    /// <p>The port forwarding configuration.</p>
    pub fn port_forwarding_config(
        &self,
    ) -> std::option::Option<&crate::model::PortForwardingConfig> {
        self.port_forwarding_config.as_ref()
    }
    /// <p>Boolean indicating whether a streaming session will be configured for the application.
    /// If <code>True</code>, AWS RoboMaker will configure a connection so you can interact with
    /// your application as it is running in the simulation. You must configure and launch the
    /// component. It must have a graphical user interface. </p>
    pub fn stream_ui(&self) -> bool {
        self.stream_ui
    }
    /// <p>If you've specified <code>General</code> as the value for your <code>RobotSoftwareSuite</code>, you can use this field to specify a list of commands for your container image.</p>
    /// <p>If you've specified <code>SimulationRuntime</code> as the value for your <code>SimulationSoftwareSuite</code>, you can use this field to specify a list of commands for your container image.</p>
    pub fn command(&self) -> std::option::Option<&[std::string::String]> {
        self.command.as_deref()
    }
}
impl std::fmt::Debug for LaunchConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("LaunchConfig");
        formatter.field("package_name", &self.package_name);
        formatter.field("launch_file", &self.launch_file);
        formatter.field("environment_variables", &self.environment_variables);
        formatter.field("port_forwarding_config", &self.port_forwarding_config);
        formatter.field("stream_ui", &self.stream_ui);
        formatter.field("command", &self.command);
        formatter.finish()
    }
}
/// See [`LaunchConfig`](crate::model::LaunchConfig)
pub mod launch_config {
    /// A builder for [`LaunchConfig`](crate::model::LaunchConfig)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) package_name: std::option::Option<std::string::String>,
        pub(crate) launch_file: std::option::Option<std::string::String>,
        pub(crate) environment_variables: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
        pub(crate) port_forwarding_config: std::option::Option<crate::model::PortForwardingConfig>,
        pub(crate) stream_ui: std::option::Option<bool>,
        pub(crate) command: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// <p>The package name.</p>
        pub fn package_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.package_name = Some(input.into());
            self
        }
        /// <p>The package name.</p>
        pub fn set_package_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.package_name = input;
            self
        }
        /// <p>The launch file name.</p>
        pub fn launch_file(mut self, input: impl Into<std::string::String>) -> Self {
            self.launch_file = Some(input.into());
            self
        }
        /// <p>The launch file name.</p>
        pub fn set_launch_file(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.launch_file = input;
            self
        }
        /// Adds a key-value pair to `environment_variables`.
        ///
        /// To override the contents of this collection use [`set_environment_variables`](Self::set_environment_variables).
        ///
        /// <p>The environment variables for the application launch.</p>
        pub fn environment_variables(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.environment_variables.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.environment_variables = Some(hash_map);
            self
        }
        /// <p>The environment variables for the application launch.</p>
        pub fn set_environment_variables(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.environment_variables = input;
            self
        }
        /// <p>The port forwarding configuration.</p>
        pub fn port_forwarding_config(mut self, input: crate::model::PortForwardingConfig) -> Self {
            self.port_forwarding_config = Some(input);
            self
        }
        /// <p>The port forwarding configuration.</p>
        pub fn set_port_forwarding_config(
            mut self,
            input: std::option::Option<crate::model::PortForwardingConfig>,
        ) -> Self {
            self.port_forwarding_config = input;
            self
        }
        /// <p>Boolean indicating whether a streaming session will be configured for the application.
        /// If <code>True</code>, AWS RoboMaker will configure a connection so you can interact with
        /// your application as it is running in the simulation. You must configure and launch the
        /// component. It must have a graphical user interface. </p>
        pub fn stream_ui(mut self, input: bool) -> Self {
            self.stream_ui = Some(input);
            self
        }
        /// <p>Boolean indicating whether a streaming session will be configured for the application.
        /// If <code>True</code>, AWS RoboMaker will configure a connection so you can interact with
        /// your application as it is running in the simulation. You must configure and launch the
        /// component. It must have a graphical user interface. </p>
        pub fn set_stream_ui(mut self, input: std::option::Option<bool>) -> Self {
            self.stream_ui = input;
            self
        }
        /// Appends an item to `command`.
        ///
        /// To override the contents of this collection use [`set_command`](Self::set_command).
        ///
        /// <p>If you've specified <code>General</code> as the value for your <code>RobotSoftwareSuite</code>, you can use this field to specify a list of commands for your container image.</p>
        /// <p>If you've specified <code>SimulationRuntime</code> as the value for your <code>SimulationSoftwareSuite</code>, you can use this field to specify a list of commands for your container image.</p>
        pub fn command(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.command.unwrap_or_default();
            v.push(input.into());
            self.command = Some(v);
            self
        }
        /// <p>If you've specified <code>General</code> as the value for your <code>RobotSoftwareSuite</code>, you can use this field to specify a list of commands for your container image.</p>
        /// <p>If you've specified <code>SimulationRuntime</code> as the value for your <code>SimulationSoftwareSuite</code>, you can use this field to specify a list of commands for your container image.</p>
        pub fn set_command(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.command = input;
            self
        }
        /// Consumes the builder and constructs a [`LaunchConfig`](crate::model::LaunchConfig)
        pub fn build(self) -> crate::model::LaunchConfig {
            crate::model::LaunchConfig {
                package_name: self.package_name,
                launch_file: self.launch_file,
                environment_variables: self.environment_variables,
                port_forwarding_config: self.port_forwarding_config,
                stream_ui: self.stream_ui.unwrap_or_default(),
                command: self.command,
            }
        }
    }
}
impl LaunchConfig {
    /// Creates a new builder-style object to manufacture [`LaunchConfig`](crate::model::LaunchConfig)
    pub fn builder() -> crate::model::launch_config::Builder {
        crate::model::launch_config::Builder::default()
    }
}

/// <p>Configuration information for port forwarding.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PortForwardingConfig {
    /// <p>The port mappings for the configuration.</p>
    pub port_mappings: std::option::Option<std::vec::Vec<crate::model::PortMapping>>,
}
impl PortForwardingConfig {
    /// <p>The port mappings for the configuration.</p>
    pub fn port_mappings(&self) -> std::option::Option<&[crate::model::PortMapping]> {
        self.port_mappings.as_deref()
    }
}
impl std::fmt::Debug for PortForwardingConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PortForwardingConfig");
        formatter.field("port_mappings", &self.port_mappings);
        formatter.finish()
    }
}
/// See [`PortForwardingConfig`](crate::model::PortForwardingConfig)
pub mod port_forwarding_config {
    /// A builder for [`PortForwardingConfig`](crate::model::PortForwardingConfig)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) port_mappings: std::option::Option<std::vec::Vec<crate::model::PortMapping>>,
    }
    impl Builder {
        /// Appends an item to `port_mappings`.
        ///
        /// To override the contents of this collection use [`set_port_mappings`](Self::set_port_mappings).
        ///
        /// <p>The port mappings for the configuration.</p>
        pub fn port_mappings(mut self, input: impl Into<crate::model::PortMapping>) -> Self {
            let mut v = self.port_mappings.unwrap_or_default();
            v.push(input.into());
            self.port_mappings = Some(v);
            self
        }
        /// <p>The port mappings for the configuration.</p>
        pub fn set_port_mappings(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::PortMapping>>,
        ) -> Self {
            self.port_mappings = input;
            self
        }
        /// Consumes the builder and constructs a [`PortForwardingConfig`](crate::model::PortForwardingConfig)
        pub fn build(self) -> crate::model::PortForwardingConfig {
            crate::model::PortForwardingConfig {
                port_mappings: self.port_mappings,
            }
        }
    }
}
impl PortForwardingConfig {
    /// Creates a new builder-style object to manufacture [`PortForwardingConfig`](crate::model::PortForwardingConfig)
    pub fn builder() -> crate::model::port_forwarding_config::Builder {
        crate::model::port_forwarding_config::Builder::default()
    }
}

/// <p>An object representing a port mapping.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PortMapping {
    /// <p>The port number on the simulation job instance to use as a remote connection point.
    /// </p>
    pub job_port: i32,
    /// <p>The port number on the application.</p>
    pub application_port: i32,
    /// <p>A Boolean indicating whether to enable this port mapping on public IP.</p>
    pub enable_on_public_ip: bool,
}
impl PortMapping {
    /// <p>The port number on the simulation job instance to use as a remote connection point.
    /// </p>
    pub fn job_port(&self) -> i32 {
        self.job_port
    }
    /// <p>The port number on the application.</p>
    pub fn application_port(&self) -> i32 {
        self.application_port
    }
    /// <p>A Boolean indicating whether to enable this port mapping on public IP.</p>
    pub fn enable_on_public_ip(&self) -> bool {
        self.enable_on_public_ip
    }
}
impl std::fmt::Debug for PortMapping {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PortMapping");
        formatter.field("job_port", &self.job_port);
        formatter.field("application_port", &self.application_port);
        formatter.field("enable_on_public_ip", &self.enable_on_public_ip);
        formatter.finish()
    }
}
/// See [`PortMapping`](crate::model::PortMapping)
pub mod port_mapping {
    /// A builder for [`PortMapping`](crate::model::PortMapping)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) job_port: std::option::Option<i32>,
        pub(crate) application_port: std::option::Option<i32>,
        pub(crate) enable_on_public_ip: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>The port number on the simulation job instance to use as a remote connection point.
        /// </p>
        pub fn job_port(mut self, input: i32) -> Self {
            self.job_port = Some(input);
            self
        }
        /// <p>The port number on the simulation job instance to use as a remote connection point.
        /// </p>
        pub fn set_job_port(mut self, input: std::option::Option<i32>) -> Self {
            self.job_port = input;
            self
        }
        /// <p>The port number on the application.</p>
        pub fn application_port(mut self, input: i32) -> Self {
            self.application_port = Some(input);
            self
        }
        /// <p>The port number on the application.</p>
        pub fn set_application_port(mut self, input: std::option::Option<i32>) -> Self {
            self.application_port = input;
            self
        }
        /// <p>A Boolean indicating whether to enable this port mapping on public IP.</p>
        pub fn enable_on_public_ip(mut self, input: bool) -> Self {
            self.enable_on_public_ip = Some(input);
            self
        }
        /// <p>A Boolean indicating whether to enable this port mapping on public IP.</p>
        pub fn set_enable_on_public_ip(mut self, input: std::option::Option<bool>) -> Self {
            self.enable_on_public_ip = input;
            self
        }
        /// Consumes the builder and constructs a [`PortMapping`](crate::model::PortMapping)
        pub fn build(self) -> crate::model::PortMapping {
            crate::model::PortMapping {
                job_port: self.job_port.unwrap_or_default(),
                application_port: self.application_port.unwrap_or_default(),
                enable_on_public_ip: self.enable_on_public_ip.unwrap_or_default(),
            }
        }
    }
}
impl PortMapping {
    /// Creates a new builder-style object to manufacture [`PortMapping`](crate::model::PortMapping)
    pub fn builder() -> crate::model::port_mapping::Builder {
        crate::model::port_mapping::Builder::default()
    }
}

/// <p>Application configuration information for a robot.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct RobotApplicationConfig {
    /// <p>The application information for the robot application.</p>
    pub application: std::option::Option<std::string::String>,
    /// <p>The version of the robot application.</p>
    pub application_version: std::option::Option<std::string::String>,
    /// <p>The launch configuration for the robot application.</p>
    pub launch_config: std::option::Option<crate::model::LaunchConfig>,
    /// <p>The upload configurations for the robot application.</p>
    pub upload_configurations:
        std::option::Option<std::vec::Vec<crate::model::UploadConfiguration>>,
    /// <p>A Boolean indicating whether to use default upload configurations. By default,
    /// <code>.ros</code> and <code>.gazebo</code> files are uploaded when the application
    /// terminates and all ROS topics will be recorded.</p>
    /// <p>If you set this value, you must specify an <code>outputLocation</code>. </p>
    pub use_default_upload_configurations: std::option::Option<bool>,
    /// <p>Information about tools configured for the robot application.</p>
    pub tools: std::option::Option<std::vec::Vec<crate::model::Tool>>,
    /// <p>A Boolean indicating whether to use default robot application tools. The default tools
    /// are rviz, rqt, terminal and rosbag record. The default is <code>False</code>. </p>
    pub use_default_tools: std::option::Option<bool>,
}
impl RobotApplicationConfig {
    /// <p>The application information for the robot application.</p>
    pub fn application(&self) -> std::option::Option<&str> {
        self.application.as_deref()
    }
    /// <p>The version of the robot application.</p>
    pub fn application_version(&self) -> std::option::Option<&str> {
        self.application_version.as_deref()
    }
    /// <p>The launch configuration for the robot application.</p>
    pub fn launch_config(&self) -> std::option::Option<&crate::model::LaunchConfig> {
        self.launch_config.as_ref()
    }
    /// <p>The upload configurations for the robot application.</p>
    pub fn upload_configurations(
        &self,
    ) -> std::option::Option<&[crate::model::UploadConfiguration]> {
        self.upload_configurations.as_deref()
    }
    /// <p>A Boolean indicating whether to use default upload configurations. By default,
    /// <code>.ros</code> and <code>.gazebo</code> files are uploaded when the application
    /// terminates and all ROS topics will be recorded.</p>
    /// <p>If you set this value, you must specify an <code>outputLocation</code>. </p>
    pub fn use_default_upload_configurations(&self) -> std::option::Option<bool> {
        self.use_default_upload_configurations
    }
    /// <p>Information about tools configured for the robot application.</p>
    pub fn tools(&self) -> std::option::Option<&[crate::model::Tool]> {
        self.tools.as_deref()
    }
    /// <p>A Boolean indicating whether to use default robot application tools. The default tools
    /// are rviz, rqt, terminal and rosbag record. The default is <code>False</code>. </p>
    pub fn use_default_tools(&self) -> std::option::Option<bool> {
        self.use_default_tools
    }
}
impl std::fmt::Debug for RobotApplicationConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("RobotApplicationConfig");
        formatter.field("application", &self.application);
        formatter.field("application_version", &self.application_version);
        formatter.field("launch_config", &self.launch_config);
        formatter.field("upload_configurations", &self.upload_configurations);
        formatter.field(
            "use_default_upload_configurations",
            &self.use_default_upload_configurations,
        );
        formatter.field("tools", &self.tools);
        formatter.field("use_default_tools", &self.use_default_tools);
        formatter.finish()
    }
}
/// See [`RobotApplicationConfig`](crate::model::RobotApplicationConfig)
pub mod robot_application_config {
    /// A builder for [`RobotApplicationConfig`](crate::model::RobotApplicationConfig)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) application: std::option::Option<std::string::String>,
        pub(crate) application_version: std::option::Option<std::string::String>,
        pub(crate) launch_config: std::option::Option<crate::model::LaunchConfig>,
        pub(crate) upload_configurations:
            std::option::Option<std::vec::Vec<crate::model::UploadConfiguration>>,
        pub(crate) use_default_upload_configurations: std::option::Option<bool>,
        pub(crate) tools: std::option::Option<std::vec::Vec<crate::model::Tool>>,
        pub(crate) use_default_tools: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>The application information for the robot application.</p>
        pub fn application(mut self, input: impl Into<std::string::String>) -> Self {
            self.application = Some(input.into());
            self
        }
        /// <p>The application information for the robot application.</p>
        pub fn set_application(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.application = input;
            self
        }
        /// <p>The version of the robot application.</p>
        pub fn application_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.application_version = Some(input.into());
            self
        }
        /// <p>The version of the robot application.</p>
        pub fn set_application_version(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.application_version = input;
            self
        }
        /// <p>The launch configuration for the robot application.</p>
        pub fn launch_config(mut self, input: crate::model::LaunchConfig) -> Self {
            self.launch_config = Some(input);
            self
        }
        /// <p>The launch configuration for the robot application.</p>
        pub fn set_launch_config(
            mut self,
            input: std::option::Option<crate::model::LaunchConfig>,
        ) -> Self {
            self.launch_config = input;
            self
        }
        /// Appends an item to `upload_configurations`.
        ///
        /// To override the contents of this collection use [`set_upload_configurations`](Self::set_upload_configurations).
        ///
        /// <p>The upload configurations for the robot application.</p>
        pub fn upload_configurations(
            mut self,
            input: impl Into<crate::model::UploadConfiguration>,
        ) -> Self {
            let mut v = self.upload_configurations.unwrap_or_default();
            v.push(input.into());
            self.upload_configurations = Some(v);
            self
        }
        /// <p>The upload configurations for the robot application.</p>
        pub fn set_upload_configurations(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::UploadConfiguration>>,
        ) -> Self {
            self.upload_configurations = input;
            self
        }
        /// <p>A Boolean indicating whether to use default upload configurations. By default,
        /// <code>.ros</code> and <code>.gazebo</code> files are uploaded when the application
        /// terminates and all ROS topics will be recorded.</p>
        /// <p>If you set this value, you must specify an <code>outputLocation</code>. </p>
        pub fn use_default_upload_configurations(mut self, input: bool) -> Self {
            self.use_default_upload_configurations = Some(input);
            self
        }
        /// <p>A Boolean indicating whether to use default upload configurations. By default,
        /// <code>.ros</code> and <code>.gazebo</code> files are uploaded when the application
        /// terminates and all ROS topics will be recorded.</p>
        /// <p>If you set this value, you must specify an <code>outputLocation</code>. </p>
        pub fn set_use_default_upload_configurations(
            mut self,
            input: std::option::Option<bool>,
        ) -> Self {
            self.use_default_upload_configurations = input;
            self
        }
        /// Appends an item to `tools`.
        ///
        /// To override the contents of this collection use [`set_tools`](Self::set_tools).
        ///
        /// <p>Information about tools configured for the robot application.</p>
        pub fn tools(mut self, input: impl Into<crate::model::Tool>) -> Self {
            let mut v = self.tools.unwrap_or_default();
            v.push(input.into());
            self.tools = Some(v);
            self
        }
        /// <p>Information about tools configured for the robot application.</p>
        pub fn set_tools(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tool>>,
        ) -> Self {
            self.tools = input;
            self
        }
        /// <p>A Boolean indicating whether to use default robot application tools. The default tools
        /// are rviz, rqt, terminal and rosbag record. The default is <code>False</code>. </p>
        pub fn use_default_tools(mut self, input: bool) -> Self {
            self.use_default_tools = Some(input);
            self
        }
        /// <p>A Boolean indicating whether to use default robot application tools. The default tools
        /// are rviz, rqt, terminal and rosbag record. The default is <code>False</code>. </p>
        pub fn set_use_default_tools(mut self, input: std::option::Option<bool>) -> Self {
            self.use_default_tools = input;
            self
        }
        /// Consumes the builder and constructs a [`RobotApplicationConfig`](crate::model::RobotApplicationConfig)
        pub fn build(self) -> crate::model::RobotApplicationConfig {
            crate::model::RobotApplicationConfig {
                application: self.application,
                application_version: self.application_version,
                launch_config: self.launch_config,
                upload_configurations: self.upload_configurations,
                use_default_upload_configurations: self.use_default_upload_configurations,
                tools: self.tools,
                use_default_tools: self.use_default_tools,
            }
        }
    }
}
impl RobotApplicationConfig {
    /// Creates a new builder-style object to manufacture [`RobotApplicationConfig`](crate::model::RobotApplicationConfig)
    pub fn builder() -> crate::model::robot_application_config::Builder {
        crate::model::robot_application_config::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum FailureBehavior {
    #[allow(missing_docs)] // documentation missing in model
    Continue,
    #[allow(missing_docs)] // documentation missing in model
    Fail,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for FailureBehavior {
    fn from(s: &str) -> Self {
        match s {
            "Continue" => FailureBehavior::Continue,
            "Fail" => FailureBehavior::Fail,
            other => FailureBehavior::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for FailureBehavior {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(FailureBehavior::from(s))
    }
}
impl FailureBehavior {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            FailureBehavior::Continue => "Continue",
            FailureBehavior::Fail => "Fail",
            FailureBehavior::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["Continue", "Fail"]
    }
}
impl AsRef<str> for FailureBehavior {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The logging configuration.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct LoggingConfig {
    /// <p>A boolean indicating whether to record all ROS topics.</p>
    pub record_all_ros_topics: std::option::Option<bool>,
}
impl LoggingConfig {
    /// <p>A boolean indicating whether to record all ROS topics.</p>
    pub fn record_all_ros_topics(&self) -> std::option::Option<bool> {
        self.record_all_ros_topics
    }
}
impl std::fmt::Debug for LoggingConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("LoggingConfig");
        formatter.field("record_all_ros_topics", &self.record_all_ros_topics);
        formatter.finish()
    }
}
/// See [`LoggingConfig`](crate::model::LoggingConfig)
pub mod logging_config {
    /// A builder for [`LoggingConfig`](crate::model::LoggingConfig)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) record_all_ros_topics: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>A boolean indicating whether to record all ROS topics.</p>
        pub fn record_all_ros_topics(mut self, input: bool) -> Self {
            self.record_all_ros_topics = Some(input);
            self
        }
        /// <p>A boolean indicating whether to record all ROS topics.</p>
        pub fn set_record_all_ros_topics(mut self, input: std::option::Option<bool>) -> Self {
            self.record_all_ros_topics = input;
            self
        }
        /// Consumes the builder and constructs a [`LoggingConfig`](crate::model::LoggingConfig)
        pub fn build(self) -> crate::model::LoggingConfig {
            crate::model::LoggingConfig {
                record_all_ros_topics: self.record_all_ros_topics,
            }
        }
    }
}
impl LoggingConfig {
    /// Creates a new builder-style object to manufacture [`LoggingConfig`](crate::model::LoggingConfig)
    pub fn builder() -> crate::model::logging_config::Builder {
        crate::model::logging_config::Builder::default()
    }
}

/// <p>The output location.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct OutputLocation {
    /// <p>The S3 bucket for output.</p>
    pub s3_bucket: std::option::Option<std::string::String>,
    /// <p>The S3 folder in the <code>s3Bucket</code> where output files will be placed.</p>
    pub s3_prefix: std::option::Option<std::string::String>,
}
impl OutputLocation {
    /// <p>The S3 bucket for output.</p>
    pub fn s3_bucket(&self) -> std::option::Option<&str> {
        self.s3_bucket.as_deref()
    }
    /// <p>The S3 folder in the <code>s3Bucket</code> where output files will be placed.</p>
    pub fn s3_prefix(&self) -> std::option::Option<&str> {
        self.s3_prefix.as_deref()
    }
}
impl std::fmt::Debug for OutputLocation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("OutputLocation");
        formatter.field("s3_bucket", &self.s3_bucket);
        formatter.field("s3_prefix", &self.s3_prefix);
        formatter.finish()
    }
}
/// See [`OutputLocation`](crate::model::OutputLocation)
pub mod output_location {
    /// A builder for [`OutputLocation`](crate::model::OutputLocation)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) s3_bucket: std::option::Option<std::string::String>,
        pub(crate) s3_prefix: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The S3 bucket for output.</p>
        pub fn s3_bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.s3_bucket = Some(input.into());
            self
        }
        /// <p>The S3 bucket for output.</p>
        pub fn set_s3_bucket(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.s3_bucket = input;
            self
        }
        /// <p>The S3 folder in the <code>s3Bucket</code> where output files will be placed.</p>
        pub fn s3_prefix(mut self, input: impl Into<std::string::String>) -> Self {
            self.s3_prefix = Some(input.into());
            self
        }
        /// <p>The S3 folder in the <code>s3Bucket</code> where output files will be placed.</p>
        pub fn set_s3_prefix(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.s3_prefix = input;
            self
        }
        /// Consumes the builder and constructs a [`OutputLocation`](crate::model::OutputLocation)
        pub fn build(self) -> crate::model::OutputLocation {
            crate::model::OutputLocation {
                s3_bucket: self.s3_bucket,
                s3_prefix: self.s3_prefix,
            }
        }
    }
}
impl OutputLocation {
    /// Creates a new builder-style object to manufacture [`OutputLocation`](crate::model::OutputLocation)
    pub fn builder() -> crate::model::output_location::Builder {
        crate::model::output_location::Builder::default()
    }
}

/// <p>Information about a failed create simulation job request.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct FailedCreateSimulationJobRequest {
    /// <p>The simulation job request.</p>
    pub request: std::option::Option<crate::model::SimulationJobRequest>,
    /// <p>The failure reason of the simulation job request.</p>
    pub failure_reason: std::option::Option<std::string::String>,
    /// <p>The failure code.</p>
    pub failure_code: std::option::Option<crate::model::SimulationJobErrorCode>,
    /// <p>The time, in milliseconds since the epoch, when the simulation job batch failed.</p>
    pub failed_at: std::option::Option<aws_smithy_types::Instant>,
}
impl FailedCreateSimulationJobRequest {
    /// <p>The simulation job request.</p>
    pub fn request(&self) -> std::option::Option<&crate::model::SimulationJobRequest> {
        self.request.as_ref()
    }
    /// <p>The failure reason of the simulation job request.</p>
    pub fn failure_reason(&self) -> std::option::Option<&str> {
        self.failure_reason.as_deref()
    }
    /// <p>The failure code.</p>
    pub fn failure_code(&self) -> std::option::Option<&crate::model::SimulationJobErrorCode> {
        self.failure_code.as_ref()
    }
    /// <p>The time, in milliseconds since the epoch, when the simulation job batch failed.</p>
    pub fn failed_at(&self) -> std::option::Option<&aws_smithy_types::Instant> {
        self.failed_at.as_ref()
    }
}
impl std::fmt::Debug for FailedCreateSimulationJobRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("FailedCreateSimulationJobRequest");
        formatter.field("request", &self.request);
        formatter.field("failure_reason", &self.failure_reason);
        formatter.field("failure_code", &self.failure_code);
        formatter.field("failed_at", &self.failed_at);
        formatter.finish()
    }
}
/// See [`FailedCreateSimulationJobRequest`](crate::model::FailedCreateSimulationJobRequest)
pub mod failed_create_simulation_job_request {
    /// A builder for [`FailedCreateSimulationJobRequest`](crate::model::FailedCreateSimulationJobRequest)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) request: std::option::Option<crate::model::SimulationJobRequest>,
        pub(crate) failure_reason: std::option::Option<std::string::String>,
        pub(crate) failure_code: std::option::Option<crate::model::SimulationJobErrorCode>,
        pub(crate) failed_at: std::option::Option<aws_smithy_types::Instant>,
    }
    impl Builder {
        /// <p>The simulation job request.</p>
        pub fn request(mut self, input: crate::model::SimulationJobRequest) -> Self {
            self.request = Some(input);
            self
        }
        /// <p>The simulation job request.</p>
        pub fn set_request(
            mut self,
            input: std::option::Option<crate::model::SimulationJobRequest>,
        ) -> Self {
            self.request = input;
            self
        }
        /// <p>The failure reason of the simulation job request.</p>
        pub fn failure_reason(mut self, input: impl Into<std::string::String>) -> Self {
            self.failure_reason = Some(input.into());
            self
        }
        /// <p>The failure reason of the simulation job request.</p>
        pub fn set_failure_reason(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.failure_reason = input;
            self
        }
        /// <p>The failure code.</p>
        pub fn failure_code(mut self, input: crate::model::SimulationJobErrorCode) -> Self {
            self.failure_code = Some(input);
            self
        }
        /// <p>The failure code.</p>
        pub fn set_failure_code(
            mut self,
            input: std::option::Option<crate::model::SimulationJobErrorCode>,
        ) -> Self {
            self.failure_code = input;
            self
        }
        /// <p>The time, in milliseconds since the epoch, when the simulation job batch failed.</p>
        pub fn failed_at(mut self, input: aws_smithy_types::Instant) -> Self {
            self.failed_at = Some(input);
            self
        }
        /// <p>The time, in milliseconds since the epoch, when the simulation job batch failed.</p>
        pub fn set_failed_at(
            mut self,
            input: std::option::Option<aws_smithy_types::Instant>,
        ) -> Self {
            self.failed_at = input;
            self
        }
        /// Consumes the builder and constructs a [`FailedCreateSimulationJobRequest`](crate::model::FailedCreateSimulationJobRequest)
        pub fn build(self) -> crate::model::FailedCreateSimulationJobRequest {
            crate::model::FailedCreateSimulationJobRequest {
                request: self.request,
                failure_reason: self.failure_reason,
                failure_code: self.failure_code,
                failed_at: self.failed_at,
            }
        }
    }
}
impl FailedCreateSimulationJobRequest {
    /// Creates a new builder-style object to manufacture [`FailedCreateSimulationJobRequest`](crate::model::FailedCreateSimulationJobRequest)
    pub fn builder() -> crate::model::failed_create_simulation_job_request::Builder {
        crate::model::failed_create_simulation_job_request::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum SimulationJobErrorCode {
    #[allow(missing_docs)] // documentation missing in model
    BadPermissionsCloudwatchLogs,
    #[allow(missing_docs)] // documentation missing in model
    BadPermissionsRobotApplication,
    #[allow(missing_docs)] // documentation missing in model
    BadPermissionsS3Object,
    #[allow(missing_docs)] // documentation missing in model
    BadPermissionsS3Output,
    #[allow(missing_docs)] // documentation missing in model
    BadPermissionsSimulationApplication,
    #[allow(missing_docs)] // documentation missing in model
    BadPermissionsUserCredentials,
    #[allow(missing_docs)] // documentation missing in model
    BatchCanceled,
    #[allow(missing_docs)] // documentation missing in model
    BatchTimedOut,
    #[allow(missing_docs)] // documentation missing in model
    EniLimitExceeded,
    #[allow(missing_docs)] // documentation missing in model
    InternalServiceError,
    #[allow(missing_docs)] // documentation missing in model
    InvalidBundleRobotApplication,
    #[allow(missing_docs)] // documentation missing in model
    InvalidBundleSimulationApplication,
    #[allow(missing_docs)] // documentation missing in model
    InvalidInput,
    #[allow(missing_docs)] // documentation missing in model
    InvalidS3Resource,
    #[allow(missing_docs)] // documentation missing in model
    LimitExceeded,
    #[allow(missing_docs)] // documentation missing in model
    MismatchedEtag,
    #[allow(missing_docs)] // documentation missing in model
    RequestThrottled,
    #[allow(missing_docs)] // documentation missing in model
    ResourceNotFound,
    #[allow(missing_docs)] // documentation missing in model
    RobotApplicationCrash,
    #[allow(missing_docs)] // documentation missing in model
    RobotApplicationHealthCheckFailure,
    #[allow(missing_docs)] // documentation missing in model
    RobotApplicationVersionMismatchedEtag,
    #[allow(missing_docs)] // documentation missing in model
    SimulationApplicationCrash,
    #[allow(missing_docs)] // documentation missing in model
    SimulationApplicationHealthCheckFailure,
    #[allow(missing_docs)] // documentation missing in model
    SimulationApplicationVersionMismatchedEtag,
    #[allow(missing_docs)] // documentation missing in model
    SubnetIpLimitExceeded,
    #[allow(missing_docs)] // documentation missing in model
    ThrottlingError,
    #[allow(missing_docs)] // documentation missing in model
    UploadContentMismatchError,
    #[allow(missing_docs)] // documentation missing in model
    WrongRegionRobotApplication,
    #[allow(missing_docs)] // documentation missing in model
    WrongRegionS3Bucket,
    #[allow(missing_docs)] // documentation missing in model
    WrongRegionS3Output,
    #[allow(missing_docs)] // documentation missing in model
    WrongRegionSimulationApplication,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for SimulationJobErrorCode {
    fn from(s: &str) -> Self {
        match s {
            "BadPermissionsCloudwatchLogs" => SimulationJobErrorCode::BadPermissionsCloudwatchLogs,
            "BadPermissionsRobotApplication" => {
                SimulationJobErrorCode::BadPermissionsRobotApplication
            }
            "BadPermissionsS3Object" => SimulationJobErrorCode::BadPermissionsS3Object,
            "BadPermissionsS3Output" => SimulationJobErrorCode::BadPermissionsS3Output,
            "BadPermissionsSimulationApplication" => {
                SimulationJobErrorCode::BadPermissionsSimulationApplication
            }
            "BadPermissionsUserCredentials" => {
                SimulationJobErrorCode::BadPermissionsUserCredentials
            }
            "BatchCanceled" => SimulationJobErrorCode::BatchCanceled,
            "BatchTimedOut" => SimulationJobErrorCode::BatchTimedOut,
            "ENILimitExceeded" => SimulationJobErrorCode::EniLimitExceeded,
            "InternalServiceError" => SimulationJobErrorCode::InternalServiceError,
            "InvalidBundleRobotApplication" => {
                SimulationJobErrorCode::InvalidBundleRobotApplication
            }
            "InvalidBundleSimulationApplication" => {
                SimulationJobErrorCode::InvalidBundleSimulationApplication
            }
            "InvalidInput" => SimulationJobErrorCode::InvalidInput,
            "InvalidS3Resource" => SimulationJobErrorCode::InvalidS3Resource,
            "LimitExceeded" => SimulationJobErrorCode::LimitExceeded,
            "MismatchedEtag" => SimulationJobErrorCode::MismatchedEtag,
            "RequestThrottled" => SimulationJobErrorCode::RequestThrottled,
            "ResourceNotFound" => SimulationJobErrorCode::ResourceNotFound,
            "RobotApplicationCrash" => SimulationJobErrorCode::RobotApplicationCrash,
            "RobotApplicationHealthCheckFailure" => {
                SimulationJobErrorCode::RobotApplicationHealthCheckFailure
            }
            "RobotApplicationVersionMismatchedEtag" => {
                SimulationJobErrorCode::RobotApplicationVersionMismatchedEtag
            }
            "SimulationApplicationCrash" => SimulationJobErrorCode::SimulationApplicationCrash,
            "SimulationApplicationHealthCheckFailure" => {
                SimulationJobErrorCode::SimulationApplicationHealthCheckFailure
            }
            "SimulationApplicationVersionMismatchedEtag" => {
                SimulationJobErrorCode::SimulationApplicationVersionMismatchedEtag
            }
            "SubnetIpLimitExceeded" => SimulationJobErrorCode::SubnetIpLimitExceeded,
            "ThrottlingError" => SimulationJobErrorCode::ThrottlingError,
            "UploadContentMismatchError" => SimulationJobErrorCode::UploadContentMismatchError,
            "WrongRegionRobotApplication" => SimulationJobErrorCode::WrongRegionRobotApplication,
            "WrongRegionS3Bucket" => SimulationJobErrorCode::WrongRegionS3Bucket,
            "WrongRegionS3Output" => SimulationJobErrorCode::WrongRegionS3Output,
            "WrongRegionSimulationApplication" => {
                SimulationJobErrorCode::WrongRegionSimulationApplication
            }
            other => SimulationJobErrorCode::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for SimulationJobErrorCode {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(SimulationJobErrorCode::from(s))
    }
}
impl SimulationJobErrorCode {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            SimulationJobErrorCode::BadPermissionsCloudwatchLogs => "BadPermissionsCloudwatchLogs",
            SimulationJobErrorCode::BadPermissionsRobotApplication => {
                "BadPermissionsRobotApplication"
            }
            SimulationJobErrorCode::BadPermissionsS3Object => "BadPermissionsS3Object",
            SimulationJobErrorCode::BadPermissionsS3Output => "BadPermissionsS3Output",
            SimulationJobErrorCode::BadPermissionsSimulationApplication => {
                "BadPermissionsSimulationApplication"
            }
            SimulationJobErrorCode::BadPermissionsUserCredentials => {
                "BadPermissionsUserCredentials"
            }
            SimulationJobErrorCode::BatchCanceled => "BatchCanceled",
            SimulationJobErrorCode::BatchTimedOut => "BatchTimedOut",
            SimulationJobErrorCode::EniLimitExceeded => "ENILimitExceeded",
            SimulationJobErrorCode::InternalServiceError => "InternalServiceError",
            SimulationJobErrorCode::InvalidBundleRobotApplication => {
                "InvalidBundleRobotApplication"
            }
            SimulationJobErrorCode::InvalidBundleSimulationApplication => {
                "InvalidBundleSimulationApplication"
            }
            SimulationJobErrorCode::InvalidInput => "InvalidInput",
            SimulationJobErrorCode::InvalidS3Resource => "InvalidS3Resource",
            SimulationJobErrorCode::LimitExceeded => "LimitExceeded",
            SimulationJobErrorCode::MismatchedEtag => "MismatchedEtag",
            SimulationJobErrorCode::RequestThrottled => "RequestThrottled",
            SimulationJobErrorCode::ResourceNotFound => "ResourceNotFound",
            SimulationJobErrorCode::RobotApplicationCrash => "RobotApplicationCrash",
            SimulationJobErrorCode::RobotApplicationHealthCheckFailure => {
                "RobotApplicationHealthCheckFailure"
            }
            SimulationJobErrorCode::RobotApplicationVersionMismatchedEtag => {
                "RobotApplicationVersionMismatchedEtag"
            }
            SimulationJobErrorCode::SimulationApplicationCrash => "SimulationApplicationCrash",
            SimulationJobErrorCode::SimulationApplicationHealthCheckFailure => {
                "SimulationApplicationHealthCheckFailure"
            }
            SimulationJobErrorCode::SimulationApplicationVersionMismatchedEtag => {
                "SimulationApplicationVersionMismatchedEtag"
            }
            SimulationJobErrorCode::SubnetIpLimitExceeded => "SubnetIpLimitExceeded",
            SimulationJobErrorCode::ThrottlingError => "ThrottlingError",
            SimulationJobErrorCode::UploadContentMismatchError => "UploadContentMismatchError",
            SimulationJobErrorCode::WrongRegionRobotApplication => "WrongRegionRobotApplication",
            SimulationJobErrorCode::WrongRegionS3Bucket => "WrongRegionS3Bucket",
            SimulationJobErrorCode::WrongRegionS3Output => "WrongRegionS3Output",
            SimulationJobErrorCode::WrongRegionSimulationApplication => {
                "WrongRegionSimulationApplication"
            }
            SimulationJobErrorCode::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &[
            "BadPermissionsCloudwatchLogs",
            "BadPermissionsRobotApplication",
            "BadPermissionsS3Object",
            "BadPermissionsS3Output",
            "BadPermissionsSimulationApplication",
            "BadPermissionsUserCredentials",
            "BatchCanceled",
            "BatchTimedOut",
            "ENILimitExceeded",
            "InternalServiceError",
            "InvalidBundleRobotApplication",
            "InvalidBundleSimulationApplication",
            "InvalidInput",
            "InvalidS3Resource",
            "LimitExceeded",
            "MismatchedEtag",
            "RequestThrottled",
            "ResourceNotFound",
            "RobotApplicationCrash",
            "RobotApplicationHealthCheckFailure",
            "RobotApplicationVersionMismatchedEtag",
            "SimulationApplicationCrash",
            "SimulationApplicationHealthCheckFailure",
            "SimulationApplicationVersionMismatchedEtag",
            "SubnetIpLimitExceeded",
            "ThrottlingError",
            "UploadContentMismatchError",
            "WrongRegionRobotApplication",
            "WrongRegionS3Bucket",
            "WrongRegionS3Output",
            "WrongRegionSimulationApplication",
        ]
    }
}
impl AsRef<str> for SimulationJobErrorCode {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum SimulationJobBatchErrorCode {
    #[allow(missing_docs)] // documentation missing in model
    InternalServiceError,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for SimulationJobBatchErrorCode {
    fn from(s: &str) -> Self {
        match s {
            "InternalServiceError" => SimulationJobBatchErrorCode::InternalServiceError,
            other => SimulationJobBatchErrorCode::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for SimulationJobBatchErrorCode {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(SimulationJobBatchErrorCode::from(s))
    }
}
impl SimulationJobBatchErrorCode {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            SimulationJobBatchErrorCode::InternalServiceError => "InternalServiceError",
            SimulationJobBatchErrorCode::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["InternalServiceError"]
    }
}
impl AsRef<str> for SimulationJobBatchErrorCode {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Information about the batch policy.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct BatchPolicy {
    /// <p>The amount of time, in seconds, to wait for the batch to complete.
    ///
    /// </p>
    /// <p>If a batch times out, and there are pending requests that were failing due to an
    /// internal failure (like <code>InternalServiceError</code>), they will be moved to the failed
    /// list and the batch status will be <code>Failed</code>. If the pending requests were failing
    /// for any other reason, the failed pending requests will be moved to the failed list and the
    /// batch status will be <code>TimedOut</code>. </p>
    pub timeout_in_seconds: std::option::Option<i64>,
    /// <p>The number of active simulation jobs create as part of the batch that can be in an
    /// active state at the same time. </p>
    /// <p>Active states include: <code>Pending</code>,<code>Preparing</code>,
    /// <code>Running</code>, <code>Restarting</code>, <code>RunningFailed</code> and
    /// <code>Terminating</code>. All other states are terminal states. </p>
    pub max_concurrency: std::option::Option<i32>,
}
impl BatchPolicy {
    /// <p>The amount of time, in seconds, to wait for the batch to complete.
    ///
    /// </p>
    /// <p>If a batch times out, and there are pending requests that were failing due to an
    /// internal failure (like <code>InternalServiceError</code>), they will be moved to the failed
    /// list and the batch status will be <code>Failed</code>. If the pending requests were failing
    /// for any other reason, the failed pending requests will be moved to the failed list and the
    /// batch status will be <code>TimedOut</code>. </p>
    pub fn timeout_in_seconds(&self) -> std::option::Option<i64> {
        self.timeout_in_seconds
    }
    /// <p>The number of active simulation jobs create as part of the batch that can be in an
    /// active state at the same time. </p>
    /// <p>Active states include: <code>Pending</code>,<code>Preparing</code>,
    /// <code>Running</code>, <code>Restarting</code>, <code>RunningFailed</code> and
    /// <code>Terminating</code>. All other states are terminal states. </p>
    pub fn max_concurrency(&self) -> std::option::Option<i32> {
        self.max_concurrency
    }
}
impl std::fmt::Debug for BatchPolicy {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("BatchPolicy");
        formatter.field("timeout_in_seconds", &self.timeout_in_seconds);
        formatter.field("max_concurrency", &self.max_concurrency);
        formatter.finish()
    }
}
/// See [`BatchPolicy`](crate::model::BatchPolicy)
pub mod batch_policy {
    /// A builder for [`BatchPolicy`](crate::model::BatchPolicy)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) timeout_in_seconds: std::option::Option<i64>,
        pub(crate) max_concurrency: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The amount of time, in seconds, to wait for the batch to complete.
        ///
        /// </p>
        /// <p>If a batch times out, and there are pending requests that were failing due to an
        /// internal failure (like <code>InternalServiceError</code>), they will be moved to the failed
        /// list and the batch status will be <code>Failed</code>. If the pending requests were failing
        /// for any other reason, the failed pending requests will be moved to the failed list and the
        /// batch status will be <code>TimedOut</code>. </p>
        pub fn timeout_in_seconds(mut self, input: i64) -> Self {
            self.timeout_in_seconds = Some(input);
            self
        }
        /// <p>The amount of time, in seconds, to wait for the batch to complete.
        ///
        /// </p>
        /// <p>If a batch times out, and there are pending requests that were failing due to an
        /// internal failure (like <code>InternalServiceError</code>), they will be moved to the failed
        /// list and the batch status will be <code>Failed</code>. If the pending requests were failing
        /// for any other reason, the failed pending requests will be moved to the failed list and the
        /// batch status will be <code>TimedOut</code>. </p>
        pub fn set_timeout_in_seconds(mut self, input: std::option::Option<i64>) -> Self {
            self.timeout_in_seconds = input;
            self
        }
        /// <p>The number of active simulation jobs create as part of the batch that can be in an
        /// active state at the same time. </p>
        /// <p>Active states include: <code>Pending</code>,<code>Preparing</code>,
        /// <code>Running</code>, <code>Restarting</code>, <code>RunningFailed</code> and
        /// <code>Terminating</code>. All other states are terminal states. </p>
        pub fn max_concurrency(mut self, input: i32) -> Self {
            self.max_concurrency = Some(input);
            self
        }
        /// <p>The number of active simulation jobs create as part of the batch that can be in an
        /// active state at the same time. </p>
        /// <p>Active states include: <code>Pending</code>,<code>Preparing</code>,
        /// <code>Running</code>, <code>Restarting</code>, <code>RunningFailed</code> and
        /// <code>Terminating</code>. All other states are terminal states. </p>
        pub fn set_max_concurrency(mut self, input: std::option::Option<i32>) -> Self {
            self.max_concurrency = input;
            self
        }
        /// Consumes the builder and constructs a [`BatchPolicy`](crate::model::BatchPolicy)
        pub fn build(self) -> crate::model::BatchPolicy {
            crate::model::BatchPolicy {
                timeout_in_seconds: self.timeout_in_seconds,
                max_concurrency: self.max_concurrency,
            }
        }
    }
}
impl BatchPolicy {
    /// Creates a new builder-style object to manufacture [`BatchPolicy`](crate::model::BatchPolicy)
    pub fn builder() -> crate::model::batch_policy::Builder {
        crate::model::batch_policy::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum SimulationJobBatchStatus {
    #[allow(missing_docs)] // documentation missing in model
    Canceled,
    #[allow(missing_docs)] // documentation missing in model
    Canceling,
    #[allow(missing_docs)] // documentation missing in model
    Completed,
    #[allow(missing_docs)] // documentation missing in model
    Completing,
    #[allow(missing_docs)] // documentation missing in model
    Failed,
    #[allow(missing_docs)] // documentation missing in model
    InProgress,
    #[allow(missing_docs)] // documentation missing in model
    Pending,
    #[allow(missing_docs)] // documentation missing in model
    TimedOut,
    #[allow(missing_docs)] // documentation missing in model
    TimingOut,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for SimulationJobBatchStatus {
    fn from(s: &str) -> Self {
        match s {
            "Canceled" => SimulationJobBatchStatus::Canceled,
            "Canceling" => SimulationJobBatchStatus::Canceling,
            "Completed" => SimulationJobBatchStatus::Completed,
            "Completing" => SimulationJobBatchStatus::Completing,
            "Failed" => SimulationJobBatchStatus::Failed,
            "InProgress" => SimulationJobBatchStatus::InProgress,
            "Pending" => SimulationJobBatchStatus::Pending,
            "TimedOut" => SimulationJobBatchStatus::TimedOut,
            "TimingOut" => SimulationJobBatchStatus::TimingOut,
            other => SimulationJobBatchStatus::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for SimulationJobBatchStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(SimulationJobBatchStatus::from(s))
    }
}
impl SimulationJobBatchStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            SimulationJobBatchStatus::Canceled => "Canceled",
            SimulationJobBatchStatus::Canceling => "Canceling",
            SimulationJobBatchStatus::Completed => "Completed",
            SimulationJobBatchStatus::Completing => "Completing",
            SimulationJobBatchStatus::Failed => "Failed",
            SimulationJobBatchStatus::InProgress => "InProgress",
            SimulationJobBatchStatus::Pending => "Pending",
            SimulationJobBatchStatus::TimedOut => "TimedOut",
            SimulationJobBatchStatus::TimingOut => "TimingOut",
            SimulationJobBatchStatus::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &[
            "Canceled",
            "Canceling",
            "Completed",
            "Completing",
            "Failed",
            "InProgress",
            "Pending",
            "TimedOut",
            "TimingOut",
        ]
    }
}
impl AsRef<str> for SimulationJobBatchStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Summary information for a template.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TemplateSummary {
    /// <p>The Amazon Resource Name (ARN) of the template.</p>
    pub arn: std::option::Option<std::string::String>,
    /// <p>The time, in milliseconds since the epoch, when the template was created.</p>
    pub created_at: std::option::Option<aws_smithy_types::Instant>,
    /// <p>The time, in milliseconds since the epoch, when the template was last updated.</p>
    pub last_updated_at: std::option::Option<aws_smithy_types::Instant>,
    /// <p>The name of the template.</p>
    pub name: std::option::Option<std::string::String>,
    /// <p>The version of the template that you're using.</p>
    pub version: std::option::Option<std::string::String>,
}
impl TemplateSummary {
    /// <p>The Amazon Resource Name (ARN) of the template.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>The time, in milliseconds since the epoch, when the template was created.</p>
    pub fn created_at(&self) -> std::option::Option<&aws_smithy_types::Instant> {
        self.created_at.as_ref()
    }
    /// <p>The time, in milliseconds since the epoch, when the template was last updated.</p>
    pub fn last_updated_at(&self) -> std::option::Option<&aws_smithy_types::Instant> {
        self.last_updated_at.as_ref()
    }
    /// <p>The name of the template.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The version of the template that you're using.</p>
    pub fn version(&self) -> std::option::Option<&str> {
        self.version.as_deref()
    }
}
impl std::fmt::Debug for TemplateSummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TemplateSummary");
        formatter.field("arn", &self.arn);
        formatter.field("created_at", &self.created_at);
        formatter.field("last_updated_at", &self.last_updated_at);
        formatter.field("name", &self.name);
        formatter.field("version", &self.version);
        formatter.finish()
    }
}
/// See [`TemplateSummary`](crate::model::TemplateSummary)
pub mod template_summary {
    /// A builder for [`TemplateSummary`](crate::model::TemplateSummary)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) created_at: std::option::Option<aws_smithy_types::Instant>,
        pub(crate) last_updated_at: std::option::Option<aws_smithy_types::Instant>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) version: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the template.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the template.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>The time, in milliseconds since the epoch, when the template was created.</p>
        pub fn created_at(mut self, input: aws_smithy_types::Instant) -> Self {
            self.created_at = Some(input);
            self
        }
        /// <p>The time, in milliseconds since the epoch, when the template was created.</p>
        pub fn set_created_at(
            mut self,
            input: std::option::Option<aws_smithy_types::Instant>,
        ) -> Self {
            self.created_at = input;
            self
        }
        /// <p>The time, in milliseconds since the epoch, when the template was last updated.</p>
        pub fn last_updated_at(mut self, input: aws_smithy_types::Instant) -> Self {
            self.last_updated_at = Some(input);
            self
        }
        /// <p>The time, in milliseconds since the epoch, when the template was last updated.</p>
        pub fn set_last_updated_at(
            mut self,
            input: std::option::Option<aws_smithy_types::Instant>,
        ) -> Self {
            self.last_updated_at = input;
            self
        }
        /// <p>The name of the template.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the template.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The version of the template that you're using.</p>
        pub fn version(mut self, input: impl Into<std::string::String>) -> Self {
            self.version = Some(input.into());
            self
        }
        /// <p>The version of the template that you're using.</p>
        pub fn set_version(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.version = input;
            self
        }
        /// Consumes the builder and constructs a [`TemplateSummary`](crate::model::TemplateSummary)
        pub fn build(self) -> crate::model::TemplateSummary {
            crate::model::TemplateSummary {
                arn: self.arn,
                created_at: self.created_at,
                last_updated_at: self.last_updated_at,
                name: self.name,
                version: self.version,
            }
        }
    }
}
impl TemplateSummary {
    /// Creates a new builder-style object to manufacture [`TemplateSummary`](crate::model::TemplateSummary)
    pub fn builder() -> crate::model::template_summary::Builder {
        crate::model::template_summary::Builder::default()
    }
}

/// <p>Information about a world.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct WorldSummary {
    /// <p>The Amazon Resource Name (ARN) of the world.</p>
    pub arn: std::option::Option<std::string::String>,
    /// <p>The time, in milliseconds since the epoch, when the world was created.</p>
    pub created_at: std::option::Option<aws_smithy_types::Instant>,
    /// <p>The Amazon Resource Name (arn) of the world generation job.</p>
    pub generation_job: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (arn) of the world template.</p>
    pub template: std::option::Option<std::string::String>,
}
impl WorldSummary {
    /// <p>The Amazon Resource Name (ARN) of the world.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>The time, in milliseconds since the epoch, when the world was created.</p>
    pub fn created_at(&self) -> std::option::Option<&aws_smithy_types::Instant> {
        self.created_at.as_ref()
    }
    /// <p>The Amazon Resource Name (arn) of the world generation job.</p>
    pub fn generation_job(&self) -> std::option::Option<&str> {
        self.generation_job.as_deref()
    }
    /// <p>The Amazon Resource Name (arn) of the world template.</p>
    pub fn template(&self) -> std::option::Option<&str> {
        self.template.as_deref()
    }
}
impl std::fmt::Debug for WorldSummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("WorldSummary");
        formatter.field("arn", &self.arn);
        formatter.field("created_at", &self.created_at);
        formatter.field("generation_job", &self.generation_job);
        formatter.field("template", &self.template);
        formatter.finish()
    }
}
/// See [`WorldSummary`](crate::model::WorldSummary)
pub mod world_summary {
    /// A builder for [`WorldSummary`](crate::model::WorldSummary)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) created_at: std::option::Option<aws_smithy_types::Instant>,
        pub(crate) generation_job: std::option::Option<std::string::String>,
        pub(crate) template: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the world.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the world.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>The time, in milliseconds since the epoch, when the world was created.</p>
        pub fn created_at(mut self, input: aws_smithy_types::Instant) -> Self {
            self.created_at = Some(input);
            self
        }
        /// <p>The time, in milliseconds since the epoch, when the world was created.</p>
        pub fn set_created_at(
            mut self,
            input: std::option::Option<aws_smithy_types::Instant>,
        ) -> Self {
            self.created_at = input;
            self
        }
        /// <p>The Amazon Resource Name (arn) of the world generation job.</p>
        pub fn generation_job(mut self, input: impl Into<std::string::String>) -> Self {
            self.generation_job = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (arn) of the world generation job.</p>
        pub fn set_generation_job(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.generation_job = input;
            self
        }
        /// <p>The Amazon Resource Name (arn) of the world template.</p>
        pub fn template(mut self, input: impl Into<std::string::String>) -> Self {
            self.template = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (arn) of the world template.</p>
        pub fn set_template(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.template = input;
            self
        }
        /// Consumes the builder and constructs a [`WorldSummary`](crate::model::WorldSummary)
        pub fn build(self) -> crate::model::WorldSummary {
            crate::model::WorldSummary {
                arn: self.arn,
                created_at: self.created_at,
                generation_job: self.generation_job,
                template: self.template,
            }
        }
    }
}
impl WorldSummary {
    /// Creates a new builder-style object to manufacture [`WorldSummary`](crate::model::WorldSummary)
    pub fn builder() -> crate::model::world_summary::Builder {
        crate::model::world_summary::Builder::default()
    }
}

/// <p>Information about a filter.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Filter {
    /// <p>The name of the filter.</p>
    pub name: std::option::Option<std::string::String>,
    /// <p>A list of values.</p>
    pub values: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl Filter {
    /// <p>The name of the filter.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>A list of values.</p>
    pub fn values(&self) -> std::option::Option<&[std::string::String]> {
        self.values.as_deref()
    }
}
impl std::fmt::Debug for Filter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Filter");
        formatter.field("name", &self.name);
        formatter.field("values", &self.values);
        formatter.finish()
    }
}
/// See [`Filter`](crate::model::Filter)
pub mod filter {
    /// A builder for [`Filter`](crate::model::Filter)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) values: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// <p>The name of the filter.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the filter.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// Appends an item to `values`.
        ///
        /// To override the contents of this collection use [`set_values`](Self::set_values).
        ///
        /// <p>A list of values.</p>
        pub fn values(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.values.unwrap_or_default();
            v.push(input.into());
            self.values = Some(v);
            self
        }
        /// <p>A list of values.</p>
        pub fn set_values(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.values = input;
            self
        }
        /// Consumes the builder and constructs a [`Filter`](crate::model::Filter)
        pub fn build(self) -> crate::model::Filter {
            crate::model::Filter {
                name: self.name,
                values: self.values,
            }
        }
    }
}
impl Filter {
    /// Creates a new builder-style object to manufacture [`Filter`](crate::model::Filter)
    pub fn builder() -> crate::model::filter::Builder {
        crate::model::filter::Builder::default()
    }
}

/// <p>Information about a world generator job.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct WorldGenerationJobSummary {
    /// <p>The Amazon Resource Name (ARN) of the world generator job.</p>
    pub arn: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (arn) of the world template.</p>
    pub template: std::option::Option<std::string::String>,
    /// <p>The time, in milliseconds since the epoch, when the world generator job was
    /// created.</p>
    pub created_at: std::option::Option<aws_smithy_types::Instant>,
    /// <p>The status of the world generator job:</p>
    /// <dl>
    /// <dt>Pending</dt>
    /// <dd>
    /// <p>The world generator job request is pending.</p>
    /// </dd>
    /// <dt>Running</dt>
    /// <dd>
    /// <p>The world generator job is running. </p>
    /// </dd>
    /// <dt>Completed</dt>
    /// <dd>
    /// <p>The world generator job completed. </p>
    /// </dd>
    /// <dt>Failed</dt>
    /// <dd>
    /// <p>The world generator job failed. See <code>failureCode</code> for more
    /// information. </p>
    /// </dd>
    /// <dt>PartialFailed</dt>
    /// <dd>
    /// <p>Some worlds did not generate.</p>
    /// </dd>
    /// <dt>Canceled</dt>
    /// <dd>
    /// <p>The world generator job was cancelled.</p>
    /// </dd>
    /// <dt>Canceling</dt>
    /// <dd>
    /// <p>The world generator job is being cancelled.</p>
    /// </dd>
    /// </dl>
    pub status: std::option::Option<crate::model::WorldGenerationJobStatus>,
    /// <p>Information about the world count.</p>
    pub world_count: std::option::Option<crate::model::WorldCount>,
    /// <p>The number of worlds that were generated.</p>
    pub succeeded_world_count: i32,
    /// <p>The number of worlds that failed.</p>
    pub failed_world_count: i32,
}
impl WorldGenerationJobSummary {
    /// <p>The Amazon Resource Name (ARN) of the world generator job.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>The Amazon Resource Name (arn) of the world template.</p>
    pub fn template(&self) -> std::option::Option<&str> {
        self.template.as_deref()
    }
    /// <p>The time, in milliseconds since the epoch, when the world generator job was
    /// created.</p>
    pub fn created_at(&self) -> std::option::Option<&aws_smithy_types::Instant> {
        self.created_at.as_ref()
    }
    /// <p>The status of the world generator job:</p>
    /// <dl>
    /// <dt>Pending</dt>
    /// <dd>
    /// <p>The world generator job request is pending.</p>
    /// </dd>
    /// <dt>Running</dt>
    /// <dd>
    /// <p>The world generator job is running. </p>
    /// </dd>
    /// <dt>Completed</dt>
    /// <dd>
    /// <p>The world generator job completed. </p>
    /// </dd>
    /// <dt>Failed</dt>
    /// <dd>
    /// <p>The world generator job failed. See <code>failureCode</code> for more
    /// information. </p>
    /// </dd>
    /// <dt>PartialFailed</dt>
    /// <dd>
    /// <p>Some worlds did not generate.</p>
    /// </dd>
    /// <dt>Canceled</dt>
    /// <dd>
    /// <p>The world generator job was cancelled.</p>
    /// </dd>
    /// <dt>Canceling</dt>
    /// <dd>
    /// <p>The world generator job is being cancelled.</p>
    /// </dd>
    /// </dl>
    pub fn status(&self) -> std::option::Option<&crate::model::WorldGenerationJobStatus> {
        self.status.as_ref()
    }
    /// <p>Information about the world count.</p>
    pub fn world_count(&self) -> std::option::Option<&crate::model::WorldCount> {
        self.world_count.as_ref()
    }
    /// <p>The number of worlds that were generated.</p>
    pub fn succeeded_world_count(&self) -> i32 {
        self.succeeded_world_count
    }
    /// <p>The number of worlds that failed.</p>
    pub fn failed_world_count(&self) -> i32 {
        self.failed_world_count
    }
}
impl std::fmt::Debug for WorldGenerationJobSummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("WorldGenerationJobSummary");
        formatter.field("arn", &self.arn);
        formatter.field("template", &self.template);
        formatter.field("created_at", &self.created_at);
        formatter.field("status", &self.status);
        formatter.field("world_count", &self.world_count);
        formatter.field("succeeded_world_count", &self.succeeded_world_count);
        formatter.field("failed_world_count", &self.failed_world_count);
        formatter.finish()
    }
}
/// See [`WorldGenerationJobSummary`](crate::model::WorldGenerationJobSummary)
pub mod world_generation_job_summary {
    /// A builder for [`WorldGenerationJobSummary`](crate::model::WorldGenerationJobSummary)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) template: std::option::Option<std::string::String>,
        pub(crate) created_at: std::option::Option<aws_smithy_types::Instant>,
        pub(crate) status: std::option::Option<crate::model::WorldGenerationJobStatus>,
        pub(crate) world_count: std::option::Option<crate::model::WorldCount>,
        pub(crate) succeeded_world_count: std::option::Option<i32>,
        pub(crate) failed_world_count: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the world generator job.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the world generator job.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>The Amazon Resource Name (arn) of the world template.</p>
        pub fn template(mut self, input: impl Into<std::string::String>) -> Self {
            self.template = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (arn) of the world template.</p>
        pub fn set_template(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.template = input;
            self
        }
        /// <p>The time, in milliseconds since the epoch, when the world generator job was
        /// created.</p>
        pub fn created_at(mut self, input: aws_smithy_types::Instant) -> Self {
            self.created_at = Some(input);
            self
        }
        /// <p>The time, in milliseconds since the epoch, when the world generator job was
        /// created.</p>
        pub fn set_created_at(
            mut self,
            input: std::option::Option<aws_smithy_types::Instant>,
        ) -> Self {
            self.created_at = input;
            self
        }
        /// <p>The status of the world generator job:</p>
        /// <dl>
        /// <dt>Pending</dt>
        /// <dd>
        /// <p>The world generator job request is pending.</p>
        /// </dd>
        /// <dt>Running</dt>
        /// <dd>
        /// <p>The world generator job is running. </p>
        /// </dd>
        /// <dt>Completed</dt>
        /// <dd>
        /// <p>The world generator job completed. </p>
        /// </dd>
        /// <dt>Failed</dt>
        /// <dd>
        /// <p>The world generator job failed. See <code>failureCode</code> for more
        /// information. </p>
        /// </dd>
        /// <dt>PartialFailed</dt>
        /// <dd>
        /// <p>Some worlds did not generate.</p>
        /// </dd>
        /// <dt>Canceled</dt>
        /// <dd>
        /// <p>The world generator job was cancelled.</p>
        /// </dd>
        /// <dt>Canceling</dt>
        /// <dd>
        /// <p>The world generator job is being cancelled.</p>
        /// </dd>
        /// </dl>
        pub fn status(mut self, input: crate::model::WorldGenerationJobStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The status of the world generator job:</p>
        /// <dl>
        /// <dt>Pending</dt>
        /// <dd>
        /// <p>The world generator job request is pending.</p>
        /// </dd>
        /// <dt>Running</dt>
        /// <dd>
        /// <p>The world generator job is running. </p>
        /// </dd>
        /// <dt>Completed</dt>
        /// <dd>
        /// <p>The world generator job completed. </p>
        /// </dd>
        /// <dt>Failed</dt>
        /// <dd>
        /// <p>The world generator job failed. See <code>failureCode</code> for more
        /// information. </p>
        /// </dd>
        /// <dt>PartialFailed</dt>
        /// <dd>
        /// <p>Some worlds did not generate.</p>
        /// </dd>
        /// <dt>Canceled</dt>
        /// <dd>
        /// <p>The world generator job was cancelled.</p>
        /// </dd>
        /// <dt>Canceling</dt>
        /// <dd>
        /// <p>The world generator job is being cancelled.</p>
        /// </dd>
        /// </dl>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::WorldGenerationJobStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// <p>Information about the world count.</p>
        pub fn world_count(mut self, input: crate::model::WorldCount) -> Self {
            self.world_count = Some(input);
            self
        }
        /// <p>Information about the world count.</p>
        pub fn set_world_count(
            mut self,
            input: std::option::Option<crate::model::WorldCount>,
        ) -> Self {
            self.world_count = input;
            self
        }
        /// <p>The number of worlds that were generated.</p>
        pub fn succeeded_world_count(mut self, input: i32) -> Self {
            self.succeeded_world_count = Some(input);
            self
        }
        /// <p>The number of worlds that were generated.</p>
        pub fn set_succeeded_world_count(mut self, input: std::option::Option<i32>) -> Self {
            self.succeeded_world_count = input;
            self
        }
        /// <p>The number of worlds that failed.</p>
        pub fn failed_world_count(mut self, input: i32) -> Self {
            self.failed_world_count = Some(input);
            self
        }
        /// <p>The number of worlds that failed.</p>
        pub fn set_failed_world_count(mut self, input: std::option::Option<i32>) -> Self {
            self.failed_world_count = input;
            self
        }
        /// Consumes the builder and constructs a [`WorldGenerationJobSummary`](crate::model::WorldGenerationJobSummary)
        pub fn build(self) -> crate::model::WorldGenerationJobSummary {
            crate::model::WorldGenerationJobSummary {
                arn: self.arn,
                template: self.template,
                created_at: self.created_at,
                status: self.status,
                world_count: self.world_count,
                succeeded_world_count: self.succeeded_world_count.unwrap_or_default(),
                failed_world_count: self.failed_world_count.unwrap_or_default(),
            }
        }
    }
}
impl WorldGenerationJobSummary {
    /// Creates a new builder-style object to manufacture [`WorldGenerationJobSummary`](crate::model::WorldGenerationJobSummary)
    pub fn builder() -> crate::model::world_generation_job_summary::Builder {
        crate::model::world_generation_job_summary::Builder::default()
    }
}

/// <p>The number of worlds that will be created. You can configure the number of unique
/// floorplans and the number of unique interiors for each floor plan. For example, if you want
/// 1 world with 20 unique interiors, you set <code>floorplanCount = 1</code> and
/// <code>interiorCountPerFloorplan = 20</code>. This will result in 20 worlds
/// (<code>floorplanCount</code> * <code>interiorCountPerFloorplan)</code>. </p>
/// <p>If you set <code>floorplanCount = 4</code> and <code>interiorCountPerFloorplan =
/// 5</code>, there will be 20 worlds with 5 unique floor plans. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct WorldCount {
    /// <p>The number of unique floorplans.</p>
    pub floorplan_count: std::option::Option<i32>,
    /// <p>The number of unique interiors per floorplan.</p>
    pub interior_count_per_floorplan: std::option::Option<i32>,
}
impl WorldCount {
    /// <p>The number of unique floorplans.</p>
    pub fn floorplan_count(&self) -> std::option::Option<i32> {
        self.floorplan_count
    }
    /// <p>The number of unique interiors per floorplan.</p>
    pub fn interior_count_per_floorplan(&self) -> std::option::Option<i32> {
        self.interior_count_per_floorplan
    }
}
impl std::fmt::Debug for WorldCount {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("WorldCount");
        formatter.field("floorplan_count", &self.floorplan_count);
        formatter.field(
            "interior_count_per_floorplan",
            &self.interior_count_per_floorplan,
        );
        formatter.finish()
    }
}
/// See [`WorldCount`](crate::model::WorldCount)
pub mod world_count {
    /// A builder for [`WorldCount`](crate::model::WorldCount)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) floorplan_count: std::option::Option<i32>,
        pub(crate) interior_count_per_floorplan: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The number of unique floorplans.</p>
        pub fn floorplan_count(mut self, input: i32) -> Self {
            self.floorplan_count = Some(input);
            self
        }
        /// <p>The number of unique floorplans.</p>
        pub fn set_floorplan_count(mut self, input: std::option::Option<i32>) -> Self {
            self.floorplan_count = input;
            self
        }
        /// <p>The number of unique interiors per floorplan.</p>
        pub fn interior_count_per_floorplan(mut self, input: i32) -> Self {
            self.interior_count_per_floorplan = Some(input);
            self
        }
        /// <p>The number of unique interiors per floorplan.</p>
        pub fn set_interior_count_per_floorplan(mut self, input: std::option::Option<i32>) -> Self {
            self.interior_count_per_floorplan = input;
            self
        }
        /// Consumes the builder and constructs a [`WorldCount`](crate::model::WorldCount)
        pub fn build(self) -> crate::model::WorldCount {
            crate::model::WorldCount {
                floorplan_count: self.floorplan_count,
                interior_count_per_floorplan: self.interior_count_per_floorplan,
            }
        }
    }
}
impl WorldCount {
    /// Creates a new builder-style object to manufacture [`WorldCount`](crate::model::WorldCount)
    pub fn builder() -> crate::model::world_count::Builder {
        crate::model::world_count::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum WorldGenerationJobStatus {
    #[allow(missing_docs)] // documentation missing in model
    Canceled,
    #[allow(missing_docs)] // documentation missing in model
    Canceling,
    #[allow(missing_docs)] // documentation missing in model
    Completed,
    #[allow(missing_docs)] // documentation missing in model
    Failed,
    #[allow(missing_docs)] // documentation missing in model
    PartialFailed,
    #[allow(missing_docs)] // documentation missing in model
    Pending,
    #[allow(missing_docs)] // documentation missing in model
    Running,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for WorldGenerationJobStatus {
    fn from(s: &str) -> Self {
        match s {
            "Canceled" => WorldGenerationJobStatus::Canceled,
            "Canceling" => WorldGenerationJobStatus::Canceling,
            "Completed" => WorldGenerationJobStatus::Completed,
            "Failed" => WorldGenerationJobStatus::Failed,
            "PartialFailed" => WorldGenerationJobStatus::PartialFailed,
            "Pending" => WorldGenerationJobStatus::Pending,
            "Running" => WorldGenerationJobStatus::Running,
            other => WorldGenerationJobStatus::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for WorldGenerationJobStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(WorldGenerationJobStatus::from(s))
    }
}
impl WorldGenerationJobStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            WorldGenerationJobStatus::Canceled => "Canceled",
            WorldGenerationJobStatus::Canceling => "Canceling",
            WorldGenerationJobStatus::Completed => "Completed",
            WorldGenerationJobStatus::Failed => "Failed",
            WorldGenerationJobStatus::PartialFailed => "PartialFailed",
            WorldGenerationJobStatus::Pending => "Pending",
            WorldGenerationJobStatus::Running => "Running",
            WorldGenerationJobStatus::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &[
            "Canceled",
            "Canceling",
            "Completed",
            "Failed",
            "PartialFailed",
            "Pending",
            "Running",
        ]
    }
}
impl AsRef<str> for WorldGenerationJobStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Information about a world export job.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct WorldExportJobSummary {
    /// <p>The Amazon Resource Name (ARN) of the world export job.</p>
    pub arn: std::option::Option<std::string::String>,
    /// <p>The status of the world export job.</p>
    /// <dl>
    /// <dt>Pending</dt>
    /// <dd>
    /// <p>The world export job request is pending.</p>
    /// </dd>
    /// <dt>Running</dt>
    /// <dd>
    /// <p>The world export job is running. </p>
    /// </dd>
    /// <dt>Completed</dt>
    /// <dd>
    /// <p>The world export job completed. </p>
    /// </dd>
    /// <dt>Failed</dt>
    /// <dd>
    /// <p>The world export job failed. See <code>failureCode</code> for more information.
    /// </p>
    /// </dd>
    /// <dt>Canceled</dt>
    /// <dd>
    /// <p>The world export job was cancelled.</p>
    /// </dd>
    /// <dt>Canceling</dt>
    /// <dd>
    /// <p>The world export job is being cancelled.</p>
    /// </dd>
    /// </dl>
    pub status: std::option::Option<crate::model::WorldExportJobStatus>,
    /// <p>The time, in milliseconds since the epoch, when the world export job was created.</p>
    pub created_at: std::option::Option<aws_smithy_types::Instant>,
    /// <p>A list of worlds.</p>
    pub worlds: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl WorldExportJobSummary {
    /// <p>The Amazon Resource Name (ARN) of the world export job.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>The status of the world export job.</p>
    /// <dl>
    /// <dt>Pending</dt>
    /// <dd>
    /// <p>The world export job request is pending.</p>
    /// </dd>
    /// <dt>Running</dt>
    /// <dd>
    /// <p>The world export job is running. </p>
    /// </dd>
    /// <dt>Completed</dt>
    /// <dd>
    /// <p>The world export job completed. </p>
    /// </dd>
    /// <dt>Failed</dt>
    /// <dd>
    /// <p>The world export job failed. See <code>failureCode</code> for more information.
    /// </p>
    /// </dd>
    /// <dt>Canceled</dt>
    /// <dd>
    /// <p>The world export job was cancelled.</p>
    /// </dd>
    /// <dt>Canceling</dt>
    /// <dd>
    /// <p>The world export job is being cancelled.</p>
    /// </dd>
    /// </dl>
    pub fn status(&self) -> std::option::Option<&crate::model::WorldExportJobStatus> {
        self.status.as_ref()
    }
    /// <p>The time, in milliseconds since the epoch, when the world export job was created.</p>
    pub fn created_at(&self) -> std::option::Option<&aws_smithy_types::Instant> {
        self.created_at.as_ref()
    }
    /// <p>A list of worlds.</p>
    pub fn worlds(&self) -> std::option::Option<&[std::string::String]> {
        self.worlds.as_deref()
    }
}
impl std::fmt::Debug for WorldExportJobSummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("WorldExportJobSummary");
        formatter.field("arn", &self.arn);
        formatter.field("status", &self.status);
        formatter.field("created_at", &self.created_at);
        formatter.field("worlds", &self.worlds);
        formatter.finish()
    }
}
/// See [`WorldExportJobSummary`](crate::model::WorldExportJobSummary)
pub mod world_export_job_summary {
    /// A builder for [`WorldExportJobSummary`](crate::model::WorldExportJobSummary)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) status: std::option::Option<crate::model::WorldExportJobStatus>,
        pub(crate) created_at: std::option::Option<aws_smithy_types::Instant>,
        pub(crate) worlds: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the world export job.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the world export job.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>The status of the world export job.</p>
        /// <dl>
        /// <dt>Pending</dt>
        /// <dd>
        /// <p>The world export job request is pending.</p>
        /// </dd>
        /// <dt>Running</dt>
        /// <dd>
        /// <p>The world export job is running. </p>
        /// </dd>
        /// <dt>Completed</dt>
        /// <dd>
        /// <p>The world export job completed. </p>
        /// </dd>
        /// <dt>Failed</dt>
        /// <dd>
        /// <p>The world export job failed. See <code>failureCode</code> for more information.
        /// </p>
        /// </dd>
        /// <dt>Canceled</dt>
        /// <dd>
        /// <p>The world export job was cancelled.</p>
        /// </dd>
        /// <dt>Canceling</dt>
        /// <dd>
        /// <p>The world export job is being cancelled.</p>
        /// </dd>
        /// </dl>
        pub fn status(mut self, input: crate::model::WorldExportJobStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The status of the world export job.</p>
        /// <dl>
        /// <dt>Pending</dt>
        /// <dd>
        /// <p>The world export job request is pending.</p>
        /// </dd>
        /// <dt>Running</dt>
        /// <dd>
        /// <p>The world export job is running. </p>
        /// </dd>
        /// <dt>Completed</dt>
        /// <dd>
        /// <p>The world export job completed. </p>
        /// </dd>
        /// <dt>Failed</dt>
        /// <dd>
        /// <p>The world export job failed. See <code>failureCode</code> for more information.
        /// </p>
        /// </dd>
        /// <dt>Canceled</dt>
        /// <dd>
        /// <p>The world export job was cancelled.</p>
        /// </dd>
        /// <dt>Canceling</dt>
        /// <dd>
        /// <p>The world export job is being cancelled.</p>
        /// </dd>
        /// </dl>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::WorldExportJobStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// <p>The time, in milliseconds since the epoch, when the world export job was created.</p>
        pub fn created_at(mut self, input: aws_smithy_types::Instant) -> Self {
            self.created_at = Some(input);
            self
        }
        /// <p>The time, in milliseconds since the epoch, when the world export job was created.</p>
        pub fn set_created_at(
            mut self,
            input: std::option::Option<aws_smithy_types::Instant>,
        ) -> Self {
            self.created_at = input;
            self
        }
        /// Appends an item to `worlds`.
        ///
        /// To override the contents of this collection use [`set_worlds`](Self::set_worlds).
        ///
        /// <p>A list of worlds.</p>
        pub fn worlds(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.worlds.unwrap_or_default();
            v.push(input.into());
            self.worlds = Some(v);
            self
        }
        /// <p>A list of worlds.</p>
        pub fn set_worlds(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.worlds = input;
            self
        }
        /// Consumes the builder and constructs a [`WorldExportJobSummary`](crate::model::WorldExportJobSummary)
        pub fn build(self) -> crate::model::WorldExportJobSummary {
            crate::model::WorldExportJobSummary {
                arn: self.arn,
                status: self.status,
                created_at: self.created_at,
                worlds: self.worlds,
            }
        }
    }
}
impl WorldExportJobSummary {
    /// Creates a new builder-style object to manufacture [`WorldExportJobSummary`](crate::model::WorldExportJobSummary)
    pub fn builder() -> crate::model::world_export_job_summary::Builder {
        crate::model::world_export_job_summary::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum WorldExportJobStatus {
    #[allow(missing_docs)] // documentation missing in model
    Canceled,
    #[allow(missing_docs)] // documentation missing in model
    Canceling,
    #[allow(missing_docs)] // documentation missing in model
    Completed,
    #[allow(missing_docs)] // documentation missing in model
    Failed,
    #[allow(missing_docs)] // documentation missing in model
    Pending,
    #[allow(missing_docs)] // documentation missing in model
    Running,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for WorldExportJobStatus {
    fn from(s: &str) -> Self {
        match s {
            "Canceled" => WorldExportJobStatus::Canceled,
            "Canceling" => WorldExportJobStatus::Canceling,
            "Completed" => WorldExportJobStatus::Completed,
            "Failed" => WorldExportJobStatus::Failed,
            "Pending" => WorldExportJobStatus::Pending,
            "Running" => WorldExportJobStatus::Running,
            other => WorldExportJobStatus::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for WorldExportJobStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(WorldExportJobStatus::from(s))
    }
}
impl WorldExportJobStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            WorldExportJobStatus::Canceled => "Canceled",
            WorldExportJobStatus::Canceling => "Canceling",
            WorldExportJobStatus::Completed => "Completed",
            WorldExportJobStatus::Failed => "Failed",
            WorldExportJobStatus::Pending => "Pending",
            WorldExportJobStatus::Running => "Running",
            WorldExportJobStatus::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &[
            "Canceled",
            "Canceling",
            "Completed",
            "Failed",
            "Pending",
            "Running",
        ]
    }
}
impl AsRef<str> for WorldExportJobStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Information about a simulation job batch.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SimulationJobBatchSummary {
    /// <p>The Amazon Resource Name (ARN) of the batch.</p>
    pub arn: std::option::Option<std::string::String>,
    /// <p>The time, in milliseconds since the epoch, when the simulation job batch was last
    /// updated.</p>
    pub last_updated_at: std::option::Option<aws_smithy_types::Instant>,
    /// <p>The time, in milliseconds since the epoch, when the simulation job batch was
    /// created.</p>
    pub created_at: std::option::Option<aws_smithy_types::Instant>,
    /// <p>The status of the simulation job batch.</p>
    /// <dl>
    /// <dt>Pending</dt>
    /// <dd>
    /// <p>The simulation job batch request is pending.</p>
    /// </dd>
    /// <dt>InProgress</dt>
    /// <dd>
    /// <p>The simulation job batch is in progress. </p>
    /// </dd>
    /// <dt>Failed</dt>
    /// <dd>
    /// <p>The simulation job batch failed. One or more simulation job requests could not
    /// be completed due to an internal failure (like <code>InternalServiceError</code>).
    /// See <code>failureCode</code> and <code>failureReason</code> for more
    /// information.</p>
    /// </dd>
    /// <dt>Completed</dt>
    /// <dd>
    /// <p>The simulation batch job completed. A batch is complete when (1) there are no
    /// pending simulation job requests in the batch and none of the failed simulation job
    /// requests are due to <code>InternalServiceError</code> and (2) when all created
    /// simulation jobs have reached a terminal state (for example, <code>Completed</code>
    /// or <code>Failed</code>). </p>
    /// </dd>
    /// <dt>Canceled</dt>
    /// <dd>
    /// <p>The simulation batch job was cancelled.</p>
    /// </dd>
    /// <dt>Canceling</dt>
    /// <dd>
    /// <p>The simulation batch job is being cancelled.</p>
    /// </dd>
    /// <dt>Completing</dt>
    /// <dd>
    /// <p>The simulation batch job is completing.</p>
    /// </dd>
    /// <dt>TimingOut</dt>
    /// <dd>
    /// <p>The simulation job batch is timing out.</p>
    /// <p>If a batch timing out, and there are pending requests that were failing due to
    /// an internal failure (like <code>InternalServiceError</code>), the batch status
    /// will be <code>Failed</code>. If there are no such failing request, the batch
    /// status will be <code>TimedOut</code>. </p>
    /// </dd>
    /// <dt>TimedOut</dt>
    /// <dd>
    /// <p>The simulation batch job timed out.</p>
    /// </dd>
    /// </dl>
    pub status: std::option::Option<crate::model::SimulationJobBatchStatus>,
    /// <p>The number of failed simulation job requests.</p>
    pub failed_request_count: i32,
    /// <p>The number of pending simulation job requests.</p>
    pub pending_request_count: i32,
    /// <p>The number of created simulation job requests.</p>
    pub created_request_count: i32,
}
impl SimulationJobBatchSummary {
    /// <p>The Amazon Resource Name (ARN) of the batch.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>The time, in milliseconds since the epoch, when the simulation job batch was last
    /// updated.</p>
    pub fn last_updated_at(&self) -> std::option::Option<&aws_smithy_types::Instant> {
        self.last_updated_at.as_ref()
    }
    /// <p>The time, in milliseconds since the epoch, when the simulation job batch was
    /// created.</p>
    pub fn created_at(&self) -> std::option::Option<&aws_smithy_types::Instant> {
        self.created_at.as_ref()
    }
    /// <p>The status of the simulation job batch.</p>
    /// <dl>
    /// <dt>Pending</dt>
    /// <dd>
    /// <p>The simulation job batch request is pending.</p>
    /// </dd>
    /// <dt>InProgress</dt>
    /// <dd>
    /// <p>The simulation job batch is in progress. </p>
    /// </dd>
    /// <dt>Failed</dt>
    /// <dd>
    /// <p>The simulation job batch failed. One or more simulation job requests could not
    /// be completed due to an internal failure (like <code>InternalServiceError</code>).
    /// See <code>failureCode</code> and <code>failureReason</code> for more
    /// information.</p>
    /// </dd>
    /// <dt>Completed</dt>
    /// <dd>
    /// <p>The simulation batch job completed. A batch is complete when (1) there are no
    /// pending simulation job requests in the batch and none of the failed simulation job
    /// requests are due to <code>InternalServiceError</code> and (2) when all created
    /// simulation jobs have reached a terminal state (for example, <code>Completed</code>
    /// or <code>Failed</code>). </p>
    /// </dd>
    /// <dt>Canceled</dt>
    /// <dd>
    /// <p>The simulation batch job was cancelled.</p>
    /// </dd>
    /// <dt>Canceling</dt>
    /// <dd>
    /// <p>The simulation batch job is being cancelled.</p>
    /// </dd>
    /// <dt>Completing</dt>
    /// <dd>
    /// <p>The simulation batch job is completing.</p>
    /// </dd>
    /// <dt>TimingOut</dt>
    /// <dd>
    /// <p>The simulation job batch is timing out.</p>
    /// <p>If a batch timing out, and there are pending requests that were failing due to
    /// an internal failure (like <code>InternalServiceError</code>), the batch status
    /// will be <code>Failed</code>. If there are no such failing request, the batch
    /// status will be <code>TimedOut</code>. </p>
    /// </dd>
    /// <dt>TimedOut</dt>
    /// <dd>
    /// <p>The simulation batch job timed out.</p>
    /// </dd>
    /// </dl>
    pub fn status(&self) -> std::option::Option<&crate::model::SimulationJobBatchStatus> {
        self.status.as_ref()
    }
    /// <p>The number of failed simulation job requests.</p>
    pub fn failed_request_count(&self) -> i32 {
        self.failed_request_count
    }
    /// <p>The number of pending simulation job requests.</p>
    pub fn pending_request_count(&self) -> i32 {
        self.pending_request_count
    }
    /// <p>The number of created simulation job requests.</p>
    pub fn created_request_count(&self) -> i32 {
        self.created_request_count
    }
}
impl std::fmt::Debug for SimulationJobBatchSummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SimulationJobBatchSummary");
        formatter.field("arn", &self.arn);
        formatter.field("last_updated_at", &self.last_updated_at);
        formatter.field("created_at", &self.created_at);
        formatter.field("status", &self.status);
        formatter.field("failed_request_count", &self.failed_request_count);
        formatter.field("pending_request_count", &self.pending_request_count);
        formatter.field("created_request_count", &self.created_request_count);
        formatter.finish()
    }
}
/// See [`SimulationJobBatchSummary`](crate::model::SimulationJobBatchSummary)
pub mod simulation_job_batch_summary {
    /// A builder for [`SimulationJobBatchSummary`](crate::model::SimulationJobBatchSummary)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) last_updated_at: std::option::Option<aws_smithy_types::Instant>,
        pub(crate) created_at: std::option::Option<aws_smithy_types::Instant>,
        pub(crate) status: std::option::Option<crate::model::SimulationJobBatchStatus>,
        pub(crate) failed_request_count: std::option::Option<i32>,
        pub(crate) pending_request_count: std::option::Option<i32>,
        pub(crate) created_request_count: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the batch.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the batch.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>The time, in milliseconds since the epoch, when the simulation job batch was last
        /// updated.</p>
        pub fn last_updated_at(mut self, input: aws_smithy_types::Instant) -> Self {
            self.last_updated_at = Some(input);
            self
        }
        /// <p>The time, in milliseconds since the epoch, when the simulation job batch was last
        /// updated.</p>
        pub fn set_last_updated_at(
            mut self,
            input: std::option::Option<aws_smithy_types::Instant>,
        ) -> Self {
            self.last_updated_at = input;
            self
        }
        /// <p>The time, in milliseconds since the epoch, when the simulation job batch was
        /// created.</p>
        pub fn created_at(mut self, input: aws_smithy_types::Instant) -> Self {
            self.created_at = Some(input);
            self
        }
        /// <p>The time, in milliseconds since the epoch, when the simulation job batch was
        /// created.</p>
        pub fn set_created_at(
            mut self,
            input: std::option::Option<aws_smithy_types::Instant>,
        ) -> Self {
            self.created_at = input;
            self
        }
        /// <p>The status of the simulation job batch.</p>
        /// <dl>
        /// <dt>Pending</dt>
        /// <dd>
        /// <p>The simulation job batch request is pending.</p>
        /// </dd>
        /// <dt>InProgress</dt>
        /// <dd>
        /// <p>The simulation job batch is in progress. </p>
        /// </dd>
        /// <dt>Failed</dt>
        /// <dd>
        /// <p>The simulation job batch failed. One or more simulation job requests could not
        /// be completed due to an internal failure (like <code>InternalServiceError</code>).
        /// See <code>failureCode</code> and <code>failureReason</code> for more
        /// information.</p>
        /// </dd>
        /// <dt>Completed</dt>
        /// <dd>
        /// <p>The simulation batch job completed. A batch is complete when (1) there are no
        /// pending simulation job requests in the batch and none of the failed simulation job
        /// requests are due to <code>InternalServiceError</code> and (2) when all created
        /// simulation jobs have reached a terminal state (for example, <code>Completed</code>
        /// or <code>Failed</code>). </p>
        /// </dd>
        /// <dt>Canceled</dt>
        /// <dd>
        /// <p>The simulation batch job was cancelled.</p>
        /// </dd>
        /// <dt>Canceling</dt>
        /// <dd>
        /// <p>The simulation batch job is being cancelled.</p>
        /// </dd>
        /// <dt>Completing</dt>
        /// <dd>
        /// <p>The simulation batch job is completing.</p>
        /// </dd>
        /// <dt>TimingOut</dt>
        /// <dd>
        /// <p>The simulation job batch is timing out.</p>
        /// <p>If a batch timing out, and there are pending requests that were failing due to
        /// an internal failure (like <code>InternalServiceError</code>), the batch status
        /// will be <code>Failed</code>. If there are no such failing request, the batch
        /// status will be <code>TimedOut</code>. </p>
        /// </dd>
        /// <dt>TimedOut</dt>
        /// <dd>
        /// <p>The simulation batch job timed out.</p>
        /// </dd>
        /// </dl>
        pub fn status(mut self, input: crate::model::SimulationJobBatchStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The status of the simulation job batch.</p>
        /// <dl>
        /// <dt>Pending</dt>
        /// <dd>
        /// <p>The simulation job batch request is pending.</p>
        /// </dd>
        /// <dt>InProgress</dt>
        /// <dd>
        /// <p>The simulation job batch is in progress. </p>
        /// </dd>
        /// <dt>Failed</dt>
        /// <dd>
        /// <p>The simulation job batch failed. One or more simulation job requests could not
        /// be completed due to an internal failure (like <code>InternalServiceError</code>).
        /// See <code>failureCode</code> and <code>failureReason</code> for more
        /// information.</p>
        /// </dd>
        /// <dt>Completed</dt>
        /// <dd>
        /// <p>The simulation batch job completed. A batch is complete when (1) there are no
        /// pending simulation job requests in the batch and none of the failed simulation job
        /// requests are due to <code>InternalServiceError</code> and (2) when all created
        /// simulation jobs have reached a terminal state (for example, <code>Completed</code>
        /// or <code>Failed</code>). </p>
        /// </dd>
        /// <dt>Canceled</dt>
        /// <dd>
        /// <p>The simulation batch job was cancelled.</p>
        /// </dd>
        /// <dt>Canceling</dt>
        /// <dd>
        /// <p>The simulation batch job is being cancelled.</p>
        /// </dd>
        /// <dt>Completing</dt>
        /// <dd>
        /// <p>The simulation batch job is completing.</p>
        /// </dd>
        /// <dt>TimingOut</dt>
        /// <dd>
        /// <p>The simulation job batch is timing out.</p>
        /// <p>If a batch timing out, and there are pending requests that were failing due to
        /// an internal failure (like <code>InternalServiceError</code>), the batch status
        /// will be <code>Failed</code>. If there are no such failing request, the batch
        /// status will be <code>TimedOut</code>. </p>
        /// </dd>
        /// <dt>TimedOut</dt>
        /// <dd>
        /// <p>The simulation batch job timed out.</p>
        /// </dd>
        /// </dl>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::SimulationJobBatchStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// <p>The number of failed simulation job requests.</p>
        pub fn failed_request_count(mut self, input: i32) -> Self {
            self.failed_request_count = Some(input);
            self
        }
        /// <p>The number of failed simulation job requests.</p>
        pub fn set_failed_request_count(mut self, input: std::option::Option<i32>) -> Self {
            self.failed_request_count = input;
            self
        }
        /// <p>The number of pending simulation job requests.</p>
        pub fn pending_request_count(mut self, input: i32) -> Self {
            self.pending_request_count = Some(input);
            self
        }
        /// <p>The number of pending simulation job requests.</p>
        pub fn set_pending_request_count(mut self, input: std::option::Option<i32>) -> Self {
            self.pending_request_count = input;
            self
        }
        /// <p>The number of created simulation job requests.</p>
        pub fn created_request_count(mut self, input: i32) -> Self {
            self.created_request_count = Some(input);
            self
        }
        /// <p>The number of created simulation job requests.</p>
        pub fn set_created_request_count(mut self, input: std::option::Option<i32>) -> Self {
            self.created_request_count = input;
            self
        }
        /// Consumes the builder and constructs a [`SimulationJobBatchSummary`](crate::model::SimulationJobBatchSummary)
        pub fn build(self) -> crate::model::SimulationJobBatchSummary {
            crate::model::SimulationJobBatchSummary {
                arn: self.arn,
                last_updated_at: self.last_updated_at,
                created_at: self.created_at,
                status: self.status,
                failed_request_count: self.failed_request_count.unwrap_or_default(),
                pending_request_count: self.pending_request_count.unwrap_or_default(),
                created_request_count: self.created_request_count.unwrap_or_default(),
            }
        }
    }
}
impl SimulationJobBatchSummary {
    /// Creates a new builder-style object to manufacture [`SimulationJobBatchSummary`](crate::model::SimulationJobBatchSummary)
    pub fn builder() -> crate::model::simulation_job_batch_summary::Builder {
        crate::model::simulation_job_batch_summary::Builder::default()
    }
}

/// <p>Summary information for a simulation application.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SimulationApplicationSummary {
    /// <p>The name of the simulation application.</p>
    pub name: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the simulation application.</p>
    pub arn: std::option::Option<std::string::String>,
    /// <p>The version of the simulation application.</p>
    pub version: std::option::Option<std::string::String>,
    /// <p>The time, in milliseconds since the epoch, when the simulation application was last
    /// updated.</p>
    pub last_updated_at: std::option::Option<aws_smithy_types::Instant>,
    /// <p>Information about a robot software suite (ROS distribution).</p>
    pub robot_software_suite: std::option::Option<crate::model::RobotSoftwareSuite>,
    /// <p>Information about a simulation software suite.</p>
    pub simulation_software_suite: std::option::Option<crate::model::SimulationSoftwareSuite>,
}
impl SimulationApplicationSummary {
    /// <p>The name of the simulation application.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the simulation application.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>The version of the simulation application.</p>
    pub fn version(&self) -> std::option::Option<&str> {
        self.version.as_deref()
    }
    /// <p>The time, in milliseconds since the epoch, when the simulation application was last
    /// updated.</p>
    pub fn last_updated_at(&self) -> std::option::Option<&aws_smithy_types::Instant> {
        self.last_updated_at.as_ref()
    }
    /// <p>Information about a robot software suite (ROS distribution).</p>
    pub fn robot_software_suite(&self) -> std::option::Option<&crate::model::RobotSoftwareSuite> {
        self.robot_software_suite.as_ref()
    }
    /// <p>Information about a simulation software suite.</p>
    pub fn simulation_software_suite(
        &self,
    ) -> std::option::Option<&crate::model::SimulationSoftwareSuite> {
        self.simulation_software_suite.as_ref()
    }
}
impl std::fmt::Debug for SimulationApplicationSummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SimulationApplicationSummary");
        formatter.field("name", &self.name);
        formatter.field("arn", &self.arn);
        formatter.field("version", &self.version);
        formatter.field("last_updated_at", &self.last_updated_at);
        formatter.field("robot_software_suite", &self.robot_software_suite);
        formatter.field("simulation_software_suite", &self.simulation_software_suite);
        formatter.finish()
    }
}
/// See [`SimulationApplicationSummary`](crate::model::SimulationApplicationSummary)
pub mod simulation_application_summary {
    /// A builder for [`SimulationApplicationSummary`](crate::model::SimulationApplicationSummary)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) version: std::option::Option<std::string::String>,
        pub(crate) last_updated_at: std::option::Option<aws_smithy_types::Instant>,
        pub(crate) robot_software_suite: std::option::Option<crate::model::RobotSoftwareSuite>,
        pub(crate) simulation_software_suite:
            std::option::Option<crate::model::SimulationSoftwareSuite>,
    }
    impl Builder {
        /// <p>The name of the simulation application.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the simulation application.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the simulation application.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the simulation application.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>The version of the simulation application.</p>
        pub fn version(mut self, input: impl Into<std::string::String>) -> Self {
            self.version = Some(input.into());
            self
        }
        /// <p>The version of the simulation application.</p>
        pub fn set_version(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.version = input;
            self
        }
        /// <p>The time, in milliseconds since the epoch, when the simulation application was last
        /// updated.</p>
        pub fn last_updated_at(mut self, input: aws_smithy_types::Instant) -> Self {
            self.last_updated_at = Some(input);
            self
        }
        /// <p>The time, in milliseconds since the epoch, when the simulation application was last
        /// updated.</p>
        pub fn set_last_updated_at(
            mut self,
            input: std::option::Option<aws_smithy_types::Instant>,
        ) -> Self {
            self.last_updated_at = input;
            self
        }
        /// <p>Information about a robot software suite (ROS distribution).</p>
        pub fn robot_software_suite(mut self, input: crate::model::RobotSoftwareSuite) -> Self {
            self.robot_software_suite = Some(input);
            self
        }
        /// <p>Information about a robot software suite (ROS distribution).</p>
        pub fn set_robot_software_suite(
            mut self,
            input: std::option::Option<crate::model::RobotSoftwareSuite>,
        ) -> Self {
            self.robot_software_suite = input;
            self
        }
        /// <p>Information about a simulation software suite.</p>
        pub fn simulation_software_suite(
            mut self,
            input: crate::model::SimulationSoftwareSuite,
        ) -> Self {
            self.simulation_software_suite = Some(input);
            self
        }
        /// <p>Information about a simulation software suite.</p>
        pub fn set_simulation_software_suite(
            mut self,
            input: std::option::Option<crate::model::SimulationSoftwareSuite>,
        ) -> Self {
            self.simulation_software_suite = input;
            self
        }
        /// Consumes the builder and constructs a [`SimulationApplicationSummary`](crate::model::SimulationApplicationSummary)
        pub fn build(self) -> crate::model::SimulationApplicationSummary {
            crate::model::SimulationApplicationSummary {
                name: self.name,
                arn: self.arn,
                version: self.version,
                last_updated_at: self.last_updated_at,
                robot_software_suite: self.robot_software_suite,
                simulation_software_suite: self.simulation_software_suite,
            }
        }
    }
}
impl SimulationApplicationSummary {
    /// Creates a new builder-style object to manufacture [`SimulationApplicationSummary`](crate::model::SimulationApplicationSummary)
    pub fn builder() -> crate::model::simulation_application_summary::Builder {
        crate::model::simulation_application_summary::Builder::default()
    }
}

/// <p>Information about a robot.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Robot {
    /// <p>The Amazon Resource Name (ARN) of the robot.</p>
    pub arn: std::option::Option<std::string::String>,
    /// <p>The name of the robot.</p>
    pub name: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the fleet.</p>
    pub fleet_arn: std::option::Option<std::string::String>,
    /// <p>The status of the robot.</p>
    pub status: std::option::Option<crate::model::RobotStatus>,
    /// <p>The Greengrass group associated with the robot.</p>
    pub green_grass_group_id: std::option::Option<std::string::String>,
    /// <p>The time, in milliseconds since the epoch, when the robot was created.</p>
    pub created_at: std::option::Option<aws_smithy_types::Instant>,
    /// <p>The architecture of the robot.</p>
    pub architecture: std::option::Option<crate::model::Architecture>,
    /// <p>The Amazon Resource Name (ARN) of the last deployment job.</p>
    pub last_deployment_job: std::option::Option<std::string::String>,
    /// <p>The time of the last deployment.</p>
    pub last_deployment_time: std::option::Option<aws_smithy_types::Instant>,
}
impl Robot {
    /// <p>The Amazon Resource Name (ARN) of the robot.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>The name of the robot.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the fleet.</p>
    pub fn fleet_arn(&self) -> std::option::Option<&str> {
        self.fleet_arn.as_deref()
    }
    /// <p>The status of the robot.</p>
    pub fn status(&self) -> std::option::Option<&crate::model::RobotStatus> {
        self.status.as_ref()
    }
    /// <p>The Greengrass group associated with the robot.</p>
    pub fn green_grass_group_id(&self) -> std::option::Option<&str> {
        self.green_grass_group_id.as_deref()
    }
    /// <p>The time, in milliseconds since the epoch, when the robot was created.</p>
    pub fn created_at(&self) -> std::option::Option<&aws_smithy_types::Instant> {
        self.created_at.as_ref()
    }
    /// <p>The architecture of the robot.</p>
    pub fn architecture(&self) -> std::option::Option<&crate::model::Architecture> {
        self.architecture.as_ref()
    }
    /// <p>The Amazon Resource Name (ARN) of the last deployment job.</p>
    pub fn last_deployment_job(&self) -> std::option::Option<&str> {
        self.last_deployment_job.as_deref()
    }
    /// <p>The time of the last deployment.</p>
    pub fn last_deployment_time(&self) -> std::option::Option<&aws_smithy_types::Instant> {
        self.last_deployment_time.as_ref()
    }
}
impl std::fmt::Debug for Robot {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Robot");
        formatter.field("arn", &self.arn);
        formatter.field("name", &self.name);
        formatter.field("fleet_arn", &self.fleet_arn);
        formatter.field("status", &self.status);
        formatter.field("green_grass_group_id", &self.green_grass_group_id);
        formatter.field("created_at", &self.created_at);
        formatter.field("architecture", &self.architecture);
        formatter.field("last_deployment_job", &self.last_deployment_job);
        formatter.field("last_deployment_time", &self.last_deployment_time);
        formatter.finish()
    }
}
/// See [`Robot`](crate::model::Robot)
pub mod robot {
    /// A builder for [`Robot`](crate::model::Robot)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) fleet_arn: std::option::Option<std::string::String>,
        pub(crate) status: std::option::Option<crate::model::RobotStatus>,
        pub(crate) green_grass_group_id: std::option::Option<std::string::String>,
        pub(crate) created_at: std::option::Option<aws_smithy_types::Instant>,
        pub(crate) architecture: std::option::Option<crate::model::Architecture>,
        pub(crate) last_deployment_job: std::option::Option<std::string::String>,
        pub(crate) last_deployment_time: std::option::Option<aws_smithy_types::Instant>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the robot.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the robot.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>The name of the robot.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the robot.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the fleet.</p>
        pub fn fleet_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.fleet_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the fleet.</p>
        pub fn set_fleet_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.fleet_arn = input;
            self
        }
        /// <p>The status of the robot.</p>
        pub fn status(mut self, input: crate::model::RobotStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The status of the robot.</p>
        pub fn set_status(mut self, input: std::option::Option<crate::model::RobotStatus>) -> Self {
            self.status = input;
            self
        }
        /// <p>The Greengrass group associated with the robot.</p>
        pub fn green_grass_group_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.green_grass_group_id = Some(input.into());
            self
        }
        /// <p>The Greengrass group associated with the robot.</p>
        pub fn set_green_grass_group_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.green_grass_group_id = input;
            self
        }
        /// <p>The time, in milliseconds since the epoch, when the robot was created.</p>
        pub fn created_at(mut self, input: aws_smithy_types::Instant) -> Self {
            self.created_at = Some(input);
            self
        }
        /// <p>The time, in milliseconds since the epoch, when the robot was created.</p>
        pub fn set_created_at(
            mut self,
            input: std::option::Option<aws_smithy_types::Instant>,
        ) -> Self {
            self.created_at = input;
            self
        }
        /// <p>The architecture of the robot.</p>
        pub fn architecture(mut self, input: crate::model::Architecture) -> Self {
            self.architecture = Some(input);
            self
        }
        /// <p>The architecture of the robot.</p>
        pub fn set_architecture(
            mut self,
            input: std::option::Option<crate::model::Architecture>,
        ) -> Self {
            self.architecture = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the last deployment job.</p>
        pub fn last_deployment_job(mut self, input: impl Into<std::string::String>) -> Self {
            self.last_deployment_job = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the last deployment job.</p>
        pub fn set_last_deployment_job(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.last_deployment_job = input;
            self
        }
        /// <p>The time of the last deployment.</p>
        pub fn last_deployment_time(mut self, input: aws_smithy_types::Instant) -> Self {
            self.last_deployment_time = Some(input);
            self
        }
        /// <p>The time of the last deployment.</p>
        pub fn set_last_deployment_time(
            mut self,
            input: std::option::Option<aws_smithy_types::Instant>,
        ) -> Self {
            self.last_deployment_time = input;
            self
        }
        /// Consumes the builder and constructs a [`Robot`](crate::model::Robot)
        pub fn build(self) -> crate::model::Robot {
            crate::model::Robot {
                arn: self.arn,
                name: self.name,
                fleet_arn: self.fleet_arn,
                status: self.status,
                green_grass_group_id: self.green_grass_group_id,
                created_at: self.created_at,
                architecture: self.architecture,
                last_deployment_job: self.last_deployment_job,
                last_deployment_time: self.last_deployment_time,
            }
        }
    }
}
impl Robot {
    /// Creates a new builder-style object to manufacture [`Robot`](crate::model::Robot)
    pub fn builder() -> crate::model::robot::Builder {
        crate::model::robot::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum RobotStatus {
    #[allow(missing_docs)] // documentation missing in model
    Available,
    #[allow(missing_docs)] // documentation missing in model
    Deploying,
    #[allow(missing_docs)] // documentation missing in model
    Failed,
    #[allow(missing_docs)] // documentation missing in model
    InSync,
    #[allow(missing_docs)] // documentation missing in model
    NoResponse,
    #[allow(missing_docs)] // documentation missing in model
    PendingNewDeployment,
    #[allow(missing_docs)] // documentation missing in model
    Registered,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for RobotStatus {
    fn from(s: &str) -> Self {
        match s {
            "Available" => RobotStatus::Available,
            "Deploying" => RobotStatus::Deploying,
            "Failed" => RobotStatus::Failed,
            "InSync" => RobotStatus::InSync,
            "NoResponse" => RobotStatus::NoResponse,
            "PendingNewDeployment" => RobotStatus::PendingNewDeployment,
            "Registered" => RobotStatus::Registered,
            other => RobotStatus::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for RobotStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(RobotStatus::from(s))
    }
}
impl RobotStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            RobotStatus::Available => "Available",
            RobotStatus::Deploying => "Deploying",
            RobotStatus::Failed => "Failed",
            RobotStatus::InSync => "InSync",
            RobotStatus::NoResponse => "NoResponse",
            RobotStatus::PendingNewDeployment => "PendingNewDeployment",
            RobotStatus::Registered => "Registered",
            RobotStatus::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &[
            "Available",
            "Deploying",
            "Failed",
            "InSync",
            "NoResponse",
            "PendingNewDeployment",
            "Registered",
        ]
    }
}
impl AsRef<str> for RobotStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Summary information for a robot application.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct RobotApplicationSummary {
    /// <p>The name of the robot application.</p>
    pub name: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the robot.</p>
    pub arn: std::option::Option<std::string::String>,
    /// <p>The version of the robot application.</p>
    pub version: std::option::Option<std::string::String>,
    /// <p>The time, in milliseconds since the epoch, when the robot application was last
    /// updated.</p>
    pub last_updated_at: std::option::Option<aws_smithy_types::Instant>,
    /// <p>Information about a robot software suite (ROS distribution).</p>
    pub robot_software_suite: std::option::Option<crate::model::RobotSoftwareSuite>,
}
impl RobotApplicationSummary {
    /// <p>The name of the robot application.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the robot.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>The version of the robot application.</p>
    pub fn version(&self) -> std::option::Option<&str> {
        self.version.as_deref()
    }
    /// <p>The time, in milliseconds since the epoch, when the robot application was last
    /// updated.</p>
    pub fn last_updated_at(&self) -> std::option::Option<&aws_smithy_types::Instant> {
        self.last_updated_at.as_ref()
    }
    /// <p>Information about a robot software suite (ROS distribution).</p>
    pub fn robot_software_suite(&self) -> std::option::Option<&crate::model::RobotSoftwareSuite> {
        self.robot_software_suite.as_ref()
    }
}
impl std::fmt::Debug for RobotApplicationSummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("RobotApplicationSummary");
        formatter.field("name", &self.name);
        formatter.field("arn", &self.arn);
        formatter.field("version", &self.version);
        formatter.field("last_updated_at", &self.last_updated_at);
        formatter.field("robot_software_suite", &self.robot_software_suite);
        formatter.finish()
    }
}
/// See [`RobotApplicationSummary`](crate::model::RobotApplicationSummary)
pub mod robot_application_summary {
    /// A builder for [`RobotApplicationSummary`](crate::model::RobotApplicationSummary)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) version: std::option::Option<std::string::String>,
        pub(crate) last_updated_at: std::option::Option<aws_smithy_types::Instant>,
        pub(crate) robot_software_suite: std::option::Option<crate::model::RobotSoftwareSuite>,
    }
    impl Builder {
        /// <p>The name of the robot application.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the robot application.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the robot.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the robot.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>The version of the robot application.</p>
        pub fn version(mut self, input: impl Into<std::string::String>) -> Self {
            self.version = Some(input.into());
            self
        }
        /// <p>The version of the robot application.</p>
        pub fn set_version(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.version = input;
            self
        }
        /// <p>The time, in milliseconds since the epoch, when the robot application was last
        /// updated.</p>
        pub fn last_updated_at(mut self, input: aws_smithy_types::Instant) -> Self {
            self.last_updated_at = Some(input);
            self
        }
        /// <p>The time, in milliseconds since the epoch, when the robot application was last
        /// updated.</p>
        pub fn set_last_updated_at(
            mut self,
            input: std::option::Option<aws_smithy_types::Instant>,
        ) -> Self {
            self.last_updated_at = input;
            self
        }
        /// <p>Information about a robot software suite (ROS distribution).</p>
        pub fn robot_software_suite(mut self, input: crate::model::RobotSoftwareSuite) -> Self {
            self.robot_software_suite = Some(input);
            self
        }
        /// <p>Information about a robot software suite (ROS distribution).</p>
        pub fn set_robot_software_suite(
            mut self,
            input: std::option::Option<crate::model::RobotSoftwareSuite>,
        ) -> Self {
            self.robot_software_suite = input;
            self
        }
        /// Consumes the builder and constructs a [`RobotApplicationSummary`](crate::model::RobotApplicationSummary)
        pub fn build(self) -> crate::model::RobotApplicationSummary {
            crate::model::RobotApplicationSummary {
                name: self.name,
                arn: self.arn,
                version: self.version,
                last_updated_at: self.last_updated_at,
                robot_software_suite: self.robot_software_suite,
            }
        }
    }
}
impl RobotApplicationSummary {
    /// Creates a new builder-style object to manufacture [`RobotApplicationSummary`](crate::model::RobotApplicationSummary)
    pub fn builder() -> crate::model::robot_application_summary::Builder {
        crate::model::robot_application_summary::Builder::default()
    }
}

/// <p>Information about a fleet.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Fleet {
    /// <p>The name of the fleet.</p>
    pub name: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the fleet.</p>
    pub arn: std::option::Option<std::string::String>,
    /// <p>The time, in milliseconds since the epoch, when the fleet was created.</p>
    pub created_at: std::option::Option<aws_smithy_types::Instant>,
    /// <p>The status of the last fleet deployment.</p>
    pub last_deployment_status: std::option::Option<crate::model::DeploymentStatus>,
    /// <p>The Amazon Resource Name (ARN) of the last deployment job.</p>
    pub last_deployment_job: std::option::Option<std::string::String>,
    /// <p>The time of the last deployment.</p>
    pub last_deployment_time: std::option::Option<aws_smithy_types::Instant>,
}
impl Fleet {
    /// <p>The name of the fleet.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the fleet.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>The time, in milliseconds since the epoch, when the fleet was created.</p>
    pub fn created_at(&self) -> std::option::Option<&aws_smithy_types::Instant> {
        self.created_at.as_ref()
    }
    /// <p>The status of the last fleet deployment.</p>
    pub fn last_deployment_status(&self) -> std::option::Option<&crate::model::DeploymentStatus> {
        self.last_deployment_status.as_ref()
    }
    /// <p>The Amazon Resource Name (ARN) of the last deployment job.</p>
    pub fn last_deployment_job(&self) -> std::option::Option<&str> {
        self.last_deployment_job.as_deref()
    }
    /// <p>The time of the last deployment.</p>
    pub fn last_deployment_time(&self) -> std::option::Option<&aws_smithy_types::Instant> {
        self.last_deployment_time.as_ref()
    }
}
impl std::fmt::Debug for Fleet {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Fleet");
        formatter.field("name", &self.name);
        formatter.field("arn", &self.arn);
        formatter.field("created_at", &self.created_at);
        formatter.field("last_deployment_status", &self.last_deployment_status);
        formatter.field("last_deployment_job", &self.last_deployment_job);
        formatter.field("last_deployment_time", &self.last_deployment_time);
        formatter.finish()
    }
}
/// See [`Fleet`](crate::model::Fleet)
pub mod fleet {
    /// A builder for [`Fleet`](crate::model::Fleet)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) created_at: std::option::Option<aws_smithy_types::Instant>,
        pub(crate) last_deployment_status: std::option::Option<crate::model::DeploymentStatus>,
        pub(crate) last_deployment_job: std::option::Option<std::string::String>,
        pub(crate) last_deployment_time: std::option::Option<aws_smithy_types::Instant>,
    }
    impl Builder {
        /// <p>The name of the fleet.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the fleet.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the fleet.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the fleet.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>The time, in milliseconds since the epoch, when the fleet was created.</p>
        pub fn created_at(mut self, input: aws_smithy_types::Instant) -> Self {
            self.created_at = Some(input);
            self
        }
        /// <p>The time, in milliseconds since the epoch, when the fleet was created.</p>
        pub fn set_created_at(
            mut self,
            input: std::option::Option<aws_smithy_types::Instant>,
        ) -> Self {
            self.created_at = input;
            self
        }
        /// <p>The status of the last fleet deployment.</p>
        pub fn last_deployment_status(mut self, input: crate::model::DeploymentStatus) -> Self {
            self.last_deployment_status = Some(input);
            self
        }
        /// <p>The status of the last fleet deployment.</p>
        pub fn set_last_deployment_status(
            mut self,
            input: std::option::Option<crate::model::DeploymentStatus>,
        ) -> Self {
            self.last_deployment_status = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the last deployment job.</p>
        pub fn last_deployment_job(mut self, input: impl Into<std::string::String>) -> Self {
            self.last_deployment_job = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the last deployment job.</p>
        pub fn set_last_deployment_job(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.last_deployment_job = input;
            self
        }
        /// <p>The time of the last deployment.</p>
        pub fn last_deployment_time(mut self, input: aws_smithy_types::Instant) -> Self {
            self.last_deployment_time = Some(input);
            self
        }
        /// <p>The time of the last deployment.</p>
        pub fn set_last_deployment_time(
            mut self,
            input: std::option::Option<aws_smithy_types::Instant>,
        ) -> Self {
            self.last_deployment_time = input;
            self
        }
        /// Consumes the builder and constructs a [`Fleet`](crate::model::Fleet)
        pub fn build(self) -> crate::model::Fleet {
            crate::model::Fleet {
                name: self.name,
                arn: self.arn,
                created_at: self.created_at,
                last_deployment_status: self.last_deployment_status,
                last_deployment_job: self.last_deployment_job,
                last_deployment_time: self.last_deployment_time,
            }
        }
    }
}
impl Fleet {
    /// Creates a new builder-style object to manufacture [`Fleet`](crate::model::Fleet)
    pub fn builder() -> crate::model::fleet::Builder {
        crate::model::fleet::Builder::default()
    }
}

/// <p>Information about a deployment job.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeploymentJob {
    /// <p>The Amazon Resource Name (ARN) of the deployment job.</p>
    pub arn: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the fleet.</p>
    pub fleet: std::option::Option<std::string::String>,
    /// <p>The status of the deployment job.</p>
    pub status: std::option::Option<crate::model::DeploymentStatus>,
    /// <p>The deployment application configuration.</p>
    pub deployment_application_configs:
        std::option::Option<std::vec::Vec<crate::model::DeploymentApplicationConfig>>,
    /// <p>The deployment configuration.</p>
    pub deployment_config: std::option::Option<crate::model::DeploymentConfig>,
    /// <p>A short description of the reason why the deployment job failed.</p>
    pub failure_reason: std::option::Option<std::string::String>,
    /// <p>The deployment job failure code.</p>
    pub failure_code: std::option::Option<crate::model::DeploymentJobErrorCode>,
    /// <p>The time, in milliseconds since the epoch, when the deployment job was created.</p>
    pub created_at: std::option::Option<aws_smithy_types::Instant>,
}
impl DeploymentJob {
    /// <p>The Amazon Resource Name (ARN) of the deployment job.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the fleet.</p>
    pub fn fleet(&self) -> std::option::Option<&str> {
        self.fleet.as_deref()
    }
    /// <p>The status of the deployment job.</p>
    pub fn status(&self) -> std::option::Option<&crate::model::DeploymentStatus> {
        self.status.as_ref()
    }
    /// <p>The deployment application configuration.</p>
    pub fn deployment_application_configs(
        &self,
    ) -> std::option::Option<&[crate::model::DeploymentApplicationConfig]> {
        self.deployment_application_configs.as_deref()
    }
    /// <p>The deployment configuration.</p>
    pub fn deployment_config(&self) -> std::option::Option<&crate::model::DeploymentConfig> {
        self.deployment_config.as_ref()
    }
    /// <p>A short description of the reason why the deployment job failed.</p>
    pub fn failure_reason(&self) -> std::option::Option<&str> {
        self.failure_reason.as_deref()
    }
    /// <p>The deployment job failure code.</p>
    pub fn failure_code(&self) -> std::option::Option<&crate::model::DeploymentJobErrorCode> {
        self.failure_code.as_ref()
    }
    /// <p>The time, in milliseconds since the epoch, when the deployment job was created.</p>
    pub fn created_at(&self) -> std::option::Option<&aws_smithy_types::Instant> {
        self.created_at.as_ref()
    }
}
impl std::fmt::Debug for DeploymentJob {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeploymentJob");
        formatter.field("arn", &self.arn);
        formatter.field("fleet", &self.fleet);
        formatter.field("status", &self.status);
        formatter.field(
            "deployment_application_configs",
            &self.deployment_application_configs,
        );
        formatter.field("deployment_config", &self.deployment_config);
        formatter.field("failure_reason", &self.failure_reason);
        formatter.field("failure_code", &self.failure_code);
        formatter.field("created_at", &self.created_at);
        formatter.finish()
    }
}
/// See [`DeploymentJob`](crate::model::DeploymentJob)
pub mod deployment_job {
    /// A builder for [`DeploymentJob`](crate::model::DeploymentJob)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) fleet: std::option::Option<std::string::String>,
        pub(crate) status: std::option::Option<crate::model::DeploymentStatus>,
        pub(crate) deployment_application_configs:
            std::option::Option<std::vec::Vec<crate::model::DeploymentApplicationConfig>>,
        pub(crate) deployment_config: std::option::Option<crate::model::DeploymentConfig>,
        pub(crate) failure_reason: std::option::Option<std::string::String>,
        pub(crate) failure_code: std::option::Option<crate::model::DeploymentJobErrorCode>,
        pub(crate) created_at: std::option::Option<aws_smithy_types::Instant>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the deployment job.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the deployment job.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the fleet.</p>
        pub fn fleet(mut self, input: impl Into<std::string::String>) -> Self {
            self.fleet = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the fleet.</p>
        pub fn set_fleet(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.fleet = input;
            self
        }
        /// <p>The status of the deployment job.</p>
        pub fn status(mut self, input: crate::model::DeploymentStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The status of the deployment job.</p>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::DeploymentStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// Appends an item to `deployment_application_configs`.
        ///
        /// To override the contents of this collection use [`set_deployment_application_configs`](Self::set_deployment_application_configs).
        ///
        /// <p>The deployment application configuration.</p>
        pub fn deployment_application_configs(
            mut self,
            input: impl Into<crate::model::DeploymentApplicationConfig>,
        ) -> Self {
            let mut v = self.deployment_application_configs.unwrap_or_default();
            v.push(input.into());
            self.deployment_application_configs = Some(v);
            self
        }
        /// <p>The deployment application configuration.</p>
        pub fn set_deployment_application_configs(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::DeploymentApplicationConfig>>,
        ) -> Self {
            self.deployment_application_configs = input;
            self
        }
        /// <p>The deployment configuration.</p>
        pub fn deployment_config(mut self, input: crate::model::DeploymentConfig) -> Self {
            self.deployment_config = Some(input);
            self
        }
        /// <p>The deployment configuration.</p>
        pub fn set_deployment_config(
            mut self,
            input: std::option::Option<crate::model::DeploymentConfig>,
        ) -> Self {
            self.deployment_config = input;
            self
        }
        /// <p>A short description of the reason why the deployment job failed.</p>
        pub fn failure_reason(mut self, input: impl Into<std::string::String>) -> Self {
            self.failure_reason = Some(input.into());
            self
        }
        /// <p>A short description of the reason why the deployment job failed.</p>
        pub fn set_failure_reason(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.failure_reason = input;
            self
        }
        /// <p>The deployment job failure code.</p>
        pub fn failure_code(mut self, input: crate::model::DeploymentJobErrorCode) -> Self {
            self.failure_code = Some(input);
            self
        }
        /// <p>The deployment job failure code.</p>
        pub fn set_failure_code(
            mut self,
            input: std::option::Option<crate::model::DeploymentJobErrorCode>,
        ) -> Self {
            self.failure_code = input;
            self
        }
        /// <p>The time, in milliseconds since the epoch, when the deployment job was created.</p>
        pub fn created_at(mut self, input: aws_smithy_types::Instant) -> Self {
            self.created_at = Some(input);
            self
        }
        /// <p>The time, in milliseconds since the epoch, when the deployment job was created.</p>
        pub fn set_created_at(
            mut self,
            input: std::option::Option<aws_smithy_types::Instant>,
        ) -> Self {
            self.created_at = input;
            self
        }
        /// Consumes the builder and constructs a [`DeploymentJob`](crate::model::DeploymentJob)
        pub fn build(self) -> crate::model::DeploymentJob {
            crate::model::DeploymentJob {
                arn: self.arn,
                fleet: self.fleet,
                status: self.status,
                deployment_application_configs: self.deployment_application_configs,
                deployment_config: self.deployment_config,
                failure_reason: self.failure_reason,
                failure_code: self.failure_code,
                created_at: self.created_at,
            }
        }
    }
}
impl DeploymentJob {
    /// Creates a new builder-style object to manufacture [`DeploymentJob`](crate::model::DeploymentJob)
    pub fn builder() -> crate::model::deployment_job::Builder {
        crate::model::deployment_job::Builder::default()
    }
}

/// <p>Information about worlds that finished.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct FinishedWorldsSummary {
    /// <p>The total number of finished worlds.</p>
    pub finished_count: i32,
    /// <p>A list of worlds that succeeded.</p>
    pub succeeded_worlds: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>Information about worlds that failed.</p>
    pub failure_summary: std::option::Option<crate::model::FailureSummary>,
}
impl FinishedWorldsSummary {
    /// <p>The total number of finished worlds.</p>
    pub fn finished_count(&self) -> i32 {
        self.finished_count
    }
    /// <p>A list of worlds that succeeded.</p>
    pub fn succeeded_worlds(&self) -> std::option::Option<&[std::string::String]> {
        self.succeeded_worlds.as_deref()
    }
    /// <p>Information about worlds that failed.</p>
    pub fn failure_summary(&self) -> std::option::Option<&crate::model::FailureSummary> {
        self.failure_summary.as_ref()
    }
}
impl std::fmt::Debug for FinishedWorldsSummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("FinishedWorldsSummary");
        formatter.field("finished_count", &self.finished_count);
        formatter.field("succeeded_worlds", &self.succeeded_worlds);
        formatter.field("failure_summary", &self.failure_summary);
        formatter.finish()
    }
}
/// See [`FinishedWorldsSummary`](crate::model::FinishedWorldsSummary)
pub mod finished_worlds_summary {
    /// A builder for [`FinishedWorldsSummary`](crate::model::FinishedWorldsSummary)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) finished_count: std::option::Option<i32>,
        pub(crate) succeeded_worlds: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) failure_summary: std::option::Option<crate::model::FailureSummary>,
    }
    impl Builder {
        /// <p>The total number of finished worlds.</p>
        pub fn finished_count(mut self, input: i32) -> Self {
            self.finished_count = Some(input);
            self
        }
        /// <p>The total number of finished worlds.</p>
        pub fn set_finished_count(mut self, input: std::option::Option<i32>) -> Self {
            self.finished_count = input;
            self
        }
        /// Appends an item to `succeeded_worlds`.
        ///
        /// To override the contents of this collection use [`set_succeeded_worlds`](Self::set_succeeded_worlds).
        ///
        /// <p>A list of worlds that succeeded.</p>
        pub fn succeeded_worlds(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.succeeded_worlds.unwrap_or_default();
            v.push(input.into());
            self.succeeded_worlds = Some(v);
            self
        }
        /// <p>A list of worlds that succeeded.</p>
        pub fn set_succeeded_worlds(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.succeeded_worlds = input;
            self
        }
        /// <p>Information about worlds that failed.</p>
        pub fn failure_summary(mut self, input: crate::model::FailureSummary) -> Self {
            self.failure_summary = Some(input);
            self
        }
        /// <p>Information about worlds that failed.</p>
        pub fn set_failure_summary(
            mut self,
            input: std::option::Option<crate::model::FailureSummary>,
        ) -> Self {
            self.failure_summary = input;
            self
        }
        /// Consumes the builder and constructs a [`FinishedWorldsSummary`](crate::model::FinishedWorldsSummary)
        pub fn build(self) -> crate::model::FinishedWorldsSummary {
            crate::model::FinishedWorldsSummary {
                finished_count: self.finished_count.unwrap_or_default(),
                succeeded_worlds: self.succeeded_worlds,
                failure_summary: self.failure_summary,
            }
        }
    }
}
impl FinishedWorldsSummary {
    /// Creates a new builder-style object to manufacture [`FinishedWorldsSummary`](crate::model::FinishedWorldsSummary)
    pub fn builder() -> crate::model::finished_worlds_summary::Builder {
        crate::model::finished_worlds_summary::Builder::default()
    }
}

/// <p>Information about worlds that failed.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct FailureSummary {
    /// <p>The total number of failures.</p>
    pub total_failure_count: i32,
    /// <p>The worlds that failed.</p>
    pub failures: std::option::Option<std::vec::Vec<crate::model::WorldFailure>>,
}
impl FailureSummary {
    /// <p>The total number of failures.</p>
    pub fn total_failure_count(&self) -> i32 {
        self.total_failure_count
    }
    /// <p>The worlds that failed.</p>
    pub fn failures(&self) -> std::option::Option<&[crate::model::WorldFailure]> {
        self.failures.as_deref()
    }
}
impl std::fmt::Debug for FailureSummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("FailureSummary");
        formatter.field("total_failure_count", &self.total_failure_count);
        formatter.field("failures", &self.failures);
        formatter.finish()
    }
}
/// See [`FailureSummary`](crate::model::FailureSummary)
pub mod failure_summary {
    /// A builder for [`FailureSummary`](crate::model::FailureSummary)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) total_failure_count: std::option::Option<i32>,
        pub(crate) failures: std::option::Option<std::vec::Vec<crate::model::WorldFailure>>,
    }
    impl Builder {
        /// <p>The total number of failures.</p>
        pub fn total_failure_count(mut self, input: i32) -> Self {
            self.total_failure_count = Some(input);
            self
        }
        /// <p>The total number of failures.</p>
        pub fn set_total_failure_count(mut self, input: std::option::Option<i32>) -> Self {
            self.total_failure_count = input;
            self
        }
        /// Appends an item to `failures`.
        ///
        /// To override the contents of this collection use [`set_failures`](Self::set_failures).
        ///
        /// <p>The worlds that failed.</p>
        pub fn failures(mut self, input: impl Into<crate::model::WorldFailure>) -> Self {
            let mut v = self.failures.unwrap_or_default();
            v.push(input.into());
            self.failures = Some(v);
            self
        }
        /// <p>The worlds that failed.</p>
        pub fn set_failures(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::WorldFailure>>,
        ) -> Self {
            self.failures = input;
            self
        }
        /// Consumes the builder and constructs a [`FailureSummary`](crate::model::FailureSummary)
        pub fn build(self) -> crate::model::FailureSummary {
            crate::model::FailureSummary {
                total_failure_count: self.total_failure_count.unwrap_or_default(),
                failures: self.failures,
            }
        }
    }
}
impl FailureSummary {
    /// Creates a new builder-style object to manufacture [`FailureSummary`](crate::model::FailureSummary)
    pub fn builder() -> crate::model::failure_summary::Builder {
        crate::model::failure_summary::Builder::default()
    }
}

/// <p>Information about a failed world.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct WorldFailure {
    /// <p>The failure code of the world export job if it failed:</p>
    /// <dl>
    /// <dt>InternalServiceError</dt>
    /// <dd>
    /// <p>Internal service error.</p>
    /// </dd>
    /// <dt>LimitExceeded</dt>
    /// <dd>
    /// <p>The requested resource exceeds the maximum number allowed, or the number of
    /// concurrent stream requests exceeds the maximum number allowed. </p>
    /// </dd>
    /// <dt>ResourceNotFound</dt>
    /// <dd>
    /// <p>The specified resource could not be found. </p>
    /// </dd>
    /// <dt>RequestThrottled</dt>
    /// <dd>
    /// <p>The request was throttled.</p>
    /// </dd>
    /// <dt>InvalidInput</dt>
    /// <dd>
    /// <p>An input parameter in the request is not valid.</p>
    /// </dd>
    /// </dl>
    pub failure_code: std::option::Option<crate::model::WorldGenerationJobErrorCode>,
    /// <p>The sample reason why the world failed. World errors are aggregated. A sample is used as
    /// the <code>sampleFailureReason</code>. </p>
    pub sample_failure_reason: std::option::Option<std::string::String>,
    /// <p>The number of failed worlds.</p>
    pub failure_count: i32,
}
impl WorldFailure {
    /// <p>The failure code of the world export job if it failed:</p>
    /// <dl>
    /// <dt>InternalServiceError</dt>
    /// <dd>
    /// <p>Internal service error.</p>
    /// </dd>
    /// <dt>LimitExceeded</dt>
    /// <dd>
    /// <p>The requested resource exceeds the maximum number allowed, or the number of
    /// concurrent stream requests exceeds the maximum number allowed. </p>
    /// </dd>
    /// <dt>ResourceNotFound</dt>
    /// <dd>
    /// <p>The specified resource could not be found. </p>
    /// </dd>
    /// <dt>RequestThrottled</dt>
    /// <dd>
    /// <p>The request was throttled.</p>
    /// </dd>
    /// <dt>InvalidInput</dt>
    /// <dd>
    /// <p>An input parameter in the request is not valid.</p>
    /// </dd>
    /// </dl>
    pub fn failure_code(&self) -> std::option::Option<&crate::model::WorldGenerationJobErrorCode> {
        self.failure_code.as_ref()
    }
    /// <p>The sample reason why the world failed. World errors are aggregated. A sample is used as
    /// the <code>sampleFailureReason</code>. </p>
    pub fn sample_failure_reason(&self) -> std::option::Option<&str> {
        self.sample_failure_reason.as_deref()
    }
    /// <p>The number of failed worlds.</p>
    pub fn failure_count(&self) -> i32 {
        self.failure_count
    }
}
impl std::fmt::Debug for WorldFailure {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("WorldFailure");
        formatter.field("failure_code", &self.failure_code);
        formatter.field("sample_failure_reason", &self.sample_failure_reason);
        formatter.field("failure_count", &self.failure_count);
        formatter.finish()
    }
}
/// See [`WorldFailure`](crate::model::WorldFailure)
pub mod world_failure {
    /// A builder for [`WorldFailure`](crate::model::WorldFailure)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) failure_code: std::option::Option<crate::model::WorldGenerationJobErrorCode>,
        pub(crate) sample_failure_reason: std::option::Option<std::string::String>,
        pub(crate) failure_count: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The failure code of the world export job if it failed:</p>
        /// <dl>
        /// <dt>InternalServiceError</dt>
        /// <dd>
        /// <p>Internal service error.</p>
        /// </dd>
        /// <dt>LimitExceeded</dt>
        /// <dd>
        /// <p>The requested resource exceeds the maximum number allowed, or the number of
        /// concurrent stream requests exceeds the maximum number allowed. </p>
        /// </dd>
        /// <dt>ResourceNotFound</dt>
        /// <dd>
        /// <p>The specified resource could not be found. </p>
        /// </dd>
        /// <dt>RequestThrottled</dt>
        /// <dd>
        /// <p>The request was throttled.</p>
        /// </dd>
        /// <dt>InvalidInput</dt>
        /// <dd>
        /// <p>An input parameter in the request is not valid.</p>
        /// </dd>
        /// </dl>
        pub fn failure_code(mut self, input: crate::model::WorldGenerationJobErrorCode) -> Self {
            self.failure_code = Some(input);
            self
        }
        /// <p>The failure code of the world export job if it failed:</p>
        /// <dl>
        /// <dt>InternalServiceError</dt>
        /// <dd>
        /// <p>Internal service error.</p>
        /// </dd>
        /// <dt>LimitExceeded</dt>
        /// <dd>
        /// <p>The requested resource exceeds the maximum number allowed, or the number of
        /// concurrent stream requests exceeds the maximum number allowed. </p>
        /// </dd>
        /// <dt>ResourceNotFound</dt>
        /// <dd>
        /// <p>The specified resource could not be found. </p>
        /// </dd>
        /// <dt>RequestThrottled</dt>
        /// <dd>
        /// <p>The request was throttled.</p>
        /// </dd>
        /// <dt>InvalidInput</dt>
        /// <dd>
        /// <p>An input parameter in the request is not valid.</p>
        /// </dd>
        /// </dl>
        pub fn set_failure_code(
            mut self,
            input: std::option::Option<crate::model::WorldGenerationJobErrorCode>,
        ) -> Self {
            self.failure_code = input;
            self
        }
        /// <p>The sample reason why the world failed. World errors are aggregated. A sample is used as
        /// the <code>sampleFailureReason</code>. </p>
        pub fn sample_failure_reason(mut self, input: impl Into<std::string::String>) -> Self {
            self.sample_failure_reason = Some(input.into());
            self
        }
        /// <p>The sample reason why the world failed. World errors are aggregated. A sample is used as
        /// the <code>sampleFailureReason</code>. </p>
        pub fn set_sample_failure_reason(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.sample_failure_reason = input;
            self
        }
        /// <p>The number of failed worlds.</p>
        pub fn failure_count(mut self, input: i32) -> Self {
            self.failure_count = Some(input);
            self
        }
        /// <p>The number of failed worlds.</p>
        pub fn set_failure_count(mut self, input: std::option::Option<i32>) -> Self {
            self.failure_count = input;
            self
        }
        /// Consumes the builder and constructs a [`WorldFailure`](crate::model::WorldFailure)
        pub fn build(self) -> crate::model::WorldFailure {
            crate::model::WorldFailure {
                failure_code: self.failure_code,
                sample_failure_reason: self.sample_failure_reason,
                failure_count: self.failure_count.unwrap_or_default(),
            }
        }
    }
}
impl WorldFailure {
    /// Creates a new builder-style object to manufacture [`WorldFailure`](crate::model::WorldFailure)
    pub fn builder() -> crate::model::world_failure::Builder {
        crate::model::world_failure::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum WorldGenerationJobErrorCode {
    #[allow(missing_docs)] // documentation missing in model
    AllWorldGenerationFailed,
    #[allow(missing_docs)] // documentation missing in model
    InternalServiceError,
    #[allow(missing_docs)] // documentation missing in model
    InvalidInput,
    #[allow(missing_docs)] // documentation missing in model
    LimitExceeded,
    #[allow(missing_docs)] // documentation missing in model
    RequestThrottled,
    #[allow(missing_docs)] // documentation missing in model
    ResourceNotFound,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for WorldGenerationJobErrorCode {
    fn from(s: &str) -> Self {
        match s {
            "AllWorldGenerationFailed" => WorldGenerationJobErrorCode::AllWorldGenerationFailed,
            "InternalServiceError" => WorldGenerationJobErrorCode::InternalServiceError,
            "InvalidInput" => WorldGenerationJobErrorCode::InvalidInput,
            "LimitExceeded" => WorldGenerationJobErrorCode::LimitExceeded,
            "RequestThrottled" => WorldGenerationJobErrorCode::RequestThrottled,
            "ResourceNotFound" => WorldGenerationJobErrorCode::ResourceNotFound,
            other => WorldGenerationJobErrorCode::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for WorldGenerationJobErrorCode {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(WorldGenerationJobErrorCode::from(s))
    }
}
impl WorldGenerationJobErrorCode {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            WorldGenerationJobErrorCode::AllWorldGenerationFailed => "AllWorldGenerationFailed",
            WorldGenerationJobErrorCode::InternalServiceError => "InternalServiceError",
            WorldGenerationJobErrorCode::InvalidInput => "InvalidInput",
            WorldGenerationJobErrorCode::LimitExceeded => "LimitExceeded",
            WorldGenerationJobErrorCode::RequestThrottled => "RequestThrottled",
            WorldGenerationJobErrorCode::ResourceNotFound => "ResourceNotFound",
            WorldGenerationJobErrorCode::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &[
            "AllWorldGenerationFailed",
            "InternalServiceError",
            "InvalidInput",
            "LimitExceeded",
            "RequestThrottled",
            "ResourceNotFound",
        ]
    }
}
impl AsRef<str> for WorldGenerationJobErrorCode {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum WorldExportJobErrorCode {
    #[allow(missing_docs)] // documentation missing in model
    AccessDenied,
    #[allow(missing_docs)] // documentation missing in model
    InternalServiceError,
    #[allow(missing_docs)] // documentation missing in model
    InvalidInput,
    #[allow(missing_docs)] // documentation missing in model
    LimitExceeded,
    #[allow(missing_docs)] // documentation missing in model
    RequestThrottled,
    #[allow(missing_docs)] // documentation missing in model
    ResourceNotFound,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for WorldExportJobErrorCode {
    fn from(s: &str) -> Self {
        match s {
            "AccessDenied" => WorldExportJobErrorCode::AccessDenied,
            "InternalServiceError" => WorldExportJobErrorCode::InternalServiceError,
            "InvalidInput" => WorldExportJobErrorCode::InvalidInput,
            "LimitExceeded" => WorldExportJobErrorCode::LimitExceeded,
            "RequestThrottled" => WorldExportJobErrorCode::RequestThrottled,
            "ResourceNotFound" => WorldExportJobErrorCode::ResourceNotFound,
            other => WorldExportJobErrorCode::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for WorldExportJobErrorCode {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(WorldExportJobErrorCode::from(s))
    }
}
impl WorldExportJobErrorCode {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            WorldExportJobErrorCode::AccessDenied => "AccessDenied",
            WorldExportJobErrorCode::InternalServiceError => "InternalServiceError",
            WorldExportJobErrorCode::InvalidInput => "InvalidInput",
            WorldExportJobErrorCode::LimitExceeded => "LimitExceeded",
            WorldExportJobErrorCode::RequestThrottled => "RequestThrottled",
            WorldExportJobErrorCode::ResourceNotFound => "ResourceNotFound",
            WorldExportJobErrorCode::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &[
            "AccessDenied",
            "InternalServiceError",
            "InvalidInput",
            "LimitExceeded",
            "RequestThrottled",
            "ResourceNotFound",
        ]
    }
}
impl AsRef<str> for WorldExportJobErrorCode {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Compute information for the simulation job</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ComputeResponse {
    /// <p>The simulation unit limit. Your simulation is allocated CPU and memory proportional to
    /// the supplied simulation unit limit. A simulation unit is 1 vcpu and 2GB of memory. You are
    /// only billed for the SU utilization you consume up to the maximum value provided. The
    /// default is 15. </p>
    pub simulation_unit_limit: std::option::Option<i32>,
    /// <p>Compute type response information for the simulation job.</p>
    pub compute_type: std::option::Option<crate::model::ComputeType>,
    /// <p>Compute GPU unit limit for the simulation job. It is the same as the number of GPUs
    /// allocated to the SimulationJob.</p>
    pub gpu_unit_limit: std::option::Option<i32>,
}
impl ComputeResponse {
    /// <p>The simulation unit limit. Your simulation is allocated CPU and memory proportional to
    /// the supplied simulation unit limit. A simulation unit is 1 vcpu and 2GB of memory. You are
    /// only billed for the SU utilization you consume up to the maximum value provided. The
    /// default is 15. </p>
    pub fn simulation_unit_limit(&self) -> std::option::Option<i32> {
        self.simulation_unit_limit
    }
    /// <p>Compute type response information for the simulation job.</p>
    pub fn compute_type(&self) -> std::option::Option<&crate::model::ComputeType> {
        self.compute_type.as_ref()
    }
    /// <p>Compute GPU unit limit for the simulation job. It is the same as the number of GPUs
    /// allocated to the SimulationJob.</p>
    pub fn gpu_unit_limit(&self) -> std::option::Option<i32> {
        self.gpu_unit_limit
    }
}
impl std::fmt::Debug for ComputeResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ComputeResponse");
        formatter.field("simulation_unit_limit", &self.simulation_unit_limit);
        formatter.field("compute_type", &self.compute_type);
        formatter.field("gpu_unit_limit", &self.gpu_unit_limit);
        formatter.finish()
    }
}
/// See [`ComputeResponse`](crate::model::ComputeResponse)
pub mod compute_response {
    /// A builder for [`ComputeResponse`](crate::model::ComputeResponse)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) simulation_unit_limit: std::option::Option<i32>,
        pub(crate) compute_type: std::option::Option<crate::model::ComputeType>,
        pub(crate) gpu_unit_limit: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The simulation unit limit. Your simulation is allocated CPU and memory proportional to
        /// the supplied simulation unit limit. A simulation unit is 1 vcpu and 2GB of memory. You are
        /// only billed for the SU utilization you consume up to the maximum value provided. The
        /// default is 15. </p>
        pub fn simulation_unit_limit(mut self, input: i32) -> Self {
            self.simulation_unit_limit = Some(input);
            self
        }
        /// <p>The simulation unit limit. Your simulation is allocated CPU and memory proportional to
        /// the supplied simulation unit limit. A simulation unit is 1 vcpu and 2GB of memory. You are
        /// only billed for the SU utilization you consume up to the maximum value provided. The
        /// default is 15. </p>
        pub fn set_simulation_unit_limit(mut self, input: std::option::Option<i32>) -> Self {
            self.simulation_unit_limit = input;
            self
        }
        /// <p>Compute type response information for the simulation job.</p>
        pub fn compute_type(mut self, input: crate::model::ComputeType) -> Self {
            self.compute_type = Some(input);
            self
        }
        /// <p>Compute type response information for the simulation job.</p>
        pub fn set_compute_type(
            mut self,
            input: std::option::Option<crate::model::ComputeType>,
        ) -> Self {
            self.compute_type = input;
            self
        }
        /// <p>Compute GPU unit limit for the simulation job. It is the same as the number of GPUs
        /// allocated to the SimulationJob.</p>
        pub fn gpu_unit_limit(mut self, input: i32) -> Self {
            self.gpu_unit_limit = Some(input);
            self
        }
        /// <p>Compute GPU unit limit for the simulation job. It is the same as the number of GPUs
        /// allocated to the SimulationJob.</p>
        pub fn set_gpu_unit_limit(mut self, input: std::option::Option<i32>) -> Self {
            self.gpu_unit_limit = input;
            self
        }
        /// Consumes the builder and constructs a [`ComputeResponse`](crate::model::ComputeResponse)
        pub fn build(self) -> crate::model::ComputeResponse {
            crate::model::ComputeResponse {
                simulation_unit_limit: self.simulation_unit_limit,
                compute_type: self.compute_type,
                gpu_unit_limit: self.gpu_unit_limit,
            }
        }
    }
}
impl ComputeResponse {
    /// Creates a new builder-style object to manufacture [`ComputeResponse`](crate::model::ComputeResponse)
    pub fn builder() -> crate::model::compute_response::Builder {
        crate::model::compute_response::Builder::default()
    }
}

/// <p>Describes a network interface.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct NetworkInterface {
    /// <p>The ID of the network interface.</p>
    pub network_interface_id: std::option::Option<std::string::String>,
    /// <p>The IPv4 address of the network interface within the subnet.</p>
    pub private_ip_address: std::option::Option<std::string::String>,
    /// <p>The IPv4 public address of the network interface.</p>
    pub public_ip_address: std::option::Option<std::string::String>,
}
impl NetworkInterface {
    /// <p>The ID of the network interface.</p>
    pub fn network_interface_id(&self) -> std::option::Option<&str> {
        self.network_interface_id.as_deref()
    }
    /// <p>The IPv4 address of the network interface within the subnet.</p>
    pub fn private_ip_address(&self) -> std::option::Option<&str> {
        self.private_ip_address.as_deref()
    }
    /// <p>The IPv4 public address of the network interface.</p>
    pub fn public_ip_address(&self) -> std::option::Option<&str> {
        self.public_ip_address.as_deref()
    }
}
impl std::fmt::Debug for NetworkInterface {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("NetworkInterface");
        formatter.field("network_interface_id", &self.network_interface_id);
        formatter.field("private_ip_address", &self.private_ip_address);
        formatter.field("public_ip_address", &self.public_ip_address);
        formatter.finish()
    }
}
/// See [`NetworkInterface`](crate::model::NetworkInterface)
pub mod network_interface {
    /// A builder for [`NetworkInterface`](crate::model::NetworkInterface)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) network_interface_id: std::option::Option<std::string::String>,
        pub(crate) private_ip_address: std::option::Option<std::string::String>,
        pub(crate) public_ip_address: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the network interface.</p>
        pub fn network_interface_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.network_interface_id = Some(input.into());
            self
        }
        /// <p>The ID of the network interface.</p>
        pub fn set_network_interface_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.network_interface_id = input;
            self
        }
        /// <p>The IPv4 address of the network interface within the subnet.</p>
        pub fn private_ip_address(mut self, input: impl Into<std::string::String>) -> Self {
            self.private_ip_address = Some(input.into());
            self
        }
        /// <p>The IPv4 address of the network interface within the subnet.</p>
        pub fn set_private_ip_address(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.private_ip_address = input;
            self
        }
        /// <p>The IPv4 public address of the network interface.</p>
        pub fn public_ip_address(mut self, input: impl Into<std::string::String>) -> Self {
            self.public_ip_address = Some(input.into());
            self
        }
        /// <p>The IPv4 public address of the network interface.</p>
        pub fn set_public_ip_address(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.public_ip_address = input;
            self
        }
        /// Consumes the builder and constructs a [`NetworkInterface`](crate::model::NetworkInterface)
        pub fn build(self) -> crate::model::NetworkInterface {
            crate::model::NetworkInterface {
                network_interface_id: self.network_interface_id,
                private_ip_address: self.private_ip_address,
                public_ip_address: self.public_ip_address,
            }
        }
    }
}
impl NetworkInterface {
    /// Creates a new builder-style object to manufacture [`NetworkInterface`](crate::model::NetworkInterface)
    pub fn builder() -> crate::model::network_interface::Builder {
        crate::model::network_interface::Builder::default()
    }
}

/// <p>VPC configuration associated with your simulation job.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct VpcConfigResponse {
    /// <p>A list of subnet IDs associated with the simulation job.</p>
    pub subnets: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>A list of security group IDs associated with the simulation job.</p>
    pub security_groups: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The VPC ID associated with your simulation job.</p>
    pub vpc_id: std::option::Option<std::string::String>,
    /// <p>A boolean indicating if a public IP was assigned.</p>
    pub assign_public_ip: bool,
}
impl VpcConfigResponse {
    /// <p>A list of subnet IDs associated with the simulation job.</p>
    pub fn subnets(&self) -> std::option::Option<&[std::string::String]> {
        self.subnets.as_deref()
    }
    /// <p>A list of security group IDs associated with the simulation job.</p>
    pub fn security_groups(&self) -> std::option::Option<&[std::string::String]> {
        self.security_groups.as_deref()
    }
    /// <p>The VPC ID associated with your simulation job.</p>
    pub fn vpc_id(&self) -> std::option::Option<&str> {
        self.vpc_id.as_deref()
    }
    /// <p>A boolean indicating if a public IP was assigned.</p>
    pub fn assign_public_ip(&self) -> bool {
        self.assign_public_ip
    }
}
impl std::fmt::Debug for VpcConfigResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("VpcConfigResponse");
        formatter.field("subnets", &self.subnets);
        formatter.field("security_groups", &self.security_groups);
        formatter.field("vpc_id", &self.vpc_id);
        formatter.field("assign_public_ip", &self.assign_public_ip);
        formatter.finish()
    }
}
/// See [`VpcConfigResponse`](crate::model::VpcConfigResponse)
pub mod vpc_config_response {
    /// A builder for [`VpcConfigResponse`](crate::model::VpcConfigResponse)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) subnets: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) security_groups: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) vpc_id: std::option::Option<std::string::String>,
        pub(crate) assign_public_ip: std::option::Option<bool>,
    }
    impl Builder {
        /// Appends an item to `subnets`.
        ///
        /// To override the contents of this collection use [`set_subnets`](Self::set_subnets).
        ///
        /// <p>A list of subnet IDs associated with the simulation job.</p>
        pub fn subnets(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.subnets.unwrap_or_default();
            v.push(input.into());
            self.subnets = Some(v);
            self
        }
        /// <p>A list of subnet IDs associated with the simulation job.</p>
        pub fn set_subnets(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.subnets = input;
            self
        }
        /// Appends an item to `security_groups`.
        ///
        /// To override the contents of this collection use [`set_security_groups`](Self::set_security_groups).
        ///
        /// <p>A list of security group IDs associated with the simulation job.</p>
        pub fn security_groups(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.security_groups.unwrap_or_default();
            v.push(input.into());
            self.security_groups = Some(v);
            self
        }
        /// <p>A list of security group IDs associated with the simulation job.</p>
        pub fn set_security_groups(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.security_groups = input;
            self
        }
        /// <p>The VPC ID associated with your simulation job.</p>
        pub fn vpc_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.vpc_id = Some(input.into());
            self
        }
        /// <p>The VPC ID associated with your simulation job.</p>
        pub fn set_vpc_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.vpc_id = input;
            self
        }
        /// <p>A boolean indicating if a public IP was assigned.</p>
        pub fn assign_public_ip(mut self, input: bool) -> Self {
            self.assign_public_ip = Some(input);
            self
        }
        /// <p>A boolean indicating if a public IP was assigned.</p>
        pub fn set_assign_public_ip(mut self, input: std::option::Option<bool>) -> Self {
            self.assign_public_ip = input;
            self
        }
        /// Consumes the builder and constructs a [`VpcConfigResponse`](crate::model::VpcConfigResponse)
        pub fn build(self) -> crate::model::VpcConfigResponse {
            crate::model::VpcConfigResponse {
                subnets: self.subnets,
                security_groups: self.security_groups,
                vpc_id: self.vpc_id,
                assign_public_ip: self.assign_public_ip.unwrap_or_default(),
            }
        }
    }
}
impl VpcConfigResponse {
    /// Creates a new builder-style object to manufacture [`VpcConfigResponse`](crate::model::VpcConfigResponse)
    pub fn builder() -> crate::model::vpc_config_response::Builder {
        crate::model::vpc_config_response::Builder::default()
    }
}

/// <p>Information about a data source.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DataSource {
    /// <p>The name of the data source.</p>
    pub name: std::option::Option<std::string::String>,
    /// <p>The S3 bucket where the data files are located.</p>
    pub s3_bucket: std::option::Option<std::string::String>,
    /// <p>The list of S3 keys identifying the data source files.</p>
    pub s3_keys: std::option::Option<std::vec::Vec<crate::model::S3KeyOutput>>,
    /// <p>The data type for the data source that you're using for your container image or
    /// simulation job. You can use this field to specify whether your data source is an Archive,
    /// an Amazon S3 prefix, or a file.</p>
    /// <p>If you don't specify a field, the default value is <code>File</code>.</p>
    pub r#type: std::option::Option<crate::model::DataSourceType>,
    /// <p>The location where your files are mounted in the container image.</p>
    /// <p>If you've specified the <code>type</code> of the data source as an <code>Archive</code>,
    /// you must provide an Amazon S3 object key to your archive. The object key must point to
    /// either a <code>.zip</code> or <code>.tar.gz</code> file.</p>
    /// <p>If you've specified the <code>type</code> of the data source as a <code>Prefix</code>,
    /// you provide the Amazon S3 prefix that points to the files that you are using for your data
    /// source.</p>
    /// <p>If you've specified the <code>type</code> of the data source as a <code>File</code>, you
    /// provide the Amazon S3 path to the file that you're using as your data source.</p>
    pub destination: std::option::Option<std::string::String>,
}
impl DataSource {
    /// <p>The name of the data source.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The S3 bucket where the data files are located.</p>
    pub fn s3_bucket(&self) -> std::option::Option<&str> {
        self.s3_bucket.as_deref()
    }
    /// <p>The list of S3 keys identifying the data source files.</p>
    pub fn s3_keys(&self) -> std::option::Option<&[crate::model::S3KeyOutput]> {
        self.s3_keys.as_deref()
    }
    /// <p>The data type for the data source that you're using for your container image or
    /// simulation job. You can use this field to specify whether your data source is an Archive,
    /// an Amazon S3 prefix, or a file.</p>
    /// <p>If you don't specify a field, the default value is <code>File</code>.</p>
    pub fn r#type(&self) -> std::option::Option<&crate::model::DataSourceType> {
        self.r#type.as_ref()
    }
    /// <p>The location where your files are mounted in the container image.</p>
    /// <p>If you've specified the <code>type</code> of the data source as an <code>Archive</code>,
    /// you must provide an Amazon S3 object key to your archive. The object key must point to
    /// either a <code>.zip</code> or <code>.tar.gz</code> file.</p>
    /// <p>If you've specified the <code>type</code> of the data source as a <code>Prefix</code>,
    /// you provide the Amazon S3 prefix that points to the files that you are using for your data
    /// source.</p>
    /// <p>If you've specified the <code>type</code> of the data source as a <code>File</code>, you
    /// provide the Amazon S3 path to the file that you're using as your data source.</p>
    pub fn destination(&self) -> std::option::Option<&str> {
        self.destination.as_deref()
    }
}
impl std::fmt::Debug for DataSource {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DataSource");
        formatter.field("name", &self.name);
        formatter.field("s3_bucket", &self.s3_bucket);
        formatter.field("s3_keys", &self.s3_keys);
        formatter.field("r#type", &self.r#type);
        formatter.field("destination", &self.destination);
        formatter.finish()
    }
}
/// See [`DataSource`](crate::model::DataSource)
pub mod data_source {
    /// A builder for [`DataSource`](crate::model::DataSource)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) s3_bucket: std::option::Option<std::string::String>,
        pub(crate) s3_keys: std::option::Option<std::vec::Vec<crate::model::S3KeyOutput>>,
        pub(crate) r#type: std::option::Option<crate::model::DataSourceType>,
        pub(crate) destination: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the data source.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the data source.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The S3 bucket where the data files are located.</p>
        pub fn s3_bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.s3_bucket = Some(input.into());
            self
        }
        /// <p>The S3 bucket where the data files are located.</p>
        pub fn set_s3_bucket(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.s3_bucket = input;
            self
        }
        /// Appends an item to `s3_keys`.
        ///
        /// To override the contents of this collection use [`set_s3_keys`](Self::set_s3_keys).
        ///
        /// <p>The list of S3 keys identifying the data source files.</p>
        pub fn s3_keys(mut self, input: impl Into<crate::model::S3KeyOutput>) -> Self {
            let mut v = self.s3_keys.unwrap_or_default();
            v.push(input.into());
            self.s3_keys = Some(v);
            self
        }
        /// <p>The list of S3 keys identifying the data source files.</p>
        pub fn set_s3_keys(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::S3KeyOutput>>,
        ) -> Self {
            self.s3_keys = input;
            self
        }
        /// <p>The data type for the data source that you're using for your container image or
        /// simulation job. You can use this field to specify whether your data source is an Archive,
        /// an Amazon S3 prefix, or a file.</p>
        /// <p>If you don't specify a field, the default value is <code>File</code>.</p>
        pub fn r#type(mut self, input: crate::model::DataSourceType) -> Self {
            self.r#type = Some(input);
            self
        }
        /// <p>The data type for the data source that you're using for your container image or
        /// simulation job. You can use this field to specify whether your data source is an Archive,
        /// an Amazon S3 prefix, or a file.</p>
        /// <p>If you don't specify a field, the default value is <code>File</code>.</p>
        pub fn set_type(
            mut self,
            input: std::option::Option<crate::model::DataSourceType>,
        ) -> Self {
            self.r#type = input;
            self
        }
        /// <p>The location where your files are mounted in the container image.</p>
        /// <p>If you've specified the <code>type</code> of the data source as an <code>Archive</code>,
        /// you must provide an Amazon S3 object key to your archive. The object key must point to
        /// either a <code>.zip</code> or <code>.tar.gz</code> file.</p>
        /// <p>If you've specified the <code>type</code> of the data source as a <code>Prefix</code>,
        /// you provide the Amazon S3 prefix that points to the files that you are using for your data
        /// source.</p>
        /// <p>If you've specified the <code>type</code> of the data source as a <code>File</code>, you
        /// provide the Amazon S3 path to the file that you're using as your data source.</p>
        pub fn destination(mut self, input: impl Into<std::string::String>) -> Self {
            self.destination = Some(input.into());
            self
        }
        /// <p>The location where your files are mounted in the container image.</p>
        /// <p>If you've specified the <code>type</code> of the data source as an <code>Archive</code>,
        /// you must provide an Amazon S3 object key to your archive. The object key must point to
        /// either a <code>.zip</code> or <code>.tar.gz</code> file.</p>
        /// <p>If you've specified the <code>type</code> of the data source as a <code>Prefix</code>,
        /// you provide the Amazon S3 prefix that points to the files that you are using for your data
        /// source.</p>
        /// <p>If you've specified the <code>type</code> of the data source as a <code>File</code>, you
        /// provide the Amazon S3 path to the file that you're using as your data source.</p>
        pub fn set_destination(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.destination = input;
            self
        }
        /// Consumes the builder and constructs a [`DataSource`](crate::model::DataSource)
        pub fn build(self) -> crate::model::DataSource {
            crate::model::DataSource {
                name: self.name,
                s3_bucket: self.s3_bucket,
                s3_keys: self.s3_keys,
                r#type: self.r#type,
                destination: self.destination,
            }
        }
    }
}
impl DataSource {
    /// Creates a new builder-style object to manufacture [`DataSource`](crate::model::DataSource)
    pub fn builder() -> crate::model::data_source::Builder {
        crate::model::data_source::Builder::default()
    }
}

/// <p>Information about S3 keys.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct S3KeyOutput {
    /// <p>The S3 key.</p>
    pub s3_key: std::option::Option<std::string::String>,
    /// <p>The etag for the object.</p>
    pub etag: std::option::Option<std::string::String>,
}
impl S3KeyOutput {
    /// <p>The S3 key.</p>
    pub fn s3_key(&self) -> std::option::Option<&str> {
        self.s3_key.as_deref()
    }
    /// <p>The etag for the object.</p>
    pub fn etag(&self) -> std::option::Option<&str> {
        self.etag.as_deref()
    }
}
impl std::fmt::Debug for S3KeyOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("S3KeyOutput");
        formatter.field("s3_key", &self.s3_key);
        formatter.field("etag", &self.etag);
        formatter.finish()
    }
}
/// See [`S3KeyOutput`](crate::model::S3KeyOutput)
pub mod s3_key_output {
    /// A builder for [`S3KeyOutput`](crate::model::S3KeyOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) s3_key: std::option::Option<std::string::String>,
        pub(crate) etag: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The S3 key.</p>
        pub fn s3_key(mut self, input: impl Into<std::string::String>) -> Self {
            self.s3_key = Some(input.into());
            self
        }
        /// <p>The S3 key.</p>
        pub fn set_s3_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.s3_key = input;
            self
        }
        /// <p>The etag for the object.</p>
        pub fn etag(mut self, input: impl Into<std::string::String>) -> Self {
            self.etag = Some(input.into());
            self
        }
        /// <p>The etag for the object.</p>
        pub fn set_etag(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.etag = input;
            self
        }
        /// Consumes the builder and constructs a [`S3KeyOutput`](crate::model::S3KeyOutput)
        pub fn build(self) -> crate::model::S3KeyOutput {
            crate::model::S3KeyOutput {
                s3_key: self.s3_key,
                etag: self.etag,
            }
        }
    }
}
impl S3KeyOutput {
    /// Creates a new builder-style object to manufacture [`S3KeyOutput`](crate::model::S3KeyOutput)
    pub fn builder() -> crate::model::s3_key_output::Builder {
        crate::model::s3_key_output::Builder::default()
    }
}

/// <p>Information about a robot deployment.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct RobotDeployment {
    /// <p>The robot deployment Amazon Resource Name (ARN).</p>
    pub arn: std::option::Option<std::string::String>,
    /// <p>The time, in milliseconds since the epoch, when the deployment was started.</p>
    pub deployment_start_time: std::option::Option<aws_smithy_types::Instant>,
    /// <p>The time, in milliseconds since the epoch, when the deployment finished.</p>
    pub deployment_finish_time: std::option::Option<aws_smithy_types::Instant>,
    /// <p>The status of the robot deployment.</p>
    pub status: std::option::Option<crate::model::RobotStatus>,
    /// <p>Information about how the deployment is progressing.</p>
    pub progress_detail: std::option::Option<crate::model::ProgressDetail>,
    /// <p>A short description of the reason why the robot deployment failed.</p>
    pub failure_reason: std::option::Option<std::string::String>,
    /// <p>The robot deployment failure code.</p>
    pub failure_code: std::option::Option<crate::model::DeploymentJobErrorCode>,
}
impl RobotDeployment {
    /// <p>The robot deployment Amazon Resource Name (ARN).</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>The time, in milliseconds since the epoch, when the deployment was started.</p>
    pub fn deployment_start_time(&self) -> std::option::Option<&aws_smithy_types::Instant> {
        self.deployment_start_time.as_ref()
    }
    /// <p>The time, in milliseconds since the epoch, when the deployment finished.</p>
    pub fn deployment_finish_time(&self) -> std::option::Option<&aws_smithy_types::Instant> {
        self.deployment_finish_time.as_ref()
    }
    /// <p>The status of the robot deployment.</p>
    pub fn status(&self) -> std::option::Option<&crate::model::RobotStatus> {
        self.status.as_ref()
    }
    /// <p>Information about how the deployment is progressing.</p>
    pub fn progress_detail(&self) -> std::option::Option<&crate::model::ProgressDetail> {
        self.progress_detail.as_ref()
    }
    /// <p>A short description of the reason why the robot deployment failed.</p>
    pub fn failure_reason(&self) -> std::option::Option<&str> {
        self.failure_reason.as_deref()
    }
    /// <p>The robot deployment failure code.</p>
    pub fn failure_code(&self) -> std::option::Option<&crate::model::DeploymentJobErrorCode> {
        self.failure_code.as_ref()
    }
}
impl std::fmt::Debug for RobotDeployment {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("RobotDeployment");
        formatter.field("arn", &self.arn);
        formatter.field("deployment_start_time", &self.deployment_start_time);
        formatter.field("deployment_finish_time", &self.deployment_finish_time);
        formatter.field("status", &self.status);
        formatter.field("progress_detail", &self.progress_detail);
        formatter.field("failure_reason", &self.failure_reason);
        formatter.field("failure_code", &self.failure_code);
        formatter.finish()
    }
}
/// See [`RobotDeployment`](crate::model::RobotDeployment)
pub mod robot_deployment {
    /// A builder for [`RobotDeployment`](crate::model::RobotDeployment)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) deployment_start_time: std::option::Option<aws_smithy_types::Instant>,
        pub(crate) deployment_finish_time: std::option::Option<aws_smithy_types::Instant>,
        pub(crate) status: std::option::Option<crate::model::RobotStatus>,
        pub(crate) progress_detail: std::option::Option<crate::model::ProgressDetail>,
        pub(crate) failure_reason: std::option::Option<std::string::String>,
        pub(crate) failure_code: std::option::Option<crate::model::DeploymentJobErrorCode>,
    }
    impl Builder {
        /// <p>The robot deployment Amazon Resource Name (ARN).</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The robot deployment Amazon Resource Name (ARN).</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>The time, in milliseconds since the epoch, when the deployment was started.</p>
        pub fn deployment_start_time(mut self, input: aws_smithy_types::Instant) -> Self {
            self.deployment_start_time = Some(input);
            self
        }
        /// <p>The time, in milliseconds since the epoch, when the deployment was started.</p>
        pub fn set_deployment_start_time(
            mut self,
            input: std::option::Option<aws_smithy_types::Instant>,
        ) -> Self {
            self.deployment_start_time = input;
            self
        }
        /// <p>The time, in milliseconds since the epoch, when the deployment finished.</p>
        pub fn deployment_finish_time(mut self, input: aws_smithy_types::Instant) -> Self {
            self.deployment_finish_time = Some(input);
            self
        }
        /// <p>The time, in milliseconds since the epoch, when the deployment finished.</p>
        pub fn set_deployment_finish_time(
            mut self,
            input: std::option::Option<aws_smithy_types::Instant>,
        ) -> Self {
            self.deployment_finish_time = input;
            self
        }
        /// <p>The status of the robot deployment.</p>
        pub fn status(mut self, input: crate::model::RobotStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The status of the robot deployment.</p>
        pub fn set_status(mut self, input: std::option::Option<crate::model::RobotStatus>) -> Self {
            self.status = input;
            self
        }
        /// <p>Information about how the deployment is progressing.</p>
        pub fn progress_detail(mut self, input: crate::model::ProgressDetail) -> Self {
            self.progress_detail = Some(input);
            self
        }
        /// <p>Information about how the deployment is progressing.</p>
        pub fn set_progress_detail(
            mut self,
            input: std::option::Option<crate::model::ProgressDetail>,
        ) -> Self {
            self.progress_detail = input;
            self
        }
        /// <p>A short description of the reason why the robot deployment failed.</p>
        pub fn failure_reason(mut self, input: impl Into<std::string::String>) -> Self {
            self.failure_reason = Some(input.into());
            self
        }
        /// <p>A short description of the reason why the robot deployment failed.</p>
        pub fn set_failure_reason(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.failure_reason = input;
            self
        }
        /// <p>The robot deployment failure code.</p>
        pub fn failure_code(mut self, input: crate::model::DeploymentJobErrorCode) -> Self {
            self.failure_code = Some(input);
            self
        }
        /// <p>The robot deployment failure code.</p>
        pub fn set_failure_code(
            mut self,
            input: std::option::Option<crate::model::DeploymentJobErrorCode>,
        ) -> Self {
            self.failure_code = input;
            self
        }
        /// Consumes the builder and constructs a [`RobotDeployment`](crate::model::RobotDeployment)
        pub fn build(self) -> crate::model::RobotDeployment {
            crate::model::RobotDeployment {
                arn: self.arn,
                deployment_start_time: self.deployment_start_time,
                deployment_finish_time: self.deployment_finish_time,
                status: self.status,
                progress_detail: self.progress_detail,
                failure_reason: self.failure_reason,
                failure_code: self.failure_code,
            }
        }
    }
}
impl RobotDeployment {
    /// Creates a new builder-style object to manufacture [`RobotDeployment`](crate::model::RobotDeployment)
    pub fn builder() -> crate::model::robot_deployment::Builder {
        crate::model::robot_deployment::Builder::default()
    }
}

/// <p>Information about the progress of a deployment job.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ProgressDetail {
    /// <p>The current progress status.</p>
    /// <dl>
    /// <dt>Validating</dt>
    /// <dd>
    /// <p>Validating the deployment.</p>
    /// </dd>
    /// <dt>DownloadingExtracting</dt>
    /// <dd>
    /// <p>Downloading and extracting the bundle on the robot.</p>
    /// </dd>
    /// <dt>ExecutingPreLaunch</dt>
    /// <dd>
    /// <p>Executing pre-launch script(s) if provided.</p>
    /// </dd>
    /// <dt>Launching</dt>
    /// <dd>
    /// <p>Launching the robot application.</p>
    /// </dd>
    /// <dt>ExecutingPostLaunch</dt>
    /// <dd>
    /// <p>Executing post-launch script(s) if provided.</p>
    /// </dd>
    /// <dt>Finished</dt>
    /// <dd>
    /// <p>Deployment is complete.</p>
    /// </dd>
    /// </dl>
    pub current_progress: std::option::Option<crate::model::RobotDeploymentStep>,
    /// <p>Precentage of the step that is done. This currently only applies to the
    /// <code>Downloading/Extracting</code> step of the deployment. It is empty for other
    /// steps.</p>
    pub percent_done: std::option::Option<f32>,
    /// <p>Estimated amount of time in seconds remaining in the step. This currently only applies
    /// to the <code>Downloading/Extracting</code> step of the deployment. It is empty for other
    /// steps.</p>
    pub estimated_time_remaining_seconds: std::option::Option<i32>,
    /// <p>The Amazon Resource Name (ARN) of the deployment job.</p>
    pub target_resource: std::option::Option<std::string::String>,
}
impl ProgressDetail {
    /// <p>The current progress status.</p>
    /// <dl>
    /// <dt>Validating</dt>
    /// <dd>
    /// <p>Validating the deployment.</p>
    /// </dd>
    /// <dt>DownloadingExtracting</dt>
    /// <dd>
    /// <p>Downloading and extracting the bundle on the robot.</p>
    /// </dd>
    /// <dt>ExecutingPreLaunch</dt>
    /// <dd>
    /// <p>Executing pre-launch script(s) if provided.</p>
    /// </dd>
    /// <dt>Launching</dt>
    /// <dd>
    /// <p>Launching the robot application.</p>
    /// </dd>
    /// <dt>ExecutingPostLaunch</dt>
    /// <dd>
    /// <p>Executing post-launch script(s) if provided.</p>
    /// </dd>
    /// <dt>Finished</dt>
    /// <dd>
    /// <p>Deployment is complete.</p>
    /// </dd>
    /// </dl>
    pub fn current_progress(&self) -> std::option::Option<&crate::model::RobotDeploymentStep> {
        self.current_progress.as_ref()
    }
    /// <p>Precentage of the step that is done. This currently only applies to the
    /// <code>Downloading/Extracting</code> step of the deployment. It is empty for other
    /// steps.</p>
    pub fn percent_done(&self) -> std::option::Option<f32> {
        self.percent_done
    }
    /// <p>Estimated amount of time in seconds remaining in the step. This currently only applies
    /// to the <code>Downloading/Extracting</code> step of the deployment. It is empty for other
    /// steps.</p>
    pub fn estimated_time_remaining_seconds(&self) -> std::option::Option<i32> {
        self.estimated_time_remaining_seconds
    }
    /// <p>The Amazon Resource Name (ARN) of the deployment job.</p>
    pub fn target_resource(&self) -> std::option::Option<&str> {
        self.target_resource.as_deref()
    }
}
impl std::fmt::Debug for ProgressDetail {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ProgressDetail");
        formatter.field("current_progress", &self.current_progress);
        formatter.field("percent_done", &self.percent_done);
        formatter.field(
            "estimated_time_remaining_seconds",
            &self.estimated_time_remaining_seconds,
        );
        formatter.field("target_resource", &self.target_resource);
        formatter.finish()
    }
}
/// See [`ProgressDetail`](crate::model::ProgressDetail)
pub mod progress_detail {
    /// A builder for [`ProgressDetail`](crate::model::ProgressDetail)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) current_progress: std::option::Option<crate::model::RobotDeploymentStep>,
        pub(crate) percent_done: std::option::Option<f32>,
        pub(crate) estimated_time_remaining_seconds: std::option::Option<i32>,
        pub(crate) target_resource: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The current progress status.</p>
        /// <dl>
        /// <dt>Validating</dt>
        /// <dd>
        /// <p>Validating the deployment.</p>
        /// </dd>
        /// <dt>DownloadingExtracting</dt>
        /// <dd>
        /// <p>Downloading and extracting the bundle on the robot.</p>
        /// </dd>
        /// <dt>ExecutingPreLaunch</dt>
        /// <dd>
        /// <p>Executing pre-launch script(s) if provided.</p>
        /// </dd>
        /// <dt>Launching</dt>
        /// <dd>
        /// <p>Launching the robot application.</p>
        /// </dd>
        /// <dt>ExecutingPostLaunch</dt>
        /// <dd>
        /// <p>Executing post-launch script(s) if provided.</p>
        /// </dd>
        /// <dt>Finished</dt>
        /// <dd>
        /// <p>Deployment is complete.</p>
        /// </dd>
        /// </dl>
        pub fn current_progress(mut self, input: crate::model::RobotDeploymentStep) -> Self {
            self.current_progress = Some(input);
            self
        }
        /// <p>The current progress status.</p>
        /// <dl>
        /// <dt>Validating</dt>
        /// <dd>
        /// <p>Validating the deployment.</p>
        /// </dd>
        /// <dt>DownloadingExtracting</dt>
        /// <dd>
        /// <p>Downloading and extracting the bundle on the robot.</p>
        /// </dd>
        /// <dt>ExecutingPreLaunch</dt>
        /// <dd>
        /// <p>Executing pre-launch script(s) if provided.</p>
        /// </dd>
        /// <dt>Launching</dt>
        /// <dd>
        /// <p>Launching the robot application.</p>
        /// </dd>
        /// <dt>ExecutingPostLaunch</dt>
        /// <dd>
        /// <p>Executing post-launch script(s) if provided.</p>
        /// </dd>
        /// <dt>Finished</dt>
        /// <dd>
        /// <p>Deployment is complete.</p>
        /// </dd>
        /// </dl>
        pub fn set_current_progress(
            mut self,
            input: std::option::Option<crate::model::RobotDeploymentStep>,
        ) -> Self {
            self.current_progress = input;
            self
        }
        /// <p>Precentage of the step that is done. This currently only applies to the
        /// <code>Downloading/Extracting</code> step of the deployment. It is empty for other
        /// steps.</p>
        pub fn percent_done(mut self, input: f32) -> Self {
            self.percent_done = Some(input);
            self
        }
        /// <p>Precentage of the step that is done. This currently only applies to the
        /// <code>Downloading/Extracting</code> step of the deployment. It is empty for other
        /// steps.</p>
        pub fn set_percent_done(mut self, input: std::option::Option<f32>) -> Self {
            self.percent_done = input;
            self
        }
        /// <p>Estimated amount of time in seconds remaining in the step. This currently only applies
        /// to the <code>Downloading/Extracting</code> step of the deployment. It is empty for other
        /// steps.</p>
        pub fn estimated_time_remaining_seconds(mut self, input: i32) -> Self {
            self.estimated_time_remaining_seconds = Some(input);
            self
        }
        /// <p>Estimated amount of time in seconds remaining in the step. This currently only applies
        /// to the <code>Downloading/Extracting</code> step of the deployment. It is empty for other
        /// steps.</p>
        pub fn set_estimated_time_remaining_seconds(
            mut self,
            input: std::option::Option<i32>,
        ) -> Self {
            self.estimated_time_remaining_seconds = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the deployment job.</p>
        pub fn target_resource(mut self, input: impl Into<std::string::String>) -> Self {
            self.target_resource = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the deployment job.</p>
        pub fn set_target_resource(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.target_resource = input;
            self
        }
        /// Consumes the builder and constructs a [`ProgressDetail`](crate::model::ProgressDetail)
        pub fn build(self) -> crate::model::ProgressDetail {
            crate::model::ProgressDetail {
                current_progress: self.current_progress,
                percent_done: self.percent_done,
                estimated_time_remaining_seconds: self.estimated_time_remaining_seconds,
                target_resource: self.target_resource,
            }
        }
    }
}
impl ProgressDetail {
    /// Creates a new builder-style object to manufacture [`ProgressDetail`](crate::model::ProgressDetail)
    pub fn builder() -> crate::model::progress_detail::Builder {
        crate::model::progress_detail::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum RobotDeploymentStep {
    #[allow(missing_docs)] // documentation missing in model
    DownloadingExtractingStep,
    #[allow(missing_docs)] // documentation missing in model
    ExecutingDownloadCondition,
    #[allow(missing_docs)] // documentation missing in model
    PostLaunchStep,
    #[allow(missing_docs)] // documentation missing in model
    PreLaunchStep,
    #[allow(missing_docs)] // documentation missing in model
    FinishedStep,
    #[allow(missing_docs)] // documentation missing in model
    LaunchingStep,
    #[allow(missing_docs)] // documentation missing in model
    ValidatingStep,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for RobotDeploymentStep {
    fn from(s: &str) -> Self {
        match s {
            "DownloadingExtracting" => RobotDeploymentStep::DownloadingExtractingStep,
            "ExecutingDownloadCondition" => RobotDeploymentStep::ExecutingDownloadCondition,
            "ExecutingPostLaunch" => RobotDeploymentStep::PostLaunchStep,
            "ExecutingPreLaunch" => RobotDeploymentStep::PreLaunchStep,
            "Finished" => RobotDeploymentStep::FinishedStep,
            "Launching" => RobotDeploymentStep::LaunchingStep,
            "Validating" => RobotDeploymentStep::ValidatingStep,
            other => RobotDeploymentStep::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for RobotDeploymentStep {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(RobotDeploymentStep::from(s))
    }
}
impl RobotDeploymentStep {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            RobotDeploymentStep::DownloadingExtractingStep => "DownloadingExtracting",
            RobotDeploymentStep::ExecutingDownloadCondition => "ExecutingDownloadCondition",
            RobotDeploymentStep::PostLaunchStep => "ExecutingPostLaunch",
            RobotDeploymentStep::PreLaunchStep => "ExecutingPreLaunch",
            RobotDeploymentStep::FinishedStep => "Finished",
            RobotDeploymentStep::LaunchingStep => "Launching",
            RobotDeploymentStep::ValidatingStep => "Validating",
            RobotDeploymentStep::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &[
            "DownloadingExtracting",
            "ExecutingDownloadCondition",
            "ExecutingPostLaunch",
            "ExecutingPreLaunch",
            "Finished",
            "Launching",
            "Validating",
        ]
    }
}
impl AsRef<str> for RobotDeploymentStep {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Information about a simulation job.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SimulationJob {
    /// <p>The Amazon Resource Name (ARN) of the simulation job.</p>
    pub arn: std::option::Option<std::string::String>,
    /// <p>The name of the simulation job.</p>
    pub name: std::option::Option<std::string::String>,
    /// <p>Status of the simulation job.</p>
    pub status: std::option::Option<crate::model::SimulationJobStatus>,
    /// <p>The time, in milliseconds since the epoch, when the simulation job was last
    /// started.</p>
    pub last_started_at: std::option::Option<aws_smithy_types::Instant>,
    /// <p>The time, in milliseconds since the epoch, when the simulation job was last
    /// updated.</p>
    pub last_updated_at: std::option::Option<aws_smithy_types::Instant>,
    /// <p>The failure behavior the simulation job.</p>
    /// <dl>
    /// <dt>Continue</dt>
    /// <dd>
    /// <p>Leaves the host running for its maximum timeout duration after a
    /// <code>4XX</code> error code.</p>
    /// </dd>
    /// <dt>Fail</dt>
    /// <dd>
    /// <p>Stop the simulation job and terminate the instance.</p>
    /// </dd>
    /// </dl>
    pub failure_behavior: std::option::Option<crate::model::FailureBehavior>,
    /// <p>The failure code of the simulation job if it failed.</p>
    pub failure_code: std::option::Option<crate::model::SimulationJobErrorCode>,
    /// <p>The reason why the simulation job failed.</p>
    pub failure_reason: std::option::Option<std::string::String>,
    /// <p>A unique identifier for this <code>SimulationJob</code> request.</p>
    pub client_request_token: std::option::Option<std::string::String>,
    /// <p>Location for output files generated by the simulation job.</p>
    pub output_location: std::option::Option<crate::model::OutputLocation>,
    /// <p>The logging configuration.</p>
    pub logging_config: std::option::Option<crate::model::LoggingConfig>,
    /// <p>The maximum simulation job duration in seconds. The value must be 8 days (691,200
    /// seconds) or less.</p>
    pub max_job_duration_in_seconds: i64,
    /// <p>The simulation job execution duration in milliseconds.</p>
    pub simulation_time_millis: i64,
    /// <p>The IAM role that allows the simulation instance to call the AWS APIs that are specified
    /// in its associated policies on your behalf. This is how credentials are passed in to your
    /// simulation job. </p>
    pub iam_role: std::option::Option<std::string::String>,
    /// <p>A list of robot applications.</p>
    pub robot_applications:
        std::option::Option<std::vec::Vec<crate::model::RobotApplicationConfig>>,
    /// <p>A list of simulation applications.</p>
    pub simulation_applications:
        std::option::Option<std::vec::Vec<crate::model::SimulationApplicationConfig>>,
    /// <p>The data sources for the simulation job.</p>
    pub data_sources: std::option::Option<std::vec::Vec<crate::model::DataSource>>,
    /// <p>A map that contains tag keys and tag values that are attached to the simulation
    /// job.</p>
    pub tags:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>VPC configuration information.</p>
    pub vpc_config: std::option::Option<crate::model::VpcConfigResponse>,
    /// <p>Information about a network interface.</p>
    pub network_interface: std::option::Option<crate::model::NetworkInterface>,
    /// <p>Compute information for the simulation job</p>
    pub compute: std::option::Option<crate::model::ComputeResponse>,
}
impl SimulationJob {
    /// <p>The Amazon Resource Name (ARN) of the simulation job.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>The name of the simulation job.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>Status of the simulation job.</p>
    pub fn status(&self) -> std::option::Option<&crate::model::SimulationJobStatus> {
        self.status.as_ref()
    }
    /// <p>The time, in milliseconds since the epoch, when the simulation job was last
    /// started.</p>
    pub fn last_started_at(&self) -> std::option::Option<&aws_smithy_types::Instant> {
        self.last_started_at.as_ref()
    }
    /// <p>The time, in milliseconds since the epoch, when the simulation job was last
    /// updated.</p>
    pub fn last_updated_at(&self) -> std::option::Option<&aws_smithy_types::Instant> {
        self.last_updated_at.as_ref()
    }
    /// <p>The failure behavior the simulation job.</p>
    /// <dl>
    /// <dt>Continue</dt>
    /// <dd>
    /// <p>Leaves the host running for its maximum timeout duration after a
    /// <code>4XX</code> error code.</p>
    /// </dd>
    /// <dt>Fail</dt>
    /// <dd>
    /// <p>Stop the simulation job and terminate the instance.</p>
    /// </dd>
    /// </dl>
    pub fn failure_behavior(&self) -> std::option::Option<&crate::model::FailureBehavior> {
        self.failure_behavior.as_ref()
    }
    /// <p>The failure code of the simulation job if it failed.</p>
    pub fn failure_code(&self) -> std::option::Option<&crate::model::SimulationJobErrorCode> {
        self.failure_code.as_ref()
    }
    /// <p>The reason why the simulation job failed.</p>
    pub fn failure_reason(&self) -> std::option::Option<&str> {
        self.failure_reason.as_deref()
    }
    /// <p>A unique identifier for this <code>SimulationJob</code> request.</p>
    pub fn client_request_token(&self) -> std::option::Option<&str> {
        self.client_request_token.as_deref()
    }
    /// <p>Location for output files generated by the simulation job.</p>
    pub fn output_location(&self) -> std::option::Option<&crate::model::OutputLocation> {
        self.output_location.as_ref()
    }
    /// <p>The logging configuration.</p>
    pub fn logging_config(&self) -> std::option::Option<&crate::model::LoggingConfig> {
        self.logging_config.as_ref()
    }
    /// <p>The maximum simulation job duration in seconds. The value must be 8 days (691,200
    /// seconds) or less.</p>
    pub fn max_job_duration_in_seconds(&self) -> i64 {
        self.max_job_duration_in_seconds
    }
    /// <p>The simulation job execution duration in milliseconds.</p>
    pub fn simulation_time_millis(&self) -> i64 {
        self.simulation_time_millis
    }
    /// <p>The IAM role that allows the simulation instance to call the AWS APIs that are specified
    /// in its associated policies on your behalf. This is how credentials are passed in to your
    /// simulation job. </p>
    pub fn iam_role(&self) -> std::option::Option<&str> {
        self.iam_role.as_deref()
    }
    /// <p>A list of robot applications.</p>
    pub fn robot_applications(
        &self,
    ) -> std::option::Option<&[crate::model::RobotApplicationConfig]> {
        self.robot_applications.as_deref()
    }
    /// <p>A list of simulation applications.</p>
    pub fn simulation_applications(
        &self,
    ) -> std::option::Option<&[crate::model::SimulationApplicationConfig]> {
        self.simulation_applications.as_deref()
    }
    /// <p>The data sources for the simulation job.</p>
    pub fn data_sources(&self) -> std::option::Option<&[crate::model::DataSource]> {
        self.data_sources.as_deref()
    }
    /// <p>A map that contains tag keys and tag values that are attached to the simulation
    /// job.</p>
    pub fn tags(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.tags.as_ref()
    }
    /// <p>VPC configuration information.</p>
    pub fn vpc_config(&self) -> std::option::Option<&crate::model::VpcConfigResponse> {
        self.vpc_config.as_ref()
    }
    /// <p>Information about a network interface.</p>
    pub fn network_interface(&self) -> std::option::Option<&crate::model::NetworkInterface> {
        self.network_interface.as_ref()
    }
    /// <p>Compute information for the simulation job</p>
    pub fn compute(&self) -> std::option::Option<&crate::model::ComputeResponse> {
        self.compute.as_ref()
    }
}
impl std::fmt::Debug for SimulationJob {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SimulationJob");
        formatter.field("arn", &self.arn);
        formatter.field("name", &self.name);
        formatter.field("status", &self.status);
        formatter.field("last_started_at", &self.last_started_at);
        formatter.field("last_updated_at", &self.last_updated_at);
        formatter.field("failure_behavior", &self.failure_behavior);
        formatter.field("failure_code", &self.failure_code);
        formatter.field("failure_reason", &self.failure_reason);
        formatter.field("client_request_token", &self.client_request_token);
        formatter.field("output_location", &self.output_location);
        formatter.field("logging_config", &self.logging_config);
        formatter.field(
            "max_job_duration_in_seconds",
            &self.max_job_duration_in_seconds,
        );
        formatter.field("simulation_time_millis", &self.simulation_time_millis);
        formatter.field("iam_role", &self.iam_role);
        formatter.field("robot_applications", &self.robot_applications);
        formatter.field("simulation_applications", &self.simulation_applications);
        formatter.field("data_sources", &self.data_sources);
        formatter.field("tags", &self.tags);
        formatter.field("vpc_config", &self.vpc_config);
        formatter.field("network_interface", &self.network_interface);
        formatter.field("compute", &self.compute);
        formatter.finish()
    }
}
/// See [`SimulationJob`](crate::model::SimulationJob)
pub mod simulation_job {
    /// A builder for [`SimulationJob`](crate::model::SimulationJob)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) status: std::option::Option<crate::model::SimulationJobStatus>,
        pub(crate) last_started_at: std::option::Option<aws_smithy_types::Instant>,
        pub(crate) last_updated_at: std::option::Option<aws_smithy_types::Instant>,
        pub(crate) failure_behavior: std::option::Option<crate::model::FailureBehavior>,
        pub(crate) failure_code: std::option::Option<crate::model::SimulationJobErrorCode>,
        pub(crate) failure_reason: std::option::Option<std::string::String>,
        pub(crate) client_request_token: std::option::Option<std::string::String>,
        pub(crate) output_location: std::option::Option<crate::model::OutputLocation>,
        pub(crate) logging_config: std::option::Option<crate::model::LoggingConfig>,
        pub(crate) max_job_duration_in_seconds: std::option::Option<i64>,
        pub(crate) simulation_time_millis: std::option::Option<i64>,
        pub(crate) iam_role: std::option::Option<std::string::String>,
        pub(crate) robot_applications:
            std::option::Option<std::vec::Vec<crate::model::RobotApplicationConfig>>,
        pub(crate) simulation_applications:
            std::option::Option<std::vec::Vec<crate::model::SimulationApplicationConfig>>,
        pub(crate) data_sources: std::option::Option<std::vec::Vec<crate::model::DataSource>>,
        pub(crate) tags: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
        pub(crate) vpc_config: std::option::Option<crate::model::VpcConfigResponse>,
        pub(crate) network_interface: std::option::Option<crate::model::NetworkInterface>,
        pub(crate) compute: std::option::Option<crate::model::ComputeResponse>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the simulation job.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the simulation job.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>The name of the simulation job.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the simulation job.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>Status of the simulation job.</p>
        pub fn status(mut self, input: crate::model::SimulationJobStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>Status of the simulation job.</p>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::SimulationJobStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// <p>The time, in milliseconds since the epoch, when the simulation job was last
        /// started.</p>
        pub fn last_started_at(mut self, input: aws_smithy_types::Instant) -> Self {
            self.last_started_at = Some(input);
            self
        }
        /// <p>The time, in milliseconds since the epoch, when the simulation job was last
        /// started.</p>
        pub fn set_last_started_at(
            mut self,
            input: std::option::Option<aws_smithy_types::Instant>,
        ) -> Self {
            self.last_started_at = input;
            self
        }
        /// <p>The time, in milliseconds since the epoch, when the simulation job was last
        /// updated.</p>
        pub fn last_updated_at(mut self, input: aws_smithy_types::Instant) -> Self {
            self.last_updated_at = Some(input);
            self
        }
        /// <p>The time, in milliseconds since the epoch, when the simulation job was last
        /// updated.</p>
        pub fn set_last_updated_at(
            mut self,
            input: std::option::Option<aws_smithy_types::Instant>,
        ) -> Self {
            self.last_updated_at = input;
            self
        }
        /// <p>The failure behavior the simulation job.</p>
        /// <dl>
        /// <dt>Continue</dt>
        /// <dd>
        /// <p>Leaves the host running for its maximum timeout duration after a
        /// <code>4XX</code> error code.</p>
        /// </dd>
        /// <dt>Fail</dt>
        /// <dd>
        /// <p>Stop the simulation job and terminate the instance.</p>
        /// </dd>
        /// </dl>
        pub fn failure_behavior(mut self, input: crate::model::FailureBehavior) -> Self {
            self.failure_behavior = Some(input);
            self
        }
        /// <p>The failure behavior the simulation job.</p>
        /// <dl>
        /// <dt>Continue</dt>
        /// <dd>
        /// <p>Leaves the host running for its maximum timeout duration after a
        /// <code>4XX</code> error code.</p>
        /// </dd>
        /// <dt>Fail</dt>
        /// <dd>
        /// <p>Stop the simulation job and terminate the instance.</p>
        /// </dd>
        /// </dl>
        pub fn set_failure_behavior(
            mut self,
            input: std::option::Option<crate::model::FailureBehavior>,
        ) -> Self {
            self.failure_behavior = input;
            self
        }
        /// <p>The failure code of the simulation job if it failed.</p>
        pub fn failure_code(mut self, input: crate::model::SimulationJobErrorCode) -> Self {
            self.failure_code = Some(input);
            self
        }
        /// <p>The failure code of the simulation job if it failed.</p>
        pub fn set_failure_code(
            mut self,
            input: std::option::Option<crate::model::SimulationJobErrorCode>,
        ) -> Self {
            self.failure_code = input;
            self
        }
        /// <p>The reason why the simulation job failed.</p>
        pub fn failure_reason(mut self, input: impl Into<std::string::String>) -> Self {
            self.failure_reason = Some(input.into());
            self
        }
        /// <p>The reason why the simulation job failed.</p>
        pub fn set_failure_reason(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.failure_reason = input;
            self
        }
        /// <p>A unique identifier for this <code>SimulationJob</code> request.</p>
        pub fn client_request_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.client_request_token = Some(input.into());
            self
        }
        /// <p>A unique identifier for this <code>SimulationJob</code> request.</p>
        pub fn set_client_request_token(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.client_request_token = input;
            self
        }
        /// <p>Location for output files generated by the simulation job.</p>
        pub fn output_location(mut self, input: crate::model::OutputLocation) -> Self {
            self.output_location = Some(input);
            self
        }
        /// <p>Location for output files generated by the simulation job.</p>
        pub fn set_output_location(
            mut self,
            input: std::option::Option<crate::model::OutputLocation>,
        ) -> Self {
            self.output_location = input;
            self
        }
        /// <p>The logging configuration.</p>
        pub fn logging_config(mut self, input: crate::model::LoggingConfig) -> Self {
            self.logging_config = Some(input);
            self
        }
        /// <p>The logging configuration.</p>
        pub fn set_logging_config(
            mut self,
            input: std::option::Option<crate::model::LoggingConfig>,
        ) -> Self {
            self.logging_config = input;
            self
        }
        /// <p>The maximum simulation job duration in seconds. The value must be 8 days (691,200
        /// seconds) or less.</p>
        pub fn max_job_duration_in_seconds(mut self, input: i64) -> Self {
            self.max_job_duration_in_seconds = Some(input);
            self
        }
        /// <p>The maximum simulation job duration in seconds. The value must be 8 days (691,200
        /// seconds) or less.</p>
        pub fn set_max_job_duration_in_seconds(mut self, input: std::option::Option<i64>) -> Self {
            self.max_job_duration_in_seconds = input;
            self
        }
        /// <p>The simulation job execution duration in milliseconds.</p>
        pub fn simulation_time_millis(mut self, input: i64) -> Self {
            self.simulation_time_millis = Some(input);
            self
        }
        /// <p>The simulation job execution duration in milliseconds.</p>
        pub fn set_simulation_time_millis(mut self, input: std::option::Option<i64>) -> Self {
            self.simulation_time_millis = input;
            self
        }
        /// <p>The IAM role that allows the simulation instance to call the AWS APIs that are specified
        /// in its associated policies on your behalf. This is how credentials are passed in to your
        /// simulation job. </p>
        pub fn iam_role(mut self, input: impl Into<std::string::String>) -> Self {
            self.iam_role = Some(input.into());
            self
        }
        /// <p>The IAM role that allows the simulation instance to call the AWS APIs that are specified
        /// in its associated policies on your behalf. This is how credentials are passed in to your
        /// simulation job. </p>
        pub fn set_iam_role(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.iam_role = input;
            self
        }
        /// Appends an item to `robot_applications`.
        ///
        /// To override the contents of this collection use [`set_robot_applications`](Self::set_robot_applications).
        ///
        /// <p>A list of robot applications.</p>
        pub fn robot_applications(
            mut self,
            input: impl Into<crate::model::RobotApplicationConfig>,
        ) -> Self {
            let mut v = self.robot_applications.unwrap_or_default();
            v.push(input.into());
            self.robot_applications = Some(v);
            self
        }
        /// <p>A list of robot applications.</p>
        pub fn set_robot_applications(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::RobotApplicationConfig>>,
        ) -> Self {
            self.robot_applications = input;
            self
        }
        /// Appends an item to `simulation_applications`.
        ///
        /// To override the contents of this collection use [`set_simulation_applications`](Self::set_simulation_applications).
        ///
        /// <p>A list of simulation applications.</p>
        pub fn simulation_applications(
            mut self,
            input: impl Into<crate::model::SimulationApplicationConfig>,
        ) -> Self {
            let mut v = self.simulation_applications.unwrap_or_default();
            v.push(input.into());
            self.simulation_applications = Some(v);
            self
        }
        /// <p>A list of simulation applications.</p>
        pub fn set_simulation_applications(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::SimulationApplicationConfig>>,
        ) -> Self {
            self.simulation_applications = input;
            self
        }
        /// Appends an item to `data_sources`.
        ///
        /// To override the contents of this collection use [`set_data_sources`](Self::set_data_sources).
        ///
        /// <p>The data sources for the simulation job.</p>
        pub fn data_sources(mut self, input: impl Into<crate::model::DataSource>) -> Self {
            let mut v = self.data_sources.unwrap_or_default();
            v.push(input.into());
            self.data_sources = Some(v);
            self
        }
        /// <p>The data sources for the simulation job.</p>
        pub fn set_data_sources(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::DataSource>>,
        ) -> Self {
            self.data_sources = input;
            self
        }
        /// Adds a key-value pair to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>A map that contains tag keys and tag values that are attached to the simulation
        /// job.</p>
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.tags.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.tags = Some(hash_map);
            self
        }
        /// <p>A map that contains tag keys and tag values that are attached to the simulation
        /// job.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.tags = input;
            self
        }
        /// <p>VPC configuration information.</p>
        pub fn vpc_config(mut self, input: crate::model::VpcConfigResponse) -> Self {
            self.vpc_config = Some(input);
            self
        }
        /// <p>VPC configuration information.</p>
        pub fn set_vpc_config(
            mut self,
            input: std::option::Option<crate::model::VpcConfigResponse>,
        ) -> Self {
            self.vpc_config = input;
            self
        }
        /// <p>Information about a network interface.</p>
        pub fn network_interface(mut self, input: crate::model::NetworkInterface) -> Self {
            self.network_interface = Some(input);
            self
        }
        /// <p>Information about a network interface.</p>
        pub fn set_network_interface(
            mut self,
            input: std::option::Option<crate::model::NetworkInterface>,
        ) -> Self {
            self.network_interface = input;
            self
        }
        /// <p>Compute information for the simulation job</p>
        pub fn compute(mut self, input: crate::model::ComputeResponse) -> Self {
            self.compute = Some(input);
            self
        }
        /// <p>Compute information for the simulation job</p>
        pub fn set_compute(
            mut self,
            input: std::option::Option<crate::model::ComputeResponse>,
        ) -> Self {
            self.compute = input;
            self
        }
        /// Consumes the builder and constructs a [`SimulationJob`](crate::model::SimulationJob)
        pub fn build(self) -> crate::model::SimulationJob {
            crate::model::SimulationJob {
                arn: self.arn,
                name: self.name,
                status: self.status,
                last_started_at: self.last_started_at,
                last_updated_at: self.last_updated_at,
                failure_behavior: self.failure_behavior,
                failure_code: self.failure_code,
                failure_reason: self.failure_reason,
                client_request_token: self.client_request_token,
                output_location: self.output_location,
                logging_config: self.logging_config,
                max_job_duration_in_seconds: self.max_job_duration_in_seconds.unwrap_or_default(),
                simulation_time_millis: self.simulation_time_millis.unwrap_or_default(),
                iam_role: self.iam_role,
                robot_applications: self.robot_applications,
                simulation_applications: self.simulation_applications,
                data_sources: self.data_sources,
                tags: self.tags,
                vpc_config: self.vpc_config,
                network_interface: self.network_interface,
                compute: self.compute,
            }
        }
    }
}
impl SimulationJob {
    /// Creates a new builder-style object to manufacture [`SimulationJob`](crate::model::SimulationJob)
    pub fn builder() -> crate::model::simulation_job::Builder {
        crate::model::simulation_job::Builder::default()
    }
}
