// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>Information about a data source.</p>
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct DataSourceConfig {
    /// <p>The name of the data source.</p>
    pub name: ::std::string::String,
    /// <p>The S3 bucket where the data files are located.</p>
    pub s3_bucket: ::std::string::String,
    /// <p>The list of S3 keys identifying the data source files.</p>
    pub s3_keys: ::std::vec::Vec<::std::string::String>,
    /// <p>The data type for the data source that you're using for your container image or simulation job. You can use this field to specify whether your data source is an Archive, an Amazon S3 prefix, or a file.</p>
    /// <p>If you don't specify a field, the default value is <code>File</code>.</p>
    pub r#type: ::std::option::Option<crate::types::DataSourceType>,
    /// <p>The location where your files are mounted in the container image.</p>
    /// <p>If you've specified the <code>type</code> of the data source as an <code>Archive</code>, you must provide an Amazon S3 object key to your archive. The object key must point to either a <code>.zip</code> or <code>.tar.gz</code> file.</p>
    /// <p>If you've specified the <code>type</code> of the data source as a <code>Prefix</code>, you provide the Amazon S3 prefix that points to the files that you are using for your data source.</p>
    /// <p>If you've specified the <code>type</code> of the data source as a <code>File</code>, you provide the Amazon S3 path to the file that you're using as your data source.</p>
    pub destination: ::std::option::Option<::std::string::String>,
}
impl DataSourceConfig {
    /// <p>The name of the data source.</p>
    pub fn name(&self) -> &str {
        use std::ops::Deref;
        self.name.deref()
    }
    /// <p>The S3 bucket where the data files are located.</p>
    pub fn s3_bucket(&self) -> &str {
        use std::ops::Deref;
        self.s3_bucket.deref()
    }
    /// <p>The list of S3 keys identifying the data source files.</p>
    pub fn s3_keys(&self) -> &[::std::string::String] {
        use std::ops::Deref;
        self.s3_keys.deref()
    }
    /// <p>The data type for the data source that you're using for your container image or simulation job. You can use this field to specify whether your data source is an Archive, an Amazon S3 prefix, or a file.</p>
    /// <p>If you don't specify a field, the default value is <code>File</code>.</p>
    pub fn r#type(&self) -> ::std::option::Option<&crate::types::DataSourceType> {
        self.r#type.as_ref()
    }
    /// <p>The location where your files are mounted in the container image.</p>
    /// <p>If you've specified the <code>type</code> of the data source as an <code>Archive</code>, you must provide an Amazon S3 object key to your archive. The object key must point to either a <code>.zip</code> or <code>.tar.gz</code> file.</p>
    /// <p>If you've specified the <code>type</code> of the data source as a <code>Prefix</code>, you provide the Amazon S3 prefix that points to the files that you are using for your data source.</p>
    /// <p>If you've specified the <code>type</code> of the data source as a <code>File</code>, you provide the Amazon S3 path to the file that you're using as your data source.</p>
    pub fn destination(&self) -> ::std::option::Option<&str> {
        self.destination.as_deref()
    }
}
impl DataSourceConfig {
    /// Creates a new builder-style object to manufacture [`DataSourceConfig`](crate::types::DataSourceConfig).
    pub fn builder() -> crate::types::builders::DataSourceConfigBuilder {
        crate::types::builders::DataSourceConfigBuilder::default()
    }
}

/// A builder for [`DataSourceConfig`](crate::types::DataSourceConfig).
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::default::Default, ::std::fmt::Debug)]
pub struct DataSourceConfigBuilder {
    pub(crate) name: ::std::option::Option<::std::string::String>,
    pub(crate) s3_bucket: ::std::option::Option<::std::string::String>,
    pub(crate) s3_keys: ::std::option::Option<::std::vec::Vec<::std::string::String>>,
    pub(crate) r#type: ::std::option::Option<crate::types::DataSourceType>,
    pub(crate) destination: ::std::option::Option<::std::string::String>,
}
impl DataSourceConfigBuilder {
    /// <p>The name of the data source.</p>
    /// This field is required.
    pub fn name(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.name = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The name of the data source.</p>
    pub fn set_name(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.name = input;
        self
    }
    /// <p>The name of the data source.</p>
    pub fn get_name(&self) -> &::std::option::Option<::std::string::String> {
        &self.name
    }
    /// <p>The S3 bucket where the data files are located.</p>
    /// This field is required.
    pub fn s3_bucket(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.s3_bucket = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The S3 bucket where the data files are located.</p>
    pub fn set_s3_bucket(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.s3_bucket = input;
        self
    }
    /// <p>The S3 bucket where the data files are located.</p>
    pub fn get_s3_bucket(&self) -> &::std::option::Option<::std::string::String> {
        &self.s3_bucket
    }
    /// Appends an item to `s3_keys`.
    ///
    /// To override the contents of this collection use [`set_s3_keys`](Self::set_s3_keys).
    ///
    /// <p>The list of S3 keys identifying the data source files.</p>
    pub fn s3_keys(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        let mut v = self.s3_keys.unwrap_or_default();
        v.push(input.into());
        self.s3_keys = ::std::option::Option::Some(v);
        self
    }
    /// <p>The list of S3 keys identifying the data source files.</p>
    pub fn set_s3_keys(mut self, input: ::std::option::Option<::std::vec::Vec<::std::string::String>>) -> Self {
        self.s3_keys = input;
        self
    }
    /// <p>The list of S3 keys identifying the data source files.</p>
    pub fn get_s3_keys(&self) -> &::std::option::Option<::std::vec::Vec<::std::string::String>> {
        &self.s3_keys
    }
    /// <p>The data type for the data source that you're using for your container image or simulation job. You can use this field to specify whether your data source is an Archive, an Amazon S3 prefix, or a file.</p>
    /// <p>If you don't specify a field, the default value is <code>File</code>.</p>
    pub fn r#type(mut self, input: crate::types::DataSourceType) -> Self {
        self.r#type = ::std::option::Option::Some(input);
        self
    }
    /// <p>The data type for the data source that you're using for your container image or simulation job. You can use this field to specify whether your data source is an Archive, an Amazon S3 prefix, or a file.</p>
    /// <p>If you don't specify a field, the default value is <code>File</code>.</p>
    pub fn set_type(mut self, input: ::std::option::Option<crate::types::DataSourceType>) -> Self {
        self.r#type = input;
        self
    }
    /// <p>The data type for the data source that you're using for your container image or simulation job. You can use this field to specify whether your data source is an Archive, an Amazon S3 prefix, or a file.</p>
    /// <p>If you don't specify a field, the default value is <code>File</code>.</p>
    pub fn get_type(&self) -> &::std::option::Option<crate::types::DataSourceType> {
        &self.r#type
    }
    /// <p>The location where your files are mounted in the container image.</p>
    /// <p>If you've specified the <code>type</code> of the data source as an <code>Archive</code>, you must provide an Amazon S3 object key to your archive. The object key must point to either a <code>.zip</code> or <code>.tar.gz</code> file.</p>
    /// <p>If you've specified the <code>type</code> of the data source as a <code>Prefix</code>, you provide the Amazon S3 prefix that points to the files that you are using for your data source.</p>
    /// <p>If you've specified the <code>type</code> of the data source as a <code>File</code>, you provide the Amazon S3 path to the file that you're using as your data source.</p>
    pub fn destination(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.destination = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The location where your files are mounted in the container image.</p>
    /// <p>If you've specified the <code>type</code> of the data source as an <code>Archive</code>, you must provide an Amazon S3 object key to your archive. The object key must point to either a <code>.zip</code> or <code>.tar.gz</code> file.</p>
    /// <p>If you've specified the <code>type</code> of the data source as a <code>Prefix</code>, you provide the Amazon S3 prefix that points to the files that you are using for your data source.</p>
    /// <p>If you've specified the <code>type</code> of the data source as a <code>File</code>, you provide the Amazon S3 path to the file that you're using as your data source.</p>
    pub fn set_destination(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.destination = input;
        self
    }
    /// <p>The location where your files are mounted in the container image.</p>
    /// <p>If you've specified the <code>type</code> of the data source as an <code>Archive</code>, you must provide an Amazon S3 object key to your archive. The object key must point to either a <code>.zip</code> or <code>.tar.gz</code> file.</p>
    /// <p>If you've specified the <code>type</code> of the data source as a <code>Prefix</code>, you provide the Amazon S3 prefix that points to the files that you are using for your data source.</p>
    /// <p>If you've specified the <code>type</code> of the data source as a <code>File</code>, you provide the Amazon S3 path to the file that you're using as your data source.</p>
    pub fn get_destination(&self) -> &::std::option::Option<::std::string::String> {
        &self.destination
    }
    /// Consumes the builder and constructs a [`DataSourceConfig`](crate::types::DataSourceConfig).
    /// This method will fail if any of the following fields are not set:
    /// - [`name`](crate::types::builders::DataSourceConfigBuilder::name)
    /// - [`s3_bucket`](crate::types::builders::DataSourceConfigBuilder::s3_bucket)
    /// - [`s3_keys`](crate::types::builders::DataSourceConfigBuilder::s3_keys)
    pub fn build(self) -> ::std::result::Result<crate::types::DataSourceConfig, ::aws_smithy_types::error::operation::BuildError> {
        ::std::result::Result::Ok(crate::types::DataSourceConfig {
            name: self.name.ok_or_else(|| {
                ::aws_smithy_types::error::operation::BuildError::missing_field(
                    "name",
                    "name was not specified but it is required when building DataSourceConfig",
                )
            })?,
            s3_bucket: self.s3_bucket.ok_or_else(|| {
                ::aws_smithy_types::error::operation::BuildError::missing_field(
                    "s3_bucket",
                    "s3_bucket was not specified but it is required when building DataSourceConfig",
                )
            })?,
            s3_keys: self.s3_keys.ok_or_else(|| {
                ::aws_smithy_types::error::operation::BuildError::missing_field(
                    "s3_keys",
                    "s3_keys was not specified but it is required when building DataSourceConfig",
                )
            })?,
            r#type: self.r#type,
            destination: self.destination,
        })
    }
}
