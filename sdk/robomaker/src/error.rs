// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct BatchDeleteWorldsError {
    pub kind: BatchDeleteWorldsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum BatchDeleteWorldsErrorKind {
    InternalServerException(crate::error::InternalServerException),
    InvalidParameterException(crate::error::InvalidParameterException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for BatchDeleteWorldsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            BatchDeleteWorldsErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            BatchDeleteWorldsErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            BatchDeleteWorldsErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            BatchDeleteWorldsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for BatchDeleteWorldsError {
    fn code(&self) -> Option<&str> {
        BatchDeleteWorldsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl BatchDeleteWorldsError {
    pub fn new(kind: BatchDeleteWorldsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: BatchDeleteWorldsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: BatchDeleteWorldsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchDeleteWorldsErrorKind::InternalServerException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchDeleteWorldsErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchDeleteWorldsErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for BatchDeleteWorldsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            BatchDeleteWorldsErrorKind::InternalServerException(_inner) => Some(_inner),
            BatchDeleteWorldsErrorKind::InvalidParameterException(_inner) => Some(_inner),
            BatchDeleteWorldsErrorKind::ThrottlingException(_inner) => Some(_inner),
            BatchDeleteWorldsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct BatchDescribeSimulationJobError {
    pub kind: BatchDescribeSimulationJobErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum BatchDescribeSimulationJobErrorKind {
    InternalServerException(crate::error::InternalServerException),
    InvalidParameterException(crate::error::InvalidParameterException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for BatchDescribeSimulationJobError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            BatchDescribeSimulationJobErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            BatchDescribeSimulationJobErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            BatchDescribeSimulationJobErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            BatchDescribeSimulationJobErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            BatchDescribeSimulationJobErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for BatchDescribeSimulationJobError {
    fn code(&self) -> Option<&str> {
        BatchDescribeSimulationJobError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl BatchDescribeSimulationJobError {
    pub fn new(kind: BatchDescribeSimulationJobErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: BatchDescribeSimulationJobErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: BatchDescribeSimulationJobErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchDescribeSimulationJobErrorKind::InternalServerException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchDescribeSimulationJobErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchDescribeSimulationJobErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchDescribeSimulationJobErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for BatchDescribeSimulationJobError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            BatchDescribeSimulationJobErrorKind::InternalServerException(_inner) => Some(_inner),
            BatchDescribeSimulationJobErrorKind::InvalidParameterException(_inner) => Some(_inner),
            BatchDescribeSimulationJobErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            BatchDescribeSimulationJobErrorKind::ThrottlingException(_inner) => Some(_inner),
            BatchDescribeSimulationJobErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CancelDeploymentJobError {
    pub kind: CancelDeploymentJobErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CancelDeploymentJobErrorKind {
    InternalServerException(crate::error::InternalServerException),
    InvalidParameterException(crate::error::InvalidParameterException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CancelDeploymentJobError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CancelDeploymentJobErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            CancelDeploymentJobErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            CancelDeploymentJobErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            CancelDeploymentJobErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            CancelDeploymentJobErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CancelDeploymentJobError {
    fn code(&self) -> Option<&str> {
        CancelDeploymentJobError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CancelDeploymentJobError {
    pub fn new(kind: CancelDeploymentJobErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CancelDeploymentJobErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CancelDeploymentJobErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            CancelDeploymentJobErrorKind::InternalServerException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            CancelDeploymentJobErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            CancelDeploymentJobErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            CancelDeploymentJobErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for CancelDeploymentJobError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CancelDeploymentJobErrorKind::InternalServerException(_inner) => Some(_inner),
            CancelDeploymentJobErrorKind::InvalidParameterException(_inner) => Some(_inner),
            CancelDeploymentJobErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            CancelDeploymentJobErrorKind::ThrottlingException(_inner) => Some(_inner),
            CancelDeploymentJobErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CancelSimulationJobError {
    pub kind: CancelSimulationJobErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CancelSimulationJobErrorKind {
    InternalServerException(crate::error::InternalServerException),
    InvalidParameterException(crate::error::InvalidParameterException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CancelSimulationJobError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CancelSimulationJobErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            CancelSimulationJobErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            CancelSimulationJobErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            CancelSimulationJobErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            CancelSimulationJobErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CancelSimulationJobError {
    fn code(&self) -> Option<&str> {
        CancelSimulationJobError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CancelSimulationJobError {
    pub fn new(kind: CancelSimulationJobErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CancelSimulationJobErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CancelSimulationJobErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            CancelSimulationJobErrorKind::InternalServerException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            CancelSimulationJobErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            CancelSimulationJobErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            CancelSimulationJobErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for CancelSimulationJobError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CancelSimulationJobErrorKind::InternalServerException(_inner) => Some(_inner),
            CancelSimulationJobErrorKind::InvalidParameterException(_inner) => Some(_inner),
            CancelSimulationJobErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            CancelSimulationJobErrorKind::ThrottlingException(_inner) => Some(_inner),
            CancelSimulationJobErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CancelSimulationJobBatchError {
    pub kind: CancelSimulationJobBatchErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CancelSimulationJobBatchErrorKind {
    InternalServerException(crate::error::InternalServerException),
    InvalidParameterException(crate::error::InvalidParameterException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CancelSimulationJobBatchError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CancelSimulationJobBatchErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            CancelSimulationJobBatchErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            CancelSimulationJobBatchErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            CancelSimulationJobBatchErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            CancelSimulationJobBatchErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CancelSimulationJobBatchError {
    fn code(&self) -> Option<&str> {
        CancelSimulationJobBatchError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CancelSimulationJobBatchError {
    pub fn new(kind: CancelSimulationJobBatchErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CancelSimulationJobBatchErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CancelSimulationJobBatchErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            CancelSimulationJobBatchErrorKind::InternalServerException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            CancelSimulationJobBatchErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            CancelSimulationJobBatchErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            CancelSimulationJobBatchErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for CancelSimulationJobBatchError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CancelSimulationJobBatchErrorKind::InternalServerException(_inner) => Some(_inner),
            CancelSimulationJobBatchErrorKind::InvalidParameterException(_inner) => Some(_inner),
            CancelSimulationJobBatchErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            CancelSimulationJobBatchErrorKind::ThrottlingException(_inner) => Some(_inner),
            CancelSimulationJobBatchErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CancelWorldExportJobError {
    pub kind: CancelWorldExportJobErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CancelWorldExportJobErrorKind {
    InternalServerException(crate::error::InternalServerException),
    InvalidParameterException(crate::error::InvalidParameterException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CancelWorldExportJobError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CancelWorldExportJobErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            CancelWorldExportJobErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            CancelWorldExportJobErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            CancelWorldExportJobErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            CancelWorldExportJobErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CancelWorldExportJobError {
    fn code(&self) -> Option<&str> {
        CancelWorldExportJobError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CancelWorldExportJobError {
    pub fn new(kind: CancelWorldExportJobErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CancelWorldExportJobErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CancelWorldExportJobErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            CancelWorldExportJobErrorKind::InternalServerException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            CancelWorldExportJobErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            CancelWorldExportJobErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            CancelWorldExportJobErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for CancelWorldExportJobError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CancelWorldExportJobErrorKind::InternalServerException(_inner) => Some(_inner),
            CancelWorldExportJobErrorKind::InvalidParameterException(_inner) => Some(_inner),
            CancelWorldExportJobErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            CancelWorldExportJobErrorKind::ThrottlingException(_inner) => Some(_inner),
            CancelWorldExportJobErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CancelWorldGenerationJobError {
    pub kind: CancelWorldGenerationJobErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CancelWorldGenerationJobErrorKind {
    InternalServerException(crate::error::InternalServerException),
    InvalidParameterException(crate::error::InvalidParameterException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CancelWorldGenerationJobError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CancelWorldGenerationJobErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            CancelWorldGenerationJobErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            CancelWorldGenerationJobErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            CancelWorldGenerationJobErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            CancelWorldGenerationJobErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CancelWorldGenerationJobError {
    fn code(&self) -> Option<&str> {
        CancelWorldGenerationJobError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CancelWorldGenerationJobError {
    pub fn new(kind: CancelWorldGenerationJobErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CancelWorldGenerationJobErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CancelWorldGenerationJobErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            CancelWorldGenerationJobErrorKind::InternalServerException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            CancelWorldGenerationJobErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            CancelWorldGenerationJobErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            CancelWorldGenerationJobErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for CancelWorldGenerationJobError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CancelWorldGenerationJobErrorKind::InternalServerException(_inner) => Some(_inner),
            CancelWorldGenerationJobErrorKind::InvalidParameterException(_inner) => Some(_inner),
            CancelWorldGenerationJobErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            CancelWorldGenerationJobErrorKind::ThrottlingException(_inner) => Some(_inner),
            CancelWorldGenerationJobErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateDeploymentJobError {
    pub kind: CreateDeploymentJobErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateDeploymentJobErrorKind {
    ConcurrentDeploymentException(crate::error::ConcurrentDeploymentException),
    IdempotentParameterMismatchException(crate::error::IdempotentParameterMismatchException),
    InternalServerException(crate::error::InternalServerException),
    InvalidParameterException(crate::error::InvalidParameterException),
    LimitExceededException(crate::error::LimitExceededException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateDeploymentJobError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateDeploymentJobErrorKind::ConcurrentDeploymentException(_inner) => _inner.fmt(f),
            CreateDeploymentJobErrorKind::IdempotentParameterMismatchException(_inner) => {
                _inner.fmt(f)
            }
            CreateDeploymentJobErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            CreateDeploymentJobErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            CreateDeploymentJobErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            CreateDeploymentJobErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            CreateDeploymentJobErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            CreateDeploymentJobErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateDeploymentJobError {
    fn code(&self) -> Option<&str> {
        CreateDeploymentJobError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateDeploymentJobError {
    pub fn new(kind: CreateDeploymentJobErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateDeploymentJobErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateDeploymentJobErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_concurrent_deployment_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateDeploymentJobErrorKind::ConcurrentDeploymentException(_)
        )
    }
    pub fn is_idempotent_parameter_mismatch_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateDeploymentJobErrorKind::IdempotentParameterMismatchException(_)
        )
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateDeploymentJobErrorKind::InternalServerException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateDeploymentJobErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateDeploymentJobErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateDeploymentJobErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateDeploymentJobErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for CreateDeploymentJobError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateDeploymentJobErrorKind::ConcurrentDeploymentException(_inner) => Some(_inner),
            CreateDeploymentJobErrorKind::IdempotentParameterMismatchException(_inner) => {
                Some(_inner)
            }
            CreateDeploymentJobErrorKind::InternalServerException(_inner) => Some(_inner),
            CreateDeploymentJobErrorKind::InvalidParameterException(_inner) => Some(_inner),
            CreateDeploymentJobErrorKind::LimitExceededException(_inner) => Some(_inner),
            CreateDeploymentJobErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            CreateDeploymentJobErrorKind::ThrottlingException(_inner) => Some(_inner),
            CreateDeploymentJobErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateFleetError {
    pub kind: CreateFleetErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateFleetErrorKind {
    InternalServerException(crate::error::InternalServerException),
    InvalidParameterException(crate::error::InvalidParameterException),
    LimitExceededException(crate::error::LimitExceededException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateFleetError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateFleetErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            CreateFleetErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            CreateFleetErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            CreateFleetErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            CreateFleetErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateFleetError {
    fn code(&self) -> Option<&str> {
        CreateFleetError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateFleetError {
    pub fn new(kind: CreateFleetErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateFleetErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateFleetErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(&self.kind, CreateFleetErrorKind::InternalServerException(_))
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateFleetErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(&self.kind, CreateFleetErrorKind::LimitExceededException(_))
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, CreateFleetErrorKind::ThrottlingException(_))
    }
}
impl std::error::Error for CreateFleetError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateFleetErrorKind::InternalServerException(_inner) => Some(_inner),
            CreateFleetErrorKind::InvalidParameterException(_inner) => Some(_inner),
            CreateFleetErrorKind::LimitExceededException(_inner) => Some(_inner),
            CreateFleetErrorKind::ThrottlingException(_inner) => Some(_inner),
            CreateFleetErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateRobotError {
    pub kind: CreateRobotErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateRobotErrorKind {
    InternalServerException(crate::error::InternalServerException),
    InvalidParameterException(crate::error::InvalidParameterException),
    LimitExceededException(crate::error::LimitExceededException),
    ResourceAlreadyExistsException(crate::error::ResourceAlreadyExistsException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateRobotError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateRobotErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            CreateRobotErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            CreateRobotErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            CreateRobotErrorKind::ResourceAlreadyExistsException(_inner) => _inner.fmt(f),
            CreateRobotErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            CreateRobotErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateRobotError {
    fn code(&self) -> Option<&str> {
        CreateRobotError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateRobotError {
    pub fn new(kind: CreateRobotErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateRobotErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateRobotErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(&self.kind, CreateRobotErrorKind::InternalServerException(_))
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateRobotErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(&self.kind, CreateRobotErrorKind::LimitExceededException(_))
    }
    pub fn is_resource_already_exists_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateRobotErrorKind::ResourceAlreadyExistsException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, CreateRobotErrorKind::ThrottlingException(_))
    }
}
impl std::error::Error for CreateRobotError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateRobotErrorKind::InternalServerException(_inner) => Some(_inner),
            CreateRobotErrorKind::InvalidParameterException(_inner) => Some(_inner),
            CreateRobotErrorKind::LimitExceededException(_inner) => Some(_inner),
            CreateRobotErrorKind::ResourceAlreadyExistsException(_inner) => Some(_inner),
            CreateRobotErrorKind::ThrottlingException(_inner) => Some(_inner),
            CreateRobotErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateRobotApplicationError {
    pub kind: CreateRobotApplicationErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateRobotApplicationErrorKind {
    IdempotentParameterMismatchException(crate::error::IdempotentParameterMismatchException),
    InternalServerException(crate::error::InternalServerException),
    InvalidParameterException(crate::error::InvalidParameterException),
    LimitExceededException(crate::error::LimitExceededException),
    ResourceAlreadyExistsException(crate::error::ResourceAlreadyExistsException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateRobotApplicationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateRobotApplicationErrorKind::IdempotentParameterMismatchException(_inner) => {
                _inner.fmt(f)
            }
            CreateRobotApplicationErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            CreateRobotApplicationErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            CreateRobotApplicationErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            CreateRobotApplicationErrorKind::ResourceAlreadyExistsException(_inner) => {
                _inner.fmt(f)
            }
            CreateRobotApplicationErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            CreateRobotApplicationErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateRobotApplicationError {
    fn code(&self) -> Option<&str> {
        CreateRobotApplicationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateRobotApplicationError {
    pub fn new(kind: CreateRobotApplicationErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateRobotApplicationErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateRobotApplicationErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_idempotent_parameter_mismatch_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateRobotApplicationErrorKind::IdempotentParameterMismatchException(_)
        )
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateRobotApplicationErrorKind::InternalServerException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateRobotApplicationErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateRobotApplicationErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_resource_already_exists_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateRobotApplicationErrorKind::ResourceAlreadyExistsException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateRobotApplicationErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for CreateRobotApplicationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateRobotApplicationErrorKind::IdempotentParameterMismatchException(_inner) => {
                Some(_inner)
            }
            CreateRobotApplicationErrorKind::InternalServerException(_inner) => Some(_inner),
            CreateRobotApplicationErrorKind::InvalidParameterException(_inner) => Some(_inner),
            CreateRobotApplicationErrorKind::LimitExceededException(_inner) => Some(_inner),
            CreateRobotApplicationErrorKind::ResourceAlreadyExistsException(_inner) => Some(_inner),
            CreateRobotApplicationErrorKind::ThrottlingException(_inner) => Some(_inner),
            CreateRobotApplicationErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateRobotApplicationVersionError {
    pub kind: CreateRobotApplicationVersionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateRobotApplicationVersionErrorKind {
    IdempotentParameterMismatchException(crate::error::IdempotentParameterMismatchException),
    InternalServerException(crate::error::InternalServerException),
    InvalidParameterException(crate::error::InvalidParameterException),
    LimitExceededException(crate::error::LimitExceededException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateRobotApplicationVersionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateRobotApplicationVersionErrorKind::IdempotentParameterMismatchException(
                _inner,
            ) => _inner.fmt(f),
            CreateRobotApplicationVersionErrorKind::InternalServerException(_inner) => {
                _inner.fmt(f)
            }
            CreateRobotApplicationVersionErrorKind::InvalidParameterException(_inner) => {
                _inner.fmt(f)
            }
            CreateRobotApplicationVersionErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            CreateRobotApplicationVersionErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            CreateRobotApplicationVersionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateRobotApplicationVersionError {
    fn code(&self) -> Option<&str> {
        CreateRobotApplicationVersionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateRobotApplicationVersionError {
    pub fn new(kind: CreateRobotApplicationVersionErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateRobotApplicationVersionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateRobotApplicationVersionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_idempotent_parameter_mismatch_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateRobotApplicationVersionErrorKind::IdempotentParameterMismatchException(_)
        )
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateRobotApplicationVersionErrorKind::InternalServerException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateRobotApplicationVersionErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateRobotApplicationVersionErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateRobotApplicationVersionErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for CreateRobotApplicationVersionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateRobotApplicationVersionErrorKind::IdempotentParameterMismatchException(
                _inner,
            ) => Some(_inner),
            CreateRobotApplicationVersionErrorKind::InternalServerException(_inner) => Some(_inner),
            CreateRobotApplicationVersionErrorKind::InvalidParameterException(_inner) => {
                Some(_inner)
            }
            CreateRobotApplicationVersionErrorKind::LimitExceededException(_inner) => Some(_inner),
            CreateRobotApplicationVersionErrorKind::ThrottlingException(_inner) => Some(_inner),
            CreateRobotApplicationVersionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateSimulationApplicationError {
    pub kind: CreateSimulationApplicationErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateSimulationApplicationErrorKind {
    IdempotentParameterMismatchException(crate::error::IdempotentParameterMismatchException),
    InternalServerException(crate::error::InternalServerException),
    InvalidParameterException(crate::error::InvalidParameterException),
    LimitExceededException(crate::error::LimitExceededException),
    ResourceAlreadyExistsException(crate::error::ResourceAlreadyExistsException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateSimulationApplicationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateSimulationApplicationErrorKind::IdempotentParameterMismatchException(_inner) => {
                _inner.fmt(f)
            }
            CreateSimulationApplicationErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            CreateSimulationApplicationErrorKind::InvalidParameterException(_inner) => {
                _inner.fmt(f)
            }
            CreateSimulationApplicationErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            CreateSimulationApplicationErrorKind::ResourceAlreadyExistsException(_inner) => {
                _inner.fmt(f)
            }
            CreateSimulationApplicationErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            CreateSimulationApplicationErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateSimulationApplicationError {
    fn code(&self) -> Option<&str> {
        CreateSimulationApplicationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateSimulationApplicationError {
    pub fn new(kind: CreateSimulationApplicationErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateSimulationApplicationErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateSimulationApplicationErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_idempotent_parameter_mismatch_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateSimulationApplicationErrorKind::IdempotentParameterMismatchException(_)
        )
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateSimulationApplicationErrorKind::InternalServerException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateSimulationApplicationErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateSimulationApplicationErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_resource_already_exists_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateSimulationApplicationErrorKind::ResourceAlreadyExistsException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateSimulationApplicationErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for CreateSimulationApplicationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateSimulationApplicationErrorKind::IdempotentParameterMismatchException(_inner) => {
                Some(_inner)
            }
            CreateSimulationApplicationErrorKind::InternalServerException(_inner) => Some(_inner),
            CreateSimulationApplicationErrorKind::InvalidParameterException(_inner) => Some(_inner),
            CreateSimulationApplicationErrorKind::LimitExceededException(_inner) => Some(_inner),
            CreateSimulationApplicationErrorKind::ResourceAlreadyExistsException(_inner) => {
                Some(_inner)
            }
            CreateSimulationApplicationErrorKind::ThrottlingException(_inner) => Some(_inner),
            CreateSimulationApplicationErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateSimulationApplicationVersionError {
    pub kind: CreateSimulationApplicationVersionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateSimulationApplicationVersionErrorKind {
    IdempotentParameterMismatchException(crate::error::IdempotentParameterMismatchException),
    InternalServerException(crate::error::InternalServerException),
    InvalidParameterException(crate::error::InvalidParameterException),
    LimitExceededException(crate::error::LimitExceededException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateSimulationApplicationVersionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateSimulationApplicationVersionErrorKind::IdempotentParameterMismatchException(
                _inner,
            ) => _inner.fmt(f),
            CreateSimulationApplicationVersionErrorKind::InternalServerException(_inner) => {
                _inner.fmt(f)
            }
            CreateSimulationApplicationVersionErrorKind::InvalidParameterException(_inner) => {
                _inner.fmt(f)
            }
            CreateSimulationApplicationVersionErrorKind::LimitExceededException(_inner) => {
                _inner.fmt(f)
            }
            CreateSimulationApplicationVersionErrorKind::ThrottlingException(_inner) => {
                _inner.fmt(f)
            }
            CreateSimulationApplicationVersionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateSimulationApplicationVersionError {
    fn code(&self) -> Option<&str> {
        CreateSimulationApplicationVersionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateSimulationApplicationVersionError {
    pub fn new(
        kind: CreateSimulationApplicationVersionErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateSimulationApplicationVersionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateSimulationApplicationVersionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_idempotent_parameter_mismatch_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateSimulationApplicationVersionErrorKind::IdempotentParameterMismatchException(_)
        )
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateSimulationApplicationVersionErrorKind::InternalServerException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateSimulationApplicationVersionErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateSimulationApplicationVersionErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateSimulationApplicationVersionErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for CreateSimulationApplicationVersionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateSimulationApplicationVersionErrorKind::IdempotentParameterMismatchException(
                _inner,
            ) => Some(_inner),
            CreateSimulationApplicationVersionErrorKind::InternalServerException(_inner) => {
                Some(_inner)
            }
            CreateSimulationApplicationVersionErrorKind::InvalidParameterException(_inner) => {
                Some(_inner)
            }
            CreateSimulationApplicationVersionErrorKind::LimitExceededException(_inner) => {
                Some(_inner)
            }
            CreateSimulationApplicationVersionErrorKind::ThrottlingException(_inner) => {
                Some(_inner)
            }
            CreateSimulationApplicationVersionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateSimulationJobError {
    pub kind: CreateSimulationJobErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateSimulationJobErrorKind {
    IdempotentParameterMismatchException(crate::error::IdempotentParameterMismatchException),
    InternalServerException(crate::error::InternalServerException),
    InvalidParameterException(crate::error::InvalidParameterException),
    LimitExceededException(crate::error::LimitExceededException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateSimulationJobError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateSimulationJobErrorKind::IdempotentParameterMismatchException(_inner) => {
                _inner.fmt(f)
            }
            CreateSimulationJobErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            CreateSimulationJobErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            CreateSimulationJobErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            CreateSimulationJobErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            CreateSimulationJobErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            CreateSimulationJobErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            CreateSimulationJobErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateSimulationJobError {
    fn code(&self) -> Option<&str> {
        CreateSimulationJobError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateSimulationJobError {
    pub fn new(kind: CreateSimulationJobErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateSimulationJobErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateSimulationJobErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_idempotent_parameter_mismatch_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateSimulationJobErrorKind::IdempotentParameterMismatchException(_)
        )
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateSimulationJobErrorKind::InternalServerException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateSimulationJobErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateSimulationJobErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateSimulationJobErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateSimulationJobErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateSimulationJobErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for CreateSimulationJobError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateSimulationJobErrorKind::IdempotentParameterMismatchException(_inner) => {
                Some(_inner)
            }
            CreateSimulationJobErrorKind::InternalServerException(_inner) => Some(_inner),
            CreateSimulationJobErrorKind::InvalidParameterException(_inner) => Some(_inner),
            CreateSimulationJobErrorKind::LimitExceededException(_inner) => Some(_inner),
            CreateSimulationJobErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            CreateSimulationJobErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            CreateSimulationJobErrorKind::ThrottlingException(_inner) => Some(_inner),
            CreateSimulationJobErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateWorldExportJobError {
    pub kind: CreateWorldExportJobErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateWorldExportJobErrorKind {
    IdempotentParameterMismatchException(crate::error::IdempotentParameterMismatchException),
    InternalServerException(crate::error::InternalServerException),
    InvalidParameterException(crate::error::InvalidParameterException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateWorldExportJobError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateWorldExportJobErrorKind::IdempotentParameterMismatchException(_inner) => {
                _inner.fmt(f)
            }
            CreateWorldExportJobErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            CreateWorldExportJobErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            CreateWorldExportJobErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            CreateWorldExportJobErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            CreateWorldExportJobErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            CreateWorldExportJobErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateWorldExportJobError {
    fn code(&self) -> Option<&str> {
        CreateWorldExportJobError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateWorldExportJobError {
    pub fn new(kind: CreateWorldExportJobErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateWorldExportJobErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateWorldExportJobErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_idempotent_parameter_mismatch_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateWorldExportJobErrorKind::IdempotentParameterMismatchException(_)
        )
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateWorldExportJobErrorKind::InternalServerException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateWorldExportJobErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateWorldExportJobErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateWorldExportJobErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateWorldExportJobErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for CreateWorldExportJobError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateWorldExportJobErrorKind::IdempotentParameterMismatchException(_inner) => {
                Some(_inner)
            }
            CreateWorldExportJobErrorKind::InternalServerException(_inner) => Some(_inner),
            CreateWorldExportJobErrorKind::InvalidParameterException(_inner) => Some(_inner),
            CreateWorldExportJobErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            CreateWorldExportJobErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            CreateWorldExportJobErrorKind::ThrottlingException(_inner) => Some(_inner),
            CreateWorldExportJobErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateWorldGenerationJobError {
    pub kind: CreateWorldGenerationJobErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateWorldGenerationJobErrorKind {
    IdempotentParameterMismatchException(crate::error::IdempotentParameterMismatchException),
    InternalServerException(crate::error::InternalServerException),
    InvalidParameterException(crate::error::InvalidParameterException),
    LimitExceededException(crate::error::LimitExceededException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateWorldGenerationJobError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateWorldGenerationJobErrorKind::IdempotentParameterMismatchException(_inner) => {
                _inner.fmt(f)
            }
            CreateWorldGenerationJobErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            CreateWorldGenerationJobErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            CreateWorldGenerationJobErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            CreateWorldGenerationJobErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            CreateWorldGenerationJobErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            CreateWorldGenerationJobErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            CreateWorldGenerationJobErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateWorldGenerationJobError {
    fn code(&self) -> Option<&str> {
        CreateWorldGenerationJobError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateWorldGenerationJobError {
    pub fn new(kind: CreateWorldGenerationJobErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateWorldGenerationJobErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateWorldGenerationJobErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_idempotent_parameter_mismatch_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateWorldGenerationJobErrorKind::IdempotentParameterMismatchException(_)
        )
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateWorldGenerationJobErrorKind::InternalServerException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateWorldGenerationJobErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateWorldGenerationJobErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateWorldGenerationJobErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateWorldGenerationJobErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateWorldGenerationJobErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for CreateWorldGenerationJobError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateWorldGenerationJobErrorKind::IdempotentParameterMismatchException(_inner) => {
                Some(_inner)
            }
            CreateWorldGenerationJobErrorKind::InternalServerException(_inner) => Some(_inner),
            CreateWorldGenerationJobErrorKind::InvalidParameterException(_inner) => Some(_inner),
            CreateWorldGenerationJobErrorKind::LimitExceededException(_inner) => Some(_inner),
            CreateWorldGenerationJobErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            CreateWorldGenerationJobErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            CreateWorldGenerationJobErrorKind::ThrottlingException(_inner) => Some(_inner),
            CreateWorldGenerationJobErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateWorldTemplateError {
    pub kind: CreateWorldTemplateErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateWorldTemplateErrorKind {
    InternalServerException(crate::error::InternalServerException),
    InvalidParameterException(crate::error::InvalidParameterException),
    LimitExceededException(crate::error::LimitExceededException),
    ResourceAlreadyExistsException(crate::error::ResourceAlreadyExistsException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateWorldTemplateError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateWorldTemplateErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            CreateWorldTemplateErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            CreateWorldTemplateErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            CreateWorldTemplateErrorKind::ResourceAlreadyExistsException(_inner) => _inner.fmt(f),
            CreateWorldTemplateErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            CreateWorldTemplateErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            CreateWorldTemplateErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateWorldTemplateError {
    fn code(&self) -> Option<&str> {
        CreateWorldTemplateError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateWorldTemplateError {
    pub fn new(kind: CreateWorldTemplateErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateWorldTemplateErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateWorldTemplateErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateWorldTemplateErrorKind::InternalServerException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateWorldTemplateErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateWorldTemplateErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_resource_already_exists_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateWorldTemplateErrorKind::ResourceAlreadyExistsException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateWorldTemplateErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateWorldTemplateErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for CreateWorldTemplateError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateWorldTemplateErrorKind::InternalServerException(_inner) => Some(_inner),
            CreateWorldTemplateErrorKind::InvalidParameterException(_inner) => Some(_inner),
            CreateWorldTemplateErrorKind::LimitExceededException(_inner) => Some(_inner),
            CreateWorldTemplateErrorKind::ResourceAlreadyExistsException(_inner) => Some(_inner),
            CreateWorldTemplateErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            CreateWorldTemplateErrorKind::ThrottlingException(_inner) => Some(_inner),
            CreateWorldTemplateErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteFleetError {
    pub kind: DeleteFleetErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteFleetErrorKind {
    InternalServerException(crate::error::InternalServerException),
    InvalidParameterException(crate::error::InvalidParameterException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteFleetError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteFleetErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            DeleteFleetErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            DeleteFleetErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DeleteFleetErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteFleetError {
    fn code(&self) -> Option<&str> {
        DeleteFleetError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteFleetError {
    pub fn new(kind: DeleteFleetErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteFleetErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteFleetErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(&self.kind, DeleteFleetErrorKind::InternalServerException(_))
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteFleetErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, DeleteFleetErrorKind::ThrottlingException(_))
    }
}
impl std::error::Error for DeleteFleetError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteFleetErrorKind::InternalServerException(_inner) => Some(_inner),
            DeleteFleetErrorKind::InvalidParameterException(_inner) => Some(_inner),
            DeleteFleetErrorKind::ThrottlingException(_inner) => Some(_inner),
            DeleteFleetErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteRobotError {
    pub kind: DeleteRobotErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteRobotErrorKind {
    InternalServerException(crate::error::InternalServerException),
    InvalidParameterException(crate::error::InvalidParameterException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteRobotError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteRobotErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            DeleteRobotErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            DeleteRobotErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DeleteRobotErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteRobotError {
    fn code(&self) -> Option<&str> {
        DeleteRobotError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteRobotError {
    pub fn new(kind: DeleteRobotErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteRobotErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteRobotErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(&self.kind, DeleteRobotErrorKind::InternalServerException(_))
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteRobotErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, DeleteRobotErrorKind::ThrottlingException(_))
    }
}
impl std::error::Error for DeleteRobotError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteRobotErrorKind::InternalServerException(_inner) => Some(_inner),
            DeleteRobotErrorKind::InvalidParameterException(_inner) => Some(_inner),
            DeleteRobotErrorKind::ThrottlingException(_inner) => Some(_inner),
            DeleteRobotErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteRobotApplicationError {
    pub kind: DeleteRobotApplicationErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteRobotApplicationErrorKind {
    InternalServerException(crate::error::InternalServerException),
    InvalidParameterException(crate::error::InvalidParameterException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteRobotApplicationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteRobotApplicationErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            DeleteRobotApplicationErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            DeleteRobotApplicationErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DeleteRobotApplicationErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteRobotApplicationError {
    fn code(&self) -> Option<&str> {
        DeleteRobotApplicationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteRobotApplicationError {
    pub fn new(kind: DeleteRobotApplicationErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteRobotApplicationErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteRobotApplicationErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteRobotApplicationErrorKind::InternalServerException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteRobotApplicationErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteRobotApplicationErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for DeleteRobotApplicationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteRobotApplicationErrorKind::InternalServerException(_inner) => Some(_inner),
            DeleteRobotApplicationErrorKind::InvalidParameterException(_inner) => Some(_inner),
            DeleteRobotApplicationErrorKind::ThrottlingException(_inner) => Some(_inner),
            DeleteRobotApplicationErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteSimulationApplicationError {
    pub kind: DeleteSimulationApplicationErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteSimulationApplicationErrorKind {
    InternalServerException(crate::error::InternalServerException),
    InvalidParameterException(crate::error::InvalidParameterException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteSimulationApplicationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteSimulationApplicationErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            DeleteSimulationApplicationErrorKind::InvalidParameterException(_inner) => {
                _inner.fmt(f)
            }
            DeleteSimulationApplicationErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DeleteSimulationApplicationErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteSimulationApplicationError {
    fn code(&self) -> Option<&str> {
        DeleteSimulationApplicationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteSimulationApplicationError {
    pub fn new(kind: DeleteSimulationApplicationErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteSimulationApplicationErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteSimulationApplicationErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteSimulationApplicationErrorKind::InternalServerException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteSimulationApplicationErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteSimulationApplicationErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for DeleteSimulationApplicationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteSimulationApplicationErrorKind::InternalServerException(_inner) => Some(_inner),
            DeleteSimulationApplicationErrorKind::InvalidParameterException(_inner) => Some(_inner),
            DeleteSimulationApplicationErrorKind::ThrottlingException(_inner) => Some(_inner),
            DeleteSimulationApplicationErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteWorldTemplateError {
    pub kind: DeleteWorldTemplateErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteWorldTemplateErrorKind {
    InternalServerException(crate::error::InternalServerException),
    InvalidParameterException(crate::error::InvalidParameterException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteWorldTemplateError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteWorldTemplateErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            DeleteWorldTemplateErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            DeleteWorldTemplateErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DeleteWorldTemplateErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DeleteWorldTemplateErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteWorldTemplateError {
    fn code(&self) -> Option<&str> {
        DeleteWorldTemplateError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteWorldTemplateError {
    pub fn new(kind: DeleteWorldTemplateErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteWorldTemplateErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteWorldTemplateErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteWorldTemplateErrorKind::InternalServerException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteWorldTemplateErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteWorldTemplateErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteWorldTemplateErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for DeleteWorldTemplateError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteWorldTemplateErrorKind::InternalServerException(_inner) => Some(_inner),
            DeleteWorldTemplateErrorKind::InvalidParameterException(_inner) => Some(_inner),
            DeleteWorldTemplateErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DeleteWorldTemplateErrorKind::ThrottlingException(_inner) => Some(_inner),
            DeleteWorldTemplateErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeregisterRobotError {
    pub kind: DeregisterRobotErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeregisterRobotErrorKind {
    InternalServerException(crate::error::InternalServerException),
    InvalidParameterException(crate::error::InvalidParameterException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeregisterRobotError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeregisterRobotErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            DeregisterRobotErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            DeregisterRobotErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DeregisterRobotErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DeregisterRobotErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeregisterRobotError {
    fn code(&self) -> Option<&str> {
        DeregisterRobotError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeregisterRobotError {
    pub fn new(kind: DeregisterRobotErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeregisterRobotErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeregisterRobotErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeregisterRobotErrorKind::InternalServerException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeregisterRobotErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeregisterRobotErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, DeregisterRobotErrorKind::ThrottlingException(_))
    }
}
impl std::error::Error for DeregisterRobotError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeregisterRobotErrorKind::InternalServerException(_inner) => Some(_inner),
            DeregisterRobotErrorKind::InvalidParameterException(_inner) => Some(_inner),
            DeregisterRobotErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DeregisterRobotErrorKind::ThrottlingException(_inner) => Some(_inner),
            DeregisterRobotErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeDeploymentJobError {
    pub kind: DescribeDeploymentJobErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeDeploymentJobErrorKind {
    InternalServerException(crate::error::InternalServerException),
    InvalidParameterException(crate::error::InvalidParameterException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeDeploymentJobError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeDeploymentJobErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            DescribeDeploymentJobErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            DescribeDeploymentJobErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DescribeDeploymentJobErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DescribeDeploymentJobErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeDeploymentJobError {
    fn code(&self) -> Option<&str> {
        DescribeDeploymentJobError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeDeploymentJobError {
    pub fn new(kind: DescribeDeploymentJobErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeDeploymentJobErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeDeploymentJobErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeDeploymentJobErrorKind::InternalServerException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeDeploymentJobErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeDeploymentJobErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeDeploymentJobErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for DescribeDeploymentJobError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeDeploymentJobErrorKind::InternalServerException(_inner) => Some(_inner),
            DescribeDeploymentJobErrorKind::InvalidParameterException(_inner) => Some(_inner),
            DescribeDeploymentJobErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DescribeDeploymentJobErrorKind::ThrottlingException(_inner) => Some(_inner),
            DescribeDeploymentJobErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeFleetError {
    pub kind: DescribeFleetErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeFleetErrorKind {
    InternalServerException(crate::error::InternalServerException),
    InvalidParameterException(crate::error::InvalidParameterException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeFleetError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeFleetErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            DescribeFleetErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            DescribeFleetErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DescribeFleetErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DescribeFleetErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeFleetError {
    fn code(&self) -> Option<&str> {
        DescribeFleetError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeFleetError {
    pub fn new(kind: DescribeFleetErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeFleetErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeFleetErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeFleetErrorKind::InternalServerException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeFleetErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeFleetErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, DescribeFleetErrorKind::ThrottlingException(_))
    }
}
impl std::error::Error for DescribeFleetError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeFleetErrorKind::InternalServerException(_inner) => Some(_inner),
            DescribeFleetErrorKind::InvalidParameterException(_inner) => Some(_inner),
            DescribeFleetErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DescribeFleetErrorKind::ThrottlingException(_inner) => Some(_inner),
            DescribeFleetErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeRobotError {
    pub kind: DescribeRobotErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeRobotErrorKind {
    InternalServerException(crate::error::InternalServerException),
    InvalidParameterException(crate::error::InvalidParameterException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeRobotError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeRobotErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            DescribeRobotErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            DescribeRobotErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DescribeRobotErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DescribeRobotErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeRobotError {
    fn code(&self) -> Option<&str> {
        DescribeRobotError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeRobotError {
    pub fn new(kind: DescribeRobotErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeRobotErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeRobotErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeRobotErrorKind::InternalServerException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeRobotErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeRobotErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, DescribeRobotErrorKind::ThrottlingException(_))
    }
}
impl std::error::Error for DescribeRobotError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeRobotErrorKind::InternalServerException(_inner) => Some(_inner),
            DescribeRobotErrorKind::InvalidParameterException(_inner) => Some(_inner),
            DescribeRobotErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DescribeRobotErrorKind::ThrottlingException(_inner) => Some(_inner),
            DescribeRobotErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeRobotApplicationError {
    pub kind: DescribeRobotApplicationErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeRobotApplicationErrorKind {
    InternalServerException(crate::error::InternalServerException),
    InvalidParameterException(crate::error::InvalidParameterException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeRobotApplicationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeRobotApplicationErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            DescribeRobotApplicationErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            DescribeRobotApplicationErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DescribeRobotApplicationErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DescribeRobotApplicationErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeRobotApplicationError {
    fn code(&self) -> Option<&str> {
        DescribeRobotApplicationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeRobotApplicationError {
    pub fn new(kind: DescribeRobotApplicationErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeRobotApplicationErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeRobotApplicationErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeRobotApplicationErrorKind::InternalServerException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeRobotApplicationErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeRobotApplicationErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeRobotApplicationErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for DescribeRobotApplicationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeRobotApplicationErrorKind::InternalServerException(_inner) => Some(_inner),
            DescribeRobotApplicationErrorKind::InvalidParameterException(_inner) => Some(_inner),
            DescribeRobotApplicationErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DescribeRobotApplicationErrorKind::ThrottlingException(_inner) => Some(_inner),
            DescribeRobotApplicationErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeSimulationApplicationError {
    pub kind: DescribeSimulationApplicationErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeSimulationApplicationErrorKind {
    InternalServerException(crate::error::InternalServerException),
    InvalidParameterException(crate::error::InvalidParameterException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeSimulationApplicationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeSimulationApplicationErrorKind::InternalServerException(_inner) => {
                _inner.fmt(f)
            }
            DescribeSimulationApplicationErrorKind::InvalidParameterException(_inner) => {
                _inner.fmt(f)
            }
            DescribeSimulationApplicationErrorKind::ResourceNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            DescribeSimulationApplicationErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DescribeSimulationApplicationErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeSimulationApplicationError {
    fn code(&self) -> Option<&str> {
        DescribeSimulationApplicationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeSimulationApplicationError {
    pub fn new(kind: DescribeSimulationApplicationErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeSimulationApplicationErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeSimulationApplicationErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeSimulationApplicationErrorKind::InternalServerException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeSimulationApplicationErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeSimulationApplicationErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeSimulationApplicationErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for DescribeSimulationApplicationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeSimulationApplicationErrorKind::InternalServerException(_inner) => Some(_inner),
            DescribeSimulationApplicationErrorKind::InvalidParameterException(_inner) => {
                Some(_inner)
            }
            DescribeSimulationApplicationErrorKind::ResourceNotFoundException(_inner) => {
                Some(_inner)
            }
            DescribeSimulationApplicationErrorKind::ThrottlingException(_inner) => Some(_inner),
            DescribeSimulationApplicationErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeSimulationJobError {
    pub kind: DescribeSimulationJobErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeSimulationJobErrorKind {
    InternalServerException(crate::error::InternalServerException),
    InvalidParameterException(crate::error::InvalidParameterException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeSimulationJobError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeSimulationJobErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            DescribeSimulationJobErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            DescribeSimulationJobErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DescribeSimulationJobErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DescribeSimulationJobErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeSimulationJobError {
    fn code(&self) -> Option<&str> {
        DescribeSimulationJobError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeSimulationJobError {
    pub fn new(kind: DescribeSimulationJobErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeSimulationJobErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeSimulationJobErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeSimulationJobErrorKind::InternalServerException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeSimulationJobErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeSimulationJobErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeSimulationJobErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for DescribeSimulationJobError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeSimulationJobErrorKind::InternalServerException(_inner) => Some(_inner),
            DescribeSimulationJobErrorKind::InvalidParameterException(_inner) => Some(_inner),
            DescribeSimulationJobErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DescribeSimulationJobErrorKind::ThrottlingException(_inner) => Some(_inner),
            DescribeSimulationJobErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeSimulationJobBatchError {
    pub kind: DescribeSimulationJobBatchErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeSimulationJobBatchErrorKind {
    InternalServerException(crate::error::InternalServerException),
    InvalidParameterException(crate::error::InvalidParameterException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeSimulationJobBatchError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeSimulationJobBatchErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            DescribeSimulationJobBatchErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            DescribeSimulationJobBatchErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DescribeSimulationJobBatchErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeSimulationJobBatchError {
    fn code(&self) -> Option<&str> {
        DescribeSimulationJobBatchError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeSimulationJobBatchError {
    pub fn new(kind: DescribeSimulationJobBatchErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeSimulationJobBatchErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeSimulationJobBatchErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeSimulationJobBatchErrorKind::InternalServerException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeSimulationJobBatchErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeSimulationJobBatchErrorKind::ResourceNotFoundException(_)
        )
    }
}
impl std::error::Error for DescribeSimulationJobBatchError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeSimulationJobBatchErrorKind::InternalServerException(_inner) => Some(_inner),
            DescribeSimulationJobBatchErrorKind::InvalidParameterException(_inner) => Some(_inner),
            DescribeSimulationJobBatchErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DescribeSimulationJobBatchErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeWorldError {
    pub kind: DescribeWorldErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeWorldErrorKind {
    InternalServerException(crate::error::InternalServerException),
    InvalidParameterException(crate::error::InvalidParameterException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeWorldError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeWorldErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            DescribeWorldErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            DescribeWorldErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DescribeWorldErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DescribeWorldErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeWorldError {
    fn code(&self) -> Option<&str> {
        DescribeWorldError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeWorldError {
    pub fn new(kind: DescribeWorldErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeWorldErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeWorldErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeWorldErrorKind::InternalServerException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeWorldErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeWorldErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, DescribeWorldErrorKind::ThrottlingException(_))
    }
}
impl std::error::Error for DescribeWorldError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeWorldErrorKind::InternalServerException(_inner) => Some(_inner),
            DescribeWorldErrorKind::InvalidParameterException(_inner) => Some(_inner),
            DescribeWorldErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DescribeWorldErrorKind::ThrottlingException(_inner) => Some(_inner),
            DescribeWorldErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeWorldExportJobError {
    pub kind: DescribeWorldExportJobErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeWorldExportJobErrorKind {
    InternalServerException(crate::error::InternalServerException),
    InvalidParameterException(crate::error::InvalidParameterException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeWorldExportJobError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeWorldExportJobErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            DescribeWorldExportJobErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            DescribeWorldExportJobErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DescribeWorldExportJobErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DescribeWorldExportJobErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeWorldExportJobError {
    fn code(&self) -> Option<&str> {
        DescribeWorldExportJobError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeWorldExportJobError {
    pub fn new(kind: DescribeWorldExportJobErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeWorldExportJobErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeWorldExportJobErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeWorldExportJobErrorKind::InternalServerException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeWorldExportJobErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeWorldExportJobErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeWorldExportJobErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for DescribeWorldExportJobError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeWorldExportJobErrorKind::InternalServerException(_inner) => Some(_inner),
            DescribeWorldExportJobErrorKind::InvalidParameterException(_inner) => Some(_inner),
            DescribeWorldExportJobErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DescribeWorldExportJobErrorKind::ThrottlingException(_inner) => Some(_inner),
            DescribeWorldExportJobErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeWorldGenerationJobError {
    pub kind: DescribeWorldGenerationJobErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeWorldGenerationJobErrorKind {
    InternalServerException(crate::error::InternalServerException),
    InvalidParameterException(crate::error::InvalidParameterException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeWorldGenerationJobError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeWorldGenerationJobErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            DescribeWorldGenerationJobErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            DescribeWorldGenerationJobErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DescribeWorldGenerationJobErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DescribeWorldGenerationJobErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeWorldGenerationJobError {
    fn code(&self) -> Option<&str> {
        DescribeWorldGenerationJobError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeWorldGenerationJobError {
    pub fn new(kind: DescribeWorldGenerationJobErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeWorldGenerationJobErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeWorldGenerationJobErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeWorldGenerationJobErrorKind::InternalServerException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeWorldGenerationJobErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeWorldGenerationJobErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeWorldGenerationJobErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for DescribeWorldGenerationJobError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeWorldGenerationJobErrorKind::InternalServerException(_inner) => Some(_inner),
            DescribeWorldGenerationJobErrorKind::InvalidParameterException(_inner) => Some(_inner),
            DescribeWorldGenerationJobErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DescribeWorldGenerationJobErrorKind::ThrottlingException(_inner) => Some(_inner),
            DescribeWorldGenerationJobErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeWorldTemplateError {
    pub kind: DescribeWorldTemplateErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeWorldTemplateErrorKind {
    InternalServerException(crate::error::InternalServerException),
    InvalidParameterException(crate::error::InvalidParameterException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeWorldTemplateError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeWorldTemplateErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            DescribeWorldTemplateErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            DescribeWorldTemplateErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DescribeWorldTemplateErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DescribeWorldTemplateErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeWorldTemplateError {
    fn code(&self) -> Option<&str> {
        DescribeWorldTemplateError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeWorldTemplateError {
    pub fn new(kind: DescribeWorldTemplateErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeWorldTemplateErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeWorldTemplateErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeWorldTemplateErrorKind::InternalServerException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeWorldTemplateErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeWorldTemplateErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeWorldTemplateErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for DescribeWorldTemplateError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeWorldTemplateErrorKind::InternalServerException(_inner) => Some(_inner),
            DescribeWorldTemplateErrorKind::InvalidParameterException(_inner) => Some(_inner),
            DescribeWorldTemplateErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DescribeWorldTemplateErrorKind::ThrottlingException(_inner) => Some(_inner),
            DescribeWorldTemplateErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetWorldTemplateBodyError {
    pub kind: GetWorldTemplateBodyErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetWorldTemplateBodyErrorKind {
    InternalServerException(crate::error::InternalServerException),
    InvalidParameterException(crate::error::InvalidParameterException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetWorldTemplateBodyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetWorldTemplateBodyErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            GetWorldTemplateBodyErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            GetWorldTemplateBodyErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            GetWorldTemplateBodyErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            GetWorldTemplateBodyErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetWorldTemplateBodyError {
    fn code(&self) -> Option<&str> {
        GetWorldTemplateBodyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetWorldTemplateBodyError {
    pub fn new(kind: GetWorldTemplateBodyErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetWorldTemplateBodyErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetWorldTemplateBodyErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetWorldTemplateBodyErrorKind::InternalServerException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetWorldTemplateBodyErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetWorldTemplateBodyErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetWorldTemplateBodyErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for GetWorldTemplateBodyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetWorldTemplateBodyErrorKind::InternalServerException(_inner) => Some(_inner),
            GetWorldTemplateBodyErrorKind::InvalidParameterException(_inner) => Some(_inner),
            GetWorldTemplateBodyErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            GetWorldTemplateBodyErrorKind::ThrottlingException(_inner) => Some(_inner),
            GetWorldTemplateBodyErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListDeploymentJobsError {
    pub kind: ListDeploymentJobsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListDeploymentJobsErrorKind {
    InternalServerException(crate::error::InternalServerException),
    InvalidParameterException(crate::error::InvalidParameterException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListDeploymentJobsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListDeploymentJobsErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            ListDeploymentJobsErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            ListDeploymentJobsErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            ListDeploymentJobsErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            ListDeploymentJobsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListDeploymentJobsError {
    fn code(&self) -> Option<&str> {
        ListDeploymentJobsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListDeploymentJobsError {
    pub fn new(kind: ListDeploymentJobsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListDeploymentJobsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListDeploymentJobsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListDeploymentJobsErrorKind::InternalServerException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListDeploymentJobsErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListDeploymentJobsErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListDeploymentJobsErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for ListDeploymentJobsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListDeploymentJobsErrorKind::InternalServerException(_inner) => Some(_inner),
            ListDeploymentJobsErrorKind::InvalidParameterException(_inner) => Some(_inner),
            ListDeploymentJobsErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            ListDeploymentJobsErrorKind::ThrottlingException(_inner) => Some(_inner),
            ListDeploymentJobsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListFleetsError {
    pub kind: ListFleetsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListFleetsErrorKind {
    InternalServerException(crate::error::InternalServerException),
    InvalidParameterException(crate::error::InvalidParameterException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListFleetsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListFleetsErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            ListFleetsErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            ListFleetsErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            ListFleetsErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            ListFleetsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListFleetsError {
    fn code(&self) -> Option<&str> {
        ListFleetsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListFleetsError {
    pub fn new(kind: ListFleetsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListFleetsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListFleetsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(&self.kind, ListFleetsErrorKind::InternalServerException(_))
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListFleetsErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListFleetsErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, ListFleetsErrorKind::ThrottlingException(_))
    }
}
impl std::error::Error for ListFleetsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListFleetsErrorKind::InternalServerException(_inner) => Some(_inner),
            ListFleetsErrorKind::InvalidParameterException(_inner) => Some(_inner),
            ListFleetsErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            ListFleetsErrorKind::ThrottlingException(_inner) => Some(_inner),
            ListFleetsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListRobotApplicationsError {
    pub kind: ListRobotApplicationsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListRobotApplicationsErrorKind {
    InternalServerException(crate::error::InternalServerException),
    InvalidParameterException(crate::error::InvalidParameterException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListRobotApplicationsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListRobotApplicationsErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            ListRobotApplicationsErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            ListRobotApplicationsErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            ListRobotApplicationsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListRobotApplicationsError {
    fn code(&self) -> Option<&str> {
        ListRobotApplicationsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListRobotApplicationsError {
    pub fn new(kind: ListRobotApplicationsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListRobotApplicationsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListRobotApplicationsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListRobotApplicationsErrorKind::InternalServerException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListRobotApplicationsErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListRobotApplicationsErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for ListRobotApplicationsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListRobotApplicationsErrorKind::InternalServerException(_inner) => Some(_inner),
            ListRobotApplicationsErrorKind::InvalidParameterException(_inner) => Some(_inner),
            ListRobotApplicationsErrorKind::ThrottlingException(_inner) => Some(_inner),
            ListRobotApplicationsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListRobotsError {
    pub kind: ListRobotsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListRobotsErrorKind {
    InternalServerException(crate::error::InternalServerException),
    InvalidParameterException(crate::error::InvalidParameterException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListRobotsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListRobotsErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            ListRobotsErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            ListRobotsErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            ListRobotsErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            ListRobotsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListRobotsError {
    fn code(&self) -> Option<&str> {
        ListRobotsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListRobotsError {
    pub fn new(kind: ListRobotsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListRobotsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListRobotsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(&self.kind, ListRobotsErrorKind::InternalServerException(_))
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListRobotsErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListRobotsErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, ListRobotsErrorKind::ThrottlingException(_))
    }
}
impl std::error::Error for ListRobotsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListRobotsErrorKind::InternalServerException(_inner) => Some(_inner),
            ListRobotsErrorKind::InvalidParameterException(_inner) => Some(_inner),
            ListRobotsErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            ListRobotsErrorKind::ThrottlingException(_inner) => Some(_inner),
            ListRobotsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListSimulationApplicationsError {
    pub kind: ListSimulationApplicationsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListSimulationApplicationsErrorKind {
    InternalServerException(crate::error::InternalServerException),
    InvalidParameterException(crate::error::InvalidParameterException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListSimulationApplicationsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListSimulationApplicationsErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            ListSimulationApplicationsErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            ListSimulationApplicationsErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            ListSimulationApplicationsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListSimulationApplicationsError {
    fn code(&self) -> Option<&str> {
        ListSimulationApplicationsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListSimulationApplicationsError {
    pub fn new(kind: ListSimulationApplicationsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListSimulationApplicationsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListSimulationApplicationsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListSimulationApplicationsErrorKind::InternalServerException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListSimulationApplicationsErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListSimulationApplicationsErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for ListSimulationApplicationsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListSimulationApplicationsErrorKind::InternalServerException(_inner) => Some(_inner),
            ListSimulationApplicationsErrorKind::InvalidParameterException(_inner) => Some(_inner),
            ListSimulationApplicationsErrorKind::ThrottlingException(_inner) => Some(_inner),
            ListSimulationApplicationsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListSimulationJobBatchesError {
    pub kind: ListSimulationJobBatchesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListSimulationJobBatchesErrorKind {
    InternalServerException(crate::error::InternalServerException),
    InvalidParameterException(crate::error::InvalidParameterException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListSimulationJobBatchesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListSimulationJobBatchesErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            ListSimulationJobBatchesErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            ListSimulationJobBatchesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListSimulationJobBatchesError {
    fn code(&self) -> Option<&str> {
        ListSimulationJobBatchesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListSimulationJobBatchesError {
    pub fn new(kind: ListSimulationJobBatchesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListSimulationJobBatchesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListSimulationJobBatchesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListSimulationJobBatchesErrorKind::InternalServerException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListSimulationJobBatchesErrorKind::InvalidParameterException(_)
        )
    }
}
impl std::error::Error for ListSimulationJobBatchesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListSimulationJobBatchesErrorKind::InternalServerException(_inner) => Some(_inner),
            ListSimulationJobBatchesErrorKind::InvalidParameterException(_inner) => Some(_inner),
            ListSimulationJobBatchesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListSimulationJobsError {
    pub kind: ListSimulationJobsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListSimulationJobsErrorKind {
    InternalServerException(crate::error::InternalServerException),
    InvalidParameterException(crate::error::InvalidParameterException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListSimulationJobsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListSimulationJobsErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            ListSimulationJobsErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            ListSimulationJobsErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            ListSimulationJobsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListSimulationJobsError {
    fn code(&self) -> Option<&str> {
        ListSimulationJobsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListSimulationJobsError {
    pub fn new(kind: ListSimulationJobsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListSimulationJobsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListSimulationJobsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListSimulationJobsErrorKind::InternalServerException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListSimulationJobsErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListSimulationJobsErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for ListSimulationJobsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListSimulationJobsErrorKind::InternalServerException(_inner) => Some(_inner),
            ListSimulationJobsErrorKind::InvalidParameterException(_inner) => Some(_inner),
            ListSimulationJobsErrorKind::ThrottlingException(_inner) => Some(_inner),
            ListSimulationJobsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListTagsForResourceError {
    pub kind: ListTagsForResourceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListTagsForResourceErrorKind {
    InternalServerException(crate::error::InternalServerException),
    InvalidParameterException(crate::error::InvalidParameterException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListTagsForResourceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListTagsForResourceErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            ListTagsForResourceErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            ListTagsForResourceErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            ListTagsForResourceErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            ListTagsForResourceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListTagsForResourceError {
    fn code(&self) -> Option<&str> {
        ListTagsForResourceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListTagsForResourceError {
    pub fn new(kind: ListTagsForResourceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListTagsForResourceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListTagsForResourceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListTagsForResourceErrorKind::InternalServerException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListTagsForResourceErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListTagsForResourceErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListTagsForResourceErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for ListTagsForResourceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListTagsForResourceErrorKind::InternalServerException(_inner) => Some(_inner),
            ListTagsForResourceErrorKind::InvalidParameterException(_inner) => Some(_inner),
            ListTagsForResourceErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            ListTagsForResourceErrorKind::ThrottlingException(_inner) => Some(_inner),
            ListTagsForResourceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListWorldExportJobsError {
    pub kind: ListWorldExportJobsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListWorldExportJobsErrorKind {
    InternalServerException(crate::error::InternalServerException),
    InvalidParameterException(crate::error::InvalidParameterException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListWorldExportJobsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListWorldExportJobsErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            ListWorldExportJobsErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            ListWorldExportJobsErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            ListWorldExportJobsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListWorldExportJobsError {
    fn code(&self) -> Option<&str> {
        ListWorldExportJobsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListWorldExportJobsError {
    pub fn new(kind: ListWorldExportJobsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListWorldExportJobsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListWorldExportJobsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListWorldExportJobsErrorKind::InternalServerException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListWorldExportJobsErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListWorldExportJobsErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for ListWorldExportJobsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListWorldExportJobsErrorKind::InternalServerException(_inner) => Some(_inner),
            ListWorldExportJobsErrorKind::InvalidParameterException(_inner) => Some(_inner),
            ListWorldExportJobsErrorKind::ThrottlingException(_inner) => Some(_inner),
            ListWorldExportJobsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListWorldGenerationJobsError {
    pub kind: ListWorldGenerationJobsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListWorldGenerationJobsErrorKind {
    InternalServerException(crate::error::InternalServerException),
    InvalidParameterException(crate::error::InvalidParameterException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListWorldGenerationJobsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListWorldGenerationJobsErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            ListWorldGenerationJobsErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            ListWorldGenerationJobsErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            ListWorldGenerationJobsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListWorldGenerationJobsError {
    fn code(&self) -> Option<&str> {
        ListWorldGenerationJobsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListWorldGenerationJobsError {
    pub fn new(kind: ListWorldGenerationJobsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListWorldGenerationJobsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListWorldGenerationJobsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListWorldGenerationJobsErrorKind::InternalServerException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListWorldGenerationJobsErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListWorldGenerationJobsErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for ListWorldGenerationJobsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListWorldGenerationJobsErrorKind::InternalServerException(_inner) => Some(_inner),
            ListWorldGenerationJobsErrorKind::InvalidParameterException(_inner) => Some(_inner),
            ListWorldGenerationJobsErrorKind::ThrottlingException(_inner) => Some(_inner),
            ListWorldGenerationJobsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListWorldsError {
    pub kind: ListWorldsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListWorldsErrorKind {
    InternalServerException(crate::error::InternalServerException),
    InvalidParameterException(crate::error::InvalidParameterException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListWorldsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListWorldsErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            ListWorldsErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            ListWorldsErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            ListWorldsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListWorldsError {
    fn code(&self) -> Option<&str> {
        ListWorldsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListWorldsError {
    pub fn new(kind: ListWorldsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListWorldsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListWorldsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(&self.kind, ListWorldsErrorKind::InternalServerException(_))
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListWorldsErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, ListWorldsErrorKind::ThrottlingException(_))
    }
}
impl std::error::Error for ListWorldsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListWorldsErrorKind::InternalServerException(_inner) => Some(_inner),
            ListWorldsErrorKind::InvalidParameterException(_inner) => Some(_inner),
            ListWorldsErrorKind::ThrottlingException(_inner) => Some(_inner),
            ListWorldsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListWorldTemplatesError {
    pub kind: ListWorldTemplatesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListWorldTemplatesErrorKind {
    InternalServerException(crate::error::InternalServerException),
    InvalidParameterException(crate::error::InvalidParameterException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListWorldTemplatesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListWorldTemplatesErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            ListWorldTemplatesErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            ListWorldTemplatesErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            ListWorldTemplatesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListWorldTemplatesError {
    fn code(&self) -> Option<&str> {
        ListWorldTemplatesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListWorldTemplatesError {
    pub fn new(kind: ListWorldTemplatesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListWorldTemplatesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListWorldTemplatesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListWorldTemplatesErrorKind::InternalServerException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListWorldTemplatesErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListWorldTemplatesErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for ListWorldTemplatesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListWorldTemplatesErrorKind::InternalServerException(_inner) => Some(_inner),
            ListWorldTemplatesErrorKind::InvalidParameterException(_inner) => Some(_inner),
            ListWorldTemplatesErrorKind::ThrottlingException(_inner) => Some(_inner),
            ListWorldTemplatesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct RegisterRobotError {
    pub kind: RegisterRobotErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum RegisterRobotErrorKind {
    InternalServerException(crate::error::InternalServerException),
    InvalidParameterException(crate::error::InvalidParameterException),
    LimitExceededException(crate::error::LimitExceededException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for RegisterRobotError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            RegisterRobotErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            RegisterRobotErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            RegisterRobotErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            RegisterRobotErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            RegisterRobotErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            RegisterRobotErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for RegisterRobotError {
    fn code(&self) -> Option<&str> {
        RegisterRobotError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl RegisterRobotError {
    pub fn new(kind: RegisterRobotErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: RegisterRobotErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: RegisterRobotErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            RegisterRobotErrorKind::InternalServerException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            RegisterRobotErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            RegisterRobotErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            RegisterRobotErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, RegisterRobotErrorKind::ThrottlingException(_))
    }
}
impl std::error::Error for RegisterRobotError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            RegisterRobotErrorKind::InternalServerException(_inner) => Some(_inner),
            RegisterRobotErrorKind::InvalidParameterException(_inner) => Some(_inner),
            RegisterRobotErrorKind::LimitExceededException(_inner) => Some(_inner),
            RegisterRobotErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            RegisterRobotErrorKind::ThrottlingException(_inner) => Some(_inner),
            RegisterRobotErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct RestartSimulationJobError {
    pub kind: RestartSimulationJobErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum RestartSimulationJobErrorKind {
    InternalServerException(crate::error::InternalServerException),
    InvalidParameterException(crate::error::InvalidParameterException),
    LimitExceededException(crate::error::LimitExceededException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for RestartSimulationJobError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            RestartSimulationJobErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            RestartSimulationJobErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            RestartSimulationJobErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            RestartSimulationJobErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            RestartSimulationJobErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            RestartSimulationJobErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for RestartSimulationJobError {
    fn code(&self) -> Option<&str> {
        RestartSimulationJobError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl RestartSimulationJobError {
    pub fn new(kind: RestartSimulationJobErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: RestartSimulationJobErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: RestartSimulationJobErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            RestartSimulationJobErrorKind::InternalServerException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            RestartSimulationJobErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            RestartSimulationJobErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            RestartSimulationJobErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            RestartSimulationJobErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for RestartSimulationJobError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            RestartSimulationJobErrorKind::InternalServerException(_inner) => Some(_inner),
            RestartSimulationJobErrorKind::InvalidParameterException(_inner) => Some(_inner),
            RestartSimulationJobErrorKind::LimitExceededException(_inner) => Some(_inner),
            RestartSimulationJobErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            RestartSimulationJobErrorKind::ThrottlingException(_inner) => Some(_inner),
            RestartSimulationJobErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct StartSimulationJobBatchError {
    pub kind: StartSimulationJobBatchErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum StartSimulationJobBatchErrorKind {
    IdempotentParameterMismatchException(crate::error::IdempotentParameterMismatchException),
    InternalServerException(crate::error::InternalServerException),
    InvalidParameterException(crate::error::InvalidParameterException),
    LimitExceededException(crate::error::LimitExceededException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for StartSimulationJobBatchError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            StartSimulationJobBatchErrorKind::IdempotentParameterMismatchException(_inner) => {
                _inner.fmt(f)
            }
            StartSimulationJobBatchErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            StartSimulationJobBatchErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            StartSimulationJobBatchErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            StartSimulationJobBatchErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            StartSimulationJobBatchErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for StartSimulationJobBatchError {
    fn code(&self) -> Option<&str> {
        StartSimulationJobBatchError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl StartSimulationJobBatchError {
    pub fn new(kind: StartSimulationJobBatchErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: StartSimulationJobBatchErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: StartSimulationJobBatchErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_idempotent_parameter_mismatch_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartSimulationJobBatchErrorKind::IdempotentParameterMismatchException(_)
        )
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartSimulationJobBatchErrorKind::InternalServerException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartSimulationJobBatchErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartSimulationJobBatchErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartSimulationJobBatchErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for StartSimulationJobBatchError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            StartSimulationJobBatchErrorKind::IdempotentParameterMismatchException(_inner) => {
                Some(_inner)
            }
            StartSimulationJobBatchErrorKind::InternalServerException(_inner) => Some(_inner),
            StartSimulationJobBatchErrorKind::InvalidParameterException(_inner) => Some(_inner),
            StartSimulationJobBatchErrorKind::LimitExceededException(_inner) => Some(_inner),
            StartSimulationJobBatchErrorKind::ThrottlingException(_inner) => Some(_inner),
            StartSimulationJobBatchErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct SyncDeploymentJobError {
    pub kind: SyncDeploymentJobErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum SyncDeploymentJobErrorKind {
    ConcurrentDeploymentException(crate::error::ConcurrentDeploymentException),
    IdempotentParameterMismatchException(crate::error::IdempotentParameterMismatchException),
    InternalServerException(crate::error::InternalServerException),
    InvalidParameterException(crate::error::InvalidParameterException),
    LimitExceededException(crate::error::LimitExceededException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for SyncDeploymentJobError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            SyncDeploymentJobErrorKind::ConcurrentDeploymentException(_inner) => _inner.fmt(f),
            SyncDeploymentJobErrorKind::IdempotentParameterMismatchException(_inner) => {
                _inner.fmt(f)
            }
            SyncDeploymentJobErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            SyncDeploymentJobErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            SyncDeploymentJobErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            SyncDeploymentJobErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            SyncDeploymentJobErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            SyncDeploymentJobErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for SyncDeploymentJobError {
    fn code(&self) -> Option<&str> {
        SyncDeploymentJobError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl SyncDeploymentJobError {
    pub fn new(kind: SyncDeploymentJobErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: SyncDeploymentJobErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: SyncDeploymentJobErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_concurrent_deployment_exception(&self) -> bool {
        matches!(
            &self.kind,
            SyncDeploymentJobErrorKind::ConcurrentDeploymentException(_)
        )
    }
    pub fn is_idempotent_parameter_mismatch_exception(&self) -> bool {
        matches!(
            &self.kind,
            SyncDeploymentJobErrorKind::IdempotentParameterMismatchException(_)
        )
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            SyncDeploymentJobErrorKind::InternalServerException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            SyncDeploymentJobErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            SyncDeploymentJobErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            SyncDeploymentJobErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            SyncDeploymentJobErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for SyncDeploymentJobError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            SyncDeploymentJobErrorKind::ConcurrentDeploymentException(_inner) => Some(_inner),
            SyncDeploymentJobErrorKind::IdempotentParameterMismatchException(_inner) => {
                Some(_inner)
            }
            SyncDeploymentJobErrorKind::InternalServerException(_inner) => Some(_inner),
            SyncDeploymentJobErrorKind::InvalidParameterException(_inner) => Some(_inner),
            SyncDeploymentJobErrorKind::LimitExceededException(_inner) => Some(_inner),
            SyncDeploymentJobErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            SyncDeploymentJobErrorKind::ThrottlingException(_inner) => Some(_inner),
            SyncDeploymentJobErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct TagResourceError {
    pub kind: TagResourceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum TagResourceErrorKind {
    InternalServerException(crate::error::InternalServerException),
    InvalidParameterException(crate::error::InvalidParameterException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for TagResourceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            TagResourceErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            TagResourceErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            TagResourceErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            TagResourceErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            TagResourceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for TagResourceError {
    fn code(&self) -> Option<&str> {
        TagResourceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl TagResourceError {
    pub fn new(kind: TagResourceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: TagResourceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: TagResourceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(&self.kind, TagResourceErrorKind::InternalServerException(_))
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            TagResourceErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            TagResourceErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, TagResourceErrorKind::ThrottlingException(_))
    }
}
impl std::error::Error for TagResourceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            TagResourceErrorKind::InternalServerException(_inner) => Some(_inner),
            TagResourceErrorKind::InvalidParameterException(_inner) => Some(_inner),
            TagResourceErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            TagResourceErrorKind::ThrottlingException(_inner) => Some(_inner),
            TagResourceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UntagResourceError {
    pub kind: UntagResourceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UntagResourceErrorKind {
    InternalServerException(crate::error::InternalServerException),
    InvalidParameterException(crate::error::InvalidParameterException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UntagResourceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UntagResourceErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            UntagResourceErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            UntagResourceErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            UntagResourceErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            UntagResourceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UntagResourceError {
    fn code(&self) -> Option<&str> {
        UntagResourceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UntagResourceError {
    pub fn new(kind: UntagResourceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UntagResourceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UntagResourceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            UntagResourceErrorKind::InternalServerException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            UntagResourceErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UntagResourceErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, UntagResourceErrorKind::ThrottlingException(_))
    }
}
impl std::error::Error for UntagResourceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UntagResourceErrorKind::InternalServerException(_inner) => Some(_inner),
            UntagResourceErrorKind::InvalidParameterException(_inner) => Some(_inner),
            UntagResourceErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            UntagResourceErrorKind::ThrottlingException(_inner) => Some(_inner),
            UntagResourceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateRobotApplicationError {
    pub kind: UpdateRobotApplicationErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateRobotApplicationErrorKind {
    InternalServerException(crate::error::InternalServerException),
    InvalidParameterException(crate::error::InvalidParameterException),
    LimitExceededException(crate::error::LimitExceededException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateRobotApplicationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateRobotApplicationErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            UpdateRobotApplicationErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            UpdateRobotApplicationErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            UpdateRobotApplicationErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            UpdateRobotApplicationErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            UpdateRobotApplicationErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateRobotApplicationError {
    fn code(&self) -> Option<&str> {
        UpdateRobotApplicationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateRobotApplicationError {
    pub fn new(kind: UpdateRobotApplicationErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateRobotApplicationErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateRobotApplicationErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateRobotApplicationErrorKind::InternalServerException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateRobotApplicationErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateRobotApplicationErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateRobotApplicationErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateRobotApplicationErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for UpdateRobotApplicationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateRobotApplicationErrorKind::InternalServerException(_inner) => Some(_inner),
            UpdateRobotApplicationErrorKind::InvalidParameterException(_inner) => Some(_inner),
            UpdateRobotApplicationErrorKind::LimitExceededException(_inner) => Some(_inner),
            UpdateRobotApplicationErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            UpdateRobotApplicationErrorKind::ThrottlingException(_inner) => Some(_inner),
            UpdateRobotApplicationErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateSimulationApplicationError {
    pub kind: UpdateSimulationApplicationErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateSimulationApplicationErrorKind {
    InternalServerException(crate::error::InternalServerException),
    InvalidParameterException(crate::error::InvalidParameterException),
    LimitExceededException(crate::error::LimitExceededException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateSimulationApplicationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateSimulationApplicationErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            UpdateSimulationApplicationErrorKind::InvalidParameterException(_inner) => {
                _inner.fmt(f)
            }
            UpdateSimulationApplicationErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            UpdateSimulationApplicationErrorKind::ResourceNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            UpdateSimulationApplicationErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            UpdateSimulationApplicationErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateSimulationApplicationError {
    fn code(&self) -> Option<&str> {
        UpdateSimulationApplicationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateSimulationApplicationError {
    pub fn new(kind: UpdateSimulationApplicationErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateSimulationApplicationErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateSimulationApplicationErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateSimulationApplicationErrorKind::InternalServerException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateSimulationApplicationErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateSimulationApplicationErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateSimulationApplicationErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateSimulationApplicationErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for UpdateSimulationApplicationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateSimulationApplicationErrorKind::InternalServerException(_inner) => Some(_inner),
            UpdateSimulationApplicationErrorKind::InvalidParameterException(_inner) => Some(_inner),
            UpdateSimulationApplicationErrorKind::LimitExceededException(_inner) => Some(_inner),
            UpdateSimulationApplicationErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            UpdateSimulationApplicationErrorKind::ThrottlingException(_inner) => Some(_inner),
            UpdateSimulationApplicationErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateWorldTemplateError {
    pub kind: UpdateWorldTemplateErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateWorldTemplateErrorKind {
    InternalServerException(crate::error::InternalServerException),
    InvalidParameterException(crate::error::InvalidParameterException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateWorldTemplateError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateWorldTemplateErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            UpdateWorldTemplateErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            UpdateWorldTemplateErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            UpdateWorldTemplateErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            UpdateWorldTemplateErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateWorldTemplateError {
    fn code(&self) -> Option<&str> {
        UpdateWorldTemplateError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateWorldTemplateError {
    pub fn new(kind: UpdateWorldTemplateErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateWorldTemplateErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateWorldTemplateErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateWorldTemplateErrorKind::InternalServerException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateWorldTemplateErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateWorldTemplateErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateWorldTemplateErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for UpdateWorldTemplateError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateWorldTemplateErrorKind::InternalServerException(_inner) => Some(_inner),
            UpdateWorldTemplateErrorKind::InvalidParameterException(_inner) => Some(_inner),
            UpdateWorldTemplateErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            UpdateWorldTemplateErrorKind::ThrottlingException(_inner) => Some(_inner),
            UpdateWorldTemplateErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// <p>AWS RoboMaker is temporarily unable to process the request. Try your call again.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ThrottlingException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ThrottlingException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ThrottlingException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ThrottlingException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ThrottlingException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ThrottlingException")?;
        if let Some(inner_1) = &self.message {
            write!(f, ": {}", inner_1)?;
        }
        Ok(())
    }
}
impl std::error::Error for ThrottlingException {}
/// See [`ThrottlingException`](crate::error::ThrottlingException)
pub mod throttling_exception {
    /// A builder for [`ThrottlingException`](crate::error::ThrottlingException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ThrottlingException`](crate::error::ThrottlingException)
        pub fn build(self) -> crate::error::ThrottlingException {
            crate::error::ThrottlingException {
                message: self.message,
            }
        }
    }
}
impl ThrottlingException {
    /// Creates a new builder-style object to manufacture [`ThrottlingException`](crate::error::ThrottlingException)
    pub fn builder() -> crate::error::throttling_exception::Builder {
        crate::error::throttling_exception::Builder::default()
    }
}

/// <p>The specified resource does not exist.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ResourceNotFoundException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ResourceNotFoundException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ResourceNotFoundException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ResourceNotFoundException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ResourceNotFoundException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ResourceNotFoundException")?;
        if let Some(inner_2) = &self.message {
            write!(f, ": {}", inner_2)?;
        }
        Ok(())
    }
}
impl std::error::Error for ResourceNotFoundException {}
/// See [`ResourceNotFoundException`](crate::error::ResourceNotFoundException)
pub mod resource_not_found_exception {
    /// A builder for [`ResourceNotFoundException`](crate::error::ResourceNotFoundException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ResourceNotFoundException`](crate::error::ResourceNotFoundException)
        pub fn build(self) -> crate::error::ResourceNotFoundException {
            crate::error::ResourceNotFoundException {
                message: self.message,
            }
        }
    }
}
impl ResourceNotFoundException {
    /// Creates a new builder-style object to manufacture [`ResourceNotFoundException`](crate::error::ResourceNotFoundException)
    pub fn builder() -> crate::error::resource_not_found_exception::Builder {
        crate::error::resource_not_found_exception::Builder::default()
    }
}

/// <p>A parameter specified in a request is not valid, is unsupported, or cannot be used. The
/// returned message provides an explanation of the error value.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidParameterException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidParameterException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidParameterException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidParameterException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidParameterException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidParameterException")?;
        if let Some(inner_3) = &self.message {
            write!(f, ": {}", inner_3)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidParameterException {}
/// See [`InvalidParameterException`](crate::error::InvalidParameterException)
pub mod invalid_parameter_exception {
    /// A builder for [`InvalidParameterException`](crate::error::InvalidParameterException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidParameterException`](crate::error::InvalidParameterException)
        pub fn build(self) -> crate::error::InvalidParameterException {
            crate::error::InvalidParameterException {
                message: self.message,
            }
        }
    }
}
impl InvalidParameterException {
    /// Creates a new builder-style object to manufacture [`InvalidParameterException`](crate::error::InvalidParameterException)
    pub fn builder() -> crate::error::invalid_parameter_exception::Builder {
        crate::error::invalid_parameter_exception::Builder::default()
    }
}

/// <p>AWS RoboMaker experienced a service issue. Try your call again.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InternalServerException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InternalServerException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InternalServerException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InternalServerException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InternalServerException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InternalServerException")?;
        if let Some(inner_4) = &self.message {
            write!(f, ": {}", inner_4)?;
        }
        Ok(())
    }
}
impl std::error::Error for InternalServerException {}
/// See [`InternalServerException`](crate::error::InternalServerException)
pub mod internal_server_exception {
    /// A builder for [`InternalServerException`](crate::error::InternalServerException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InternalServerException`](crate::error::InternalServerException)
        pub fn build(self) -> crate::error::InternalServerException {
            crate::error::InternalServerException {
                message: self.message,
            }
        }
    }
}
impl InternalServerException {
    /// Creates a new builder-style object to manufacture [`InternalServerException`](crate::error::InternalServerException)
    pub fn builder() -> crate::error::internal_server_exception::Builder {
        crate::error::internal_server_exception::Builder::default()
    }
}

/// <p>The requested resource exceeds the maximum number allowed, or the number of concurrent
/// stream requests exceeds the maximum number allowed. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct LimitExceededException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for LimitExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("LimitExceededException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl LimitExceededException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for LimitExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "LimitExceededException")?;
        if let Some(inner_5) = &self.message {
            write!(f, ": {}", inner_5)?;
        }
        Ok(())
    }
}
impl std::error::Error for LimitExceededException {}
/// See [`LimitExceededException`](crate::error::LimitExceededException)
pub mod limit_exceeded_exception {
    /// A builder for [`LimitExceededException`](crate::error::LimitExceededException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`LimitExceededException`](crate::error::LimitExceededException)
        pub fn build(self) -> crate::error::LimitExceededException {
            crate::error::LimitExceededException {
                message: self.message,
            }
        }
    }
}
impl LimitExceededException {
    /// Creates a new builder-style object to manufacture [`LimitExceededException`](crate::error::LimitExceededException)
    pub fn builder() -> crate::error::limit_exceeded_exception::Builder {
        crate::error::limit_exceeded_exception::Builder::default()
    }
}

/// <p>The request uses the same client token as a previous, but non-identical request. Do not
/// reuse a client token with different requests, unless the requests are identical. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct IdempotentParameterMismatchException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for IdempotentParameterMismatchException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("IdempotentParameterMismatchException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl IdempotentParameterMismatchException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for IdempotentParameterMismatchException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "IdempotentParameterMismatchException")?;
        if let Some(inner_6) = &self.message {
            write!(f, ": {}", inner_6)?;
        }
        Ok(())
    }
}
impl std::error::Error for IdempotentParameterMismatchException {}
/// See [`IdempotentParameterMismatchException`](crate::error::IdempotentParameterMismatchException)
pub mod idempotent_parameter_mismatch_exception {
    /// A builder for [`IdempotentParameterMismatchException`](crate::error::IdempotentParameterMismatchException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`IdempotentParameterMismatchException`](crate::error::IdempotentParameterMismatchException)
        pub fn build(self) -> crate::error::IdempotentParameterMismatchException {
            crate::error::IdempotentParameterMismatchException {
                message: self.message,
            }
        }
    }
}
impl IdempotentParameterMismatchException {
    /// Creates a new builder-style object to manufacture [`IdempotentParameterMismatchException`](crate::error::IdempotentParameterMismatchException)
    pub fn builder() -> crate::error::idempotent_parameter_mismatch_exception::Builder {
        crate::error::idempotent_parameter_mismatch_exception::Builder::default()
    }
}

/// <p>The failure percentage threshold percentage was met.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ConcurrentDeploymentException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ConcurrentDeploymentException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ConcurrentDeploymentException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ConcurrentDeploymentException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ConcurrentDeploymentException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ConcurrentDeploymentException")?;
        if let Some(inner_7) = &self.message {
            write!(f, ": {}", inner_7)?;
        }
        Ok(())
    }
}
impl std::error::Error for ConcurrentDeploymentException {}
/// See [`ConcurrentDeploymentException`](crate::error::ConcurrentDeploymentException)
pub mod concurrent_deployment_exception {
    /// A builder for [`ConcurrentDeploymentException`](crate::error::ConcurrentDeploymentException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ConcurrentDeploymentException`](crate::error::ConcurrentDeploymentException)
        pub fn build(self) -> crate::error::ConcurrentDeploymentException {
            crate::error::ConcurrentDeploymentException {
                message: self.message,
            }
        }
    }
}
impl ConcurrentDeploymentException {
    /// Creates a new builder-style object to manufacture [`ConcurrentDeploymentException`](crate::error::ConcurrentDeploymentException)
    pub fn builder() -> crate::error::concurrent_deployment_exception::Builder {
        crate::error::concurrent_deployment_exception::Builder::default()
    }
}

/// <p>The specified resource already exists.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ResourceAlreadyExistsException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ResourceAlreadyExistsException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ResourceAlreadyExistsException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ResourceAlreadyExistsException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ResourceAlreadyExistsException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ResourceAlreadyExistsException")?;
        if let Some(inner_8) = &self.message {
            write!(f, ": {}", inner_8)?;
        }
        Ok(())
    }
}
impl std::error::Error for ResourceAlreadyExistsException {}
/// See [`ResourceAlreadyExistsException`](crate::error::ResourceAlreadyExistsException)
pub mod resource_already_exists_exception {
    /// A builder for [`ResourceAlreadyExistsException`](crate::error::ResourceAlreadyExistsException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ResourceAlreadyExistsException`](crate::error::ResourceAlreadyExistsException)
        pub fn build(self) -> crate::error::ResourceAlreadyExistsException {
            crate::error::ResourceAlreadyExistsException {
                message: self.message,
            }
        }
    }
}
impl ResourceAlreadyExistsException {
    /// Creates a new builder-style object to manufacture [`ResourceAlreadyExistsException`](crate::error::ResourceAlreadyExistsException)
    pub fn builder() -> crate::error::resource_already_exists_exception::Builder {
        crate::error::resource_already_exists_exception::Builder::default()
    }
}

/// <p>The request has failed due to a temporary failure of the server.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ServiceUnavailableException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ServiceUnavailableException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ServiceUnavailableException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ServiceUnavailableException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ServiceUnavailableException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ServiceUnavailableException")?;
        if let Some(inner_9) = &self.message {
            write!(f, ": {}", inner_9)?;
        }
        Ok(())
    }
}
impl std::error::Error for ServiceUnavailableException {}
/// See [`ServiceUnavailableException`](crate::error::ServiceUnavailableException)
pub mod service_unavailable_exception {
    /// A builder for [`ServiceUnavailableException`](crate::error::ServiceUnavailableException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ServiceUnavailableException`](crate::error::ServiceUnavailableException)
        pub fn build(self) -> crate::error::ServiceUnavailableException {
            crate::error::ServiceUnavailableException {
                message: self.message,
            }
        }
    }
}
impl ServiceUnavailableException {
    /// Creates a new builder-style object to manufacture [`ServiceUnavailableException`](crate::error::ServiceUnavailableException)
    pub fn builder() -> crate::error::service_unavailable_exception::Builder {
        crate::error::service_unavailable_exception::Builder::default()
    }
}
