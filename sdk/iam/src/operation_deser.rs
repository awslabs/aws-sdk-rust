// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[allow(clippy::unnecessary_wraps)]
pub fn parse_add_client_id_to_open_id_connect_provider_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<
    crate::output::AddClientIDToOpenIDConnectProviderOutput,
    crate::error::AddClientIDToOpenIDConnectProviderError,
> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::AddClientIDToOpenIDConnectProviderError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::AddClientIDToOpenIDConnectProviderError::unhandled(generic))
        }
    };
    Err(match error_code {
        "InvalidInputException" => crate::error::AddClientIDToOpenIDConnectProviderError {
            meta: generic,
            kind: crate::error::AddClientIDToOpenIDConnectProviderErrorKind::InvalidInputError({
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_input_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_invalid_input_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::AddClientIDToOpenIDConnectProviderError::unhandled)?;
                output.build()
            }),
        },
        "LimitExceededException" => crate::error::AddClientIDToOpenIDConnectProviderError {
            meta: generic,
            kind: crate::error::AddClientIDToOpenIDConnectProviderErrorKind::LimitExceededError({
                #[allow(unused_mut)]
                let mut output = crate::error::limit_exceeded_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_limit_exceeded_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::AddClientIDToOpenIDConnectProviderError::unhandled)?;
                output.build()
            }),
        },
        "NoSuchEntityException" => crate::error::AddClientIDToOpenIDConnectProviderError {
            meta: generic,
            kind: crate::error::AddClientIDToOpenIDConnectProviderErrorKind::NoSuchEntityError({
                #[allow(unused_mut)]
                let mut output = crate::error::no_such_entity_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_no_such_entity_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::AddClientIDToOpenIDConnectProviderError::unhandled)?;
                output.build()
            }),
        },
        "ServiceFailureException" => crate::error::AddClientIDToOpenIDConnectProviderError {
            meta: generic,
            kind: crate::error::AddClientIDToOpenIDConnectProviderErrorKind::ServiceFailureError({
                #[allow(unused_mut)]
                let mut output = crate::error::service_failure_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_service_failure_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::AddClientIDToOpenIDConnectProviderError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::AddClientIDToOpenIDConnectProviderError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_add_client_id_to_open_id_connect_provider_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<
    crate::output::AddClientIDToOpenIDConnectProviderOutput,
    crate::error::AddClientIDToOpenIDConnectProviderError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::add_client_id_to_open_id_connect_provider_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_add_role_to_instance_profile_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<
    crate::output::AddRoleToInstanceProfileOutput,
    crate::error::AddRoleToInstanceProfileError,
> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::AddRoleToInstanceProfileError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::AddRoleToInstanceProfileError::unhandled(
                generic,
            ))
        }
    };
    Err(match error_code {
        "EntityAlreadyExistsException" => crate::error::AddRoleToInstanceProfileError {
            meta: generic,
            kind: crate::error::AddRoleToInstanceProfileErrorKind::EntityAlreadyExistsError({
                #[allow(unused_mut)]
                let mut output = crate::error::entity_already_exists_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_entity_already_exists_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::AddRoleToInstanceProfileError::unhandled)?;
                output.build()
            }),
        },
        "LimitExceededException" => crate::error::AddRoleToInstanceProfileError {
            meta: generic,
            kind: crate::error::AddRoleToInstanceProfileErrorKind::LimitExceededError({
                #[allow(unused_mut)]
                let mut output = crate::error::limit_exceeded_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_limit_exceeded_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::AddRoleToInstanceProfileError::unhandled)?;
                output.build()
            }),
        },
        "NoSuchEntityException" => crate::error::AddRoleToInstanceProfileError {
            meta: generic,
            kind: crate::error::AddRoleToInstanceProfileErrorKind::NoSuchEntityError({
                #[allow(unused_mut)]
                let mut output = crate::error::no_such_entity_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_no_such_entity_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::AddRoleToInstanceProfileError::unhandled)?;
                output.build()
            }),
        },
        "ServiceFailureException" => crate::error::AddRoleToInstanceProfileError {
            meta: generic,
            kind: crate::error::AddRoleToInstanceProfileErrorKind::ServiceFailureError({
                #[allow(unused_mut)]
                let mut output = crate::error::service_failure_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_service_failure_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::AddRoleToInstanceProfileError::unhandled)?;
                output.build()
            }),
        },
        "UnmodifiableEntityException" => crate::error::AddRoleToInstanceProfileError {
            meta: generic,
            kind: crate::error::AddRoleToInstanceProfileErrorKind::UnmodifiableEntityError({
                #[allow(unused_mut)]
                let mut output = crate::error::unmodifiable_entity_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_unmodifiable_entity_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::AddRoleToInstanceProfileError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::AddRoleToInstanceProfileError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_add_role_to_instance_profile_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<
    crate::output::AddRoleToInstanceProfileOutput,
    crate::error::AddRoleToInstanceProfileError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::add_role_to_instance_profile_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_add_user_to_group_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::AddUserToGroupOutput, crate::error::AddUserToGroupError> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::AddUserToGroupError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::AddUserToGroupError::unhandled(generic)),
    };
    Err(match error_code {
        "LimitExceededException" => crate::error::AddUserToGroupError {
            meta: generic,
            kind: crate::error::AddUserToGroupErrorKind::LimitExceededError({
                #[allow(unused_mut)]
                let mut output = crate::error::limit_exceeded_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_limit_exceeded_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::AddUserToGroupError::unhandled)?;
                output.build()
            }),
        },
        "NoSuchEntityException" => crate::error::AddUserToGroupError {
            meta: generic,
            kind: crate::error::AddUserToGroupErrorKind::NoSuchEntityError({
                #[allow(unused_mut)]
                let mut output = crate::error::no_such_entity_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_no_such_entity_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::AddUserToGroupError::unhandled)?;
                output.build()
            }),
        },
        "ServiceFailureException" => crate::error::AddUserToGroupError {
            meta: generic,
            kind: crate::error::AddUserToGroupErrorKind::ServiceFailureError({
                #[allow(unused_mut)]
                let mut output = crate::error::service_failure_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_service_failure_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::AddUserToGroupError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::AddUserToGroupError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_add_user_to_group_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::AddUserToGroupOutput, crate::error::AddUserToGroupError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::add_user_to_group_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_attach_group_policy_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::AttachGroupPolicyOutput, crate::error::AttachGroupPolicyError> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::AttachGroupPolicyError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::AttachGroupPolicyError::unhandled(generic)),
    };
    Err(match error_code {
        "InvalidInputException" => crate::error::AttachGroupPolicyError {
            meta: generic,
            kind: crate::error::AttachGroupPolicyErrorKind::InvalidInputError({
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_input_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_invalid_input_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::AttachGroupPolicyError::unhandled)?;
                output.build()
            }),
        },
        "LimitExceededException" => crate::error::AttachGroupPolicyError {
            meta: generic,
            kind: crate::error::AttachGroupPolicyErrorKind::LimitExceededError({
                #[allow(unused_mut)]
                let mut output = crate::error::limit_exceeded_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_limit_exceeded_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::AttachGroupPolicyError::unhandled)?;
                output.build()
            }),
        },
        "NoSuchEntityException" => crate::error::AttachGroupPolicyError {
            meta: generic,
            kind: crate::error::AttachGroupPolicyErrorKind::NoSuchEntityError({
                #[allow(unused_mut)]
                let mut output = crate::error::no_such_entity_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_no_such_entity_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::AttachGroupPolicyError::unhandled)?;
                output.build()
            }),
        },
        "PolicyNotAttachableException" => crate::error::AttachGroupPolicyError {
            meta: generic,
            kind: crate::error::AttachGroupPolicyErrorKind::PolicyNotAttachableError({
                #[allow(unused_mut)]
                let mut output = crate::error::policy_not_attachable_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_policy_not_attachable_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::AttachGroupPolicyError::unhandled)?;
                output.build()
            }),
        },
        "ServiceFailureException" => crate::error::AttachGroupPolicyError {
            meta: generic,
            kind: crate::error::AttachGroupPolicyErrorKind::ServiceFailureError({
                #[allow(unused_mut)]
                let mut output = crate::error::service_failure_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_service_failure_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::AttachGroupPolicyError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::AttachGroupPolicyError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_attach_group_policy_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::AttachGroupPolicyOutput, crate::error::AttachGroupPolicyError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::attach_group_policy_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_attach_role_policy_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::AttachRolePolicyOutput, crate::error::AttachRolePolicyError> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::AttachRolePolicyError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::AttachRolePolicyError::unhandled(generic)),
    };
    Err(match error_code {
        "InvalidInputException" => crate::error::AttachRolePolicyError {
            meta: generic,
            kind: crate::error::AttachRolePolicyErrorKind::InvalidInputError({
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_input_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_invalid_input_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::AttachRolePolicyError::unhandled)?;
                output.build()
            }),
        },
        "LimitExceededException" => crate::error::AttachRolePolicyError {
            meta: generic,
            kind: crate::error::AttachRolePolicyErrorKind::LimitExceededError({
                #[allow(unused_mut)]
                let mut output = crate::error::limit_exceeded_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_limit_exceeded_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::AttachRolePolicyError::unhandled)?;
                output.build()
            }),
        },
        "NoSuchEntityException" => crate::error::AttachRolePolicyError {
            meta: generic,
            kind: crate::error::AttachRolePolicyErrorKind::NoSuchEntityError({
                #[allow(unused_mut)]
                let mut output = crate::error::no_such_entity_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_no_such_entity_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::AttachRolePolicyError::unhandled)?;
                output.build()
            }),
        },
        "PolicyNotAttachableException" => crate::error::AttachRolePolicyError {
            meta: generic,
            kind: crate::error::AttachRolePolicyErrorKind::PolicyNotAttachableError({
                #[allow(unused_mut)]
                let mut output = crate::error::policy_not_attachable_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_policy_not_attachable_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::AttachRolePolicyError::unhandled)?;
                output.build()
            }),
        },
        "ServiceFailureException" => crate::error::AttachRolePolicyError {
            meta: generic,
            kind: crate::error::AttachRolePolicyErrorKind::ServiceFailureError({
                #[allow(unused_mut)]
                let mut output = crate::error::service_failure_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_service_failure_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::AttachRolePolicyError::unhandled)?;
                output.build()
            }),
        },
        "UnmodifiableEntityException" => crate::error::AttachRolePolicyError {
            meta: generic,
            kind: crate::error::AttachRolePolicyErrorKind::UnmodifiableEntityError({
                #[allow(unused_mut)]
                let mut output = crate::error::unmodifiable_entity_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_unmodifiable_entity_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::AttachRolePolicyError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::AttachRolePolicyError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_attach_role_policy_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::AttachRolePolicyOutput, crate::error::AttachRolePolicyError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::attach_role_policy_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_attach_user_policy_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::AttachUserPolicyOutput, crate::error::AttachUserPolicyError> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::AttachUserPolicyError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::AttachUserPolicyError::unhandled(generic)),
    };
    Err(match error_code {
        "InvalidInputException" => crate::error::AttachUserPolicyError {
            meta: generic,
            kind: crate::error::AttachUserPolicyErrorKind::InvalidInputError({
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_input_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_invalid_input_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::AttachUserPolicyError::unhandled)?;
                output.build()
            }),
        },
        "LimitExceededException" => crate::error::AttachUserPolicyError {
            meta: generic,
            kind: crate::error::AttachUserPolicyErrorKind::LimitExceededError({
                #[allow(unused_mut)]
                let mut output = crate::error::limit_exceeded_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_limit_exceeded_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::AttachUserPolicyError::unhandled)?;
                output.build()
            }),
        },
        "NoSuchEntityException" => crate::error::AttachUserPolicyError {
            meta: generic,
            kind: crate::error::AttachUserPolicyErrorKind::NoSuchEntityError({
                #[allow(unused_mut)]
                let mut output = crate::error::no_such_entity_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_no_such_entity_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::AttachUserPolicyError::unhandled)?;
                output.build()
            }),
        },
        "PolicyNotAttachableException" => crate::error::AttachUserPolicyError {
            meta: generic,
            kind: crate::error::AttachUserPolicyErrorKind::PolicyNotAttachableError({
                #[allow(unused_mut)]
                let mut output = crate::error::policy_not_attachable_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_policy_not_attachable_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::AttachUserPolicyError::unhandled)?;
                output.build()
            }),
        },
        "ServiceFailureException" => crate::error::AttachUserPolicyError {
            meta: generic,
            kind: crate::error::AttachUserPolicyErrorKind::ServiceFailureError({
                #[allow(unused_mut)]
                let mut output = crate::error::service_failure_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_service_failure_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::AttachUserPolicyError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::AttachUserPolicyError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_attach_user_policy_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::AttachUserPolicyOutput, crate::error::AttachUserPolicyError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::attach_user_policy_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_change_password_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::ChangePasswordOutput, crate::error::ChangePasswordError> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::ChangePasswordError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ChangePasswordError::unhandled(generic)),
    };
    Err(match error_code {
        "EntityTemporarilyUnmodifiableException" => crate::error::ChangePasswordError {
            meta: generic,
            kind: crate::error::ChangePasswordErrorKind::EntityTemporarilyUnmodifiableError({
                #[allow(unused_mut)]
                let mut output =
                    crate::error::entity_temporarily_unmodifiable_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_entity_temporarily_unmodifiable_error_xml_err(response.body().as_ref(), output).map_err(crate::error::ChangePasswordError::unhandled)?;
                output.build()
            }),
        },
        "InvalidUserTypeException" => crate::error::ChangePasswordError {
            meta: generic,
            kind: crate::error::ChangePasswordErrorKind::InvalidUserTypeError({
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_user_type_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_invalid_user_type_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::ChangePasswordError::unhandled)?;
                output.build()
            }),
        },
        "LimitExceededException" => crate::error::ChangePasswordError {
            meta: generic,
            kind: crate::error::ChangePasswordErrorKind::LimitExceededError({
                #[allow(unused_mut)]
                let mut output = crate::error::limit_exceeded_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_limit_exceeded_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::ChangePasswordError::unhandled)?;
                output.build()
            }),
        },
        "NoSuchEntityException" => crate::error::ChangePasswordError {
            meta: generic,
            kind: crate::error::ChangePasswordErrorKind::NoSuchEntityError({
                #[allow(unused_mut)]
                let mut output = crate::error::no_such_entity_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_no_such_entity_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::ChangePasswordError::unhandled)?;
                output.build()
            }),
        },
        "PasswordPolicyViolationException" => crate::error::ChangePasswordError {
            meta: generic,
            kind: crate::error::ChangePasswordErrorKind::PasswordPolicyViolationError({
                #[allow(unused_mut)]
                let mut output = crate::error::password_policy_violation_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_password_policy_violation_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::ChangePasswordError::unhandled)?;
                output.build()
            }),
        },
        "ServiceFailureException" => crate::error::ChangePasswordError {
            meta: generic,
            kind: crate::error::ChangePasswordErrorKind::ServiceFailureError({
                #[allow(unused_mut)]
                let mut output = crate::error::service_failure_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_service_failure_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::ChangePasswordError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::ChangePasswordError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_change_password_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::ChangePasswordOutput, crate::error::ChangePasswordError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::change_password_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_access_key_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::CreateAccessKeyOutput, crate::error::CreateAccessKeyError> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::CreateAccessKeyError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::CreateAccessKeyError::unhandled(generic)),
    };
    Err(match error_code {
        "LimitExceededException" => crate::error::CreateAccessKeyError {
            meta: generic,
            kind: crate::error::CreateAccessKeyErrorKind::LimitExceededError({
                #[allow(unused_mut)]
                let mut output = crate::error::limit_exceeded_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_limit_exceeded_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::CreateAccessKeyError::unhandled)?;
                output.build()
            }),
        },
        "NoSuchEntityException" => crate::error::CreateAccessKeyError {
            meta: generic,
            kind: crate::error::CreateAccessKeyErrorKind::NoSuchEntityError({
                #[allow(unused_mut)]
                let mut output = crate::error::no_such_entity_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_no_such_entity_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::CreateAccessKeyError::unhandled)?;
                output.build()
            }),
        },
        "ServiceFailureException" => crate::error::CreateAccessKeyError {
            meta: generic,
            kind: crate::error::CreateAccessKeyErrorKind::ServiceFailureError({
                #[allow(unused_mut)]
                let mut output = crate::error::service_failure_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_service_failure_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::CreateAccessKeyError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::CreateAccessKeyError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_access_key_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::CreateAccessKeyOutput, crate::error::CreateAccessKeyError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_access_key_output::Builder::default();
        let _ = response;
        output =
            crate::xml_deser::deser_operation_create_access_key(response.body().as_ref(), output)
                .map_err(crate::error::CreateAccessKeyError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_account_alias_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::CreateAccountAliasOutput, crate::error::CreateAccountAliasError> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::CreateAccountAliasError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::CreateAccountAliasError::unhandled(generic)),
    };
    Err(match error_code {
        "EntityAlreadyExistsException" => crate::error::CreateAccountAliasError {
            meta: generic,
            kind: crate::error::CreateAccountAliasErrorKind::EntityAlreadyExistsError({
                #[allow(unused_mut)]
                let mut output = crate::error::entity_already_exists_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_entity_already_exists_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::CreateAccountAliasError::unhandled)?;
                output.build()
            }),
        },
        "LimitExceededException" => crate::error::CreateAccountAliasError {
            meta: generic,
            kind: crate::error::CreateAccountAliasErrorKind::LimitExceededError({
                #[allow(unused_mut)]
                let mut output = crate::error::limit_exceeded_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_limit_exceeded_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::CreateAccountAliasError::unhandled)?;
                output.build()
            }),
        },
        "ServiceFailureException" => crate::error::CreateAccountAliasError {
            meta: generic,
            kind: crate::error::CreateAccountAliasErrorKind::ServiceFailureError({
                #[allow(unused_mut)]
                let mut output = crate::error::service_failure_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_service_failure_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::CreateAccountAliasError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::CreateAccountAliasError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_account_alias_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::CreateAccountAliasOutput, crate::error::CreateAccountAliasError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_account_alias_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_group_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::CreateGroupOutput, crate::error::CreateGroupError> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::CreateGroupError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::CreateGroupError::unhandled(generic)),
    };
    Err(match error_code {
        "EntityAlreadyExistsException" => crate::error::CreateGroupError {
            meta: generic,
            kind: crate::error::CreateGroupErrorKind::EntityAlreadyExistsError({
                #[allow(unused_mut)]
                let mut output = crate::error::entity_already_exists_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_entity_already_exists_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::CreateGroupError::unhandled)?;
                output.build()
            }),
        },
        "LimitExceededException" => crate::error::CreateGroupError {
            meta: generic,
            kind: crate::error::CreateGroupErrorKind::LimitExceededError({
                #[allow(unused_mut)]
                let mut output = crate::error::limit_exceeded_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_limit_exceeded_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::CreateGroupError::unhandled)?;
                output.build()
            }),
        },
        "NoSuchEntityException" => crate::error::CreateGroupError {
            meta: generic,
            kind: crate::error::CreateGroupErrorKind::NoSuchEntityError({
                #[allow(unused_mut)]
                let mut output = crate::error::no_such_entity_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_no_such_entity_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::CreateGroupError::unhandled)?;
                output.build()
            }),
        },
        "ServiceFailureException" => crate::error::CreateGroupError {
            meta: generic,
            kind: crate::error::CreateGroupErrorKind::ServiceFailureError({
                #[allow(unused_mut)]
                let mut output = crate::error::service_failure_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_service_failure_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::CreateGroupError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::CreateGroupError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_group_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::CreateGroupOutput, crate::error::CreateGroupError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_group_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_create_group(response.body().as_ref(), output)
            .map_err(crate::error::CreateGroupError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_instance_profile_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::CreateInstanceProfileOutput, crate::error::CreateInstanceProfileError> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::CreateInstanceProfileError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::CreateInstanceProfileError::unhandled(generic)),
    };
    Err(match error_code {
        "ConcurrentModificationException" => crate::error::CreateInstanceProfileError {
            meta: generic,
            kind: crate::error::CreateInstanceProfileErrorKind::ConcurrentModificationError({
                #[allow(unused_mut)]
                let mut output = crate::error::concurrent_modification_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_concurrent_modification_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::CreateInstanceProfileError::unhandled)?;
                output.build()
            }),
        },
        "EntityAlreadyExistsException" => crate::error::CreateInstanceProfileError {
            meta: generic,
            kind: crate::error::CreateInstanceProfileErrorKind::EntityAlreadyExistsError({
                #[allow(unused_mut)]
                let mut output = crate::error::entity_already_exists_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_entity_already_exists_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::CreateInstanceProfileError::unhandled)?;
                output.build()
            }),
        },
        "InvalidInputException" => crate::error::CreateInstanceProfileError {
            meta: generic,
            kind: crate::error::CreateInstanceProfileErrorKind::InvalidInputError({
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_input_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_invalid_input_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::CreateInstanceProfileError::unhandled)?;
                output.build()
            }),
        },
        "LimitExceededException" => crate::error::CreateInstanceProfileError {
            meta: generic,
            kind: crate::error::CreateInstanceProfileErrorKind::LimitExceededError({
                #[allow(unused_mut)]
                let mut output = crate::error::limit_exceeded_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_limit_exceeded_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::CreateInstanceProfileError::unhandled)?;
                output.build()
            }),
        },
        "ServiceFailureException" => crate::error::CreateInstanceProfileError {
            meta: generic,
            kind: crate::error::CreateInstanceProfileErrorKind::ServiceFailureError({
                #[allow(unused_mut)]
                let mut output = crate::error::service_failure_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_service_failure_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::CreateInstanceProfileError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::CreateInstanceProfileError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_instance_profile_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::CreateInstanceProfileOutput, crate::error::CreateInstanceProfileError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_instance_profile_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_create_instance_profile(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreateInstanceProfileError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_login_profile_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::CreateLoginProfileOutput, crate::error::CreateLoginProfileError> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::CreateLoginProfileError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::CreateLoginProfileError::unhandled(generic)),
    };
    Err(match error_code {
        "EntityAlreadyExistsException" => crate::error::CreateLoginProfileError {
            meta: generic,
            kind: crate::error::CreateLoginProfileErrorKind::EntityAlreadyExistsError({
                #[allow(unused_mut)]
                let mut output = crate::error::entity_already_exists_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_entity_already_exists_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::CreateLoginProfileError::unhandled)?;
                output.build()
            }),
        },
        "LimitExceededException" => crate::error::CreateLoginProfileError {
            meta: generic,
            kind: crate::error::CreateLoginProfileErrorKind::LimitExceededError({
                #[allow(unused_mut)]
                let mut output = crate::error::limit_exceeded_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_limit_exceeded_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::CreateLoginProfileError::unhandled)?;
                output.build()
            }),
        },
        "NoSuchEntityException" => crate::error::CreateLoginProfileError {
            meta: generic,
            kind: crate::error::CreateLoginProfileErrorKind::NoSuchEntityError({
                #[allow(unused_mut)]
                let mut output = crate::error::no_such_entity_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_no_such_entity_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::CreateLoginProfileError::unhandled)?;
                output.build()
            }),
        },
        "PasswordPolicyViolationException" => crate::error::CreateLoginProfileError {
            meta: generic,
            kind: crate::error::CreateLoginProfileErrorKind::PasswordPolicyViolationError({
                #[allow(unused_mut)]
                let mut output = crate::error::password_policy_violation_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_password_policy_violation_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::CreateLoginProfileError::unhandled)?;
                output.build()
            }),
        },
        "ServiceFailureException" => crate::error::CreateLoginProfileError {
            meta: generic,
            kind: crate::error::CreateLoginProfileErrorKind::ServiceFailureError({
                #[allow(unused_mut)]
                let mut output = crate::error::service_failure_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_service_failure_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::CreateLoginProfileError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::CreateLoginProfileError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_login_profile_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::CreateLoginProfileOutput, crate::error::CreateLoginProfileError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_login_profile_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_create_login_profile(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreateLoginProfileError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_open_id_connect_provider_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<
    crate::output::CreateOpenIDConnectProviderOutput,
    crate::error::CreateOpenIDConnectProviderError,
> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::CreateOpenIDConnectProviderError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::CreateOpenIDConnectProviderError::unhandled(
                generic,
            ))
        }
    };
    Err(match error_code {
        "ConcurrentModificationException" => {
            crate::error::CreateOpenIDConnectProviderError {
                meta: generic,
                kind:
                    crate::error::CreateOpenIDConnectProviderErrorKind::ConcurrentModificationError(
                        {
                            #[allow(unused_mut)]
                            let mut output =
                                crate::error::concurrent_modification_error::Builder::default();
                            let _ = response;
                            output = crate::xml_deser::deser_structure_concurrent_modification_error_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateOpenIDConnectProviderError::unhandled)?;
                            output.build()
                        },
                    ),
            }
        }
        "EntityAlreadyExistsException" => crate::error::CreateOpenIDConnectProviderError {
            meta: generic,
            kind: crate::error::CreateOpenIDConnectProviderErrorKind::EntityAlreadyExistsError({
                #[allow(unused_mut)]
                let mut output = crate::error::entity_already_exists_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_entity_already_exists_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::CreateOpenIDConnectProviderError::unhandled)?;
                output.build()
            }),
        },
        "InvalidInputException" => crate::error::CreateOpenIDConnectProviderError {
            meta: generic,
            kind: crate::error::CreateOpenIDConnectProviderErrorKind::InvalidInputError({
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_input_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_invalid_input_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::CreateOpenIDConnectProviderError::unhandled)?;
                output.build()
            }),
        },
        "LimitExceededException" => crate::error::CreateOpenIDConnectProviderError {
            meta: generic,
            kind: crate::error::CreateOpenIDConnectProviderErrorKind::LimitExceededError({
                #[allow(unused_mut)]
                let mut output = crate::error::limit_exceeded_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_limit_exceeded_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::CreateOpenIDConnectProviderError::unhandled)?;
                output.build()
            }),
        },
        "ServiceFailureException" => crate::error::CreateOpenIDConnectProviderError {
            meta: generic,
            kind: crate::error::CreateOpenIDConnectProviderErrorKind::ServiceFailureError({
                #[allow(unused_mut)]
                let mut output = crate::error::service_failure_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_service_failure_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::CreateOpenIDConnectProviderError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::CreateOpenIDConnectProviderError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_open_id_connect_provider_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<
    crate::output::CreateOpenIDConnectProviderOutput,
    crate::error::CreateOpenIDConnectProviderError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_open_id_connect_provider_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_create_open_id_connect_provider(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreateOpenIDConnectProviderError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_policy_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::CreatePolicyOutput, crate::error::CreatePolicyError> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::CreatePolicyError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::CreatePolicyError::unhandled(generic)),
    };
    Err(match error_code {
        "ConcurrentModificationException" => crate::error::CreatePolicyError {
            meta: generic,
            kind: crate::error::CreatePolicyErrorKind::ConcurrentModificationError({
                #[allow(unused_mut)]
                let mut output = crate::error::concurrent_modification_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_concurrent_modification_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::CreatePolicyError::unhandled)?;
                output.build()
            }),
        },
        "EntityAlreadyExistsException" => crate::error::CreatePolicyError {
            meta: generic,
            kind: crate::error::CreatePolicyErrorKind::EntityAlreadyExistsError({
                #[allow(unused_mut)]
                let mut output = crate::error::entity_already_exists_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_entity_already_exists_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::CreatePolicyError::unhandled)?;
                output.build()
            }),
        },
        "InvalidInputException" => crate::error::CreatePolicyError {
            meta: generic,
            kind: crate::error::CreatePolicyErrorKind::InvalidInputError({
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_input_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_invalid_input_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::CreatePolicyError::unhandled)?;
                output.build()
            }),
        },
        "LimitExceededException" => crate::error::CreatePolicyError {
            meta: generic,
            kind: crate::error::CreatePolicyErrorKind::LimitExceededError({
                #[allow(unused_mut)]
                let mut output = crate::error::limit_exceeded_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_limit_exceeded_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::CreatePolicyError::unhandled)?;
                output.build()
            }),
        },
        "MalformedPolicyDocumentException" => crate::error::CreatePolicyError {
            meta: generic,
            kind: crate::error::CreatePolicyErrorKind::MalformedPolicyDocumentError({
                #[allow(unused_mut)]
                let mut output = crate::error::malformed_policy_document_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_malformed_policy_document_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::CreatePolicyError::unhandled)?;
                output.build()
            }),
        },
        "ServiceFailureException" => crate::error::CreatePolicyError {
            meta: generic,
            kind: crate::error::CreatePolicyErrorKind::ServiceFailureError({
                #[allow(unused_mut)]
                let mut output = crate::error::service_failure_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_service_failure_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::CreatePolicyError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::CreatePolicyError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_policy_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::CreatePolicyOutput, crate::error::CreatePolicyError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_policy_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_create_policy(response.body().as_ref(), output)
            .map_err(crate::error::CreatePolicyError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_policy_version_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::CreatePolicyVersionOutput, crate::error::CreatePolicyVersionError> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::CreatePolicyVersionError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::CreatePolicyVersionError::unhandled(generic)),
    };
    Err(match error_code {
        "InvalidInputException" => crate::error::CreatePolicyVersionError {
            meta: generic,
            kind: crate::error::CreatePolicyVersionErrorKind::InvalidInputError({
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_input_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_invalid_input_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::CreatePolicyVersionError::unhandled)?;
                output.build()
            }),
        },
        "LimitExceededException" => crate::error::CreatePolicyVersionError {
            meta: generic,
            kind: crate::error::CreatePolicyVersionErrorKind::LimitExceededError({
                #[allow(unused_mut)]
                let mut output = crate::error::limit_exceeded_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_limit_exceeded_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::CreatePolicyVersionError::unhandled)?;
                output.build()
            }),
        },
        "MalformedPolicyDocumentException" => crate::error::CreatePolicyVersionError {
            meta: generic,
            kind: crate::error::CreatePolicyVersionErrorKind::MalformedPolicyDocumentError({
                #[allow(unused_mut)]
                let mut output = crate::error::malformed_policy_document_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_malformed_policy_document_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::CreatePolicyVersionError::unhandled)?;
                output.build()
            }),
        },
        "NoSuchEntityException" => crate::error::CreatePolicyVersionError {
            meta: generic,
            kind: crate::error::CreatePolicyVersionErrorKind::NoSuchEntityError({
                #[allow(unused_mut)]
                let mut output = crate::error::no_such_entity_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_no_such_entity_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::CreatePolicyVersionError::unhandled)?;
                output.build()
            }),
        },
        "ServiceFailureException" => crate::error::CreatePolicyVersionError {
            meta: generic,
            kind: crate::error::CreatePolicyVersionErrorKind::ServiceFailureError({
                #[allow(unused_mut)]
                let mut output = crate::error::service_failure_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_service_failure_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::CreatePolicyVersionError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::CreatePolicyVersionError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_policy_version_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::CreatePolicyVersionOutput, crate::error::CreatePolicyVersionError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_policy_version_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_create_policy_version(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreatePolicyVersionError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_role_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::CreateRoleOutput, crate::error::CreateRoleError> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::CreateRoleError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::CreateRoleError::unhandled(generic)),
    };
    Err(match error_code {
        "ConcurrentModificationException" => crate::error::CreateRoleError {
            meta: generic,
            kind: crate::error::CreateRoleErrorKind::ConcurrentModificationError({
                #[allow(unused_mut)]
                let mut output = crate::error::concurrent_modification_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_concurrent_modification_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::CreateRoleError::unhandled)?;
                output.build()
            }),
        },
        "EntityAlreadyExistsException" => crate::error::CreateRoleError {
            meta: generic,
            kind: crate::error::CreateRoleErrorKind::EntityAlreadyExistsError({
                #[allow(unused_mut)]
                let mut output = crate::error::entity_already_exists_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_entity_already_exists_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::CreateRoleError::unhandled)?;
                output.build()
            }),
        },
        "InvalidInputException" => crate::error::CreateRoleError {
            meta: generic,
            kind: crate::error::CreateRoleErrorKind::InvalidInputError({
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_input_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_invalid_input_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::CreateRoleError::unhandled)?;
                output.build()
            }),
        },
        "LimitExceededException" => crate::error::CreateRoleError {
            meta: generic,
            kind: crate::error::CreateRoleErrorKind::LimitExceededError({
                #[allow(unused_mut)]
                let mut output = crate::error::limit_exceeded_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_limit_exceeded_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::CreateRoleError::unhandled)?;
                output.build()
            }),
        },
        "MalformedPolicyDocumentException" => crate::error::CreateRoleError {
            meta: generic,
            kind: crate::error::CreateRoleErrorKind::MalformedPolicyDocumentError({
                #[allow(unused_mut)]
                let mut output = crate::error::malformed_policy_document_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_malformed_policy_document_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::CreateRoleError::unhandled)?;
                output.build()
            }),
        },
        "ServiceFailureException" => crate::error::CreateRoleError {
            meta: generic,
            kind: crate::error::CreateRoleErrorKind::ServiceFailureError({
                #[allow(unused_mut)]
                let mut output = crate::error::service_failure_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_service_failure_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::CreateRoleError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::CreateRoleError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_role_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::CreateRoleOutput, crate::error::CreateRoleError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_role_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_create_role(response.body().as_ref(), output)
            .map_err(crate::error::CreateRoleError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_saml_provider_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::CreateSAMLProviderOutput, crate::error::CreateSAMLProviderError> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::CreateSAMLProviderError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::CreateSAMLProviderError::unhandled(generic)),
    };
    Err(match error_code {
        "ConcurrentModificationException" => crate::error::CreateSAMLProviderError {
            meta: generic,
            kind: crate::error::CreateSAMLProviderErrorKind::ConcurrentModificationError({
                #[allow(unused_mut)]
                let mut output = crate::error::concurrent_modification_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_concurrent_modification_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::CreateSAMLProviderError::unhandled)?;
                output.build()
            }),
        },
        "EntityAlreadyExistsException" => crate::error::CreateSAMLProviderError {
            meta: generic,
            kind: crate::error::CreateSAMLProviderErrorKind::EntityAlreadyExistsError({
                #[allow(unused_mut)]
                let mut output = crate::error::entity_already_exists_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_entity_already_exists_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::CreateSAMLProviderError::unhandled)?;
                output.build()
            }),
        },
        "InvalidInputException" => crate::error::CreateSAMLProviderError {
            meta: generic,
            kind: crate::error::CreateSAMLProviderErrorKind::InvalidInputError({
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_input_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_invalid_input_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::CreateSAMLProviderError::unhandled)?;
                output.build()
            }),
        },
        "LimitExceededException" => crate::error::CreateSAMLProviderError {
            meta: generic,
            kind: crate::error::CreateSAMLProviderErrorKind::LimitExceededError({
                #[allow(unused_mut)]
                let mut output = crate::error::limit_exceeded_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_limit_exceeded_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::CreateSAMLProviderError::unhandled)?;
                output.build()
            }),
        },
        "ServiceFailureException" => crate::error::CreateSAMLProviderError {
            meta: generic,
            kind: crate::error::CreateSAMLProviderErrorKind::ServiceFailureError({
                #[allow(unused_mut)]
                let mut output = crate::error::service_failure_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_service_failure_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::CreateSAMLProviderError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::CreateSAMLProviderError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_saml_provider_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::CreateSAMLProviderOutput, crate::error::CreateSAMLProviderError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_saml_provider_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_create_saml_provider(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreateSAMLProviderError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_service_linked_role_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::CreateServiceLinkedRoleOutput, crate::error::CreateServiceLinkedRoleError>
{
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::CreateServiceLinkedRoleError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::CreateServiceLinkedRoleError::unhandled(
                generic,
            ))
        }
    };
    Err(match error_code {
        "InvalidInputException" => crate::error::CreateServiceLinkedRoleError {
            meta: generic,
            kind: crate::error::CreateServiceLinkedRoleErrorKind::InvalidInputError({
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_input_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_invalid_input_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::CreateServiceLinkedRoleError::unhandled)?;
                output.build()
            }),
        },
        "LimitExceededException" => crate::error::CreateServiceLinkedRoleError {
            meta: generic,
            kind: crate::error::CreateServiceLinkedRoleErrorKind::LimitExceededError({
                #[allow(unused_mut)]
                let mut output = crate::error::limit_exceeded_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_limit_exceeded_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::CreateServiceLinkedRoleError::unhandled)?;
                output.build()
            }),
        },
        "NoSuchEntityException" => crate::error::CreateServiceLinkedRoleError {
            meta: generic,
            kind: crate::error::CreateServiceLinkedRoleErrorKind::NoSuchEntityError({
                #[allow(unused_mut)]
                let mut output = crate::error::no_such_entity_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_no_such_entity_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::CreateServiceLinkedRoleError::unhandled)?;
                output.build()
            }),
        },
        "ServiceFailureException" => crate::error::CreateServiceLinkedRoleError {
            meta: generic,
            kind: crate::error::CreateServiceLinkedRoleErrorKind::ServiceFailureError({
                #[allow(unused_mut)]
                let mut output = crate::error::service_failure_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_service_failure_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::CreateServiceLinkedRoleError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::CreateServiceLinkedRoleError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_service_linked_role_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::CreateServiceLinkedRoleOutput, crate::error::CreateServiceLinkedRoleError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_service_linked_role_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_create_service_linked_role(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreateServiceLinkedRoleError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_service_specific_credential_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<
    crate::output::CreateServiceSpecificCredentialOutput,
    crate::error::CreateServiceSpecificCredentialError,
> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::CreateServiceSpecificCredentialError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::CreateServiceSpecificCredentialError::unhandled(generic)),
    };
    Err(match error_code {
        "LimitExceededException" => crate::error::CreateServiceSpecificCredentialError {
            meta: generic,
            kind: crate::error::CreateServiceSpecificCredentialErrorKind::LimitExceededError({
                #[allow(unused_mut)]
                let mut output = crate::error::limit_exceeded_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_limit_exceeded_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::CreateServiceSpecificCredentialError::unhandled)?;
                output.build()
            }),
        },
        "NoSuchEntityException" => crate::error::CreateServiceSpecificCredentialError {
            meta: generic,
            kind: crate::error::CreateServiceSpecificCredentialErrorKind::NoSuchEntityError({
                #[allow(unused_mut)]
                let mut output = crate::error::no_such_entity_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_no_such_entity_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::CreateServiceSpecificCredentialError::unhandled)?;
                output.build()
            }),
        },
        "ServiceNotSupportedException" => {
            crate::error::CreateServiceSpecificCredentialError {
                meta: generic,
                kind:
                    crate::error::CreateServiceSpecificCredentialErrorKind::ServiceNotSupportedError(
                        {
                            #[allow(unused_mut)]
                            let mut output =
                                crate::error::service_not_supported_error::Builder::default();
                            let _ = response;
                            output = crate::xml_deser::deser_structure_service_not_supported_error_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateServiceSpecificCredentialError::unhandled)?;
                            output.build()
                        },
                    ),
            }
        }
        _ => crate::error::CreateServiceSpecificCredentialError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_service_specific_credential_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<
    crate::output::CreateServiceSpecificCredentialOutput,
    crate::error::CreateServiceSpecificCredentialError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::create_service_specific_credential_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_create_service_specific_credential(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreateServiceSpecificCredentialError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_user_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::CreateUserOutput, crate::error::CreateUserError> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::CreateUserError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::CreateUserError::unhandled(generic)),
    };
    Err(match error_code {
        "ConcurrentModificationException" => crate::error::CreateUserError {
            meta: generic,
            kind: crate::error::CreateUserErrorKind::ConcurrentModificationError({
                #[allow(unused_mut)]
                let mut output = crate::error::concurrent_modification_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_concurrent_modification_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::CreateUserError::unhandled)?;
                output.build()
            }),
        },
        "EntityAlreadyExistsException" => crate::error::CreateUserError {
            meta: generic,
            kind: crate::error::CreateUserErrorKind::EntityAlreadyExistsError({
                #[allow(unused_mut)]
                let mut output = crate::error::entity_already_exists_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_entity_already_exists_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::CreateUserError::unhandled)?;
                output.build()
            }),
        },
        "InvalidInputException" => crate::error::CreateUserError {
            meta: generic,
            kind: crate::error::CreateUserErrorKind::InvalidInputError({
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_input_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_invalid_input_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::CreateUserError::unhandled)?;
                output.build()
            }),
        },
        "LimitExceededException" => crate::error::CreateUserError {
            meta: generic,
            kind: crate::error::CreateUserErrorKind::LimitExceededError({
                #[allow(unused_mut)]
                let mut output = crate::error::limit_exceeded_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_limit_exceeded_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::CreateUserError::unhandled)?;
                output.build()
            }),
        },
        "NoSuchEntityException" => crate::error::CreateUserError {
            meta: generic,
            kind: crate::error::CreateUserErrorKind::NoSuchEntityError({
                #[allow(unused_mut)]
                let mut output = crate::error::no_such_entity_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_no_such_entity_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::CreateUserError::unhandled)?;
                output.build()
            }),
        },
        "ServiceFailureException" => crate::error::CreateUserError {
            meta: generic,
            kind: crate::error::CreateUserErrorKind::ServiceFailureError({
                #[allow(unused_mut)]
                let mut output = crate::error::service_failure_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_service_failure_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::CreateUserError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::CreateUserError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_user_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::CreateUserOutput, crate::error::CreateUserError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_user_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_create_user(response.body().as_ref(), output)
            .map_err(crate::error::CreateUserError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_virtual_mfa_device_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::CreateVirtualMFADeviceOutput, crate::error::CreateVirtualMFADeviceError>
{
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::CreateVirtualMFADeviceError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::CreateVirtualMFADeviceError::unhandled(
                generic,
            ))
        }
    };
    Err(match error_code {
        "ConcurrentModificationException" => crate::error::CreateVirtualMFADeviceError {
            meta: generic,
            kind: crate::error::CreateVirtualMFADeviceErrorKind::ConcurrentModificationError({
                #[allow(unused_mut)]
                let mut output = crate::error::concurrent_modification_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_concurrent_modification_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::CreateVirtualMFADeviceError::unhandled)?;
                output.build()
            }),
        },
        "EntityAlreadyExistsException" => crate::error::CreateVirtualMFADeviceError {
            meta: generic,
            kind: crate::error::CreateVirtualMFADeviceErrorKind::EntityAlreadyExistsError({
                #[allow(unused_mut)]
                let mut output = crate::error::entity_already_exists_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_entity_already_exists_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::CreateVirtualMFADeviceError::unhandled)?;
                output.build()
            }),
        },
        "InvalidInputException" => crate::error::CreateVirtualMFADeviceError {
            meta: generic,
            kind: crate::error::CreateVirtualMFADeviceErrorKind::InvalidInputError({
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_input_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_invalid_input_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::CreateVirtualMFADeviceError::unhandled)?;
                output.build()
            }),
        },
        "LimitExceededException" => crate::error::CreateVirtualMFADeviceError {
            meta: generic,
            kind: crate::error::CreateVirtualMFADeviceErrorKind::LimitExceededError({
                #[allow(unused_mut)]
                let mut output = crate::error::limit_exceeded_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_limit_exceeded_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::CreateVirtualMFADeviceError::unhandled)?;
                output.build()
            }),
        },
        "ServiceFailureException" => crate::error::CreateVirtualMFADeviceError {
            meta: generic,
            kind: crate::error::CreateVirtualMFADeviceErrorKind::ServiceFailureError({
                #[allow(unused_mut)]
                let mut output = crate::error::service_failure_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_service_failure_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::CreateVirtualMFADeviceError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::CreateVirtualMFADeviceError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_virtual_mfa_device_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::CreateVirtualMFADeviceOutput, crate::error::CreateVirtualMFADeviceError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_virtual_mfa_device_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_create_virtual_mfa_device(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreateVirtualMFADeviceError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_deactivate_mfa_device_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::DeactivateMFADeviceOutput, crate::error::DeactivateMFADeviceError> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::DeactivateMFADeviceError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DeactivateMFADeviceError::unhandled(generic)),
    };
    Err(match error_code {
        "EntityTemporarilyUnmodifiableException" => crate::error::DeactivateMFADeviceError {
            meta: generic,
            kind: crate::error::DeactivateMFADeviceErrorKind::EntityTemporarilyUnmodifiableError({
                #[allow(unused_mut)]
                let mut output =
                    crate::error::entity_temporarily_unmodifiable_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_entity_temporarily_unmodifiable_error_xml_err(response.body().as_ref(), output).map_err(crate::error::DeactivateMFADeviceError::unhandled)?;
                output.build()
            }),
        },
        "LimitExceededException" => crate::error::DeactivateMFADeviceError {
            meta: generic,
            kind: crate::error::DeactivateMFADeviceErrorKind::LimitExceededError({
                #[allow(unused_mut)]
                let mut output = crate::error::limit_exceeded_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_limit_exceeded_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DeactivateMFADeviceError::unhandled)?;
                output.build()
            }),
        },
        "NoSuchEntityException" => crate::error::DeactivateMFADeviceError {
            meta: generic,
            kind: crate::error::DeactivateMFADeviceErrorKind::NoSuchEntityError({
                #[allow(unused_mut)]
                let mut output = crate::error::no_such_entity_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_no_such_entity_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DeactivateMFADeviceError::unhandled)?;
                output.build()
            }),
        },
        "ServiceFailureException" => crate::error::DeactivateMFADeviceError {
            meta: generic,
            kind: crate::error::DeactivateMFADeviceErrorKind::ServiceFailureError({
                #[allow(unused_mut)]
                let mut output = crate::error::service_failure_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_service_failure_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DeactivateMFADeviceError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::DeactivateMFADeviceError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_deactivate_mfa_device_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::DeactivateMFADeviceOutput, crate::error::DeactivateMFADeviceError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::deactivate_mfa_device_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_access_key_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::DeleteAccessKeyOutput, crate::error::DeleteAccessKeyError> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::DeleteAccessKeyError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DeleteAccessKeyError::unhandled(generic)),
    };
    Err(match error_code {
        "LimitExceededException" => crate::error::DeleteAccessKeyError {
            meta: generic,
            kind: crate::error::DeleteAccessKeyErrorKind::LimitExceededError({
                #[allow(unused_mut)]
                let mut output = crate::error::limit_exceeded_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_limit_exceeded_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DeleteAccessKeyError::unhandled)?;
                output.build()
            }),
        },
        "NoSuchEntityException" => crate::error::DeleteAccessKeyError {
            meta: generic,
            kind: crate::error::DeleteAccessKeyErrorKind::NoSuchEntityError({
                #[allow(unused_mut)]
                let mut output = crate::error::no_such_entity_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_no_such_entity_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DeleteAccessKeyError::unhandled)?;
                output.build()
            }),
        },
        "ServiceFailureException" => crate::error::DeleteAccessKeyError {
            meta: generic,
            kind: crate::error::DeleteAccessKeyErrorKind::ServiceFailureError({
                #[allow(unused_mut)]
                let mut output = crate::error::service_failure_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_service_failure_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DeleteAccessKeyError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::DeleteAccessKeyError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_access_key_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::DeleteAccessKeyOutput, crate::error::DeleteAccessKeyError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_access_key_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_account_alias_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::DeleteAccountAliasOutput, crate::error::DeleteAccountAliasError> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::DeleteAccountAliasError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DeleteAccountAliasError::unhandled(generic)),
    };
    Err(match error_code {
        "LimitExceededException" => crate::error::DeleteAccountAliasError {
            meta: generic,
            kind: crate::error::DeleteAccountAliasErrorKind::LimitExceededError({
                #[allow(unused_mut)]
                let mut output = crate::error::limit_exceeded_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_limit_exceeded_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DeleteAccountAliasError::unhandled)?;
                output.build()
            }),
        },
        "NoSuchEntityException" => crate::error::DeleteAccountAliasError {
            meta: generic,
            kind: crate::error::DeleteAccountAliasErrorKind::NoSuchEntityError({
                #[allow(unused_mut)]
                let mut output = crate::error::no_such_entity_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_no_such_entity_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DeleteAccountAliasError::unhandled)?;
                output.build()
            }),
        },
        "ServiceFailureException" => crate::error::DeleteAccountAliasError {
            meta: generic,
            kind: crate::error::DeleteAccountAliasErrorKind::ServiceFailureError({
                #[allow(unused_mut)]
                let mut output = crate::error::service_failure_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_service_failure_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DeleteAccountAliasError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::DeleteAccountAliasError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_account_alias_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::DeleteAccountAliasOutput, crate::error::DeleteAccountAliasError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_account_alias_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_account_password_policy_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<
    crate::output::DeleteAccountPasswordPolicyOutput,
    crate::error::DeleteAccountPasswordPolicyError,
> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::DeleteAccountPasswordPolicyError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DeleteAccountPasswordPolicyError::unhandled(
                generic,
            ))
        }
    };
    Err(match error_code {
        "LimitExceededException" => crate::error::DeleteAccountPasswordPolicyError {
            meta: generic,
            kind: crate::error::DeleteAccountPasswordPolicyErrorKind::LimitExceededError({
                #[allow(unused_mut)]
                let mut output = crate::error::limit_exceeded_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_limit_exceeded_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DeleteAccountPasswordPolicyError::unhandled)?;
                output.build()
            }),
        },
        "NoSuchEntityException" => crate::error::DeleteAccountPasswordPolicyError {
            meta: generic,
            kind: crate::error::DeleteAccountPasswordPolicyErrorKind::NoSuchEntityError({
                #[allow(unused_mut)]
                let mut output = crate::error::no_such_entity_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_no_such_entity_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DeleteAccountPasswordPolicyError::unhandled)?;
                output.build()
            }),
        },
        "ServiceFailureException" => crate::error::DeleteAccountPasswordPolicyError {
            meta: generic,
            kind: crate::error::DeleteAccountPasswordPolicyErrorKind::ServiceFailureError({
                #[allow(unused_mut)]
                let mut output = crate::error::service_failure_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_service_failure_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DeleteAccountPasswordPolicyError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::DeleteAccountPasswordPolicyError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_account_password_policy_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<
    crate::output::DeleteAccountPasswordPolicyOutput,
    crate::error::DeleteAccountPasswordPolicyError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_account_password_policy_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_group_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::DeleteGroupOutput, crate::error::DeleteGroupError> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::DeleteGroupError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DeleteGroupError::unhandled(generic)),
    };
    Err(match error_code {
        "DeleteConflictException" => crate::error::DeleteGroupError {
            meta: generic,
            kind: crate::error::DeleteGroupErrorKind::DeleteConflictError({
                #[allow(unused_mut)]
                let mut output = crate::error::delete_conflict_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_delete_conflict_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DeleteGroupError::unhandled)?;
                output.build()
            }),
        },
        "LimitExceededException" => crate::error::DeleteGroupError {
            meta: generic,
            kind: crate::error::DeleteGroupErrorKind::LimitExceededError({
                #[allow(unused_mut)]
                let mut output = crate::error::limit_exceeded_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_limit_exceeded_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DeleteGroupError::unhandled)?;
                output.build()
            }),
        },
        "NoSuchEntityException" => crate::error::DeleteGroupError {
            meta: generic,
            kind: crate::error::DeleteGroupErrorKind::NoSuchEntityError({
                #[allow(unused_mut)]
                let mut output = crate::error::no_such_entity_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_no_such_entity_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DeleteGroupError::unhandled)?;
                output.build()
            }),
        },
        "ServiceFailureException" => crate::error::DeleteGroupError {
            meta: generic,
            kind: crate::error::DeleteGroupErrorKind::ServiceFailureError({
                #[allow(unused_mut)]
                let mut output = crate::error::service_failure_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_service_failure_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DeleteGroupError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::DeleteGroupError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_group_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::DeleteGroupOutput, crate::error::DeleteGroupError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_group_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_group_policy_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::DeleteGroupPolicyOutput, crate::error::DeleteGroupPolicyError> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::DeleteGroupPolicyError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DeleteGroupPolicyError::unhandled(generic)),
    };
    Err(match error_code {
        "LimitExceededException" => crate::error::DeleteGroupPolicyError {
            meta: generic,
            kind: crate::error::DeleteGroupPolicyErrorKind::LimitExceededError({
                #[allow(unused_mut)]
                let mut output = crate::error::limit_exceeded_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_limit_exceeded_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DeleteGroupPolicyError::unhandled)?;
                output.build()
            }),
        },
        "NoSuchEntityException" => crate::error::DeleteGroupPolicyError {
            meta: generic,
            kind: crate::error::DeleteGroupPolicyErrorKind::NoSuchEntityError({
                #[allow(unused_mut)]
                let mut output = crate::error::no_such_entity_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_no_such_entity_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DeleteGroupPolicyError::unhandled)?;
                output.build()
            }),
        },
        "ServiceFailureException" => crate::error::DeleteGroupPolicyError {
            meta: generic,
            kind: crate::error::DeleteGroupPolicyErrorKind::ServiceFailureError({
                #[allow(unused_mut)]
                let mut output = crate::error::service_failure_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_service_failure_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DeleteGroupPolicyError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::DeleteGroupPolicyError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_group_policy_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::DeleteGroupPolicyOutput, crate::error::DeleteGroupPolicyError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_group_policy_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_instance_profile_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::DeleteInstanceProfileOutput, crate::error::DeleteInstanceProfileError> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::DeleteInstanceProfileError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DeleteInstanceProfileError::unhandled(generic)),
    };
    Err(match error_code {
        "DeleteConflictException" => crate::error::DeleteInstanceProfileError {
            meta: generic,
            kind: crate::error::DeleteInstanceProfileErrorKind::DeleteConflictError({
                #[allow(unused_mut)]
                let mut output = crate::error::delete_conflict_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_delete_conflict_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DeleteInstanceProfileError::unhandled)?;
                output.build()
            }),
        },
        "LimitExceededException" => crate::error::DeleteInstanceProfileError {
            meta: generic,
            kind: crate::error::DeleteInstanceProfileErrorKind::LimitExceededError({
                #[allow(unused_mut)]
                let mut output = crate::error::limit_exceeded_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_limit_exceeded_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DeleteInstanceProfileError::unhandled)?;
                output.build()
            }),
        },
        "NoSuchEntityException" => crate::error::DeleteInstanceProfileError {
            meta: generic,
            kind: crate::error::DeleteInstanceProfileErrorKind::NoSuchEntityError({
                #[allow(unused_mut)]
                let mut output = crate::error::no_such_entity_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_no_such_entity_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DeleteInstanceProfileError::unhandled)?;
                output.build()
            }),
        },
        "ServiceFailureException" => crate::error::DeleteInstanceProfileError {
            meta: generic,
            kind: crate::error::DeleteInstanceProfileErrorKind::ServiceFailureError({
                #[allow(unused_mut)]
                let mut output = crate::error::service_failure_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_service_failure_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DeleteInstanceProfileError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::DeleteInstanceProfileError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_instance_profile_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::DeleteInstanceProfileOutput, crate::error::DeleteInstanceProfileError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_instance_profile_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_login_profile_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::DeleteLoginProfileOutput, crate::error::DeleteLoginProfileError> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::DeleteLoginProfileError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DeleteLoginProfileError::unhandled(generic)),
    };
    Err(match error_code {
        "EntityTemporarilyUnmodifiableException" => crate::error::DeleteLoginProfileError {
            meta: generic,
            kind: crate::error::DeleteLoginProfileErrorKind::EntityTemporarilyUnmodifiableError({
                #[allow(unused_mut)]
                let mut output =
                    crate::error::entity_temporarily_unmodifiable_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_entity_temporarily_unmodifiable_error_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteLoginProfileError::unhandled)?;
                output.build()
            }),
        },
        "LimitExceededException" => crate::error::DeleteLoginProfileError {
            meta: generic,
            kind: crate::error::DeleteLoginProfileErrorKind::LimitExceededError({
                #[allow(unused_mut)]
                let mut output = crate::error::limit_exceeded_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_limit_exceeded_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DeleteLoginProfileError::unhandled)?;
                output.build()
            }),
        },
        "NoSuchEntityException" => crate::error::DeleteLoginProfileError {
            meta: generic,
            kind: crate::error::DeleteLoginProfileErrorKind::NoSuchEntityError({
                #[allow(unused_mut)]
                let mut output = crate::error::no_such_entity_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_no_such_entity_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DeleteLoginProfileError::unhandled)?;
                output.build()
            }),
        },
        "ServiceFailureException" => crate::error::DeleteLoginProfileError {
            meta: generic,
            kind: crate::error::DeleteLoginProfileErrorKind::ServiceFailureError({
                #[allow(unused_mut)]
                let mut output = crate::error::service_failure_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_service_failure_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DeleteLoginProfileError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::DeleteLoginProfileError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_login_profile_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::DeleteLoginProfileOutput, crate::error::DeleteLoginProfileError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_login_profile_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_open_id_connect_provider_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<
    crate::output::DeleteOpenIDConnectProviderOutput,
    crate::error::DeleteOpenIDConnectProviderError,
> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::DeleteOpenIDConnectProviderError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DeleteOpenIDConnectProviderError::unhandled(
                generic,
            ))
        }
    };
    Err(match error_code {
        "InvalidInputException" => crate::error::DeleteOpenIDConnectProviderError {
            meta: generic,
            kind: crate::error::DeleteOpenIDConnectProviderErrorKind::InvalidInputError({
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_input_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_invalid_input_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DeleteOpenIDConnectProviderError::unhandled)?;
                output.build()
            }),
        },
        "NoSuchEntityException" => crate::error::DeleteOpenIDConnectProviderError {
            meta: generic,
            kind: crate::error::DeleteOpenIDConnectProviderErrorKind::NoSuchEntityError({
                #[allow(unused_mut)]
                let mut output = crate::error::no_such_entity_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_no_such_entity_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DeleteOpenIDConnectProviderError::unhandled)?;
                output.build()
            }),
        },
        "ServiceFailureException" => crate::error::DeleteOpenIDConnectProviderError {
            meta: generic,
            kind: crate::error::DeleteOpenIDConnectProviderErrorKind::ServiceFailureError({
                #[allow(unused_mut)]
                let mut output = crate::error::service_failure_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_service_failure_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DeleteOpenIDConnectProviderError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::DeleteOpenIDConnectProviderError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_open_id_connect_provider_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<
    crate::output::DeleteOpenIDConnectProviderOutput,
    crate::error::DeleteOpenIDConnectProviderError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_open_id_connect_provider_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_policy_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::DeletePolicyOutput, crate::error::DeletePolicyError> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::DeletePolicyError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DeletePolicyError::unhandled(generic)),
    };
    Err(match error_code {
        "DeleteConflictException" => crate::error::DeletePolicyError {
            meta: generic,
            kind: crate::error::DeletePolicyErrorKind::DeleteConflictError({
                #[allow(unused_mut)]
                let mut output = crate::error::delete_conflict_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_delete_conflict_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DeletePolicyError::unhandled)?;
                output.build()
            }),
        },
        "InvalidInputException" => crate::error::DeletePolicyError {
            meta: generic,
            kind: crate::error::DeletePolicyErrorKind::InvalidInputError({
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_input_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_invalid_input_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DeletePolicyError::unhandled)?;
                output.build()
            }),
        },
        "LimitExceededException" => crate::error::DeletePolicyError {
            meta: generic,
            kind: crate::error::DeletePolicyErrorKind::LimitExceededError({
                #[allow(unused_mut)]
                let mut output = crate::error::limit_exceeded_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_limit_exceeded_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DeletePolicyError::unhandled)?;
                output.build()
            }),
        },
        "NoSuchEntityException" => crate::error::DeletePolicyError {
            meta: generic,
            kind: crate::error::DeletePolicyErrorKind::NoSuchEntityError({
                #[allow(unused_mut)]
                let mut output = crate::error::no_such_entity_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_no_such_entity_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DeletePolicyError::unhandled)?;
                output.build()
            }),
        },
        "ServiceFailureException" => crate::error::DeletePolicyError {
            meta: generic,
            kind: crate::error::DeletePolicyErrorKind::ServiceFailureError({
                #[allow(unused_mut)]
                let mut output = crate::error::service_failure_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_service_failure_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DeletePolicyError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::DeletePolicyError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_policy_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::DeletePolicyOutput, crate::error::DeletePolicyError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_policy_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_policy_version_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::DeletePolicyVersionOutput, crate::error::DeletePolicyVersionError> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::DeletePolicyVersionError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DeletePolicyVersionError::unhandled(generic)),
    };
    Err(match error_code {
        "DeleteConflictException" => crate::error::DeletePolicyVersionError {
            meta: generic,
            kind: crate::error::DeletePolicyVersionErrorKind::DeleteConflictError({
                #[allow(unused_mut)]
                let mut output = crate::error::delete_conflict_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_delete_conflict_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DeletePolicyVersionError::unhandled)?;
                output.build()
            }),
        },
        "InvalidInputException" => crate::error::DeletePolicyVersionError {
            meta: generic,
            kind: crate::error::DeletePolicyVersionErrorKind::InvalidInputError({
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_input_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_invalid_input_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DeletePolicyVersionError::unhandled)?;
                output.build()
            }),
        },
        "LimitExceededException" => crate::error::DeletePolicyVersionError {
            meta: generic,
            kind: crate::error::DeletePolicyVersionErrorKind::LimitExceededError({
                #[allow(unused_mut)]
                let mut output = crate::error::limit_exceeded_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_limit_exceeded_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DeletePolicyVersionError::unhandled)?;
                output.build()
            }),
        },
        "NoSuchEntityException" => crate::error::DeletePolicyVersionError {
            meta: generic,
            kind: crate::error::DeletePolicyVersionErrorKind::NoSuchEntityError({
                #[allow(unused_mut)]
                let mut output = crate::error::no_such_entity_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_no_such_entity_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DeletePolicyVersionError::unhandled)?;
                output.build()
            }),
        },
        "ServiceFailureException" => crate::error::DeletePolicyVersionError {
            meta: generic,
            kind: crate::error::DeletePolicyVersionErrorKind::ServiceFailureError({
                #[allow(unused_mut)]
                let mut output = crate::error::service_failure_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_service_failure_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DeletePolicyVersionError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::DeletePolicyVersionError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_policy_version_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::DeletePolicyVersionOutput, crate::error::DeletePolicyVersionError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_policy_version_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_role_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::DeleteRoleOutput, crate::error::DeleteRoleError> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::DeleteRoleError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DeleteRoleError::unhandled(generic)),
    };
    Err(match error_code {
        "ConcurrentModificationException" => crate::error::DeleteRoleError {
            meta: generic,
            kind: crate::error::DeleteRoleErrorKind::ConcurrentModificationError({
                #[allow(unused_mut)]
                let mut output = crate::error::concurrent_modification_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_concurrent_modification_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DeleteRoleError::unhandled)?;
                output.build()
            }),
        },
        "DeleteConflictException" => crate::error::DeleteRoleError {
            meta: generic,
            kind: crate::error::DeleteRoleErrorKind::DeleteConflictError({
                #[allow(unused_mut)]
                let mut output = crate::error::delete_conflict_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_delete_conflict_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DeleteRoleError::unhandled)?;
                output.build()
            }),
        },
        "LimitExceededException" => crate::error::DeleteRoleError {
            meta: generic,
            kind: crate::error::DeleteRoleErrorKind::LimitExceededError({
                #[allow(unused_mut)]
                let mut output = crate::error::limit_exceeded_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_limit_exceeded_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DeleteRoleError::unhandled)?;
                output.build()
            }),
        },
        "NoSuchEntityException" => crate::error::DeleteRoleError {
            meta: generic,
            kind: crate::error::DeleteRoleErrorKind::NoSuchEntityError({
                #[allow(unused_mut)]
                let mut output = crate::error::no_such_entity_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_no_such_entity_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DeleteRoleError::unhandled)?;
                output.build()
            }),
        },
        "ServiceFailureException" => crate::error::DeleteRoleError {
            meta: generic,
            kind: crate::error::DeleteRoleErrorKind::ServiceFailureError({
                #[allow(unused_mut)]
                let mut output = crate::error::service_failure_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_service_failure_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DeleteRoleError::unhandled)?;
                output.build()
            }),
        },
        "UnmodifiableEntityException" => crate::error::DeleteRoleError {
            meta: generic,
            kind: crate::error::DeleteRoleErrorKind::UnmodifiableEntityError({
                #[allow(unused_mut)]
                let mut output = crate::error::unmodifiable_entity_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_unmodifiable_entity_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DeleteRoleError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::DeleteRoleError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_role_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::DeleteRoleOutput, crate::error::DeleteRoleError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_role_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_role_permissions_boundary_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<
    crate::output::DeleteRolePermissionsBoundaryOutput,
    crate::error::DeleteRolePermissionsBoundaryError,
> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::DeleteRolePermissionsBoundaryError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DeleteRolePermissionsBoundaryError::unhandled(
                generic,
            ))
        }
    };
    Err(match error_code {
        "NoSuchEntityException" => crate::error::DeleteRolePermissionsBoundaryError {
            meta: generic,
            kind: crate::error::DeleteRolePermissionsBoundaryErrorKind::NoSuchEntityError({
                #[allow(unused_mut)]
                let mut output = crate::error::no_such_entity_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_no_such_entity_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DeleteRolePermissionsBoundaryError::unhandled)?;
                output.build()
            }),
        },
        "ServiceFailureException" => crate::error::DeleteRolePermissionsBoundaryError {
            meta: generic,
            kind: crate::error::DeleteRolePermissionsBoundaryErrorKind::ServiceFailureError({
                #[allow(unused_mut)]
                let mut output = crate::error::service_failure_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_service_failure_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DeleteRolePermissionsBoundaryError::unhandled)?;
                output.build()
            }),
        },
        "UnmodifiableEntityException" => crate::error::DeleteRolePermissionsBoundaryError {
            meta: generic,
            kind: crate::error::DeleteRolePermissionsBoundaryErrorKind::UnmodifiableEntityError({
                #[allow(unused_mut)]
                let mut output = crate::error::unmodifiable_entity_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_unmodifiable_entity_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DeleteRolePermissionsBoundaryError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::DeleteRolePermissionsBoundaryError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_role_permissions_boundary_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<
    crate::output::DeleteRolePermissionsBoundaryOutput,
    crate::error::DeleteRolePermissionsBoundaryError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_role_permissions_boundary_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_role_policy_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::DeleteRolePolicyOutput, crate::error::DeleteRolePolicyError> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::DeleteRolePolicyError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DeleteRolePolicyError::unhandled(generic)),
    };
    Err(match error_code {
        "LimitExceededException" => crate::error::DeleteRolePolicyError {
            meta: generic,
            kind: crate::error::DeleteRolePolicyErrorKind::LimitExceededError({
                #[allow(unused_mut)]
                let mut output = crate::error::limit_exceeded_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_limit_exceeded_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DeleteRolePolicyError::unhandled)?;
                output.build()
            }),
        },
        "NoSuchEntityException" => crate::error::DeleteRolePolicyError {
            meta: generic,
            kind: crate::error::DeleteRolePolicyErrorKind::NoSuchEntityError({
                #[allow(unused_mut)]
                let mut output = crate::error::no_such_entity_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_no_such_entity_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DeleteRolePolicyError::unhandled)?;
                output.build()
            }),
        },
        "ServiceFailureException" => crate::error::DeleteRolePolicyError {
            meta: generic,
            kind: crate::error::DeleteRolePolicyErrorKind::ServiceFailureError({
                #[allow(unused_mut)]
                let mut output = crate::error::service_failure_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_service_failure_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DeleteRolePolicyError::unhandled)?;
                output.build()
            }),
        },
        "UnmodifiableEntityException" => crate::error::DeleteRolePolicyError {
            meta: generic,
            kind: crate::error::DeleteRolePolicyErrorKind::UnmodifiableEntityError({
                #[allow(unused_mut)]
                let mut output = crate::error::unmodifiable_entity_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_unmodifiable_entity_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DeleteRolePolicyError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::DeleteRolePolicyError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_role_policy_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::DeleteRolePolicyOutput, crate::error::DeleteRolePolicyError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_role_policy_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_saml_provider_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::DeleteSAMLProviderOutput, crate::error::DeleteSAMLProviderError> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::DeleteSAMLProviderError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DeleteSAMLProviderError::unhandled(generic)),
    };
    Err(match error_code {
        "InvalidInputException" => crate::error::DeleteSAMLProviderError {
            meta: generic,
            kind: crate::error::DeleteSAMLProviderErrorKind::InvalidInputError({
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_input_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_invalid_input_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DeleteSAMLProviderError::unhandled)?;
                output.build()
            }),
        },
        "LimitExceededException" => crate::error::DeleteSAMLProviderError {
            meta: generic,
            kind: crate::error::DeleteSAMLProviderErrorKind::LimitExceededError({
                #[allow(unused_mut)]
                let mut output = crate::error::limit_exceeded_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_limit_exceeded_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DeleteSAMLProviderError::unhandled)?;
                output.build()
            }),
        },
        "NoSuchEntityException" => crate::error::DeleteSAMLProviderError {
            meta: generic,
            kind: crate::error::DeleteSAMLProviderErrorKind::NoSuchEntityError({
                #[allow(unused_mut)]
                let mut output = crate::error::no_such_entity_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_no_such_entity_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DeleteSAMLProviderError::unhandled)?;
                output.build()
            }),
        },
        "ServiceFailureException" => crate::error::DeleteSAMLProviderError {
            meta: generic,
            kind: crate::error::DeleteSAMLProviderErrorKind::ServiceFailureError({
                #[allow(unused_mut)]
                let mut output = crate::error::service_failure_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_service_failure_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DeleteSAMLProviderError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::DeleteSAMLProviderError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_saml_provider_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::DeleteSAMLProviderOutput, crate::error::DeleteSAMLProviderError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_saml_provider_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_server_certificate_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::DeleteServerCertificateOutput, crate::error::DeleteServerCertificateError>
{
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::DeleteServerCertificateError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DeleteServerCertificateError::unhandled(
                generic,
            ))
        }
    };
    Err(match error_code {
        "DeleteConflictException" => crate::error::DeleteServerCertificateError {
            meta: generic,
            kind: crate::error::DeleteServerCertificateErrorKind::DeleteConflictError({
                #[allow(unused_mut)]
                let mut output = crate::error::delete_conflict_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_delete_conflict_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DeleteServerCertificateError::unhandled)?;
                output.build()
            }),
        },
        "LimitExceededException" => crate::error::DeleteServerCertificateError {
            meta: generic,
            kind: crate::error::DeleteServerCertificateErrorKind::LimitExceededError({
                #[allow(unused_mut)]
                let mut output = crate::error::limit_exceeded_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_limit_exceeded_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DeleteServerCertificateError::unhandled)?;
                output.build()
            }),
        },
        "NoSuchEntityException" => crate::error::DeleteServerCertificateError {
            meta: generic,
            kind: crate::error::DeleteServerCertificateErrorKind::NoSuchEntityError({
                #[allow(unused_mut)]
                let mut output = crate::error::no_such_entity_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_no_such_entity_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DeleteServerCertificateError::unhandled)?;
                output.build()
            }),
        },
        "ServiceFailureException" => crate::error::DeleteServerCertificateError {
            meta: generic,
            kind: crate::error::DeleteServerCertificateErrorKind::ServiceFailureError({
                #[allow(unused_mut)]
                let mut output = crate::error::service_failure_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_service_failure_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DeleteServerCertificateError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::DeleteServerCertificateError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_server_certificate_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::DeleteServerCertificateOutput, crate::error::DeleteServerCertificateError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_server_certificate_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_service_linked_role_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::DeleteServiceLinkedRoleOutput, crate::error::DeleteServiceLinkedRoleError>
{
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::DeleteServiceLinkedRoleError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DeleteServiceLinkedRoleError::unhandled(
                generic,
            ))
        }
    };
    Err(match error_code {
        "LimitExceededException" => crate::error::DeleteServiceLinkedRoleError {
            meta: generic,
            kind: crate::error::DeleteServiceLinkedRoleErrorKind::LimitExceededError({
                #[allow(unused_mut)]
                let mut output = crate::error::limit_exceeded_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_limit_exceeded_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DeleteServiceLinkedRoleError::unhandled)?;
                output.build()
            }),
        },
        "NoSuchEntityException" => crate::error::DeleteServiceLinkedRoleError {
            meta: generic,
            kind: crate::error::DeleteServiceLinkedRoleErrorKind::NoSuchEntityError({
                #[allow(unused_mut)]
                let mut output = crate::error::no_such_entity_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_no_such_entity_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DeleteServiceLinkedRoleError::unhandled)?;
                output.build()
            }),
        },
        "ServiceFailureException" => crate::error::DeleteServiceLinkedRoleError {
            meta: generic,
            kind: crate::error::DeleteServiceLinkedRoleErrorKind::ServiceFailureError({
                #[allow(unused_mut)]
                let mut output = crate::error::service_failure_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_service_failure_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DeleteServiceLinkedRoleError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::DeleteServiceLinkedRoleError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_service_linked_role_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::DeleteServiceLinkedRoleOutput, crate::error::DeleteServiceLinkedRoleError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_service_linked_role_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_delete_service_linked_role(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DeleteServiceLinkedRoleError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_service_specific_credential_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<
    crate::output::DeleteServiceSpecificCredentialOutput,
    crate::error::DeleteServiceSpecificCredentialError,
> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::DeleteServiceSpecificCredentialError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DeleteServiceSpecificCredentialError::unhandled(generic)),
    };
    Err(match error_code {
        "NoSuchEntityException" => crate::error::DeleteServiceSpecificCredentialError {
            meta: generic,
            kind: crate::error::DeleteServiceSpecificCredentialErrorKind::NoSuchEntityError({
                #[allow(unused_mut)]
                let mut output = crate::error::no_such_entity_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_no_such_entity_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DeleteServiceSpecificCredentialError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::DeleteServiceSpecificCredentialError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_service_specific_credential_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<
    crate::output::DeleteServiceSpecificCredentialOutput,
    crate::error::DeleteServiceSpecificCredentialError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::delete_service_specific_credential_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_signing_certificate_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<
    crate::output::DeleteSigningCertificateOutput,
    crate::error::DeleteSigningCertificateError,
> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::DeleteSigningCertificateError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DeleteSigningCertificateError::unhandled(
                generic,
            ))
        }
    };
    Err(match error_code {
        "LimitExceededException" => crate::error::DeleteSigningCertificateError {
            meta: generic,
            kind: crate::error::DeleteSigningCertificateErrorKind::LimitExceededError({
                #[allow(unused_mut)]
                let mut output = crate::error::limit_exceeded_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_limit_exceeded_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DeleteSigningCertificateError::unhandled)?;
                output.build()
            }),
        },
        "NoSuchEntityException" => crate::error::DeleteSigningCertificateError {
            meta: generic,
            kind: crate::error::DeleteSigningCertificateErrorKind::NoSuchEntityError({
                #[allow(unused_mut)]
                let mut output = crate::error::no_such_entity_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_no_such_entity_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DeleteSigningCertificateError::unhandled)?;
                output.build()
            }),
        },
        "ServiceFailureException" => crate::error::DeleteSigningCertificateError {
            meta: generic,
            kind: crate::error::DeleteSigningCertificateErrorKind::ServiceFailureError({
                #[allow(unused_mut)]
                let mut output = crate::error::service_failure_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_service_failure_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DeleteSigningCertificateError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::DeleteSigningCertificateError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_signing_certificate_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<
    crate::output::DeleteSigningCertificateOutput,
    crate::error::DeleteSigningCertificateError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_signing_certificate_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_ssh_public_key_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::DeleteSSHPublicKeyOutput, crate::error::DeleteSSHPublicKeyError> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::DeleteSSHPublicKeyError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DeleteSSHPublicKeyError::unhandled(generic)),
    };
    Err(match error_code {
        "NoSuchEntityException" => crate::error::DeleteSSHPublicKeyError {
            meta: generic,
            kind: crate::error::DeleteSSHPublicKeyErrorKind::NoSuchEntityError({
                #[allow(unused_mut)]
                let mut output = crate::error::no_such_entity_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_no_such_entity_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DeleteSSHPublicKeyError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::DeleteSSHPublicKeyError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_ssh_public_key_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::DeleteSSHPublicKeyOutput, crate::error::DeleteSSHPublicKeyError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_ssh_public_key_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_user_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::DeleteUserOutput, crate::error::DeleteUserError> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::DeleteUserError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DeleteUserError::unhandled(generic)),
    };
    Err(match error_code {
        "ConcurrentModificationException" => crate::error::DeleteUserError {
            meta: generic,
            kind: crate::error::DeleteUserErrorKind::ConcurrentModificationError({
                #[allow(unused_mut)]
                let mut output = crate::error::concurrent_modification_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_concurrent_modification_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DeleteUserError::unhandled)?;
                output.build()
            }),
        },
        "DeleteConflictException" => crate::error::DeleteUserError {
            meta: generic,
            kind: crate::error::DeleteUserErrorKind::DeleteConflictError({
                #[allow(unused_mut)]
                let mut output = crate::error::delete_conflict_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_delete_conflict_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DeleteUserError::unhandled)?;
                output.build()
            }),
        },
        "LimitExceededException" => crate::error::DeleteUserError {
            meta: generic,
            kind: crate::error::DeleteUserErrorKind::LimitExceededError({
                #[allow(unused_mut)]
                let mut output = crate::error::limit_exceeded_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_limit_exceeded_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DeleteUserError::unhandled)?;
                output.build()
            }),
        },
        "NoSuchEntityException" => crate::error::DeleteUserError {
            meta: generic,
            kind: crate::error::DeleteUserErrorKind::NoSuchEntityError({
                #[allow(unused_mut)]
                let mut output = crate::error::no_such_entity_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_no_such_entity_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DeleteUserError::unhandled)?;
                output.build()
            }),
        },
        "ServiceFailureException" => crate::error::DeleteUserError {
            meta: generic,
            kind: crate::error::DeleteUserErrorKind::ServiceFailureError({
                #[allow(unused_mut)]
                let mut output = crate::error::service_failure_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_service_failure_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DeleteUserError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::DeleteUserError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_user_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::DeleteUserOutput, crate::error::DeleteUserError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_user_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_user_permissions_boundary_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<
    crate::output::DeleteUserPermissionsBoundaryOutput,
    crate::error::DeleteUserPermissionsBoundaryError,
> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::DeleteUserPermissionsBoundaryError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DeleteUserPermissionsBoundaryError::unhandled(
                generic,
            ))
        }
    };
    Err(match error_code {
        "NoSuchEntityException" => crate::error::DeleteUserPermissionsBoundaryError {
            meta: generic,
            kind: crate::error::DeleteUserPermissionsBoundaryErrorKind::NoSuchEntityError({
                #[allow(unused_mut)]
                let mut output = crate::error::no_such_entity_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_no_such_entity_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DeleteUserPermissionsBoundaryError::unhandled)?;
                output.build()
            }),
        },
        "ServiceFailureException" => crate::error::DeleteUserPermissionsBoundaryError {
            meta: generic,
            kind: crate::error::DeleteUserPermissionsBoundaryErrorKind::ServiceFailureError({
                #[allow(unused_mut)]
                let mut output = crate::error::service_failure_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_service_failure_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DeleteUserPermissionsBoundaryError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::DeleteUserPermissionsBoundaryError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_user_permissions_boundary_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<
    crate::output::DeleteUserPermissionsBoundaryOutput,
    crate::error::DeleteUserPermissionsBoundaryError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_user_permissions_boundary_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_user_policy_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::DeleteUserPolicyOutput, crate::error::DeleteUserPolicyError> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::DeleteUserPolicyError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DeleteUserPolicyError::unhandled(generic)),
    };
    Err(match error_code {
        "LimitExceededException" => crate::error::DeleteUserPolicyError {
            meta: generic,
            kind: crate::error::DeleteUserPolicyErrorKind::LimitExceededError({
                #[allow(unused_mut)]
                let mut output = crate::error::limit_exceeded_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_limit_exceeded_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DeleteUserPolicyError::unhandled)?;
                output.build()
            }),
        },
        "NoSuchEntityException" => crate::error::DeleteUserPolicyError {
            meta: generic,
            kind: crate::error::DeleteUserPolicyErrorKind::NoSuchEntityError({
                #[allow(unused_mut)]
                let mut output = crate::error::no_such_entity_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_no_such_entity_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DeleteUserPolicyError::unhandled)?;
                output.build()
            }),
        },
        "ServiceFailureException" => crate::error::DeleteUserPolicyError {
            meta: generic,
            kind: crate::error::DeleteUserPolicyErrorKind::ServiceFailureError({
                #[allow(unused_mut)]
                let mut output = crate::error::service_failure_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_service_failure_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DeleteUserPolicyError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::DeleteUserPolicyError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_user_policy_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::DeleteUserPolicyOutput, crate::error::DeleteUserPolicyError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_user_policy_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_virtual_mfa_device_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::DeleteVirtualMFADeviceOutput, crate::error::DeleteVirtualMFADeviceError>
{
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::DeleteVirtualMFADeviceError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DeleteVirtualMFADeviceError::unhandled(
                generic,
            ))
        }
    };
    Err(match error_code {
        "DeleteConflictException" => crate::error::DeleteVirtualMFADeviceError {
            meta: generic,
            kind: crate::error::DeleteVirtualMFADeviceErrorKind::DeleteConflictError({
                #[allow(unused_mut)]
                let mut output = crate::error::delete_conflict_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_delete_conflict_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DeleteVirtualMFADeviceError::unhandled)?;
                output.build()
            }),
        },
        "LimitExceededException" => crate::error::DeleteVirtualMFADeviceError {
            meta: generic,
            kind: crate::error::DeleteVirtualMFADeviceErrorKind::LimitExceededError({
                #[allow(unused_mut)]
                let mut output = crate::error::limit_exceeded_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_limit_exceeded_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DeleteVirtualMFADeviceError::unhandled)?;
                output.build()
            }),
        },
        "NoSuchEntityException" => crate::error::DeleteVirtualMFADeviceError {
            meta: generic,
            kind: crate::error::DeleteVirtualMFADeviceErrorKind::NoSuchEntityError({
                #[allow(unused_mut)]
                let mut output = crate::error::no_such_entity_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_no_such_entity_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DeleteVirtualMFADeviceError::unhandled)?;
                output.build()
            }),
        },
        "ServiceFailureException" => crate::error::DeleteVirtualMFADeviceError {
            meta: generic,
            kind: crate::error::DeleteVirtualMFADeviceErrorKind::ServiceFailureError({
                #[allow(unused_mut)]
                let mut output = crate::error::service_failure_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_service_failure_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DeleteVirtualMFADeviceError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::DeleteVirtualMFADeviceError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_virtual_mfa_device_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::DeleteVirtualMFADeviceOutput, crate::error::DeleteVirtualMFADeviceError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_virtual_mfa_device_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_detach_group_policy_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::DetachGroupPolicyOutput, crate::error::DetachGroupPolicyError> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::DetachGroupPolicyError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DetachGroupPolicyError::unhandled(generic)),
    };
    Err(match error_code {
        "InvalidInputException" => crate::error::DetachGroupPolicyError {
            meta: generic,
            kind: crate::error::DetachGroupPolicyErrorKind::InvalidInputError({
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_input_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_invalid_input_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DetachGroupPolicyError::unhandled)?;
                output.build()
            }),
        },
        "LimitExceededException" => crate::error::DetachGroupPolicyError {
            meta: generic,
            kind: crate::error::DetachGroupPolicyErrorKind::LimitExceededError({
                #[allow(unused_mut)]
                let mut output = crate::error::limit_exceeded_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_limit_exceeded_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DetachGroupPolicyError::unhandled)?;
                output.build()
            }),
        },
        "NoSuchEntityException" => crate::error::DetachGroupPolicyError {
            meta: generic,
            kind: crate::error::DetachGroupPolicyErrorKind::NoSuchEntityError({
                #[allow(unused_mut)]
                let mut output = crate::error::no_such_entity_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_no_such_entity_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DetachGroupPolicyError::unhandled)?;
                output.build()
            }),
        },
        "ServiceFailureException" => crate::error::DetachGroupPolicyError {
            meta: generic,
            kind: crate::error::DetachGroupPolicyErrorKind::ServiceFailureError({
                #[allow(unused_mut)]
                let mut output = crate::error::service_failure_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_service_failure_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DetachGroupPolicyError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::DetachGroupPolicyError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_detach_group_policy_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::DetachGroupPolicyOutput, crate::error::DetachGroupPolicyError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::detach_group_policy_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_detach_role_policy_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::DetachRolePolicyOutput, crate::error::DetachRolePolicyError> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::DetachRolePolicyError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DetachRolePolicyError::unhandled(generic)),
    };
    Err(match error_code {
        "InvalidInputException" => crate::error::DetachRolePolicyError {
            meta: generic,
            kind: crate::error::DetachRolePolicyErrorKind::InvalidInputError({
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_input_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_invalid_input_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DetachRolePolicyError::unhandled)?;
                output.build()
            }),
        },
        "LimitExceededException" => crate::error::DetachRolePolicyError {
            meta: generic,
            kind: crate::error::DetachRolePolicyErrorKind::LimitExceededError({
                #[allow(unused_mut)]
                let mut output = crate::error::limit_exceeded_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_limit_exceeded_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DetachRolePolicyError::unhandled)?;
                output.build()
            }),
        },
        "NoSuchEntityException" => crate::error::DetachRolePolicyError {
            meta: generic,
            kind: crate::error::DetachRolePolicyErrorKind::NoSuchEntityError({
                #[allow(unused_mut)]
                let mut output = crate::error::no_such_entity_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_no_such_entity_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DetachRolePolicyError::unhandled)?;
                output.build()
            }),
        },
        "ServiceFailureException" => crate::error::DetachRolePolicyError {
            meta: generic,
            kind: crate::error::DetachRolePolicyErrorKind::ServiceFailureError({
                #[allow(unused_mut)]
                let mut output = crate::error::service_failure_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_service_failure_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DetachRolePolicyError::unhandled)?;
                output.build()
            }),
        },
        "UnmodifiableEntityException" => crate::error::DetachRolePolicyError {
            meta: generic,
            kind: crate::error::DetachRolePolicyErrorKind::UnmodifiableEntityError({
                #[allow(unused_mut)]
                let mut output = crate::error::unmodifiable_entity_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_unmodifiable_entity_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DetachRolePolicyError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::DetachRolePolicyError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_detach_role_policy_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::DetachRolePolicyOutput, crate::error::DetachRolePolicyError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::detach_role_policy_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_detach_user_policy_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::DetachUserPolicyOutput, crate::error::DetachUserPolicyError> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::DetachUserPolicyError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DetachUserPolicyError::unhandled(generic)),
    };
    Err(match error_code {
        "InvalidInputException" => crate::error::DetachUserPolicyError {
            meta: generic,
            kind: crate::error::DetachUserPolicyErrorKind::InvalidInputError({
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_input_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_invalid_input_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DetachUserPolicyError::unhandled)?;
                output.build()
            }),
        },
        "LimitExceededException" => crate::error::DetachUserPolicyError {
            meta: generic,
            kind: crate::error::DetachUserPolicyErrorKind::LimitExceededError({
                #[allow(unused_mut)]
                let mut output = crate::error::limit_exceeded_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_limit_exceeded_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DetachUserPolicyError::unhandled)?;
                output.build()
            }),
        },
        "NoSuchEntityException" => crate::error::DetachUserPolicyError {
            meta: generic,
            kind: crate::error::DetachUserPolicyErrorKind::NoSuchEntityError({
                #[allow(unused_mut)]
                let mut output = crate::error::no_such_entity_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_no_such_entity_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DetachUserPolicyError::unhandled)?;
                output.build()
            }),
        },
        "ServiceFailureException" => crate::error::DetachUserPolicyError {
            meta: generic,
            kind: crate::error::DetachUserPolicyErrorKind::ServiceFailureError({
                #[allow(unused_mut)]
                let mut output = crate::error::service_failure_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_service_failure_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DetachUserPolicyError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::DetachUserPolicyError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_detach_user_policy_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::DetachUserPolicyOutput, crate::error::DetachUserPolicyError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::detach_user_policy_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_enable_mfa_device_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::EnableMFADeviceOutput, crate::error::EnableMFADeviceError> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::EnableMFADeviceError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::EnableMFADeviceError::unhandled(generic)),
    };
    Err(match error_code {
        "EntityAlreadyExistsException" => crate::error::EnableMFADeviceError {
            meta: generic,
            kind: crate::error::EnableMFADeviceErrorKind::EntityAlreadyExistsError({
                #[allow(unused_mut)]
                let mut output = crate::error::entity_already_exists_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_entity_already_exists_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::EnableMFADeviceError::unhandled)?;
                output.build()
            }),
        },
        "EntityTemporarilyUnmodifiableException" => crate::error::EnableMFADeviceError {
            meta: generic,
            kind: crate::error::EnableMFADeviceErrorKind::EntityTemporarilyUnmodifiableError({
                #[allow(unused_mut)]
                let mut output =
                    crate::error::entity_temporarily_unmodifiable_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_entity_temporarily_unmodifiable_error_xml_err(response.body().as_ref(), output).map_err(crate::error::EnableMFADeviceError::unhandled)?;
                output.build()
            }),
        },
        "InvalidAuthenticationCodeException" => {
            crate::error::EnableMFADeviceError {
                meta: generic,
                kind: crate::error::EnableMFADeviceErrorKind::InvalidAuthenticationCodeError({
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_authentication_code_error::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_invalid_authentication_code_error_xml_err(response.body().as_ref(), output).map_err(crate::error::EnableMFADeviceError::unhandled)?;
                    output.build()
                }),
            }
        }
        "LimitExceededException" => crate::error::EnableMFADeviceError {
            meta: generic,
            kind: crate::error::EnableMFADeviceErrorKind::LimitExceededError({
                #[allow(unused_mut)]
                let mut output = crate::error::limit_exceeded_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_limit_exceeded_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::EnableMFADeviceError::unhandled)?;
                output.build()
            }),
        },
        "NoSuchEntityException" => crate::error::EnableMFADeviceError {
            meta: generic,
            kind: crate::error::EnableMFADeviceErrorKind::NoSuchEntityError({
                #[allow(unused_mut)]
                let mut output = crate::error::no_such_entity_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_no_such_entity_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::EnableMFADeviceError::unhandled)?;
                output.build()
            }),
        },
        "ServiceFailureException" => crate::error::EnableMFADeviceError {
            meta: generic,
            kind: crate::error::EnableMFADeviceErrorKind::ServiceFailureError({
                #[allow(unused_mut)]
                let mut output = crate::error::service_failure_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_service_failure_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::EnableMFADeviceError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::EnableMFADeviceError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_enable_mfa_device_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::EnableMFADeviceOutput, crate::error::EnableMFADeviceError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::enable_mfa_device_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_generate_credential_report_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<
    crate::output::GenerateCredentialReportOutput,
    crate::error::GenerateCredentialReportError,
> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::GenerateCredentialReportError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::GenerateCredentialReportError::unhandled(
                generic,
            ))
        }
    };
    Err(match error_code {
        "LimitExceededException" => crate::error::GenerateCredentialReportError {
            meta: generic,
            kind: crate::error::GenerateCredentialReportErrorKind::LimitExceededError({
                #[allow(unused_mut)]
                let mut output = crate::error::limit_exceeded_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_limit_exceeded_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::GenerateCredentialReportError::unhandled)?;
                output.build()
            }),
        },
        "ServiceFailureException" => crate::error::GenerateCredentialReportError {
            meta: generic,
            kind: crate::error::GenerateCredentialReportErrorKind::ServiceFailureError({
                #[allow(unused_mut)]
                let mut output = crate::error::service_failure_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_service_failure_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::GenerateCredentialReportError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::GenerateCredentialReportError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_generate_credential_report_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<
    crate::output::GenerateCredentialReportOutput,
    crate::error::GenerateCredentialReportError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::generate_credential_report_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_generate_credential_report(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::GenerateCredentialReportError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_generate_organizations_access_report_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<
    crate::output::GenerateOrganizationsAccessReportOutput,
    crate::error::GenerateOrganizationsAccessReportError,
> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::GenerateOrganizationsAccessReportError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::GenerateOrganizationsAccessReportError::unhandled(generic))
        }
    };
    Err(match error_code {
        "ReportGenerationLimitExceededException" => crate::error::GenerateOrganizationsAccessReportError { meta: generic, kind: crate::error::GenerateOrganizationsAccessReportErrorKind::ReportGenerationLimitExceededError({
            #[allow(unused_mut)]let mut output = crate::error::report_generation_limit_exceeded_error::Builder::default();
            let _ = response;
            output = crate::xml_deser::deser_structure_report_generation_limit_exceeded_error_xml_err(response.body().as_ref(), output).map_err(crate::error::GenerateOrganizationsAccessReportError::unhandled)?;
            output.build()
        })},
        _ => crate::error::GenerateOrganizationsAccessReportError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_generate_organizations_access_report_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<
    crate::output::GenerateOrganizationsAccessReportOutput,
    crate::error::GenerateOrganizationsAccessReportError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::generate_organizations_access_report_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_generate_organizations_access_report(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::GenerateOrganizationsAccessReportError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_generate_service_last_accessed_details_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<
    crate::output::GenerateServiceLastAccessedDetailsOutput,
    crate::error::GenerateServiceLastAccessedDetailsError,
> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::GenerateServiceLastAccessedDetailsError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::GenerateServiceLastAccessedDetailsError::unhandled(generic))
        }
    };
    Err(match error_code {
        "InvalidInputException" => crate::error::GenerateServiceLastAccessedDetailsError {
            meta: generic,
            kind: crate::error::GenerateServiceLastAccessedDetailsErrorKind::InvalidInputError({
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_input_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_invalid_input_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::GenerateServiceLastAccessedDetailsError::unhandled)?;
                output.build()
            }),
        },
        "NoSuchEntityException" => crate::error::GenerateServiceLastAccessedDetailsError {
            meta: generic,
            kind: crate::error::GenerateServiceLastAccessedDetailsErrorKind::NoSuchEntityError({
                #[allow(unused_mut)]
                let mut output = crate::error::no_such_entity_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_no_such_entity_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::GenerateServiceLastAccessedDetailsError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::GenerateServiceLastAccessedDetailsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_generate_service_last_accessed_details_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<
    crate::output::GenerateServiceLastAccessedDetailsOutput,
    crate::error::GenerateServiceLastAccessedDetailsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::generate_service_last_accessed_details_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_generate_service_last_accessed_details(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::GenerateServiceLastAccessedDetailsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_access_key_last_used_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::GetAccessKeyLastUsedOutput, crate::error::GetAccessKeyLastUsedError> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::GetAccessKeyLastUsedError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::GetAccessKeyLastUsedError::unhandled(generic)),
    };
    Err(match error_code {
        "NoSuchEntityException" => crate::error::GetAccessKeyLastUsedError {
            meta: generic,
            kind: crate::error::GetAccessKeyLastUsedErrorKind::NoSuchEntityError({
                #[allow(unused_mut)]
                let mut output = crate::error::no_such_entity_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_no_such_entity_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::GetAccessKeyLastUsedError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::GetAccessKeyLastUsedError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_access_key_last_used_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::GetAccessKeyLastUsedOutput, crate::error::GetAccessKeyLastUsedError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_access_key_last_used_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_get_access_key_last_used(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::GetAccessKeyLastUsedError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_account_authorization_details_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<
    crate::output::GetAccountAuthorizationDetailsOutput,
    crate::error::GetAccountAuthorizationDetailsError,
> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::GetAccountAuthorizationDetailsError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::GetAccountAuthorizationDetailsError::unhandled(generic)),
    };
    Err(match error_code {
        "ServiceFailureException" => crate::error::GetAccountAuthorizationDetailsError {
            meta: generic,
            kind: crate::error::GetAccountAuthorizationDetailsErrorKind::ServiceFailureError({
                #[allow(unused_mut)]
                let mut output = crate::error::service_failure_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_service_failure_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::GetAccountAuthorizationDetailsError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::GetAccountAuthorizationDetailsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_account_authorization_details_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<
    crate::output::GetAccountAuthorizationDetailsOutput,
    crate::error::GetAccountAuthorizationDetailsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::get_account_authorization_details_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_get_account_authorization_details(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::GetAccountAuthorizationDetailsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_account_password_policy_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<
    crate::output::GetAccountPasswordPolicyOutput,
    crate::error::GetAccountPasswordPolicyError,
> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::GetAccountPasswordPolicyError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::GetAccountPasswordPolicyError::unhandled(
                generic,
            ))
        }
    };
    Err(match error_code {
        "NoSuchEntityException" => crate::error::GetAccountPasswordPolicyError {
            meta: generic,
            kind: crate::error::GetAccountPasswordPolicyErrorKind::NoSuchEntityError({
                #[allow(unused_mut)]
                let mut output = crate::error::no_such_entity_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_no_such_entity_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::GetAccountPasswordPolicyError::unhandled)?;
                output.build()
            }),
        },
        "ServiceFailureException" => crate::error::GetAccountPasswordPolicyError {
            meta: generic,
            kind: crate::error::GetAccountPasswordPolicyErrorKind::ServiceFailureError({
                #[allow(unused_mut)]
                let mut output = crate::error::service_failure_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_service_failure_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::GetAccountPasswordPolicyError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::GetAccountPasswordPolicyError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_account_password_policy_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<
    crate::output::GetAccountPasswordPolicyOutput,
    crate::error::GetAccountPasswordPolicyError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_account_password_policy_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_get_account_password_policy(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::GetAccountPasswordPolicyError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_account_summary_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::GetAccountSummaryOutput, crate::error::GetAccountSummaryError> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::GetAccountSummaryError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::GetAccountSummaryError::unhandled(generic)),
    };
    Err(match error_code {
        "ServiceFailureException" => crate::error::GetAccountSummaryError {
            meta: generic,
            kind: crate::error::GetAccountSummaryErrorKind::ServiceFailureError({
                #[allow(unused_mut)]
                let mut output = crate::error::service_failure_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_service_failure_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::GetAccountSummaryError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::GetAccountSummaryError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_account_summary_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::GetAccountSummaryOutput, crate::error::GetAccountSummaryError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_account_summary_output::Builder::default();
        let _ = response;
        output =
            crate::xml_deser::deser_operation_get_account_summary(response.body().as_ref(), output)
                .map_err(crate::error::GetAccountSummaryError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_context_keys_for_custom_policy_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<
    crate::output::GetContextKeysForCustomPolicyOutput,
    crate::error::GetContextKeysForCustomPolicyError,
> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::GetContextKeysForCustomPolicyError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::GetContextKeysForCustomPolicyError::unhandled(
                generic,
            ))
        }
    };
    Err(match error_code {
        "InvalidInputException" => crate::error::GetContextKeysForCustomPolicyError {
            meta: generic,
            kind: crate::error::GetContextKeysForCustomPolicyErrorKind::InvalidInputError({
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_input_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_invalid_input_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::GetContextKeysForCustomPolicyError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::GetContextKeysForCustomPolicyError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_context_keys_for_custom_policy_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<
    crate::output::GetContextKeysForCustomPolicyOutput,
    crate::error::GetContextKeysForCustomPolicyError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::get_context_keys_for_custom_policy_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_get_context_keys_for_custom_policy(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::GetContextKeysForCustomPolicyError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_context_keys_for_principal_policy_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<
    crate::output::GetContextKeysForPrincipalPolicyOutput,
    crate::error::GetContextKeysForPrincipalPolicyError,
> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::GetContextKeysForPrincipalPolicyError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::GetContextKeysForPrincipalPolicyError::unhandled(generic))
        }
    };
    Err(match error_code {
        "InvalidInputException" => crate::error::GetContextKeysForPrincipalPolicyError {
            meta: generic,
            kind: crate::error::GetContextKeysForPrincipalPolicyErrorKind::InvalidInputError({
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_input_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_invalid_input_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::GetContextKeysForPrincipalPolicyError::unhandled)?;
                output.build()
            }),
        },
        "NoSuchEntityException" => crate::error::GetContextKeysForPrincipalPolicyError {
            meta: generic,
            kind: crate::error::GetContextKeysForPrincipalPolicyErrorKind::NoSuchEntityError({
                #[allow(unused_mut)]
                let mut output = crate::error::no_such_entity_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_no_such_entity_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::GetContextKeysForPrincipalPolicyError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::GetContextKeysForPrincipalPolicyError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_context_keys_for_principal_policy_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<
    crate::output::GetContextKeysForPrincipalPolicyOutput,
    crate::error::GetContextKeysForPrincipalPolicyError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::get_context_keys_for_principal_policy_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_get_context_keys_for_principal_policy(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::GetContextKeysForPrincipalPolicyError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_credential_report_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::GetCredentialReportOutput, crate::error::GetCredentialReportError> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::GetCredentialReportError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::GetCredentialReportError::unhandled(generic)),
    };
    Err(match error_code {
        "CredentialReportExpiredException" => crate::error::GetCredentialReportError {
            meta: generic,
            kind: crate::error::GetCredentialReportErrorKind::CredentialReportExpiredError({
                #[allow(unused_mut)]
                let mut output = crate::error::credential_report_expired_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_credential_report_expired_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::GetCredentialReportError::unhandled)?;
                output.build()
            }),
        },
        "CredentialReportNotPresentException" => {
            crate::error::GetCredentialReportError {
                meta: generic,
                kind: crate::error::GetCredentialReportErrorKind::CredentialReportNotPresentError(
                    {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::credential_report_not_present_error::Builder::default();
                        let _ = response;
                        output = crate::xml_deser::deser_structure_credential_report_not_present_error_xml_err(response.body().as_ref(), output).map_err(crate::error::GetCredentialReportError::unhandled)?;
                        output.build()
                    },
                ),
            }
        }
        "CredentialReportNotReadyException" => {
            crate::error::GetCredentialReportError {
                meta: generic,
                kind: crate::error::GetCredentialReportErrorKind::CredentialReportNotReadyError({
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::credential_report_not_ready_error::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_credential_report_not_ready_error_xml_err(response.body().as_ref(), output).map_err(crate::error::GetCredentialReportError::unhandled)?;
                    output.build()
                }),
            }
        }
        "ServiceFailureException" => crate::error::GetCredentialReportError {
            meta: generic,
            kind: crate::error::GetCredentialReportErrorKind::ServiceFailureError({
                #[allow(unused_mut)]
                let mut output = crate::error::service_failure_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_service_failure_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::GetCredentialReportError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::GetCredentialReportError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_credential_report_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::GetCredentialReportOutput, crate::error::GetCredentialReportError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_credential_report_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_get_credential_report(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::GetCredentialReportError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_group_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::GetGroupOutput, crate::error::GetGroupError> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::GetGroupError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::GetGroupError::unhandled(generic)),
    };
    Err(match error_code {
        "NoSuchEntityException" => crate::error::GetGroupError {
            meta: generic,
            kind: crate::error::GetGroupErrorKind::NoSuchEntityError({
                #[allow(unused_mut)]
                let mut output = crate::error::no_such_entity_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_no_such_entity_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::GetGroupError::unhandled)?;
                output.build()
            }),
        },
        "ServiceFailureException" => crate::error::GetGroupError {
            meta: generic,
            kind: crate::error::GetGroupErrorKind::ServiceFailureError({
                #[allow(unused_mut)]
                let mut output = crate::error::service_failure_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_service_failure_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::GetGroupError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::GetGroupError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_group_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::GetGroupOutput, crate::error::GetGroupError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_group_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_get_group(response.body().as_ref(), output)
            .map_err(crate::error::GetGroupError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_group_policy_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::GetGroupPolicyOutput, crate::error::GetGroupPolicyError> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::GetGroupPolicyError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::GetGroupPolicyError::unhandled(generic)),
    };
    Err(match error_code {
        "NoSuchEntityException" => crate::error::GetGroupPolicyError {
            meta: generic,
            kind: crate::error::GetGroupPolicyErrorKind::NoSuchEntityError({
                #[allow(unused_mut)]
                let mut output = crate::error::no_such_entity_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_no_such_entity_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::GetGroupPolicyError::unhandled)?;
                output.build()
            }),
        },
        "ServiceFailureException" => crate::error::GetGroupPolicyError {
            meta: generic,
            kind: crate::error::GetGroupPolicyErrorKind::ServiceFailureError({
                #[allow(unused_mut)]
                let mut output = crate::error::service_failure_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_service_failure_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::GetGroupPolicyError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::GetGroupPolicyError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_group_policy_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::GetGroupPolicyOutput, crate::error::GetGroupPolicyError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_group_policy_output::Builder::default();
        let _ = response;
        output =
            crate::xml_deser::deser_operation_get_group_policy(response.body().as_ref(), output)
                .map_err(crate::error::GetGroupPolicyError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_instance_profile_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::GetInstanceProfileOutput, crate::error::GetInstanceProfileError> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::GetInstanceProfileError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::GetInstanceProfileError::unhandled(generic)),
    };
    Err(match error_code {
        "NoSuchEntityException" => crate::error::GetInstanceProfileError {
            meta: generic,
            kind: crate::error::GetInstanceProfileErrorKind::NoSuchEntityError({
                #[allow(unused_mut)]
                let mut output = crate::error::no_such_entity_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_no_such_entity_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::GetInstanceProfileError::unhandled)?;
                output.build()
            }),
        },
        "ServiceFailureException" => crate::error::GetInstanceProfileError {
            meta: generic,
            kind: crate::error::GetInstanceProfileErrorKind::ServiceFailureError({
                #[allow(unused_mut)]
                let mut output = crate::error::service_failure_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_service_failure_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::GetInstanceProfileError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::GetInstanceProfileError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_instance_profile_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::GetInstanceProfileOutput, crate::error::GetInstanceProfileError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_instance_profile_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_get_instance_profile(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::GetInstanceProfileError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_login_profile_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::GetLoginProfileOutput, crate::error::GetLoginProfileError> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::GetLoginProfileError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::GetLoginProfileError::unhandled(generic)),
    };
    Err(match error_code {
        "NoSuchEntityException" => crate::error::GetLoginProfileError {
            meta: generic,
            kind: crate::error::GetLoginProfileErrorKind::NoSuchEntityError({
                #[allow(unused_mut)]
                let mut output = crate::error::no_such_entity_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_no_such_entity_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::GetLoginProfileError::unhandled)?;
                output.build()
            }),
        },
        "ServiceFailureException" => crate::error::GetLoginProfileError {
            meta: generic,
            kind: crate::error::GetLoginProfileErrorKind::ServiceFailureError({
                #[allow(unused_mut)]
                let mut output = crate::error::service_failure_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_service_failure_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::GetLoginProfileError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::GetLoginProfileError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_login_profile_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::GetLoginProfileOutput, crate::error::GetLoginProfileError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_login_profile_output::Builder::default();
        let _ = response;
        output =
            crate::xml_deser::deser_operation_get_login_profile(response.body().as_ref(), output)
                .map_err(crate::error::GetLoginProfileError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_open_id_connect_provider_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<
    crate::output::GetOpenIDConnectProviderOutput,
    crate::error::GetOpenIDConnectProviderError,
> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::GetOpenIDConnectProviderError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::GetOpenIDConnectProviderError::unhandled(
                generic,
            ))
        }
    };
    Err(match error_code {
        "InvalidInputException" => crate::error::GetOpenIDConnectProviderError {
            meta: generic,
            kind: crate::error::GetOpenIDConnectProviderErrorKind::InvalidInputError({
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_input_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_invalid_input_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::GetOpenIDConnectProviderError::unhandled)?;
                output.build()
            }),
        },
        "NoSuchEntityException" => crate::error::GetOpenIDConnectProviderError {
            meta: generic,
            kind: crate::error::GetOpenIDConnectProviderErrorKind::NoSuchEntityError({
                #[allow(unused_mut)]
                let mut output = crate::error::no_such_entity_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_no_such_entity_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::GetOpenIDConnectProviderError::unhandled)?;
                output.build()
            }),
        },
        "ServiceFailureException" => crate::error::GetOpenIDConnectProviderError {
            meta: generic,
            kind: crate::error::GetOpenIDConnectProviderErrorKind::ServiceFailureError({
                #[allow(unused_mut)]
                let mut output = crate::error::service_failure_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_service_failure_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::GetOpenIDConnectProviderError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::GetOpenIDConnectProviderError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_open_id_connect_provider_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<
    crate::output::GetOpenIDConnectProviderOutput,
    crate::error::GetOpenIDConnectProviderError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_open_id_connect_provider_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_get_open_id_connect_provider(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::GetOpenIDConnectProviderError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_organizations_access_report_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<
    crate::output::GetOrganizationsAccessReportOutput,
    crate::error::GetOrganizationsAccessReportError,
> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::GetOrganizationsAccessReportError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::GetOrganizationsAccessReportError::unhandled(
                generic,
            ))
        }
    };
    Err(match error_code {
        "NoSuchEntityException" => crate::error::GetOrganizationsAccessReportError {
            meta: generic,
            kind: crate::error::GetOrganizationsAccessReportErrorKind::NoSuchEntityError({
                #[allow(unused_mut)]
                let mut output = crate::error::no_such_entity_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_no_such_entity_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::GetOrganizationsAccessReportError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::GetOrganizationsAccessReportError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_organizations_access_report_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<
    crate::output::GetOrganizationsAccessReportOutput,
    crate::error::GetOrganizationsAccessReportError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_organizations_access_report_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_get_organizations_access_report(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::GetOrganizationsAccessReportError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_policy_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::GetPolicyOutput, crate::error::GetPolicyError> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::GetPolicyError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::GetPolicyError::unhandled(generic)),
    };
    Err(match error_code {
        "InvalidInputException" => crate::error::GetPolicyError {
            meta: generic,
            kind: crate::error::GetPolicyErrorKind::InvalidInputError({
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_input_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_invalid_input_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::GetPolicyError::unhandled)?;
                output.build()
            }),
        },
        "NoSuchEntityException" => crate::error::GetPolicyError {
            meta: generic,
            kind: crate::error::GetPolicyErrorKind::NoSuchEntityError({
                #[allow(unused_mut)]
                let mut output = crate::error::no_such_entity_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_no_such_entity_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::GetPolicyError::unhandled)?;
                output.build()
            }),
        },
        "ServiceFailureException" => crate::error::GetPolicyError {
            meta: generic,
            kind: crate::error::GetPolicyErrorKind::ServiceFailureError({
                #[allow(unused_mut)]
                let mut output = crate::error::service_failure_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_service_failure_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::GetPolicyError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::GetPolicyError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_policy_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::GetPolicyOutput, crate::error::GetPolicyError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_policy_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_get_policy(response.body().as_ref(), output)
            .map_err(crate::error::GetPolicyError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_policy_version_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::GetPolicyVersionOutput, crate::error::GetPolicyVersionError> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::GetPolicyVersionError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::GetPolicyVersionError::unhandled(generic)),
    };
    Err(match error_code {
        "InvalidInputException" => crate::error::GetPolicyVersionError {
            meta: generic,
            kind: crate::error::GetPolicyVersionErrorKind::InvalidInputError({
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_input_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_invalid_input_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::GetPolicyVersionError::unhandled)?;
                output.build()
            }),
        },
        "NoSuchEntityException" => crate::error::GetPolicyVersionError {
            meta: generic,
            kind: crate::error::GetPolicyVersionErrorKind::NoSuchEntityError({
                #[allow(unused_mut)]
                let mut output = crate::error::no_such_entity_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_no_such_entity_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::GetPolicyVersionError::unhandled)?;
                output.build()
            }),
        },
        "ServiceFailureException" => crate::error::GetPolicyVersionError {
            meta: generic,
            kind: crate::error::GetPolicyVersionErrorKind::ServiceFailureError({
                #[allow(unused_mut)]
                let mut output = crate::error::service_failure_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_service_failure_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::GetPolicyVersionError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::GetPolicyVersionError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_policy_version_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::GetPolicyVersionOutput, crate::error::GetPolicyVersionError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_policy_version_output::Builder::default();
        let _ = response;
        output =
            crate::xml_deser::deser_operation_get_policy_version(response.body().as_ref(), output)
                .map_err(crate::error::GetPolicyVersionError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_role_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::GetRoleOutput, crate::error::GetRoleError> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::GetRoleError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::GetRoleError::unhandled(generic)),
    };
    Err(match error_code {
        "NoSuchEntityException" => crate::error::GetRoleError {
            meta: generic,
            kind: crate::error::GetRoleErrorKind::NoSuchEntityError({
                #[allow(unused_mut)]
                let mut output = crate::error::no_such_entity_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_no_such_entity_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::GetRoleError::unhandled)?;
                output.build()
            }),
        },
        "ServiceFailureException" => crate::error::GetRoleError {
            meta: generic,
            kind: crate::error::GetRoleErrorKind::ServiceFailureError({
                #[allow(unused_mut)]
                let mut output = crate::error::service_failure_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_service_failure_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::GetRoleError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::GetRoleError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_role_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::GetRoleOutput, crate::error::GetRoleError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_role_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_get_role(response.body().as_ref(), output)
            .map_err(crate::error::GetRoleError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_role_policy_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::GetRolePolicyOutput, crate::error::GetRolePolicyError> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::GetRolePolicyError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::GetRolePolicyError::unhandled(generic)),
    };
    Err(match error_code {
        "NoSuchEntityException" => crate::error::GetRolePolicyError {
            meta: generic,
            kind: crate::error::GetRolePolicyErrorKind::NoSuchEntityError({
                #[allow(unused_mut)]
                let mut output = crate::error::no_such_entity_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_no_such_entity_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::GetRolePolicyError::unhandled)?;
                output.build()
            }),
        },
        "ServiceFailureException" => crate::error::GetRolePolicyError {
            meta: generic,
            kind: crate::error::GetRolePolicyErrorKind::ServiceFailureError({
                #[allow(unused_mut)]
                let mut output = crate::error::service_failure_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_service_failure_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::GetRolePolicyError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::GetRolePolicyError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_role_policy_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::GetRolePolicyOutput, crate::error::GetRolePolicyError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_role_policy_output::Builder::default();
        let _ = response;
        output =
            crate::xml_deser::deser_operation_get_role_policy(response.body().as_ref(), output)
                .map_err(crate::error::GetRolePolicyError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_saml_provider_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::GetSAMLProviderOutput, crate::error::GetSAMLProviderError> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::GetSAMLProviderError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::GetSAMLProviderError::unhandled(generic)),
    };
    Err(match error_code {
        "InvalidInputException" => crate::error::GetSAMLProviderError {
            meta: generic,
            kind: crate::error::GetSAMLProviderErrorKind::InvalidInputError({
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_input_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_invalid_input_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::GetSAMLProviderError::unhandled)?;
                output.build()
            }),
        },
        "NoSuchEntityException" => crate::error::GetSAMLProviderError {
            meta: generic,
            kind: crate::error::GetSAMLProviderErrorKind::NoSuchEntityError({
                #[allow(unused_mut)]
                let mut output = crate::error::no_such_entity_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_no_such_entity_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::GetSAMLProviderError::unhandled)?;
                output.build()
            }),
        },
        "ServiceFailureException" => crate::error::GetSAMLProviderError {
            meta: generic,
            kind: crate::error::GetSAMLProviderErrorKind::ServiceFailureError({
                #[allow(unused_mut)]
                let mut output = crate::error::service_failure_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_service_failure_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::GetSAMLProviderError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::GetSAMLProviderError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_saml_provider_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::GetSAMLProviderOutput, crate::error::GetSAMLProviderError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_saml_provider_output::Builder::default();
        let _ = response;
        output =
            crate::xml_deser::deser_operation_get_saml_provider(response.body().as_ref(), output)
                .map_err(crate::error::GetSAMLProviderError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_server_certificate_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::GetServerCertificateOutput, crate::error::GetServerCertificateError> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::GetServerCertificateError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::GetServerCertificateError::unhandled(generic)),
    };
    Err(match error_code {
        "NoSuchEntityException" => crate::error::GetServerCertificateError {
            meta: generic,
            kind: crate::error::GetServerCertificateErrorKind::NoSuchEntityError({
                #[allow(unused_mut)]
                let mut output = crate::error::no_such_entity_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_no_such_entity_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::GetServerCertificateError::unhandled)?;
                output.build()
            }),
        },
        "ServiceFailureException" => crate::error::GetServerCertificateError {
            meta: generic,
            kind: crate::error::GetServerCertificateErrorKind::ServiceFailureError({
                #[allow(unused_mut)]
                let mut output = crate::error::service_failure_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_service_failure_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::GetServerCertificateError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::GetServerCertificateError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_server_certificate_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::GetServerCertificateOutput, crate::error::GetServerCertificateError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_server_certificate_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_get_server_certificate(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::GetServerCertificateError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_service_last_accessed_details_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<
    crate::output::GetServiceLastAccessedDetailsOutput,
    crate::error::GetServiceLastAccessedDetailsError,
> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::GetServiceLastAccessedDetailsError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::GetServiceLastAccessedDetailsError::unhandled(
                generic,
            ))
        }
    };
    Err(match error_code {
        "InvalidInputException" => crate::error::GetServiceLastAccessedDetailsError {
            meta: generic,
            kind: crate::error::GetServiceLastAccessedDetailsErrorKind::InvalidInputError({
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_input_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_invalid_input_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::GetServiceLastAccessedDetailsError::unhandled)?;
                output.build()
            }),
        },
        "NoSuchEntityException" => crate::error::GetServiceLastAccessedDetailsError {
            meta: generic,
            kind: crate::error::GetServiceLastAccessedDetailsErrorKind::NoSuchEntityError({
                #[allow(unused_mut)]
                let mut output = crate::error::no_such_entity_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_no_such_entity_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::GetServiceLastAccessedDetailsError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::GetServiceLastAccessedDetailsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_service_last_accessed_details_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<
    crate::output::GetServiceLastAccessedDetailsOutput,
    crate::error::GetServiceLastAccessedDetailsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::get_service_last_accessed_details_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_get_service_last_accessed_details(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::GetServiceLastAccessedDetailsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_service_last_accessed_details_with_entities_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<
    crate::output::GetServiceLastAccessedDetailsWithEntitiesOutput,
    crate::error::GetServiceLastAccessedDetailsWithEntitiesError,
> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::GetServiceLastAccessedDetailsWithEntitiesError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(
                crate::error::GetServiceLastAccessedDetailsWithEntitiesError::unhandled(generic),
            )
        }
    };
    Err(match error_code {
        "InvalidInputException" => crate::error::GetServiceLastAccessedDetailsWithEntitiesError {
            meta: generic,
            kind:
                crate::error::GetServiceLastAccessedDetailsWithEntitiesErrorKind::InvalidInputError(
                    {
                        #[allow(unused_mut)]
                        let mut output = crate::error::invalid_input_error::Builder::default();
                        let _ = response;
                        output = crate::xml_deser::deser_structure_invalid_input_error_xml_err(
                            response.body().as_ref(),
                            output,
                        )
                        .map_err(
                            crate::error::GetServiceLastAccessedDetailsWithEntitiesError::unhandled,
                        )?;
                        output.build()
                    },
                ),
        },
        "NoSuchEntityException" => crate::error::GetServiceLastAccessedDetailsWithEntitiesError {
            meta: generic,
            kind:
                crate::error::GetServiceLastAccessedDetailsWithEntitiesErrorKind::NoSuchEntityError(
                    {
                        #[allow(unused_mut)]
                        let mut output = crate::error::no_such_entity_error::Builder::default();
                        let _ = response;
                        output = crate::xml_deser::deser_structure_no_such_entity_error_xml_err(
                            response.body().as_ref(),
                            output,
                        )
                        .map_err(
                            crate::error::GetServiceLastAccessedDetailsWithEntitiesError::unhandled,
                        )?;
                        output.build()
                    },
                ),
        },
        _ => crate::error::GetServiceLastAccessedDetailsWithEntitiesError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_service_last_accessed_details_with_entities_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<
    crate::output::GetServiceLastAccessedDetailsWithEntitiesOutput,
    crate::error::GetServiceLastAccessedDetailsWithEntitiesError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::get_service_last_accessed_details_with_entities_output::Builder::default(
            );
        let _ = response;
        output = crate::xml_deser::deser_operation_get_service_last_accessed_details_with_entities(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::GetServiceLastAccessedDetailsWithEntitiesError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_service_linked_role_deletion_status_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<
    crate::output::GetServiceLinkedRoleDeletionStatusOutput,
    crate::error::GetServiceLinkedRoleDeletionStatusError,
> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::GetServiceLinkedRoleDeletionStatusError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::GetServiceLinkedRoleDeletionStatusError::unhandled(generic))
        }
    };
    Err(match error_code {
        "InvalidInputException" => crate::error::GetServiceLinkedRoleDeletionStatusError {
            meta: generic,
            kind: crate::error::GetServiceLinkedRoleDeletionStatusErrorKind::InvalidInputError({
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_input_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_invalid_input_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::GetServiceLinkedRoleDeletionStatusError::unhandled)?;
                output.build()
            }),
        },
        "NoSuchEntityException" => crate::error::GetServiceLinkedRoleDeletionStatusError {
            meta: generic,
            kind: crate::error::GetServiceLinkedRoleDeletionStatusErrorKind::NoSuchEntityError({
                #[allow(unused_mut)]
                let mut output = crate::error::no_such_entity_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_no_such_entity_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::GetServiceLinkedRoleDeletionStatusError::unhandled)?;
                output.build()
            }),
        },
        "ServiceFailureException" => crate::error::GetServiceLinkedRoleDeletionStatusError {
            meta: generic,
            kind: crate::error::GetServiceLinkedRoleDeletionStatusErrorKind::ServiceFailureError({
                #[allow(unused_mut)]
                let mut output = crate::error::service_failure_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_service_failure_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::GetServiceLinkedRoleDeletionStatusError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::GetServiceLinkedRoleDeletionStatusError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_service_linked_role_deletion_status_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<
    crate::output::GetServiceLinkedRoleDeletionStatusOutput,
    crate::error::GetServiceLinkedRoleDeletionStatusError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::get_service_linked_role_deletion_status_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_get_service_linked_role_deletion_status(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::GetServiceLinkedRoleDeletionStatusError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_ssh_public_key_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::GetSSHPublicKeyOutput, crate::error::GetSSHPublicKeyError> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::GetSSHPublicKeyError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::GetSSHPublicKeyError::unhandled(generic)),
    };
    Err(match error_code {
        "NoSuchEntityException" => crate::error::GetSSHPublicKeyError {
            meta: generic,
            kind: crate::error::GetSSHPublicKeyErrorKind::NoSuchEntityError({
                #[allow(unused_mut)]
                let mut output = crate::error::no_such_entity_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_no_such_entity_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::GetSSHPublicKeyError::unhandled)?;
                output.build()
            }),
        },
        "UnrecognizedPublicKeyEncodingException" => crate::error::GetSSHPublicKeyError {
            meta: generic,
            kind: crate::error::GetSSHPublicKeyErrorKind::UnrecognizedPublicKeyEncodingError({
                #[allow(unused_mut)]
                let mut output =
                    crate::error::unrecognized_public_key_encoding_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_unrecognized_public_key_encoding_error_xml_err(response.body().as_ref(), output).map_err(crate::error::GetSSHPublicKeyError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::GetSSHPublicKeyError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_ssh_public_key_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::GetSSHPublicKeyOutput, crate::error::GetSSHPublicKeyError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_ssh_public_key_output::Builder::default();
        let _ = response;
        output =
            crate::xml_deser::deser_operation_get_ssh_public_key(response.body().as_ref(), output)
                .map_err(crate::error::GetSSHPublicKeyError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_user_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::GetUserOutput, crate::error::GetUserError> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::GetUserError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::GetUserError::unhandled(generic)),
    };
    Err(match error_code {
        "NoSuchEntityException" => crate::error::GetUserError {
            meta: generic,
            kind: crate::error::GetUserErrorKind::NoSuchEntityError({
                #[allow(unused_mut)]
                let mut output = crate::error::no_such_entity_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_no_such_entity_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::GetUserError::unhandled)?;
                output.build()
            }),
        },
        "ServiceFailureException" => crate::error::GetUserError {
            meta: generic,
            kind: crate::error::GetUserErrorKind::ServiceFailureError({
                #[allow(unused_mut)]
                let mut output = crate::error::service_failure_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_service_failure_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::GetUserError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::GetUserError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_user_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::GetUserOutput, crate::error::GetUserError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_user_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_get_user(response.body().as_ref(), output)
            .map_err(crate::error::GetUserError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_user_policy_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::GetUserPolicyOutput, crate::error::GetUserPolicyError> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::GetUserPolicyError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::GetUserPolicyError::unhandled(generic)),
    };
    Err(match error_code {
        "NoSuchEntityException" => crate::error::GetUserPolicyError {
            meta: generic,
            kind: crate::error::GetUserPolicyErrorKind::NoSuchEntityError({
                #[allow(unused_mut)]
                let mut output = crate::error::no_such_entity_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_no_such_entity_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::GetUserPolicyError::unhandled)?;
                output.build()
            }),
        },
        "ServiceFailureException" => crate::error::GetUserPolicyError {
            meta: generic,
            kind: crate::error::GetUserPolicyErrorKind::ServiceFailureError({
                #[allow(unused_mut)]
                let mut output = crate::error::service_failure_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_service_failure_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::GetUserPolicyError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::GetUserPolicyError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_user_policy_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::GetUserPolicyOutput, crate::error::GetUserPolicyError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_user_policy_output::Builder::default();
        let _ = response;
        output =
            crate::xml_deser::deser_operation_get_user_policy(response.body().as_ref(), output)
                .map_err(crate::error::GetUserPolicyError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_access_keys_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::ListAccessKeysOutput, crate::error::ListAccessKeysError> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::ListAccessKeysError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ListAccessKeysError::unhandled(generic)),
    };
    Err(match error_code {
        "NoSuchEntityException" => crate::error::ListAccessKeysError {
            meta: generic,
            kind: crate::error::ListAccessKeysErrorKind::NoSuchEntityError({
                #[allow(unused_mut)]
                let mut output = crate::error::no_such_entity_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_no_such_entity_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::ListAccessKeysError::unhandled)?;
                output.build()
            }),
        },
        "ServiceFailureException" => crate::error::ListAccessKeysError {
            meta: generic,
            kind: crate::error::ListAccessKeysErrorKind::ServiceFailureError({
                #[allow(unused_mut)]
                let mut output = crate::error::service_failure_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_service_failure_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::ListAccessKeysError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::ListAccessKeysError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_access_keys_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::ListAccessKeysOutput, crate::error::ListAccessKeysError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_access_keys_output::Builder::default();
        let _ = response;
        output =
            crate::xml_deser::deser_operation_list_access_keys(response.body().as_ref(), output)
                .map_err(crate::error::ListAccessKeysError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_account_aliases_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::ListAccountAliasesOutput, crate::error::ListAccountAliasesError> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::ListAccountAliasesError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ListAccountAliasesError::unhandled(generic)),
    };
    Err(match error_code {
        "ServiceFailureException" => crate::error::ListAccountAliasesError {
            meta: generic,
            kind: crate::error::ListAccountAliasesErrorKind::ServiceFailureError({
                #[allow(unused_mut)]
                let mut output = crate::error::service_failure_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_service_failure_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::ListAccountAliasesError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::ListAccountAliasesError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_account_aliases_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::ListAccountAliasesOutput, crate::error::ListAccountAliasesError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_account_aliases_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_list_account_aliases(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListAccountAliasesError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_attached_group_policies_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<
    crate::output::ListAttachedGroupPoliciesOutput,
    crate::error::ListAttachedGroupPoliciesError,
> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::ListAttachedGroupPoliciesError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::ListAttachedGroupPoliciesError::unhandled(
                generic,
            ))
        }
    };
    Err(match error_code {
        "InvalidInputException" => crate::error::ListAttachedGroupPoliciesError {
            meta: generic,
            kind: crate::error::ListAttachedGroupPoliciesErrorKind::InvalidInputError({
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_input_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_invalid_input_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::ListAttachedGroupPoliciesError::unhandled)?;
                output.build()
            }),
        },
        "NoSuchEntityException" => crate::error::ListAttachedGroupPoliciesError {
            meta: generic,
            kind: crate::error::ListAttachedGroupPoliciesErrorKind::NoSuchEntityError({
                #[allow(unused_mut)]
                let mut output = crate::error::no_such_entity_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_no_such_entity_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::ListAttachedGroupPoliciesError::unhandled)?;
                output.build()
            }),
        },
        "ServiceFailureException" => crate::error::ListAttachedGroupPoliciesError {
            meta: generic,
            kind: crate::error::ListAttachedGroupPoliciesErrorKind::ServiceFailureError({
                #[allow(unused_mut)]
                let mut output = crate::error::service_failure_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_service_failure_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::ListAttachedGroupPoliciesError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::ListAttachedGroupPoliciesError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_attached_group_policies_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<
    crate::output::ListAttachedGroupPoliciesOutput,
    crate::error::ListAttachedGroupPoliciesError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_attached_group_policies_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_list_attached_group_policies(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListAttachedGroupPoliciesError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_attached_role_policies_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<
    crate::output::ListAttachedRolePoliciesOutput,
    crate::error::ListAttachedRolePoliciesError,
> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::ListAttachedRolePoliciesError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::ListAttachedRolePoliciesError::unhandled(
                generic,
            ))
        }
    };
    Err(match error_code {
        "InvalidInputException" => crate::error::ListAttachedRolePoliciesError {
            meta: generic,
            kind: crate::error::ListAttachedRolePoliciesErrorKind::InvalidInputError({
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_input_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_invalid_input_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::ListAttachedRolePoliciesError::unhandled)?;
                output.build()
            }),
        },
        "NoSuchEntityException" => crate::error::ListAttachedRolePoliciesError {
            meta: generic,
            kind: crate::error::ListAttachedRolePoliciesErrorKind::NoSuchEntityError({
                #[allow(unused_mut)]
                let mut output = crate::error::no_such_entity_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_no_such_entity_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::ListAttachedRolePoliciesError::unhandled)?;
                output.build()
            }),
        },
        "ServiceFailureException" => crate::error::ListAttachedRolePoliciesError {
            meta: generic,
            kind: crate::error::ListAttachedRolePoliciesErrorKind::ServiceFailureError({
                #[allow(unused_mut)]
                let mut output = crate::error::service_failure_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_service_failure_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::ListAttachedRolePoliciesError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::ListAttachedRolePoliciesError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_attached_role_policies_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<
    crate::output::ListAttachedRolePoliciesOutput,
    crate::error::ListAttachedRolePoliciesError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_attached_role_policies_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_list_attached_role_policies(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListAttachedRolePoliciesError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_attached_user_policies_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<
    crate::output::ListAttachedUserPoliciesOutput,
    crate::error::ListAttachedUserPoliciesError,
> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::ListAttachedUserPoliciesError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::ListAttachedUserPoliciesError::unhandled(
                generic,
            ))
        }
    };
    Err(match error_code {
        "InvalidInputException" => crate::error::ListAttachedUserPoliciesError {
            meta: generic,
            kind: crate::error::ListAttachedUserPoliciesErrorKind::InvalidInputError({
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_input_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_invalid_input_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::ListAttachedUserPoliciesError::unhandled)?;
                output.build()
            }),
        },
        "NoSuchEntityException" => crate::error::ListAttachedUserPoliciesError {
            meta: generic,
            kind: crate::error::ListAttachedUserPoliciesErrorKind::NoSuchEntityError({
                #[allow(unused_mut)]
                let mut output = crate::error::no_such_entity_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_no_such_entity_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::ListAttachedUserPoliciesError::unhandled)?;
                output.build()
            }),
        },
        "ServiceFailureException" => crate::error::ListAttachedUserPoliciesError {
            meta: generic,
            kind: crate::error::ListAttachedUserPoliciesErrorKind::ServiceFailureError({
                #[allow(unused_mut)]
                let mut output = crate::error::service_failure_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_service_failure_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::ListAttachedUserPoliciesError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::ListAttachedUserPoliciesError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_attached_user_policies_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<
    crate::output::ListAttachedUserPoliciesOutput,
    crate::error::ListAttachedUserPoliciesError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_attached_user_policies_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_list_attached_user_policies(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListAttachedUserPoliciesError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_entities_for_policy_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::ListEntitiesForPolicyOutput, crate::error::ListEntitiesForPolicyError> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::ListEntitiesForPolicyError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ListEntitiesForPolicyError::unhandled(generic)),
    };
    Err(match error_code {
        "InvalidInputException" => crate::error::ListEntitiesForPolicyError {
            meta: generic,
            kind: crate::error::ListEntitiesForPolicyErrorKind::InvalidInputError({
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_input_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_invalid_input_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::ListEntitiesForPolicyError::unhandled)?;
                output.build()
            }),
        },
        "NoSuchEntityException" => crate::error::ListEntitiesForPolicyError {
            meta: generic,
            kind: crate::error::ListEntitiesForPolicyErrorKind::NoSuchEntityError({
                #[allow(unused_mut)]
                let mut output = crate::error::no_such_entity_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_no_such_entity_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::ListEntitiesForPolicyError::unhandled)?;
                output.build()
            }),
        },
        "ServiceFailureException" => crate::error::ListEntitiesForPolicyError {
            meta: generic,
            kind: crate::error::ListEntitiesForPolicyErrorKind::ServiceFailureError({
                #[allow(unused_mut)]
                let mut output = crate::error::service_failure_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_service_failure_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::ListEntitiesForPolicyError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::ListEntitiesForPolicyError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_entities_for_policy_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::ListEntitiesForPolicyOutput, crate::error::ListEntitiesForPolicyError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_entities_for_policy_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_list_entities_for_policy(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListEntitiesForPolicyError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_group_policies_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::ListGroupPoliciesOutput, crate::error::ListGroupPoliciesError> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::ListGroupPoliciesError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ListGroupPoliciesError::unhandled(generic)),
    };
    Err(match error_code {
        "NoSuchEntityException" => crate::error::ListGroupPoliciesError {
            meta: generic,
            kind: crate::error::ListGroupPoliciesErrorKind::NoSuchEntityError({
                #[allow(unused_mut)]
                let mut output = crate::error::no_such_entity_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_no_such_entity_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::ListGroupPoliciesError::unhandled)?;
                output.build()
            }),
        },
        "ServiceFailureException" => crate::error::ListGroupPoliciesError {
            meta: generic,
            kind: crate::error::ListGroupPoliciesErrorKind::ServiceFailureError({
                #[allow(unused_mut)]
                let mut output = crate::error::service_failure_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_service_failure_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::ListGroupPoliciesError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::ListGroupPoliciesError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_group_policies_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::ListGroupPoliciesOutput, crate::error::ListGroupPoliciesError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_group_policies_output::Builder::default();
        let _ = response;
        output =
            crate::xml_deser::deser_operation_list_group_policies(response.body().as_ref(), output)
                .map_err(crate::error::ListGroupPoliciesError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_groups_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::ListGroupsOutput, crate::error::ListGroupsError> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::ListGroupsError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ListGroupsError::unhandled(generic)),
    };
    Err(match error_code {
        "ServiceFailureException" => crate::error::ListGroupsError {
            meta: generic,
            kind: crate::error::ListGroupsErrorKind::ServiceFailureError({
                #[allow(unused_mut)]
                let mut output = crate::error::service_failure_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_service_failure_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::ListGroupsError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::ListGroupsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_groups_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::ListGroupsOutput, crate::error::ListGroupsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_groups_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_list_groups(response.body().as_ref(), output)
            .map_err(crate::error::ListGroupsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_groups_for_user_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::ListGroupsForUserOutput, crate::error::ListGroupsForUserError> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::ListGroupsForUserError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ListGroupsForUserError::unhandled(generic)),
    };
    Err(match error_code {
        "NoSuchEntityException" => crate::error::ListGroupsForUserError {
            meta: generic,
            kind: crate::error::ListGroupsForUserErrorKind::NoSuchEntityError({
                #[allow(unused_mut)]
                let mut output = crate::error::no_such_entity_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_no_such_entity_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::ListGroupsForUserError::unhandled)?;
                output.build()
            }),
        },
        "ServiceFailureException" => crate::error::ListGroupsForUserError {
            meta: generic,
            kind: crate::error::ListGroupsForUserErrorKind::ServiceFailureError({
                #[allow(unused_mut)]
                let mut output = crate::error::service_failure_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_service_failure_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::ListGroupsForUserError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::ListGroupsForUserError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_groups_for_user_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::ListGroupsForUserOutput, crate::error::ListGroupsForUserError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_groups_for_user_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_list_groups_for_user(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListGroupsForUserError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_instance_profiles_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::ListInstanceProfilesOutput, crate::error::ListInstanceProfilesError> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::ListInstanceProfilesError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ListInstanceProfilesError::unhandled(generic)),
    };
    Err(match error_code {
        "ServiceFailureException" => crate::error::ListInstanceProfilesError {
            meta: generic,
            kind: crate::error::ListInstanceProfilesErrorKind::ServiceFailureError({
                #[allow(unused_mut)]
                let mut output = crate::error::service_failure_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_service_failure_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::ListInstanceProfilesError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::ListInstanceProfilesError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_instance_profiles_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::ListInstanceProfilesOutput, crate::error::ListInstanceProfilesError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_instance_profiles_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_list_instance_profiles(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListInstanceProfilesError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_instance_profiles_for_role_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<
    crate::output::ListInstanceProfilesForRoleOutput,
    crate::error::ListInstanceProfilesForRoleError,
> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::ListInstanceProfilesForRoleError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::ListInstanceProfilesForRoleError::unhandled(
                generic,
            ))
        }
    };
    Err(match error_code {
        "NoSuchEntityException" => crate::error::ListInstanceProfilesForRoleError {
            meta: generic,
            kind: crate::error::ListInstanceProfilesForRoleErrorKind::NoSuchEntityError({
                #[allow(unused_mut)]
                let mut output = crate::error::no_such_entity_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_no_such_entity_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::ListInstanceProfilesForRoleError::unhandled)?;
                output.build()
            }),
        },
        "ServiceFailureException" => crate::error::ListInstanceProfilesForRoleError {
            meta: generic,
            kind: crate::error::ListInstanceProfilesForRoleErrorKind::ServiceFailureError({
                #[allow(unused_mut)]
                let mut output = crate::error::service_failure_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_service_failure_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::ListInstanceProfilesForRoleError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::ListInstanceProfilesForRoleError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_instance_profiles_for_role_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<
    crate::output::ListInstanceProfilesForRoleOutput,
    crate::error::ListInstanceProfilesForRoleError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_instance_profiles_for_role_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_list_instance_profiles_for_role(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListInstanceProfilesForRoleError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_instance_profile_tags_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::ListInstanceProfileTagsOutput, crate::error::ListInstanceProfileTagsError>
{
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::ListInstanceProfileTagsError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::ListInstanceProfileTagsError::unhandled(
                generic,
            ))
        }
    };
    Err(match error_code {
        "NoSuchEntityException" => crate::error::ListInstanceProfileTagsError {
            meta: generic,
            kind: crate::error::ListInstanceProfileTagsErrorKind::NoSuchEntityError({
                #[allow(unused_mut)]
                let mut output = crate::error::no_such_entity_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_no_such_entity_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::ListInstanceProfileTagsError::unhandled)?;
                output.build()
            }),
        },
        "ServiceFailureException" => crate::error::ListInstanceProfileTagsError {
            meta: generic,
            kind: crate::error::ListInstanceProfileTagsErrorKind::ServiceFailureError({
                #[allow(unused_mut)]
                let mut output = crate::error::service_failure_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_service_failure_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::ListInstanceProfileTagsError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::ListInstanceProfileTagsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_instance_profile_tags_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::ListInstanceProfileTagsOutput, crate::error::ListInstanceProfileTagsError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_instance_profile_tags_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_list_instance_profile_tags(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListInstanceProfileTagsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_mfa_devices_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::ListMFADevicesOutput, crate::error::ListMFADevicesError> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::ListMFADevicesError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ListMFADevicesError::unhandled(generic)),
    };
    Err(match error_code {
        "NoSuchEntityException" => crate::error::ListMFADevicesError {
            meta: generic,
            kind: crate::error::ListMFADevicesErrorKind::NoSuchEntityError({
                #[allow(unused_mut)]
                let mut output = crate::error::no_such_entity_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_no_such_entity_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::ListMFADevicesError::unhandled)?;
                output.build()
            }),
        },
        "ServiceFailureException" => crate::error::ListMFADevicesError {
            meta: generic,
            kind: crate::error::ListMFADevicesErrorKind::ServiceFailureError({
                #[allow(unused_mut)]
                let mut output = crate::error::service_failure_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_service_failure_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::ListMFADevicesError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::ListMFADevicesError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_mfa_devices_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::ListMFADevicesOutput, crate::error::ListMFADevicesError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_mfa_devices_output::Builder::default();
        let _ = response;
        output =
            crate::xml_deser::deser_operation_list_mfa_devices(response.body().as_ref(), output)
                .map_err(crate::error::ListMFADevicesError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_mfa_device_tags_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::ListMFADeviceTagsOutput, crate::error::ListMFADeviceTagsError> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::ListMFADeviceTagsError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ListMFADeviceTagsError::unhandled(generic)),
    };
    Err(match error_code {
        "InvalidInputException" => crate::error::ListMFADeviceTagsError {
            meta: generic,
            kind: crate::error::ListMFADeviceTagsErrorKind::InvalidInputError({
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_input_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_invalid_input_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::ListMFADeviceTagsError::unhandled)?;
                output.build()
            }),
        },
        "NoSuchEntityException" => crate::error::ListMFADeviceTagsError {
            meta: generic,
            kind: crate::error::ListMFADeviceTagsErrorKind::NoSuchEntityError({
                #[allow(unused_mut)]
                let mut output = crate::error::no_such_entity_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_no_such_entity_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::ListMFADeviceTagsError::unhandled)?;
                output.build()
            }),
        },
        "ServiceFailureException" => crate::error::ListMFADeviceTagsError {
            meta: generic,
            kind: crate::error::ListMFADeviceTagsErrorKind::ServiceFailureError({
                #[allow(unused_mut)]
                let mut output = crate::error::service_failure_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_service_failure_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::ListMFADeviceTagsError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::ListMFADeviceTagsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_mfa_device_tags_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::ListMFADeviceTagsOutput, crate::error::ListMFADeviceTagsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_mfa_device_tags_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_list_mfa_device_tags(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListMFADeviceTagsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_open_id_connect_providers_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<
    crate::output::ListOpenIDConnectProvidersOutput,
    crate::error::ListOpenIDConnectProvidersError,
> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::ListOpenIDConnectProvidersError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::ListOpenIDConnectProvidersError::unhandled(
                generic,
            ))
        }
    };
    Err(match error_code {
        "ServiceFailureException" => crate::error::ListOpenIDConnectProvidersError {
            meta: generic,
            kind: crate::error::ListOpenIDConnectProvidersErrorKind::ServiceFailureError({
                #[allow(unused_mut)]
                let mut output = crate::error::service_failure_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_service_failure_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::ListOpenIDConnectProvidersError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::ListOpenIDConnectProvidersError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_open_id_connect_providers_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<
    crate::output::ListOpenIDConnectProvidersOutput,
    crate::error::ListOpenIDConnectProvidersError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_open_id_connect_providers_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_list_open_id_connect_providers(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListOpenIDConnectProvidersError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_open_id_connect_provider_tags_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<
    crate::output::ListOpenIDConnectProviderTagsOutput,
    crate::error::ListOpenIDConnectProviderTagsError,
> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::ListOpenIDConnectProviderTagsError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::ListOpenIDConnectProviderTagsError::unhandled(
                generic,
            ))
        }
    };
    Err(match error_code {
        "InvalidInputException" => crate::error::ListOpenIDConnectProviderTagsError {
            meta: generic,
            kind: crate::error::ListOpenIDConnectProviderTagsErrorKind::InvalidInputError({
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_input_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_invalid_input_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::ListOpenIDConnectProviderTagsError::unhandled)?;
                output.build()
            }),
        },
        "NoSuchEntityException" => crate::error::ListOpenIDConnectProviderTagsError {
            meta: generic,
            kind: crate::error::ListOpenIDConnectProviderTagsErrorKind::NoSuchEntityError({
                #[allow(unused_mut)]
                let mut output = crate::error::no_such_entity_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_no_such_entity_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::ListOpenIDConnectProviderTagsError::unhandled)?;
                output.build()
            }),
        },
        "ServiceFailureException" => crate::error::ListOpenIDConnectProviderTagsError {
            meta: generic,
            kind: crate::error::ListOpenIDConnectProviderTagsErrorKind::ServiceFailureError({
                #[allow(unused_mut)]
                let mut output = crate::error::service_failure_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_service_failure_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::ListOpenIDConnectProviderTagsError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::ListOpenIDConnectProviderTagsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_open_id_connect_provider_tags_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<
    crate::output::ListOpenIDConnectProviderTagsOutput,
    crate::error::ListOpenIDConnectProviderTagsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::list_open_id_connect_provider_tags_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_list_open_id_connect_provider_tags(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListOpenIDConnectProviderTagsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_policies_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::ListPoliciesOutput, crate::error::ListPoliciesError> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::ListPoliciesError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ListPoliciesError::unhandled(generic)),
    };
    Err(match error_code {
        "ServiceFailureException" => crate::error::ListPoliciesError {
            meta: generic,
            kind: crate::error::ListPoliciesErrorKind::ServiceFailureError({
                #[allow(unused_mut)]
                let mut output = crate::error::service_failure_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_service_failure_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::ListPoliciesError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::ListPoliciesError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_policies_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::ListPoliciesOutput, crate::error::ListPoliciesError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_policies_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_list_policies(response.body().as_ref(), output)
            .map_err(crate::error::ListPoliciesError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_policies_granting_service_access_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<
    crate::output::ListPoliciesGrantingServiceAccessOutput,
    crate::error::ListPoliciesGrantingServiceAccessError,
> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::ListPoliciesGrantingServiceAccessError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::ListPoliciesGrantingServiceAccessError::unhandled(generic))
        }
    };
    Err(match error_code {
        "InvalidInputException" => crate::error::ListPoliciesGrantingServiceAccessError {
            meta: generic,
            kind: crate::error::ListPoliciesGrantingServiceAccessErrorKind::InvalidInputError({
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_input_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_invalid_input_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::ListPoliciesGrantingServiceAccessError::unhandled)?;
                output.build()
            }),
        },
        "NoSuchEntityException" => crate::error::ListPoliciesGrantingServiceAccessError {
            meta: generic,
            kind: crate::error::ListPoliciesGrantingServiceAccessErrorKind::NoSuchEntityError({
                #[allow(unused_mut)]
                let mut output = crate::error::no_such_entity_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_no_such_entity_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::ListPoliciesGrantingServiceAccessError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::ListPoliciesGrantingServiceAccessError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_policies_granting_service_access_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<
    crate::output::ListPoliciesGrantingServiceAccessOutput,
    crate::error::ListPoliciesGrantingServiceAccessError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::list_policies_granting_service_access_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_list_policies_granting_service_access(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListPoliciesGrantingServiceAccessError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_policy_tags_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::ListPolicyTagsOutput, crate::error::ListPolicyTagsError> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::ListPolicyTagsError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ListPolicyTagsError::unhandled(generic)),
    };
    Err(match error_code {
        "InvalidInputException" => crate::error::ListPolicyTagsError {
            meta: generic,
            kind: crate::error::ListPolicyTagsErrorKind::InvalidInputError({
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_input_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_invalid_input_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::ListPolicyTagsError::unhandled)?;
                output.build()
            }),
        },
        "NoSuchEntityException" => crate::error::ListPolicyTagsError {
            meta: generic,
            kind: crate::error::ListPolicyTagsErrorKind::NoSuchEntityError({
                #[allow(unused_mut)]
                let mut output = crate::error::no_such_entity_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_no_such_entity_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::ListPolicyTagsError::unhandled)?;
                output.build()
            }),
        },
        "ServiceFailureException" => crate::error::ListPolicyTagsError {
            meta: generic,
            kind: crate::error::ListPolicyTagsErrorKind::ServiceFailureError({
                #[allow(unused_mut)]
                let mut output = crate::error::service_failure_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_service_failure_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::ListPolicyTagsError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::ListPolicyTagsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_policy_tags_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::ListPolicyTagsOutput, crate::error::ListPolicyTagsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_policy_tags_output::Builder::default();
        let _ = response;
        output =
            crate::xml_deser::deser_operation_list_policy_tags(response.body().as_ref(), output)
                .map_err(crate::error::ListPolicyTagsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_policy_versions_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::ListPolicyVersionsOutput, crate::error::ListPolicyVersionsError> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::ListPolicyVersionsError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ListPolicyVersionsError::unhandled(generic)),
    };
    Err(match error_code {
        "InvalidInputException" => crate::error::ListPolicyVersionsError {
            meta: generic,
            kind: crate::error::ListPolicyVersionsErrorKind::InvalidInputError({
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_input_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_invalid_input_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::ListPolicyVersionsError::unhandled)?;
                output.build()
            }),
        },
        "NoSuchEntityException" => crate::error::ListPolicyVersionsError {
            meta: generic,
            kind: crate::error::ListPolicyVersionsErrorKind::NoSuchEntityError({
                #[allow(unused_mut)]
                let mut output = crate::error::no_such_entity_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_no_such_entity_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::ListPolicyVersionsError::unhandled)?;
                output.build()
            }),
        },
        "ServiceFailureException" => crate::error::ListPolicyVersionsError {
            meta: generic,
            kind: crate::error::ListPolicyVersionsErrorKind::ServiceFailureError({
                #[allow(unused_mut)]
                let mut output = crate::error::service_failure_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_service_failure_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::ListPolicyVersionsError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::ListPolicyVersionsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_policy_versions_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::ListPolicyVersionsOutput, crate::error::ListPolicyVersionsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_policy_versions_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_list_policy_versions(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListPolicyVersionsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_role_policies_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::ListRolePoliciesOutput, crate::error::ListRolePoliciesError> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::ListRolePoliciesError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ListRolePoliciesError::unhandled(generic)),
    };
    Err(match error_code {
        "NoSuchEntityException" => crate::error::ListRolePoliciesError {
            meta: generic,
            kind: crate::error::ListRolePoliciesErrorKind::NoSuchEntityError({
                #[allow(unused_mut)]
                let mut output = crate::error::no_such_entity_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_no_such_entity_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::ListRolePoliciesError::unhandled)?;
                output.build()
            }),
        },
        "ServiceFailureException" => crate::error::ListRolePoliciesError {
            meta: generic,
            kind: crate::error::ListRolePoliciesErrorKind::ServiceFailureError({
                #[allow(unused_mut)]
                let mut output = crate::error::service_failure_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_service_failure_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::ListRolePoliciesError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::ListRolePoliciesError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_role_policies_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::ListRolePoliciesOutput, crate::error::ListRolePoliciesError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_role_policies_output::Builder::default();
        let _ = response;
        output =
            crate::xml_deser::deser_operation_list_role_policies(response.body().as_ref(), output)
                .map_err(crate::error::ListRolePoliciesError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_roles_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::ListRolesOutput, crate::error::ListRolesError> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::ListRolesError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ListRolesError::unhandled(generic)),
    };
    Err(match error_code {
        "ServiceFailureException" => crate::error::ListRolesError {
            meta: generic,
            kind: crate::error::ListRolesErrorKind::ServiceFailureError({
                #[allow(unused_mut)]
                let mut output = crate::error::service_failure_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_service_failure_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::ListRolesError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::ListRolesError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_roles_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::ListRolesOutput, crate::error::ListRolesError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_roles_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_list_roles(response.body().as_ref(), output)
            .map_err(crate::error::ListRolesError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_role_tags_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::ListRoleTagsOutput, crate::error::ListRoleTagsError> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::ListRoleTagsError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ListRoleTagsError::unhandled(generic)),
    };
    Err(match error_code {
        "NoSuchEntityException" => crate::error::ListRoleTagsError {
            meta: generic,
            kind: crate::error::ListRoleTagsErrorKind::NoSuchEntityError({
                #[allow(unused_mut)]
                let mut output = crate::error::no_such_entity_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_no_such_entity_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::ListRoleTagsError::unhandled)?;
                output.build()
            }),
        },
        "ServiceFailureException" => crate::error::ListRoleTagsError {
            meta: generic,
            kind: crate::error::ListRoleTagsErrorKind::ServiceFailureError({
                #[allow(unused_mut)]
                let mut output = crate::error::service_failure_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_service_failure_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::ListRoleTagsError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::ListRoleTagsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_role_tags_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::ListRoleTagsOutput, crate::error::ListRoleTagsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_role_tags_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_list_role_tags(response.body().as_ref(), output)
            .map_err(crate::error::ListRoleTagsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_saml_providers_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::ListSAMLProvidersOutput, crate::error::ListSAMLProvidersError> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::ListSAMLProvidersError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ListSAMLProvidersError::unhandled(generic)),
    };
    Err(match error_code {
        "ServiceFailureException" => crate::error::ListSAMLProvidersError {
            meta: generic,
            kind: crate::error::ListSAMLProvidersErrorKind::ServiceFailureError({
                #[allow(unused_mut)]
                let mut output = crate::error::service_failure_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_service_failure_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::ListSAMLProvidersError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::ListSAMLProvidersError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_saml_providers_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::ListSAMLProvidersOutput, crate::error::ListSAMLProvidersError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_saml_providers_output::Builder::default();
        let _ = response;
        output =
            crate::xml_deser::deser_operation_list_saml_providers(response.body().as_ref(), output)
                .map_err(crate::error::ListSAMLProvidersError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_saml_provider_tags_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::ListSAMLProviderTagsOutput, crate::error::ListSAMLProviderTagsError> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::ListSAMLProviderTagsError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ListSAMLProviderTagsError::unhandled(generic)),
    };
    Err(match error_code {
        "InvalidInputException" => crate::error::ListSAMLProviderTagsError {
            meta: generic,
            kind: crate::error::ListSAMLProviderTagsErrorKind::InvalidInputError({
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_input_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_invalid_input_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::ListSAMLProviderTagsError::unhandled)?;
                output.build()
            }),
        },
        "NoSuchEntityException" => crate::error::ListSAMLProviderTagsError {
            meta: generic,
            kind: crate::error::ListSAMLProviderTagsErrorKind::NoSuchEntityError({
                #[allow(unused_mut)]
                let mut output = crate::error::no_such_entity_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_no_such_entity_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::ListSAMLProviderTagsError::unhandled)?;
                output.build()
            }),
        },
        "ServiceFailureException" => crate::error::ListSAMLProviderTagsError {
            meta: generic,
            kind: crate::error::ListSAMLProviderTagsErrorKind::ServiceFailureError({
                #[allow(unused_mut)]
                let mut output = crate::error::service_failure_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_service_failure_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::ListSAMLProviderTagsError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::ListSAMLProviderTagsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_saml_provider_tags_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::ListSAMLProviderTagsOutput, crate::error::ListSAMLProviderTagsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_saml_provider_tags_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_list_saml_provider_tags(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListSAMLProviderTagsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_server_certificates_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::ListServerCertificatesOutput, crate::error::ListServerCertificatesError>
{
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::ListServerCertificatesError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::ListServerCertificatesError::unhandled(
                generic,
            ))
        }
    };
    Err(match error_code {
        "ServiceFailureException" => crate::error::ListServerCertificatesError {
            meta: generic,
            kind: crate::error::ListServerCertificatesErrorKind::ServiceFailureError({
                #[allow(unused_mut)]
                let mut output = crate::error::service_failure_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_service_failure_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::ListServerCertificatesError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::ListServerCertificatesError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_server_certificates_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::ListServerCertificatesOutput, crate::error::ListServerCertificatesError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_server_certificates_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_list_server_certificates(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListServerCertificatesError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_server_certificate_tags_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<
    crate::output::ListServerCertificateTagsOutput,
    crate::error::ListServerCertificateTagsError,
> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::ListServerCertificateTagsError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::ListServerCertificateTagsError::unhandled(
                generic,
            ))
        }
    };
    Err(match error_code {
        "NoSuchEntityException" => crate::error::ListServerCertificateTagsError {
            meta: generic,
            kind: crate::error::ListServerCertificateTagsErrorKind::NoSuchEntityError({
                #[allow(unused_mut)]
                let mut output = crate::error::no_such_entity_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_no_such_entity_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::ListServerCertificateTagsError::unhandled)?;
                output.build()
            }),
        },
        "ServiceFailureException" => crate::error::ListServerCertificateTagsError {
            meta: generic,
            kind: crate::error::ListServerCertificateTagsErrorKind::ServiceFailureError({
                #[allow(unused_mut)]
                let mut output = crate::error::service_failure_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_service_failure_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::ListServerCertificateTagsError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::ListServerCertificateTagsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_server_certificate_tags_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<
    crate::output::ListServerCertificateTagsOutput,
    crate::error::ListServerCertificateTagsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_server_certificate_tags_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_list_server_certificate_tags(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListServerCertificateTagsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_service_specific_credentials_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<
    crate::output::ListServiceSpecificCredentialsOutput,
    crate::error::ListServiceSpecificCredentialsError,
> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::ListServiceSpecificCredentialsError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ListServiceSpecificCredentialsError::unhandled(generic)),
    };
    Err(match error_code {
        "NoSuchEntityException" => crate::error::ListServiceSpecificCredentialsError {
            meta: generic,
            kind: crate::error::ListServiceSpecificCredentialsErrorKind::NoSuchEntityError({
                #[allow(unused_mut)]
                let mut output = crate::error::no_such_entity_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_no_such_entity_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::ListServiceSpecificCredentialsError::unhandled)?;
                output.build()
            }),
        },
        "ServiceNotSupportedException" => {
            crate::error::ListServiceSpecificCredentialsError {
                meta: generic,
                kind:
                    crate::error::ListServiceSpecificCredentialsErrorKind::ServiceNotSupportedError(
                        {
                            #[allow(unused_mut)]
                            let mut output =
                                crate::error::service_not_supported_error::Builder::default();
                            let _ = response;
                            output = crate::xml_deser::deser_structure_service_not_supported_error_xml_err(response.body().as_ref(), output).map_err(crate::error::ListServiceSpecificCredentialsError::unhandled)?;
                            output.build()
                        },
                    ),
            }
        }
        _ => crate::error::ListServiceSpecificCredentialsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_service_specific_credentials_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<
    crate::output::ListServiceSpecificCredentialsOutput,
    crate::error::ListServiceSpecificCredentialsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::list_service_specific_credentials_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_list_service_specific_credentials(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListServiceSpecificCredentialsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_signing_certificates_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::ListSigningCertificatesOutput, crate::error::ListSigningCertificatesError>
{
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::ListSigningCertificatesError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::ListSigningCertificatesError::unhandled(
                generic,
            ))
        }
    };
    Err(match error_code {
        "NoSuchEntityException" => crate::error::ListSigningCertificatesError {
            meta: generic,
            kind: crate::error::ListSigningCertificatesErrorKind::NoSuchEntityError({
                #[allow(unused_mut)]
                let mut output = crate::error::no_such_entity_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_no_such_entity_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::ListSigningCertificatesError::unhandled)?;
                output.build()
            }),
        },
        "ServiceFailureException" => crate::error::ListSigningCertificatesError {
            meta: generic,
            kind: crate::error::ListSigningCertificatesErrorKind::ServiceFailureError({
                #[allow(unused_mut)]
                let mut output = crate::error::service_failure_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_service_failure_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::ListSigningCertificatesError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::ListSigningCertificatesError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_signing_certificates_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::ListSigningCertificatesOutput, crate::error::ListSigningCertificatesError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_signing_certificates_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_list_signing_certificates(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListSigningCertificatesError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_ssh_public_keys_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::ListSSHPublicKeysOutput, crate::error::ListSSHPublicKeysError> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::ListSSHPublicKeysError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ListSSHPublicKeysError::unhandled(generic)),
    };
    Err(match error_code {
        "NoSuchEntityException" => crate::error::ListSSHPublicKeysError {
            meta: generic,
            kind: crate::error::ListSSHPublicKeysErrorKind::NoSuchEntityError({
                #[allow(unused_mut)]
                let mut output = crate::error::no_such_entity_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_no_such_entity_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::ListSSHPublicKeysError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::ListSSHPublicKeysError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_ssh_public_keys_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::ListSSHPublicKeysOutput, crate::error::ListSSHPublicKeysError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_ssh_public_keys_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_list_ssh_public_keys(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListSSHPublicKeysError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_user_policies_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::ListUserPoliciesOutput, crate::error::ListUserPoliciesError> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::ListUserPoliciesError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ListUserPoliciesError::unhandled(generic)),
    };
    Err(match error_code {
        "NoSuchEntityException" => crate::error::ListUserPoliciesError {
            meta: generic,
            kind: crate::error::ListUserPoliciesErrorKind::NoSuchEntityError({
                #[allow(unused_mut)]
                let mut output = crate::error::no_such_entity_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_no_such_entity_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::ListUserPoliciesError::unhandled)?;
                output.build()
            }),
        },
        "ServiceFailureException" => crate::error::ListUserPoliciesError {
            meta: generic,
            kind: crate::error::ListUserPoliciesErrorKind::ServiceFailureError({
                #[allow(unused_mut)]
                let mut output = crate::error::service_failure_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_service_failure_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::ListUserPoliciesError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::ListUserPoliciesError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_user_policies_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::ListUserPoliciesOutput, crate::error::ListUserPoliciesError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_user_policies_output::Builder::default();
        let _ = response;
        output =
            crate::xml_deser::deser_operation_list_user_policies(response.body().as_ref(), output)
                .map_err(crate::error::ListUserPoliciesError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_users_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::ListUsersOutput, crate::error::ListUsersError> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::ListUsersError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ListUsersError::unhandled(generic)),
    };
    Err(match error_code {
        "ServiceFailureException" => crate::error::ListUsersError {
            meta: generic,
            kind: crate::error::ListUsersErrorKind::ServiceFailureError({
                #[allow(unused_mut)]
                let mut output = crate::error::service_failure_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_service_failure_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::ListUsersError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::ListUsersError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_users_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::ListUsersOutput, crate::error::ListUsersError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_users_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_list_users(response.body().as_ref(), output)
            .map_err(crate::error::ListUsersError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_user_tags_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::ListUserTagsOutput, crate::error::ListUserTagsError> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::ListUserTagsError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ListUserTagsError::unhandled(generic)),
    };
    Err(match error_code {
        "NoSuchEntityException" => crate::error::ListUserTagsError {
            meta: generic,
            kind: crate::error::ListUserTagsErrorKind::NoSuchEntityError({
                #[allow(unused_mut)]
                let mut output = crate::error::no_such_entity_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_no_such_entity_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::ListUserTagsError::unhandled)?;
                output.build()
            }),
        },
        "ServiceFailureException" => crate::error::ListUserTagsError {
            meta: generic,
            kind: crate::error::ListUserTagsErrorKind::ServiceFailureError({
                #[allow(unused_mut)]
                let mut output = crate::error::service_failure_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_service_failure_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::ListUserTagsError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::ListUserTagsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_user_tags_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::ListUserTagsOutput, crate::error::ListUserTagsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_user_tags_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_list_user_tags(response.body().as_ref(), output)
            .map_err(crate::error::ListUserTagsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_virtual_mfa_devices_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::ListVirtualMFADevicesOutput, crate::error::ListVirtualMFADevicesError> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::ListVirtualMFADevicesError::unhandled)?;
    Err(crate::error::ListVirtualMFADevicesError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_virtual_mfa_devices_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::ListVirtualMFADevicesOutput, crate::error::ListVirtualMFADevicesError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_virtual_mfa_devices_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_list_virtual_mfa_devices(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListVirtualMFADevicesError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_put_group_policy_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::PutGroupPolicyOutput, crate::error::PutGroupPolicyError> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::PutGroupPolicyError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::PutGroupPolicyError::unhandled(generic)),
    };
    Err(match error_code {
        "LimitExceededException" => crate::error::PutGroupPolicyError {
            meta: generic,
            kind: crate::error::PutGroupPolicyErrorKind::LimitExceededError({
                #[allow(unused_mut)]
                let mut output = crate::error::limit_exceeded_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_limit_exceeded_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::PutGroupPolicyError::unhandled)?;
                output.build()
            }),
        },
        "MalformedPolicyDocumentException" => crate::error::PutGroupPolicyError {
            meta: generic,
            kind: crate::error::PutGroupPolicyErrorKind::MalformedPolicyDocumentError({
                #[allow(unused_mut)]
                let mut output = crate::error::malformed_policy_document_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_malformed_policy_document_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::PutGroupPolicyError::unhandled)?;
                output.build()
            }),
        },
        "NoSuchEntityException" => crate::error::PutGroupPolicyError {
            meta: generic,
            kind: crate::error::PutGroupPolicyErrorKind::NoSuchEntityError({
                #[allow(unused_mut)]
                let mut output = crate::error::no_such_entity_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_no_such_entity_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::PutGroupPolicyError::unhandled)?;
                output.build()
            }),
        },
        "ServiceFailureException" => crate::error::PutGroupPolicyError {
            meta: generic,
            kind: crate::error::PutGroupPolicyErrorKind::ServiceFailureError({
                #[allow(unused_mut)]
                let mut output = crate::error::service_failure_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_service_failure_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::PutGroupPolicyError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::PutGroupPolicyError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_put_group_policy_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::PutGroupPolicyOutput, crate::error::PutGroupPolicyError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::put_group_policy_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_put_role_permissions_boundary_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<
    crate::output::PutRolePermissionsBoundaryOutput,
    crate::error::PutRolePermissionsBoundaryError,
> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::PutRolePermissionsBoundaryError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::PutRolePermissionsBoundaryError::unhandled(
                generic,
            ))
        }
    };
    Err(match error_code {
        "InvalidInputException" => crate::error::PutRolePermissionsBoundaryError {
            meta: generic,
            kind: crate::error::PutRolePermissionsBoundaryErrorKind::InvalidInputError({
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_input_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_invalid_input_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::PutRolePermissionsBoundaryError::unhandled)?;
                output.build()
            }),
        },
        "NoSuchEntityException" => crate::error::PutRolePermissionsBoundaryError {
            meta: generic,
            kind: crate::error::PutRolePermissionsBoundaryErrorKind::NoSuchEntityError({
                #[allow(unused_mut)]
                let mut output = crate::error::no_such_entity_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_no_such_entity_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::PutRolePermissionsBoundaryError::unhandled)?;
                output.build()
            }),
        },
        "PolicyNotAttachableException" => crate::error::PutRolePermissionsBoundaryError {
            meta: generic,
            kind: crate::error::PutRolePermissionsBoundaryErrorKind::PolicyNotAttachableError({
                #[allow(unused_mut)]
                let mut output = crate::error::policy_not_attachable_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_policy_not_attachable_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::PutRolePermissionsBoundaryError::unhandled)?;
                output.build()
            }),
        },
        "ServiceFailureException" => crate::error::PutRolePermissionsBoundaryError {
            meta: generic,
            kind: crate::error::PutRolePermissionsBoundaryErrorKind::ServiceFailureError({
                #[allow(unused_mut)]
                let mut output = crate::error::service_failure_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_service_failure_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::PutRolePermissionsBoundaryError::unhandled)?;
                output.build()
            }),
        },
        "UnmodifiableEntityException" => crate::error::PutRolePermissionsBoundaryError {
            meta: generic,
            kind: crate::error::PutRolePermissionsBoundaryErrorKind::UnmodifiableEntityError({
                #[allow(unused_mut)]
                let mut output = crate::error::unmodifiable_entity_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_unmodifiable_entity_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::PutRolePermissionsBoundaryError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::PutRolePermissionsBoundaryError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_put_role_permissions_boundary_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<
    crate::output::PutRolePermissionsBoundaryOutput,
    crate::error::PutRolePermissionsBoundaryError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::put_role_permissions_boundary_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_put_role_policy_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::PutRolePolicyOutput, crate::error::PutRolePolicyError> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::PutRolePolicyError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::PutRolePolicyError::unhandled(generic)),
    };
    Err(match error_code {
        "LimitExceededException" => crate::error::PutRolePolicyError {
            meta: generic,
            kind: crate::error::PutRolePolicyErrorKind::LimitExceededError({
                #[allow(unused_mut)]
                let mut output = crate::error::limit_exceeded_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_limit_exceeded_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::PutRolePolicyError::unhandled)?;
                output.build()
            }),
        },
        "MalformedPolicyDocumentException" => crate::error::PutRolePolicyError {
            meta: generic,
            kind: crate::error::PutRolePolicyErrorKind::MalformedPolicyDocumentError({
                #[allow(unused_mut)]
                let mut output = crate::error::malformed_policy_document_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_malformed_policy_document_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::PutRolePolicyError::unhandled)?;
                output.build()
            }),
        },
        "NoSuchEntityException" => crate::error::PutRolePolicyError {
            meta: generic,
            kind: crate::error::PutRolePolicyErrorKind::NoSuchEntityError({
                #[allow(unused_mut)]
                let mut output = crate::error::no_such_entity_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_no_such_entity_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::PutRolePolicyError::unhandled)?;
                output.build()
            }),
        },
        "ServiceFailureException" => crate::error::PutRolePolicyError {
            meta: generic,
            kind: crate::error::PutRolePolicyErrorKind::ServiceFailureError({
                #[allow(unused_mut)]
                let mut output = crate::error::service_failure_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_service_failure_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::PutRolePolicyError::unhandled)?;
                output.build()
            }),
        },
        "UnmodifiableEntityException" => crate::error::PutRolePolicyError {
            meta: generic,
            kind: crate::error::PutRolePolicyErrorKind::UnmodifiableEntityError({
                #[allow(unused_mut)]
                let mut output = crate::error::unmodifiable_entity_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_unmodifiable_entity_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::PutRolePolicyError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::PutRolePolicyError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_put_role_policy_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::PutRolePolicyOutput, crate::error::PutRolePolicyError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::put_role_policy_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_put_user_permissions_boundary_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<
    crate::output::PutUserPermissionsBoundaryOutput,
    crate::error::PutUserPermissionsBoundaryError,
> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::PutUserPermissionsBoundaryError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::PutUserPermissionsBoundaryError::unhandled(
                generic,
            ))
        }
    };
    Err(match error_code {
        "InvalidInputException" => crate::error::PutUserPermissionsBoundaryError {
            meta: generic,
            kind: crate::error::PutUserPermissionsBoundaryErrorKind::InvalidInputError({
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_input_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_invalid_input_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::PutUserPermissionsBoundaryError::unhandled)?;
                output.build()
            }),
        },
        "NoSuchEntityException" => crate::error::PutUserPermissionsBoundaryError {
            meta: generic,
            kind: crate::error::PutUserPermissionsBoundaryErrorKind::NoSuchEntityError({
                #[allow(unused_mut)]
                let mut output = crate::error::no_such_entity_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_no_such_entity_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::PutUserPermissionsBoundaryError::unhandled)?;
                output.build()
            }),
        },
        "PolicyNotAttachableException" => crate::error::PutUserPermissionsBoundaryError {
            meta: generic,
            kind: crate::error::PutUserPermissionsBoundaryErrorKind::PolicyNotAttachableError({
                #[allow(unused_mut)]
                let mut output = crate::error::policy_not_attachable_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_policy_not_attachable_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::PutUserPermissionsBoundaryError::unhandled)?;
                output.build()
            }),
        },
        "ServiceFailureException" => crate::error::PutUserPermissionsBoundaryError {
            meta: generic,
            kind: crate::error::PutUserPermissionsBoundaryErrorKind::ServiceFailureError({
                #[allow(unused_mut)]
                let mut output = crate::error::service_failure_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_service_failure_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::PutUserPermissionsBoundaryError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::PutUserPermissionsBoundaryError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_put_user_permissions_boundary_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<
    crate::output::PutUserPermissionsBoundaryOutput,
    crate::error::PutUserPermissionsBoundaryError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::put_user_permissions_boundary_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_put_user_policy_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::PutUserPolicyOutput, crate::error::PutUserPolicyError> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::PutUserPolicyError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::PutUserPolicyError::unhandled(generic)),
    };
    Err(match error_code {
        "LimitExceededException" => crate::error::PutUserPolicyError {
            meta: generic,
            kind: crate::error::PutUserPolicyErrorKind::LimitExceededError({
                #[allow(unused_mut)]
                let mut output = crate::error::limit_exceeded_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_limit_exceeded_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::PutUserPolicyError::unhandled)?;
                output.build()
            }),
        },
        "MalformedPolicyDocumentException" => crate::error::PutUserPolicyError {
            meta: generic,
            kind: crate::error::PutUserPolicyErrorKind::MalformedPolicyDocumentError({
                #[allow(unused_mut)]
                let mut output = crate::error::malformed_policy_document_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_malformed_policy_document_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::PutUserPolicyError::unhandled)?;
                output.build()
            }),
        },
        "NoSuchEntityException" => crate::error::PutUserPolicyError {
            meta: generic,
            kind: crate::error::PutUserPolicyErrorKind::NoSuchEntityError({
                #[allow(unused_mut)]
                let mut output = crate::error::no_such_entity_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_no_such_entity_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::PutUserPolicyError::unhandled)?;
                output.build()
            }),
        },
        "ServiceFailureException" => crate::error::PutUserPolicyError {
            meta: generic,
            kind: crate::error::PutUserPolicyErrorKind::ServiceFailureError({
                #[allow(unused_mut)]
                let mut output = crate::error::service_failure_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_service_failure_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::PutUserPolicyError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::PutUserPolicyError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_put_user_policy_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::PutUserPolicyOutput, crate::error::PutUserPolicyError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::put_user_policy_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_remove_client_id_from_open_id_connect_provider_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<
    crate::output::RemoveClientIDFromOpenIDConnectProviderOutput,
    crate::error::RemoveClientIDFromOpenIDConnectProviderError,
> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::RemoveClientIDFromOpenIDConnectProviderError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(
                crate::error::RemoveClientIDFromOpenIDConnectProviderError::unhandled(generic),
            )
        }
    };
    Err(match error_code {
        "InvalidInputException" => crate::error::RemoveClientIDFromOpenIDConnectProviderError {
            meta: generic,
            kind: crate::error::RemoveClientIDFromOpenIDConnectProviderErrorKind::InvalidInputError(
                {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_input_error::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_invalid_input_error_xml_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(
                        crate::error::RemoveClientIDFromOpenIDConnectProviderError::unhandled,
                    )?;
                    output.build()
                },
            ),
        },
        "NoSuchEntityException" => crate::error::RemoveClientIDFromOpenIDConnectProviderError {
            meta: generic,
            kind: crate::error::RemoveClientIDFromOpenIDConnectProviderErrorKind::NoSuchEntityError(
                {
                    #[allow(unused_mut)]
                    let mut output = crate::error::no_such_entity_error::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_no_such_entity_error_xml_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(
                        crate::error::RemoveClientIDFromOpenIDConnectProviderError::unhandled,
                    )?;
                    output.build()
                },
            ),
        },
        "ServiceFailureException" => crate::error::RemoveClientIDFromOpenIDConnectProviderError {
            meta: generic,
            kind:
                crate::error::RemoveClientIDFromOpenIDConnectProviderErrorKind::ServiceFailureError(
                    {
                        #[allow(unused_mut)]
                        let mut output = crate::error::service_failure_error::Builder::default();
                        let _ = response;
                        output = crate::xml_deser::deser_structure_service_failure_error_xml_err(
                            response.body().as_ref(),
                            output,
                        )
                        .map_err(
                            crate::error::RemoveClientIDFromOpenIDConnectProviderError::unhandled,
                        )?;
                        output.build()
                    },
                ),
        },
        _ => crate::error::RemoveClientIDFromOpenIDConnectProviderError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_remove_client_id_from_open_id_connect_provider_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<
    crate::output::RemoveClientIDFromOpenIDConnectProviderOutput,
    crate::error::RemoveClientIDFromOpenIDConnectProviderError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::remove_client_id_from_open_id_connect_provider_output::Builder::default(
            );
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_remove_role_from_instance_profile_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<
    crate::output::RemoveRoleFromInstanceProfileOutput,
    crate::error::RemoveRoleFromInstanceProfileError,
> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::RemoveRoleFromInstanceProfileError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::RemoveRoleFromInstanceProfileError::unhandled(
                generic,
            ))
        }
    };
    Err(match error_code {
        "LimitExceededException" => crate::error::RemoveRoleFromInstanceProfileError {
            meta: generic,
            kind: crate::error::RemoveRoleFromInstanceProfileErrorKind::LimitExceededError({
                #[allow(unused_mut)]
                let mut output = crate::error::limit_exceeded_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_limit_exceeded_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::RemoveRoleFromInstanceProfileError::unhandled)?;
                output.build()
            }),
        },
        "NoSuchEntityException" => crate::error::RemoveRoleFromInstanceProfileError {
            meta: generic,
            kind: crate::error::RemoveRoleFromInstanceProfileErrorKind::NoSuchEntityError({
                #[allow(unused_mut)]
                let mut output = crate::error::no_such_entity_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_no_such_entity_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::RemoveRoleFromInstanceProfileError::unhandled)?;
                output.build()
            }),
        },
        "ServiceFailureException" => crate::error::RemoveRoleFromInstanceProfileError {
            meta: generic,
            kind: crate::error::RemoveRoleFromInstanceProfileErrorKind::ServiceFailureError({
                #[allow(unused_mut)]
                let mut output = crate::error::service_failure_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_service_failure_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::RemoveRoleFromInstanceProfileError::unhandled)?;
                output.build()
            }),
        },
        "UnmodifiableEntityException" => crate::error::RemoveRoleFromInstanceProfileError {
            meta: generic,
            kind: crate::error::RemoveRoleFromInstanceProfileErrorKind::UnmodifiableEntityError({
                #[allow(unused_mut)]
                let mut output = crate::error::unmodifiable_entity_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_unmodifiable_entity_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::RemoveRoleFromInstanceProfileError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::RemoveRoleFromInstanceProfileError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_remove_role_from_instance_profile_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<
    crate::output::RemoveRoleFromInstanceProfileOutput,
    crate::error::RemoveRoleFromInstanceProfileError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::remove_role_from_instance_profile_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_remove_user_from_group_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::RemoveUserFromGroupOutput, crate::error::RemoveUserFromGroupError> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::RemoveUserFromGroupError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::RemoveUserFromGroupError::unhandled(generic)),
    };
    Err(match error_code {
        "LimitExceededException" => crate::error::RemoveUserFromGroupError {
            meta: generic,
            kind: crate::error::RemoveUserFromGroupErrorKind::LimitExceededError({
                #[allow(unused_mut)]
                let mut output = crate::error::limit_exceeded_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_limit_exceeded_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::RemoveUserFromGroupError::unhandled)?;
                output.build()
            }),
        },
        "NoSuchEntityException" => crate::error::RemoveUserFromGroupError {
            meta: generic,
            kind: crate::error::RemoveUserFromGroupErrorKind::NoSuchEntityError({
                #[allow(unused_mut)]
                let mut output = crate::error::no_such_entity_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_no_such_entity_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::RemoveUserFromGroupError::unhandled)?;
                output.build()
            }),
        },
        "ServiceFailureException" => crate::error::RemoveUserFromGroupError {
            meta: generic,
            kind: crate::error::RemoveUserFromGroupErrorKind::ServiceFailureError({
                #[allow(unused_mut)]
                let mut output = crate::error::service_failure_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_service_failure_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::RemoveUserFromGroupError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::RemoveUserFromGroupError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_remove_user_from_group_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::RemoveUserFromGroupOutput, crate::error::RemoveUserFromGroupError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::remove_user_from_group_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_reset_service_specific_credential_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<
    crate::output::ResetServiceSpecificCredentialOutput,
    crate::error::ResetServiceSpecificCredentialError,
> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::ResetServiceSpecificCredentialError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ResetServiceSpecificCredentialError::unhandled(generic)),
    };
    Err(match error_code {
        "NoSuchEntityException" => crate::error::ResetServiceSpecificCredentialError {
            meta: generic,
            kind: crate::error::ResetServiceSpecificCredentialErrorKind::NoSuchEntityError({
                #[allow(unused_mut)]
                let mut output = crate::error::no_such_entity_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_no_such_entity_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::ResetServiceSpecificCredentialError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::ResetServiceSpecificCredentialError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_reset_service_specific_credential_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<
    crate::output::ResetServiceSpecificCredentialOutput,
    crate::error::ResetServiceSpecificCredentialError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::reset_service_specific_credential_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_reset_service_specific_credential(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ResetServiceSpecificCredentialError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_resync_mfa_device_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::ResyncMFADeviceOutput, crate::error::ResyncMFADeviceError> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::ResyncMFADeviceError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ResyncMFADeviceError::unhandled(generic)),
    };
    Err(match error_code {
        "InvalidAuthenticationCodeException" => {
            crate::error::ResyncMFADeviceError {
                meta: generic,
                kind: crate::error::ResyncMFADeviceErrorKind::InvalidAuthenticationCodeError({
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_authentication_code_error::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_invalid_authentication_code_error_xml_err(response.body().as_ref(), output).map_err(crate::error::ResyncMFADeviceError::unhandled)?;
                    output.build()
                }),
            }
        }
        "LimitExceededException" => crate::error::ResyncMFADeviceError {
            meta: generic,
            kind: crate::error::ResyncMFADeviceErrorKind::LimitExceededError({
                #[allow(unused_mut)]
                let mut output = crate::error::limit_exceeded_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_limit_exceeded_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::ResyncMFADeviceError::unhandled)?;
                output.build()
            }),
        },
        "NoSuchEntityException" => crate::error::ResyncMFADeviceError {
            meta: generic,
            kind: crate::error::ResyncMFADeviceErrorKind::NoSuchEntityError({
                #[allow(unused_mut)]
                let mut output = crate::error::no_such_entity_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_no_such_entity_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::ResyncMFADeviceError::unhandled)?;
                output.build()
            }),
        },
        "ServiceFailureException" => crate::error::ResyncMFADeviceError {
            meta: generic,
            kind: crate::error::ResyncMFADeviceErrorKind::ServiceFailureError({
                #[allow(unused_mut)]
                let mut output = crate::error::service_failure_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_service_failure_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::ResyncMFADeviceError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::ResyncMFADeviceError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_resync_mfa_device_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::ResyncMFADeviceOutput, crate::error::ResyncMFADeviceError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::resync_mfa_device_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_set_default_policy_version_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::SetDefaultPolicyVersionOutput, crate::error::SetDefaultPolicyVersionError>
{
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::SetDefaultPolicyVersionError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::SetDefaultPolicyVersionError::unhandled(
                generic,
            ))
        }
    };
    Err(match error_code {
        "InvalidInputException" => crate::error::SetDefaultPolicyVersionError {
            meta: generic,
            kind: crate::error::SetDefaultPolicyVersionErrorKind::InvalidInputError({
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_input_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_invalid_input_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::SetDefaultPolicyVersionError::unhandled)?;
                output.build()
            }),
        },
        "LimitExceededException" => crate::error::SetDefaultPolicyVersionError {
            meta: generic,
            kind: crate::error::SetDefaultPolicyVersionErrorKind::LimitExceededError({
                #[allow(unused_mut)]
                let mut output = crate::error::limit_exceeded_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_limit_exceeded_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::SetDefaultPolicyVersionError::unhandled)?;
                output.build()
            }),
        },
        "NoSuchEntityException" => crate::error::SetDefaultPolicyVersionError {
            meta: generic,
            kind: crate::error::SetDefaultPolicyVersionErrorKind::NoSuchEntityError({
                #[allow(unused_mut)]
                let mut output = crate::error::no_such_entity_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_no_such_entity_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::SetDefaultPolicyVersionError::unhandled)?;
                output.build()
            }),
        },
        "ServiceFailureException" => crate::error::SetDefaultPolicyVersionError {
            meta: generic,
            kind: crate::error::SetDefaultPolicyVersionErrorKind::ServiceFailureError({
                #[allow(unused_mut)]
                let mut output = crate::error::service_failure_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_service_failure_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::SetDefaultPolicyVersionError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::SetDefaultPolicyVersionError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_set_default_policy_version_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::SetDefaultPolicyVersionOutput, crate::error::SetDefaultPolicyVersionError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::set_default_policy_version_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_set_security_token_service_preferences_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<
    crate::output::SetSecurityTokenServicePreferencesOutput,
    crate::error::SetSecurityTokenServicePreferencesError,
> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::SetSecurityTokenServicePreferencesError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::SetSecurityTokenServicePreferencesError::unhandled(generic))
        }
    };
    Err(match error_code {
        "ServiceFailureException" => crate::error::SetSecurityTokenServicePreferencesError {
            meta: generic,
            kind: crate::error::SetSecurityTokenServicePreferencesErrorKind::ServiceFailureError({
                #[allow(unused_mut)]
                let mut output = crate::error::service_failure_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_service_failure_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::SetSecurityTokenServicePreferencesError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::SetSecurityTokenServicePreferencesError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_set_security_token_service_preferences_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<
    crate::output::SetSecurityTokenServicePreferencesOutput,
    crate::error::SetSecurityTokenServicePreferencesError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::set_security_token_service_preferences_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_simulate_custom_policy_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::SimulateCustomPolicyOutput, crate::error::SimulateCustomPolicyError> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::SimulateCustomPolicyError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::SimulateCustomPolicyError::unhandled(generic)),
    };
    Err(match error_code {
        "InvalidInputException" => crate::error::SimulateCustomPolicyError {
            meta: generic,
            kind: crate::error::SimulateCustomPolicyErrorKind::InvalidInputError({
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_input_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_invalid_input_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::SimulateCustomPolicyError::unhandled)?;
                output.build()
            }),
        },
        "PolicyEvaluationException" => crate::error::SimulateCustomPolicyError {
            meta: generic,
            kind: crate::error::SimulateCustomPolicyErrorKind::PolicyEvaluationError({
                #[allow(unused_mut)]
                let mut output = crate::error::policy_evaluation_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_policy_evaluation_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::SimulateCustomPolicyError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::SimulateCustomPolicyError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_simulate_custom_policy_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::SimulateCustomPolicyOutput, crate::error::SimulateCustomPolicyError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::simulate_custom_policy_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_simulate_custom_policy(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::SimulateCustomPolicyError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_simulate_principal_policy_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::SimulatePrincipalPolicyOutput, crate::error::SimulatePrincipalPolicyError>
{
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::SimulatePrincipalPolicyError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::SimulatePrincipalPolicyError::unhandled(
                generic,
            ))
        }
    };
    Err(match error_code {
        "InvalidInputException" => crate::error::SimulatePrincipalPolicyError {
            meta: generic,
            kind: crate::error::SimulatePrincipalPolicyErrorKind::InvalidInputError({
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_input_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_invalid_input_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::SimulatePrincipalPolicyError::unhandled)?;
                output.build()
            }),
        },
        "NoSuchEntityException" => crate::error::SimulatePrincipalPolicyError {
            meta: generic,
            kind: crate::error::SimulatePrincipalPolicyErrorKind::NoSuchEntityError({
                #[allow(unused_mut)]
                let mut output = crate::error::no_such_entity_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_no_such_entity_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::SimulatePrincipalPolicyError::unhandled)?;
                output.build()
            }),
        },
        "PolicyEvaluationException" => crate::error::SimulatePrincipalPolicyError {
            meta: generic,
            kind: crate::error::SimulatePrincipalPolicyErrorKind::PolicyEvaluationError({
                #[allow(unused_mut)]
                let mut output = crate::error::policy_evaluation_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_policy_evaluation_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::SimulatePrincipalPolicyError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::SimulatePrincipalPolicyError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_simulate_principal_policy_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::SimulatePrincipalPolicyOutput, crate::error::SimulatePrincipalPolicyError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::simulate_principal_policy_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_simulate_principal_policy(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::SimulatePrincipalPolicyError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_tag_instance_profile_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::TagInstanceProfileOutput, crate::error::TagInstanceProfileError> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::TagInstanceProfileError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::TagInstanceProfileError::unhandled(generic)),
    };
    Err(match error_code {
        "ConcurrentModificationException" => crate::error::TagInstanceProfileError {
            meta: generic,
            kind: crate::error::TagInstanceProfileErrorKind::ConcurrentModificationError({
                #[allow(unused_mut)]
                let mut output = crate::error::concurrent_modification_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_concurrent_modification_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::TagInstanceProfileError::unhandled)?;
                output.build()
            }),
        },
        "InvalidInputException" => crate::error::TagInstanceProfileError {
            meta: generic,
            kind: crate::error::TagInstanceProfileErrorKind::InvalidInputError({
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_input_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_invalid_input_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::TagInstanceProfileError::unhandled)?;
                output.build()
            }),
        },
        "LimitExceededException" => crate::error::TagInstanceProfileError {
            meta: generic,
            kind: crate::error::TagInstanceProfileErrorKind::LimitExceededError({
                #[allow(unused_mut)]
                let mut output = crate::error::limit_exceeded_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_limit_exceeded_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::TagInstanceProfileError::unhandled)?;
                output.build()
            }),
        },
        "NoSuchEntityException" => crate::error::TagInstanceProfileError {
            meta: generic,
            kind: crate::error::TagInstanceProfileErrorKind::NoSuchEntityError({
                #[allow(unused_mut)]
                let mut output = crate::error::no_such_entity_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_no_such_entity_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::TagInstanceProfileError::unhandled)?;
                output.build()
            }),
        },
        "ServiceFailureException" => crate::error::TagInstanceProfileError {
            meta: generic,
            kind: crate::error::TagInstanceProfileErrorKind::ServiceFailureError({
                #[allow(unused_mut)]
                let mut output = crate::error::service_failure_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_service_failure_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::TagInstanceProfileError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::TagInstanceProfileError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_tag_instance_profile_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::TagInstanceProfileOutput, crate::error::TagInstanceProfileError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::tag_instance_profile_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_tag_mfa_device_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::TagMFADeviceOutput, crate::error::TagMFADeviceError> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::TagMFADeviceError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::TagMFADeviceError::unhandled(generic)),
    };
    Err(match error_code {
        "ConcurrentModificationException" => crate::error::TagMFADeviceError {
            meta: generic,
            kind: crate::error::TagMFADeviceErrorKind::ConcurrentModificationError({
                #[allow(unused_mut)]
                let mut output = crate::error::concurrent_modification_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_concurrent_modification_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::TagMFADeviceError::unhandled)?;
                output.build()
            }),
        },
        "InvalidInputException" => crate::error::TagMFADeviceError {
            meta: generic,
            kind: crate::error::TagMFADeviceErrorKind::InvalidInputError({
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_input_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_invalid_input_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::TagMFADeviceError::unhandled)?;
                output.build()
            }),
        },
        "LimitExceededException" => crate::error::TagMFADeviceError {
            meta: generic,
            kind: crate::error::TagMFADeviceErrorKind::LimitExceededError({
                #[allow(unused_mut)]
                let mut output = crate::error::limit_exceeded_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_limit_exceeded_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::TagMFADeviceError::unhandled)?;
                output.build()
            }),
        },
        "NoSuchEntityException" => crate::error::TagMFADeviceError {
            meta: generic,
            kind: crate::error::TagMFADeviceErrorKind::NoSuchEntityError({
                #[allow(unused_mut)]
                let mut output = crate::error::no_such_entity_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_no_such_entity_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::TagMFADeviceError::unhandled)?;
                output.build()
            }),
        },
        "ServiceFailureException" => crate::error::TagMFADeviceError {
            meta: generic,
            kind: crate::error::TagMFADeviceErrorKind::ServiceFailureError({
                #[allow(unused_mut)]
                let mut output = crate::error::service_failure_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_service_failure_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::TagMFADeviceError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::TagMFADeviceError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_tag_mfa_device_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::TagMFADeviceOutput, crate::error::TagMFADeviceError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::tag_mfa_device_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_tag_open_id_connect_provider_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<
    crate::output::TagOpenIDConnectProviderOutput,
    crate::error::TagOpenIDConnectProviderError,
> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::TagOpenIDConnectProviderError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::TagOpenIDConnectProviderError::unhandled(
                generic,
            ))
        }
    };
    Err(match error_code {
        "ConcurrentModificationException" => crate::error::TagOpenIDConnectProviderError {
            meta: generic,
            kind: crate::error::TagOpenIDConnectProviderErrorKind::ConcurrentModificationError({
                #[allow(unused_mut)]
                let mut output = crate::error::concurrent_modification_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_concurrent_modification_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::TagOpenIDConnectProviderError::unhandled)?;
                output.build()
            }),
        },
        "InvalidInputException" => crate::error::TagOpenIDConnectProviderError {
            meta: generic,
            kind: crate::error::TagOpenIDConnectProviderErrorKind::InvalidInputError({
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_input_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_invalid_input_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::TagOpenIDConnectProviderError::unhandled)?;
                output.build()
            }),
        },
        "LimitExceededException" => crate::error::TagOpenIDConnectProviderError {
            meta: generic,
            kind: crate::error::TagOpenIDConnectProviderErrorKind::LimitExceededError({
                #[allow(unused_mut)]
                let mut output = crate::error::limit_exceeded_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_limit_exceeded_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::TagOpenIDConnectProviderError::unhandled)?;
                output.build()
            }),
        },
        "NoSuchEntityException" => crate::error::TagOpenIDConnectProviderError {
            meta: generic,
            kind: crate::error::TagOpenIDConnectProviderErrorKind::NoSuchEntityError({
                #[allow(unused_mut)]
                let mut output = crate::error::no_such_entity_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_no_such_entity_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::TagOpenIDConnectProviderError::unhandled)?;
                output.build()
            }),
        },
        "ServiceFailureException" => crate::error::TagOpenIDConnectProviderError {
            meta: generic,
            kind: crate::error::TagOpenIDConnectProviderErrorKind::ServiceFailureError({
                #[allow(unused_mut)]
                let mut output = crate::error::service_failure_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_service_failure_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::TagOpenIDConnectProviderError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::TagOpenIDConnectProviderError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_tag_open_id_connect_provider_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<
    crate::output::TagOpenIDConnectProviderOutput,
    crate::error::TagOpenIDConnectProviderError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::tag_open_id_connect_provider_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_tag_policy_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::TagPolicyOutput, crate::error::TagPolicyError> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::TagPolicyError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::TagPolicyError::unhandled(generic)),
    };
    Err(match error_code {
        "ConcurrentModificationException" => crate::error::TagPolicyError {
            meta: generic,
            kind: crate::error::TagPolicyErrorKind::ConcurrentModificationError({
                #[allow(unused_mut)]
                let mut output = crate::error::concurrent_modification_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_concurrent_modification_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::TagPolicyError::unhandled)?;
                output.build()
            }),
        },
        "InvalidInputException" => crate::error::TagPolicyError {
            meta: generic,
            kind: crate::error::TagPolicyErrorKind::InvalidInputError({
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_input_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_invalid_input_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::TagPolicyError::unhandled)?;
                output.build()
            }),
        },
        "LimitExceededException" => crate::error::TagPolicyError {
            meta: generic,
            kind: crate::error::TagPolicyErrorKind::LimitExceededError({
                #[allow(unused_mut)]
                let mut output = crate::error::limit_exceeded_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_limit_exceeded_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::TagPolicyError::unhandled)?;
                output.build()
            }),
        },
        "NoSuchEntityException" => crate::error::TagPolicyError {
            meta: generic,
            kind: crate::error::TagPolicyErrorKind::NoSuchEntityError({
                #[allow(unused_mut)]
                let mut output = crate::error::no_such_entity_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_no_such_entity_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::TagPolicyError::unhandled)?;
                output.build()
            }),
        },
        "ServiceFailureException" => crate::error::TagPolicyError {
            meta: generic,
            kind: crate::error::TagPolicyErrorKind::ServiceFailureError({
                #[allow(unused_mut)]
                let mut output = crate::error::service_failure_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_service_failure_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::TagPolicyError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::TagPolicyError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_tag_policy_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::TagPolicyOutput, crate::error::TagPolicyError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::tag_policy_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_tag_role_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::TagRoleOutput, crate::error::TagRoleError> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::TagRoleError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::TagRoleError::unhandled(generic)),
    };
    Err(match error_code {
        "ConcurrentModificationException" => crate::error::TagRoleError {
            meta: generic,
            kind: crate::error::TagRoleErrorKind::ConcurrentModificationError({
                #[allow(unused_mut)]
                let mut output = crate::error::concurrent_modification_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_concurrent_modification_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::TagRoleError::unhandled)?;
                output.build()
            }),
        },
        "InvalidInputException" => crate::error::TagRoleError {
            meta: generic,
            kind: crate::error::TagRoleErrorKind::InvalidInputError({
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_input_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_invalid_input_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::TagRoleError::unhandled)?;
                output.build()
            }),
        },
        "LimitExceededException" => crate::error::TagRoleError {
            meta: generic,
            kind: crate::error::TagRoleErrorKind::LimitExceededError({
                #[allow(unused_mut)]
                let mut output = crate::error::limit_exceeded_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_limit_exceeded_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::TagRoleError::unhandled)?;
                output.build()
            }),
        },
        "NoSuchEntityException" => crate::error::TagRoleError {
            meta: generic,
            kind: crate::error::TagRoleErrorKind::NoSuchEntityError({
                #[allow(unused_mut)]
                let mut output = crate::error::no_such_entity_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_no_such_entity_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::TagRoleError::unhandled)?;
                output.build()
            }),
        },
        "ServiceFailureException" => crate::error::TagRoleError {
            meta: generic,
            kind: crate::error::TagRoleErrorKind::ServiceFailureError({
                #[allow(unused_mut)]
                let mut output = crate::error::service_failure_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_service_failure_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::TagRoleError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::TagRoleError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_tag_role_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::TagRoleOutput, crate::error::TagRoleError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::tag_role_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_tag_saml_provider_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::TagSAMLProviderOutput, crate::error::TagSAMLProviderError> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::TagSAMLProviderError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::TagSAMLProviderError::unhandled(generic)),
    };
    Err(match error_code {
        "ConcurrentModificationException" => crate::error::TagSAMLProviderError {
            meta: generic,
            kind: crate::error::TagSAMLProviderErrorKind::ConcurrentModificationError({
                #[allow(unused_mut)]
                let mut output = crate::error::concurrent_modification_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_concurrent_modification_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::TagSAMLProviderError::unhandled)?;
                output.build()
            }),
        },
        "InvalidInputException" => crate::error::TagSAMLProviderError {
            meta: generic,
            kind: crate::error::TagSAMLProviderErrorKind::InvalidInputError({
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_input_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_invalid_input_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::TagSAMLProviderError::unhandled)?;
                output.build()
            }),
        },
        "LimitExceededException" => crate::error::TagSAMLProviderError {
            meta: generic,
            kind: crate::error::TagSAMLProviderErrorKind::LimitExceededError({
                #[allow(unused_mut)]
                let mut output = crate::error::limit_exceeded_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_limit_exceeded_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::TagSAMLProviderError::unhandled)?;
                output.build()
            }),
        },
        "NoSuchEntityException" => crate::error::TagSAMLProviderError {
            meta: generic,
            kind: crate::error::TagSAMLProviderErrorKind::NoSuchEntityError({
                #[allow(unused_mut)]
                let mut output = crate::error::no_such_entity_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_no_such_entity_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::TagSAMLProviderError::unhandled)?;
                output.build()
            }),
        },
        "ServiceFailureException" => crate::error::TagSAMLProviderError {
            meta: generic,
            kind: crate::error::TagSAMLProviderErrorKind::ServiceFailureError({
                #[allow(unused_mut)]
                let mut output = crate::error::service_failure_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_service_failure_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::TagSAMLProviderError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::TagSAMLProviderError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_tag_saml_provider_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::TagSAMLProviderOutput, crate::error::TagSAMLProviderError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::tag_saml_provider_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_tag_server_certificate_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::TagServerCertificateOutput, crate::error::TagServerCertificateError> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::TagServerCertificateError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::TagServerCertificateError::unhandled(generic)),
    };
    Err(match error_code {
        "ConcurrentModificationException" => crate::error::TagServerCertificateError {
            meta: generic,
            kind: crate::error::TagServerCertificateErrorKind::ConcurrentModificationError({
                #[allow(unused_mut)]
                let mut output = crate::error::concurrent_modification_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_concurrent_modification_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::TagServerCertificateError::unhandled)?;
                output.build()
            }),
        },
        "InvalidInputException" => crate::error::TagServerCertificateError {
            meta: generic,
            kind: crate::error::TagServerCertificateErrorKind::InvalidInputError({
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_input_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_invalid_input_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::TagServerCertificateError::unhandled)?;
                output.build()
            }),
        },
        "LimitExceededException" => crate::error::TagServerCertificateError {
            meta: generic,
            kind: crate::error::TagServerCertificateErrorKind::LimitExceededError({
                #[allow(unused_mut)]
                let mut output = crate::error::limit_exceeded_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_limit_exceeded_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::TagServerCertificateError::unhandled)?;
                output.build()
            }),
        },
        "NoSuchEntityException" => crate::error::TagServerCertificateError {
            meta: generic,
            kind: crate::error::TagServerCertificateErrorKind::NoSuchEntityError({
                #[allow(unused_mut)]
                let mut output = crate::error::no_such_entity_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_no_such_entity_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::TagServerCertificateError::unhandled)?;
                output.build()
            }),
        },
        "ServiceFailureException" => crate::error::TagServerCertificateError {
            meta: generic,
            kind: crate::error::TagServerCertificateErrorKind::ServiceFailureError({
                #[allow(unused_mut)]
                let mut output = crate::error::service_failure_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_service_failure_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::TagServerCertificateError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::TagServerCertificateError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_tag_server_certificate_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::TagServerCertificateOutput, crate::error::TagServerCertificateError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::tag_server_certificate_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_tag_user_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::TagUserOutput, crate::error::TagUserError> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::TagUserError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::TagUserError::unhandled(generic)),
    };
    Err(match error_code {
        "ConcurrentModificationException" => crate::error::TagUserError {
            meta: generic,
            kind: crate::error::TagUserErrorKind::ConcurrentModificationError({
                #[allow(unused_mut)]
                let mut output = crate::error::concurrent_modification_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_concurrent_modification_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::TagUserError::unhandled)?;
                output.build()
            }),
        },
        "InvalidInputException" => crate::error::TagUserError {
            meta: generic,
            kind: crate::error::TagUserErrorKind::InvalidInputError({
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_input_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_invalid_input_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::TagUserError::unhandled)?;
                output.build()
            }),
        },
        "LimitExceededException" => crate::error::TagUserError {
            meta: generic,
            kind: crate::error::TagUserErrorKind::LimitExceededError({
                #[allow(unused_mut)]
                let mut output = crate::error::limit_exceeded_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_limit_exceeded_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::TagUserError::unhandled)?;
                output.build()
            }),
        },
        "NoSuchEntityException" => crate::error::TagUserError {
            meta: generic,
            kind: crate::error::TagUserErrorKind::NoSuchEntityError({
                #[allow(unused_mut)]
                let mut output = crate::error::no_such_entity_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_no_such_entity_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::TagUserError::unhandled)?;
                output.build()
            }),
        },
        "ServiceFailureException" => crate::error::TagUserError {
            meta: generic,
            kind: crate::error::TagUserErrorKind::ServiceFailureError({
                #[allow(unused_mut)]
                let mut output = crate::error::service_failure_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_service_failure_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::TagUserError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::TagUserError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_tag_user_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::TagUserOutput, crate::error::TagUserError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::tag_user_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_untag_instance_profile_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::UntagInstanceProfileOutput, crate::error::UntagInstanceProfileError> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::UntagInstanceProfileError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::UntagInstanceProfileError::unhandled(generic)),
    };
    Err(match error_code {
        "ConcurrentModificationException" => crate::error::UntagInstanceProfileError {
            meta: generic,
            kind: crate::error::UntagInstanceProfileErrorKind::ConcurrentModificationError({
                #[allow(unused_mut)]
                let mut output = crate::error::concurrent_modification_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_concurrent_modification_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::UntagInstanceProfileError::unhandled)?;
                output.build()
            }),
        },
        "InvalidInputException" => crate::error::UntagInstanceProfileError {
            meta: generic,
            kind: crate::error::UntagInstanceProfileErrorKind::InvalidInputError({
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_input_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_invalid_input_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::UntagInstanceProfileError::unhandled)?;
                output.build()
            }),
        },
        "NoSuchEntityException" => crate::error::UntagInstanceProfileError {
            meta: generic,
            kind: crate::error::UntagInstanceProfileErrorKind::NoSuchEntityError({
                #[allow(unused_mut)]
                let mut output = crate::error::no_such_entity_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_no_such_entity_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::UntagInstanceProfileError::unhandled)?;
                output.build()
            }),
        },
        "ServiceFailureException" => crate::error::UntagInstanceProfileError {
            meta: generic,
            kind: crate::error::UntagInstanceProfileErrorKind::ServiceFailureError({
                #[allow(unused_mut)]
                let mut output = crate::error::service_failure_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_service_failure_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::UntagInstanceProfileError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::UntagInstanceProfileError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_untag_instance_profile_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::UntagInstanceProfileOutput, crate::error::UntagInstanceProfileError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::untag_instance_profile_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_untag_mfa_device_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::UntagMFADeviceOutput, crate::error::UntagMFADeviceError> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::UntagMFADeviceError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::UntagMFADeviceError::unhandled(generic)),
    };
    Err(match error_code {
        "ConcurrentModificationException" => crate::error::UntagMFADeviceError {
            meta: generic,
            kind: crate::error::UntagMFADeviceErrorKind::ConcurrentModificationError({
                #[allow(unused_mut)]
                let mut output = crate::error::concurrent_modification_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_concurrent_modification_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::UntagMFADeviceError::unhandled)?;
                output.build()
            }),
        },
        "InvalidInputException" => crate::error::UntagMFADeviceError {
            meta: generic,
            kind: crate::error::UntagMFADeviceErrorKind::InvalidInputError({
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_input_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_invalid_input_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::UntagMFADeviceError::unhandled)?;
                output.build()
            }),
        },
        "NoSuchEntityException" => crate::error::UntagMFADeviceError {
            meta: generic,
            kind: crate::error::UntagMFADeviceErrorKind::NoSuchEntityError({
                #[allow(unused_mut)]
                let mut output = crate::error::no_such_entity_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_no_such_entity_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::UntagMFADeviceError::unhandled)?;
                output.build()
            }),
        },
        "ServiceFailureException" => crate::error::UntagMFADeviceError {
            meta: generic,
            kind: crate::error::UntagMFADeviceErrorKind::ServiceFailureError({
                #[allow(unused_mut)]
                let mut output = crate::error::service_failure_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_service_failure_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::UntagMFADeviceError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::UntagMFADeviceError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_untag_mfa_device_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::UntagMFADeviceOutput, crate::error::UntagMFADeviceError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::untag_mfa_device_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_untag_open_id_connect_provider_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<
    crate::output::UntagOpenIDConnectProviderOutput,
    crate::error::UntagOpenIDConnectProviderError,
> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::UntagOpenIDConnectProviderError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::UntagOpenIDConnectProviderError::unhandled(
                generic,
            ))
        }
    };
    Err(match error_code {
        "ConcurrentModificationException" => crate::error::UntagOpenIDConnectProviderError {
            meta: generic,
            kind: crate::error::UntagOpenIDConnectProviderErrorKind::ConcurrentModificationError({
                #[allow(unused_mut)]
                let mut output = crate::error::concurrent_modification_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_concurrent_modification_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::UntagOpenIDConnectProviderError::unhandled)?;
                output.build()
            }),
        },
        "InvalidInputException" => crate::error::UntagOpenIDConnectProviderError {
            meta: generic,
            kind: crate::error::UntagOpenIDConnectProviderErrorKind::InvalidInputError({
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_input_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_invalid_input_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::UntagOpenIDConnectProviderError::unhandled)?;
                output.build()
            }),
        },
        "NoSuchEntityException" => crate::error::UntagOpenIDConnectProviderError {
            meta: generic,
            kind: crate::error::UntagOpenIDConnectProviderErrorKind::NoSuchEntityError({
                #[allow(unused_mut)]
                let mut output = crate::error::no_such_entity_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_no_such_entity_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::UntagOpenIDConnectProviderError::unhandled)?;
                output.build()
            }),
        },
        "ServiceFailureException" => crate::error::UntagOpenIDConnectProviderError {
            meta: generic,
            kind: crate::error::UntagOpenIDConnectProviderErrorKind::ServiceFailureError({
                #[allow(unused_mut)]
                let mut output = crate::error::service_failure_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_service_failure_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::UntagOpenIDConnectProviderError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::UntagOpenIDConnectProviderError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_untag_open_id_connect_provider_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<
    crate::output::UntagOpenIDConnectProviderOutput,
    crate::error::UntagOpenIDConnectProviderError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::untag_open_id_connect_provider_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_untag_policy_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::UntagPolicyOutput, crate::error::UntagPolicyError> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::UntagPolicyError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::UntagPolicyError::unhandled(generic)),
    };
    Err(match error_code {
        "ConcurrentModificationException" => crate::error::UntagPolicyError {
            meta: generic,
            kind: crate::error::UntagPolicyErrorKind::ConcurrentModificationError({
                #[allow(unused_mut)]
                let mut output = crate::error::concurrent_modification_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_concurrent_modification_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::UntagPolicyError::unhandled)?;
                output.build()
            }),
        },
        "InvalidInputException" => crate::error::UntagPolicyError {
            meta: generic,
            kind: crate::error::UntagPolicyErrorKind::InvalidInputError({
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_input_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_invalid_input_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::UntagPolicyError::unhandled)?;
                output.build()
            }),
        },
        "NoSuchEntityException" => crate::error::UntagPolicyError {
            meta: generic,
            kind: crate::error::UntagPolicyErrorKind::NoSuchEntityError({
                #[allow(unused_mut)]
                let mut output = crate::error::no_such_entity_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_no_such_entity_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::UntagPolicyError::unhandled)?;
                output.build()
            }),
        },
        "ServiceFailureException" => crate::error::UntagPolicyError {
            meta: generic,
            kind: crate::error::UntagPolicyErrorKind::ServiceFailureError({
                #[allow(unused_mut)]
                let mut output = crate::error::service_failure_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_service_failure_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::UntagPolicyError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::UntagPolicyError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_untag_policy_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::UntagPolicyOutput, crate::error::UntagPolicyError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::untag_policy_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_untag_role_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::UntagRoleOutput, crate::error::UntagRoleError> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::UntagRoleError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::UntagRoleError::unhandled(generic)),
    };
    Err(match error_code {
        "ConcurrentModificationException" => crate::error::UntagRoleError {
            meta: generic,
            kind: crate::error::UntagRoleErrorKind::ConcurrentModificationError({
                #[allow(unused_mut)]
                let mut output = crate::error::concurrent_modification_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_concurrent_modification_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::UntagRoleError::unhandled)?;
                output.build()
            }),
        },
        "NoSuchEntityException" => crate::error::UntagRoleError {
            meta: generic,
            kind: crate::error::UntagRoleErrorKind::NoSuchEntityError({
                #[allow(unused_mut)]
                let mut output = crate::error::no_such_entity_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_no_such_entity_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::UntagRoleError::unhandled)?;
                output.build()
            }),
        },
        "ServiceFailureException" => crate::error::UntagRoleError {
            meta: generic,
            kind: crate::error::UntagRoleErrorKind::ServiceFailureError({
                #[allow(unused_mut)]
                let mut output = crate::error::service_failure_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_service_failure_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::UntagRoleError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::UntagRoleError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_untag_role_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::UntagRoleOutput, crate::error::UntagRoleError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::untag_role_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_untag_saml_provider_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::UntagSAMLProviderOutput, crate::error::UntagSAMLProviderError> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::UntagSAMLProviderError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::UntagSAMLProviderError::unhandled(generic)),
    };
    Err(match error_code {
        "ConcurrentModificationException" => crate::error::UntagSAMLProviderError {
            meta: generic,
            kind: crate::error::UntagSAMLProviderErrorKind::ConcurrentModificationError({
                #[allow(unused_mut)]
                let mut output = crate::error::concurrent_modification_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_concurrent_modification_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::UntagSAMLProviderError::unhandled)?;
                output.build()
            }),
        },
        "InvalidInputException" => crate::error::UntagSAMLProviderError {
            meta: generic,
            kind: crate::error::UntagSAMLProviderErrorKind::InvalidInputError({
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_input_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_invalid_input_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::UntagSAMLProviderError::unhandled)?;
                output.build()
            }),
        },
        "NoSuchEntityException" => crate::error::UntagSAMLProviderError {
            meta: generic,
            kind: crate::error::UntagSAMLProviderErrorKind::NoSuchEntityError({
                #[allow(unused_mut)]
                let mut output = crate::error::no_such_entity_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_no_such_entity_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::UntagSAMLProviderError::unhandled)?;
                output.build()
            }),
        },
        "ServiceFailureException" => crate::error::UntagSAMLProviderError {
            meta: generic,
            kind: crate::error::UntagSAMLProviderErrorKind::ServiceFailureError({
                #[allow(unused_mut)]
                let mut output = crate::error::service_failure_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_service_failure_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::UntagSAMLProviderError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::UntagSAMLProviderError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_untag_saml_provider_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::UntagSAMLProviderOutput, crate::error::UntagSAMLProviderError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::untag_saml_provider_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_untag_server_certificate_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::UntagServerCertificateOutput, crate::error::UntagServerCertificateError>
{
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::UntagServerCertificateError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::UntagServerCertificateError::unhandled(
                generic,
            ))
        }
    };
    Err(match error_code {
        "ConcurrentModificationException" => crate::error::UntagServerCertificateError {
            meta: generic,
            kind: crate::error::UntagServerCertificateErrorKind::ConcurrentModificationError({
                #[allow(unused_mut)]
                let mut output = crate::error::concurrent_modification_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_concurrent_modification_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::UntagServerCertificateError::unhandled)?;
                output.build()
            }),
        },
        "InvalidInputException" => crate::error::UntagServerCertificateError {
            meta: generic,
            kind: crate::error::UntagServerCertificateErrorKind::InvalidInputError({
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_input_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_invalid_input_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::UntagServerCertificateError::unhandled)?;
                output.build()
            }),
        },
        "NoSuchEntityException" => crate::error::UntagServerCertificateError {
            meta: generic,
            kind: crate::error::UntagServerCertificateErrorKind::NoSuchEntityError({
                #[allow(unused_mut)]
                let mut output = crate::error::no_such_entity_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_no_such_entity_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::UntagServerCertificateError::unhandled)?;
                output.build()
            }),
        },
        "ServiceFailureException" => crate::error::UntagServerCertificateError {
            meta: generic,
            kind: crate::error::UntagServerCertificateErrorKind::ServiceFailureError({
                #[allow(unused_mut)]
                let mut output = crate::error::service_failure_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_service_failure_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::UntagServerCertificateError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::UntagServerCertificateError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_untag_server_certificate_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::UntagServerCertificateOutput, crate::error::UntagServerCertificateError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::untag_server_certificate_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_untag_user_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::UntagUserOutput, crate::error::UntagUserError> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::UntagUserError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::UntagUserError::unhandled(generic)),
    };
    Err(match error_code {
        "ConcurrentModificationException" => crate::error::UntagUserError {
            meta: generic,
            kind: crate::error::UntagUserErrorKind::ConcurrentModificationError({
                #[allow(unused_mut)]
                let mut output = crate::error::concurrent_modification_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_concurrent_modification_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::UntagUserError::unhandled)?;
                output.build()
            }),
        },
        "NoSuchEntityException" => crate::error::UntagUserError {
            meta: generic,
            kind: crate::error::UntagUserErrorKind::NoSuchEntityError({
                #[allow(unused_mut)]
                let mut output = crate::error::no_such_entity_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_no_such_entity_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::UntagUserError::unhandled)?;
                output.build()
            }),
        },
        "ServiceFailureException" => crate::error::UntagUserError {
            meta: generic,
            kind: crate::error::UntagUserErrorKind::ServiceFailureError({
                #[allow(unused_mut)]
                let mut output = crate::error::service_failure_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_service_failure_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::UntagUserError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::UntagUserError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_untag_user_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::UntagUserOutput, crate::error::UntagUserError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::untag_user_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_access_key_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::UpdateAccessKeyOutput, crate::error::UpdateAccessKeyError> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::UpdateAccessKeyError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::UpdateAccessKeyError::unhandled(generic)),
    };
    Err(match error_code {
        "LimitExceededException" => crate::error::UpdateAccessKeyError {
            meta: generic,
            kind: crate::error::UpdateAccessKeyErrorKind::LimitExceededError({
                #[allow(unused_mut)]
                let mut output = crate::error::limit_exceeded_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_limit_exceeded_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::UpdateAccessKeyError::unhandled)?;
                output.build()
            }),
        },
        "NoSuchEntityException" => crate::error::UpdateAccessKeyError {
            meta: generic,
            kind: crate::error::UpdateAccessKeyErrorKind::NoSuchEntityError({
                #[allow(unused_mut)]
                let mut output = crate::error::no_such_entity_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_no_such_entity_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::UpdateAccessKeyError::unhandled)?;
                output.build()
            }),
        },
        "ServiceFailureException" => crate::error::UpdateAccessKeyError {
            meta: generic,
            kind: crate::error::UpdateAccessKeyErrorKind::ServiceFailureError({
                #[allow(unused_mut)]
                let mut output = crate::error::service_failure_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_service_failure_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::UpdateAccessKeyError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::UpdateAccessKeyError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_access_key_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::UpdateAccessKeyOutput, crate::error::UpdateAccessKeyError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::update_access_key_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_account_password_policy_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<
    crate::output::UpdateAccountPasswordPolicyOutput,
    crate::error::UpdateAccountPasswordPolicyError,
> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::UpdateAccountPasswordPolicyError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::UpdateAccountPasswordPolicyError::unhandled(
                generic,
            ))
        }
    };
    Err(match error_code {
        "LimitExceededException" => crate::error::UpdateAccountPasswordPolicyError {
            meta: generic,
            kind: crate::error::UpdateAccountPasswordPolicyErrorKind::LimitExceededError({
                #[allow(unused_mut)]
                let mut output = crate::error::limit_exceeded_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_limit_exceeded_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::UpdateAccountPasswordPolicyError::unhandled)?;
                output.build()
            }),
        },
        "MalformedPolicyDocumentException" => {
            crate::error::UpdateAccountPasswordPolicyError {
                meta: generic,
                kind:
                    crate::error::UpdateAccountPasswordPolicyErrorKind::MalformedPolicyDocumentError(
                        {
                            #[allow(unused_mut)]
                            let mut output =
                                crate::error::malformed_policy_document_error::Builder::default();
                            let _ = response;
                            output = crate::xml_deser::deser_structure_malformed_policy_document_error_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateAccountPasswordPolicyError::unhandled)?;
                            output.build()
                        },
                    ),
            }
        }
        "NoSuchEntityException" => crate::error::UpdateAccountPasswordPolicyError {
            meta: generic,
            kind: crate::error::UpdateAccountPasswordPolicyErrorKind::NoSuchEntityError({
                #[allow(unused_mut)]
                let mut output = crate::error::no_such_entity_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_no_such_entity_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::UpdateAccountPasswordPolicyError::unhandled)?;
                output.build()
            }),
        },
        "ServiceFailureException" => crate::error::UpdateAccountPasswordPolicyError {
            meta: generic,
            kind: crate::error::UpdateAccountPasswordPolicyErrorKind::ServiceFailureError({
                #[allow(unused_mut)]
                let mut output = crate::error::service_failure_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_service_failure_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::UpdateAccountPasswordPolicyError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::UpdateAccountPasswordPolicyError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_account_password_policy_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<
    crate::output::UpdateAccountPasswordPolicyOutput,
    crate::error::UpdateAccountPasswordPolicyError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::update_account_password_policy_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_assume_role_policy_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::UpdateAssumeRolePolicyOutput, crate::error::UpdateAssumeRolePolicyError>
{
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::UpdateAssumeRolePolicyError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::UpdateAssumeRolePolicyError::unhandled(
                generic,
            ))
        }
    };
    Err(match error_code {
        "LimitExceededException" => crate::error::UpdateAssumeRolePolicyError {
            meta: generic,
            kind: crate::error::UpdateAssumeRolePolicyErrorKind::LimitExceededError({
                #[allow(unused_mut)]
                let mut output = crate::error::limit_exceeded_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_limit_exceeded_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::UpdateAssumeRolePolicyError::unhandled)?;
                output.build()
            }),
        },
        "MalformedPolicyDocumentException" => crate::error::UpdateAssumeRolePolicyError {
            meta: generic,
            kind: crate::error::UpdateAssumeRolePolicyErrorKind::MalformedPolicyDocumentError({
                #[allow(unused_mut)]
                let mut output = crate::error::malformed_policy_document_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_malformed_policy_document_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::UpdateAssumeRolePolicyError::unhandled)?;
                output.build()
            }),
        },
        "NoSuchEntityException" => crate::error::UpdateAssumeRolePolicyError {
            meta: generic,
            kind: crate::error::UpdateAssumeRolePolicyErrorKind::NoSuchEntityError({
                #[allow(unused_mut)]
                let mut output = crate::error::no_such_entity_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_no_such_entity_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::UpdateAssumeRolePolicyError::unhandled)?;
                output.build()
            }),
        },
        "ServiceFailureException" => crate::error::UpdateAssumeRolePolicyError {
            meta: generic,
            kind: crate::error::UpdateAssumeRolePolicyErrorKind::ServiceFailureError({
                #[allow(unused_mut)]
                let mut output = crate::error::service_failure_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_service_failure_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::UpdateAssumeRolePolicyError::unhandled)?;
                output.build()
            }),
        },
        "UnmodifiableEntityException" => crate::error::UpdateAssumeRolePolicyError {
            meta: generic,
            kind: crate::error::UpdateAssumeRolePolicyErrorKind::UnmodifiableEntityError({
                #[allow(unused_mut)]
                let mut output = crate::error::unmodifiable_entity_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_unmodifiable_entity_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::UpdateAssumeRolePolicyError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::UpdateAssumeRolePolicyError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_assume_role_policy_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::UpdateAssumeRolePolicyOutput, crate::error::UpdateAssumeRolePolicyError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::update_assume_role_policy_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_group_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::UpdateGroupOutput, crate::error::UpdateGroupError> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::UpdateGroupError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::UpdateGroupError::unhandled(generic)),
    };
    Err(match error_code {
        "EntityAlreadyExistsException" => crate::error::UpdateGroupError {
            meta: generic,
            kind: crate::error::UpdateGroupErrorKind::EntityAlreadyExistsError({
                #[allow(unused_mut)]
                let mut output = crate::error::entity_already_exists_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_entity_already_exists_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::UpdateGroupError::unhandled)?;
                output.build()
            }),
        },
        "LimitExceededException" => crate::error::UpdateGroupError {
            meta: generic,
            kind: crate::error::UpdateGroupErrorKind::LimitExceededError({
                #[allow(unused_mut)]
                let mut output = crate::error::limit_exceeded_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_limit_exceeded_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::UpdateGroupError::unhandled)?;
                output.build()
            }),
        },
        "NoSuchEntityException" => crate::error::UpdateGroupError {
            meta: generic,
            kind: crate::error::UpdateGroupErrorKind::NoSuchEntityError({
                #[allow(unused_mut)]
                let mut output = crate::error::no_such_entity_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_no_such_entity_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::UpdateGroupError::unhandled)?;
                output.build()
            }),
        },
        "ServiceFailureException" => crate::error::UpdateGroupError {
            meta: generic,
            kind: crate::error::UpdateGroupErrorKind::ServiceFailureError({
                #[allow(unused_mut)]
                let mut output = crate::error::service_failure_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_service_failure_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::UpdateGroupError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::UpdateGroupError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_group_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::UpdateGroupOutput, crate::error::UpdateGroupError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::update_group_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_login_profile_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::UpdateLoginProfileOutput, crate::error::UpdateLoginProfileError> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::UpdateLoginProfileError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::UpdateLoginProfileError::unhandled(generic)),
    };
    Err(match error_code {
        "EntityTemporarilyUnmodifiableException" => crate::error::UpdateLoginProfileError {
            meta: generic,
            kind: crate::error::UpdateLoginProfileErrorKind::EntityTemporarilyUnmodifiableError({
                #[allow(unused_mut)]
                let mut output =
                    crate::error::entity_temporarily_unmodifiable_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_entity_temporarily_unmodifiable_error_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateLoginProfileError::unhandled)?;
                output.build()
            }),
        },
        "LimitExceededException" => crate::error::UpdateLoginProfileError {
            meta: generic,
            kind: crate::error::UpdateLoginProfileErrorKind::LimitExceededError({
                #[allow(unused_mut)]
                let mut output = crate::error::limit_exceeded_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_limit_exceeded_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::UpdateLoginProfileError::unhandled)?;
                output.build()
            }),
        },
        "NoSuchEntityException" => crate::error::UpdateLoginProfileError {
            meta: generic,
            kind: crate::error::UpdateLoginProfileErrorKind::NoSuchEntityError({
                #[allow(unused_mut)]
                let mut output = crate::error::no_such_entity_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_no_such_entity_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::UpdateLoginProfileError::unhandled)?;
                output.build()
            }),
        },
        "PasswordPolicyViolationException" => crate::error::UpdateLoginProfileError {
            meta: generic,
            kind: crate::error::UpdateLoginProfileErrorKind::PasswordPolicyViolationError({
                #[allow(unused_mut)]
                let mut output = crate::error::password_policy_violation_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_password_policy_violation_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::UpdateLoginProfileError::unhandled)?;
                output.build()
            }),
        },
        "ServiceFailureException" => crate::error::UpdateLoginProfileError {
            meta: generic,
            kind: crate::error::UpdateLoginProfileErrorKind::ServiceFailureError({
                #[allow(unused_mut)]
                let mut output = crate::error::service_failure_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_service_failure_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::UpdateLoginProfileError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::UpdateLoginProfileError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_login_profile_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::UpdateLoginProfileOutput, crate::error::UpdateLoginProfileError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::update_login_profile_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_open_id_connect_provider_thumbprint_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<
    crate::output::UpdateOpenIDConnectProviderThumbprintOutput,
    crate::error::UpdateOpenIDConnectProviderThumbprintError,
> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::UpdateOpenIDConnectProviderThumbprintError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(
                crate::error::UpdateOpenIDConnectProviderThumbprintError::unhandled(generic),
            )
        }
    };
    Err(match error_code {
        "InvalidInputException" => crate::error::UpdateOpenIDConnectProviderThumbprintError {
            meta: generic,
            kind: crate::error::UpdateOpenIDConnectProviderThumbprintErrorKind::InvalidInputError(
                {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_input_error::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_invalid_input_error_xml_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::UpdateOpenIDConnectProviderThumbprintError::unhandled)?;
                    output.build()
                },
            ),
        },
        "NoSuchEntityException" => {
            crate::error::UpdateOpenIDConnectProviderThumbprintError {
                meta: generic,
                kind:
                    crate::error::UpdateOpenIDConnectProviderThumbprintErrorKind::NoSuchEntityError(
                        {
                            #[allow(unused_mut)]
                            let mut output = crate::error::no_such_entity_error::Builder::default();
                            let _ = response;
                            output = crate::xml_deser::deser_structure_no_such_entity_error_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateOpenIDConnectProviderThumbprintError::unhandled)?;
                            output.build()
                        },
                    ),
            }
        }
        "ServiceFailureException" => crate::error::UpdateOpenIDConnectProviderThumbprintError {
            meta: generic,
            kind: crate::error::UpdateOpenIDConnectProviderThumbprintErrorKind::ServiceFailureError(
                {
                    #[allow(unused_mut)]
                    let mut output = crate::error::service_failure_error::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_service_failure_error_xml_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::UpdateOpenIDConnectProviderThumbprintError::unhandled)?;
                    output.build()
                },
            ),
        },
        _ => crate::error::UpdateOpenIDConnectProviderThumbprintError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_open_id_connect_provider_thumbprint_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<
    crate::output::UpdateOpenIDConnectProviderThumbprintOutput,
    crate::error::UpdateOpenIDConnectProviderThumbprintError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::update_open_id_connect_provider_thumbprint_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_role_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::UpdateRoleOutput, crate::error::UpdateRoleError> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::UpdateRoleError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::UpdateRoleError::unhandled(generic)),
    };
    Err(match error_code {
        "NoSuchEntityException" => crate::error::UpdateRoleError {
            meta: generic,
            kind: crate::error::UpdateRoleErrorKind::NoSuchEntityError({
                #[allow(unused_mut)]
                let mut output = crate::error::no_such_entity_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_no_such_entity_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::UpdateRoleError::unhandled)?;
                output.build()
            }),
        },
        "ServiceFailureException" => crate::error::UpdateRoleError {
            meta: generic,
            kind: crate::error::UpdateRoleErrorKind::ServiceFailureError({
                #[allow(unused_mut)]
                let mut output = crate::error::service_failure_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_service_failure_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::UpdateRoleError::unhandled)?;
                output.build()
            }),
        },
        "UnmodifiableEntityException" => crate::error::UpdateRoleError {
            meta: generic,
            kind: crate::error::UpdateRoleErrorKind::UnmodifiableEntityError({
                #[allow(unused_mut)]
                let mut output = crate::error::unmodifiable_entity_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_unmodifiable_entity_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::UpdateRoleError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::UpdateRoleError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_role_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::UpdateRoleOutput, crate::error::UpdateRoleError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::update_role_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_role_description_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::UpdateRoleDescriptionOutput, crate::error::UpdateRoleDescriptionError> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::UpdateRoleDescriptionError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::UpdateRoleDescriptionError::unhandled(generic)),
    };
    Err(match error_code {
        "NoSuchEntityException" => crate::error::UpdateRoleDescriptionError {
            meta: generic,
            kind: crate::error::UpdateRoleDescriptionErrorKind::NoSuchEntityError({
                #[allow(unused_mut)]
                let mut output = crate::error::no_such_entity_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_no_such_entity_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::UpdateRoleDescriptionError::unhandled)?;
                output.build()
            }),
        },
        "ServiceFailureException" => crate::error::UpdateRoleDescriptionError {
            meta: generic,
            kind: crate::error::UpdateRoleDescriptionErrorKind::ServiceFailureError({
                #[allow(unused_mut)]
                let mut output = crate::error::service_failure_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_service_failure_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::UpdateRoleDescriptionError::unhandled)?;
                output.build()
            }),
        },
        "UnmodifiableEntityException" => crate::error::UpdateRoleDescriptionError {
            meta: generic,
            kind: crate::error::UpdateRoleDescriptionErrorKind::UnmodifiableEntityError({
                #[allow(unused_mut)]
                let mut output = crate::error::unmodifiable_entity_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_unmodifiable_entity_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::UpdateRoleDescriptionError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::UpdateRoleDescriptionError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_role_description_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::UpdateRoleDescriptionOutput, crate::error::UpdateRoleDescriptionError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::update_role_description_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_update_role_description(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::UpdateRoleDescriptionError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_saml_provider_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::UpdateSAMLProviderOutput, crate::error::UpdateSAMLProviderError> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::UpdateSAMLProviderError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::UpdateSAMLProviderError::unhandled(generic)),
    };
    Err(match error_code {
        "InvalidInputException" => crate::error::UpdateSAMLProviderError {
            meta: generic,
            kind: crate::error::UpdateSAMLProviderErrorKind::InvalidInputError({
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_input_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_invalid_input_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::UpdateSAMLProviderError::unhandled)?;
                output.build()
            }),
        },
        "LimitExceededException" => crate::error::UpdateSAMLProviderError {
            meta: generic,
            kind: crate::error::UpdateSAMLProviderErrorKind::LimitExceededError({
                #[allow(unused_mut)]
                let mut output = crate::error::limit_exceeded_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_limit_exceeded_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::UpdateSAMLProviderError::unhandled)?;
                output.build()
            }),
        },
        "NoSuchEntityException" => crate::error::UpdateSAMLProviderError {
            meta: generic,
            kind: crate::error::UpdateSAMLProviderErrorKind::NoSuchEntityError({
                #[allow(unused_mut)]
                let mut output = crate::error::no_such_entity_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_no_such_entity_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::UpdateSAMLProviderError::unhandled)?;
                output.build()
            }),
        },
        "ServiceFailureException" => crate::error::UpdateSAMLProviderError {
            meta: generic,
            kind: crate::error::UpdateSAMLProviderErrorKind::ServiceFailureError({
                #[allow(unused_mut)]
                let mut output = crate::error::service_failure_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_service_failure_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::UpdateSAMLProviderError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::UpdateSAMLProviderError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_saml_provider_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::UpdateSAMLProviderOutput, crate::error::UpdateSAMLProviderError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::update_saml_provider_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_update_saml_provider(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::UpdateSAMLProviderError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_server_certificate_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::UpdateServerCertificateOutput, crate::error::UpdateServerCertificateError>
{
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::UpdateServerCertificateError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::UpdateServerCertificateError::unhandled(
                generic,
            ))
        }
    };
    Err(match error_code {
        "EntityAlreadyExistsException" => crate::error::UpdateServerCertificateError {
            meta: generic,
            kind: crate::error::UpdateServerCertificateErrorKind::EntityAlreadyExistsError({
                #[allow(unused_mut)]
                let mut output = crate::error::entity_already_exists_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_entity_already_exists_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::UpdateServerCertificateError::unhandled)?;
                output.build()
            }),
        },
        "LimitExceededException" => crate::error::UpdateServerCertificateError {
            meta: generic,
            kind: crate::error::UpdateServerCertificateErrorKind::LimitExceededError({
                #[allow(unused_mut)]
                let mut output = crate::error::limit_exceeded_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_limit_exceeded_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::UpdateServerCertificateError::unhandled)?;
                output.build()
            }),
        },
        "NoSuchEntityException" => crate::error::UpdateServerCertificateError {
            meta: generic,
            kind: crate::error::UpdateServerCertificateErrorKind::NoSuchEntityError({
                #[allow(unused_mut)]
                let mut output = crate::error::no_such_entity_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_no_such_entity_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::UpdateServerCertificateError::unhandled)?;
                output.build()
            }),
        },
        "ServiceFailureException" => crate::error::UpdateServerCertificateError {
            meta: generic,
            kind: crate::error::UpdateServerCertificateErrorKind::ServiceFailureError({
                #[allow(unused_mut)]
                let mut output = crate::error::service_failure_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_service_failure_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::UpdateServerCertificateError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::UpdateServerCertificateError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_server_certificate_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::UpdateServerCertificateOutput, crate::error::UpdateServerCertificateError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::update_server_certificate_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_service_specific_credential_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<
    crate::output::UpdateServiceSpecificCredentialOutput,
    crate::error::UpdateServiceSpecificCredentialError,
> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::UpdateServiceSpecificCredentialError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::UpdateServiceSpecificCredentialError::unhandled(generic)),
    };
    Err(match error_code {
        "NoSuchEntityException" => crate::error::UpdateServiceSpecificCredentialError {
            meta: generic,
            kind: crate::error::UpdateServiceSpecificCredentialErrorKind::NoSuchEntityError({
                #[allow(unused_mut)]
                let mut output = crate::error::no_such_entity_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_no_such_entity_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::UpdateServiceSpecificCredentialError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::UpdateServiceSpecificCredentialError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_service_specific_credential_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<
    crate::output::UpdateServiceSpecificCredentialOutput,
    crate::error::UpdateServiceSpecificCredentialError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::update_service_specific_credential_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_signing_certificate_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<
    crate::output::UpdateSigningCertificateOutput,
    crate::error::UpdateSigningCertificateError,
> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::UpdateSigningCertificateError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::UpdateSigningCertificateError::unhandled(
                generic,
            ))
        }
    };
    Err(match error_code {
        "LimitExceededException" => crate::error::UpdateSigningCertificateError {
            meta: generic,
            kind: crate::error::UpdateSigningCertificateErrorKind::LimitExceededError({
                #[allow(unused_mut)]
                let mut output = crate::error::limit_exceeded_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_limit_exceeded_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::UpdateSigningCertificateError::unhandled)?;
                output.build()
            }),
        },
        "NoSuchEntityException" => crate::error::UpdateSigningCertificateError {
            meta: generic,
            kind: crate::error::UpdateSigningCertificateErrorKind::NoSuchEntityError({
                #[allow(unused_mut)]
                let mut output = crate::error::no_such_entity_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_no_such_entity_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::UpdateSigningCertificateError::unhandled)?;
                output.build()
            }),
        },
        "ServiceFailureException" => crate::error::UpdateSigningCertificateError {
            meta: generic,
            kind: crate::error::UpdateSigningCertificateErrorKind::ServiceFailureError({
                #[allow(unused_mut)]
                let mut output = crate::error::service_failure_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_service_failure_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::UpdateSigningCertificateError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::UpdateSigningCertificateError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_signing_certificate_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<
    crate::output::UpdateSigningCertificateOutput,
    crate::error::UpdateSigningCertificateError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::update_signing_certificate_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_ssh_public_key_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::UpdateSSHPublicKeyOutput, crate::error::UpdateSSHPublicKeyError> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::UpdateSSHPublicKeyError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::UpdateSSHPublicKeyError::unhandled(generic)),
    };
    Err(match error_code {
        "NoSuchEntityException" => crate::error::UpdateSSHPublicKeyError {
            meta: generic,
            kind: crate::error::UpdateSSHPublicKeyErrorKind::NoSuchEntityError({
                #[allow(unused_mut)]
                let mut output = crate::error::no_such_entity_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_no_such_entity_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::UpdateSSHPublicKeyError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::UpdateSSHPublicKeyError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_ssh_public_key_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::UpdateSSHPublicKeyOutput, crate::error::UpdateSSHPublicKeyError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::update_ssh_public_key_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_user_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::UpdateUserOutput, crate::error::UpdateUserError> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::UpdateUserError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::UpdateUserError::unhandled(generic)),
    };
    Err(match error_code {
        "ConcurrentModificationException" => crate::error::UpdateUserError {
            meta: generic,
            kind: crate::error::UpdateUserErrorKind::ConcurrentModificationError({
                #[allow(unused_mut)]
                let mut output = crate::error::concurrent_modification_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_concurrent_modification_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::UpdateUserError::unhandled)?;
                output.build()
            }),
        },
        "EntityAlreadyExistsException" => crate::error::UpdateUserError {
            meta: generic,
            kind: crate::error::UpdateUserErrorKind::EntityAlreadyExistsError({
                #[allow(unused_mut)]
                let mut output = crate::error::entity_already_exists_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_entity_already_exists_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::UpdateUserError::unhandled)?;
                output.build()
            }),
        },
        "EntityTemporarilyUnmodifiableException" => crate::error::UpdateUserError {
            meta: generic,
            kind: crate::error::UpdateUserErrorKind::EntityTemporarilyUnmodifiableError({
                #[allow(unused_mut)]
                let mut output =
                    crate::error::entity_temporarily_unmodifiable_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_entity_temporarily_unmodifiable_error_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateUserError::unhandled)?;
                output.build()
            }),
        },
        "LimitExceededException" => crate::error::UpdateUserError {
            meta: generic,
            kind: crate::error::UpdateUserErrorKind::LimitExceededError({
                #[allow(unused_mut)]
                let mut output = crate::error::limit_exceeded_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_limit_exceeded_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::UpdateUserError::unhandled)?;
                output.build()
            }),
        },
        "NoSuchEntityException" => crate::error::UpdateUserError {
            meta: generic,
            kind: crate::error::UpdateUserErrorKind::NoSuchEntityError({
                #[allow(unused_mut)]
                let mut output = crate::error::no_such_entity_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_no_such_entity_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::UpdateUserError::unhandled)?;
                output.build()
            }),
        },
        "ServiceFailureException" => crate::error::UpdateUserError {
            meta: generic,
            kind: crate::error::UpdateUserErrorKind::ServiceFailureError({
                #[allow(unused_mut)]
                let mut output = crate::error::service_failure_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_service_failure_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::UpdateUserError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::UpdateUserError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_user_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::UpdateUserOutput, crate::error::UpdateUserError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::update_user_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_upload_server_certificate_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::UploadServerCertificateOutput, crate::error::UploadServerCertificateError>
{
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::UploadServerCertificateError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::UploadServerCertificateError::unhandled(
                generic,
            ))
        }
    };
    Err(match error_code {
        "ConcurrentModificationException" => crate::error::UploadServerCertificateError {
            meta: generic,
            kind: crate::error::UploadServerCertificateErrorKind::ConcurrentModificationError({
                #[allow(unused_mut)]
                let mut output = crate::error::concurrent_modification_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_concurrent_modification_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::UploadServerCertificateError::unhandled)?;
                output.build()
            }),
        },
        "EntityAlreadyExistsException" => crate::error::UploadServerCertificateError {
            meta: generic,
            kind: crate::error::UploadServerCertificateErrorKind::EntityAlreadyExistsError({
                #[allow(unused_mut)]
                let mut output = crate::error::entity_already_exists_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_entity_already_exists_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::UploadServerCertificateError::unhandled)?;
                output.build()
            }),
        },
        "InvalidInputException" => crate::error::UploadServerCertificateError {
            meta: generic,
            kind: crate::error::UploadServerCertificateErrorKind::InvalidInputError({
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_input_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_invalid_input_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::UploadServerCertificateError::unhandled)?;
                output.build()
            }),
        },
        "KeyPairMismatchException" => crate::error::UploadServerCertificateError {
            meta: generic,
            kind: crate::error::UploadServerCertificateErrorKind::KeyPairMismatchError({
                #[allow(unused_mut)]
                let mut output = crate::error::key_pair_mismatch_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_key_pair_mismatch_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::UploadServerCertificateError::unhandled)?;
                output.build()
            }),
        },
        "LimitExceededException" => crate::error::UploadServerCertificateError {
            meta: generic,
            kind: crate::error::UploadServerCertificateErrorKind::LimitExceededError({
                #[allow(unused_mut)]
                let mut output = crate::error::limit_exceeded_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_limit_exceeded_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::UploadServerCertificateError::unhandled)?;
                output.build()
            }),
        },
        "MalformedCertificateException" => crate::error::UploadServerCertificateError {
            meta: generic,
            kind: crate::error::UploadServerCertificateErrorKind::MalformedCertificateError({
                #[allow(unused_mut)]
                let mut output = crate::error::malformed_certificate_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_malformed_certificate_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::UploadServerCertificateError::unhandled)?;
                output.build()
            }),
        },
        "ServiceFailureException" => crate::error::UploadServerCertificateError {
            meta: generic,
            kind: crate::error::UploadServerCertificateErrorKind::ServiceFailureError({
                #[allow(unused_mut)]
                let mut output = crate::error::service_failure_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_service_failure_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::UploadServerCertificateError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::UploadServerCertificateError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_upload_server_certificate_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::UploadServerCertificateOutput, crate::error::UploadServerCertificateError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::upload_server_certificate_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_upload_server_certificate(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::UploadServerCertificateError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_upload_signing_certificate_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<
    crate::output::UploadSigningCertificateOutput,
    crate::error::UploadSigningCertificateError,
> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::UploadSigningCertificateError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::UploadSigningCertificateError::unhandled(
                generic,
            ))
        }
    };
    Err(match error_code {
        "DuplicateCertificateException" => crate::error::UploadSigningCertificateError {
            meta: generic,
            kind: crate::error::UploadSigningCertificateErrorKind::DuplicateCertificateError({
                #[allow(unused_mut)]
                let mut output = crate::error::duplicate_certificate_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_duplicate_certificate_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::UploadSigningCertificateError::unhandled)?;
                output.build()
            }),
        },
        "EntityAlreadyExistsException" => crate::error::UploadSigningCertificateError {
            meta: generic,
            kind: crate::error::UploadSigningCertificateErrorKind::EntityAlreadyExistsError({
                #[allow(unused_mut)]
                let mut output = crate::error::entity_already_exists_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_entity_already_exists_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::UploadSigningCertificateError::unhandled)?;
                output.build()
            }),
        },
        "InvalidCertificateException" => crate::error::UploadSigningCertificateError {
            meta: generic,
            kind: crate::error::UploadSigningCertificateErrorKind::InvalidCertificateError({
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_certificate_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_invalid_certificate_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::UploadSigningCertificateError::unhandled)?;
                output.build()
            }),
        },
        "LimitExceededException" => crate::error::UploadSigningCertificateError {
            meta: generic,
            kind: crate::error::UploadSigningCertificateErrorKind::LimitExceededError({
                #[allow(unused_mut)]
                let mut output = crate::error::limit_exceeded_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_limit_exceeded_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::UploadSigningCertificateError::unhandled)?;
                output.build()
            }),
        },
        "MalformedCertificateException" => crate::error::UploadSigningCertificateError {
            meta: generic,
            kind: crate::error::UploadSigningCertificateErrorKind::MalformedCertificateError({
                #[allow(unused_mut)]
                let mut output = crate::error::malformed_certificate_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_malformed_certificate_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::UploadSigningCertificateError::unhandled)?;
                output.build()
            }),
        },
        "NoSuchEntityException" => crate::error::UploadSigningCertificateError {
            meta: generic,
            kind: crate::error::UploadSigningCertificateErrorKind::NoSuchEntityError({
                #[allow(unused_mut)]
                let mut output = crate::error::no_such_entity_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_no_such_entity_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::UploadSigningCertificateError::unhandled)?;
                output.build()
            }),
        },
        "ServiceFailureException" => crate::error::UploadSigningCertificateError {
            meta: generic,
            kind: crate::error::UploadSigningCertificateErrorKind::ServiceFailureError({
                #[allow(unused_mut)]
                let mut output = crate::error::service_failure_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_service_failure_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::UploadSigningCertificateError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::UploadSigningCertificateError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_upload_signing_certificate_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<
    crate::output::UploadSigningCertificateOutput,
    crate::error::UploadSigningCertificateError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::upload_signing_certificate_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_upload_signing_certificate(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::UploadSigningCertificateError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_upload_ssh_public_key_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::UploadSSHPublicKeyOutput, crate::error::UploadSSHPublicKeyError> {
    let generic = crate::xml_deser::parse_generic_error(&response)
        .map_err(crate::error::UploadSSHPublicKeyError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::UploadSSHPublicKeyError::unhandled(generic)),
    };
    Err(match error_code {
        "DuplicateSSHPublicKeyException" => crate::error::UploadSSHPublicKeyError {
            meta: generic,
            kind: crate::error::UploadSSHPublicKeyErrorKind::DuplicateSSHPublicKeyError({
                #[allow(unused_mut)]
                let mut output = crate::error::duplicate_ssh_public_key_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_duplicate_ssh_public_key_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::UploadSSHPublicKeyError::unhandled)?;
                output.build()
            }),
        },
        "InvalidPublicKeyException" => crate::error::UploadSSHPublicKeyError {
            meta: generic,
            kind: crate::error::UploadSSHPublicKeyErrorKind::InvalidPublicKeyError({
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_public_key_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_invalid_public_key_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::UploadSSHPublicKeyError::unhandled)?;
                output.build()
            }),
        },
        "LimitExceededException" => crate::error::UploadSSHPublicKeyError {
            meta: generic,
            kind: crate::error::UploadSSHPublicKeyErrorKind::LimitExceededError({
                #[allow(unused_mut)]
                let mut output = crate::error::limit_exceeded_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_limit_exceeded_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::UploadSSHPublicKeyError::unhandled)?;
                output.build()
            }),
        },
        "NoSuchEntityException" => crate::error::UploadSSHPublicKeyError {
            meta: generic,
            kind: crate::error::UploadSSHPublicKeyErrorKind::NoSuchEntityError({
                #[allow(unused_mut)]
                let mut output = crate::error::no_such_entity_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_no_such_entity_error_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::UploadSSHPublicKeyError::unhandled)?;
                output.build()
            }),
        },
        "UnrecognizedPublicKeyEncodingException" => crate::error::UploadSSHPublicKeyError {
            meta: generic,
            kind: crate::error::UploadSSHPublicKeyErrorKind::UnrecognizedPublicKeyEncodingError({
                #[allow(unused_mut)]
                let mut output =
                    crate::error::unrecognized_public_key_encoding_error::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_unrecognized_public_key_encoding_error_xml_err(response.body().as_ref(), output).map_err(crate::error::UploadSSHPublicKeyError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::UploadSSHPublicKeyError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_upload_ssh_public_key_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::UploadSSHPublicKeyOutput, crate::error::UploadSSHPublicKeyError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::upload_ssh_public_key_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_upload_ssh_public_key(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::UploadSSHPublicKeyError::unhandled)?;
        output.build()
    })
}
