// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[derive(std::fmt::Debug)]
pub(crate) struct Handle {
    client: aws_hyper::Client<aws_hyper::conn::Standard>,
    conf: crate::Config,
}

#[derive(Clone, std::fmt::Debug)]
pub struct Client {
    handle: std::sync::Arc<Handle>,
}
impl Client {
    #[cfg(any(feature = "rustls", feature = "native-tls"))]
    pub fn from_env() -> Self {
        Self::from_conf_conn(
            crate::Config::builder().build(),
            aws_hyper::conn::Standard::https(),
        )
    }

    #[cfg(any(feature = "rustls", feature = "native-tls"))]
    pub fn from_conf(conf: crate::Config) -> Self {
        Self::from_conf_conn(conf, aws_hyper::conn::Standard::https())
    }

    pub fn from_conf_conn(conf: crate::Config, conn: aws_hyper::conn::Standard) -> Self {
        let client = aws_hyper::Client::new(conn);
        Self {
            handle: std::sync::Arc::new(Handle { client, conf }),
        }
    }

    pub fn conf(&self) -> &crate::Config {
        &self.handle.conf
    }
    pub fn add_client_id_to_open_id_connect_provider(
        &self,
    ) -> fluent_builders::AddClientIDToOpenIDConnectProvider {
        fluent_builders::AddClientIDToOpenIDConnectProvider::new(self.handle.clone())
    }
    pub fn add_role_to_instance_profile(&self) -> fluent_builders::AddRoleToInstanceProfile {
        fluent_builders::AddRoleToInstanceProfile::new(self.handle.clone())
    }
    pub fn add_user_to_group(&self) -> fluent_builders::AddUserToGroup {
        fluent_builders::AddUserToGroup::new(self.handle.clone())
    }
    pub fn attach_group_policy(&self) -> fluent_builders::AttachGroupPolicy {
        fluent_builders::AttachGroupPolicy::new(self.handle.clone())
    }
    pub fn attach_role_policy(&self) -> fluent_builders::AttachRolePolicy {
        fluent_builders::AttachRolePolicy::new(self.handle.clone())
    }
    pub fn attach_user_policy(&self) -> fluent_builders::AttachUserPolicy {
        fluent_builders::AttachUserPolicy::new(self.handle.clone())
    }
    pub fn change_password(&self) -> fluent_builders::ChangePassword {
        fluent_builders::ChangePassword::new(self.handle.clone())
    }
    pub fn create_access_key(&self) -> fluent_builders::CreateAccessKey {
        fluent_builders::CreateAccessKey::new(self.handle.clone())
    }
    pub fn create_account_alias(&self) -> fluent_builders::CreateAccountAlias {
        fluent_builders::CreateAccountAlias::new(self.handle.clone())
    }
    pub fn create_group(&self) -> fluent_builders::CreateGroup {
        fluent_builders::CreateGroup::new(self.handle.clone())
    }
    pub fn create_instance_profile(&self) -> fluent_builders::CreateInstanceProfile {
        fluent_builders::CreateInstanceProfile::new(self.handle.clone())
    }
    pub fn create_login_profile(&self) -> fluent_builders::CreateLoginProfile {
        fluent_builders::CreateLoginProfile::new(self.handle.clone())
    }
    pub fn create_open_id_connect_provider(&self) -> fluent_builders::CreateOpenIDConnectProvider {
        fluent_builders::CreateOpenIDConnectProvider::new(self.handle.clone())
    }
    pub fn create_policy(&self) -> fluent_builders::CreatePolicy {
        fluent_builders::CreatePolicy::new(self.handle.clone())
    }
    pub fn create_policy_version(&self) -> fluent_builders::CreatePolicyVersion {
        fluent_builders::CreatePolicyVersion::new(self.handle.clone())
    }
    pub fn create_role(&self) -> fluent_builders::CreateRole {
        fluent_builders::CreateRole::new(self.handle.clone())
    }
    pub fn create_saml_provider(&self) -> fluent_builders::CreateSAMLProvider {
        fluent_builders::CreateSAMLProvider::new(self.handle.clone())
    }
    pub fn create_service_linked_role(&self) -> fluent_builders::CreateServiceLinkedRole {
        fluent_builders::CreateServiceLinkedRole::new(self.handle.clone())
    }
    pub fn create_service_specific_credential(
        &self,
    ) -> fluent_builders::CreateServiceSpecificCredential {
        fluent_builders::CreateServiceSpecificCredential::new(self.handle.clone())
    }
    pub fn create_user(&self) -> fluent_builders::CreateUser {
        fluent_builders::CreateUser::new(self.handle.clone())
    }
    pub fn create_virtual_mfa_device(&self) -> fluent_builders::CreateVirtualMFADevice {
        fluent_builders::CreateVirtualMFADevice::new(self.handle.clone())
    }
    pub fn deactivate_mfa_device(&self) -> fluent_builders::DeactivateMFADevice {
        fluent_builders::DeactivateMFADevice::new(self.handle.clone())
    }
    pub fn delete_access_key(&self) -> fluent_builders::DeleteAccessKey {
        fluent_builders::DeleteAccessKey::new(self.handle.clone())
    }
    pub fn delete_account_alias(&self) -> fluent_builders::DeleteAccountAlias {
        fluent_builders::DeleteAccountAlias::new(self.handle.clone())
    }
    pub fn delete_account_password_policy(&self) -> fluent_builders::DeleteAccountPasswordPolicy {
        fluent_builders::DeleteAccountPasswordPolicy::new(self.handle.clone())
    }
    pub fn delete_group(&self) -> fluent_builders::DeleteGroup {
        fluent_builders::DeleteGroup::new(self.handle.clone())
    }
    pub fn delete_group_policy(&self) -> fluent_builders::DeleteGroupPolicy {
        fluent_builders::DeleteGroupPolicy::new(self.handle.clone())
    }
    pub fn delete_instance_profile(&self) -> fluent_builders::DeleteInstanceProfile {
        fluent_builders::DeleteInstanceProfile::new(self.handle.clone())
    }
    pub fn delete_login_profile(&self) -> fluent_builders::DeleteLoginProfile {
        fluent_builders::DeleteLoginProfile::new(self.handle.clone())
    }
    pub fn delete_open_id_connect_provider(&self) -> fluent_builders::DeleteOpenIDConnectProvider {
        fluent_builders::DeleteOpenIDConnectProvider::new(self.handle.clone())
    }
    pub fn delete_policy(&self) -> fluent_builders::DeletePolicy {
        fluent_builders::DeletePolicy::new(self.handle.clone())
    }
    pub fn delete_policy_version(&self) -> fluent_builders::DeletePolicyVersion {
        fluent_builders::DeletePolicyVersion::new(self.handle.clone())
    }
    pub fn delete_role(&self) -> fluent_builders::DeleteRole {
        fluent_builders::DeleteRole::new(self.handle.clone())
    }
    pub fn delete_role_permissions_boundary(
        &self,
    ) -> fluent_builders::DeleteRolePermissionsBoundary {
        fluent_builders::DeleteRolePermissionsBoundary::new(self.handle.clone())
    }
    pub fn delete_role_policy(&self) -> fluent_builders::DeleteRolePolicy {
        fluent_builders::DeleteRolePolicy::new(self.handle.clone())
    }
    pub fn delete_saml_provider(&self) -> fluent_builders::DeleteSAMLProvider {
        fluent_builders::DeleteSAMLProvider::new(self.handle.clone())
    }
    pub fn delete_server_certificate(&self) -> fluent_builders::DeleteServerCertificate {
        fluent_builders::DeleteServerCertificate::new(self.handle.clone())
    }
    pub fn delete_service_linked_role(&self) -> fluent_builders::DeleteServiceLinkedRole {
        fluent_builders::DeleteServiceLinkedRole::new(self.handle.clone())
    }
    pub fn delete_service_specific_credential(
        &self,
    ) -> fluent_builders::DeleteServiceSpecificCredential {
        fluent_builders::DeleteServiceSpecificCredential::new(self.handle.clone())
    }
    pub fn delete_signing_certificate(&self) -> fluent_builders::DeleteSigningCertificate {
        fluent_builders::DeleteSigningCertificate::new(self.handle.clone())
    }
    pub fn delete_ssh_public_key(&self) -> fluent_builders::DeleteSSHPublicKey {
        fluent_builders::DeleteSSHPublicKey::new(self.handle.clone())
    }
    pub fn delete_user(&self) -> fluent_builders::DeleteUser {
        fluent_builders::DeleteUser::new(self.handle.clone())
    }
    pub fn delete_user_permissions_boundary(
        &self,
    ) -> fluent_builders::DeleteUserPermissionsBoundary {
        fluent_builders::DeleteUserPermissionsBoundary::new(self.handle.clone())
    }
    pub fn delete_user_policy(&self) -> fluent_builders::DeleteUserPolicy {
        fluent_builders::DeleteUserPolicy::new(self.handle.clone())
    }
    pub fn delete_virtual_mfa_device(&self) -> fluent_builders::DeleteVirtualMFADevice {
        fluent_builders::DeleteVirtualMFADevice::new(self.handle.clone())
    }
    pub fn detach_group_policy(&self) -> fluent_builders::DetachGroupPolicy {
        fluent_builders::DetachGroupPolicy::new(self.handle.clone())
    }
    pub fn detach_role_policy(&self) -> fluent_builders::DetachRolePolicy {
        fluent_builders::DetachRolePolicy::new(self.handle.clone())
    }
    pub fn detach_user_policy(&self) -> fluent_builders::DetachUserPolicy {
        fluent_builders::DetachUserPolicy::new(self.handle.clone())
    }
    pub fn enable_mfa_device(&self) -> fluent_builders::EnableMFADevice {
        fluent_builders::EnableMFADevice::new(self.handle.clone())
    }
    pub fn generate_credential_report(&self) -> fluent_builders::GenerateCredentialReport {
        fluent_builders::GenerateCredentialReport::new(self.handle.clone())
    }
    pub fn generate_organizations_access_report(
        &self,
    ) -> fluent_builders::GenerateOrganizationsAccessReport {
        fluent_builders::GenerateOrganizationsAccessReport::new(self.handle.clone())
    }
    pub fn generate_service_last_accessed_details(
        &self,
    ) -> fluent_builders::GenerateServiceLastAccessedDetails {
        fluent_builders::GenerateServiceLastAccessedDetails::new(self.handle.clone())
    }
    pub fn get_access_key_last_used(&self) -> fluent_builders::GetAccessKeyLastUsed {
        fluent_builders::GetAccessKeyLastUsed::new(self.handle.clone())
    }
    pub fn get_account_authorization_details(
        &self,
    ) -> fluent_builders::GetAccountAuthorizationDetails {
        fluent_builders::GetAccountAuthorizationDetails::new(self.handle.clone())
    }
    pub fn get_account_password_policy(&self) -> fluent_builders::GetAccountPasswordPolicy {
        fluent_builders::GetAccountPasswordPolicy::new(self.handle.clone())
    }
    pub fn get_account_summary(&self) -> fluent_builders::GetAccountSummary {
        fluent_builders::GetAccountSummary::new(self.handle.clone())
    }
    pub fn get_context_keys_for_custom_policy(
        &self,
    ) -> fluent_builders::GetContextKeysForCustomPolicy {
        fluent_builders::GetContextKeysForCustomPolicy::new(self.handle.clone())
    }
    pub fn get_context_keys_for_principal_policy(
        &self,
    ) -> fluent_builders::GetContextKeysForPrincipalPolicy {
        fluent_builders::GetContextKeysForPrincipalPolicy::new(self.handle.clone())
    }
    pub fn get_credential_report(&self) -> fluent_builders::GetCredentialReport {
        fluent_builders::GetCredentialReport::new(self.handle.clone())
    }
    pub fn get_group(&self) -> fluent_builders::GetGroup {
        fluent_builders::GetGroup::new(self.handle.clone())
    }
    pub fn get_group_policy(&self) -> fluent_builders::GetGroupPolicy {
        fluent_builders::GetGroupPolicy::new(self.handle.clone())
    }
    pub fn get_instance_profile(&self) -> fluent_builders::GetInstanceProfile {
        fluent_builders::GetInstanceProfile::new(self.handle.clone())
    }
    pub fn get_login_profile(&self) -> fluent_builders::GetLoginProfile {
        fluent_builders::GetLoginProfile::new(self.handle.clone())
    }
    pub fn get_open_id_connect_provider(&self) -> fluent_builders::GetOpenIDConnectProvider {
        fluent_builders::GetOpenIDConnectProvider::new(self.handle.clone())
    }
    pub fn get_organizations_access_report(&self) -> fluent_builders::GetOrganizationsAccessReport {
        fluent_builders::GetOrganizationsAccessReport::new(self.handle.clone())
    }
    pub fn get_policy(&self) -> fluent_builders::GetPolicy {
        fluent_builders::GetPolicy::new(self.handle.clone())
    }
    pub fn get_policy_version(&self) -> fluent_builders::GetPolicyVersion {
        fluent_builders::GetPolicyVersion::new(self.handle.clone())
    }
    pub fn get_role(&self) -> fluent_builders::GetRole {
        fluent_builders::GetRole::new(self.handle.clone())
    }
    pub fn get_role_policy(&self) -> fluent_builders::GetRolePolicy {
        fluent_builders::GetRolePolicy::new(self.handle.clone())
    }
    pub fn get_saml_provider(&self) -> fluent_builders::GetSAMLProvider {
        fluent_builders::GetSAMLProvider::new(self.handle.clone())
    }
    pub fn get_server_certificate(&self) -> fluent_builders::GetServerCertificate {
        fluent_builders::GetServerCertificate::new(self.handle.clone())
    }
    pub fn get_service_last_accessed_details(
        &self,
    ) -> fluent_builders::GetServiceLastAccessedDetails {
        fluent_builders::GetServiceLastAccessedDetails::new(self.handle.clone())
    }
    pub fn get_service_last_accessed_details_with_entities(
        &self,
    ) -> fluent_builders::GetServiceLastAccessedDetailsWithEntities {
        fluent_builders::GetServiceLastAccessedDetailsWithEntities::new(self.handle.clone())
    }
    pub fn get_service_linked_role_deletion_status(
        &self,
    ) -> fluent_builders::GetServiceLinkedRoleDeletionStatus {
        fluent_builders::GetServiceLinkedRoleDeletionStatus::new(self.handle.clone())
    }
    pub fn get_ssh_public_key(&self) -> fluent_builders::GetSSHPublicKey {
        fluent_builders::GetSSHPublicKey::new(self.handle.clone())
    }
    pub fn get_user(&self) -> fluent_builders::GetUser {
        fluent_builders::GetUser::new(self.handle.clone())
    }
    pub fn get_user_policy(&self) -> fluent_builders::GetUserPolicy {
        fluent_builders::GetUserPolicy::new(self.handle.clone())
    }
    pub fn list_access_keys(&self) -> fluent_builders::ListAccessKeys {
        fluent_builders::ListAccessKeys::new(self.handle.clone())
    }
    pub fn list_account_aliases(&self) -> fluent_builders::ListAccountAliases {
        fluent_builders::ListAccountAliases::new(self.handle.clone())
    }
    pub fn list_attached_group_policies(&self) -> fluent_builders::ListAttachedGroupPolicies {
        fluent_builders::ListAttachedGroupPolicies::new(self.handle.clone())
    }
    pub fn list_attached_role_policies(&self) -> fluent_builders::ListAttachedRolePolicies {
        fluent_builders::ListAttachedRolePolicies::new(self.handle.clone())
    }
    pub fn list_attached_user_policies(&self) -> fluent_builders::ListAttachedUserPolicies {
        fluent_builders::ListAttachedUserPolicies::new(self.handle.clone())
    }
    pub fn list_entities_for_policy(&self) -> fluent_builders::ListEntitiesForPolicy {
        fluent_builders::ListEntitiesForPolicy::new(self.handle.clone())
    }
    pub fn list_group_policies(&self) -> fluent_builders::ListGroupPolicies {
        fluent_builders::ListGroupPolicies::new(self.handle.clone())
    }
    pub fn list_groups(&self) -> fluent_builders::ListGroups {
        fluent_builders::ListGroups::new(self.handle.clone())
    }
    pub fn list_groups_for_user(&self) -> fluent_builders::ListGroupsForUser {
        fluent_builders::ListGroupsForUser::new(self.handle.clone())
    }
    pub fn list_instance_profiles(&self) -> fluent_builders::ListInstanceProfiles {
        fluent_builders::ListInstanceProfiles::new(self.handle.clone())
    }
    pub fn list_instance_profiles_for_role(&self) -> fluent_builders::ListInstanceProfilesForRole {
        fluent_builders::ListInstanceProfilesForRole::new(self.handle.clone())
    }
    pub fn list_instance_profile_tags(&self) -> fluent_builders::ListInstanceProfileTags {
        fluent_builders::ListInstanceProfileTags::new(self.handle.clone())
    }
    pub fn list_mfa_devices(&self) -> fluent_builders::ListMFADevices {
        fluent_builders::ListMFADevices::new(self.handle.clone())
    }
    pub fn list_mfa_device_tags(&self) -> fluent_builders::ListMFADeviceTags {
        fluent_builders::ListMFADeviceTags::new(self.handle.clone())
    }
    pub fn list_open_id_connect_providers(&self) -> fluent_builders::ListOpenIDConnectProviders {
        fluent_builders::ListOpenIDConnectProviders::new(self.handle.clone())
    }
    pub fn list_open_id_connect_provider_tags(
        &self,
    ) -> fluent_builders::ListOpenIDConnectProviderTags {
        fluent_builders::ListOpenIDConnectProviderTags::new(self.handle.clone())
    }
    pub fn list_policies(&self) -> fluent_builders::ListPolicies {
        fluent_builders::ListPolicies::new(self.handle.clone())
    }
    pub fn list_policies_granting_service_access(
        &self,
    ) -> fluent_builders::ListPoliciesGrantingServiceAccess {
        fluent_builders::ListPoliciesGrantingServiceAccess::new(self.handle.clone())
    }
    pub fn list_policy_tags(&self) -> fluent_builders::ListPolicyTags {
        fluent_builders::ListPolicyTags::new(self.handle.clone())
    }
    pub fn list_policy_versions(&self) -> fluent_builders::ListPolicyVersions {
        fluent_builders::ListPolicyVersions::new(self.handle.clone())
    }
    pub fn list_role_policies(&self) -> fluent_builders::ListRolePolicies {
        fluent_builders::ListRolePolicies::new(self.handle.clone())
    }
    pub fn list_roles(&self) -> fluent_builders::ListRoles {
        fluent_builders::ListRoles::new(self.handle.clone())
    }
    pub fn list_role_tags(&self) -> fluent_builders::ListRoleTags {
        fluent_builders::ListRoleTags::new(self.handle.clone())
    }
    pub fn list_saml_providers(&self) -> fluent_builders::ListSAMLProviders {
        fluent_builders::ListSAMLProviders::new(self.handle.clone())
    }
    pub fn list_saml_provider_tags(&self) -> fluent_builders::ListSAMLProviderTags {
        fluent_builders::ListSAMLProviderTags::new(self.handle.clone())
    }
    pub fn list_server_certificates(&self) -> fluent_builders::ListServerCertificates {
        fluent_builders::ListServerCertificates::new(self.handle.clone())
    }
    pub fn list_server_certificate_tags(&self) -> fluent_builders::ListServerCertificateTags {
        fluent_builders::ListServerCertificateTags::new(self.handle.clone())
    }
    pub fn list_service_specific_credentials(
        &self,
    ) -> fluent_builders::ListServiceSpecificCredentials {
        fluent_builders::ListServiceSpecificCredentials::new(self.handle.clone())
    }
    pub fn list_signing_certificates(&self) -> fluent_builders::ListSigningCertificates {
        fluent_builders::ListSigningCertificates::new(self.handle.clone())
    }
    pub fn list_ssh_public_keys(&self) -> fluent_builders::ListSSHPublicKeys {
        fluent_builders::ListSSHPublicKeys::new(self.handle.clone())
    }
    pub fn list_user_policies(&self) -> fluent_builders::ListUserPolicies {
        fluent_builders::ListUserPolicies::new(self.handle.clone())
    }
    pub fn list_users(&self) -> fluent_builders::ListUsers {
        fluent_builders::ListUsers::new(self.handle.clone())
    }
    pub fn list_user_tags(&self) -> fluent_builders::ListUserTags {
        fluent_builders::ListUserTags::new(self.handle.clone())
    }
    pub fn list_virtual_mfa_devices(&self) -> fluent_builders::ListVirtualMFADevices {
        fluent_builders::ListVirtualMFADevices::new(self.handle.clone())
    }
    pub fn put_group_policy(&self) -> fluent_builders::PutGroupPolicy {
        fluent_builders::PutGroupPolicy::new(self.handle.clone())
    }
    pub fn put_role_permissions_boundary(&self) -> fluent_builders::PutRolePermissionsBoundary {
        fluent_builders::PutRolePermissionsBoundary::new(self.handle.clone())
    }
    pub fn put_role_policy(&self) -> fluent_builders::PutRolePolicy {
        fluent_builders::PutRolePolicy::new(self.handle.clone())
    }
    pub fn put_user_permissions_boundary(&self) -> fluent_builders::PutUserPermissionsBoundary {
        fluent_builders::PutUserPermissionsBoundary::new(self.handle.clone())
    }
    pub fn put_user_policy(&self) -> fluent_builders::PutUserPolicy {
        fluent_builders::PutUserPolicy::new(self.handle.clone())
    }
    pub fn remove_client_id_from_open_id_connect_provider(
        &self,
    ) -> fluent_builders::RemoveClientIDFromOpenIDConnectProvider {
        fluent_builders::RemoveClientIDFromOpenIDConnectProvider::new(self.handle.clone())
    }
    pub fn remove_role_from_instance_profile(
        &self,
    ) -> fluent_builders::RemoveRoleFromInstanceProfile {
        fluent_builders::RemoveRoleFromInstanceProfile::new(self.handle.clone())
    }
    pub fn remove_user_from_group(&self) -> fluent_builders::RemoveUserFromGroup {
        fluent_builders::RemoveUserFromGroup::new(self.handle.clone())
    }
    pub fn reset_service_specific_credential(
        &self,
    ) -> fluent_builders::ResetServiceSpecificCredential {
        fluent_builders::ResetServiceSpecificCredential::new(self.handle.clone())
    }
    pub fn resync_mfa_device(&self) -> fluent_builders::ResyncMFADevice {
        fluent_builders::ResyncMFADevice::new(self.handle.clone())
    }
    pub fn set_default_policy_version(&self) -> fluent_builders::SetDefaultPolicyVersion {
        fluent_builders::SetDefaultPolicyVersion::new(self.handle.clone())
    }
    pub fn set_security_token_service_preferences(
        &self,
    ) -> fluent_builders::SetSecurityTokenServicePreferences {
        fluent_builders::SetSecurityTokenServicePreferences::new(self.handle.clone())
    }
    pub fn simulate_custom_policy(&self) -> fluent_builders::SimulateCustomPolicy {
        fluent_builders::SimulateCustomPolicy::new(self.handle.clone())
    }
    pub fn simulate_principal_policy(&self) -> fluent_builders::SimulatePrincipalPolicy {
        fluent_builders::SimulatePrincipalPolicy::new(self.handle.clone())
    }
    pub fn tag_instance_profile(&self) -> fluent_builders::TagInstanceProfile {
        fluent_builders::TagInstanceProfile::new(self.handle.clone())
    }
    pub fn tag_mfa_device(&self) -> fluent_builders::TagMFADevice {
        fluent_builders::TagMFADevice::new(self.handle.clone())
    }
    pub fn tag_open_id_connect_provider(&self) -> fluent_builders::TagOpenIDConnectProvider {
        fluent_builders::TagOpenIDConnectProvider::new(self.handle.clone())
    }
    pub fn tag_policy(&self) -> fluent_builders::TagPolicy {
        fluent_builders::TagPolicy::new(self.handle.clone())
    }
    pub fn tag_role(&self) -> fluent_builders::TagRole {
        fluent_builders::TagRole::new(self.handle.clone())
    }
    pub fn tag_saml_provider(&self) -> fluent_builders::TagSAMLProvider {
        fluent_builders::TagSAMLProvider::new(self.handle.clone())
    }
    pub fn tag_server_certificate(&self) -> fluent_builders::TagServerCertificate {
        fluent_builders::TagServerCertificate::new(self.handle.clone())
    }
    pub fn tag_user(&self) -> fluent_builders::TagUser {
        fluent_builders::TagUser::new(self.handle.clone())
    }
    pub fn untag_instance_profile(&self) -> fluent_builders::UntagInstanceProfile {
        fluent_builders::UntagInstanceProfile::new(self.handle.clone())
    }
    pub fn untag_mfa_device(&self) -> fluent_builders::UntagMFADevice {
        fluent_builders::UntagMFADevice::new(self.handle.clone())
    }
    pub fn untag_open_id_connect_provider(&self) -> fluent_builders::UntagOpenIDConnectProvider {
        fluent_builders::UntagOpenIDConnectProvider::new(self.handle.clone())
    }
    pub fn untag_policy(&self) -> fluent_builders::UntagPolicy {
        fluent_builders::UntagPolicy::new(self.handle.clone())
    }
    pub fn untag_role(&self) -> fluent_builders::UntagRole {
        fluent_builders::UntagRole::new(self.handle.clone())
    }
    pub fn untag_saml_provider(&self) -> fluent_builders::UntagSAMLProvider {
        fluent_builders::UntagSAMLProvider::new(self.handle.clone())
    }
    pub fn untag_server_certificate(&self) -> fluent_builders::UntagServerCertificate {
        fluent_builders::UntagServerCertificate::new(self.handle.clone())
    }
    pub fn untag_user(&self) -> fluent_builders::UntagUser {
        fluent_builders::UntagUser::new(self.handle.clone())
    }
    pub fn update_access_key(&self) -> fluent_builders::UpdateAccessKey {
        fluent_builders::UpdateAccessKey::new(self.handle.clone())
    }
    pub fn update_account_password_policy(&self) -> fluent_builders::UpdateAccountPasswordPolicy {
        fluent_builders::UpdateAccountPasswordPolicy::new(self.handle.clone())
    }
    pub fn update_assume_role_policy(&self) -> fluent_builders::UpdateAssumeRolePolicy {
        fluent_builders::UpdateAssumeRolePolicy::new(self.handle.clone())
    }
    pub fn update_group(&self) -> fluent_builders::UpdateGroup {
        fluent_builders::UpdateGroup::new(self.handle.clone())
    }
    pub fn update_login_profile(&self) -> fluent_builders::UpdateLoginProfile {
        fluent_builders::UpdateLoginProfile::new(self.handle.clone())
    }
    pub fn update_open_id_connect_provider_thumbprint(
        &self,
    ) -> fluent_builders::UpdateOpenIDConnectProviderThumbprint {
        fluent_builders::UpdateOpenIDConnectProviderThumbprint::new(self.handle.clone())
    }
    pub fn update_role(&self) -> fluent_builders::UpdateRole {
        fluent_builders::UpdateRole::new(self.handle.clone())
    }
    pub fn update_role_description(&self) -> fluent_builders::UpdateRoleDescription {
        fluent_builders::UpdateRoleDescription::new(self.handle.clone())
    }
    pub fn update_saml_provider(&self) -> fluent_builders::UpdateSAMLProvider {
        fluent_builders::UpdateSAMLProvider::new(self.handle.clone())
    }
    pub fn update_server_certificate(&self) -> fluent_builders::UpdateServerCertificate {
        fluent_builders::UpdateServerCertificate::new(self.handle.clone())
    }
    pub fn update_service_specific_credential(
        &self,
    ) -> fluent_builders::UpdateServiceSpecificCredential {
        fluent_builders::UpdateServiceSpecificCredential::new(self.handle.clone())
    }
    pub fn update_signing_certificate(&self) -> fluent_builders::UpdateSigningCertificate {
        fluent_builders::UpdateSigningCertificate::new(self.handle.clone())
    }
    pub fn update_ssh_public_key(&self) -> fluent_builders::UpdateSSHPublicKey {
        fluent_builders::UpdateSSHPublicKey::new(self.handle.clone())
    }
    pub fn update_user(&self) -> fluent_builders::UpdateUser {
        fluent_builders::UpdateUser::new(self.handle.clone())
    }
    pub fn upload_server_certificate(&self) -> fluent_builders::UploadServerCertificate {
        fluent_builders::UploadServerCertificate::new(self.handle.clone())
    }
    pub fn upload_signing_certificate(&self) -> fluent_builders::UploadSigningCertificate {
        fluent_builders::UploadSigningCertificate::new(self.handle.clone())
    }
    pub fn upload_ssh_public_key(&self) -> fluent_builders::UploadSSHPublicKey {
        fluent_builders::UploadSSHPublicKey::new(self.handle.clone())
    }
}
pub mod fluent_builders {
    #[derive(std::fmt::Debug)]
    pub struct AddClientIDToOpenIDConnectProvider {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::add_client_id_to_open_id_connect_provider_input::Builder,
    }
    impl AddClientIDToOpenIDConnectProvider {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::AddClientIDToOpenIDConnectProviderOutput,
            smithy_http::result::SdkError<crate::error::AddClientIDToOpenIDConnectProviderError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the IAM OpenID Connect (OIDC) provider resource to
        /// add the client ID to. You can get a list of OIDC provider ARNs by using the <a>ListOpenIDConnectProviders</a> operation.</p>
        pub fn open_id_connect_provider_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.open_id_connect_provider_arn(inp);
            self
        }
        pub fn set_open_id_connect_provider_arn(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_open_id_connect_provider_arn(inp);
            self
        }
        /// <p>The client ID (also known as audience) to add to the IAM OpenID Connect provider
        /// resource.</p>
        pub fn client_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.client_id(inp);
            self
        }
        pub fn set_client_id(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_client_id(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct AddRoleToInstanceProfile {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::add_role_to_instance_profile_input::Builder,
    }
    impl AddRoleToInstanceProfile {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::AddRoleToInstanceProfileOutput,
            smithy_http::result::SdkError<crate::error::AddRoleToInstanceProfileError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the instance profile to update.</p>
        /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
        /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
        pub fn instance_profile_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.instance_profile_name(inp);
            self
        }
        pub fn set_instance_profile_name(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_instance_profile_name(inp);
            self
        }
        /// <p>The name of the role to add.</p>
        /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
        /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
        pub fn role_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.role_name(inp);
            self
        }
        pub fn set_role_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_role_name(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct AddUserToGroup {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::add_user_to_group_input::Builder,
    }
    impl AddUserToGroup {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::AddUserToGroupOutput,
            smithy_http::result::SdkError<crate::error::AddUserToGroupError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the group to update.</p>
        /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
        /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
        pub fn group_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.group_name(inp);
            self
        }
        pub fn set_group_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_group_name(inp);
            self
        }
        /// <p>The name of the user to add.</p>
        /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
        /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
        pub fn user_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.user_name(inp);
            self
        }
        pub fn set_user_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_user_name(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct AttachGroupPolicy {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::attach_group_policy_input::Builder,
    }
    impl AttachGroupPolicy {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::AttachGroupPolicyOutput,
            smithy_http::result::SdkError<crate::error::AttachGroupPolicyError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name (friendly name, not ARN) of the group to attach the policy to.</p>
        /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
        /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
        pub fn group_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.group_name(inp);
            self
        }
        pub fn set_group_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_group_name(inp);
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the IAM policy you want to attach.</p>
        /// <p>For more information about ARNs, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">Amazon Resource Names (ARNs)</a> in the <i>AWS General Reference</i>.</p>
        pub fn policy_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.policy_arn(inp);
            self
        }
        pub fn set_policy_arn(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_policy_arn(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct AttachRolePolicy {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::attach_role_policy_input::Builder,
    }
    impl AttachRolePolicy {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::AttachRolePolicyOutput,
            smithy_http::result::SdkError<crate::error::AttachRolePolicyError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name (friendly name, not ARN) of the role to attach the policy to.</p>
        /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
        /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
        pub fn role_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.role_name(inp);
            self
        }
        pub fn set_role_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_role_name(inp);
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the IAM policy you want to attach.</p>
        /// <p>For more information about ARNs, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">Amazon Resource Names (ARNs)</a> in the <i>AWS General Reference</i>.</p>
        pub fn policy_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.policy_arn(inp);
            self
        }
        pub fn set_policy_arn(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_policy_arn(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct AttachUserPolicy {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::attach_user_policy_input::Builder,
    }
    impl AttachUserPolicy {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::AttachUserPolicyOutput,
            smithy_http::result::SdkError<crate::error::AttachUserPolicyError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name (friendly name, not ARN) of the IAM user to attach the policy to.</p>
        /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
        /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
        pub fn user_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.user_name(inp);
            self
        }
        pub fn set_user_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_user_name(inp);
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the IAM policy you want to attach.</p>
        /// <p>For more information about ARNs, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">Amazon Resource Names (ARNs)</a> in the <i>AWS General Reference</i>.</p>
        pub fn policy_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.policy_arn(inp);
            self
        }
        pub fn set_policy_arn(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_policy_arn(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ChangePassword {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::change_password_input::Builder,
    }
    impl ChangePassword {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::ChangePasswordOutput,
            smithy_http::result::SdkError<crate::error::ChangePasswordError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The IAM user's current password.</p>
        pub fn old_password(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.old_password(inp);
            self
        }
        pub fn set_old_password(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_old_password(inp);
            self
        }
        /// <p>The new password. The new password must conform to the AWS account's password
        /// policy, if one exists.</p>
        /// <p>The <a href="http://wikipedia.org/wiki/regex">regex pattern</a>
        /// that is used to validate this parameter is a string of characters. That string can include almost any printable
        /// ASCII character from the space (<code>\u0020</code>) through the end of the ASCII character range (<code>\u00FF</code>).
        /// You can also include the tab (<code>\u0009</code>), line feed (<code>\u000A</code>), and carriage return (<code>\u000D</code>)
        /// characters. Any of these characters are valid in a password. However, many tools, such
        /// as the AWS Management Console, might restrict the ability to type certain characters because they have
        /// special meaning within that tool.</p>
        pub fn new_password(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.new_password(inp);
            self
        }
        pub fn set_new_password(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_new_password(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateAccessKey {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::create_access_key_input::Builder,
    }
    impl CreateAccessKey {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::CreateAccessKeyOutput,
            smithy_http::result::SdkError<crate::error::CreateAccessKeyError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the IAM user that the new key will belong to.</p>
        /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
        /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
        pub fn user_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.user_name(inp);
            self
        }
        pub fn set_user_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_user_name(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateAccountAlias {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::create_account_alias_input::Builder,
    }
    impl CreateAccountAlias {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::CreateAccountAliasOutput,
            smithy_http::result::SdkError<crate::error::CreateAccountAliasError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The account alias to create.</p>
        /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of
        /// lowercase letters, digits, and dashes. You cannot start or finish with a dash, nor can you have
        /// two dashes in a row.</p>
        pub fn account_alias(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.account_alias(inp);
            self
        }
        pub fn set_account_alias(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_account_alias(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateGroup {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::create_group_input::Builder,
    }
    impl CreateGroup {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::CreateGroupOutput,
            smithy_http::result::SdkError<crate::error::CreateGroupError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p> The path to the group. For more information about paths, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html">IAM
        /// identifiers</a> in the <i>IAM User Guide</i>.</p>
        /// <p>This parameter is optional. If it is not included, it defaults to a slash (/).</p>
        /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting
        /// of either a forward slash (/) by itself or a string that must begin and end with forward slashes.
        /// In addition, it can contain any ASCII character from the ! (<code>\u0021</code>) through the DEL character (<code>\u007F</code>), including
        /// most punctuation characters, digits, and upper and lowercased letters.</p>
        pub fn path(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.path(inp);
            self
        }
        pub fn set_path(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_path(inp);
            self
        }
        /// <p>The name of the group to create. Do not include the path in this value.</p>
        /// <p>IAM user, group, role, and policy names must be unique within the account. Names are
        /// not distinguished by case. For example, you cannot create resources named both
        /// "MyResource" and "myresource".</p>
        pub fn group_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.group_name(inp);
            self
        }
        pub fn set_group_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_group_name(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateInstanceProfile {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::create_instance_profile_input::Builder,
    }
    impl CreateInstanceProfile {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::CreateInstanceProfileOutput,
            smithy_http::result::SdkError<crate::error::CreateInstanceProfileError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the instance profile to create.</p>
        /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
        /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
        pub fn instance_profile_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.instance_profile_name(inp);
            self
        }
        pub fn set_instance_profile_name(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_instance_profile_name(inp);
            self
        }
        /// <p> The path to the instance profile. For more information about paths, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html">IAM
        /// Identifiers</a> in the <i>IAM User Guide</i>.</p>
        /// <p>This parameter is optional. If it is not included, it defaults to a slash (/).</p>
        /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting
        /// of either a forward slash (/) by itself or a string that must begin and end with forward slashes.
        /// In addition, it can contain any ASCII character from the ! (<code>\u0021</code>) through the DEL character (<code>\u007F</code>), including
        /// most punctuation characters, digits, and upper and lowercased letters.</p>
        pub fn path(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.path(inp);
            self
        }
        pub fn set_path(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_path(inp);
            self
        }
        /// <p>A list of tags that you want to attach to the newly created IAM instance profile.
        /// Each tag consists of a key name and an associated value. For more information about tagging, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_tags.html">Tagging IAM resources</a> in the
        /// <i>IAM User Guide</i>.</p>
        /// <note>
        /// <p>If any one of the tags is invalid or if you exceed the allowed maximum number of tags, then the entire request
        /// fails and the resource is not created.</p>
        /// </note>
        pub fn tags(mut self, inp: impl Into<crate::model::Tag>) -> Self {
            self.inner = self.inner.tags(inp);
            self
        }
        pub fn set_tags(
            mut self,
            inp: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.inner = self.inner.set_tags(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateLoginProfile {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::create_login_profile_input::Builder,
    }
    impl CreateLoginProfile {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::CreateLoginProfileOutput,
            smithy_http::result::SdkError<crate::error::CreateLoginProfileError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the IAM user to create a password for. The user must already
        /// exist.</p>
        /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
        /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
        pub fn user_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.user_name(inp);
            self
        }
        pub fn set_user_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_user_name(inp);
            self
        }
        /// <p>The new password for the user.</p>
        /// <p>The <a href="http://wikipedia.org/wiki/regex">regex pattern</a>
        /// that is used to validate this parameter is a string of characters. That string can include almost any printable
        /// ASCII character from the space (<code>\u0020</code>) through the end of the ASCII character range (<code>\u00FF</code>).
        /// You can also include the tab (<code>\u0009</code>), line feed (<code>\u000A</code>), and carriage return (<code>\u000D</code>)
        /// characters. Any of these characters are valid in a password. However, many tools, such
        /// as the AWS Management Console, might restrict the ability to type certain characters because they have
        /// special meaning within that tool.</p>
        pub fn password(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.password(inp);
            self
        }
        pub fn set_password(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_password(inp);
            self
        }
        /// <p>Specifies whether the user is required to set a new password on next sign-in.</p>
        pub fn password_reset_required(mut self, inp: bool) -> Self {
            self.inner = self.inner.password_reset_required(inp);
            self
        }
        pub fn set_password_reset_required(mut self, inp: bool) -> Self {
            self.inner = self.inner.set_password_reset_required(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateOpenIDConnectProvider {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::create_open_id_connect_provider_input::Builder,
    }
    impl CreateOpenIDConnectProvider {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::CreateOpenIDConnectProviderOutput,
            smithy_http::result::SdkError<crate::error::CreateOpenIDConnectProviderError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The URL of the identity provider. The URL must begin with <code>https://</code> and
        /// should correspond to the <code>iss</code> claim in the provider's OpenID Connect ID
        /// tokens. Per the OIDC standard, path components are allowed but query parameters are not.
        /// Typically the URL consists of only a hostname, like
        /// <code>https://server.example.org</code> or <code>https://example.com</code>.</p>
        /// <p>You cannot register the same provider multiple times in a single AWS account. If you
        /// try to submit a URL that has already been used for an OpenID Connect provider in the
        /// AWS account, you will get an error.</p>
        pub fn url(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.url(inp);
            self
        }
        pub fn set_url(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_url(inp);
            self
        }
        /// <p>A list of client IDs (also known as audiences). When a mobile or web app registers
        /// with an OpenID Connect provider, they establish a value that identifies the application.
        /// (This is the value that's sent as the <code>client_id</code> parameter on OAuth
        /// requests.)</p>
        /// <p>You can register multiple client IDs with the same provider. For example, you might
        /// have multiple applications that use the same OIDC provider. You cannot register more
        /// than 100 client IDs with a single IAM OIDC provider.</p>
        /// <p>There is no defined format for a client ID. The
        /// <code>CreateOpenIDConnectProviderRequest</code> operation accepts client IDs up to
        /// 255 characters long.</p>
        pub fn client_id_list(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.client_id_list(inp);
            self
        }
        pub fn set_client_id_list(
            mut self,
            inp: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_client_id_list(inp);
            self
        }
        /// <p>A list of server certificate thumbprints for the OpenID Connect (OIDC) identity
        /// provider's server certificates. Typically this list includes only one entry. However,
        /// IAM lets you have up to five thumbprints for an OIDC provider. This lets you maintain
        /// multiple thumbprints if the identity provider is rotating certificates.</p>
        /// <p>The server certificate thumbprint is the hex-encoded SHA-1 hash value of the X.509
        /// certificate used by the domain where the OpenID Connect provider makes its keys
        /// available. It is always a 40-character string.</p>
        /// <p>You must provide at least one thumbprint when creating an IAM OIDC provider. For
        /// example, assume that the OIDC provider is <code>server.example.com</code> and the
        /// provider stores its keys at https://keys.server.example.com/openid-connect. In that
        /// case, the thumbprint string would be the hex-encoded SHA-1 hash value of the certificate
        /// used by https://keys.server.example.com.</p>
        /// <p>For more information about obtaining the OIDC provider's thumbprint, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/identity-providers-oidc-obtain-thumbprint.html">Obtaining the
        /// thumbprint for an OpenID Connect provider</a> in the <i>IAM User
        /// Guide</i>.</p>
        pub fn thumbprint_list(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.thumbprint_list(inp);
            self
        }
        pub fn set_thumbprint_list(
            mut self,
            inp: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_thumbprint_list(inp);
            self
        }
        /// <p>A list of tags that you want to attach to the new IAM OpenID Connect (OIDC) provider.
        /// Each tag consists of a key name and an associated value. For more information about tagging, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_tags.html">Tagging IAM resources</a> in the
        /// <i>IAM User Guide</i>.</p>
        /// <note>
        /// <p>If any one of the tags is invalid or if you exceed the allowed maximum number of tags, then the entire request
        /// fails and the resource is not created.</p>
        /// </note>
        pub fn tags(mut self, inp: impl Into<crate::model::Tag>) -> Self {
            self.inner = self.inner.tags(inp);
            self
        }
        pub fn set_tags(
            mut self,
            inp: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.inner = self.inner.set_tags(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreatePolicy {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::create_policy_input::Builder,
    }
    impl CreatePolicy {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::CreatePolicyOutput,
            smithy_http::result::SdkError<crate::error::CreatePolicyError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The friendly name of the policy.</p>
        /// <p>IAM user, group, role, and policy names must be unique within the account. Names are
        /// not distinguished by case. For example, you cannot create resources named both
        /// "MyResource" and "myresource".</p>
        pub fn policy_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.policy_name(inp);
            self
        }
        pub fn set_policy_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_policy_name(inp);
            self
        }
        /// <p>The path for the policy.</p>
        /// <p>For more information about paths, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html">IAM identifiers</a> in the
        /// <i>IAM User Guide</i>.</p>
        /// <p>This parameter is optional. If it is not included, it defaults to a slash (/).</p>
        /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting
        /// of either a forward slash (/) by itself or a string that must begin and end with forward slashes.
        /// In addition, it can contain any ASCII character from the ! (<code>\u0021</code>) through the DEL character (<code>\u007F</code>), including
        /// most punctuation characters, digits, and upper and lowercased letters.</p>
        pub fn path(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.path(inp);
            self
        }
        pub fn set_path(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_path(inp);
            self
        }
        /// <p>The JSON policy document that you want to use as the content for the new
        /// policy.</p>
        /// <p>You must provide policies in JSON format in IAM. However, for AWS CloudFormation
        /// templates formatted in YAML, you can provide the policy in JSON or YAML format. AWS
        /// CloudFormation always converts a YAML policy to JSON format before submitting it to
        /// IAM.</p>
        /// <p>The <a href="http://wikipedia.org/wiki/regex">regex pattern</a>
        /// used to validate this parameter is a string of characters consisting of the following:</p>
        /// <ul>
        /// <li>
        /// <p>Any printable ASCII
        /// character ranging from the space character (<code>\u0020</code>) through the end of the ASCII character range</p>
        /// </li>
        /// <li>
        /// <p>The printable characters in the Basic Latin and  Latin-1 Supplement character set
        /// (through <code>\u00FF</code>)</p>
        /// </li>
        /// <li>
        /// <p>The special characters tab (<code>\u0009</code>), line feed (<code>\u000A</code>), and
        /// carriage return (<code>\u000D</code>)</p>
        /// </li>
        /// </ul>
        pub fn policy_document(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.policy_document(inp);
            self
        }
        pub fn set_policy_document(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_policy_document(inp);
            self
        }
        /// <p>A friendly description of the policy.</p>
        /// <p>Typically used to store information about the permissions defined in the policy. For
        /// example, "Grants access to production DynamoDB tables."</p>
        /// <p>The policy description is immutable. After a value is assigned, it cannot be
        /// changed.</p>
        pub fn description(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.description(inp);
            self
        }
        pub fn set_description(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_description(inp);
            self
        }
        /// <p>A list of tags that you want to attach to the new IAM customer managed policy.
        /// Each tag consists of a key name and an associated value. For more information about tagging, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_tags.html">Tagging IAM resources</a> in the
        /// <i>IAM User Guide</i>.</p>
        /// <note>
        /// <p>If any one of the tags is invalid or if you exceed the allowed maximum number of tags, then the entire request
        /// fails and the resource is not created.</p>
        /// </note>
        pub fn tags(mut self, inp: impl Into<crate::model::Tag>) -> Self {
            self.inner = self.inner.tags(inp);
            self
        }
        pub fn set_tags(
            mut self,
            inp: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.inner = self.inner.set_tags(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreatePolicyVersion {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::create_policy_version_input::Builder,
    }
    impl CreatePolicyVersion {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::CreatePolicyVersionOutput,
            smithy_http::result::SdkError<crate::error::CreatePolicyVersionError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the IAM policy to which you want to add a new
        /// version.</p>
        /// <p>For more information about ARNs, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">Amazon Resource Names (ARNs)</a> in the <i>AWS General Reference</i>.</p>
        pub fn policy_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.policy_arn(inp);
            self
        }
        pub fn set_policy_arn(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_policy_arn(inp);
            self
        }
        /// <p>The JSON policy document that you want to use as the content for this new version of
        /// the policy.</p>
        /// <p>You must provide policies in JSON format in IAM. However, for AWS CloudFormation
        /// templates formatted in YAML, you can provide the policy in JSON or YAML format. AWS
        /// CloudFormation always converts a YAML policy to JSON format before submitting it to
        /// IAM.</p>
        /// <p>The <a href="http://wikipedia.org/wiki/regex">regex pattern</a>
        /// used to validate this parameter is a string of characters consisting of the following:</p>
        /// <ul>
        /// <li>
        /// <p>Any printable ASCII
        /// character ranging from the space character (<code>\u0020</code>) through the end of the ASCII character range</p>
        /// </li>
        /// <li>
        /// <p>The printable characters in the Basic Latin and  Latin-1 Supplement character set
        /// (through <code>\u00FF</code>)</p>
        /// </li>
        /// <li>
        /// <p>The special characters tab (<code>\u0009</code>), line feed (<code>\u000A</code>), and
        /// carriage return (<code>\u000D</code>)</p>
        /// </li>
        /// </ul>
        pub fn policy_document(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.policy_document(inp);
            self
        }
        pub fn set_policy_document(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_policy_document(inp);
            self
        }
        /// <p>Specifies whether to set this version as the policy's default version.</p>
        /// <p>When this parameter is <code>true</code>, the new policy version becomes the operative
        /// version. That is, it becomes the version that is in effect for the IAM users, groups,
        /// and roles that the policy is attached to.</p>
        /// <p>For more information about managed policy versions, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/policies-managed-versions.html">Versioning for managed
        /// policies</a> in the <i>IAM User Guide</i>.</p>
        pub fn set_as_default(mut self, inp: bool) -> Self {
            self.inner = self.inner.set_as_default(inp);
            self
        }
        pub fn set_set_as_default(mut self, inp: bool) -> Self {
            self.inner = self.inner.set_set_as_default(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateRole {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::create_role_input::Builder,
    }
    impl CreateRole {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::CreateRoleOutput,
            smithy_http::result::SdkError<crate::error::CreateRoleError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p> The path to the role. For more information about paths, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html">IAM
        /// Identifiers</a> in the <i>IAM User Guide</i>.</p>
        /// <p>This parameter is optional. If it is not included, it defaults to a slash (/).</p>
        /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting
        /// of either a forward slash (/) by itself or a string that must begin and end with forward slashes.
        /// In addition, it can contain any ASCII character from the ! (<code>\u0021</code>) through the DEL character (<code>\u007F</code>), including
        /// most punctuation characters, digits, and upper and lowercased letters.</p>
        pub fn path(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.path(inp);
            self
        }
        pub fn set_path(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_path(inp);
            self
        }
        /// <p>The name of the role to create.</p>
        /// <p>IAM user, group, role, and policy names must be unique within the account. Names are
        /// not distinguished by case. For example, you cannot create resources named both
        /// "MyResource" and "myresource".</p>
        pub fn role_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.role_name(inp);
            self
        }
        pub fn set_role_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_role_name(inp);
            self
        }
        /// <p>The trust relationship policy document that grants an entity permission to assume the
        /// role.</p>
        /// <p>In IAM, you must provide a JSON policy that has been converted to a string. However,
        /// for AWS CloudFormation templates formatted in YAML, you can provide the policy in JSON
        /// or YAML format. AWS CloudFormation always converts a YAML policy to JSON format before
        /// submitting it to IAM.</p>
        /// <p>The <a href="http://wikipedia.org/wiki/regex">regex pattern</a>
        /// used to validate this parameter is a string of characters consisting of the following:</p>
        /// <ul>
        /// <li>
        /// <p>Any printable ASCII
        /// character ranging from the space character (<code>\u0020</code>) through the end of the ASCII character range</p>
        /// </li>
        /// <li>
        /// <p>The printable characters in the Basic Latin and  Latin-1 Supplement character set
        /// (through <code>\u00FF</code>)</p>
        /// </li>
        /// <li>
        /// <p>The special characters tab (<code>\u0009</code>), line feed (<code>\u000A</code>), and
        /// carriage return (<code>\u000D</code>)</p>
        /// </li>
        /// </ul>
        /// <p> Upon success, the response includes the same trust policy in JSON format.</p>
        pub fn assume_role_policy_document(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.assume_role_policy_document(inp);
            self
        }
        pub fn set_assume_role_policy_document(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_assume_role_policy_document(inp);
            self
        }
        /// <p>A description of the role.</p>
        pub fn description(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.description(inp);
            self
        }
        pub fn set_description(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_description(inp);
            self
        }
        /// <p>The maximum session duration (in seconds) that you want to set for the specified role.
        /// If you do not specify a value for this setting, the default maximum of one hour is
        /// applied. This setting can have a value from 1 hour to 12 hours.</p>
        /// <p>Anyone who assumes the role from the AWS CLI or API can use the
        /// <code>DurationSeconds</code> API parameter or the <code>duration-seconds</code> CLI
        /// parameter to request a longer session. The <code>MaxSessionDuration</code> setting
        /// determines the maximum duration that can be requested using the
        /// <code>DurationSeconds</code> parameter. If users don't specify a value for the
        /// <code>DurationSeconds</code> parameter, their security credentials are valid for one
        /// hour by default. This applies when you use the <code>AssumeRole*</code> API operations
        /// or the <code>assume-role*</code> CLI operations but does not apply when you use those
        /// operations to create a console URL. For more information, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_use.html">Using IAM
        /// roles</a> in the <i>IAM User Guide</i>.</p>
        pub fn max_session_duration(mut self, inp: i32) -> Self {
            self.inner = self.inner.max_session_duration(inp);
            self
        }
        pub fn set_max_session_duration(mut self, inp: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_session_duration(inp);
            self
        }
        /// <p>The ARN of the policy that is used to set the permissions boundary for the
        /// role.</p>
        pub fn permissions_boundary(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.permissions_boundary(inp);
            self
        }
        pub fn set_permissions_boundary(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_permissions_boundary(inp);
            self
        }
        /// <p>A list of tags that you want to attach to the new role. Each tag consists of a key name and an associated value.
        /// For more information about tagging, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_tags.html">Tagging IAM resources</a> in the
        /// <i>IAM User Guide</i>.</p>
        /// <note>
        /// <p>If any one of the tags is invalid or if you exceed the allowed maximum number of tags, then the entire request
        /// fails and the resource is not created.</p>
        /// </note>
        pub fn tags(mut self, inp: impl Into<crate::model::Tag>) -> Self {
            self.inner = self.inner.tags(inp);
            self
        }
        pub fn set_tags(
            mut self,
            inp: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.inner = self.inner.set_tags(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateSAMLProvider {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::create_saml_provider_input::Builder,
    }
    impl CreateSAMLProvider {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::CreateSAMLProviderOutput,
            smithy_http::result::SdkError<crate::error::CreateSAMLProviderError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>An XML document generated by an identity provider (IdP) that supports SAML 2.0. The
        /// document includes the issuer's name, expiration information, and keys that can be used
        /// to validate the SAML authentication response (assertions) that are received from the
        /// IdP. You must generate the metadata document using the identity management software that
        /// is used as your organization's IdP.</p>
        /// <p>For more information, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_providers_saml.html">About SAML 2.0-based
        /// federation</a> in the <i>IAM User Guide</i>
        /// </p>
        pub fn saml_metadata_document(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.saml_metadata_document(inp);
            self
        }
        pub fn set_saml_metadata_document(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_saml_metadata_document(inp);
            self
        }
        /// <p>The name of the provider to create.</p>
        /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
        /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
        pub fn name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(inp);
            self
        }
        pub fn set_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(inp);
            self
        }
        /// <p>A list of tags that you want to attach to the new IAM SAML provider.
        /// Each tag consists of a key name and an associated value. For more information about tagging, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_tags.html">Tagging IAM resources</a> in the
        /// <i>IAM User Guide</i>.</p>
        /// <note>
        /// <p>If any one of the tags is invalid or if you exceed the allowed maximum number of tags, then the entire request
        /// fails and the resource is not created.</p>
        /// </note>
        pub fn tags(mut self, inp: impl Into<crate::model::Tag>) -> Self {
            self.inner = self.inner.tags(inp);
            self
        }
        pub fn set_tags(
            mut self,
            inp: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.inner = self.inner.set_tags(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateServiceLinkedRole {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::create_service_linked_role_input::Builder,
    }
    impl CreateServiceLinkedRole {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::CreateServiceLinkedRoleOutput,
            smithy_http::result::SdkError<crate::error::CreateServiceLinkedRoleError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The service principal for the AWS service to which this role is attached. You use a
        /// string similar to a URL but without the http:// in front. For example:
        /// <code>elasticbeanstalk.amazonaws.com</code>. </p>
        /// <p>Service principals are unique and case-sensitive. To find the exact service principal
        /// for your service-linked role, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_aws-services-that-work-with-iam.html">AWS services
        /// that work with IAM</a> in the <i>IAM User Guide</i>. Look for
        /// the services that have <b>Yes </b>in the <b>Service-Linked Role</b> column. Choose the <b>Yes</b> link to view the service-linked role documentation for that
        /// service.</p>
        pub fn aws_service_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.aws_service_name(inp);
            self
        }
        pub fn set_aws_service_name(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_aws_service_name(inp);
            self
        }
        /// <p>The description of the role.</p>
        pub fn description(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.description(inp);
            self
        }
        pub fn set_description(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_description(inp);
            self
        }
        /// <p></p>
        /// <p>A string that you provide, which is combined with the service-provided prefix to form
        /// the complete role name. If you make multiple requests for the same service, then you
        /// must supply a different <code>CustomSuffix</code> for each request. Otherwise the
        /// request fails with a duplicate role name error. For example, you could add
        /// <code>-1</code> or <code>-debug</code> to the suffix.</p>
        /// <p>Some services do not support the <code>CustomSuffix</code> parameter. If you provide
        /// an optional suffix and the operation fails, try the operation again without the
        /// suffix.</p>
        pub fn custom_suffix(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.custom_suffix(inp);
            self
        }
        pub fn set_custom_suffix(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_custom_suffix(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateServiceSpecificCredential {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::create_service_specific_credential_input::Builder,
    }
    impl CreateServiceSpecificCredential {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::CreateServiceSpecificCredentialOutput,
            smithy_http::result::SdkError<crate::error::CreateServiceSpecificCredentialError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the IAM user that is to be associated with the credentials. The new
        /// service-specific credentials have the same permissions as the associated user except
        /// that they can be used only to access the specified service.</p>
        /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
        /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
        pub fn user_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.user_name(inp);
            self
        }
        pub fn set_user_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_user_name(inp);
            self
        }
        /// <p>The name of the AWS service that is to be associated with the credentials. The
        /// service you specify here is the only service that can be accessed using these
        /// credentials.</p>
        pub fn service_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.service_name(inp);
            self
        }
        pub fn set_service_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_service_name(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateUser {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::create_user_input::Builder,
    }
    impl CreateUser {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::CreateUserOutput,
            smithy_http::result::SdkError<crate::error::CreateUserError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p> The path for the user name. For more information about paths, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html">IAM
        /// identifiers</a> in the <i>IAM User Guide</i>.</p>
        /// <p>This parameter is optional. If it is not included, it defaults to a slash (/).</p>
        /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting
        /// of either a forward slash (/) by itself or a string that must begin and end with forward slashes.
        /// In addition, it can contain any ASCII character from the ! (<code>\u0021</code>) through the DEL character (<code>\u007F</code>), including
        /// most punctuation characters, digits, and upper and lowercased letters.</p>
        pub fn path(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.path(inp);
            self
        }
        pub fn set_path(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_path(inp);
            self
        }
        /// <p>The name of the user to create.</p>
        /// <p>IAM user, group, role, and policy names must be unique within the account. Names are
        /// not distinguished by case. For example, you cannot create resources named both
        /// "MyResource" and "myresource".</p>
        pub fn user_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.user_name(inp);
            self
        }
        pub fn set_user_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_user_name(inp);
            self
        }
        /// <p>The ARN of the policy that is used to set the permissions boundary for the
        /// user.</p>
        pub fn permissions_boundary(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.permissions_boundary(inp);
            self
        }
        pub fn set_permissions_boundary(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_permissions_boundary(inp);
            self
        }
        /// <p>A list of tags that you want to attach to the new user. Each tag consists of a key name and an associated value.
        /// For more information about tagging, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_tags.html">Tagging IAM resources</a> in the
        /// <i>IAM User Guide</i>.</p>
        /// <note>
        /// <p>If any one of the tags is invalid or if you exceed the allowed maximum number of tags, then the entire request
        /// fails and the resource is not created.</p>
        /// </note>
        pub fn tags(mut self, inp: impl Into<crate::model::Tag>) -> Self {
            self.inner = self.inner.tags(inp);
            self
        }
        pub fn set_tags(
            mut self,
            inp: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.inner = self.inner.set_tags(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateVirtualMFADevice {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::create_virtual_mfa_device_input::Builder,
    }
    impl CreateVirtualMFADevice {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::CreateVirtualMFADeviceOutput,
            smithy_http::result::SdkError<crate::error::CreateVirtualMFADeviceError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p> The path for the virtual MFA device. For more information about paths, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html">IAM
        /// identifiers</a> in the <i>IAM User Guide</i>.</p>
        /// <p>This parameter is optional. If it is not included, it defaults to a slash (/).</p>
        /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting
        /// of either a forward slash (/) by itself or a string that must begin and end with forward slashes.
        /// In addition, it can contain any ASCII character from the ! (<code>\u0021</code>) through the DEL character (<code>\u007F</code>), including
        /// most punctuation characters, digits, and upper and lowercased letters.</p>
        pub fn path(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.path(inp);
            self
        }
        pub fn set_path(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_path(inp);
            self
        }
        /// <p>The name of the virtual MFA device. Use with path to uniquely identify a virtual MFA
        /// device.</p>
        /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
        /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
        pub fn virtual_mfa_device_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.virtual_mfa_device_name(inp);
            self
        }
        pub fn set_virtual_mfa_device_name(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_virtual_mfa_device_name(inp);
            self
        }
        /// <p>A list of tags that you want to attach to the new IAM virtual MFA device.
        /// Each tag consists of a key name and an associated value. For more information about tagging, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_tags.html">Tagging IAM resources</a> in the
        /// <i>IAM User Guide</i>.</p>
        /// <note>
        /// <p>If any one of the tags is invalid or if you exceed the allowed maximum number of tags, then the entire request
        /// fails and the resource is not created.</p>
        /// </note>
        pub fn tags(mut self, inp: impl Into<crate::model::Tag>) -> Self {
            self.inner = self.inner.tags(inp);
            self
        }
        pub fn set_tags(
            mut self,
            inp: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.inner = self.inner.set_tags(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeactivateMFADevice {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::deactivate_mfa_device_input::Builder,
    }
    impl DeactivateMFADevice {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::DeactivateMFADeviceOutput,
            smithy_http::result::SdkError<crate::error::DeactivateMFADeviceError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the user whose MFA device you want to deactivate.</p>
        /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
        /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
        pub fn user_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.user_name(inp);
            self
        }
        pub fn set_user_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_user_name(inp);
            self
        }
        /// <p>The serial number that uniquely identifies the MFA device. For virtual MFA devices,
        /// the serial number is the device ARN.</p>
        /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting
        /// of upper and lowercase alphanumeric characters with no spaces. You can also include any of the
        /// following characters: =,.@:/-</p>
        pub fn serial_number(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.serial_number(inp);
            self
        }
        pub fn set_serial_number(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_serial_number(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteAccessKey {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::delete_access_key_input::Builder,
    }
    impl DeleteAccessKey {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::DeleteAccessKeyOutput,
            smithy_http::result::SdkError<crate::error::DeleteAccessKeyError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the user whose access key pair you want to delete.</p>
        /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
        /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
        pub fn user_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.user_name(inp);
            self
        }
        pub fn set_user_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_user_name(inp);
            self
        }
        /// <p>The access key ID for the access key ID and secret access key you want to
        /// delete.</p>
        /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters that can
        /// consist of any upper or lowercased letter or digit.</p>
        pub fn access_key_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.access_key_id(inp);
            self
        }
        pub fn set_access_key_id(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_access_key_id(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteAccountAlias {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::delete_account_alias_input::Builder,
    }
    impl DeleteAccountAlias {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::DeleteAccountAliasOutput,
            smithy_http::result::SdkError<crate::error::DeleteAccountAliasError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the account alias to delete.</p>
        /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of
        /// lowercase letters, digits, and dashes. You cannot start or finish with a dash, nor can you have
        /// two dashes in a row.</p>
        pub fn account_alias(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.account_alias(inp);
            self
        }
        pub fn set_account_alias(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_account_alias(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteAccountPasswordPolicy {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::delete_account_password_policy_input::Builder,
    }
    impl DeleteAccountPasswordPolicy {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::DeleteAccountPasswordPolicyOutput,
            smithy_http::result::SdkError<crate::error::DeleteAccountPasswordPolicyError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteGroup {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::delete_group_input::Builder,
    }
    impl DeleteGroup {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::DeleteGroupOutput,
            smithy_http::result::SdkError<crate::error::DeleteGroupError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the IAM group to delete.</p>
        /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
        /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
        pub fn group_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.group_name(inp);
            self
        }
        pub fn set_group_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_group_name(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteGroupPolicy {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::delete_group_policy_input::Builder,
    }
    impl DeleteGroupPolicy {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::DeleteGroupPolicyOutput,
            smithy_http::result::SdkError<crate::error::DeleteGroupPolicyError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name (friendly name, not ARN) identifying the group that the policy is embedded
        /// in.</p>
        /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
        /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
        pub fn group_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.group_name(inp);
            self
        }
        pub fn set_group_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_group_name(inp);
            self
        }
        /// <p>The name identifying the policy document to delete.</p>
        /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
        /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
        pub fn policy_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.policy_name(inp);
            self
        }
        pub fn set_policy_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_policy_name(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteInstanceProfile {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::delete_instance_profile_input::Builder,
    }
    impl DeleteInstanceProfile {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::DeleteInstanceProfileOutput,
            smithy_http::result::SdkError<crate::error::DeleteInstanceProfileError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the instance profile to delete.</p>
        /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
        /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
        pub fn instance_profile_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.instance_profile_name(inp);
            self
        }
        pub fn set_instance_profile_name(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_instance_profile_name(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteLoginProfile {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::delete_login_profile_input::Builder,
    }
    impl DeleteLoginProfile {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::DeleteLoginProfileOutput,
            smithy_http::result::SdkError<crate::error::DeleteLoginProfileError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the user whose password you want to delete.</p>
        /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
        /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
        pub fn user_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.user_name(inp);
            self
        }
        pub fn set_user_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_user_name(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteOpenIDConnectProvider {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::delete_open_id_connect_provider_input::Builder,
    }
    impl DeleteOpenIDConnectProvider {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::DeleteOpenIDConnectProviderOutput,
            smithy_http::result::SdkError<crate::error::DeleteOpenIDConnectProviderError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the IAM OpenID Connect provider resource object to
        /// delete. You can get a list of OpenID Connect provider resource ARNs by using the <a>ListOpenIDConnectProviders</a> operation.</p>
        pub fn open_id_connect_provider_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.open_id_connect_provider_arn(inp);
            self
        }
        pub fn set_open_id_connect_provider_arn(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_open_id_connect_provider_arn(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeletePolicy {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::delete_policy_input::Builder,
    }
    impl DeletePolicy {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::DeletePolicyOutput,
            smithy_http::result::SdkError<crate::error::DeletePolicyError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the IAM policy you want to delete.</p>
        /// <p>For more information about ARNs, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">Amazon Resource Names (ARNs)</a> in the <i>AWS General Reference</i>.</p>
        pub fn policy_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.policy_arn(inp);
            self
        }
        pub fn set_policy_arn(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_policy_arn(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeletePolicyVersion {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::delete_policy_version_input::Builder,
    }
    impl DeletePolicyVersion {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::DeletePolicyVersionOutput,
            smithy_http::result::SdkError<crate::error::DeletePolicyVersionError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the IAM policy from which you want to delete a
        /// version.</p>
        /// <p>For more information about ARNs, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">Amazon Resource Names (ARNs)</a> in the <i>AWS General Reference</i>.</p>
        pub fn policy_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.policy_arn(inp);
            self
        }
        pub fn set_policy_arn(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_policy_arn(inp);
            self
        }
        /// <p>The policy version to delete.</p>
        /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters that
        /// consists of the lowercase letter 'v' followed by one or two digits, and optionally
        /// followed by a period '.' and a string of letters and digits.</p>
        /// <p>For more information about managed policy versions, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/policies-managed-versions.html">Versioning for managed
        /// policies</a> in the <i>IAM User Guide</i>.</p>
        pub fn version_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.version_id(inp);
            self
        }
        pub fn set_version_id(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_version_id(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteRole {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::delete_role_input::Builder,
    }
    impl DeleteRole {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::DeleteRoleOutput,
            smithy_http::result::SdkError<crate::error::DeleteRoleError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the role to delete.</p>
        /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
        /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
        pub fn role_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.role_name(inp);
            self
        }
        pub fn set_role_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_role_name(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteRolePermissionsBoundary {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::delete_role_permissions_boundary_input::Builder,
    }
    impl DeleteRolePermissionsBoundary {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::DeleteRolePermissionsBoundaryOutput,
            smithy_http::result::SdkError<crate::error::DeleteRolePermissionsBoundaryError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name (friendly name, not ARN) of the IAM role from which you want to remove the
        /// permissions boundary.</p>
        pub fn role_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.role_name(inp);
            self
        }
        pub fn set_role_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_role_name(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteRolePolicy {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::delete_role_policy_input::Builder,
    }
    impl DeleteRolePolicy {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::DeleteRolePolicyOutput,
            smithy_http::result::SdkError<crate::error::DeleteRolePolicyError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name (friendly name, not ARN) identifying the role that the policy is embedded
        /// in.</p>
        /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
        /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
        pub fn role_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.role_name(inp);
            self
        }
        pub fn set_role_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_role_name(inp);
            self
        }
        /// <p>The name of the inline policy to delete from the specified IAM role.</p>
        /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
        /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
        pub fn policy_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.policy_name(inp);
            self
        }
        pub fn set_policy_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_policy_name(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteSAMLProvider {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::delete_saml_provider_input::Builder,
    }
    impl DeleteSAMLProvider {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::DeleteSAMLProviderOutput,
            smithy_http::result::SdkError<crate::error::DeleteSAMLProviderError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the SAML provider to delete.</p>
        pub fn saml_provider_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.saml_provider_arn(inp);
            self
        }
        pub fn set_saml_provider_arn(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_saml_provider_arn(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteServerCertificate {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::delete_server_certificate_input::Builder,
    }
    impl DeleteServerCertificate {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::DeleteServerCertificateOutput,
            smithy_http::result::SdkError<crate::error::DeleteServerCertificateError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the server certificate you want to delete.</p>
        /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
        /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
        pub fn server_certificate_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.server_certificate_name(inp);
            self
        }
        pub fn set_server_certificate_name(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_server_certificate_name(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteServiceLinkedRole {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::delete_service_linked_role_input::Builder,
    }
    impl DeleteServiceLinkedRole {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::DeleteServiceLinkedRoleOutput,
            smithy_http::result::SdkError<crate::error::DeleteServiceLinkedRoleError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the service-linked role to be deleted.</p>
        pub fn role_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.role_name(inp);
            self
        }
        pub fn set_role_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_role_name(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteServiceSpecificCredential {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::delete_service_specific_credential_input::Builder,
    }
    impl DeleteServiceSpecificCredential {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::DeleteServiceSpecificCredentialOutput,
            smithy_http::result::SdkError<crate::error::DeleteServiceSpecificCredentialError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the IAM user associated with the service-specific credential. If this
        /// value is not specified, then the operation assumes the user whose credentials are used
        /// to call the operation.</p>
        /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
        /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
        pub fn user_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.user_name(inp);
            self
        }
        pub fn set_user_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_user_name(inp);
            self
        }
        /// <p>The unique identifier of the service-specific credential. You can get this value by
        /// calling <a>ListServiceSpecificCredentials</a>.</p>
        /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters that can
        /// consist of any upper or lowercased letter or digit.</p>
        pub fn service_specific_credential_id(
            mut self,
            inp: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.service_specific_credential_id(inp);
            self
        }
        pub fn set_service_specific_credential_id(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_service_specific_credential_id(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteSigningCertificate {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::delete_signing_certificate_input::Builder,
    }
    impl DeleteSigningCertificate {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::DeleteSigningCertificateOutput,
            smithy_http::result::SdkError<crate::error::DeleteSigningCertificateError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the user the signing certificate belongs to.</p>
        /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
        /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
        pub fn user_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.user_name(inp);
            self
        }
        pub fn set_user_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_user_name(inp);
            self
        }
        /// <p>The ID of the signing certificate to delete.</p>
        /// <p>The format of this parameter, as described by its <a href="http://wikipedia.org/wiki/regex">regex</a> pattern, is a string of
        /// characters that can be upper- or lower-cased letters or digits.</p>
        pub fn certificate_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.certificate_id(inp);
            self
        }
        pub fn set_certificate_id(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_certificate_id(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteSSHPublicKey {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::delete_ssh_public_key_input::Builder,
    }
    impl DeleteSSHPublicKey {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::DeleteSSHPublicKeyOutput,
            smithy_http::result::SdkError<crate::error::DeleteSSHPublicKeyError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the IAM user associated with the SSH public key.</p>
        /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
        /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
        pub fn user_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.user_name(inp);
            self
        }
        pub fn set_user_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_user_name(inp);
            self
        }
        /// <p>The unique identifier for the SSH public key.</p>
        /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters that can
        /// consist of any upper or lowercased letter or digit.</p>
        pub fn ssh_public_key_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.ssh_public_key_id(inp);
            self
        }
        pub fn set_ssh_public_key_id(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_ssh_public_key_id(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteUser {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::delete_user_input::Builder,
    }
    impl DeleteUser {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::DeleteUserOutput,
            smithy_http::result::SdkError<crate::error::DeleteUserError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the user to delete.</p>
        /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
        /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
        pub fn user_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.user_name(inp);
            self
        }
        pub fn set_user_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_user_name(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteUserPermissionsBoundary {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::delete_user_permissions_boundary_input::Builder,
    }
    impl DeleteUserPermissionsBoundary {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::DeleteUserPermissionsBoundaryOutput,
            smithy_http::result::SdkError<crate::error::DeleteUserPermissionsBoundaryError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name (friendly name, not ARN) of the IAM user from which you want to remove the
        /// permissions boundary.</p>
        pub fn user_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.user_name(inp);
            self
        }
        pub fn set_user_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_user_name(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteUserPolicy {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::delete_user_policy_input::Builder,
    }
    impl DeleteUserPolicy {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::DeleteUserPolicyOutput,
            smithy_http::result::SdkError<crate::error::DeleteUserPolicyError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name (friendly name, not ARN) identifying the user that the policy is embedded
        /// in.</p>
        /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
        /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
        pub fn user_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.user_name(inp);
            self
        }
        pub fn set_user_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_user_name(inp);
            self
        }
        /// <p>The name identifying the policy document to delete.</p>
        /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
        /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
        pub fn policy_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.policy_name(inp);
            self
        }
        pub fn set_policy_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_policy_name(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteVirtualMFADevice {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::delete_virtual_mfa_device_input::Builder,
    }
    impl DeleteVirtualMFADevice {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::DeleteVirtualMFADeviceOutput,
            smithy_http::result::SdkError<crate::error::DeleteVirtualMFADeviceError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The serial number that uniquely identifies the MFA device. For virtual MFA devices,
        /// the serial number is the same as the ARN.</p>
        /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting
        /// of upper and lowercase alphanumeric characters with no spaces. You can also include any of the
        /// following characters: =,.@:/-</p>
        pub fn serial_number(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.serial_number(inp);
            self
        }
        pub fn set_serial_number(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_serial_number(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DetachGroupPolicy {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::detach_group_policy_input::Builder,
    }
    impl DetachGroupPolicy {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::DetachGroupPolicyOutput,
            smithy_http::result::SdkError<crate::error::DetachGroupPolicyError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name (friendly name, not ARN) of the IAM group to detach the policy from.</p>
        /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
        /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
        pub fn group_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.group_name(inp);
            self
        }
        pub fn set_group_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_group_name(inp);
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the IAM policy you want to detach.</p>
        /// <p>For more information about ARNs, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">Amazon Resource Names (ARNs)</a> in the <i>AWS General Reference</i>.</p>
        pub fn policy_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.policy_arn(inp);
            self
        }
        pub fn set_policy_arn(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_policy_arn(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DetachRolePolicy {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::detach_role_policy_input::Builder,
    }
    impl DetachRolePolicy {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::DetachRolePolicyOutput,
            smithy_http::result::SdkError<crate::error::DetachRolePolicyError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name (friendly name, not ARN) of the IAM role to detach the policy from.</p>
        /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
        /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
        pub fn role_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.role_name(inp);
            self
        }
        pub fn set_role_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_role_name(inp);
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the IAM policy you want to detach.</p>
        /// <p>For more information about ARNs, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">Amazon Resource Names (ARNs)</a> in the <i>AWS General Reference</i>.</p>
        pub fn policy_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.policy_arn(inp);
            self
        }
        pub fn set_policy_arn(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_policy_arn(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DetachUserPolicy {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::detach_user_policy_input::Builder,
    }
    impl DetachUserPolicy {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::DetachUserPolicyOutput,
            smithy_http::result::SdkError<crate::error::DetachUserPolicyError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name (friendly name, not ARN) of the IAM user to detach the policy from.</p>
        /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
        /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
        pub fn user_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.user_name(inp);
            self
        }
        pub fn set_user_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_user_name(inp);
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the IAM policy you want to detach.</p>
        /// <p>For more information about ARNs, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">Amazon Resource Names (ARNs)</a> in the <i>AWS General Reference</i>.</p>
        pub fn policy_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.policy_arn(inp);
            self
        }
        pub fn set_policy_arn(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_policy_arn(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct EnableMFADevice {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::enable_mfa_device_input::Builder,
    }
    impl EnableMFADevice {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::EnableMFADeviceOutput,
            smithy_http::result::SdkError<crate::error::EnableMFADeviceError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the IAM user for whom you want to enable the MFA device.</p>
        /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
        /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
        pub fn user_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.user_name(inp);
            self
        }
        pub fn set_user_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_user_name(inp);
            self
        }
        /// <p>The serial number that uniquely identifies the MFA device. For virtual MFA devices,
        /// the serial number is the device ARN.</p>
        /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting
        /// of upper and lowercase alphanumeric characters with no spaces. You can also include any of the
        /// following characters: =,.@:/-</p>
        pub fn serial_number(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.serial_number(inp);
            self
        }
        pub fn set_serial_number(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_serial_number(inp);
            self
        }
        /// <p>An authentication code emitted by the device. </p>
        /// <p>The format for this parameter is a string of six digits.</p>
        /// <important>
        /// <p>Submit your request immediately after generating the authentication codes. If you
        /// generate the codes and then wait too long to submit the request, the MFA device
        /// successfully associates with the user but the MFA device becomes out of sync. This
        /// happens because time-based one-time passwords (TOTP) expire after a short period of
        /// time. If this happens, you can <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_mfa_sync.html">resync the
        /// device</a>.</p>
        /// </important>
        pub fn authentication_code1(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.authentication_code1(inp);
            self
        }
        pub fn set_authentication_code1(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_authentication_code1(inp);
            self
        }
        /// <p>A subsequent authentication code emitted by the device.</p>
        /// <p>The format for this parameter is a string of six digits.</p>
        /// <important>
        /// <p>Submit your request immediately after generating the authentication codes. If you
        /// generate the codes and then wait too long to submit the request, the MFA device
        /// successfully associates with the user but the MFA device becomes out of sync. This
        /// happens because time-based one-time passwords (TOTP) expire after a short period of
        /// time. If this happens, you can <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_mfa_sync.html">resync the
        /// device</a>.</p>
        /// </important>
        pub fn authentication_code2(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.authentication_code2(inp);
            self
        }
        pub fn set_authentication_code2(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_authentication_code2(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GenerateCredentialReport {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::generate_credential_report_input::Builder,
    }
    impl GenerateCredentialReport {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::GenerateCredentialReportOutput,
            smithy_http::result::SdkError<crate::error::GenerateCredentialReportError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GenerateOrganizationsAccessReport {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::generate_organizations_access_report_input::Builder,
    }
    impl GenerateOrganizationsAccessReport {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::GenerateOrganizationsAccessReportOutput,
            smithy_http::result::SdkError<crate::error::GenerateOrganizationsAccessReportError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The path of the AWS Organizations entity (root, OU, or account). You can build an entity path using
        /// the known structure of your organization. For example, assume that your account ID is
        /// <code>123456789012</code> and its parent OU ID is <code>ou-rge0-awsabcde</code>. The
        /// organization root ID is <code>r-f6g7h8i9j0example</code> and your organization ID is
        /// <code>o-a1b2c3d4e5</code>. Your entity path is
        /// <code>o-a1b2c3d4e5/r-f6g7h8i9j0example/ou-rge0-awsabcde/123456789012</code>.</p>
        pub fn entity_path(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.entity_path(inp);
            self
        }
        pub fn set_entity_path(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_entity_path(inp);
            self
        }
        /// <p>The identifier of the AWS Organizations service control policy (SCP). This parameter is
        /// optional.</p>
        /// <p>This ID is used to generate information about when an account principal that is
        /// limited by the SCP attempted to access an AWS service.</p>
        pub fn organizations_policy_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.organizations_policy_id(inp);
            self
        }
        pub fn set_organizations_policy_id(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_organizations_policy_id(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GenerateServiceLastAccessedDetails {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::generate_service_last_accessed_details_input::Builder,
    }
    impl GenerateServiceLastAccessedDetails {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::GenerateServiceLastAccessedDetailsOutput,
            smithy_http::result::SdkError<crate::error::GenerateServiceLastAccessedDetailsError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ARN of the IAM resource (user, group, role, or managed policy) used to generate
        /// information about when the resource was last used in an attempt to access an AWS
        /// service.</p>
        pub fn arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.arn(inp);
            self
        }
        pub fn set_arn(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_arn(inp);
            self
        }
        /// <p>The level of detail that you want to generate. You can specify whether you want to
        /// generate information about the last attempt to access services or actions. If you
        /// specify service-level granularity, this operation generates only service data. If you
        /// specify action-level granularity, it generates service and action data. If you don't
        /// include this optional parameter, the operation generates service data.</p>
        pub fn granularity(mut self, inp: crate::model::AccessAdvisorUsageGranularityType) -> Self {
            self.inner = self.inner.granularity(inp);
            self
        }
        pub fn set_granularity(
            mut self,
            inp: std::option::Option<crate::model::AccessAdvisorUsageGranularityType>,
        ) -> Self {
            self.inner = self.inner.set_granularity(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetAccessKeyLastUsed {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::get_access_key_last_used_input::Builder,
    }
    impl GetAccessKeyLastUsed {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::GetAccessKeyLastUsedOutput,
            smithy_http::result::SdkError<crate::error::GetAccessKeyLastUsedError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The identifier of an access key.</p>
        /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters that can
        /// consist of any upper or lowercased letter or digit.</p>
        pub fn access_key_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.access_key_id(inp);
            self
        }
        pub fn set_access_key_id(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_access_key_id(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetAccountAuthorizationDetails {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::get_account_authorization_details_input::Builder,
    }
    impl GetAccountAuthorizationDetails {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::GetAccountAuthorizationDetailsOutput,
            smithy_http::result::SdkError<crate::error::GetAccountAuthorizationDetailsError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>A list of entity types used to filter the results. Only the entities that match the
        /// types you specify are included in the output. Use the value
        /// <code>LocalManagedPolicy</code> to include customer managed policies.</p>
        /// <p>The format for this parameter is a comma-separated (if more than one) list of strings.
        /// Each string value in the list must be one of the valid values listed below.</p>
        pub fn filter(mut self, inp: impl Into<crate::model::EntityType>) -> Self {
            self.inner = self.inner.filter(inp);
            self
        }
        pub fn set_filter(
            mut self,
            inp: std::option::Option<std::vec::Vec<crate::model::EntityType>>,
        ) -> Self {
            self.inner = self.inner.set_filter(inp);
            self
        }
        /// <p>Use this only when paginating results to indicate the
        /// maximum number of items you want in the response. If additional items exist beyond the maximum
        /// you specify, the <code>IsTruncated</code> response element is <code>true</code>.</p>
        /// <p>If you do not include this parameter, the number of items defaults to 100. Note that
        /// IAM might return fewer results, even when there are more results available. In that case, the
        /// <code>IsTruncated</code> response element returns <code>true</code>, and <code>Marker</code>
        /// contains a value to include in the subsequent call that tells the service where to continue
        /// from.</p>
        pub fn max_items(mut self, inp: i32) -> Self {
            self.inner = self.inner.max_items(inp);
            self
        }
        pub fn set_max_items(mut self, inp: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_items(inp);
            self
        }
        /// <p>Use this parameter only when paginating results and only after
        /// you receive a response indicating that the results are truncated. Set it to the value of the
        /// <code>Marker</code> element in the response that you received to indicate where the next call
        /// should start.</p>
        pub fn marker(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.marker(inp);
            self
        }
        pub fn set_marker(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_marker(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetAccountPasswordPolicy {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::get_account_password_policy_input::Builder,
    }
    impl GetAccountPasswordPolicy {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::GetAccountPasswordPolicyOutput,
            smithy_http::result::SdkError<crate::error::GetAccountPasswordPolicyError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetAccountSummary {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::get_account_summary_input::Builder,
    }
    impl GetAccountSummary {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::GetAccountSummaryOutput,
            smithy_http::result::SdkError<crate::error::GetAccountSummaryError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetContextKeysForCustomPolicy {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::get_context_keys_for_custom_policy_input::Builder,
    }
    impl GetContextKeysForCustomPolicy {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::GetContextKeysForCustomPolicyOutput,
            smithy_http::result::SdkError<crate::error::GetContextKeysForCustomPolicyError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>A list of policies for which you want the list of context keys referenced in those
        /// policies. Each document is specified as a string containing the complete, valid JSON
        /// text of an IAM policy.</p>
        /// <p>The <a href="http://wikipedia.org/wiki/regex">regex pattern</a>
        /// used to validate this parameter is a string of characters consisting of the following:</p>
        /// <ul>
        /// <li>
        /// <p>Any printable ASCII
        /// character ranging from the space character (<code>\u0020</code>) through the end of the ASCII character range</p>
        /// </li>
        /// <li>
        /// <p>The printable characters in the Basic Latin and  Latin-1 Supplement character set
        /// (through <code>\u00FF</code>)</p>
        /// </li>
        /// <li>
        /// <p>The special characters tab (<code>\u0009</code>), line feed (<code>\u000A</code>), and
        /// carriage return (<code>\u000D</code>)</p>
        /// </li>
        /// </ul>
        pub fn policy_input_list(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.policy_input_list(inp);
            self
        }
        pub fn set_policy_input_list(
            mut self,
            inp: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_policy_input_list(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetContextKeysForPrincipalPolicy {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::get_context_keys_for_principal_policy_input::Builder,
    }
    impl GetContextKeysForPrincipalPolicy {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::GetContextKeysForPrincipalPolicyOutput,
            smithy_http::result::SdkError<crate::error::GetContextKeysForPrincipalPolicyError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ARN of a user, group, or role whose policies contain the context keys that you
        /// want listed. If you specify a user, the list includes context keys that are found in all
        /// policies that are attached to the user. The list also includes all groups that the user
        /// is a member of. If you pick a group or a role, then it includes only those context keys
        /// that are found in policies attached to that entity. Note that all parameters are shown
        /// in unencoded form here for clarity, but must be URL encoded to be included as a part of
        /// a real HTML request.</p>
        /// <p>For more information about ARNs, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">Amazon Resource Names (ARNs)</a> in the <i>AWS General Reference</i>.</p>
        pub fn policy_source_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.policy_source_arn(inp);
            self
        }
        pub fn set_policy_source_arn(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_policy_source_arn(inp);
            self
        }
        /// <p>An optional list of additional policies for which you want the list of context keys
        /// that are referenced.</p>
        /// <p>The <a href="http://wikipedia.org/wiki/regex">regex pattern</a>
        /// used to validate this parameter is a string of characters consisting of the following:</p>
        /// <ul>
        /// <li>
        /// <p>Any printable ASCII
        /// character ranging from the space character (<code>\u0020</code>) through the end of the ASCII character range</p>
        /// </li>
        /// <li>
        /// <p>The printable characters in the Basic Latin and  Latin-1 Supplement character set
        /// (through <code>\u00FF</code>)</p>
        /// </li>
        /// <li>
        /// <p>The special characters tab (<code>\u0009</code>), line feed (<code>\u000A</code>), and
        /// carriage return (<code>\u000D</code>)</p>
        /// </li>
        /// </ul>
        pub fn policy_input_list(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.policy_input_list(inp);
            self
        }
        pub fn set_policy_input_list(
            mut self,
            inp: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_policy_input_list(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetCredentialReport {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::get_credential_report_input::Builder,
    }
    impl GetCredentialReport {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::GetCredentialReportOutput,
            smithy_http::result::SdkError<crate::error::GetCredentialReportError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetGroup {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::get_group_input::Builder,
    }
    impl GetGroup {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::GetGroupOutput,
            smithy_http::result::SdkError<crate::error::GetGroupError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the group.</p>
        /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
        /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
        pub fn group_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.group_name(inp);
            self
        }
        pub fn set_group_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_group_name(inp);
            self
        }
        /// <p>Use this parameter only when paginating results and only after
        /// you receive a response indicating that the results are truncated. Set it to the value of the
        /// <code>Marker</code> element in the response that you received to indicate where the next call
        /// should start.</p>
        pub fn marker(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.marker(inp);
            self
        }
        pub fn set_marker(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_marker(inp);
            self
        }
        /// <p>Use this only when paginating results to indicate the
        /// maximum number of items you want in the response. If additional items exist beyond the maximum
        /// you specify, the <code>IsTruncated</code> response element is <code>true</code>.</p>
        /// <p>If you do not include this parameter, the number of items defaults to 100. Note that
        /// IAM might return fewer results, even when there are more results available. In that case, the
        /// <code>IsTruncated</code> response element returns <code>true</code>, and <code>Marker</code>
        /// contains a value to include in the subsequent call that tells the service where to continue
        /// from.</p>
        pub fn max_items(mut self, inp: i32) -> Self {
            self.inner = self.inner.max_items(inp);
            self
        }
        pub fn set_max_items(mut self, inp: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_items(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetGroupPolicy {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::get_group_policy_input::Builder,
    }
    impl GetGroupPolicy {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::GetGroupPolicyOutput,
            smithy_http::result::SdkError<crate::error::GetGroupPolicyError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the group the policy is associated with.</p>
        /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
        /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
        pub fn group_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.group_name(inp);
            self
        }
        pub fn set_group_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_group_name(inp);
            self
        }
        /// <p>The name of the policy document to get.</p>
        /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
        /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
        pub fn policy_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.policy_name(inp);
            self
        }
        pub fn set_policy_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_policy_name(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetInstanceProfile {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::get_instance_profile_input::Builder,
    }
    impl GetInstanceProfile {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::GetInstanceProfileOutput,
            smithy_http::result::SdkError<crate::error::GetInstanceProfileError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the instance profile to get information about.</p>
        /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
        /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
        pub fn instance_profile_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.instance_profile_name(inp);
            self
        }
        pub fn set_instance_profile_name(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_instance_profile_name(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetLoginProfile {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::get_login_profile_input::Builder,
    }
    impl GetLoginProfile {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::GetLoginProfileOutput,
            smithy_http::result::SdkError<crate::error::GetLoginProfileError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the user whose login profile you want to retrieve.</p>
        /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
        /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
        pub fn user_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.user_name(inp);
            self
        }
        pub fn set_user_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_user_name(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetOpenIDConnectProvider {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::get_open_id_connect_provider_input::Builder,
    }
    impl GetOpenIDConnectProvider {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::GetOpenIDConnectProviderOutput,
            smithy_http::result::SdkError<crate::error::GetOpenIDConnectProviderError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the OIDC provider resource object in IAM to get
        /// information for. You can get a list of OIDC provider resource ARNs by using the <a>ListOpenIDConnectProviders</a> operation.</p>
        /// <p>For more information about ARNs, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">Amazon Resource Names (ARNs)</a> in the <i>AWS General Reference</i>.</p>
        pub fn open_id_connect_provider_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.open_id_connect_provider_arn(inp);
            self
        }
        pub fn set_open_id_connect_provider_arn(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_open_id_connect_provider_arn(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetOrganizationsAccessReport {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::get_organizations_access_report_input::Builder,
    }
    impl GetOrganizationsAccessReport {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::GetOrganizationsAccessReportOutput,
            smithy_http::result::SdkError<crate::error::GetOrganizationsAccessReportError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The identifier of the request generated by the <a>GenerateOrganizationsAccessReport</a> operation.</p>
        pub fn job_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.job_id(inp);
            self
        }
        pub fn set_job_id(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_job_id(inp);
            self
        }
        /// <p>Use this only when paginating results to indicate the
        /// maximum number of items you want in the response. If additional items exist beyond the maximum
        /// you specify, the <code>IsTruncated</code> response element is <code>true</code>.</p>
        /// <p>If you do not include this parameter, the number of items defaults to 100. Note that
        /// IAM might return fewer results, even when there are more results available. In that case, the
        /// <code>IsTruncated</code> response element returns <code>true</code>, and <code>Marker</code>
        /// contains a value to include in the subsequent call that tells the service where to continue
        /// from.</p>
        pub fn max_items(mut self, inp: i32) -> Self {
            self.inner = self.inner.max_items(inp);
            self
        }
        pub fn set_max_items(mut self, inp: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_items(inp);
            self
        }
        /// <p>Use this parameter only when paginating results and only after
        /// you receive a response indicating that the results are truncated. Set it to the value of the
        /// <code>Marker</code> element in the response that you received to indicate where the next call
        /// should start.</p>
        pub fn marker(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.marker(inp);
            self
        }
        pub fn set_marker(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_marker(inp);
            self
        }
        /// <p>The key that is used to sort the results. If you choose the namespace key, the results
        /// are returned in alphabetical order. If you choose the time key, the results are sorted
        /// numerically by the date and time.</p>
        pub fn sort_key(mut self, inp: crate::model::SortKeyType) -> Self {
            self.inner = self.inner.sort_key(inp);
            self
        }
        pub fn set_sort_key(mut self, inp: std::option::Option<crate::model::SortKeyType>) -> Self {
            self.inner = self.inner.set_sort_key(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetPolicy {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::get_policy_input::Builder,
    }
    impl GetPolicy {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::GetPolicyOutput,
            smithy_http::result::SdkError<crate::error::GetPolicyError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the managed policy that you want information
        /// about.</p>
        /// <p>For more information about ARNs, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">Amazon Resource Names (ARNs)</a> in the <i>AWS General Reference</i>.</p>
        pub fn policy_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.policy_arn(inp);
            self
        }
        pub fn set_policy_arn(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_policy_arn(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetPolicyVersion {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::get_policy_version_input::Builder,
    }
    impl GetPolicyVersion {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::GetPolicyVersionOutput,
            smithy_http::result::SdkError<crate::error::GetPolicyVersionError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the managed policy that you want information
        /// about.</p>
        /// <p>For more information about ARNs, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">Amazon Resource Names (ARNs)</a> in the <i>AWS General Reference</i>.</p>
        pub fn policy_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.policy_arn(inp);
            self
        }
        pub fn set_policy_arn(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_policy_arn(inp);
            self
        }
        /// <p>Identifies the policy version to retrieve.</p>
        /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters that
        /// consists of the lowercase letter 'v' followed by one or two digits, and optionally
        /// followed by a period '.' and a string of letters and digits.</p>
        pub fn version_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.version_id(inp);
            self
        }
        pub fn set_version_id(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_version_id(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetRole {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::get_role_input::Builder,
    }
    impl GetRole {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::GetRoleOutput,
            smithy_http::result::SdkError<crate::error::GetRoleError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the IAM role to get information about.</p>
        /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
        /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
        pub fn role_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.role_name(inp);
            self
        }
        pub fn set_role_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_role_name(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetRolePolicy {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::get_role_policy_input::Builder,
    }
    impl GetRolePolicy {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::GetRolePolicyOutput,
            smithy_http::result::SdkError<crate::error::GetRolePolicyError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the role associated with the policy.</p>
        /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
        /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
        pub fn role_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.role_name(inp);
            self
        }
        pub fn set_role_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_role_name(inp);
            self
        }
        /// <p>The name of the policy document to get.</p>
        /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
        /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
        pub fn policy_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.policy_name(inp);
            self
        }
        pub fn set_policy_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_policy_name(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetSAMLProvider {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::get_saml_provider_input::Builder,
    }
    impl GetSAMLProvider {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::GetSAMLProviderOutput,
            smithy_http::result::SdkError<crate::error::GetSAMLProviderError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the SAML provider resource object in IAM to get
        /// information about.</p>
        /// <p>For more information about ARNs, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">Amazon Resource Names (ARNs)</a> in the <i>AWS General Reference</i>.</p>
        pub fn saml_provider_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.saml_provider_arn(inp);
            self
        }
        pub fn set_saml_provider_arn(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_saml_provider_arn(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetServerCertificate {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::get_server_certificate_input::Builder,
    }
    impl GetServerCertificate {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::GetServerCertificateOutput,
            smithy_http::result::SdkError<crate::error::GetServerCertificateError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the server certificate you want to retrieve information about.</p>
        /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
        /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
        pub fn server_certificate_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.server_certificate_name(inp);
            self
        }
        pub fn set_server_certificate_name(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_server_certificate_name(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetServiceLastAccessedDetails {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::get_service_last_accessed_details_input::Builder,
    }
    impl GetServiceLastAccessedDetails {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::GetServiceLastAccessedDetailsOutput,
            smithy_http::result::SdkError<crate::error::GetServiceLastAccessedDetailsError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the request generated by the <a>GenerateServiceLastAccessedDetails</a> operation. The <code>JobId</code>
        /// returned by <code>GenerateServiceLastAccessedDetail</code> must be used by the same role
        /// within a session, or by the same user when used to call
        /// <code>GetServiceLastAccessedDetail</code>.</p>
        pub fn job_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.job_id(inp);
            self
        }
        pub fn set_job_id(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_job_id(inp);
            self
        }
        /// <p>Use this only when paginating results to indicate the
        /// maximum number of items you want in the response. If additional items exist beyond the maximum
        /// you specify, the <code>IsTruncated</code> response element is <code>true</code>.</p>
        /// <p>If you do not include this parameter, the number of items defaults to 100. Note that
        /// IAM might return fewer results, even when there are more results available. In that case, the
        /// <code>IsTruncated</code> response element returns <code>true</code>, and <code>Marker</code>
        /// contains a value to include in the subsequent call that tells the service where to continue
        /// from.</p>
        pub fn max_items(mut self, inp: i32) -> Self {
            self.inner = self.inner.max_items(inp);
            self
        }
        pub fn set_max_items(mut self, inp: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_items(inp);
            self
        }
        /// <p>Use this parameter only when paginating results and only after
        /// you receive a response indicating that the results are truncated. Set it to the value of the
        /// <code>Marker</code> element in the response that you received to indicate where the next call
        /// should start.</p>
        pub fn marker(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.marker(inp);
            self
        }
        pub fn set_marker(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_marker(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetServiceLastAccessedDetailsWithEntities {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::get_service_last_accessed_details_with_entities_input::Builder,
    }
    impl GetServiceLastAccessedDetailsWithEntities {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::GetServiceLastAccessedDetailsWithEntitiesOutput,
            smithy_http::result::SdkError<
                crate::error::GetServiceLastAccessedDetailsWithEntitiesError,
            >,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the request generated by the <code>GenerateServiceLastAccessedDetails</code>
        /// operation.</p>
        pub fn job_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.job_id(inp);
            self
        }
        pub fn set_job_id(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_job_id(inp);
            self
        }
        /// <p>The service namespace for an AWS service. Provide the service namespace to learn
        /// when the IAM entity last attempted to access the specified service.</p>
        /// <p>To learn the service namespace for a service, see <a href="https://docs.aws.amazon.com/service-authorization/latest/reference/reference_policies_actions-resources-contextkeys.html">Actions, resources, and condition keys for AWS services</a> in the
        /// <i>IAM User Guide</i>. Choose the name of the service to view
        /// details for that service. In the first paragraph, find the service prefix. For example,
        /// <code>(service prefix: a4b)</code>. For more information about service namespaces,
        /// see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html#genref-aws-service-namespaces">AWS
        /// service namespaces</a> in the<i>AWS General Reference</i>.</p>
        pub fn service_namespace(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.service_namespace(inp);
            self
        }
        pub fn set_service_namespace(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_service_namespace(inp);
            self
        }
        /// <p>Use this only when paginating results to indicate the
        /// maximum number of items you want in the response. If additional items exist beyond the maximum
        /// you specify, the <code>IsTruncated</code> response element is <code>true</code>.</p>
        /// <p>If you do not include this parameter, the number of items defaults to 100. Note that
        /// IAM might return fewer results, even when there are more results available. In that case, the
        /// <code>IsTruncated</code> response element returns <code>true</code>, and <code>Marker</code>
        /// contains a value to include in the subsequent call that tells the service where to continue
        /// from.</p>
        pub fn max_items(mut self, inp: i32) -> Self {
            self.inner = self.inner.max_items(inp);
            self
        }
        pub fn set_max_items(mut self, inp: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_items(inp);
            self
        }
        /// <p>Use this parameter only when paginating results and only after
        /// you receive a response indicating that the results are truncated. Set it to the value of the
        /// <code>Marker</code> element in the response that you received to indicate where the next call
        /// should start.</p>
        pub fn marker(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.marker(inp);
            self
        }
        pub fn set_marker(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_marker(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetServiceLinkedRoleDeletionStatus {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::get_service_linked_role_deletion_status_input::Builder,
    }
    impl GetServiceLinkedRoleDeletionStatus {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::GetServiceLinkedRoleDeletionStatusOutput,
            smithy_http::result::SdkError<crate::error::GetServiceLinkedRoleDeletionStatusError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The deletion task identifier. This identifier is returned by the <a>DeleteServiceLinkedRole</a> operation in the format
        /// <code>task/aws-service-role/<service-principal-name>/<role-name>/<task-uuid></code>.</p>
        pub fn deletion_task_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.deletion_task_id(inp);
            self
        }
        pub fn set_deletion_task_id(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_deletion_task_id(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetSSHPublicKey {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::get_ssh_public_key_input::Builder,
    }
    impl GetSSHPublicKey {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::GetSSHPublicKeyOutput,
            smithy_http::result::SdkError<crate::error::GetSSHPublicKeyError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the IAM user associated with the SSH public key.</p>
        /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
        /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
        pub fn user_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.user_name(inp);
            self
        }
        pub fn set_user_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_user_name(inp);
            self
        }
        /// <p>The unique identifier for the SSH public key.</p>
        /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters that can
        /// consist of any upper or lowercased letter or digit.</p>
        pub fn ssh_public_key_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.ssh_public_key_id(inp);
            self
        }
        pub fn set_ssh_public_key_id(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_ssh_public_key_id(inp);
            self
        }
        /// <p>Specifies the public key encoding format to use in the response. To retrieve the
        /// public key in ssh-rsa format, use <code>SSH</code>. To retrieve the public key in PEM
        /// format, use <code>PEM</code>.</p>
        pub fn encoding(mut self, inp: crate::model::EncodingType) -> Self {
            self.inner = self.inner.encoding(inp);
            self
        }
        pub fn set_encoding(
            mut self,
            inp: std::option::Option<crate::model::EncodingType>,
        ) -> Self {
            self.inner = self.inner.set_encoding(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetUser {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::get_user_input::Builder,
    }
    impl GetUser {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::GetUserOutput,
            smithy_http::result::SdkError<crate::error::GetUserError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the user to get information about.</p>
        /// <p>This parameter is optional. If it is not included, it defaults to the user making the
        /// request. This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
        /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
        pub fn user_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.user_name(inp);
            self
        }
        pub fn set_user_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_user_name(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetUserPolicy {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::get_user_policy_input::Builder,
    }
    impl GetUserPolicy {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::GetUserPolicyOutput,
            smithy_http::result::SdkError<crate::error::GetUserPolicyError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the user who the policy is associated with.</p>
        /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
        /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
        pub fn user_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.user_name(inp);
            self
        }
        pub fn set_user_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_user_name(inp);
            self
        }
        /// <p>The name of the policy document to get.</p>
        /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
        /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
        pub fn policy_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.policy_name(inp);
            self
        }
        pub fn set_policy_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_policy_name(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListAccessKeys {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::list_access_keys_input::Builder,
    }
    impl ListAccessKeys {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::ListAccessKeysOutput,
            smithy_http::result::SdkError<crate::error::ListAccessKeysError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the user.</p>
        /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
        /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
        pub fn user_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.user_name(inp);
            self
        }
        pub fn set_user_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_user_name(inp);
            self
        }
        /// <p>Use this parameter only when paginating results and only after
        /// you receive a response indicating that the results are truncated. Set it to the value of the
        /// <code>Marker</code> element in the response that you received to indicate where the next call
        /// should start.</p>
        pub fn marker(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.marker(inp);
            self
        }
        pub fn set_marker(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_marker(inp);
            self
        }
        /// <p>Use this only when paginating results to indicate the
        /// maximum number of items you want in the response. If additional items exist beyond the maximum
        /// you specify, the <code>IsTruncated</code> response element is <code>true</code>.</p>
        /// <p>If you do not include this parameter, the number of items defaults to 100. Note that
        /// IAM might return fewer results, even when there are more results available. In that case, the
        /// <code>IsTruncated</code> response element returns <code>true</code>, and <code>Marker</code>
        /// contains a value to include in the subsequent call that tells the service where to continue
        /// from.</p>
        pub fn max_items(mut self, inp: i32) -> Self {
            self.inner = self.inner.max_items(inp);
            self
        }
        pub fn set_max_items(mut self, inp: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_items(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListAccountAliases {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::list_account_aliases_input::Builder,
    }
    impl ListAccountAliases {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::ListAccountAliasesOutput,
            smithy_http::result::SdkError<crate::error::ListAccountAliasesError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Use this parameter only when paginating results and only after
        /// you receive a response indicating that the results are truncated. Set it to the value of the
        /// <code>Marker</code> element in the response that you received to indicate where the next call
        /// should start.</p>
        pub fn marker(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.marker(inp);
            self
        }
        pub fn set_marker(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_marker(inp);
            self
        }
        /// <p>Use this only when paginating results to indicate the
        /// maximum number of items you want in the response. If additional items exist beyond the maximum
        /// you specify, the <code>IsTruncated</code> response element is <code>true</code>.</p>
        /// <p>If you do not include this parameter, the number of items defaults to 100. Note that
        /// IAM might return fewer results, even when there are more results available. In that case, the
        /// <code>IsTruncated</code> response element returns <code>true</code>, and <code>Marker</code>
        /// contains a value to include in the subsequent call that tells the service where to continue
        /// from.</p>
        pub fn max_items(mut self, inp: i32) -> Self {
            self.inner = self.inner.max_items(inp);
            self
        }
        pub fn set_max_items(mut self, inp: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_items(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListAttachedGroupPolicies {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::list_attached_group_policies_input::Builder,
    }
    impl ListAttachedGroupPolicies {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::ListAttachedGroupPoliciesOutput,
            smithy_http::result::SdkError<crate::error::ListAttachedGroupPoliciesError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name (friendly name, not ARN) of the group to list attached policies for.</p>
        /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
        /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
        pub fn group_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.group_name(inp);
            self
        }
        pub fn set_group_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_group_name(inp);
            self
        }
        /// <p>The path prefix for filtering the results. This parameter is optional. If it is not
        /// included, it defaults to a slash (/), listing all policies.</p>
        /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting
        /// of either a forward slash (/) by itself or a string that must begin and end with forward slashes.
        /// In addition, it can contain any ASCII character from the ! (<code>\u0021</code>) through the DEL character (<code>\u007F</code>), including
        /// most punctuation characters, digits, and upper and lowercased letters.</p>
        pub fn path_prefix(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.path_prefix(inp);
            self
        }
        pub fn set_path_prefix(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_path_prefix(inp);
            self
        }
        /// <p>Use this parameter only when paginating results and only after
        /// you receive a response indicating that the results are truncated. Set it to the value of the
        /// <code>Marker</code> element in the response that you received to indicate where the next call
        /// should start.</p>
        pub fn marker(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.marker(inp);
            self
        }
        pub fn set_marker(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_marker(inp);
            self
        }
        /// <p>Use this only when paginating results to indicate the
        /// maximum number of items you want in the response. If additional items exist beyond the maximum
        /// you specify, the <code>IsTruncated</code> response element is <code>true</code>.</p>
        /// <p>If you do not include this parameter, the number of items defaults to 100. Note that
        /// IAM might return fewer results, even when there are more results available. In that case, the
        /// <code>IsTruncated</code> response element returns <code>true</code>, and <code>Marker</code>
        /// contains a value to include in the subsequent call that tells the service where to continue
        /// from.</p>
        pub fn max_items(mut self, inp: i32) -> Self {
            self.inner = self.inner.max_items(inp);
            self
        }
        pub fn set_max_items(mut self, inp: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_items(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListAttachedRolePolicies {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::list_attached_role_policies_input::Builder,
    }
    impl ListAttachedRolePolicies {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::ListAttachedRolePoliciesOutput,
            smithy_http::result::SdkError<crate::error::ListAttachedRolePoliciesError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name (friendly name, not ARN) of the role to list attached policies for.</p>
        /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
        /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
        pub fn role_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.role_name(inp);
            self
        }
        pub fn set_role_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_role_name(inp);
            self
        }
        /// <p>The path prefix for filtering the results. This parameter is optional. If it is not
        /// included, it defaults to a slash (/), listing all policies.</p>
        /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting
        /// of either a forward slash (/) by itself or a string that must begin and end with forward slashes.
        /// In addition, it can contain any ASCII character from the ! (<code>\u0021</code>) through the DEL character (<code>\u007F</code>), including
        /// most punctuation characters, digits, and upper and lowercased letters.</p>
        pub fn path_prefix(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.path_prefix(inp);
            self
        }
        pub fn set_path_prefix(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_path_prefix(inp);
            self
        }
        /// <p>Use this parameter only when paginating results and only after
        /// you receive a response indicating that the results are truncated. Set it to the value of the
        /// <code>Marker</code> element in the response that you received to indicate where the next call
        /// should start.</p>
        pub fn marker(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.marker(inp);
            self
        }
        pub fn set_marker(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_marker(inp);
            self
        }
        /// <p>Use this only when paginating results to indicate the
        /// maximum number of items you want in the response. If additional items exist beyond the maximum
        /// you specify, the <code>IsTruncated</code> response element is <code>true</code>.</p>
        /// <p>If you do not include this parameter, the number of items defaults to 100. Note that
        /// IAM might return fewer results, even when there are more results available. In that case, the
        /// <code>IsTruncated</code> response element returns <code>true</code>, and <code>Marker</code>
        /// contains a value to include in the subsequent call that tells the service where to continue
        /// from.</p>
        pub fn max_items(mut self, inp: i32) -> Self {
            self.inner = self.inner.max_items(inp);
            self
        }
        pub fn set_max_items(mut self, inp: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_items(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListAttachedUserPolicies {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::list_attached_user_policies_input::Builder,
    }
    impl ListAttachedUserPolicies {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::ListAttachedUserPoliciesOutput,
            smithy_http::result::SdkError<crate::error::ListAttachedUserPoliciesError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name (friendly name, not ARN) of the user to list attached policies for.</p>
        /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
        /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
        pub fn user_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.user_name(inp);
            self
        }
        pub fn set_user_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_user_name(inp);
            self
        }
        /// <p>The path prefix for filtering the results. This parameter is optional. If it is not
        /// included, it defaults to a slash (/), listing all policies.</p>
        /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting
        /// of either a forward slash (/) by itself or a string that must begin and end with forward slashes.
        /// In addition, it can contain any ASCII character from the ! (<code>\u0021</code>) through the DEL character (<code>\u007F</code>), including
        /// most punctuation characters, digits, and upper and lowercased letters.</p>
        pub fn path_prefix(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.path_prefix(inp);
            self
        }
        pub fn set_path_prefix(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_path_prefix(inp);
            self
        }
        /// <p>Use this parameter only when paginating results and only after
        /// you receive a response indicating that the results are truncated. Set it to the value of the
        /// <code>Marker</code> element in the response that you received to indicate where the next call
        /// should start.</p>
        pub fn marker(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.marker(inp);
            self
        }
        pub fn set_marker(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_marker(inp);
            self
        }
        /// <p>Use this only when paginating results to indicate the
        /// maximum number of items you want in the response. If additional items exist beyond the maximum
        /// you specify, the <code>IsTruncated</code> response element is <code>true</code>.</p>
        /// <p>If you do not include this parameter, the number of items defaults to 100. Note that
        /// IAM might return fewer results, even when there are more results available. In that case, the
        /// <code>IsTruncated</code> response element returns <code>true</code>, and <code>Marker</code>
        /// contains a value to include in the subsequent call that tells the service where to continue
        /// from.</p>
        pub fn max_items(mut self, inp: i32) -> Self {
            self.inner = self.inner.max_items(inp);
            self
        }
        pub fn set_max_items(mut self, inp: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_items(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListEntitiesForPolicy {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::list_entities_for_policy_input::Builder,
    }
    impl ListEntitiesForPolicy {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::ListEntitiesForPolicyOutput,
            smithy_http::result::SdkError<crate::error::ListEntitiesForPolicyError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the IAM policy for which you want the
        /// versions.</p>
        /// <p>For more information about ARNs, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">Amazon Resource Names (ARNs)</a> in the <i>AWS General Reference</i>.</p>
        pub fn policy_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.policy_arn(inp);
            self
        }
        pub fn set_policy_arn(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_policy_arn(inp);
            self
        }
        /// <p>The entity type to use for filtering the results.</p>
        /// <p>For example, when <code>EntityFilter</code> is <code>Role</code>, only the roles that
        /// are attached to the specified policy are returned. This parameter is optional. If it is
        /// not included, all attached entities (users, groups, and roles) are returned. The
        /// argument for this parameter must be one of the valid values listed below.</p>
        pub fn entity_filter(mut self, inp: crate::model::EntityType) -> Self {
            self.inner = self.inner.entity_filter(inp);
            self
        }
        pub fn set_entity_filter(
            mut self,
            inp: std::option::Option<crate::model::EntityType>,
        ) -> Self {
            self.inner = self.inner.set_entity_filter(inp);
            self
        }
        /// <p>The path prefix for filtering the results. This parameter is optional. If it is not
        /// included, it defaults to a slash (/), listing all entities.</p>
        /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting
        /// of either a forward slash (/) by itself or a string that must begin and end with forward slashes.
        /// In addition, it can contain any ASCII character from the ! (<code>\u0021</code>) through the DEL character (<code>\u007F</code>), including
        /// most punctuation characters, digits, and upper and lowercased letters.</p>
        pub fn path_prefix(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.path_prefix(inp);
            self
        }
        pub fn set_path_prefix(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_path_prefix(inp);
            self
        }
        /// <p>The policy usage method to use for filtering the results.</p>
        /// <p>To list only permissions policies,
        /// set<code>PolicyUsageFilter</code>to<code>PermissionsPolicy</code>. To list only
        /// the policies used to set permissions boundaries, setthe value
        /// to<code>PermissionsBoundary</code>.</p>
        /// <p>This parameter is optional. If it is not included, all policies are returned. </p>
        pub fn policy_usage_filter(mut self, inp: crate::model::PolicyUsageType) -> Self {
            self.inner = self.inner.policy_usage_filter(inp);
            self
        }
        pub fn set_policy_usage_filter(
            mut self,
            inp: std::option::Option<crate::model::PolicyUsageType>,
        ) -> Self {
            self.inner = self.inner.set_policy_usage_filter(inp);
            self
        }
        /// <p>Use this parameter only when paginating results and only after
        /// you receive a response indicating that the results are truncated. Set it to the value of the
        /// <code>Marker</code> element in the response that you received to indicate where the next call
        /// should start.</p>
        pub fn marker(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.marker(inp);
            self
        }
        pub fn set_marker(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_marker(inp);
            self
        }
        /// <p>Use this only when paginating results to indicate the
        /// maximum number of items you want in the response. If additional items exist beyond the maximum
        /// you specify, the <code>IsTruncated</code> response element is <code>true</code>.</p>
        /// <p>If you do not include this parameter, the number of items defaults to 100. Note that
        /// IAM might return fewer results, even when there are more results available. In that case, the
        /// <code>IsTruncated</code> response element returns <code>true</code>, and <code>Marker</code>
        /// contains a value to include in the subsequent call that tells the service where to continue
        /// from.</p>
        pub fn max_items(mut self, inp: i32) -> Self {
            self.inner = self.inner.max_items(inp);
            self
        }
        pub fn set_max_items(mut self, inp: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_items(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListGroupPolicies {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::list_group_policies_input::Builder,
    }
    impl ListGroupPolicies {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::ListGroupPoliciesOutput,
            smithy_http::result::SdkError<crate::error::ListGroupPoliciesError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the group to list policies for.</p>
        /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
        /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
        pub fn group_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.group_name(inp);
            self
        }
        pub fn set_group_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_group_name(inp);
            self
        }
        /// <p>Use this parameter only when paginating results and only after
        /// you receive a response indicating that the results are truncated. Set it to the value of the
        /// <code>Marker</code> element in the response that you received to indicate where the next call
        /// should start.</p>
        pub fn marker(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.marker(inp);
            self
        }
        pub fn set_marker(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_marker(inp);
            self
        }
        /// <p>Use this only when paginating results to indicate the
        /// maximum number of items you want in the response. If additional items exist beyond the maximum
        /// you specify, the <code>IsTruncated</code> response element is <code>true</code>.</p>
        /// <p>If you do not include this parameter, the number of items defaults to 100. Note that
        /// IAM might return fewer results, even when there are more results available. In that case, the
        /// <code>IsTruncated</code> response element returns <code>true</code>, and <code>Marker</code>
        /// contains a value to include in the subsequent call that tells the service where to continue
        /// from.</p>
        pub fn max_items(mut self, inp: i32) -> Self {
            self.inner = self.inner.max_items(inp);
            self
        }
        pub fn set_max_items(mut self, inp: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_items(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListGroups {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::list_groups_input::Builder,
    }
    impl ListGroups {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::ListGroupsOutput,
            smithy_http::result::SdkError<crate::error::ListGroupsError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p> The path prefix for filtering the results. For example, the prefix
        /// <code>/division_abc/subdivision_xyz/</code> gets all groups whose path starts with
        /// <code>/division_abc/subdivision_xyz/</code>.</p>
        /// <p>This parameter is optional. If it is not included, it defaults to a slash (/), listing
        /// all groups. This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting
        /// of either a forward slash (/) by itself or a string that must begin and end with forward slashes.
        /// In addition, it can contain any ASCII character from the ! (<code>\u0021</code>) through the DEL character (<code>\u007F</code>), including
        /// most punctuation characters, digits, and upper and lowercased letters.</p>
        pub fn path_prefix(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.path_prefix(inp);
            self
        }
        pub fn set_path_prefix(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_path_prefix(inp);
            self
        }
        /// <p>Use this parameter only when paginating results and only after
        /// you receive a response indicating that the results are truncated. Set it to the value of the
        /// <code>Marker</code> element in the response that you received to indicate where the next call
        /// should start.</p>
        pub fn marker(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.marker(inp);
            self
        }
        pub fn set_marker(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_marker(inp);
            self
        }
        /// <p>Use this only when paginating results to indicate the
        /// maximum number of items you want in the response. If additional items exist beyond the maximum
        /// you specify, the <code>IsTruncated</code> response element is <code>true</code>.</p>
        /// <p>If you do not include this parameter, the number of items defaults to 100. Note that
        /// IAM might return fewer results, even when there are more results available. In that case, the
        /// <code>IsTruncated</code> response element returns <code>true</code>, and <code>Marker</code>
        /// contains a value to include in the subsequent call that tells the service where to continue
        /// from.</p>
        pub fn max_items(mut self, inp: i32) -> Self {
            self.inner = self.inner.max_items(inp);
            self
        }
        pub fn set_max_items(mut self, inp: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_items(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListGroupsForUser {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::list_groups_for_user_input::Builder,
    }
    impl ListGroupsForUser {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::ListGroupsForUserOutput,
            smithy_http::result::SdkError<crate::error::ListGroupsForUserError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the user to list groups for.</p>
        /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
        /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
        pub fn user_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.user_name(inp);
            self
        }
        pub fn set_user_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_user_name(inp);
            self
        }
        /// <p>Use this parameter only when paginating results and only after
        /// you receive a response indicating that the results are truncated. Set it to the value of the
        /// <code>Marker</code> element in the response that you received to indicate where the next call
        /// should start.</p>
        pub fn marker(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.marker(inp);
            self
        }
        pub fn set_marker(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_marker(inp);
            self
        }
        /// <p>Use this only when paginating results to indicate the
        /// maximum number of items you want in the response. If additional items exist beyond the maximum
        /// you specify, the <code>IsTruncated</code> response element is <code>true</code>.</p>
        /// <p>If you do not include this parameter, the number of items defaults to 100. Note that
        /// IAM might return fewer results, even when there are more results available. In that case, the
        /// <code>IsTruncated</code> response element returns <code>true</code>, and <code>Marker</code>
        /// contains a value to include in the subsequent call that tells the service where to continue
        /// from.</p>
        pub fn max_items(mut self, inp: i32) -> Self {
            self.inner = self.inner.max_items(inp);
            self
        }
        pub fn set_max_items(mut self, inp: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_items(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListInstanceProfiles {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::list_instance_profiles_input::Builder,
    }
    impl ListInstanceProfiles {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::ListInstanceProfilesOutput,
            smithy_http::result::SdkError<crate::error::ListInstanceProfilesError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p> The path prefix for filtering the results. For example, the prefix
        /// <code>/application_abc/component_xyz/</code> gets all instance profiles whose path
        /// starts with <code>/application_abc/component_xyz/</code>.</p>
        /// <p>This parameter is optional. If it is not included, it defaults to a slash (/), listing
        /// all instance profiles. This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting
        /// of either a forward slash (/) by itself or a string that must begin and end with forward slashes.
        /// In addition, it can contain any ASCII character from the ! (<code>\u0021</code>) through the DEL character (<code>\u007F</code>), including
        /// most punctuation characters, digits, and upper and lowercased letters.</p>
        pub fn path_prefix(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.path_prefix(inp);
            self
        }
        pub fn set_path_prefix(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_path_prefix(inp);
            self
        }
        /// <p>Use this parameter only when paginating results and only after
        /// you receive a response indicating that the results are truncated. Set it to the value of the
        /// <code>Marker</code> element in the response that you received to indicate where the next call
        /// should start.</p>
        pub fn marker(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.marker(inp);
            self
        }
        pub fn set_marker(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_marker(inp);
            self
        }
        /// <p>Use this only when paginating results to indicate the
        /// maximum number of items you want in the response. If additional items exist beyond the maximum
        /// you specify, the <code>IsTruncated</code> response element is <code>true</code>.</p>
        /// <p>If you do not include this parameter, the number of items defaults to 100. Note that
        /// IAM might return fewer results, even when there are more results available. In that case, the
        /// <code>IsTruncated</code> response element returns <code>true</code>, and <code>Marker</code>
        /// contains a value to include in the subsequent call that tells the service where to continue
        /// from.</p>
        pub fn max_items(mut self, inp: i32) -> Self {
            self.inner = self.inner.max_items(inp);
            self
        }
        pub fn set_max_items(mut self, inp: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_items(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListInstanceProfilesForRole {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::list_instance_profiles_for_role_input::Builder,
    }
    impl ListInstanceProfilesForRole {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::ListInstanceProfilesForRoleOutput,
            smithy_http::result::SdkError<crate::error::ListInstanceProfilesForRoleError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the role to list instance profiles for.</p>
        /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
        /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
        pub fn role_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.role_name(inp);
            self
        }
        pub fn set_role_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_role_name(inp);
            self
        }
        /// <p>Use this parameter only when paginating results and only after
        /// you receive a response indicating that the results are truncated. Set it to the value of the
        /// <code>Marker</code> element in the response that you received to indicate where the next call
        /// should start.</p>
        pub fn marker(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.marker(inp);
            self
        }
        pub fn set_marker(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_marker(inp);
            self
        }
        /// <p>Use this only when paginating results to indicate the
        /// maximum number of items you want in the response. If additional items exist beyond the maximum
        /// you specify, the <code>IsTruncated</code> response element is <code>true</code>.</p>
        /// <p>If you do not include this parameter, the number of items defaults to 100. Note that
        /// IAM might return fewer results, even when there are more results available. In that case, the
        /// <code>IsTruncated</code> response element returns <code>true</code>, and <code>Marker</code>
        /// contains a value to include in the subsequent call that tells the service where to continue
        /// from.</p>
        pub fn max_items(mut self, inp: i32) -> Self {
            self.inner = self.inner.max_items(inp);
            self
        }
        pub fn set_max_items(mut self, inp: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_items(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListInstanceProfileTags {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::list_instance_profile_tags_input::Builder,
    }
    impl ListInstanceProfileTags {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::ListInstanceProfileTagsOutput,
            smithy_http::result::SdkError<crate::error::ListInstanceProfileTagsError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the IAM instance profile whose tags you want to see.</p>
        /// <p>This parameter accepts (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters that consist of upper and lowercase alphanumeric
        /// characters with no spaces. You can also include any of the following characters: =,.@-</p>
        pub fn instance_profile_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.instance_profile_name(inp);
            self
        }
        pub fn set_instance_profile_name(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_instance_profile_name(inp);
            self
        }
        /// <p>Use this parameter only when paginating results and only after
        /// you receive a response indicating that the results are truncated. Set it to the value of the
        /// <code>Marker</code> element in the response that you received to indicate where the next call
        /// should start.</p>
        pub fn marker(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.marker(inp);
            self
        }
        pub fn set_marker(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_marker(inp);
            self
        }
        /// <p>(Optional) Use this only when paginating results to indicate the
        /// maximum number of items that you want in the response. If additional items exist beyond the maximum that you specify, the <code>IsTruncated</code> response element is <code>true</code>.</p>
        /// <p>If you do not include this parameter, it defaults to 100. Note that
        /// IAM might return fewer results, even when more results are available. In that case, the
        /// <code>IsTruncated</code> response element returns <code>true</code>, and <code>Marker</code>
        /// contains a value to include in the subsequent call that tells the service where to continue
        /// from.</p>
        pub fn max_items(mut self, inp: i32) -> Self {
            self.inner = self.inner.max_items(inp);
            self
        }
        pub fn set_max_items(mut self, inp: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_items(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListMFADevices {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::list_mfa_devices_input::Builder,
    }
    impl ListMFADevices {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::ListMFADevicesOutput,
            smithy_http::result::SdkError<crate::error::ListMFADevicesError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the user whose MFA devices you want to list.</p>
        /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
        /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
        pub fn user_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.user_name(inp);
            self
        }
        pub fn set_user_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_user_name(inp);
            self
        }
        /// <p>Use this parameter only when paginating results and only after
        /// you receive a response indicating that the results are truncated. Set it to the value of the
        /// <code>Marker</code> element in the response that you received to indicate where the next call
        /// should start.</p>
        pub fn marker(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.marker(inp);
            self
        }
        pub fn set_marker(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_marker(inp);
            self
        }
        /// <p>Use this only when paginating results to indicate the
        /// maximum number of items you want in the response. If additional items exist beyond the maximum
        /// you specify, the <code>IsTruncated</code> response element is <code>true</code>.</p>
        /// <p>If you do not include this parameter, the number of items defaults to 100. Note that
        /// IAM might return fewer results, even when there are more results available. In that case, the
        /// <code>IsTruncated</code> response element returns <code>true</code>, and <code>Marker</code>
        /// contains a value to include in the subsequent call that tells the service where to continue
        /// from.</p>
        pub fn max_items(mut self, inp: i32) -> Self {
            self.inner = self.inner.max_items(inp);
            self
        }
        pub fn set_max_items(mut self, inp: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_items(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListMFADeviceTags {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::list_mfa_device_tags_input::Builder,
    }
    impl ListMFADeviceTags {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::ListMFADeviceTagsOutput,
            smithy_http::result::SdkError<crate::error::ListMFADeviceTagsError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The unique identifier for the IAM virtual MFA device whose tags you want to see.
        /// For virtual MFA devices, the serial number is the same as the ARN.</p>
        /// <p>This parameter accepts (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters that consist of upper and lowercase alphanumeric
        /// characters with no spaces. You can also include any of the following characters: =,.@-</p>
        pub fn serial_number(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.serial_number(inp);
            self
        }
        pub fn set_serial_number(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_serial_number(inp);
            self
        }
        /// <p>Use this parameter only when paginating results and only after
        /// you receive a response indicating that the results are truncated. Set it to the value of the
        /// <code>Marker</code> element in the response that you received to indicate where the next call
        /// should start.</p>
        pub fn marker(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.marker(inp);
            self
        }
        pub fn set_marker(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_marker(inp);
            self
        }
        /// <p>(Optional) Use this only when paginating results to indicate the
        /// maximum number of items that you want in the response. If additional items exist beyond the maximum that you specify, the <code>IsTruncated</code> response element is <code>true</code>.</p>
        /// <p>If you do not include this parameter, it defaults to 100. Note that
        /// IAM might return fewer results, even when more results are available. In that case, the
        /// <code>IsTruncated</code> response element returns <code>true</code>, and <code>Marker</code>
        /// contains a value to include in the subsequent call that tells the service where to continue
        /// from.</p>
        pub fn max_items(mut self, inp: i32) -> Self {
            self.inner = self.inner.max_items(inp);
            self
        }
        pub fn set_max_items(mut self, inp: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_items(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListOpenIDConnectProviders {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::list_open_id_connect_providers_input::Builder,
    }
    impl ListOpenIDConnectProviders {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::ListOpenIDConnectProvidersOutput,
            smithy_http::result::SdkError<crate::error::ListOpenIDConnectProvidersError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListOpenIDConnectProviderTags {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::list_open_id_connect_provider_tags_input::Builder,
    }
    impl ListOpenIDConnectProviderTags {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::ListOpenIDConnectProviderTagsOutput,
            smithy_http::result::SdkError<crate::error::ListOpenIDConnectProviderTagsError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ARN of the OpenID Connect (OIDC) identity provider whose tags you want to
        /// see.</p>
        /// <p>This parameter accepts (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters that consist of upper and lowercase alphanumeric
        /// characters with no spaces. You can also include any of the following characters: =,.@-</p>
        pub fn open_id_connect_provider_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.open_id_connect_provider_arn(inp);
            self
        }
        pub fn set_open_id_connect_provider_arn(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_open_id_connect_provider_arn(inp);
            self
        }
        /// <p>Use this parameter only when paginating results and only after
        /// you receive a response indicating that the results are truncated. Set it to the value of the
        /// <code>Marker</code> element in the response that you received to indicate where the next call
        /// should start.</p>
        pub fn marker(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.marker(inp);
            self
        }
        pub fn set_marker(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_marker(inp);
            self
        }
        /// <p>(Optional) Use this only when paginating results to indicate the
        /// maximum number of items that you want in the response. If additional items exist beyond the maximum that you specify, the <code>IsTruncated</code> response element is <code>true</code>.</p>
        /// <p>If you do not include this parameter, it defaults to 100. Note that
        /// IAM might return fewer results, even when more results are available. In that case, the
        /// <code>IsTruncated</code> response element returns <code>true</code>, and <code>Marker</code>
        /// contains a value to include in the subsequent call that tells the service where to continue
        /// from.</p>
        pub fn max_items(mut self, inp: i32) -> Self {
            self.inner = self.inner.max_items(inp);
            self
        }
        pub fn set_max_items(mut self, inp: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_items(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListPolicies {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::list_policies_input::Builder,
    }
    impl ListPolicies {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::ListPoliciesOutput,
            smithy_http::result::SdkError<crate::error::ListPoliciesError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The scope to use for filtering the results.</p>
        /// <p>To list only AWS managed policies, set <code>Scope</code> to <code>AWS</code>. To
        /// list only the customer managed policies in your AWS account, set <code>Scope</code> to
        /// <code>Local</code>.</p>
        /// <p>This parameter is optional. If it is not included, or if it is set to
        /// <code>All</code>, all policies are returned.</p>
        pub fn scope(mut self, inp: crate::model::PolicyScopeType) -> Self {
            self.inner = self.inner.scope(inp);
            self
        }
        pub fn set_scope(
            mut self,
            inp: std::option::Option<crate::model::PolicyScopeType>,
        ) -> Self {
            self.inner = self.inner.set_scope(inp);
            self
        }
        /// <p>A flag to filter the results to only the attached policies.</p>
        /// <p>When <code>OnlyAttached</code> is <code>true</code>, the returned list contains only
        /// the policies that are attached to an IAM user, group, or role. When
        /// <code>OnlyAttached</code> is <code>false</code>, or when the parameter is not
        /// included, all policies are returned.</p>
        pub fn only_attached(mut self, inp: bool) -> Self {
            self.inner = self.inner.only_attached(inp);
            self
        }
        pub fn set_only_attached(mut self, inp: bool) -> Self {
            self.inner = self.inner.set_only_attached(inp);
            self
        }
        /// <p>The path prefix for filtering the results. This parameter is optional. If it is not
        /// included, it defaults to a slash (/), listing all policies. This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting
        /// of either a forward slash (/) by itself or a string that must begin and end with forward slashes.
        /// In addition, it can contain any ASCII character from the ! (<code>\u0021</code>) through the DEL character (<code>\u007F</code>), including
        /// most punctuation characters, digits, and upper and lowercased letters.</p>
        pub fn path_prefix(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.path_prefix(inp);
            self
        }
        pub fn set_path_prefix(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_path_prefix(inp);
            self
        }
        /// <p>The policy usage method to use for filtering the results.</p>
        /// <p>To list only permissions policies,
        /// set<code>PolicyUsageFilter</code>to<code>PermissionsPolicy</code>. To list only
        /// the policies used to set permissions boundaries, setthe value
        /// to<code>PermissionsBoundary</code>.</p>
        /// <p>This parameter is optional. If it is not included, all policies are returned. </p>
        pub fn policy_usage_filter(mut self, inp: crate::model::PolicyUsageType) -> Self {
            self.inner = self.inner.policy_usage_filter(inp);
            self
        }
        pub fn set_policy_usage_filter(
            mut self,
            inp: std::option::Option<crate::model::PolicyUsageType>,
        ) -> Self {
            self.inner = self.inner.set_policy_usage_filter(inp);
            self
        }
        /// <p>Use this parameter only when paginating results and only after
        /// you receive a response indicating that the results are truncated. Set it to the value of the
        /// <code>Marker</code> element in the response that you received to indicate where the next call
        /// should start.</p>
        pub fn marker(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.marker(inp);
            self
        }
        pub fn set_marker(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_marker(inp);
            self
        }
        /// <p>Use this only when paginating results to indicate the
        /// maximum number of items you want in the response. If additional items exist beyond the maximum
        /// you specify, the <code>IsTruncated</code> response element is <code>true</code>.</p>
        /// <p>If you do not include this parameter, the number of items defaults to 100. Note that
        /// IAM might return fewer results, even when there are more results available. In that case, the
        /// <code>IsTruncated</code> response element returns <code>true</code>, and <code>Marker</code>
        /// contains a value to include in the subsequent call that tells the service where to continue
        /// from.</p>
        pub fn max_items(mut self, inp: i32) -> Self {
            self.inner = self.inner.max_items(inp);
            self
        }
        pub fn set_max_items(mut self, inp: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_items(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListPoliciesGrantingServiceAccess {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::list_policies_granting_service_access_input::Builder,
    }
    impl ListPoliciesGrantingServiceAccess {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::ListPoliciesGrantingServiceAccessOutput,
            smithy_http::result::SdkError<crate::error::ListPoliciesGrantingServiceAccessError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Use this parameter only when paginating results and only after
        /// you receive a response indicating that the results are truncated. Set it to the value of the
        /// <code>Marker</code> element in the response that you received to indicate where the next call
        /// should start.</p>
        pub fn marker(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.marker(inp);
            self
        }
        pub fn set_marker(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_marker(inp);
            self
        }
        /// <p>The ARN of the IAM identity (user, group, or role) whose policies you want to
        /// list.</p>
        pub fn arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.arn(inp);
            self
        }
        pub fn set_arn(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_arn(inp);
            self
        }
        /// <p>The service namespace for the AWS services whose policies you want to list.</p>
        /// <p>To learn the service namespace for a service, see <a href="https://docs.aws.amazon.com/service-authorization/latest/reference/reference_policies_actions-resources-contextkeys.html">Actions, resources, and condition keys for AWS services</a> in the
        /// <i>IAM User Guide</i>. Choose the name of the service to view
        /// details for that service. In the first paragraph, find the service prefix. For example,
        /// <code>(service prefix: a4b)</code>. For more information about service namespaces,
        /// see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html#genref-aws-service-namespaces">AWS
        /// service namespaces</a> in the<i>AWS General Reference</i>.</p>
        pub fn service_namespaces(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.service_namespaces(inp);
            self
        }
        pub fn set_service_namespaces(
            mut self,
            inp: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_service_namespaces(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListPolicyTags {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::list_policy_tags_input::Builder,
    }
    impl ListPolicyTags {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::ListPolicyTagsOutput,
            smithy_http::result::SdkError<crate::error::ListPolicyTagsError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ARN of the IAM customer managed policy whose tags you want to see.</p>
        /// <p>This parameter accepts (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters that consist of upper and lowercase alphanumeric
        /// characters with no spaces. You can also include any of the following characters: =,.@-</p>
        pub fn policy_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.policy_arn(inp);
            self
        }
        pub fn set_policy_arn(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_policy_arn(inp);
            self
        }
        /// <p>Use this parameter only when paginating results and only after
        /// you receive a response indicating that the results are truncated. Set it to the value of the
        /// <code>Marker</code> element in the response that you received to indicate where the next call
        /// should start.</p>
        pub fn marker(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.marker(inp);
            self
        }
        pub fn set_marker(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_marker(inp);
            self
        }
        /// <p>(Optional) Use this only when paginating results to indicate the
        /// maximum number of items that you want in the response. If additional items exist beyond the maximum that you specify, the <code>IsTruncated</code> response element is <code>true</code>.</p>
        /// <p>If you do not include this parameter, it defaults to 100. Note that
        /// IAM might return fewer results, even when more results are available. In that case, the
        /// <code>IsTruncated</code> response element returns <code>true</code>, and <code>Marker</code>
        /// contains a value to include in the subsequent call that tells the service where to continue
        /// from.</p>
        pub fn max_items(mut self, inp: i32) -> Self {
            self.inner = self.inner.max_items(inp);
            self
        }
        pub fn set_max_items(mut self, inp: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_items(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListPolicyVersions {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::list_policy_versions_input::Builder,
    }
    impl ListPolicyVersions {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::ListPolicyVersionsOutput,
            smithy_http::result::SdkError<crate::error::ListPolicyVersionsError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the IAM policy for which you want the
        /// versions.</p>
        /// <p>For more information about ARNs, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">Amazon Resource Names (ARNs)</a> in the <i>AWS General Reference</i>.</p>
        pub fn policy_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.policy_arn(inp);
            self
        }
        pub fn set_policy_arn(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_policy_arn(inp);
            self
        }
        /// <p>Use this parameter only when paginating results and only after
        /// you receive a response indicating that the results are truncated. Set it to the value of the
        /// <code>Marker</code> element in the response that you received to indicate where the next call
        /// should start.</p>
        pub fn marker(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.marker(inp);
            self
        }
        pub fn set_marker(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_marker(inp);
            self
        }
        /// <p>Use this only when paginating results to indicate the
        /// maximum number of items you want in the response. If additional items exist beyond the maximum
        /// you specify, the <code>IsTruncated</code> response element is <code>true</code>.</p>
        /// <p>If you do not include this parameter, the number of items defaults to 100. Note that
        /// IAM might return fewer results, even when there are more results available. In that case, the
        /// <code>IsTruncated</code> response element returns <code>true</code>, and <code>Marker</code>
        /// contains a value to include in the subsequent call that tells the service where to continue
        /// from.</p>
        pub fn max_items(mut self, inp: i32) -> Self {
            self.inner = self.inner.max_items(inp);
            self
        }
        pub fn set_max_items(mut self, inp: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_items(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListRolePolicies {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::list_role_policies_input::Builder,
    }
    impl ListRolePolicies {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::ListRolePoliciesOutput,
            smithy_http::result::SdkError<crate::error::ListRolePoliciesError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the role to list policies for.</p>
        /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
        /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
        pub fn role_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.role_name(inp);
            self
        }
        pub fn set_role_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_role_name(inp);
            self
        }
        /// <p>Use this parameter only when paginating results and only after
        /// you receive a response indicating that the results are truncated. Set it to the value of the
        /// <code>Marker</code> element in the response that you received to indicate where the next call
        /// should start.</p>
        pub fn marker(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.marker(inp);
            self
        }
        pub fn set_marker(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_marker(inp);
            self
        }
        /// <p>Use this only when paginating results to indicate the
        /// maximum number of items you want in the response. If additional items exist beyond the maximum
        /// you specify, the <code>IsTruncated</code> response element is <code>true</code>.</p>
        /// <p>If you do not include this parameter, the number of items defaults to 100. Note that
        /// IAM might return fewer results, even when there are more results available. In that case, the
        /// <code>IsTruncated</code> response element returns <code>true</code>, and <code>Marker</code>
        /// contains a value to include in the subsequent call that tells the service where to continue
        /// from.</p>
        pub fn max_items(mut self, inp: i32) -> Self {
            self.inner = self.inner.max_items(inp);
            self
        }
        pub fn set_max_items(mut self, inp: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_items(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListRoles {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::list_roles_input::Builder,
    }
    impl ListRoles {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::ListRolesOutput,
            smithy_http::result::SdkError<crate::error::ListRolesError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p> The path prefix for filtering the results. For example, the prefix
        /// <code>/application_abc/component_xyz/</code> gets all roles whose path starts with
        /// <code>/application_abc/component_xyz/</code>.</p>
        /// <p>This parameter is optional. If it is not included, it defaults to a slash (/), listing
        /// all roles. This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting
        /// of either a forward slash (/) by itself or a string that must begin and end with forward slashes.
        /// In addition, it can contain any ASCII character from the ! (<code>\u0021</code>) through the DEL character (<code>\u007F</code>), including
        /// most punctuation characters, digits, and upper and lowercased letters.</p>
        pub fn path_prefix(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.path_prefix(inp);
            self
        }
        pub fn set_path_prefix(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_path_prefix(inp);
            self
        }
        /// <p>Use this parameter only when paginating results and only after
        /// you receive a response indicating that the results are truncated. Set it to the value of the
        /// <code>Marker</code> element in the response that you received to indicate where the next call
        /// should start.</p>
        pub fn marker(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.marker(inp);
            self
        }
        pub fn set_marker(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_marker(inp);
            self
        }
        /// <p>Use this only when paginating results to indicate the
        /// maximum number of items you want in the response. If additional items exist beyond the maximum
        /// you specify, the <code>IsTruncated</code> response element is <code>true</code>.</p>
        /// <p>If you do not include this parameter, the number of items defaults to 100. Note that
        /// IAM might return fewer results, even when there are more results available. In that case, the
        /// <code>IsTruncated</code> response element returns <code>true</code>, and <code>Marker</code>
        /// contains a value to include in the subsequent call that tells the service where to continue
        /// from.</p>
        pub fn max_items(mut self, inp: i32) -> Self {
            self.inner = self.inner.max_items(inp);
            self
        }
        pub fn set_max_items(mut self, inp: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_items(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListRoleTags {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::list_role_tags_input::Builder,
    }
    impl ListRoleTags {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::ListRoleTagsOutput,
            smithy_http::result::SdkError<crate::error::ListRoleTagsError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the IAM role for which you want to see the list of tags.</p>
        /// <p>This parameter accepts (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters that consist of upper and lowercase alphanumeric
        /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
        pub fn role_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.role_name(inp);
            self
        }
        pub fn set_role_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_role_name(inp);
            self
        }
        /// <p>Use this parameter only when paginating results and only after
        /// you receive a response indicating that the results are truncated. Set it to the value of the
        /// <code>Marker</code> element in the response that you received to indicate where the next call
        /// should start.</p>
        pub fn marker(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.marker(inp);
            self
        }
        pub fn set_marker(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_marker(inp);
            self
        }
        /// <p>(Optional) Use this only when paginating results to indicate the
        /// maximum number of items that you want in the response. If additional items exist beyond the maximum that you specify, the <code>IsTruncated</code> response element is <code>true</code>.</p>
        /// <p>If you do not include this parameter, it defaults to 100. Note that
        /// IAM might return fewer results, even when more results are available. In that case, the
        /// <code>IsTruncated</code> response element returns <code>true</code>, and <code>Marker</code>
        /// contains a value to include in the subsequent call that tells the service where to continue
        /// from.</p>
        pub fn max_items(mut self, inp: i32) -> Self {
            self.inner = self.inner.max_items(inp);
            self
        }
        pub fn set_max_items(mut self, inp: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_items(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListSAMLProviders {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::list_saml_providers_input::Builder,
    }
    impl ListSAMLProviders {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::ListSAMLProvidersOutput,
            smithy_http::result::SdkError<crate::error::ListSAMLProvidersError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListSAMLProviderTags {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::list_saml_provider_tags_input::Builder,
    }
    impl ListSAMLProviderTags {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::ListSAMLProviderTagsOutput,
            smithy_http::result::SdkError<crate::error::ListSAMLProviderTagsError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ARN of the Security Assertion Markup Language (SAML) identity provider whose tags
        /// you want to see.</p>
        /// <p>This parameter accepts (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters that consist of upper and lowercase alphanumeric
        /// characters with no spaces. You can also include any of the following characters: =,.@-</p>
        pub fn saml_provider_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.saml_provider_arn(inp);
            self
        }
        pub fn set_saml_provider_arn(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_saml_provider_arn(inp);
            self
        }
        /// <p>Use this parameter only when paginating results and only after
        /// you receive a response indicating that the results are truncated. Set it to the value of the
        /// <code>Marker</code> element in the response that you received to indicate where the next call
        /// should start.</p>
        pub fn marker(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.marker(inp);
            self
        }
        pub fn set_marker(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_marker(inp);
            self
        }
        /// <p>(Optional) Use this only when paginating results to indicate the
        /// maximum number of items that you want in the response. If additional items exist beyond the maximum that you specify, the <code>IsTruncated</code> response element is <code>true</code>.</p>
        /// <p>If you do not include this parameter, it defaults to 100. Note that
        /// IAM might return fewer results, even when more results are available. In that case, the
        /// <code>IsTruncated</code> response element returns <code>true</code>, and <code>Marker</code>
        /// contains a value to include in the subsequent call that tells the service where to continue
        /// from.</p>
        pub fn max_items(mut self, inp: i32) -> Self {
            self.inner = self.inner.max_items(inp);
            self
        }
        pub fn set_max_items(mut self, inp: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_items(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListServerCertificates {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::list_server_certificates_input::Builder,
    }
    impl ListServerCertificates {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::ListServerCertificatesOutput,
            smithy_http::result::SdkError<crate::error::ListServerCertificatesError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p> The path prefix for filtering the results. For example:
        /// <code>/company/servercerts</code> would get all server certificates for which the
        /// path starts with <code>/company/servercerts</code>.</p>
        /// <p>This parameter is optional. If it is not included, it defaults to a slash (/), listing
        /// all server certificates. This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting
        /// of either a forward slash (/) by itself or a string that must begin and end with forward slashes.
        /// In addition, it can contain any ASCII character from the ! (<code>\u0021</code>) through the DEL character (<code>\u007F</code>), including
        /// most punctuation characters, digits, and upper and lowercased letters.</p>
        pub fn path_prefix(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.path_prefix(inp);
            self
        }
        pub fn set_path_prefix(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_path_prefix(inp);
            self
        }
        /// <p>Use this parameter only when paginating results and only after
        /// you receive a response indicating that the results are truncated. Set it to the value of the
        /// <code>Marker</code> element in the response that you received to indicate where the next call
        /// should start.</p>
        pub fn marker(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.marker(inp);
            self
        }
        pub fn set_marker(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_marker(inp);
            self
        }
        /// <p>Use this only when paginating results to indicate the
        /// maximum number of items you want in the response. If additional items exist beyond the maximum
        /// you specify, the <code>IsTruncated</code> response element is <code>true</code>.</p>
        /// <p>If you do not include this parameter, the number of items defaults to 100. Note that
        /// IAM might return fewer results, even when there are more results available. In that case, the
        /// <code>IsTruncated</code> response element returns <code>true</code>, and <code>Marker</code>
        /// contains a value to include in the subsequent call that tells the service where to continue
        /// from.</p>
        pub fn max_items(mut self, inp: i32) -> Self {
            self.inner = self.inner.max_items(inp);
            self
        }
        pub fn set_max_items(mut self, inp: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_items(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListServerCertificateTags {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::list_server_certificate_tags_input::Builder,
    }
    impl ListServerCertificateTags {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::ListServerCertificateTagsOutput,
            smithy_http::result::SdkError<crate::error::ListServerCertificateTagsError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the IAM server certificate whose tags you want to see.</p>
        /// <p>This parameter accepts (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters that consist of upper and lowercase alphanumeric
        /// characters with no spaces. You can also include any of the following characters: =,.@-</p>
        pub fn server_certificate_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.server_certificate_name(inp);
            self
        }
        pub fn set_server_certificate_name(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_server_certificate_name(inp);
            self
        }
        /// <p>Use this parameter only when paginating results and only after
        /// you receive a response indicating that the results are truncated. Set it to the value of the
        /// <code>Marker</code> element in the response that you received to indicate where the next call
        /// should start.</p>
        pub fn marker(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.marker(inp);
            self
        }
        pub fn set_marker(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_marker(inp);
            self
        }
        /// <p>(Optional) Use this only when paginating results to indicate the
        /// maximum number of items that you want in the response. If additional items exist beyond the maximum that you specify, the <code>IsTruncated</code> response element is <code>true</code>.</p>
        /// <p>If you do not include this parameter, it defaults to 100. Note that
        /// IAM might return fewer results, even when more results are available. In that case, the
        /// <code>IsTruncated</code> response element returns <code>true</code>, and <code>Marker</code>
        /// contains a value to include in the subsequent call that tells the service where to continue
        /// from.</p>
        pub fn max_items(mut self, inp: i32) -> Self {
            self.inner = self.inner.max_items(inp);
            self
        }
        pub fn set_max_items(mut self, inp: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_items(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListServiceSpecificCredentials {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::list_service_specific_credentials_input::Builder,
    }
    impl ListServiceSpecificCredentials {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::ListServiceSpecificCredentialsOutput,
            smithy_http::result::SdkError<crate::error::ListServiceSpecificCredentialsError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the user whose service-specific credentials you want information about. If
        /// this value is not specified, then the operation assumes the user whose credentials are
        /// used to call the operation.</p>
        /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
        /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
        pub fn user_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.user_name(inp);
            self
        }
        pub fn set_user_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_user_name(inp);
            self
        }
        /// <p>Filters the returned results to only those for the specified AWS service. If not
        /// specified, then AWS returns service-specific credentials for all services.</p>
        pub fn service_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.service_name(inp);
            self
        }
        pub fn set_service_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_service_name(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListSigningCertificates {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::list_signing_certificates_input::Builder,
    }
    impl ListSigningCertificates {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::ListSigningCertificatesOutput,
            smithy_http::result::SdkError<crate::error::ListSigningCertificatesError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the IAM user whose signing certificates you want to examine.</p>
        /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
        /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
        pub fn user_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.user_name(inp);
            self
        }
        pub fn set_user_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_user_name(inp);
            self
        }
        /// <p>Use this parameter only when paginating results and only after
        /// you receive a response indicating that the results are truncated. Set it to the value of the
        /// <code>Marker</code> element in the response that you received to indicate where the next call
        /// should start.</p>
        pub fn marker(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.marker(inp);
            self
        }
        pub fn set_marker(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_marker(inp);
            self
        }
        /// <p>Use this only when paginating results to indicate the
        /// maximum number of items you want in the response. If additional items exist beyond the maximum
        /// you specify, the <code>IsTruncated</code> response element is <code>true</code>.</p>
        /// <p>If you do not include this parameter, the number of items defaults to 100. Note that
        /// IAM might return fewer results, even when there are more results available. In that case, the
        /// <code>IsTruncated</code> response element returns <code>true</code>, and <code>Marker</code>
        /// contains a value to include in the subsequent call that tells the service where to continue
        /// from.</p>
        pub fn max_items(mut self, inp: i32) -> Self {
            self.inner = self.inner.max_items(inp);
            self
        }
        pub fn set_max_items(mut self, inp: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_items(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListSSHPublicKeys {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::list_ssh_public_keys_input::Builder,
    }
    impl ListSSHPublicKeys {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::ListSSHPublicKeysOutput,
            smithy_http::result::SdkError<crate::error::ListSSHPublicKeysError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the IAM user to list SSH public keys for. If none is specified, the
        /// <code>UserName</code> field is determined implicitly based on the AWS access key
        /// used to sign the request.</p>
        /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
        /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
        pub fn user_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.user_name(inp);
            self
        }
        pub fn set_user_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_user_name(inp);
            self
        }
        /// <p>Use this parameter only when paginating results and only after
        /// you receive a response indicating that the results are truncated. Set it to the value of the
        /// <code>Marker</code> element in the response that you received to indicate where the next call
        /// should start.</p>
        pub fn marker(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.marker(inp);
            self
        }
        pub fn set_marker(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_marker(inp);
            self
        }
        /// <p>Use this only when paginating results to indicate the
        /// maximum number of items you want in the response. If additional items exist beyond the maximum
        /// you specify, the <code>IsTruncated</code> response element is <code>true</code>.</p>
        /// <p>If you do not include this parameter, the number of items defaults to 100. Note that
        /// IAM might return fewer results, even when there are more results available. In that case, the
        /// <code>IsTruncated</code> response element returns <code>true</code>, and <code>Marker</code>
        /// contains a value to include in the subsequent call that tells the service where to continue
        /// from.</p>
        pub fn max_items(mut self, inp: i32) -> Self {
            self.inner = self.inner.max_items(inp);
            self
        }
        pub fn set_max_items(mut self, inp: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_items(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListUserPolicies {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::list_user_policies_input::Builder,
    }
    impl ListUserPolicies {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::ListUserPoliciesOutput,
            smithy_http::result::SdkError<crate::error::ListUserPoliciesError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the user to list policies for.</p>
        /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
        /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
        pub fn user_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.user_name(inp);
            self
        }
        pub fn set_user_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_user_name(inp);
            self
        }
        /// <p>Use this parameter only when paginating results and only after
        /// you receive a response indicating that the results are truncated. Set it to the value of the
        /// <code>Marker</code> element in the response that you received to indicate where the next call
        /// should start.</p>
        pub fn marker(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.marker(inp);
            self
        }
        pub fn set_marker(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_marker(inp);
            self
        }
        /// <p>Use this only when paginating results to indicate the
        /// maximum number of items you want in the response. If additional items exist beyond the maximum
        /// you specify, the <code>IsTruncated</code> response element is <code>true</code>.</p>
        /// <p>If you do not include this parameter, the number of items defaults to 100. Note that
        /// IAM might return fewer results, even when there are more results available. In that case, the
        /// <code>IsTruncated</code> response element returns <code>true</code>, and <code>Marker</code>
        /// contains a value to include in the subsequent call that tells the service where to continue
        /// from.</p>
        pub fn max_items(mut self, inp: i32) -> Self {
            self.inner = self.inner.max_items(inp);
            self
        }
        pub fn set_max_items(mut self, inp: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_items(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListUsers {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::list_users_input::Builder,
    }
    impl ListUsers {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::ListUsersOutput,
            smithy_http::result::SdkError<crate::error::ListUsersError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p> The path prefix for filtering the results. For example:
        /// <code>/division_abc/subdivision_xyz/</code>, which would get all user names whose
        /// path starts with <code>/division_abc/subdivision_xyz/</code>.</p>
        /// <p>This parameter is optional. If it is not included, it defaults to a slash (/), listing
        /// all user names. This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting
        /// of either a forward slash (/) by itself or a string that must begin and end with forward slashes.
        /// In addition, it can contain any ASCII character from the ! (<code>\u0021</code>) through the DEL character (<code>\u007F</code>), including
        /// most punctuation characters, digits, and upper and lowercased letters.</p>
        pub fn path_prefix(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.path_prefix(inp);
            self
        }
        pub fn set_path_prefix(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_path_prefix(inp);
            self
        }
        /// <p>Use this parameter only when paginating results and only after
        /// you receive a response indicating that the results are truncated. Set it to the value of the
        /// <code>Marker</code> element in the response that you received to indicate where the next call
        /// should start.</p>
        pub fn marker(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.marker(inp);
            self
        }
        pub fn set_marker(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_marker(inp);
            self
        }
        /// <p>Use this only when paginating results to indicate the
        /// maximum number of items you want in the response. If additional items exist beyond the maximum
        /// you specify, the <code>IsTruncated</code> response element is <code>true</code>.</p>
        /// <p>If you do not include this parameter, the number of items defaults to 100. Note that
        /// IAM might return fewer results, even when there are more results available. In that case, the
        /// <code>IsTruncated</code> response element returns <code>true</code>, and <code>Marker</code>
        /// contains a value to include in the subsequent call that tells the service where to continue
        /// from.</p>
        pub fn max_items(mut self, inp: i32) -> Self {
            self.inner = self.inner.max_items(inp);
            self
        }
        pub fn set_max_items(mut self, inp: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_items(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListUserTags {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::list_user_tags_input::Builder,
    }
    impl ListUserTags {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::ListUserTagsOutput,
            smithy_http::result::SdkError<crate::error::ListUserTagsError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the IAM user whose tags you want to see.</p>
        /// <p>This parameter accepts (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters that consist of upper and lowercase alphanumeric
        /// characters with no spaces. You can also include any of the following characters: =,.@-</p>
        pub fn user_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.user_name(inp);
            self
        }
        pub fn set_user_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_user_name(inp);
            self
        }
        /// <p>Use this parameter only when paginating results and only after
        /// you receive a response indicating that the results are truncated. Set it to the value of the
        /// <code>Marker</code> element in the response that you received to indicate where the next call
        /// should start.</p>
        pub fn marker(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.marker(inp);
            self
        }
        pub fn set_marker(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_marker(inp);
            self
        }
        /// <p>(Optional) Use this only when paginating results to indicate the
        /// maximum number of items that you want in the response. If additional items exist beyond the maximum that you specify, the <code>IsTruncated</code> response element is <code>true</code>.</p>
        /// <p>If you do not include this parameter, it defaults to 100. Note that
        /// IAM might return fewer results, even when more results are available. In that case, the
        /// <code>IsTruncated</code> response element returns <code>true</code>, and <code>Marker</code>
        /// contains a value to include in the subsequent call that tells the service where to continue
        /// from.</p>
        pub fn max_items(mut self, inp: i32) -> Self {
            self.inner = self.inner.max_items(inp);
            self
        }
        pub fn set_max_items(mut self, inp: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_items(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListVirtualMFADevices {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::list_virtual_mfa_devices_input::Builder,
    }
    impl ListVirtualMFADevices {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::ListVirtualMFADevicesOutput,
            smithy_http::result::SdkError<crate::error::ListVirtualMFADevicesError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p> The status (<code>Unassigned</code> or <code>Assigned</code>) of the devices to list.
        /// If you do not specify an <code>AssignmentStatus</code>, the operation defaults to
        /// <code>Any</code>, which lists both assigned and unassigned virtual MFA
        /// devices.,</p>
        pub fn assignment_status(mut self, inp: crate::model::AssignmentStatusType) -> Self {
            self.inner = self.inner.assignment_status(inp);
            self
        }
        pub fn set_assignment_status(
            mut self,
            inp: std::option::Option<crate::model::AssignmentStatusType>,
        ) -> Self {
            self.inner = self.inner.set_assignment_status(inp);
            self
        }
        /// <p>Use this parameter only when paginating results and only after
        /// you receive a response indicating that the results are truncated. Set it to the value of the
        /// <code>Marker</code> element in the response that you received to indicate where the next call
        /// should start.</p>
        pub fn marker(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.marker(inp);
            self
        }
        pub fn set_marker(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_marker(inp);
            self
        }
        /// <p>Use this only when paginating results to indicate the
        /// maximum number of items you want in the response. If additional items exist beyond the maximum
        /// you specify, the <code>IsTruncated</code> response element is <code>true</code>.</p>
        /// <p>If you do not include this parameter, the number of items defaults to 100. Note that
        /// IAM might return fewer results, even when there are more results available. In that case, the
        /// <code>IsTruncated</code> response element returns <code>true</code>, and <code>Marker</code>
        /// contains a value to include in the subsequent call that tells the service where to continue
        /// from.</p>
        pub fn max_items(mut self, inp: i32) -> Self {
            self.inner = self.inner.max_items(inp);
            self
        }
        pub fn set_max_items(mut self, inp: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_items(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct PutGroupPolicy {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::put_group_policy_input::Builder,
    }
    impl PutGroupPolicy {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::PutGroupPolicyOutput,
            smithy_http::result::SdkError<crate::error::PutGroupPolicyError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the group to associate the policy with.</p>
        /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
        /// characters with no spaces. You can also include any of the following characters: _+=,.@-.</p>
        pub fn group_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.group_name(inp);
            self
        }
        pub fn set_group_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_group_name(inp);
            self
        }
        /// <p>The name of the policy document.</p>
        /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
        /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
        pub fn policy_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.policy_name(inp);
            self
        }
        pub fn set_policy_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_policy_name(inp);
            self
        }
        /// <p>The policy document.</p>
        /// <p>You must provide policies in JSON format in IAM. However, for AWS CloudFormation
        /// templates formatted in YAML, you can provide the policy in JSON or YAML format. AWS
        /// CloudFormation always converts a YAML policy to JSON format before submitting it to
        /// IAM.</p>
        /// <p>The <a href="http://wikipedia.org/wiki/regex">regex pattern</a>
        /// used to validate this parameter is a string of characters consisting of the following:</p>
        /// <ul>
        /// <li>
        /// <p>Any printable ASCII
        /// character ranging from the space character (<code>\u0020</code>) through the end of the ASCII character range</p>
        /// </li>
        /// <li>
        /// <p>The printable characters in the Basic Latin and  Latin-1 Supplement character set
        /// (through <code>\u00FF</code>)</p>
        /// </li>
        /// <li>
        /// <p>The special characters tab (<code>\u0009</code>), line feed (<code>\u000A</code>), and
        /// carriage return (<code>\u000D</code>)</p>
        /// </li>
        /// </ul>
        pub fn policy_document(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.policy_document(inp);
            self
        }
        pub fn set_policy_document(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_policy_document(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct PutRolePermissionsBoundary {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::put_role_permissions_boundary_input::Builder,
    }
    impl PutRolePermissionsBoundary {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::PutRolePermissionsBoundaryOutput,
            smithy_http::result::SdkError<crate::error::PutRolePermissionsBoundaryError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name (friendly name, not ARN) of the IAM role for which you want to set the
        /// permissions boundary.</p>
        pub fn role_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.role_name(inp);
            self
        }
        pub fn set_role_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_role_name(inp);
            self
        }
        /// <p>The ARN of the policy that is used to set the permissions boundary for the
        /// role.</p>
        pub fn permissions_boundary(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.permissions_boundary(inp);
            self
        }
        pub fn set_permissions_boundary(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_permissions_boundary(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct PutRolePolicy {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::put_role_policy_input::Builder,
    }
    impl PutRolePolicy {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::PutRolePolicyOutput,
            smithy_http::result::SdkError<crate::error::PutRolePolicyError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the role to associate the policy with.</p>
        /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
        /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
        pub fn role_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.role_name(inp);
            self
        }
        pub fn set_role_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_role_name(inp);
            self
        }
        /// <p>The name of the policy document.</p>
        /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
        /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
        pub fn policy_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.policy_name(inp);
            self
        }
        pub fn set_policy_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_policy_name(inp);
            self
        }
        /// <p>The policy document.</p>
        /// <p>You must provide policies in JSON format in IAM. However, for AWS CloudFormation
        /// templates formatted in YAML, you can provide the policy in JSON or YAML format. AWS
        /// CloudFormation always converts a YAML policy to JSON format before submitting it to
        /// IAM.</p>
        /// <p>The <a href="http://wikipedia.org/wiki/regex">regex pattern</a>
        /// used to validate this parameter is a string of characters consisting of the following:</p>
        /// <ul>
        /// <li>
        /// <p>Any printable ASCII
        /// character ranging from the space character (<code>\u0020</code>) through the end of the ASCII character range</p>
        /// </li>
        /// <li>
        /// <p>The printable characters in the Basic Latin and  Latin-1 Supplement character set
        /// (through <code>\u00FF</code>)</p>
        /// </li>
        /// <li>
        /// <p>The special characters tab (<code>\u0009</code>), line feed (<code>\u000A</code>), and
        /// carriage return (<code>\u000D</code>)</p>
        /// </li>
        /// </ul>
        pub fn policy_document(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.policy_document(inp);
            self
        }
        pub fn set_policy_document(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_policy_document(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct PutUserPermissionsBoundary {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::put_user_permissions_boundary_input::Builder,
    }
    impl PutUserPermissionsBoundary {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::PutUserPermissionsBoundaryOutput,
            smithy_http::result::SdkError<crate::error::PutUserPermissionsBoundaryError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name (friendly name, not ARN) of the IAM user for which you want to set the
        /// permissions boundary.</p>
        pub fn user_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.user_name(inp);
            self
        }
        pub fn set_user_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_user_name(inp);
            self
        }
        /// <p>The ARN of the policy that is used to set the permissions boundary for the
        /// user.</p>
        pub fn permissions_boundary(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.permissions_boundary(inp);
            self
        }
        pub fn set_permissions_boundary(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_permissions_boundary(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct PutUserPolicy {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::put_user_policy_input::Builder,
    }
    impl PutUserPolicy {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::PutUserPolicyOutput,
            smithy_http::result::SdkError<crate::error::PutUserPolicyError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the user to associate the policy with.</p>
        /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
        /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
        pub fn user_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.user_name(inp);
            self
        }
        pub fn set_user_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_user_name(inp);
            self
        }
        /// <p>The name of the policy document.</p>
        /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
        /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
        pub fn policy_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.policy_name(inp);
            self
        }
        pub fn set_policy_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_policy_name(inp);
            self
        }
        /// <p>The policy document.</p>
        /// <p>You must provide policies in JSON format in IAM. However, for AWS CloudFormation
        /// templates formatted in YAML, you can provide the policy in JSON or YAML format. AWS
        /// CloudFormation always converts a YAML policy to JSON format before submitting it to
        /// IAM.</p>
        /// <p>The <a href="http://wikipedia.org/wiki/regex">regex pattern</a>
        /// used to validate this parameter is a string of characters consisting of the following:</p>
        /// <ul>
        /// <li>
        /// <p>Any printable ASCII
        /// character ranging from the space character (<code>\u0020</code>) through the end of the ASCII character range</p>
        /// </li>
        /// <li>
        /// <p>The printable characters in the Basic Latin and  Latin-1 Supplement character set
        /// (through <code>\u00FF</code>)</p>
        /// </li>
        /// <li>
        /// <p>The special characters tab (<code>\u0009</code>), line feed (<code>\u000A</code>), and
        /// carriage return (<code>\u000D</code>)</p>
        /// </li>
        /// </ul>
        pub fn policy_document(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.policy_document(inp);
            self
        }
        pub fn set_policy_document(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_policy_document(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct RemoveClientIDFromOpenIDConnectProvider {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::remove_client_id_from_open_id_connect_provider_input::Builder,
    }
    impl RemoveClientIDFromOpenIDConnectProvider {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::RemoveClientIDFromOpenIDConnectProviderOutput,
            smithy_http::result::SdkError<
                crate::error::RemoveClientIDFromOpenIDConnectProviderError,
            >,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the IAM OIDC provider resource to remove the
        /// client ID from. You can get a list of OIDC provider ARNs by using the <a>ListOpenIDConnectProviders</a> operation.</p>
        /// <p>For more information about ARNs, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">Amazon Resource Names (ARNs)</a> in the <i>AWS General Reference</i>.</p>
        pub fn open_id_connect_provider_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.open_id_connect_provider_arn(inp);
            self
        }
        pub fn set_open_id_connect_provider_arn(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_open_id_connect_provider_arn(inp);
            self
        }
        /// <p>The client ID (also known as audience) to remove from the IAM OIDC provider
        /// resource. For more information about client IDs, see <a>CreateOpenIDConnectProvider</a>.</p>
        pub fn client_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.client_id(inp);
            self
        }
        pub fn set_client_id(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_client_id(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct RemoveRoleFromInstanceProfile {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::remove_role_from_instance_profile_input::Builder,
    }
    impl RemoveRoleFromInstanceProfile {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::RemoveRoleFromInstanceProfileOutput,
            smithy_http::result::SdkError<crate::error::RemoveRoleFromInstanceProfileError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the instance profile to update.</p>
        /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
        /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
        pub fn instance_profile_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.instance_profile_name(inp);
            self
        }
        pub fn set_instance_profile_name(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_instance_profile_name(inp);
            self
        }
        /// <p>The name of the role to remove.</p>
        /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
        /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
        pub fn role_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.role_name(inp);
            self
        }
        pub fn set_role_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_role_name(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct RemoveUserFromGroup {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::remove_user_from_group_input::Builder,
    }
    impl RemoveUserFromGroup {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::RemoveUserFromGroupOutput,
            smithy_http::result::SdkError<crate::error::RemoveUserFromGroupError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the group to update.</p>
        /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
        /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
        pub fn group_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.group_name(inp);
            self
        }
        pub fn set_group_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_group_name(inp);
            self
        }
        /// <p>The name of the user to remove.</p>
        /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
        /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
        pub fn user_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.user_name(inp);
            self
        }
        pub fn set_user_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_user_name(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ResetServiceSpecificCredential {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::reset_service_specific_credential_input::Builder,
    }
    impl ResetServiceSpecificCredential {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::ResetServiceSpecificCredentialOutput,
            smithy_http::result::SdkError<crate::error::ResetServiceSpecificCredentialError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the IAM user associated with the service-specific credential. If this
        /// value is not specified, then the operation assumes the user whose credentials are used
        /// to call the operation.</p>
        /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
        /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
        pub fn user_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.user_name(inp);
            self
        }
        pub fn set_user_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_user_name(inp);
            self
        }
        /// <p>The unique identifier of the service-specific credential.</p>
        /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters that can
        /// consist of any upper or lowercased letter or digit.</p>
        pub fn service_specific_credential_id(
            mut self,
            inp: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.service_specific_credential_id(inp);
            self
        }
        pub fn set_service_specific_credential_id(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_service_specific_credential_id(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ResyncMFADevice {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::resync_mfa_device_input::Builder,
    }
    impl ResyncMFADevice {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::ResyncMFADeviceOutput,
            smithy_http::result::SdkError<crate::error::ResyncMFADeviceError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the user whose MFA device you want to resynchronize.</p>
        /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
        /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
        pub fn user_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.user_name(inp);
            self
        }
        pub fn set_user_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_user_name(inp);
            self
        }
        /// <p>Serial number that uniquely identifies the MFA device.</p>
        /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
        /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
        pub fn serial_number(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.serial_number(inp);
            self
        }
        pub fn set_serial_number(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_serial_number(inp);
            self
        }
        /// <p>An authentication code emitted by the device.</p>
        /// <p>The format for this parameter is a sequence of six digits.</p>
        pub fn authentication_code1(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.authentication_code1(inp);
            self
        }
        pub fn set_authentication_code1(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_authentication_code1(inp);
            self
        }
        /// <p>A subsequent authentication code emitted by the device.</p>
        /// <p>The format for this parameter is a sequence of six digits.</p>
        pub fn authentication_code2(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.authentication_code2(inp);
            self
        }
        pub fn set_authentication_code2(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_authentication_code2(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct SetDefaultPolicyVersion {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::set_default_policy_version_input::Builder,
    }
    impl SetDefaultPolicyVersion {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::SetDefaultPolicyVersionOutput,
            smithy_http::result::SdkError<crate::error::SetDefaultPolicyVersionError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the IAM policy whose default version you want to
        /// set.</p>
        /// <p>For more information about ARNs, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">Amazon Resource Names (ARNs)</a> in the <i>AWS General Reference</i>.</p>
        pub fn policy_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.policy_arn(inp);
            self
        }
        pub fn set_policy_arn(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_policy_arn(inp);
            self
        }
        /// <p>The version of the policy to set as the default (operative) version.</p>
        /// <p>For more information about managed policy versions, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/policies-managed-versions.html">Versioning for managed
        /// policies</a> in the <i>IAM User Guide</i>.</p>
        pub fn version_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.version_id(inp);
            self
        }
        pub fn set_version_id(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_version_id(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct SetSecurityTokenServicePreferences {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::set_security_token_service_preferences_input::Builder,
    }
    impl SetSecurityTokenServicePreferences {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::SetSecurityTokenServicePreferencesOutput,
            smithy_http::result::SdkError<crate::error::SetSecurityTokenServicePreferencesError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The version of the global endpoint token. Version 1 tokens are valid only in AWS
        /// Regions that are available by default. These tokens do not work in manually enabled
        /// Regions, such as Asia Pacific (Hong Kong). Version 2 tokens are valid in all Regions.
        /// However, version 2 tokens are longer and might affect systems where you temporarily
        /// store tokens.</p>
        /// <p>For information, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_temp_enable-regions.html">Activating and
        /// deactivating STS in an AWS region</a> in the
        /// <i>IAM User Guide</i>.</p>
        pub fn global_endpoint_token_version(
            mut self,
            inp: crate::model::GlobalEndpointTokenVersion,
        ) -> Self {
            self.inner = self.inner.global_endpoint_token_version(inp);
            self
        }
        pub fn set_global_endpoint_token_version(
            mut self,
            inp: std::option::Option<crate::model::GlobalEndpointTokenVersion>,
        ) -> Self {
            self.inner = self.inner.set_global_endpoint_token_version(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct SimulateCustomPolicy {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::simulate_custom_policy_input::Builder,
    }
    impl SimulateCustomPolicy {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::SimulateCustomPolicyOutput,
            smithy_http::result::SdkError<crate::error::SimulateCustomPolicyError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>A list of policy documents to include in the simulation. Each document is specified as
        /// a string containing the complete, valid JSON text of an IAM policy. Do not include any
        /// resource-based policies in this parameter. Any resource-based policy must be submitted
        /// with the <code>ResourcePolicy</code> parameter. The policies cannot be "scope-down"
        /// policies, such as you could include in a call to <a href="https://docs.aws.amazon.com/IAM/latest/APIReference/API_GetFederationToken.html">GetFederationToken</a> or one of
        /// the <a href="https://docs.aws.amazon.com/IAM/latest/APIReference/API_AssumeRole.html">AssumeRole</a> API operations. In other words, do not use policies designed to
        /// restrict what a user can do while using the temporary credentials.</p>
        /// <p>The <a href="http://wikipedia.org/wiki/regex">regex pattern</a>
        /// used to validate this parameter is a string of characters consisting of the following:</p>
        /// <ul>
        /// <li>
        /// <p>Any printable ASCII
        /// character ranging from the space character (<code>\u0020</code>) through the end of the ASCII character range</p>
        /// </li>
        /// <li>
        /// <p>The printable characters in the Basic Latin and  Latin-1 Supplement character set
        /// (through <code>\u00FF</code>)</p>
        /// </li>
        /// <li>
        /// <p>The special characters tab (<code>\u0009</code>), line feed (<code>\u000A</code>), and
        /// carriage return (<code>\u000D</code>)</p>
        /// </li>
        /// </ul>
        pub fn policy_input_list(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.policy_input_list(inp);
            self
        }
        pub fn set_policy_input_list(
            mut self,
            inp: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_policy_input_list(inp);
            self
        }
        /// <p>The IAM permissions boundary policy to simulate. The permissions boundary sets the
        /// maximum permissions that an IAM entity can have. You can input only one permissions
        /// boundary when you pass a policy to this operation. For more information about
        /// permissions boundaries, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies_boundaries.html">Permissions boundaries for IAM
        /// entities</a> in the <i>IAM User Guide</i>. The policy input is
        /// specified as a string that contains the complete, valid JSON text of a permissions
        /// boundary policy.</p>
        /// <p>The <a href="http://wikipedia.org/wiki/regex">regex pattern</a>
        /// used to validate this parameter is a string of characters consisting of the following:</p>
        /// <ul>
        /// <li>
        /// <p>Any printable ASCII
        /// character ranging from the space character (<code>\u0020</code>) through the end of the ASCII character range</p>
        /// </li>
        /// <li>
        /// <p>The printable characters in the Basic Latin and  Latin-1 Supplement character set
        /// (through <code>\u00FF</code>)</p>
        /// </li>
        /// <li>
        /// <p>The special characters tab (<code>\u0009</code>), line feed (<code>\u000A</code>), and
        /// carriage return (<code>\u000D</code>)</p>
        /// </li>
        /// </ul>
        pub fn permissions_boundary_policy_input_list(
            mut self,
            inp: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.permissions_boundary_policy_input_list(inp);
            self
        }
        pub fn set_permissions_boundary_policy_input_list(
            mut self,
            inp: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_permissions_boundary_policy_input_list(inp);
            self
        }
        /// <p>A list of names of API operations to evaluate in the simulation. Each operation is
        /// evaluated against each resource. Each operation must include the service identifier,
        /// such as <code>iam:CreateUser</code>. This operation does not support using wildcards (*)
        /// in an action name.</p>
        pub fn action_names(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.action_names(inp);
            self
        }
        pub fn set_action_names(
            mut self,
            inp: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_action_names(inp);
            self
        }
        /// <p>A list of ARNs of AWS resources to include in the simulation. If this parameter is
        /// not provided, then the value defaults to <code>*</code> (all resources). Each API in the
        /// <code>ActionNames</code> parameter is evaluated for each resource in this list. The
        /// simulation determines the access result (allowed or denied) of each combination and
        /// reports it in the response. You can simulate resources that don't exist in your
        /// account.</p>
        /// <p>The simulation does not automatically retrieve policies for the specified resources.
        /// If you want to include a resource policy in the simulation, then you must include the
        /// policy as a string in the <code>ResourcePolicy</code> parameter.</p>
        /// <p>If you include a <code>ResourcePolicy</code>, then it must be applicable to all of the
        /// resources included in the simulation or you receive an invalid input error.</p>
        /// <p>For more information about ARNs, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">Amazon Resource Names (ARNs)</a> in the <i>AWS General Reference</i>.</p>
        pub fn resource_arns(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resource_arns(inp);
            self
        }
        pub fn set_resource_arns(
            mut self,
            inp: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_resource_arns(inp);
            self
        }
        /// <p>A resource-based policy to include in the simulation provided as a string. Each
        /// resource in the simulation is treated as if it had this policy attached. You can include
        /// only one resource-based policy in a simulation.</p>
        /// <p>The <a href="http://wikipedia.org/wiki/regex">regex pattern</a>
        /// used to validate this parameter is a string of characters consisting of the following:</p>
        /// <ul>
        /// <li>
        /// <p>Any printable ASCII
        /// character ranging from the space character (<code>\u0020</code>) through the end of the ASCII character range</p>
        /// </li>
        /// <li>
        /// <p>The printable characters in the Basic Latin and  Latin-1 Supplement character set
        /// (through <code>\u00FF</code>)</p>
        /// </li>
        /// <li>
        /// <p>The special characters tab (<code>\u0009</code>), line feed (<code>\u000A</code>), and
        /// carriage return (<code>\u000D</code>)</p>
        /// </li>
        /// </ul>
        pub fn resource_policy(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resource_policy(inp);
            self
        }
        pub fn set_resource_policy(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_resource_policy(inp);
            self
        }
        /// <p>An ARN representing the AWS account ID that specifies the owner of any simulated
        /// resource that does not identify its owner in the resource ARN. Examples of resource ARNs
        /// include an S3 bucket or object. If <code>ResourceOwner</code> is specified, it is also
        /// used as the account owner of any <code>ResourcePolicy</code> included in the simulation.
        /// If the <code>ResourceOwner</code> parameter is not specified, then the owner of the
        /// resources and the resource policy defaults to the account of the identity provided in
        /// <code>CallerArn</code>. This parameter is required only if you specify a
        /// resource-based policy and account that owns the resource is different from the account
        /// that owns the simulated calling user <code>CallerArn</code>.</p>
        /// <p>The ARN for an account uses the following syntax:
        /// <code>arn:aws:iam::<i>AWS-account-ID</i>:root</code>. For example,
        /// to represent the account with the 112233445566 ID, use the following ARN:
        /// <code>arn:aws:iam::112233445566-ID:root</code>. </p>
        pub fn resource_owner(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resource_owner(inp);
            self
        }
        pub fn set_resource_owner(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_resource_owner(inp);
            self
        }
        /// <p>The ARN of the IAM user that you want to use as the simulated caller of the API
        /// operations. <code>CallerArn</code> is required if you include a
        /// <code>ResourcePolicy</code> so that the policy's <code>Principal</code> element has
        /// a value to use in evaluating the policy.</p>
        /// <p>You can specify only the ARN of an IAM user. You cannot specify the ARN of an
        /// assumed role, federated user, or a service principal.</p>
        pub fn caller_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.caller_arn(inp);
            self
        }
        pub fn set_caller_arn(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_caller_arn(inp);
            self
        }
        /// <p>A list of context keys and corresponding values for the simulation to use. Whenever a
        /// context key is evaluated in one of the simulated IAM permissions policies, the
        /// corresponding value is supplied.</p>
        pub fn context_entries(mut self, inp: impl Into<crate::model::ContextEntry>) -> Self {
            self.inner = self.inner.context_entries(inp);
            self
        }
        pub fn set_context_entries(
            mut self,
            inp: std::option::Option<std::vec::Vec<crate::model::ContextEntry>>,
        ) -> Self {
            self.inner = self.inner.set_context_entries(inp);
            self
        }
        /// <p>Specifies the type of simulation to run. Different API operations that support
        /// resource-based policies require different combinations of resources. By specifying the
        /// type of simulation to run, you enable the policy simulator to enforce the presence of
        /// the required resources to ensure reliable simulation results. If your simulation does
        /// not match one of the following scenarios, then you can omit this parameter. The
        /// following list shows each of the supported scenario values and the resources that you
        /// must define to run the simulation.</p>
        /// <p>Each of the EC2 scenarios requires that you specify instance, image, and
        /// security-group resources. If your scenario includes an EBS volume, then you must specify
        /// that volume as a resource. If the EC2 scenario includes VPC, then you must supply the
        /// network-interface resource. If it includes an IP subnet, then you must specify the
        /// subnet resource. For more information on the EC2 scenario options, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-supported-platforms.html">Supported platforms</a> in the <i>Amazon EC2 User
        /// Guide</i>.</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <b>EC2-Classic-InstanceStore</b>
        /// </p>
        /// <p>instance, image, security-group</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>EC2-Classic-EBS</b>
        /// </p>
        /// <p>instance, image, security-group, volume</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>EC2-VPC-InstanceStore</b>
        /// </p>
        /// <p>instance, image, security-group, network-interface</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>EC2-VPC-InstanceStore-Subnet</b>
        /// </p>
        /// <p>instance, image, security-group, network-interface, subnet</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>EC2-VPC-EBS</b>
        /// </p>
        /// <p>instance, image, security-group, network-interface, volume</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>EC2-VPC-EBS-Subnet</b>
        /// </p>
        /// <p>instance, image, security-group, network-interface, subnet, volume</p>
        /// </li>
        /// </ul>
        pub fn resource_handling_option(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resource_handling_option(inp);
            self
        }
        pub fn set_resource_handling_option(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_resource_handling_option(inp);
            self
        }
        /// <p>Use this only when paginating results to indicate the
        /// maximum number of items you want in the response. If additional items exist beyond the maximum
        /// you specify, the <code>IsTruncated</code> response element is <code>true</code>.</p>
        /// <p>If you do not include this parameter, the number of items defaults to 100. Note that
        /// IAM might return fewer results, even when there are more results available. In that case, the
        /// <code>IsTruncated</code> response element returns <code>true</code>, and <code>Marker</code>
        /// contains a value to include in the subsequent call that tells the service where to continue
        /// from.</p>
        pub fn max_items(mut self, inp: i32) -> Self {
            self.inner = self.inner.max_items(inp);
            self
        }
        pub fn set_max_items(mut self, inp: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_items(inp);
            self
        }
        /// <p>Use this parameter only when paginating results and only after
        /// you receive a response indicating that the results are truncated. Set it to the value of the
        /// <code>Marker</code> element in the response that you received to indicate where the next call
        /// should start.</p>
        pub fn marker(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.marker(inp);
            self
        }
        pub fn set_marker(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_marker(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct SimulatePrincipalPolicy {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::simulate_principal_policy_input::Builder,
    }
    impl SimulatePrincipalPolicy {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::SimulatePrincipalPolicyOutput,
            smithy_http::result::SdkError<crate::error::SimulatePrincipalPolicyError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of a user, group, or role whose policies you want to
        /// include in the simulation. If you specify a user, group, or role, the simulation
        /// includes all policies that are associated with that entity. If you specify a user, the
        /// simulation also includes all policies that are attached to any groups the user belongs
        /// to.</p>
        /// <p>For more information about ARNs, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">Amazon Resource Names (ARNs)</a> in the <i>AWS General Reference</i>.</p>
        pub fn policy_source_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.policy_source_arn(inp);
            self
        }
        pub fn set_policy_source_arn(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_policy_source_arn(inp);
            self
        }
        /// <p>An optional list of additional policy documents to include in the simulation. Each
        /// document is specified as a string containing the complete, valid JSON text of an IAM
        /// policy.</p>
        /// <p>The <a href="http://wikipedia.org/wiki/regex">regex pattern</a>
        /// used to validate this parameter is a string of characters consisting of the following:</p>
        /// <ul>
        /// <li>
        /// <p>Any printable ASCII
        /// character ranging from the space character (<code>\u0020</code>) through the end of the ASCII character range</p>
        /// </li>
        /// <li>
        /// <p>The printable characters in the Basic Latin and  Latin-1 Supplement character set
        /// (through <code>\u00FF</code>)</p>
        /// </li>
        /// <li>
        /// <p>The special characters tab (<code>\u0009</code>), line feed (<code>\u000A</code>), and
        /// carriage return (<code>\u000D</code>)</p>
        /// </li>
        /// </ul>
        pub fn policy_input_list(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.policy_input_list(inp);
            self
        }
        pub fn set_policy_input_list(
            mut self,
            inp: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_policy_input_list(inp);
            self
        }
        /// <p>The IAM permissions boundary policy to simulate. The permissions boundary sets the
        /// maximum permissions that the entity can have. You can input only one permissions
        /// boundary when you pass a policy to this operation. An IAM entity can only have one
        /// permissions boundary in effect at a time. For example, if a permissions boundary is
        /// attached to an entity and you pass in a different permissions boundary policy using this
        /// parameter, then the new permissions boundary policy is used for the simulation. For more
        /// information about permissions boundaries, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies_boundaries.html">Permissions boundaries for IAM
        /// entities</a> in the <i>IAM User Guide</i>. The policy input is
        /// specified as a string containing the complete, valid JSON text of a permissions boundary
        /// policy.</p>
        /// <p>The <a href="http://wikipedia.org/wiki/regex">regex pattern</a>
        /// used to validate this parameter is a string of characters consisting of the following:</p>
        /// <ul>
        /// <li>
        /// <p>Any printable ASCII
        /// character ranging from the space character (<code>\u0020</code>) through the end of the ASCII character range</p>
        /// </li>
        /// <li>
        /// <p>The printable characters in the Basic Latin and  Latin-1 Supplement character set
        /// (through <code>\u00FF</code>)</p>
        /// </li>
        /// <li>
        /// <p>The special characters tab (<code>\u0009</code>), line feed (<code>\u000A</code>), and
        /// carriage return (<code>\u000D</code>)</p>
        /// </li>
        /// </ul>
        pub fn permissions_boundary_policy_input_list(
            mut self,
            inp: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.permissions_boundary_policy_input_list(inp);
            self
        }
        pub fn set_permissions_boundary_policy_input_list(
            mut self,
            inp: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_permissions_boundary_policy_input_list(inp);
            self
        }
        /// <p>A list of names of API operations to evaluate in the simulation. Each operation is
        /// evaluated for each resource. Each operation must include the service identifier, such as
        /// <code>iam:CreateUser</code>.</p>
        pub fn action_names(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.action_names(inp);
            self
        }
        pub fn set_action_names(
            mut self,
            inp: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_action_names(inp);
            self
        }
        /// <p>A list of ARNs of AWS resources to include in the simulation. If this parameter is
        /// not provided, then the value defaults to <code>*</code> (all resources). Each API in the
        /// <code>ActionNames</code> parameter is evaluated for each resource in this list. The
        /// simulation determines the access result (allowed or denied) of each combination and
        /// reports it in the response. You can simulate resources that don't exist in your
        /// account.</p>
        /// <p>The simulation does not automatically retrieve policies for the specified resources.
        /// If you want to include a resource policy in the simulation, then you must include the
        /// policy as a string in the <code>ResourcePolicy</code> parameter.</p>
        /// <p>For more information about ARNs, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">Amazon Resource Names (ARNs)</a> in the <i>AWS General Reference</i>.</p>
        pub fn resource_arns(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resource_arns(inp);
            self
        }
        pub fn set_resource_arns(
            mut self,
            inp: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_resource_arns(inp);
            self
        }
        /// <p>A resource-based policy to include in the simulation provided as a string. Each
        /// resource in the simulation is treated as if it had this policy attached. You can include
        /// only one resource-based policy in a simulation.</p>
        /// <p>The <a href="http://wikipedia.org/wiki/regex">regex pattern</a>
        /// used to validate this parameter is a string of characters consisting of the following:</p>
        /// <ul>
        /// <li>
        /// <p>Any printable ASCII
        /// character ranging from the space character (<code>\u0020</code>) through the end of the ASCII character range</p>
        /// </li>
        /// <li>
        /// <p>The printable characters in the Basic Latin and  Latin-1 Supplement character set
        /// (through <code>\u00FF</code>)</p>
        /// </li>
        /// <li>
        /// <p>The special characters tab (<code>\u0009</code>), line feed (<code>\u000A</code>), and
        /// carriage return (<code>\u000D</code>)</p>
        /// </li>
        /// </ul>
        pub fn resource_policy(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resource_policy(inp);
            self
        }
        pub fn set_resource_policy(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_resource_policy(inp);
            self
        }
        /// <p>An AWS account ID that specifies the owner of any simulated resource that does not
        /// identify its owner in the resource ARN. Examples of resource ARNs include an S3 bucket
        /// or object. If <code>ResourceOwner</code> is specified, it is also used as the account
        /// owner of any <code>ResourcePolicy</code> included in the simulation. If the
        /// <code>ResourceOwner</code> parameter is not specified, then the owner of the
        /// resources and the resource policy defaults to the account of the identity provided in
        /// <code>CallerArn</code>. This parameter is required only if you specify a
        /// resource-based policy and account that owns the resource is different from the account
        /// that owns the simulated calling user <code>CallerArn</code>.</p>
        pub fn resource_owner(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resource_owner(inp);
            self
        }
        pub fn set_resource_owner(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_resource_owner(inp);
            self
        }
        /// <p>The ARN of the IAM user that you want to specify as the simulated caller of the API
        /// operations. If you do not specify a <code>CallerArn</code>, it defaults to the ARN of
        /// the user that you specify in <code>PolicySourceArn</code>, if you specified a user. If
        /// you include both a <code>PolicySourceArn</code> (for example,
        /// <code>arn:aws:iam::123456789012:user/David</code>) and a <code>CallerArn</code> (for
        /// example, <code>arn:aws:iam::123456789012:user/Bob</code>), the result is that you
        /// simulate calling the API operations as Bob, as if Bob had David's policies.</p>
        /// <p>You can specify only the ARN of an IAM user. You cannot specify the ARN of an
        /// assumed role, federated user, or a service principal.</p>
        /// <p>
        /// <code>CallerArn</code> is required if you include a <code>ResourcePolicy</code> and
        /// the <code>PolicySourceArn</code> is not the ARN for an IAM user. This is required so
        /// that the resource-based policy's <code>Principal</code> element has a value to use in
        /// evaluating the policy.</p>
        /// <p>For more information about ARNs, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">Amazon Resource Names (ARNs)</a> in the <i>AWS General Reference</i>.</p>
        pub fn caller_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.caller_arn(inp);
            self
        }
        pub fn set_caller_arn(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_caller_arn(inp);
            self
        }
        /// <p>A list of context keys and corresponding values for the simulation to use. Whenever a
        /// context key is evaluated in one of the simulated IAM permissions policies, the
        /// corresponding value is supplied.</p>
        pub fn context_entries(mut self, inp: impl Into<crate::model::ContextEntry>) -> Self {
            self.inner = self.inner.context_entries(inp);
            self
        }
        pub fn set_context_entries(
            mut self,
            inp: std::option::Option<std::vec::Vec<crate::model::ContextEntry>>,
        ) -> Self {
            self.inner = self.inner.set_context_entries(inp);
            self
        }
        /// <p>Specifies the type of simulation to run. Different API operations that support
        /// resource-based policies require different combinations of resources. By specifying the
        /// type of simulation to run, you enable the policy simulator to enforce the presence of
        /// the required resources to ensure reliable simulation results. If your simulation does
        /// not match one of the following scenarios, then you can omit this parameter. The
        /// following list shows each of the supported scenario values and the resources that you
        /// must define to run the simulation.</p>
        /// <p>Each of the EC2 scenarios requires that you specify instance, image, and security
        /// group resources. If your scenario includes an EBS volume, then you must specify that
        /// volume as a resource. If the EC2 scenario includes VPC, then you must supply the network
        /// interface resource. If it includes an IP subnet, then you must specify the subnet
        /// resource. For more information on the EC2 scenario options, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-supported-platforms.html">Supported platforms</a> in the <i>Amazon EC2 User
        /// Guide</i>.</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <b>EC2-Classic-InstanceStore</b>
        /// </p>
        /// <p>instance, image, security group</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>EC2-Classic-EBS</b>
        /// </p>
        /// <p>instance, image, security group, volume</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>EC2-VPC-InstanceStore</b>
        /// </p>
        /// <p>instance, image, security group, network interface</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>EC2-VPC-InstanceStore-Subnet</b>
        /// </p>
        /// <p>instance, image, security group, network interface, subnet</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>EC2-VPC-EBS</b>
        /// </p>
        /// <p>instance, image, security group, network interface, volume</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>EC2-VPC-EBS-Subnet</b>
        /// </p>
        /// <p>instance, image, security group, network interface, subnet, volume</p>
        /// </li>
        /// </ul>
        pub fn resource_handling_option(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resource_handling_option(inp);
            self
        }
        pub fn set_resource_handling_option(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_resource_handling_option(inp);
            self
        }
        /// <p>Use this only when paginating results to indicate the
        /// maximum number of items you want in the response. If additional items exist beyond the maximum
        /// you specify, the <code>IsTruncated</code> response element is <code>true</code>.</p>
        /// <p>If you do not include this parameter, the number of items defaults to 100. Note that
        /// IAM might return fewer results, even when there are more results available. In that case, the
        /// <code>IsTruncated</code> response element returns <code>true</code>, and <code>Marker</code>
        /// contains a value to include in the subsequent call that tells the service where to continue
        /// from.</p>
        pub fn max_items(mut self, inp: i32) -> Self {
            self.inner = self.inner.max_items(inp);
            self
        }
        pub fn set_max_items(mut self, inp: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_items(inp);
            self
        }
        /// <p>Use this parameter only when paginating results and only after
        /// you receive a response indicating that the results are truncated. Set it to the value of the
        /// <code>Marker</code> element in the response that you received to indicate where the next call
        /// should start.</p>
        pub fn marker(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.marker(inp);
            self
        }
        pub fn set_marker(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_marker(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct TagInstanceProfile {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::tag_instance_profile_input::Builder,
    }
    impl TagInstanceProfile {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::TagInstanceProfileOutput,
            smithy_http::result::SdkError<crate::error::TagInstanceProfileError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the IAM instance profile to which you want to add tags.</p>
        /// <p>This parameter accepts (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters that consist of upper and lowercase alphanumeric
        /// characters with no spaces. You can also include any of the following characters: =,.@-</p>
        pub fn instance_profile_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.instance_profile_name(inp);
            self
        }
        pub fn set_instance_profile_name(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_instance_profile_name(inp);
            self
        }
        /// <p>The list of tags that you want to attach to the IAM instance profile.
        /// Each tag consists of a key name and an associated value.</p>
        pub fn tags(mut self, inp: impl Into<crate::model::Tag>) -> Self {
            self.inner = self.inner.tags(inp);
            self
        }
        pub fn set_tags(
            mut self,
            inp: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.inner = self.inner.set_tags(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct TagMFADevice {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::tag_mfa_device_input::Builder,
    }
    impl TagMFADevice {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::TagMFADeviceOutput,
            smithy_http::result::SdkError<crate::error::TagMFADeviceError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The unique identifier for the IAM virtual MFA device to which you want to add tags.
        /// For virtual MFA devices, the serial number is the same as the ARN.</p>
        /// <p>This parameter accepts (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters that consist of upper and lowercase alphanumeric
        /// characters with no spaces. You can also include any of the following characters: =,.@-</p>
        pub fn serial_number(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.serial_number(inp);
            self
        }
        pub fn set_serial_number(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_serial_number(inp);
            self
        }
        /// <p>The list of tags that you want to attach to the IAM virtual MFA device.
        /// Each tag consists of a key name and an associated value.</p>
        pub fn tags(mut self, inp: impl Into<crate::model::Tag>) -> Self {
            self.inner = self.inner.tags(inp);
            self
        }
        pub fn set_tags(
            mut self,
            inp: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.inner = self.inner.set_tags(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct TagOpenIDConnectProvider {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::tag_open_id_connect_provider_input::Builder,
    }
    impl TagOpenIDConnectProvider {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::TagOpenIDConnectProviderOutput,
            smithy_http::result::SdkError<crate::error::TagOpenIDConnectProviderError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ARN of the OIDC identity provider in IAM to which you want to add tags.</p>
        /// <p>This parameter accepts (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters that consist of upper and lowercase alphanumeric
        /// characters with no spaces. You can also include any of the following characters: =,.@-</p>
        pub fn open_id_connect_provider_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.open_id_connect_provider_arn(inp);
            self
        }
        pub fn set_open_id_connect_provider_arn(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_open_id_connect_provider_arn(inp);
            self
        }
        /// <p>The list of tags that you want to attach to the OIDC identity provider in IAM.
        /// Each tag consists of a key name and an associated value.</p>
        pub fn tags(mut self, inp: impl Into<crate::model::Tag>) -> Self {
            self.inner = self.inner.tags(inp);
            self
        }
        pub fn set_tags(
            mut self,
            inp: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.inner = self.inner.set_tags(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct TagPolicy {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::tag_policy_input::Builder,
    }
    impl TagPolicy {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::TagPolicyOutput,
            smithy_http::result::SdkError<crate::error::TagPolicyError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ARN of the IAM customer managed policy to which you want to add tags.</p>
        /// <p>This parameter accepts (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters that consist of upper and lowercase alphanumeric
        /// characters with no spaces. You can also include any of the following characters: =,.@-</p>
        pub fn policy_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.policy_arn(inp);
            self
        }
        pub fn set_policy_arn(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_policy_arn(inp);
            self
        }
        /// <p>The list of tags that you want to attach to the IAM customer managed policy.
        /// Each tag consists of a key name and an associated value.</p>
        pub fn tags(mut self, inp: impl Into<crate::model::Tag>) -> Self {
            self.inner = self.inner.tags(inp);
            self
        }
        pub fn set_tags(
            mut self,
            inp: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.inner = self.inner.set_tags(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct TagRole {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::tag_role_input::Builder,
    }
    impl TagRole {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::TagRoleOutput,
            smithy_http::result::SdkError<crate::error::TagRoleError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the IAM role to which you want to add tags.</p>
        /// <p>This parameter accepts (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters that consist of upper and lowercase alphanumeric
        /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
        pub fn role_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.role_name(inp);
            self
        }
        pub fn set_role_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_role_name(inp);
            self
        }
        /// <p>The list of tags that you want to attach to the IAM role. Each tag consists of a key name and an associated value.</p>
        pub fn tags(mut self, inp: impl Into<crate::model::Tag>) -> Self {
            self.inner = self.inner.tags(inp);
            self
        }
        pub fn set_tags(
            mut self,
            inp: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.inner = self.inner.set_tags(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct TagSAMLProvider {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::tag_saml_provider_input::Builder,
    }
    impl TagSAMLProvider {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::TagSAMLProviderOutput,
            smithy_http::result::SdkError<crate::error::TagSAMLProviderError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ARN of the SAML identity provider in IAM to which you want to add tags.</p>
        /// <p>This parameter accepts (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters that consist of upper and lowercase alphanumeric
        /// characters with no spaces. You can also include any of the following characters: =,.@-</p>
        pub fn saml_provider_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.saml_provider_arn(inp);
            self
        }
        pub fn set_saml_provider_arn(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_saml_provider_arn(inp);
            self
        }
        /// <p>The list of tags that you want to attach to the SAML identity provider in IAM.
        /// Each tag consists of a key name and an associated value.</p>
        pub fn tags(mut self, inp: impl Into<crate::model::Tag>) -> Self {
            self.inner = self.inner.tags(inp);
            self
        }
        pub fn set_tags(
            mut self,
            inp: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.inner = self.inner.set_tags(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct TagServerCertificate {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::tag_server_certificate_input::Builder,
    }
    impl TagServerCertificate {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::TagServerCertificateOutput,
            smithy_http::result::SdkError<crate::error::TagServerCertificateError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the IAM server certificate to which you want to add tags.</p>
        /// <p>This parameter accepts (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters that consist of upper and lowercase alphanumeric
        /// characters with no spaces. You can also include any of the following characters: =,.@-</p>
        pub fn server_certificate_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.server_certificate_name(inp);
            self
        }
        pub fn set_server_certificate_name(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_server_certificate_name(inp);
            self
        }
        /// <p>The list of tags that you want to attach to the IAM server certificate.
        /// Each tag consists of a key name and an associated value.</p>
        pub fn tags(mut self, inp: impl Into<crate::model::Tag>) -> Self {
            self.inner = self.inner.tags(inp);
            self
        }
        pub fn set_tags(
            mut self,
            inp: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.inner = self.inner.set_tags(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct TagUser {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::tag_user_input::Builder,
    }
    impl TagUser {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::TagUserOutput,
            smithy_http::result::SdkError<crate::error::TagUserError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the IAM user to which you want to add tags.</p>
        /// <p>This parameter accepts (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters that consist of upper and lowercase alphanumeric
        /// characters with no spaces. You can also include any of the following characters: =,.@-</p>
        pub fn user_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.user_name(inp);
            self
        }
        pub fn set_user_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_user_name(inp);
            self
        }
        /// <p>The list of tags that you want to attach to the IAM user. Each tag consists of a key name and an associated value.</p>
        pub fn tags(mut self, inp: impl Into<crate::model::Tag>) -> Self {
            self.inner = self.inner.tags(inp);
            self
        }
        pub fn set_tags(
            mut self,
            inp: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.inner = self.inner.set_tags(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UntagInstanceProfile {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::untag_instance_profile_input::Builder,
    }
    impl UntagInstanceProfile {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::UntagInstanceProfileOutput,
            smithy_http::result::SdkError<crate::error::UntagInstanceProfileError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the IAM instance profile from which you want to remove tags.</p>
        /// <p>This parameter accepts (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters that consist of upper and lowercase alphanumeric
        /// characters with no spaces. You can also include any of the following characters: =,.@-</p>
        pub fn instance_profile_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.instance_profile_name(inp);
            self
        }
        pub fn set_instance_profile_name(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_instance_profile_name(inp);
            self
        }
        /// <p>A list of key names as a simple array of strings. The tags with matching keys are
        /// removed from the specified instance profile.</p>
        pub fn tag_keys(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.tag_keys(inp);
            self
        }
        pub fn set_tag_keys(
            mut self,
            inp: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_tag_keys(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UntagMFADevice {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::untag_mfa_device_input::Builder,
    }
    impl UntagMFADevice {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::UntagMFADeviceOutput,
            smithy_http::result::SdkError<crate::error::UntagMFADeviceError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The unique identifier for the IAM virtual MFA device from which you want to remove
        /// tags. For virtual MFA devices, the serial number is the same as the ARN.</p>
        /// <p>This parameter accepts (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters that consist of upper and lowercase alphanumeric
        /// characters with no spaces. You can also include any of the following characters: =,.@-</p>
        pub fn serial_number(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.serial_number(inp);
            self
        }
        pub fn set_serial_number(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_serial_number(inp);
            self
        }
        /// <p>A list of key names as a simple array of strings. The tags with matching keys are
        /// removed from the specified instance profile.</p>
        pub fn tag_keys(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.tag_keys(inp);
            self
        }
        pub fn set_tag_keys(
            mut self,
            inp: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_tag_keys(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UntagOpenIDConnectProvider {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::untag_open_id_connect_provider_input::Builder,
    }
    impl UntagOpenIDConnectProvider {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::UntagOpenIDConnectProviderOutput,
            smithy_http::result::SdkError<crate::error::UntagOpenIDConnectProviderError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ARN of the OIDC provider in IAM from which you want to remove tags.</p>
        /// <p>This parameter accepts (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters that consist of upper and lowercase alphanumeric
        /// characters with no spaces. You can also include any of the following characters: =,.@-</p>
        pub fn open_id_connect_provider_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.open_id_connect_provider_arn(inp);
            self
        }
        pub fn set_open_id_connect_provider_arn(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_open_id_connect_provider_arn(inp);
            self
        }
        /// <p>A list of key names as a simple array of strings. The tags with matching keys are
        /// removed from the specified OIDC provider.</p>
        pub fn tag_keys(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.tag_keys(inp);
            self
        }
        pub fn set_tag_keys(
            mut self,
            inp: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_tag_keys(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UntagPolicy {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::untag_policy_input::Builder,
    }
    impl UntagPolicy {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::UntagPolicyOutput,
            smithy_http::result::SdkError<crate::error::UntagPolicyError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ARN of the IAM customer managed policy from which you want to remove
        /// tags.</p>
        /// <p>This parameter accepts (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters that consist of upper and lowercase alphanumeric
        /// characters with no spaces. You can also include any of the following characters: =,.@-</p>
        pub fn policy_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.policy_arn(inp);
            self
        }
        pub fn set_policy_arn(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_policy_arn(inp);
            self
        }
        /// <p>A list of key names as a simple array of strings. The tags with matching keys are
        /// removed from the specified policy.</p>
        pub fn tag_keys(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.tag_keys(inp);
            self
        }
        pub fn set_tag_keys(
            mut self,
            inp: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_tag_keys(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UntagRole {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::untag_role_input::Builder,
    }
    impl UntagRole {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::UntagRoleOutput,
            smithy_http::result::SdkError<crate::error::UntagRoleError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the IAM role from which you want to remove tags.</p>
        /// <p>This parameter accepts (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters that consist of upper and lowercase alphanumeric
        /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
        pub fn role_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.role_name(inp);
            self
        }
        pub fn set_role_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_role_name(inp);
            self
        }
        /// <p>A list of key names as a simple array of strings. The tags with matching keys are
        /// removed from the specified role.</p>
        pub fn tag_keys(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.tag_keys(inp);
            self
        }
        pub fn set_tag_keys(
            mut self,
            inp: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_tag_keys(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UntagSAMLProvider {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::untag_saml_provider_input::Builder,
    }
    impl UntagSAMLProvider {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::UntagSAMLProviderOutput,
            smithy_http::result::SdkError<crate::error::UntagSAMLProviderError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ARN of the SAML identity provider in IAM from which you want to remove
        /// tags.</p>
        /// <p>This parameter accepts (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters that consist of upper and lowercase alphanumeric
        /// characters with no spaces. You can also include any of the following characters: =,.@-</p>
        pub fn saml_provider_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.saml_provider_arn(inp);
            self
        }
        pub fn set_saml_provider_arn(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_saml_provider_arn(inp);
            self
        }
        /// <p>A list of key names as a simple array of strings. The tags with matching keys are
        /// removed from the specified SAML identity provider.</p>
        pub fn tag_keys(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.tag_keys(inp);
            self
        }
        pub fn set_tag_keys(
            mut self,
            inp: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_tag_keys(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UntagServerCertificate {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::untag_server_certificate_input::Builder,
    }
    impl UntagServerCertificate {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::UntagServerCertificateOutput,
            smithy_http::result::SdkError<crate::error::UntagServerCertificateError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the IAM server certificate from which you want to remove tags.</p>
        /// <p>This parameter accepts (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters that consist of upper and lowercase alphanumeric
        /// characters with no spaces. You can also include any of the following characters: =,.@-</p>
        pub fn server_certificate_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.server_certificate_name(inp);
            self
        }
        pub fn set_server_certificate_name(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_server_certificate_name(inp);
            self
        }
        /// <p>A list of key names as a simple array of strings. The tags with matching keys are
        /// removed from the specified IAM server certificate.</p>
        pub fn tag_keys(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.tag_keys(inp);
            self
        }
        pub fn set_tag_keys(
            mut self,
            inp: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_tag_keys(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UntagUser {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::untag_user_input::Builder,
    }
    impl UntagUser {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::UntagUserOutput,
            smithy_http::result::SdkError<crate::error::UntagUserError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the IAM user from which you want to remove tags.</p>
        /// <p>This parameter accepts (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters that consist of upper and lowercase alphanumeric
        /// characters with no spaces. You can also include any of the following characters: =,.@-</p>
        pub fn user_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.user_name(inp);
            self
        }
        pub fn set_user_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_user_name(inp);
            self
        }
        /// <p>A list of key names as a simple array of strings. The tags with matching keys are
        /// removed from the specified user.</p>
        pub fn tag_keys(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.tag_keys(inp);
            self
        }
        pub fn set_tag_keys(
            mut self,
            inp: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_tag_keys(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateAccessKey {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::update_access_key_input::Builder,
    }
    impl UpdateAccessKey {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::UpdateAccessKeyOutput,
            smithy_http::result::SdkError<crate::error::UpdateAccessKeyError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the user whose key you want to update.</p>
        /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
        /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
        pub fn user_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.user_name(inp);
            self
        }
        pub fn set_user_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_user_name(inp);
            self
        }
        /// <p>The access key ID of the secret access key you want to update.</p>
        /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters that can
        /// consist of any upper or lowercased letter or digit.</p>
        pub fn access_key_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.access_key_id(inp);
            self
        }
        pub fn set_access_key_id(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_access_key_id(inp);
            self
        }
        /// <p> The status you want to assign to the secret access key. <code>Active</code> means
        /// that the key can be used for programmatic calls to AWS, while <code>Inactive</code>
        /// means that the key cannot be used.</p>
        pub fn status(mut self, inp: crate::model::StatusType) -> Self {
            self.inner = self.inner.status(inp);
            self
        }
        pub fn set_status(mut self, inp: std::option::Option<crate::model::StatusType>) -> Self {
            self.inner = self.inner.set_status(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateAccountPasswordPolicy {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::update_account_password_policy_input::Builder,
    }
    impl UpdateAccountPasswordPolicy {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::UpdateAccountPasswordPolicyOutput,
            smithy_http::result::SdkError<crate::error::UpdateAccountPasswordPolicyError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The minimum number of characters allowed in an IAM user password.</p>
        /// <p>If you do not specify a value for this parameter, then the operation uses the default
        /// value of <code>6</code>.</p>
        pub fn minimum_password_length(mut self, inp: i32) -> Self {
            self.inner = self.inner.minimum_password_length(inp);
            self
        }
        pub fn set_minimum_password_length(mut self, inp: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_minimum_password_length(inp);
            self
        }
        /// <p>Specifies whether IAM user passwords must contain at least one of the following
        /// non-alphanumeric characters:</p>
        /// <p>! @ # $ % ^ & * ( ) _ + - = [ ] { } | '</p>
        /// <p>If you do not specify a value for this parameter, then the operation uses the default
        /// value of <code>false</code>. The result is that passwords do not require at least one
        /// symbol character.</p>
        pub fn require_symbols(mut self, inp: bool) -> Self {
            self.inner = self.inner.require_symbols(inp);
            self
        }
        pub fn set_require_symbols(mut self, inp: bool) -> Self {
            self.inner = self.inner.set_require_symbols(inp);
            self
        }
        /// <p>Specifies whether IAM user passwords must contain at least one numeric character (0
        /// to 9).</p>
        /// <p>If you do not specify a value for this parameter, then the operation uses the default
        /// value of <code>false</code>. The result is that passwords do not require at least one
        /// numeric character.</p>
        pub fn require_numbers(mut self, inp: bool) -> Self {
            self.inner = self.inner.require_numbers(inp);
            self
        }
        pub fn set_require_numbers(mut self, inp: bool) -> Self {
            self.inner = self.inner.set_require_numbers(inp);
            self
        }
        /// <p>Specifies whether IAM user passwords must contain at least one uppercase character
        /// from the ISO basic Latin alphabet (A to Z).</p>
        /// <p>If you do not specify a value for this parameter, then the operation uses the default
        /// value of <code>false</code>. The result is that passwords do not require at least one
        /// uppercase character.</p>
        pub fn require_uppercase_characters(mut self, inp: bool) -> Self {
            self.inner = self.inner.require_uppercase_characters(inp);
            self
        }
        pub fn set_require_uppercase_characters(mut self, inp: bool) -> Self {
            self.inner = self.inner.set_require_uppercase_characters(inp);
            self
        }
        /// <p>Specifies whether IAM user passwords must contain at least one lowercase character
        /// from the ISO basic Latin alphabet (a to z).</p>
        /// <p>If you do not specify a value for this parameter, then the operation uses the default
        /// value of <code>false</code>. The result is that passwords do not require at least one
        /// lowercase character.</p>
        pub fn require_lowercase_characters(mut self, inp: bool) -> Self {
            self.inner = self.inner.require_lowercase_characters(inp);
            self
        }
        pub fn set_require_lowercase_characters(mut self, inp: bool) -> Self {
            self.inner = self.inner.set_require_lowercase_characters(inp);
            self
        }
        /// <p> Allows all IAM users in your account to use the AWS Management Console to change their own
        /// passwords. For more information, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/HowToPwdIAMUser.html">Letting IAM users change their own
        /// passwords</a> in the <i>IAM User Guide</i>.</p>
        /// <p>If you do not specify a value for this parameter, then the operation uses the default
        /// value of <code>false</code>. The result is that IAM users in the account do not
        /// automatically have permissions to change their own password.</p>
        pub fn allow_users_to_change_password(mut self, inp: bool) -> Self {
            self.inner = self.inner.allow_users_to_change_password(inp);
            self
        }
        pub fn set_allow_users_to_change_password(mut self, inp: bool) -> Self {
            self.inner = self.inner.set_allow_users_to_change_password(inp);
            self
        }
        /// <p>The number of days that an IAM user password is valid.</p>
        /// <p>If you do not specify a value for this parameter, then the operation uses the default
        /// value of <code>0</code>. The result is that IAM user passwords never expire.</p>
        pub fn max_password_age(mut self, inp: i32) -> Self {
            self.inner = self.inner.max_password_age(inp);
            self
        }
        pub fn set_max_password_age(mut self, inp: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_password_age(inp);
            self
        }
        /// <p>Specifies the number of previous passwords that IAM users are prevented from
        /// reusing.</p>
        /// <p>If you do not specify a value for this parameter, then the operation uses the default
        /// value of <code>0</code>. The result is that IAM users are not prevented from reusing
        /// previous passwords.</p>
        pub fn password_reuse_prevention(mut self, inp: i32) -> Self {
            self.inner = self.inner.password_reuse_prevention(inp);
            self
        }
        pub fn set_password_reuse_prevention(mut self, inp: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_password_reuse_prevention(inp);
            self
        }
        /// <p>Prevents IAM users from setting a new password after their password has expired. The
        /// IAM user cannot be accessed until an administrator resets the password.</p>
        /// <p>If you do not specify a value for this parameter, then the operation uses the default
        /// value of <code>false</code>. The result is that IAM users can change their passwords
        /// after they expire and continue to sign in as the user.</p>
        pub fn hard_expiry(mut self, inp: bool) -> Self {
            self.inner = self.inner.hard_expiry(inp);
            self
        }
        pub fn set_hard_expiry(mut self, inp: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_hard_expiry(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateAssumeRolePolicy {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::update_assume_role_policy_input::Builder,
    }
    impl UpdateAssumeRolePolicy {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::UpdateAssumeRolePolicyOutput,
            smithy_http::result::SdkError<crate::error::UpdateAssumeRolePolicyError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the role to update with the new policy.</p>
        /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
        /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
        pub fn role_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.role_name(inp);
            self
        }
        pub fn set_role_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_role_name(inp);
            self
        }
        /// <p>The policy that grants an entity permission to assume the role.</p>
        /// <p>You must provide policies in JSON format in IAM. However, for AWS CloudFormation
        /// templates formatted in YAML, you can provide the policy in JSON or YAML format. AWS
        /// CloudFormation always converts a YAML policy to JSON format before submitting it to
        /// IAM.</p>
        /// <p>The <a href="http://wikipedia.org/wiki/regex">regex pattern</a>
        /// used to validate this parameter is a string of characters consisting of the following:</p>
        /// <ul>
        /// <li>
        /// <p>Any printable ASCII
        /// character ranging from the space character (<code>\u0020</code>) through the end of the ASCII character range</p>
        /// </li>
        /// <li>
        /// <p>The printable characters in the Basic Latin and  Latin-1 Supplement character set
        /// (through <code>\u00FF</code>)</p>
        /// </li>
        /// <li>
        /// <p>The special characters tab (<code>\u0009</code>), line feed (<code>\u000A</code>), and
        /// carriage return (<code>\u000D</code>)</p>
        /// </li>
        /// </ul>
        pub fn policy_document(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.policy_document(inp);
            self
        }
        pub fn set_policy_document(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_policy_document(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateGroup {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::update_group_input::Builder,
    }
    impl UpdateGroup {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::UpdateGroupOutput,
            smithy_http::result::SdkError<crate::error::UpdateGroupError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Name of the IAM group to update. If you're changing the name of the group, this is
        /// the original name.</p>
        /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
        /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
        pub fn group_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.group_name(inp);
            self
        }
        pub fn set_group_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_group_name(inp);
            self
        }
        /// <p>New path for the IAM group. Only include this if changing the group's path.</p>
        /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting
        /// of either a forward slash (/) by itself or a string that must begin and end with forward slashes.
        /// In addition, it can contain any ASCII character from the ! (<code>\u0021</code>) through the DEL character (<code>\u007F</code>), including
        /// most punctuation characters, digits, and upper and lowercased letters.</p>
        pub fn new_path(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.new_path(inp);
            self
        }
        pub fn set_new_path(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_new_path(inp);
            self
        }
        /// <p>New name for the IAM group. Only include this if changing the group's name.</p>
        /// <p>IAM user, group, role, and policy names must be unique within the account. Names are
        /// not distinguished by case. For example, you cannot create resources named both
        /// "MyResource" and "myresource".</p>
        pub fn new_group_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.new_group_name(inp);
            self
        }
        pub fn set_new_group_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_new_group_name(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateLoginProfile {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::update_login_profile_input::Builder,
    }
    impl UpdateLoginProfile {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::UpdateLoginProfileOutput,
            smithy_http::result::SdkError<crate::error::UpdateLoginProfileError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the user whose password you want to update.</p>
        /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
        /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
        pub fn user_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.user_name(inp);
            self
        }
        pub fn set_user_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_user_name(inp);
            self
        }
        /// <p>The new password for the specified IAM user.</p>
        /// <p>The <a href="http://wikipedia.org/wiki/regex">regex pattern</a>
        /// used to validate this parameter is a string of characters consisting of the following:</p>
        /// <ul>
        /// <li>
        /// <p>Any printable ASCII
        /// character ranging from the space character (<code>\u0020</code>) through the end of the ASCII character range</p>
        /// </li>
        /// <li>
        /// <p>The printable characters in the Basic Latin and  Latin-1 Supplement character set
        /// (through <code>\u00FF</code>)</p>
        /// </li>
        /// <li>
        /// <p>The special characters tab (<code>\u0009</code>), line feed (<code>\u000A</code>), and
        /// carriage return (<code>\u000D</code>)</p>
        /// </li>
        /// </ul>
        /// <p>However, the format can be further restricted by the account administrator by setting
        /// a password policy on the AWS account. For more information, see <a>UpdateAccountPasswordPolicy</a>.</p>
        pub fn password(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.password(inp);
            self
        }
        pub fn set_password(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_password(inp);
            self
        }
        /// <p>Allows this new password to be used only once by requiring the specified IAM user to
        /// set a new password on next sign-in.</p>
        pub fn password_reset_required(mut self, inp: bool) -> Self {
            self.inner = self.inner.password_reset_required(inp);
            self
        }
        pub fn set_password_reset_required(mut self, inp: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_password_reset_required(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateOpenIDConnectProviderThumbprint {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::update_open_id_connect_provider_thumbprint_input::Builder,
    }
    impl UpdateOpenIDConnectProviderThumbprint {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::UpdateOpenIDConnectProviderThumbprintOutput,
            smithy_http::result::SdkError<crate::error::UpdateOpenIDConnectProviderThumbprintError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the IAM OIDC provider resource object for which
        /// you want to update the thumbprint. You can get a list of OIDC provider ARNs by using the
        /// <a>ListOpenIDConnectProviders</a> operation.</p>
        /// <p>For more information about ARNs, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">Amazon Resource Names (ARNs)</a> in the <i>AWS General Reference</i>.</p>
        pub fn open_id_connect_provider_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.open_id_connect_provider_arn(inp);
            self
        }
        pub fn set_open_id_connect_provider_arn(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_open_id_connect_provider_arn(inp);
            self
        }
        /// <p>A list of certificate thumbprints that are associated with the specified IAM OpenID
        /// Connect provider. For more information, see <a>CreateOpenIDConnectProvider</a>. </p>
        pub fn thumbprint_list(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.thumbprint_list(inp);
            self
        }
        pub fn set_thumbprint_list(
            mut self,
            inp: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_thumbprint_list(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateRole {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::update_role_input::Builder,
    }
    impl UpdateRole {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::UpdateRoleOutput,
            smithy_http::result::SdkError<crate::error::UpdateRoleError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the role that you want to modify.</p>
        pub fn role_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.role_name(inp);
            self
        }
        pub fn set_role_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_role_name(inp);
            self
        }
        /// <p>The new description that you want to apply to the specified role.</p>
        pub fn description(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.description(inp);
            self
        }
        pub fn set_description(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_description(inp);
            self
        }
        /// <p>The maximum session duration (in seconds) that you want to set for the specified role.
        /// If you do not specify a value for this setting, the default maximum of one hour is
        /// applied. This setting can have a value from 1 hour to 12 hours.</p>
        /// <p>Anyone who assumes the role from the AWS CLI or API can use the
        /// <code>DurationSeconds</code> API parameter or the <code>duration-seconds</code> CLI
        /// parameter to request a longer session. The <code>MaxSessionDuration</code> setting
        /// determines the maximum duration that can be requested using the
        /// <code>DurationSeconds</code> parameter. If users don't specify a value for the
        /// <code>DurationSeconds</code> parameter, their security credentials are valid for one
        /// hour by default. This applies when you use the <code>AssumeRole*</code> API operations
        /// or the <code>assume-role*</code> CLI operations but does not apply when you use those
        /// operations to create a console URL. For more information, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_use.html">Using IAM
        /// roles</a> in the <i>IAM User Guide</i>.</p>
        pub fn max_session_duration(mut self, inp: i32) -> Self {
            self.inner = self.inner.max_session_duration(inp);
            self
        }
        pub fn set_max_session_duration(mut self, inp: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_session_duration(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateRoleDescription {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::update_role_description_input::Builder,
    }
    impl UpdateRoleDescription {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::UpdateRoleDescriptionOutput,
            smithy_http::result::SdkError<crate::error::UpdateRoleDescriptionError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the role that you want to modify.</p>
        pub fn role_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.role_name(inp);
            self
        }
        pub fn set_role_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_role_name(inp);
            self
        }
        /// <p>The new description that you want to apply to the specified role.</p>
        pub fn description(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.description(inp);
            self
        }
        pub fn set_description(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_description(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateSAMLProvider {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::update_saml_provider_input::Builder,
    }
    impl UpdateSAMLProvider {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::UpdateSAMLProviderOutput,
            smithy_http::result::SdkError<crate::error::UpdateSAMLProviderError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>An XML document generated by an identity provider (IdP) that supports SAML 2.0. The
        /// document includes the issuer's name, expiration information, and keys that can be used
        /// to validate the SAML authentication response (assertions) that are received from the
        /// IdP. You must generate the metadata document using the identity management software that
        /// is used as your organization's IdP.</p>
        pub fn saml_metadata_document(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.saml_metadata_document(inp);
            self
        }
        pub fn set_saml_metadata_document(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_saml_metadata_document(inp);
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the SAML provider to update.</p>
        /// <p>For more information about ARNs, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">Amazon Resource Names (ARNs)</a> in the <i>AWS General Reference</i>.</p>
        pub fn saml_provider_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.saml_provider_arn(inp);
            self
        }
        pub fn set_saml_provider_arn(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_saml_provider_arn(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateServerCertificate {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::update_server_certificate_input::Builder,
    }
    impl UpdateServerCertificate {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::UpdateServerCertificateOutput,
            smithy_http::result::SdkError<crate::error::UpdateServerCertificateError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the server certificate that you want to update.</p>
        /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
        /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
        pub fn server_certificate_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.server_certificate_name(inp);
            self
        }
        pub fn set_server_certificate_name(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_server_certificate_name(inp);
            self
        }
        /// <p>The new path for the server certificate. Include this only if you are updating the
        /// server certificate's path.</p>
        /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting
        /// of either a forward slash (/) by itself or a string that must begin and end with forward slashes.
        /// In addition, it can contain any ASCII character from the ! (<code>\u0021</code>) through the DEL character (<code>\u007F</code>), including
        /// most punctuation characters, digits, and upper and lowercased letters.</p>
        pub fn new_path(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.new_path(inp);
            self
        }
        pub fn set_new_path(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_new_path(inp);
            self
        }
        /// <p>The new name for the server certificate. Include this only if you are updating the
        /// server certificate's name. The name of the certificate cannot contain any spaces.</p>
        /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
        /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
        pub fn new_server_certificate_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.new_server_certificate_name(inp);
            self
        }
        pub fn set_new_server_certificate_name(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_new_server_certificate_name(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateServiceSpecificCredential {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::update_service_specific_credential_input::Builder,
    }
    impl UpdateServiceSpecificCredential {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::UpdateServiceSpecificCredentialOutput,
            smithy_http::result::SdkError<crate::error::UpdateServiceSpecificCredentialError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the IAM user associated with the service-specific credential. If you do
        /// not specify this value, then the operation assumes the user whose credentials are used
        /// to call the operation.</p>
        /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
        /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
        pub fn user_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.user_name(inp);
            self
        }
        pub fn set_user_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_user_name(inp);
            self
        }
        /// <p>The unique identifier of the service-specific credential.</p>
        /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters that can
        /// consist of any upper or lowercased letter or digit.</p>
        pub fn service_specific_credential_id(
            mut self,
            inp: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.service_specific_credential_id(inp);
            self
        }
        pub fn set_service_specific_credential_id(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_service_specific_credential_id(inp);
            self
        }
        /// <p>The status to be assigned to the service-specific credential.</p>
        pub fn status(mut self, inp: crate::model::StatusType) -> Self {
            self.inner = self.inner.status(inp);
            self
        }
        pub fn set_status(mut self, inp: std::option::Option<crate::model::StatusType>) -> Self {
            self.inner = self.inner.set_status(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateSigningCertificate {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::update_signing_certificate_input::Builder,
    }
    impl UpdateSigningCertificate {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::UpdateSigningCertificateOutput,
            smithy_http::result::SdkError<crate::error::UpdateSigningCertificateError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the IAM user the signing certificate belongs to.</p>
        /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
        /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
        pub fn user_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.user_name(inp);
            self
        }
        pub fn set_user_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_user_name(inp);
            self
        }
        /// <p>The ID of the signing certificate you want to update.</p>
        /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters that can
        /// consist of any upper or lowercased letter or digit.</p>
        pub fn certificate_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.certificate_id(inp);
            self
        }
        pub fn set_certificate_id(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_certificate_id(inp);
            self
        }
        /// <p> The status you want to assign to the certificate. <code>Active</code> means that the
        /// certificate can be used for programmatic calls to AWS <code>Inactive</code> means that
        /// the certificate cannot be used.</p>
        pub fn status(mut self, inp: crate::model::StatusType) -> Self {
            self.inner = self.inner.status(inp);
            self
        }
        pub fn set_status(mut self, inp: std::option::Option<crate::model::StatusType>) -> Self {
            self.inner = self.inner.set_status(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateSSHPublicKey {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::update_ssh_public_key_input::Builder,
    }
    impl UpdateSSHPublicKey {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::UpdateSSHPublicKeyOutput,
            smithy_http::result::SdkError<crate::error::UpdateSSHPublicKeyError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the IAM user associated with the SSH public key.</p>
        /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
        /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
        pub fn user_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.user_name(inp);
            self
        }
        pub fn set_user_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_user_name(inp);
            self
        }
        /// <p>The unique identifier for the SSH public key.</p>
        /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters that can
        /// consist of any upper or lowercased letter or digit.</p>
        pub fn ssh_public_key_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.ssh_public_key_id(inp);
            self
        }
        pub fn set_ssh_public_key_id(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_ssh_public_key_id(inp);
            self
        }
        /// <p>The status to assign to the SSH public key. <code>Active</code> means that the key can
        /// be used for authentication with an AWS CodeCommit repository. <code>Inactive</code> means that
        /// the key cannot be used.</p>
        pub fn status(mut self, inp: crate::model::StatusType) -> Self {
            self.inner = self.inner.status(inp);
            self
        }
        pub fn set_status(mut self, inp: std::option::Option<crate::model::StatusType>) -> Self {
            self.inner = self.inner.set_status(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateUser {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::update_user_input::Builder,
    }
    impl UpdateUser {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::UpdateUserOutput,
            smithy_http::result::SdkError<crate::error::UpdateUserError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Name of the user to update. If you're changing the name of the user, this is the
        /// original user name.</p>
        /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
        /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
        pub fn user_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.user_name(inp);
            self
        }
        pub fn set_user_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_user_name(inp);
            self
        }
        /// <p>New path for the IAM user. Include this parameter only if you're changing the user's
        /// path.</p>
        /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting
        /// of either a forward slash (/) by itself or a string that must begin and end with forward slashes.
        /// In addition, it can contain any ASCII character from the ! (<code>\u0021</code>) through the DEL character (<code>\u007F</code>), including
        /// most punctuation characters, digits, and upper and lowercased letters.</p>
        pub fn new_path(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.new_path(inp);
            self
        }
        pub fn set_new_path(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_new_path(inp);
            self
        }
        /// <p>New name for the user. Include this parameter only if you're changing the user's
        /// name.</p>
        /// <p>IAM user, group, role, and policy names must be unique within the account. Names are
        /// not distinguished by case. For example, you cannot create resources named both
        /// "MyResource" and "myresource".</p>
        pub fn new_user_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.new_user_name(inp);
            self
        }
        pub fn set_new_user_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_new_user_name(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UploadServerCertificate {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::upload_server_certificate_input::Builder,
    }
    impl UploadServerCertificate {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::UploadServerCertificateOutput,
            smithy_http::result::SdkError<crate::error::UploadServerCertificateError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The path for the server certificate. For more information about paths, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html">IAM
        /// identifiers</a> in the <i>IAM User Guide</i>.</p>
        /// <p>This parameter is optional. If it is not included, it defaults to a slash (/).
        /// This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting
        /// of either a forward slash (/) by itself or a string that must begin and end with forward slashes.
        /// In addition, it can contain any ASCII character from the ! (<code>\u0021</code>) through the DEL character (<code>\u007F</code>), including
        /// most punctuation characters, digits, and upper and lowercased letters.</p>
        /// <note>
        /// <p> If you are uploading a server certificate specifically for use with Amazon
        /// CloudFront distributions, you must specify a path using the <code>path</code>
        /// parameter. The path must begin with <code>/cloudfront</code> and must include a
        /// trailing slash (for example, <code>/cloudfront/test/</code>).</p>
        /// </note>
        pub fn path(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.path(inp);
            self
        }
        pub fn set_path(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_path(inp);
            self
        }
        /// <p>The name for the server certificate. Do not include the path in this value. The name
        /// of the certificate cannot contain any spaces.</p>
        /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
        /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
        pub fn server_certificate_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.server_certificate_name(inp);
            self
        }
        pub fn set_server_certificate_name(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_server_certificate_name(inp);
            self
        }
        /// <p>The contents of the public key certificate in PEM-encoded format.</p>
        /// <p>The <a href="http://wikipedia.org/wiki/regex">regex pattern</a>
        /// used to validate this parameter is a string of characters consisting of the following:</p>
        /// <ul>
        /// <li>
        /// <p>Any printable ASCII
        /// character ranging from the space character (<code>\u0020</code>) through the end of the ASCII character range</p>
        /// </li>
        /// <li>
        /// <p>The printable characters in the Basic Latin and  Latin-1 Supplement character set
        /// (through <code>\u00FF</code>)</p>
        /// </li>
        /// <li>
        /// <p>The special characters tab (<code>\u0009</code>), line feed (<code>\u000A</code>), and
        /// carriage return (<code>\u000D</code>)</p>
        /// </li>
        /// </ul>
        pub fn certificate_body(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.certificate_body(inp);
            self
        }
        pub fn set_certificate_body(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_certificate_body(inp);
            self
        }
        /// <p>The contents of the private key in PEM-encoded format.</p>
        /// <p>The <a href="http://wikipedia.org/wiki/regex">regex pattern</a>
        /// used to validate this parameter is a string of characters consisting of the following:</p>
        /// <ul>
        /// <li>
        /// <p>Any printable ASCII
        /// character ranging from the space character (<code>\u0020</code>) through the end of the ASCII character range</p>
        /// </li>
        /// <li>
        /// <p>The printable characters in the Basic Latin and  Latin-1 Supplement character set
        /// (through <code>\u00FF</code>)</p>
        /// </li>
        /// <li>
        /// <p>The special characters tab (<code>\u0009</code>), line feed (<code>\u000A</code>), and
        /// carriage return (<code>\u000D</code>)</p>
        /// </li>
        /// </ul>
        pub fn private_key(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.private_key(inp);
            self
        }
        pub fn set_private_key(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_private_key(inp);
            self
        }
        /// <p>The contents of the certificate chain. This is typically a concatenation of the
        /// PEM-encoded public key certificates of the chain.</p>
        /// <p>The <a href="http://wikipedia.org/wiki/regex">regex pattern</a>
        /// used to validate this parameter is a string of characters consisting of the following:</p>
        /// <ul>
        /// <li>
        /// <p>Any printable ASCII
        /// character ranging from the space character (<code>\u0020</code>) through the end of the ASCII character range</p>
        /// </li>
        /// <li>
        /// <p>The printable characters in the Basic Latin and  Latin-1 Supplement character set
        /// (through <code>\u00FF</code>)</p>
        /// </li>
        /// <li>
        /// <p>The special characters tab (<code>\u0009</code>), line feed (<code>\u000A</code>), and
        /// carriage return (<code>\u000D</code>)</p>
        /// </li>
        /// </ul>
        pub fn certificate_chain(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.certificate_chain(inp);
            self
        }
        pub fn set_certificate_chain(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_certificate_chain(inp);
            self
        }
        /// <p>A list of tags that you want to attach to the new IAM server certificate resource.
        /// Each tag consists of a key name and an associated value. For more information about tagging, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_tags.html">Tagging IAM resources</a> in the
        /// <i>IAM User Guide</i>.</p>
        /// <note>
        /// <p>If any one of the tags is invalid or if you exceed the allowed maximum number of tags, then the entire request
        /// fails and the resource is not created.</p>
        /// </note>
        pub fn tags(mut self, inp: impl Into<crate::model::Tag>) -> Self {
            self.inner = self.inner.tags(inp);
            self
        }
        pub fn set_tags(
            mut self,
            inp: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.inner = self.inner.set_tags(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UploadSigningCertificate {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::upload_signing_certificate_input::Builder,
    }
    impl UploadSigningCertificate {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::UploadSigningCertificateOutput,
            smithy_http::result::SdkError<crate::error::UploadSigningCertificateError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the user the signing certificate is for.</p>
        /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
        /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
        pub fn user_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.user_name(inp);
            self
        }
        pub fn set_user_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_user_name(inp);
            self
        }
        /// <p>The contents of the signing certificate.</p>
        /// <p>The <a href="http://wikipedia.org/wiki/regex">regex pattern</a>
        /// used to validate this parameter is a string of characters consisting of the following:</p>
        /// <ul>
        /// <li>
        /// <p>Any printable ASCII
        /// character ranging from the space character (<code>\u0020</code>) through the end of the ASCII character range</p>
        /// </li>
        /// <li>
        /// <p>The printable characters in the Basic Latin and  Latin-1 Supplement character set
        /// (through <code>\u00FF</code>)</p>
        /// </li>
        /// <li>
        /// <p>The special characters tab (<code>\u0009</code>), line feed (<code>\u000A</code>), and
        /// carriage return (<code>\u000D</code>)</p>
        /// </li>
        /// </ul>
        pub fn certificate_body(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.certificate_body(inp);
            self
        }
        pub fn set_certificate_body(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_certificate_body(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UploadSSHPublicKey {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::upload_ssh_public_key_input::Builder,
    }
    impl UploadSSHPublicKey {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::UploadSSHPublicKeyOutput,
            smithy_http::result::SdkError<crate::error::UploadSSHPublicKeyError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the IAM user to associate the SSH public key with.</p>
        /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
        /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
        pub fn user_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.user_name(inp);
            self
        }
        pub fn set_user_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_user_name(inp);
            self
        }
        /// <p>The SSH public key. The public key must be encoded in ssh-rsa format or PEM format.
        /// The minimum bit-length of the public key is 2048 bits. For example, you can generate a
        /// 2048-bit key, and the resulting PEM file is 1679 bytes long.</p>
        /// <p>The <a href="http://wikipedia.org/wiki/regex">regex pattern</a>
        /// used to validate this parameter is a string of characters consisting of the following:</p>
        /// <ul>
        /// <li>
        /// <p>Any printable ASCII
        /// character ranging from the space character (<code>\u0020</code>) through the end of the ASCII character range</p>
        /// </li>
        /// <li>
        /// <p>The printable characters in the Basic Latin and  Latin-1 Supplement character set
        /// (through <code>\u00FF</code>)</p>
        /// </li>
        /// <li>
        /// <p>The special characters tab (<code>\u0009</code>), line feed (<code>\u000A</code>), and
        /// carriage return (<code>\u000D</code>)</p>
        /// </li>
        /// </ul>
        pub fn ssh_public_key_body(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.ssh_public_key_body(inp);
            self
        }
        pub fn set_ssh_public_key_body(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_ssh_public_key_body(inp);
            self
        }
    }
}
