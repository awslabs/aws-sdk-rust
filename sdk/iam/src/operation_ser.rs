// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
pub fn serialize_operation_crate_operation_add_client_id_to_open_id_connect_provider(
    input: &crate::input::AddClientIdToOpenIdConnectProviderInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(
        &mut out,
        "AddClientIDToOpenIDConnectProvider",
        "2010-05-08",
    );
    #[allow(unused_mut)]
    let mut scope_1 = writer.prefix("OpenIDConnectProviderArn");
    if let Some(var_2) = &input.open_id_connect_provider_arn {
        scope_1.string(var_2);
    }
    #[allow(unused_mut)]
    let mut scope_3 = writer.prefix("ClientID");
    if let Some(var_4) = &input.client_id {
        scope_3.string(var_4);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_add_role_to_instance_profile(
    input: &crate::input::AddRoleToInstanceProfileInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "AddRoleToInstanceProfile", "2010-05-08");
    #[allow(unused_mut)]
    let mut scope_5 = writer.prefix("InstanceProfileName");
    if let Some(var_6) = &input.instance_profile_name {
        scope_5.string(var_6);
    }
    #[allow(unused_mut)]
    let mut scope_7 = writer.prefix("RoleName");
    if let Some(var_8) = &input.role_name {
        scope_7.string(var_8);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_add_user_to_group(
    input: &crate::input::AddUserToGroupInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "AddUserToGroup", "2010-05-08");
    #[allow(unused_mut)]
    let mut scope_9 = writer.prefix("GroupName");
    if let Some(var_10) = &input.group_name {
        scope_9.string(var_10);
    }
    #[allow(unused_mut)]
    let mut scope_11 = writer.prefix("UserName");
    if let Some(var_12) = &input.user_name {
        scope_11.string(var_12);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_attach_group_policy(
    input: &crate::input::AttachGroupPolicyInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "AttachGroupPolicy", "2010-05-08");
    #[allow(unused_mut)]
    let mut scope_13 = writer.prefix("GroupName");
    if let Some(var_14) = &input.group_name {
        scope_13.string(var_14);
    }
    #[allow(unused_mut)]
    let mut scope_15 = writer.prefix("PolicyArn");
    if let Some(var_16) = &input.policy_arn {
        scope_15.string(var_16);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_attach_role_policy(
    input: &crate::input::AttachRolePolicyInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "AttachRolePolicy", "2010-05-08");
    #[allow(unused_mut)]
    let mut scope_17 = writer.prefix("RoleName");
    if let Some(var_18) = &input.role_name {
        scope_17.string(var_18);
    }
    #[allow(unused_mut)]
    let mut scope_19 = writer.prefix("PolicyArn");
    if let Some(var_20) = &input.policy_arn {
        scope_19.string(var_20);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_attach_user_policy(
    input: &crate::input::AttachUserPolicyInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "AttachUserPolicy", "2010-05-08");
    #[allow(unused_mut)]
    let mut scope_21 = writer.prefix("UserName");
    if let Some(var_22) = &input.user_name {
        scope_21.string(var_22);
    }
    #[allow(unused_mut)]
    let mut scope_23 = writer.prefix("PolicyArn");
    if let Some(var_24) = &input.policy_arn {
        scope_23.string(var_24);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_change_password(
    input: &crate::input::ChangePasswordInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "ChangePassword", "2010-05-08");
    #[allow(unused_mut)]
    let mut scope_25 = writer.prefix("OldPassword");
    if let Some(var_26) = &input.old_password {
        scope_25.string(var_26);
    }
    #[allow(unused_mut)]
    let mut scope_27 = writer.prefix("NewPassword");
    if let Some(var_28) = &input.new_password {
        scope_27.string(var_28);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_create_access_key(
    input: &crate::input::CreateAccessKeyInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "CreateAccessKey", "2010-05-08");
    #[allow(unused_mut)]
    let mut scope_29 = writer.prefix("UserName");
    if let Some(var_30) = &input.user_name {
        scope_29.string(var_30);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_create_account_alias(
    input: &crate::input::CreateAccountAliasInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "CreateAccountAlias", "2010-05-08");
    #[allow(unused_mut)]
    let mut scope_31 = writer.prefix("AccountAlias");
    if let Some(var_32) = &input.account_alias {
        scope_31.string(var_32);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_create_group(
    input: &crate::input::CreateGroupInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "CreateGroup", "2010-05-08");
    #[allow(unused_mut)]
    let mut scope_33 = writer.prefix("Path");
    if let Some(var_34) = &input.path {
        scope_33.string(var_34);
    }
    #[allow(unused_mut)]
    let mut scope_35 = writer.prefix("GroupName");
    if let Some(var_36) = &input.group_name {
        scope_35.string(var_36);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_create_instance_profile(
    input: &crate::input::CreateInstanceProfileInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "CreateInstanceProfile", "2010-05-08");
    #[allow(unused_mut)]
    let mut scope_37 = writer.prefix("InstanceProfileName");
    if let Some(var_38) = &input.instance_profile_name {
        scope_37.string(var_38);
    }
    #[allow(unused_mut)]
    let mut scope_39 = writer.prefix("Path");
    if let Some(var_40) = &input.path {
        scope_39.string(var_40);
    }
    #[allow(unused_mut)]
    let mut scope_41 = writer.prefix("Tags");
    if let Some(var_42) = &input.tags {
        let mut list_44 = scope_41.start_list(false, None);
        for item_43 in var_42 {
            #[allow(unused_mut)]
            let mut entry_45 = list_44.entry();
            crate::query_ser::serialize_structure_crate_model_tag(entry_45, item_43);
        }
        list_44.finish();
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_create_login_profile(
    input: &crate::input::CreateLoginProfileInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "CreateLoginProfile", "2010-05-08");
    #[allow(unused_mut)]
    let mut scope_46 = writer.prefix("UserName");
    if let Some(var_47) = &input.user_name {
        scope_46.string(var_47);
    }
    #[allow(unused_mut)]
    let mut scope_48 = writer.prefix("Password");
    if let Some(var_49) = &input.password {
        scope_48.string(var_49);
    }
    #[allow(unused_mut)]
    let mut scope_50 = writer.prefix("PasswordResetRequired");
    if input.password_reset_required {
        scope_50.boolean(input.password_reset_required);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_create_open_id_connect_provider(
    input: &crate::input::CreateOpenIdConnectProviderInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "CreateOpenIDConnectProvider", "2010-05-08");
    #[allow(unused_mut)]
    let mut scope_51 = writer.prefix("Url");
    if let Some(var_52) = &input.url {
        scope_51.string(var_52);
    }
    #[allow(unused_mut)]
    let mut scope_53 = writer.prefix("ClientIDList");
    if let Some(var_54) = &input.client_id_list {
        let mut list_56 = scope_53.start_list(false, None);
        for item_55 in var_54 {
            #[allow(unused_mut)]
            let mut entry_57 = list_56.entry();
            entry_57.string(item_55);
        }
        list_56.finish();
    }
    #[allow(unused_mut)]
    let mut scope_58 = writer.prefix("ThumbprintList");
    if let Some(var_59) = &input.thumbprint_list {
        let mut list_61 = scope_58.start_list(false, None);
        for item_60 in var_59 {
            #[allow(unused_mut)]
            let mut entry_62 = list_61.entry();
            entry_62.string(item_60);
        }
        list_61.finish();
    }
    #[allow(unused_mut)]
    let mut scope_63 = writer.prefix("Tags");
    if let Some(var_64) = &input.tags {
        let mut list_66 = scope_63.start_list(false, None);
        for item_65 in var_64 {
            #[allow(unused_mut)]
            let mut entry_67 = list_66.entry();
            crate::query_ser::serialize_structure_crate_model_tag(entry_67, item_65);
        }
        list_66.finish();
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_create_policy(
    input: &crate::input::CreatePolicyInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "CreatePolicy", "2010-05-08");
    #[allow(unused_mut)]
    let mut scope_68 = writer.prefix("PolicyName");
    if let Some(var_69) = &input.policy_name {
        scope_68.string(var_69);
    }
    #[allow(unused_mut)]
    let mut scope_70 = writer.prefix("Path");
    if let Some(var_71) = &input.path {
        scope_70.string(var_71);
    }
    #[allow(unused_mut)]
    let mut scope_72 = writer.prefix("PolicyDocument");
    if let Some(var_73) = &input.policy_document {
        scope_72.string(var_73);
    }
    #[allow(unused_mut)]
    let mut scope_74 = writer.prefix("Description");
    if let Some(var_75) = &input.description {
        scope_74.string(var_75);
    }
    #[allow(unused_mut)]
    let mut scope_76 = writer.prefix("Tags");
    if let Some(var_77) = &input.tags {
        let mut list_79 = scope_76.start_list(false, None);
        for item_78 in var_77 {
            #[allow(unused_mut)]
            let mut entry_80 = list_79.entry();
            crate::query_ser::serialize_structure_crate_model_tag(entry_80, item_78);
        }
        list_79.finish();
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_create_policy_version(
    input: &crate::input::CreatePolicyVersionInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "CreatePolicyVersion", "2010-05-08");
    #[allow(unused_mut)]
    let mut scope_81 = writer.prefix("PolicyArn");
    if let Some(var_82) = &input.policy_arn {
        scope_81.string(var_82);
    }
    #[allow(unused_mut)]
    let mut scope_83 = writer.prefix("PolicyDocument");
    if let Some(var_84) = &input.policy_document {
        scope_83.string(var_84);
    }
    #[allow(unused_mut)]
    let mut scope_85 = writer.prefix("SetAsDefault");
    if input.set_as_default {
        scope_85.boolean(input.set_as_default);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_create_role(
    input: &crate::input::CreateRoleInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "CreateRole", "2010-05-08");
    #[allow(unused_mut)]
    let mut scope_86 = writer.prefix("Path");
    if let Some(var_87) = &input.path {
        scope_86.string(var_87);
    }
    #[allow(unused_mut)]
    let mut scope_88 = writer.prefix("RoleName");
    if let Some(var_89) = &input.role_name {
        scope_88.string(var_89);
    }
    #[allow(unused_mut)]
    let mut scope_90 = writer.prefix("AssumeRolePolicyDocument");
    if let Some(var_91) = &input.assume_role_policy_document {
        scope_90.string(var_91);
    }
    #[allow(unused_mut)]
    let mut scope_92 = writer.prefix("Description");
    if let Some(var_93) = &input.description {
        scope_92.string(var_93);
    }
    #[allow(unused_mut)]
    let mut scope_94 = writer.prefix("MaxSessionDuration");
    if let Some(var_95) = &input.max_session_duration {
        scope_94.number(
            #[allow(clippy::useless_conversion)]
            smithy_types::Number::NegInt((*var_95).into()),
        );
    }
    #[allow(unused_mut)]
    let mut scope_96 = writer.prefix("PermissionsBoundary");
    if let Some(var_97) = &input.permissions_boundary {
        scope_96.string(var_97);
    }
    #[allow(unused_mut)]
    let mut scope_98 = writer.prefix("Tags");
    if let Some(var_99) = &input.tags {
        let mut list_101 = scope_98.start_list(false, None);
        for item_100 in var_99 {
            #[allow(unused_mut)]
            let mut entry_102 = list_101.entry();
            crate::query_ser::serialize_structure_crate_model_tag(entry_102, item_100);
        }
        list_101.finish();
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_create_saml_provider(
    input: &crate::input::CreateSamlProviderInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "CreateSAMLProvider", "2010-05-08");
    #[allow(unused_mut)]
    let mut scope_103 = writer.prefix("SAMLMetadataDocument");
    if let Some(var_104) = &input.saml_metadata_document {
        scope_103.string(var_104);
    }
    #[allow(unused_mut)]
    let mut scope_105 = writer.prefix("Name");
    if let Some(var_106) = &input.name {
        scope_105.string(var_106);
    }
    #[allow(unused_mut)]
    let mut scope_107 = writer.prefix("Tags");
    if let Some(var_108) = &input.tags {
        let mut list_110 = scope_107.start_list(false, None);
        for item_109 in var_108 {
            #[allow(unused_mut)]
            let mut entry_111 = list_110.entry();
            crate::query_ser::serialize_structure_crate_model_tag(entry_111, item_109);
        }
        list_110.finish();
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_create_service_linked_role(
    input: &crate::input::CreateServiceLinkedRoleInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "CreateServiceLinkedRole", "2010-05-08");
    #[allow(unused_mut)]
    let mut scope_112 = writer.prefix("AWSServiceName");
    if let Some(var_113) = &input.aws_service_name {
        scope_112.string(var_113);
    }
    #[allow(unused_mut)]
    let mut scope_114 = writer.prefix("Description");
    if let Some(var_115) = &input.description {
        scope_114.string(var_115);
    }
    #[allow(unused_mut)]
    let mut scope_116 = writer.prefix("CustomSuffix");
    if let Some(var_117) = &input.custom_suffix {
        scope_116.string(var_117);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_create_service_specific_credential(
    input: &crate::input::CreateServiceSpecificCredentialInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "CreateServiceSpecificCredential", "2010-05-08");
    #[allow(unused_mut)]
    let mut scope_118 = writer.prefix("UserName");
    if let Some(var_119) = &input.user_name {
        scope_118.string(var_119);
    }
    #[allow(unused_mut)]
    let mut scope_120 = writer.prefix("ServiceName");
    if let Some(var_121) = &input.service_name {
        scope_120.string(var_121);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_create_user(
    input: &crate::input::CreateUserInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "CreateUser", "2010-05-08");
    #[allow(unused_mut)]
    let mut scope_122 = writer.prefix("Path");
    if let Some(var_123) = &input.path {
        scope_122.string(var_123);
    }
    #[allow(unused_mut)]
    let mut scope_124 = writer.prefix("UserName");
    if let Some(var_125) = &input.user_name {
        scope_124.string(var_125);
    }
    #[allow(unused_mut)]
    let mut scope_126 = writer.prefix("PermissionsBoundary");
    if let Some(var_127) = &input.permissions_boundary {
        scope_126.string(var_127);
    }
    #[allow(unused_mut)]
    let mut scope_128 = writer.prefix("Tags");
    if let Some(var_129) = &input.tags {
        let mut list_131 = scope_128.start_list(false, None);
        for item_130 in var_129 {
            #[allow(unused_mut)]
            let mut entry_132 = list_131.entry();
            crate::query_ser::serialize_structure_crate_model_tag(entry_132, item_130);
        }
        list_131.finish();
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_create_virtual_mfa_device(
    input: &crate::input::CreateVirtualMfaDeviceInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "CreateVirtualMFADevice", "2010-05-08");
    #[allow(unused_mut)]
    let mut scope_133 = writer.prefix("Path");
    if let Some(var_134) = &input.path {
        scope_133.string(var_134);
    }
    #[allow(unused_mut)]
    let mut scope_135 = writer.prefix("VirtualMFADeviceName");
    if let Some(var_136) = &input.virtual_mfa_device_name {
        scope_135.string(var_136);
    }
    #[allow(unused_mut)]
    let mut scope_137 = writer.prefix("Tags");
    if let Some(var_138) = &input.tags {
        let mut list_140 = scope_137.start_list(false, None);
        for item_139 in var_138 {
            #[allow(unused_mut)]
            let mut entry_141 = list_140.entry();
            crate::query_ser::serialize_structure_crate_model_tag(entry_141, item_139);
        }
        list_140.finish();
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_deactivate_mfa_device(
    input: &crate::input::DeactivateMfaDeviceInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "DeactivateMFADevice", "2010-05-08");
    #[allow(unused_mut)]
    let mut scope_142 = writer.prefix("UserName");
    if let Some(var_143) = &input.user_name {
        scope_142.string(var_143);
    }
    #[allow(unused_mut)]
    let mut scope_144 = writer.prefix("SerialNumber");
    if let Some(var_145) = &input.serial_number {
        scope_144.string(var_145);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_delete_access_key(
    input: &crate::input::DeleteAccessKeyInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "DeleteAccessKey", "2010-05-08");
    #[allow(unused_mut)]
    let mut scope_146 = writer.prefix("UserName");
    if let Some(var_147) = &input.user_name {
        scope_146.string(var_147);
    }
    #[allow(unused_mut)]
    let mut scope_148 = writer.prefix("AccessKeyId");
    if let Some(var_149) = &input.access_key_id {
        scope_148.string(var_149);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_delete_account_alias(
    input: &crate::input::DeleteAccountAliasInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "DeleteAccountAlias", "2010-05-08");
    #[allow(unused_mut)]
    let mut scope_150 = writer.prefix("AccountAlias");
    if let Some(var_151) = &input.account_alias {
        scope_150.string(var_151);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_delete_account_password_policy(
    input: &crate::input::DeleteAccountPasswordPolicyInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let _ = input;
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "DeleteAccountPasswordPolicy", "2010-05-08");
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_delete_group(
    input: &crate::input::DeleteGroupInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "DeleteGroup", "2010-05-08");
    #[allow(unused_mut)]
    let mut scope_152 = writer.prefix("GroupName");
    if let Some(var_153) = &input.group_name {
        scope_152.string(var_153);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_delete_group_policy(
    input: &crate::input::DeleteGroupPolicyInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "DeleteGroupPolicy", "2010-05-08");
    #[allow(unused_mut)]
    let mut scope_154 = writer.prefix("GroupName");
    if let Some(var_155) = &input.group_name {
        scope_154.string(var_155);
    }
    #[allow(unused_mut)]
    let mut scope_156 = writer.prefix("PolicyName");
    if let Some(var_157) = &input.policy_name {
        scope_156.string(var_157);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_delete_instance_profile(
    input: &crate::input::DeleteInstanceProfileInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "DeleteInstanceProfile", "2010-05-08");
    #[allow(unused_mut)]
    let mut scope_158 = writer.prefix("InstanceProfileName");
    if let Some(var_159) = &input.instance_profile_name {
        scope_158.string(var_159);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_delete_login_profile(
    input: &crate::input::DeleteLoginProfileInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "DeleteLoginProfile", "2010-05-08");
    #[allow(unused_mut)]
    let mut scope_160 = writer.prefix("UserName");
    if let Some(var_161) = &input.user_name {
        scope_160.string(var_161);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_delete_open_id_connect_provider(
    input: &crate::input::DeleteOpenIdConnectProviderInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "DeleteOpenIDConnectProvider", "2010-05-08");
    #[allow(unused_mut)]
    let mut scope_162 = writer.prefix("OpenIDConnectProviderArn");
    if let Some(var_163) = &input.open_id_connect_provider_arn {
        scope_162.string(var_163);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_delete_policy(
    input: &crate::input::DeletePolicyInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "DeletePolicy", "2010-05-08");
    #[allow(unused_mut)]
    let mut scope_164 = writer.prefix("PolicyArn");
    if let Some(var_165) = &input.policy_arn {
        scope_164.string(var_165);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_delete_policy_version(
    input: &crate::input::DeletePolicyVersionInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "DeletePolicyVersion", "2010-05-08");
    #[allow(unused_mut)]
    let mut scope_166 = writer.prefix("PolicyArn");
    if let Some(var_167) = &input.policy_arn {
        scope_166.string(var_167);
    }
    #[allow(unused_mut)]
    let mut scope_168 = writer.prefix("VersionId");
    if let Some(var_169) = &input.version_id {
        scope_168.string(var_169);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_delete_role(
    input: &crate::input::DeleteRoleInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "DeleteRole", "2010-05-08");
    #[allow(unused_mut)]
    let mut scope_170 = writer.prefix("RoleName");
    if let Some(var_171) = &input.role_name {
        scope_170.string(var_171);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_delete_role_permissions_boundary(
    input: &crate::input::DeleteRolePermissionsBoundaryInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "DeleteRolePermissionsBoundary", "2010-05-08");
    #[allow(unused_mut)]
    let mut scope_172 = writer.prefix("RoleName");
    if let Some(var_173) = &input.role_name {
        scope_172.string(var_173);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_delete_role_policy(
    input: &crate::input::DeleteRolePolicyInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "DeleteRolePolicy", "2010-05-08");
    #[allow(unused_mut)]
    let mut scope_174 = writer.prefix("RoleName");
    if let Some(var_175) = &input.role_name {
        scope_174.string(var_175);
    }
    #[allow(unused_mut)]
    let mut scope_176 = writer.prefix("PolicyName");
    if let Some(var_177) = &input.policy_name {
        scope_176.string(var_177);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_delete_saml_provider(
    input: &crate::input::DeleteSamlProviderInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "DeleteSAMLProvider", "2010-05-08");
    #[allow(unused_mut)]
    let mut scope_178 = writer.prefix("SAMLProviderArn");
    if let Some(var_179) = &input.saml_provider_arn {
        scope_178.string(var_179);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_delete_server_certificate(
    input: &crate::input::DeleteServerCertificateInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "DeleteServerCertificate", "2010-05-08");
    #[allow(unused_mut)]
    let mut scope_180 = writer.prefix("ServerCertificateName");
    if let Some(var_181) = &input.server_certificate_name {
        scope_180.string(var_181);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_delete_service_linked_role(
    input: &crate::input::DeleteServiceLinkedRoleInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "DeleteServiceLinkedRole", "2010-05-08");
    #[allow(unused_mut)]
    let mut scope_182 = writer.prefix("RoleName");
    if let Some(var_183) = &input.role_name {
        scope_182.string(var_183);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_delete_service_specific_credential(
    input: &crate::input::DeleteServiceSpecificCredentialInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "DeleteServiceSpecificCredential", "2010-05-08");
    #[allow(unused_mut)]
    let mut scope_184 = writer.prefix("UserName");
    if let Some(var_185) = &input.user_name {
        scope_184.string(var_185);
    }
    #[allow(unused_mut)]
    let mut scope_186 = writer.prefix("ServiceSpecificCredentialId");
    if let Some(var_187) = &input.service_specific_credential_id {
        scope_186.string(var_187);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_delete_signing_certificate(
    input: &crate::input::DeleteSigningCertificateInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "DeleteSigningCertificate", "2010-05-08");
    #[allow(unused_mut)]
    let mut scope_188 = writer.prefix("UserName");
    if let Some(var_189) = &input.user_name {
        scope_188.string(var_189);
    }
    #[allow(unused_mut)]
    let mut scope_190 = writer.prefix("CertificateId");
    if let Some(var_191) = &input.certificate_id {
        scope_190.string(var_191);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_delete_ssh_public_key(
    input: &crate::input::DeleteSshPublicKeyInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "DeleteSSHPublicKey", "2010-05-08");
    #[allow(unused_mut)]
    let mut scope_192 = writer.prefix("UserName");
    if let Some(var_193) = &input.user_name {
        scope_192.string(var_193);
    }
    #[allow(unused_mut)]
    let mut scope_194 = writer.prefix("SSHPublicKeyId");
    if let Some(var_195) = &input.ssh_public_key_id {
        scope_194.string(var_195);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_delete_user(
    input: &crate::input::DeleteUserInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "DeleteUser", "2010-05-08");
    #[allow(unused_mut)]
    let mut scope_196 = writer.prefix("UserName");
    if let Some(var_197) = &input.user_name {
        scope_196.string(var_197);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_delete_user_permissions_boundary(
    input: &crate::input::DeleteUserPermissionsBoundaryInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "DeleteUserPermissionsBoundary", "2010-05-08");
    #[allow(unused_mut)]
    let mut scope_198 = writer.prefix("UserName");
    if let Some(var_199) = &input.user_name {
        scope_198.string(var_199);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_delete_user_policy(
    input: &crate::input::DeleteUserPolicyInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "DeleteUserPolicy", "2010-05-08");
    #[allow(unused_mut)]
    let mut scope_200 = writer.prefix("UserName");
    if let Some(var_201) = &input.user_name {
        scope_200.string(var_201);
    }
    #[allow(unused_mut)]
    let mut scope_202 = writer.prefix("PolicyName");
    if let Some(var_203) = &input.policy_name {
        scope_202.string(var_203);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_delete_virtual_mfa_device(
    input: &crate::input::DeleteVirtualMfaDeviceInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "DeleteVirtualMFADevice", "2010-05-08");
    #[allow(unused_mut)]
    let mut scope_204 = writer.prefix("SerialNumber");
    if let Some(var_205) = &input.serial_number {
        scope_204.string(var_205);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_detach_group_policy(
    input: &crate::input::DetachGroupPolicyInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "DetachGroupPolicy", "2010-05-08");
    #[allow(unused_mut)]
    let mut scope_206 = writer.prefix("GroupName");
    if let Some(var_207) = &input.group_name {
        scope_206.string(var_207);
    }
    #[allow(unused_mut)]
    let mut scope_208 = writer.prefix("PolicyArn");
    if let Some(var_209) = &input.policy_arn {
        scope_208.string(var_209);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_detach_role_policy(
    input: &crate::input::DetachRolePolicyInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "DetachRolePolicy", "2010-05-08");
    #[allow(unused_mut)]
    let mut scope_210 = writer.prefix("RoleName");
    if let Some(var_211) = &input.role_name {
        scope_210.string(var_211);
    }
    #[allow(unused_mut)]
    let mut scope_212 = writer.prefix("PolicyArn");
    if let Some(var_213) = &input.policy_arn {
        scope_212.string(var_213);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_detach_user_policy(
    input: &crate::input::DetachUserPolicyInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "DetachUserPolicy", "2010-05-08");
    #[allow(unused_mut)]
    let mut scope_214 = writer.prefix("UserName");
    if let Some(var_215) = &input.user_name {
        scope_214.string(var_215);
    }
    #[allow(unused_mut)]
    let mut scope_216 = writer.prefix("PolicyArn");
    if let Some(var_217) = &input.policy_arn {
        scope_216.string(var_217);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_enable_mfa_device(
    input: &crate::input::EnableMfaDeviceInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "EnableMFADevice", "2010-05-08");
    #[allow(unused_mut)]
    let mut scope_218 = writer.prefix("UserName");
    if let Some(var_219) = &input.user_name {
        scope_218.string(var_219);
    }
    #[allow(unused_mut)]
    let mut scope_220 = writer.prefix("SerialNumber");
    if let Some(var_221) = &input.serial_number {
        scope_220.string(var_221);
    }
    #[allow(unused_mut)]
    let mut scope_222 = writer.prefix("AuthenticationCode1");
    if let Some(var_223) = &input.authentication_code1 {
        scope_222.string(var_223);
    }
    #[allow(unused_mut)]
    let mut scope_224 = writer.prefix("AuthenticationCode2");
    if let Some(var_225) = &input.authentication_code2 {
        scope_224.string(var_225);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_generate_credential_report(
    input: &crate::input::GenerateCredentialReportInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let _ = input;
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "GenerateCredentialReport", "2010-05-08");
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_generate_organizations_access_report(
    input: &crate::input::GenerateOrganizationsAccessReportInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "GenerateOrganizationsAccessReport", "2010-05-08");
    #[allow(unused_mut)]
    let mut scope_226 = writer.prefix("EntityPath");
    if let Some(var_227) = &input.entity_path {
        scope_226.string(var_227);
    }
    #[allow(unused_mut)]
    let mut scope_228 = writer.prefix("OrganizationsPolicyId");
    if let Some(var_229) = &input.organizations_policy_id {
        scope_228.string(var_229);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_generate_service_last_accessed_details(
    input: &crate::input::GenerateServiceLastAccessedDetailsInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(
        &mut out,
        "GenerateServiceLastAccessedDetails",
        "2010-05-08",
    );
    #[allow(unused_mut)]
    let mut scope_230 = writer.prefix("Arn");
    if let Some(var_231) = &input.arn {
        scope_230.string(var_231);
    }
    #[allow(unused_mut)]
    let mut scope_232 = writer.prefix("Granularity");
    if let Some(var_233) = &input.granularity {
        scope_232.string(var_233.as_str());
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_get_access_key_last_used(
    input: &crate::input::GetAccessKeyLastUsedInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "GetAccessKeyLastUsed", "2010-05-08");
    #[allow(unused_mut)]
    let mut scope_234 = writer.prefix("AccessKeyId");
    if let Some(var_235) = &input.access_key_id {
        scope_234.string(var_235);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_get_account_authorization_details(
    input: &crate::input::GetAccountAuthorizationDetailsInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "GetAccountAuthorizationDetails", "2010-05-08");
    #[allow(unused_mut)]
    let mut scope_236 = writer.prefix("Filter");
    if let Some(var_237) = &input.filter {
        let mut list_239 = scope_236.start_list(false, None);
        for item_238 in var_237 {
            #[allow(unused_mut)]
            let mut entry_240 = list_239.entry();
            entry_240.string(item_238.as_str());
        }
        list_239.finish();
    }
    #[allow(unused_mut)]
    let mut scope_241 = writer.prefix("MaxItems");
    if let Some(var_242) = &input.max_items {
        scope_241.number(
            #[allow(clippy::useless_conversion)]
            smithy_types::Number::NegInt((*var_242).into()),
        );
    }
    #[allow(unused_mut)]
    let mut scope_243 = writer.prefix("Marker");
    if let Some(var_244) = &input.marker {
        scope_243.string(var_244);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_get_account_password_policy(
    input: &crate::input::GetAccountPasswordPolicyInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let _ = input;
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "GetAccountPasswordPolicy", "2010-05-08");
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_get_account_summary(
    input: &crate::input::GetAccountSummaryInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let _ = input;
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "GetAccountSummary", "2010-05-08");
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_get_context_keys_for_custom_policy(
    input: &crate::input::GetContextKeysForCustomPolicyInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "GetContextKeysForCustomPolicy", "2010-05-08");
    #[allow(unused_mut)]
    let mut scope_245 = writer.prefix("PolicyInputList");
    if let Some(var_246) = &input.policy_input_list {
        let mut list_248 = scope_245.start_list(false, None);
        for item_247 in var_246 {
            #[allow(unused_mut)]
            let mut entry_249 = list_248.entry();
            entry_249.string(item_247);
        }
        list_248.finish();
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_get_context_keys_for_principal_policy(
    input: &crate::input::GetContextKeysForPrincipalPolicyInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "GetContextKeysForPrincipalPolicy", "2010-05-08");
    #[allow(unused_mut)]
    let mut scope_250 = writer.prefix("PolicySourceArn");
    if let Some(var_251) = &input.policy_source_arn {
        scope_250.string(var_251);
    }
    #[allow(unused_mut)]
    let mut scope_252 = writer.prefix("PolicyInputList");
    if let Some(var_253) = &input.policy_input_list {
        let mut list_255 = scope_252.start_list(false, None);
        for item_254 in var_253 {
            #[allow(unused_mut)]
            let mut entry_256 = list_255.entry();
            entry_256.string(item_254);
        }
        list_255.finish();
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_get_credential_report(
    input: &crate::input::GetCredentialReportInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let _ = input;
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "GetCredentialReport", "2010-05-08");
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_get_group(
    input: &crate::input::GetGroupInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "GetGroup", "2010-05-08");
    #[allow(unused_mut)]
    let mut scope_257 = writer.prefix("GroupName");
    if let Some(var_258) = &input.group_name {
        scope_257.string(var_258);
    }
    #[allow(unused_mut)]
    let mut scope_259 = writer.prefix("Marker");
    if let Some(var_260) = &input.marker {
        scope_259.string(var_260);
    }
    #[allow(unused_mut)]
    let mut scope_261 = writer.prefix("MaxItems");
    if let Some(var_262) = &input.max_items {
        scope_261.number(
            #[allow(clippy::useless_conversion)]
            smithy_types::Number::NegInt((*var_262).into()),
        );
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_get_group_policy(
    input: &crate::input::GetGroupPolicyInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "GetGroupPolicy", "2010-05-08");
    #[allow(unused_mut)]
    let mut scope_263 = writer.prefix("GroupName");
    if let Some(var_264) = &input.group_name {
        scope_263.string(var_264);
    }
    #[allow(unused_mut)]
    let mut scope_265 = writer.prefix("PolicyName");
    if let Some(var_266) = &input.policy_name {
        scope_265.string(var_266);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_get_instance_profile(
    input: &crate::input::GetInstanceProfileInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "GetInstanceProfile", "2010-05-08");
    #[allow(unused_mut)]
    let mut scope_267 = writer.prefix("InstanceProfileName");
    if let Some(var_268) = &input.instance_profile_name {
        scope_267.string(var_268);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_get_login_profile(
    input: &crate::input::GetLoginProfileInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "GetLoginProfile", "2010-05-08");
    #[allow(unused_mut)]
    let mut scope_269 = writer.prefix("UserName");
    if let Some(var_270) = &input.user_name {
        scope_269.string(var_270);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_get_open_id_connect_provider(
    input: &crate::input::GetOpenIdConnectProviderInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "GetOpenIDConnectProvider", "2010-05-08");
    #[allow(unused_mut)]
    let mut scope_271 = writer.prefix("OpenIDConnectProviderArn");
    if let Some(var_272) = &input.open_id_connect_provider_arn {
        scope_271.string(var_272);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_get_organizations_access_report(
    input: &crate::input::GetOrganizationsAccessReportInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "GetOrganizationsAccessReport", "2010-05-08");
    #[allow(unused_mut)]
    let mut scope_273 = writer.prefix("JobId");
    if let Some(var_274) = &input.job_id {
        scope_273.string(var_274);
    }
    #[allow(unused_mut)]
    let mut scope_275 = writer.prefix("MaxItems");
    if let Some(var_276) = &input.max_items {
        scope_275.number(
            #[allow(clippy::useless_conversion)]
            smithy_types::Number::NegInt((*var_276).into()),
        );
    }
    #[allow(unused_mut)]
    let mut scope_277 = writer.prefix("Marker");
    if let Some(var_278) = &input.marker {
        scope_277.string(var_278);
    }
    #[allow(unused_mut)]
    let mut scope_279 = writer.prefix("SortKey");
    if let Some(var_280) = &input.sort_key {
        scope_279.string(var_280.as_str());
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_get_policy(
    input: &crate::input::GetPolicyInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "GetPolicy", "2010-05-08");
    #[allow(unused_mut)]
    let mut scope_281 = writer.prefix("PolicyArn");
    if let Some(var_282) = &input.policy_arn {
        scope_281.string(var_282);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_get_policy_version(
    input: &crate::input::GetPolicyVersionInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "GetPolicyVersion", "2010-05-08");
    #[allow(unused_mut)]
    let mut scope_283 = writer.prefix("PolicyArn");
    if let Some(var_284) = &input.policy_arn {
        scope_283.string(var_284);
    }
    #[allow(unused_mut)]
    let mut scope_285 = writer.prefix("VersionId");
    if let Some(var_286) = &input.version_id {
        scope_285.string(var_286);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_get_role(
    input: &crate::input::GetRoleInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "GetRole", "2010-05-08");
    #[allow(unused_mut)]
    let mut scope_287 = writer.prefix("RoleName");
    if let Some(var_288) = &input.role_name {
        scope_287.string(var_288);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_get_role_policy(
    input: &crate::input::GetRolePolicyInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "GetRolePolicy", "2010-05-08");
    #[allow(unused_mut)]
    let mut scope_289 = writer.prefix("RoleName");
    if let Some(var_290) = &input.role_name {
        scope_289.string(var_290);
    }
    #[allow(unused_mut)]
    let mut scope_291 = writer.prefix("PolicyName");
    if let Some(var_292) = &input.policy_name {
        scope_291.string(var_292);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_get_saml_provider(
    input: &crate::input::GetSamlProviderInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "GetSAMLProvider", "2010-05-08");
    #[allow(unused_mut)]
    let mut scope_293 = writer.prefix("SAMLProviderArn");
    if let Some(var_294) = &input.saml_provider_arn {
        scope_293.string(var_294);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_get_server_certificate(
    input: &crate::input::GetServerCertificateInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "GetServerCertificate", "2010-05-08");
    #[allow(unused_mut)]
    let mut scope_295 = writer.prefix("ServerCertificateName");
    if let Some(var_296) = &input.server_certificate_name {
        scope_295.string(var_296);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_get_service_last_accessed_details(
    input: &crate::input::GetServiceLastAccessedDetailsInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "GetServiceLastAccessedDetails", "2010-05-08");
    #[allow(unused_mut)]
    let mut scope_297 = writer.prefix("JobId");
    if let Some(var_298) = &input.job_id {
        scope_297.string(var_298);
    }
    #[allow(unused_mut)]
    let mut scope_299 = writer.prefix("MaxItems");
    if let Some(var_300) = &input.max_items {
        scope_299.number(
            #[allow(clippy::useless_conversion)]
            smithy_types::Number::NegInt((*var_300).into()),
        );
    }
    #[allow(unused_mut)]
    let mut scope_301 = writer.prefix("Marker");
    if let Some(var_302) = &input.marker {
        scope_301.string(var_302);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_get_service_last_accessed_details_with_entities(
    input: &crate::input::GetServiceLastAccessedDetailsWithEntitiesInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(
        &mut out,
        "GetServiceLastAccessedDetailsWithEntities",
        "2010-05-08",
    );
    #[allow(unused_mut)]
    let mut scope_303 = writer.prefix("JobId");
    if let Some(var_304) = &input.job_id {
        scope_303.string(var_304);
    }
    #[allow(unused_mut)]
    let mut scope_305 = writer.prefix("ServiceNamespace");
    if let Some(var_306) = &input.service_namespace {
        scope_305.string(var_306);
    }
    #[allow(unused_mut)]
    let mut scope_307 = writer.prefix("MaxItems");
    if let Some(var_308) = &input.max_items {
        scope_307.number(
            #[allow(clippy::useless_conversion)]
            smithy_types::Number::NegInt((*var_308).into()),
        );
    }
    #[allow(unused_mut)]
    let mut scope_309 = writer.prefix("Marker");
    if let Some(var_310) = &input.marker {
        scope_309.string(var_310);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_get_service_linked_role_deletion_status(
    input: &crate::input::GetServiceLinkedRoleDeletionStatusInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(
        &mut out,
        "GetServiceLinkedRoleDeletionStatus",
        "2010-05-08",
    );
    #[allow(unused_mut)]
    let mut scope_311 = writer.prefix("DeletionTaskId");
    if let Some(var_312) = &input.deletion_task_id {
        scope_311.string(var_312);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_get_ssh_public_key(
    input: &crate::input::GetSshPublicKeyInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "GetSSHPublicKey", "2010-05-08");
    #[allow(unused_mut)]
    let mut scope_313 = writer.prefix("UserName");
    if let Some(var_314) = &input.user_name {
        scope_313.string(var_314);
    }
    #[allow(unused_mut)]
    let mut scope_315 = writer.prefix("SSHPublicKeyId");
    if let Some(var_316) = &input.ssh_public_key_id {
        scope_315.string(var_316);
    }
    #[allow(unused_mut)]
    let mut scope_317 = writer.prefix("Encoding");
    if let Some(var_318) = &input.encoding {
        scope_317.string(var_318.as_str());
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_get_user(
    input: &crate::input::GetUserInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "GetUser", "2010-05-08");
    #[allow(unused_mut)]
    let mut scope_319 = writer.prefix("UserName");
    if let Some(var_320) = &input.user_name {
        scope_319.string(var_320);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_get_user_policy(
    input: &crate::input::GetUserPolicyInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "GetUserPolicy", "2010-05-08");
    #[allow(unused_mut)]
    let mut scope_321 = writer.prefix("UserName");
    if let Some(var_322) = &input.user_name {
        scope_321.string(var_322);
    }
    #[allow(unused_mut)]
    let mut scope_323 = writer.prefix("PolicyName");
    if let Some(var_324) = &input.policy_name {
        scope_323.string(var_324);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_list_access_keys(
    input: &crate::input::ListAccessKeysInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "ListAccessKeys", "2010-05-08");
    #[allow(unused_mut)]
    let mut scope_325 = writer.prefix("UserName");
    if let Some(var_326) = &input.user_name {
        scope_325.string(var_326);
    }
    #[allow(unused_mut)]
    let mut scope_327 = writer.prefix("Marker");
    if let Some(var_328) = &input.marker {
        scope_327.string(var_328);
    }
    #[allow(unused_mut)]
    let mut scope_329 = writer.prefix("MaxItems");
    if let Some(var_330) = &input.max_items {
        scope_329.number(
            #[allow(clippy::useless_conversion)]
            smithy_types::Number::NegInt((*var_330).into()),
        );
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_list_account_aliases(
    input: &crate::input::ListAccountAliasesInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "ListAccountAliases", "2010-05-08");
    #[allow(unused_mut)]
    let mut scope_331 = writer.prefix("Marker");
    if let Some(var_332) = &input.marker {
        scope_331.string(var_332);
    }
    #[allow(unused_mut)]
    let mut scope_333 = writer.prefix("MaxItems");
    if let Some(var_334) = &input.max_items {
        scope_333.number(
            #[allow(clippy::useless_conversion)]
            smithy_types::Number::NegInt((*var_334).into()),
        );
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_list_attached_group_policies(
    input: &crate::input::ListAttachedGroupPoliciesInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "ListAttachedGroupPolicies", "2010-05-08");
    #[allow(unused_mut)]
    let mut scope_335 = writer.prefix("GroupName");
    if let Some(var_336) = &input.group_name {
        scope_335.string(var_336);
    }
    #[allow(unused_mut)]
    let mut scope_337 = writer.prefix("PathPrefix");
    if let Some(var_338) = &input.path_prefix {
        scope_337.string(var_338);
    }
    #[allow(unused_mut)]
    let mut scope_339 = writer.prefix("Marker");
    if let Some(var_340) = &input.marker {
        scope_339.string(var_340);
    }
    #[allow(unused_mut)]
    let mut scope_341 = writer.prefix("MaxItems");
    if let Some(var_342) = &input.max_items {
        scope_341.number(
            #[allow(clippy::useless_conversion)]
            smithy_types::Number::NegInt((*var_342).into()),
        );
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_list_attached_role_policies(
    input: &crate::input::ListAttachedRolePoliciesInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "ListAttachedRolePolicies", "2010-05-08");
    #[allow(unused_mut)]
    let mut scope_343 = writer.prefix("RoleName");
    if let Some(var_344) = &input.role_name {
        scope_343.string(var_344);
    }
    #[allow(unused_mut)]
    let mut scope_345 = writer.prefix("PathPrefix");
    if let Some(var_346) = &input.path_prefix {
        scope_345.string(var_346);
    }
    #[allow(unused_mut)]
    let mut scope_347 = writer.prefix("Marker");
    if let Some(var_348) = &input.marker {
        scope_347.string(var_348);
    }
    #[allow(unused_mut)]
    let mut scope_349 = writer.prefix("MaxItems");
    if let Some(var_350) = &input.max_items {
        scope_349.number(
            #[allow(clippy::useless_conversion)]
            smithy_types::Number::NegInt((*var_350).into()),
        );
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_list_attached_user_policies(
    input: &crate::input::ListAttachedUserPoliciesInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "ListAttachedUserPolicies", "2010-05-08");
    #[allow(unused_mut)]
    let mut scope_351 = writer.prefix("UserName");
    if let Some(var_352) = &input.user_name {
        scope_351.string(var_352);
    }
    #[allow(unused_mut)]
    let mut scope_353 = writer.prefix("PathPrefix");
    if let Some(var_354) = &input.path_prefix {
        scope_353.string(var_354);
    }
    #[allow(unused_mut)]
    let mut scope_355 = writer.prefix("Marker");
    if let Some(var_356) = &input.marker {
        scope_355.string(var_356);
    }
    #[allow(unused_mut)]
    let mut scope_357 = writer.prefix("MaxItems");
    if let Some(var_358) = &input.max_items {
        scope_357.number(
            #[allow(clippy::useless_conversion)]
            smithy_types::Number::NegInt((*var_358).into()),
        );
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_list_entities_for_policy(
    input: &crate::input::ListEntitiesForPolicyInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "ListEntitiesForPolicy", "2010-05-08");
    #[allow(unused_mut)]
    let mut scope_359 = writer.prefix("PolicyArn");
    if let Some(var_360) = &input.policy_arn {
        scope_359.string(var_360);
    }
    #[allow(unused_mut)]
    let mut scope_361 = writer.prefix("EntityFilter");
    if let Some(var_362) = &input.entity_filter {
        scope_361.string(var_362.as_str());
    }
    #[allow(unused_mut)]
    let mut scope_363 = writer.prefix("PathPrefix");
    if let Some(var_364) = &input.path_prefix {
        scope_363.string(var_364);
    }
    #[allow(unused_mut)]
    let mut scope_365 = writer.prefix("PolicyUsageFilter");
    if let Some(var_366) = &input.policy_usage_filter {
        scope_365.string(var_366.as_str());
    }
    #[allow(unused_mut)]
    let mut scope_367 = writer.prefix("Marker");
    if let Some(var_368) = &input.marker {
        scope_367.string(var_368);
    }
    #[allow(unused_mut)]
    let mut scope_369 = writer.prefix("MaxItems");
    if let Some(var_370) = &input.max_items {
        scope_369.number(
            #[allow(clippy::useless_conversion)]
            smithy_types::Number::NegInt((*var_370).into()),
        );
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_list_group_policies(
    input: &crate::input::ListGroupPoliciesInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "ListGroupPolicies", "2010-05-08");
    #[allow(unused_mut)]
    let mut scope_371 = writer.prefix("GroupName");
    if let Some(var_372) = &input.group_name {
        scope_371.string(var_372);
    }
    #[allow(unused_mut)]
    let mut scope_373 = writer.prefix("Marker");
    if let Some(var_374) = &input.marker {
        scope_373.string(var_374);
    }
    #[allow(unused_mut)]
    let mut scope_375 = writer.prefix("MaxItems");
    if let Some(var_376) = &input.max_items {
        scope_375.number(
            #[allow(clippy::useless_conversion)]
            smithy_types::Number::NegInt((*var_376).into()),
        );
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_list_groups(
    input: &crate::input::ListGroupsInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "ListGroups", "2010-05-08");
    #[allow(unused_mut)]
    let mut scope_377 = writer.prefix("PathPrefix");
    if let Some(var_378) = &input.path_prefix {
        scope_377.string(var_378);
    }
    #[allow(unused_mut)]
    let mut scope_379 = writer.prefix("Marker");
    if let Some(var_380) = &input.marker {
        scope_379.string(var_380);
    }
    #[allow(unused_mut)]
    let mut scope_381 = writer.prefix("MaxItems");
    if let Some(var_382) = &input.max_items {
        scope_381.number(
            #[allow(clippy::useless_conversion)]
            smithy_types::Number::NegInt((*var_382).into()),
        );
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_list_groups_for_user(
    input: &crate::input::ListGroupsForUserInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "ListGroupsForUser", "2010-05-08");
    #[allow(unused_mut)]
    let mut scope_383 = writer.prefix("UserName");
    if let Some(var_384) = &input.user_name {
        scope_383.string(var_384);
    }
    #[allow(unused_mut)]
    let mut scope_385 = writer.prefix("Marker");
    if let Some(var_386) = &input.marker {
        scope_385.string(var_386);
    }
    #[allow(unused_mut)]
    let mut scope_387 = writer.prefix("MaxItems");
    if let Some(var_388) = &input.max_items {
        scope_387.number(
            #[allow(clippy::useless_conversion)]
            smithy_types::Number::NegInt((*var_388).into()),
        );
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_list_instance_profiles(
    input: &crate::input::ListInstanceProfilesInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "ListInstanceProfiles", "2010-05-08");
    #[allow(unused_mut)]
    let mut scope_389 = writer.prefix("PathPrefix");
    if let Some(var_390) = &input.path_prefix {
        scope_389.string(var_390);
    }
    #[allow(unused_mut)]
    let mut scope_391 = writer.prefix("Marker");
    if let Some(var_392) = &input.marker {
        scope_391.string(var_392);
    }
    #[allow(unused_mut)]
    let mut scope_393 = writer.prefix("MaxItems");
    if let Some(var_394) = &input.max_items {
        scope_393.number(
            #[allow(clippy::useless_conversion)]
            smithy_types::Number::NegInt((*var_394).into()),
        );
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_list_instance_profiles_for_role(
    input: &crate::input::ListInstanceProfilesForRoleInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "ListInstanceProfilesForRole", "2010-05-08");
    #[allow(unused_mut)]
    let mut scope_395 = writer.prefix("RoleName");
    if let Some(var_396) = &input.role_name {
        scope_395.string(var_396);
    }
    #[allow(unused_mut)]
    let mut scope_397 = writer.prefix("Marker");
    if let Some(var_398) = &input.marker {
        scope_397.string(var_398);
    }
    #[allow(unused_mut)]
    let mut scope_399 = writer.prefix("MaxItems");
    if let Some(var_400) = &input.max_items {
        scope_399.number(
            #[allow(clippy::useless_conversion)]
            smithy_types::Number::NegInt((*var_400).into()),
        );
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_list_instance_profile_tags(
    input: &crate::input::ListInstanceProfileTagsInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "ListInstanceProfileTags", "2010-05-08");
    #[allow(unused_mut)]
    let mut scope_401 = writer.prefix("InstanceProfileName");
    if let Some(var_402) = &input.instance_profile_name {
        scope_401.string(var_402);
    }
    #[allow(unused_mut)]
    let mut scope_403 = writer.prefix("Marker");
    if let Some(var_404) = &input.marker {
        scope_403.string(var_404);
    }
    #[allow(unused_mut)]
    let mut scope_405 = writer.prefix("MaxItems");
    if let Some(var_406) = &input.max_items {
        scope_405.number(
            #[allow(clippy::useless_conversion)]
            smithy_types::Number::NegInt((*var_406).into()),
        );
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_list_mfa_devices(
    input: &crate::input::ListMfaDevicesInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "ListMFADevices", "2010-05-08");
    #[allow(unused_mut)]
    let mut scope_407 = writer.prefix("UserName");
    if let Some(var_408) = &input.user_name {
        scope_407.string(var_408);
    }
    #[allow(unused_mut)]
    let mut scope_409 = writer.prefix("Marker");
    if let Some(var_410) = &input.marker {
        scope_409.string(var_410);
    }
    #[allow(unused_mut)]
    let mut scope_411 = writer.prefix("MaxItems");
    if let Some(var_412) = &input.max_items {
        scope_411.number(
            #[allow(clippy::useless_conversion)]
            smithy_types::Number::NegInt((*var_412).into()),
        );
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_list_mfa_device_tags(
    input: &crate::input::ListMfaDeviceTagsInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "ListMFADeviceTags", "2010-05-08");
    #[allow(unused_mut)]
    let mut scope_413 = writer.prefix("SerialNumber");
    if let Some(var_414) = &input.serial_number {
        scope_413.string(var_414);
    }
    #[allow(unused_mut)]
    let mut scope_415 = writer.prefix("Marker");
    if let Some(var_416) = &input.marker {
        scope_415.string(var_416);
    }
    #[allow(unused_mut)]
    let mut scope_417 = writer.prefix("MaxItems");
    if let Some(var_418) = &input.max_items {
        scope_417.number(
            #[allow(clippy::useless_conversion)]
            smithy_types::Number::NegInt((*var_418).into()),
        );
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_list_open_id_connect_providers(
    input: &crate::input::ListOpenIdConnectProvidersInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let _ = input;
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "ListOpenIDConnectProviders", "2010-05-08");
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_list_open_id_connect_provider_tags(
    input: &crate::input::ListOpenIdConnectProviderTagsInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "ListOpenIDConnectProviderTags", "2010-05-08");
    #[allow(unused_mut)]
    let mut scope_419 = writer.prefix("OpenIDConnectProviderArn");
    if let Some(var_420) = &input.open_id_connect_provider_arn {
        scope_419.string(var_420);
    }
    #[allow(unused_mut)]
    let mut scope_421 = writer.prefix("Marker");
    if let Some(var_422) = &input.marker {
        scope_421.string(var_422);
    }
    #[allow(unused_mut)]
    let mut scope_423 = writer.prefix("MaxItems");
    if let Some(var_424) = &input.max_items {
        scope_423.number(
            #[allow(clippy::useless_conversion)]
            smithy_types::Number::NegInt((*var_424).into()),
        );
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_list_policies(
    input: &crate::input::ListPoliciesInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "ListPolicies", "2010-05-08");
    #[allow(unused_mut)]
    let mut scope_425 = writer.prefix("Scope");
    if let Some(var_426) = &input.scope {
        scope_425.string(var_426.as_str());
    }
    #[allow(unused_mut)]
    let mut scope_427 = writer.prefix("OnlyAttached");
    if input.only_attached {
        scope_427.boolean(input.only_attached);
    }
    #[allow(unused_mut)]
    let mut scope_428 = writer.prefix("PathPrefix");
    if let Some(var_429) = &input.path_prefix {
        scope_428.string(var_429);
    }
    #[allow(unused_mut)]
    let mut scope_430 = writer.prefix("PolicyUsageFilter");
    if let Some(var_431) = &input.policy_usage_filter {
        scope_430.string(var_431.as_str());
    }
    #[allow(unused_mut)]
    let mut scope_432 = writer.prefix("Marker");
    if let Some(var_433) = &input.marker {
        scope_432.string(var_433);
    }
    #[allow(unused_mut)]
    let mut scope_434 = writer.prefix("MaxItems");
    if let Some(var_435) = &input.max_items {
        scope_434.number(
            #[allow(clippy::useless_conversion)]
            smithy_types::Number::NegInt((*var_435).into()),
        );
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_list_policies_granting_service_access(
    input: &crate::input::ListPoliciesGrantingServiceAccessInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "ListPoliciesGrantingServiceAccess", "2010-05-08");
    #[allow(unused_mut)]
    let mut scope_436 = writer.prefix("Marker");
    if let Some(var_437) = &input.marker {
        scope_436.string(var_437);
    }
    #[allow(unused_mut)]
    let mut scope_438 = writer.prefix("Arn");
    if let Some(var_439) = &input.arn {
        scope_438.string(var_439);
    }
    #[allow(unused_mut)]
    let mut scope_440 = writer.prefix("ServiceNamespaces");
    if let Some(var_441) = &input.service_namespaces {
        let mut list_443 = scope_440.start_list(false, None);
        for item_442 in var_441 {
            #[allow(unused_mut)]
            let mut entry_444 = list_443.entry();
            entry_444.string(item_442);
        }
        list_443.finish();
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_list_policy_tags(
    input: &crate::input::ListPolicyTagsInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "ListPolicyTags", "2010-05-08");
    #[allow(unused_mut)]
    let mut scope_445 = writer.prefix("PolicyArn");
    if let Some(var_446) = &input.policy_arn {
        scope_445.string(var_446);
    }
    #[allow(unused_mut)]
    let mut scope_447 = writer.prefix("Marker");
    if let Some(var_448) = &input.marker {
        scope_447.string(var_448);
    }
    #[allow(unused_mut)]
    let mut scope_449 = writer.prefix("MaxItems");
    if let Some(var_450) = &input.max_items {
        scope_449.number(
            #[allow(clippy::useless_conversion)]
            smithy_types::Number::NegInt((*var_450).into()),
        );
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_list_policy_versions(
    input: &crate::input::ListPolicyVersionsInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "ListPolicyVersions", "2010-05-08");
    #[allow(unused_mut)]
    let mut scope_451 = writer.prefix("PolicyArn");
    if let Some(var_452) = &input.policy_arn {
        scope_451.string(var_452);
    }
    #[allow(unused_mut)]
    let mut scope_453 = writer.prefix("Marker");
    if let Some(var_454) = &input.marker {
        scope_453.string(var_454);
    }
    #[allow(unused_mut)]
    let mut scope_455 = writer.prefix("MaxItems");
    if let Some(var_456) = &input.max_items {
        scope_455.number(
            #[allow(clippy::useless_conversion)]
            smithy_types::Number::NegInt((*var_456).into()),
        );
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_list_role_policies(
    input: &crate::input::ListRolePoliciesInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "ListRolePolicies", "2010-05-08");
    #[allow(unused_mut)]
    let mut scope_457 = writer.prefix("RoleName");
    if let Some(var_458) = &input.role_name {
        scope_457.string(var_458);
    }
    #[allow(unused_mut)]
    let mut scope_459 = writer.prefix("Marker");
    if let Some(var_460) = &input.marker {
        scope_459.string(var_460);
    }
    #[allow(unused_mut)]
    let mut scope_461 = writer.prefix("MaxItems");
    if let Some(var_462) = &input.max_items {
        scope_461.number(
            #[allow(clippy::useless_conversion)]
            smithy_types::Number::NegInt((*var_462).into()),
        );
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_list_roles(
    input: &crate::input::ListRolesInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "ListRoles", "2010-05-08");
    #[allow(unused_mut)]
    let mut scope_463 = writer.prefix("PathPrefix");
    if let Some(var_464) = &input.path_prefix {
        scope_463.string(var_464);
    }
    #[allow(unused_mut)]
    let mut scope_465 = writer.prefix("Marker");
    if let Some(var_466) = &input.marker {
        scope_465.string(var_466);
    }
    #[allow(unused_mut)]
    let mut scope_467 = writer.prefix("MaxItems");
    if let Some(var_468) = &input.max_items {
        scope_467.number(
            #[allow(clippy::useless_conversion)]
            smithy_types::Number::NegInt((*var_468).into()),
        );
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_list_role_tags(
    input: &crate::input::ListRoleTagsInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "ListRoleTags", "2010-05-08");
    #[allow(unused_mut)]
    let mut scope_469 = writer.prefix("RoleName");
    if let Some(var_470) = &input.role_name {
        scope_469.string(var_470);
    }
    #[allow(unused_mut)]
    let mut scope_471 = writer.prefix("Marker");
    if let Some(var_472) = &input.marker {
        scope_471.string(var_472);
    }
    #[allow(unused_mut)]
    let mut scope_473 = writer.prefix("MaxItems");
    if let Some(var_474) = &input.max_items {
        scope_473.number(
            #[allow(clippy::useless_conversion)]
            smithy_types::Number::NegInt((*var_474).into()),
        );
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_list_saml_providers(
    input: &crate::input::ListSamlProvidersInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let _ = input;
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "ListSAMLProviders", "2010-05-08");
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_list_saml_provider_tags(
    input: &crate::input::ListSamlProviderTagsInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "ListSAMLProviderTags", "2010-05-08");
    #[allow(unused_mut)]
    let mut scope_475 = writer.prefix("SAMLProviderArn");
    if let Some(var_476) = &input.saml_provider_arn {
        scope_475.string(var_476);
    }
    #[allow(unused_mut)]
    let mut scope_477 = writer.prefix("Marker");
    if let Some(var_478) = &input.marker {
        scope_477.string(var_478);
    }
    #[allow(unused_mut)]
    let mut scope_479 = writer.prefix("MaxItems");
    if let Some(var_480) = &input.max_items {
        scope_479.number(
            #[allow(clippy::useless_conversion)]
            smithy_types::Number::NegInt((*var_480).into()),
        );
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_list_server_certificates(
    input: &crate::input::ListServerCertificatesInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "ListServerCertificates", "2010-05-08");
    #[allow(unused_mut)]
    let mut scope_481 = writer.prefix("PathPrefix");
    if let Some(var_482) = &input.path_prefix {
        scope_481.string(var_482);
    }
    #[allow(unused_mut)]
    let mut scope_483 = writer.prefix("Marker");
    if let Some(var_484) = &input.marker {
        scope_483.string(var_484);
    }
    #[allow(unused_mut)]
    let mut scope_485 = writer.prefix("MaxItems");
    if let Some(var_486) = &input.max_items {
        scope_485.number(
            #[allow(clippy::useless_conversion)]
            smithy_types::Number::NegInt((*var_486).into()),
        );
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_list_server_certificate_tags(
    input: &crate::input::ListServerCertificateTagsInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "ListServerCertificateTags", "2010-05-08");
    #[allow(unused_mut)]
    let mut scope_487 = writer.prefix("ServerCertificateName");
    if let Some(var_488) = &input.server_certificate_name {
        scope_487.string(var_488);
    }
    #[allow(unused_mut)]
    let mut scope_489 = writer.prefix("Marker");
    if let Some(var_490) = &input.marker {
        scope_489.string(var_490);
    }
    #[allow(unused_mut)]
    let mut scope_491 = writer.prefix("MaxItems");
    if let Some(var_492) = &input.max_items {
        scope_491.number(
            #[allow(clippy::useless_conversion)]
            smithy_types::Number::NegInt((*var_492).into()),
        );
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_list_service_specific_credentials(
    input: &crate::input::ListServiceSpecificCredentialsInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "ListServiceSpecificCredentials", "2010-05-08");
    #[allow(unused_mut)]
    let mut scope_493 = writer.prefix("UserName");
    if let Some(var_494) = &input.user_name {
        scope_493.string(var_494);
    }
    #[allow(unused_mut)]
    let mut scope_495 = writer.prefix("ServiceName");
    if let Some(var_496) = &input.service_name {
        scope_495.string(var_496);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_list_signing_certificates(
    input: &crate::input::ListSigningCertificatesInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "ListSigningCertificates", "2010-05-08");
    #[allow(unused_mut)]
    let mut scope_497 = writer.prefix("UserName");
    if let Some(var_498) = &input.user_name {
        scope_497.string(var_498);
    }
    #[allow(unused_mut)]
    let mut scope_499 = writer.prefix("Marker");
    if let Some(var_500) = &input.marker {
        scope_499.string(var_500);
    }
    #[allow(unused_mut)]
    let mut scope_501 = writer.prefix("MaxItems");
    if let Some(var_502) = &input.max_items {
        scope_501.number(
            #[allow(clippy::useless_conversion)]
            smithy_types::Number::NegInt((*var_502).into()),
        );
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_list_ssh_public_keys(
    input: &crate::input::ListSshPublicKeysInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "ListSSHPublicKeys", "2010-05-08");
    #[allow(unused_mut)]
    let mut scope_503 = writer.prefix("UserName");
    if let Some(var_504) = &input.user_name {
        scope_503.string(var_504);
    }
    #[allow(unused_mut)]
    let mut scope_505 = writer.prefix("Marker");
    if let Some(var_506) = &input.marker {
        scope_505.string(var_506);
    }
    #[allow(unused_mut)]
    let mut scope_507 = writer.prefix("MaxItems");
    if let Some(var_508) = &input.max_items {
        scope_507.number(
            #[allow(clippy::useless_conversion)]
            smithy_types::Number::NegInt((*var_508).into()),
        );
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_list_user_policies(
    input: &crate::input::ListUserPoliciesInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "ListUserPolicies", "2010-05-08");
    #[allow(unused_mut)]
    let mut scope_509 = writer.prefix("UserName");
    if let Some(var_510) = &input.user_name {
        scope_509.string(var_510);
    }
    #[allow(unused_mut)]
    let mut scope_511 = writer.prefix("Marker");
    if let Some(var_512) = &input.marker {
        scope_511.string(var_512);
    }
    #[allow(unused_mut)]
    let mut scope_513 = writer.prefix("MaxItems");
    if let Some(var_514) = &input.max_items {
        scope_513.number(
            #[allow(clippy::useless_conversion)]
            smithy_types::Number::NegInt((*var_514).into()),
        );
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_list_users(
    input: &crate::input::ListUsersInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "ListUsers", "2010-05-08");
    #[allow(unused_mut)]
    let mut scope_515 = writer.prefix("PathPrefix");
    if let Some(var_516) = &input.path_prefix {
        scope_515.string(var_516);
    }
    #[allow(unused_mut)]
    let mut scope_517 = writer.prefix("Marker");
    if let Some(var_518) = &input.marker {
        scope_517.string(var_518);
    }
    #[allow(unused_mut)]
    let mut scope_519 = writer.prefix("MaxItems");
    if let Some(var_520) = &input.max_items {
        scope_519.number(
            #[allow(clippy::useless_conversion)]
            smithy_types::Number::NegInt((*var_520).into()),
        );
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_list_user_tags(
    input: &crate::input::ListUserTagsInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "ListUserTags", "2010-05-08");
    #[allow(unused_mut)]
    let mut scope_521 = writer.prefix("UserName");
    if let Some(var_522) = &input.user_name {
        scope_521.string(var_522);
    }
    #[allow(unused_mut)]
    let mut scope_523 = writer.prefix("Marker");
    if let Some(var_524) = &input.marker {
        scope_523.string(var_524);
    }
    #[allow(unused_mut)]
    let mut scope_525 = writer.prefix("MaxItems");
    if let Some(var_526) = &input.max_items {
        scope_525.number(
            #[allow(clippy::useless_conversion)]
            smithy_types::Number::NegInt((*var_526).into()),
        );
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_list_virtual_mfa_devices(
    input: &crate::input::ListVirtualMfaDevicesInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "ListVirtualMFADevices", "2010-05-08");
    #[allow(unused_mut)]
    let mut scope_527 = writer.prefix("AssignmentStatus");
    if let Some(var_528) = &input.assignment_status {
        scope_527.string(var_528.as_str());
    }
    #[allow(unused_mut)]
    let mut scope_529 = writer.prefix("Marker");
    if let Some(var_530) = &input.marker {
        scope_529.string(var_530);
    }
    #[allow(unused_mut)]
    let mut scope_531 = writer.prefix("MaxItems");
    if let Some(var_532) = &input.max_items {
        scope_531.number(
            #[allow(clippy::useless_conversion)]
            smithy_types::Number::NegInt((*var_532).into()),
        );
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_put_group_policy(
    input: &crate::input::PutGroupPolicyInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "PutGroupPolicy", "2010-05-08");
    #[allow(unused_mut)]
    let mut scope_533 = writer.prefix("GroupName");
    if let Some(var_534) = &input.group_name {
        scope_533.string(var_534);
    }
    #[allow(unused_mut)]
    let mut scope_535 = writer.prefix("PolicyName");
    if let Some(var_536) = &input.policy_name {
        scope_535.string(var_536);
    }
    #[allow(unused_mut)]
    let mut scope_537 = writer.prefix("PolicyDocument");
    if let Some(var_538) = &input.policy_document {
        scope_537.string(var_538);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_put_role_permissions_boundary(
    input: &crate::input::PutRolePermissionsBoundaryInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "PutRolePermissionsBoundary", "2010-05-08");
    #[allow(unused_mut)]
    let mut scope_539 = writer.prefix("RoleName");
    if let Some(var_540) = &input.role_name {
        scope_539.string(var_540);
    }
    #[allow(unused_mut)]
    let mut scope_541 = writer.prefix("PermissionsBoundary");
    if let Some(var_542) = &input.permissions_boundary {
        scope_541.string(var_542);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_put_role_policy(
    input: &crate::input::PutRolePolicyInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "PutRolePolicy", "2010-05-08");
    #[allow(unused_mut)]
    let mut scope_543 = writer.prefix("RoleName");
    if let Some(var_544) = &input.role_name {
        scope_543.string(var_544);
    }
    #[allow(unused_mut)]
    let mut scope_545 = writer.prefix("PolicyName");
    if let Some(var_546) = &input.policy_name {
        scope_545.string(var_546);
    }
    #[allow(unused_mut)]
    let mut scope_547 = writer.prefix("PolicyDocument");
    if let Some(var_548) = &input.policy_document {
        scope_547.string(var_548);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_put_user_permissions_boundary(
    input: &crate::input::PutUserPermissionsBoundaryInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "PutUserPermissionsBoundary", "2010-05-08");
    #[allow(unused_mut)]
    let mut scope_549 = writer.prefix("UserName");
    if let Some(var_550) = &input.user_name {
        scope_549.string(var_550);
    }
    #[allow(unused_mut)]
    let mut scope_551 = writer.prefix("PermissionsBoundary");
    if let Some(var_552) = &input.permissions_boundary {
        scope_551.string(var_552);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_put_user_policy(
    input: &crate::input::PutUserPolicyInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "PutUserPolicy", "2010-05-08");
    #[allow(unused_mut)]
    let mut scope_553 = writer.prefix("UserName");
    if let Some(var_554) = &input.user_name {
        scope_553.string(var_554);
    }
    #[allow(unused_mut)]
    let mut scope_555 = writer.prefix("PolicyName");
    if let Some(var_556) = &input.policy_name {
        scope_555.string(var_556);
    }
    #[allow(unused_mut)]
    let mut scope_557 = writer.prefix("PolicyDocument");
    if let Some(var_558) = &input.policy_document {
        scope_557.string(var_558);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_remove_client_id_from_open_id_connect_provider(
    input: &crate::input::RemoveClientIdFromOpenIdConnectProviderInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(
        &mut out,
        "RemoveClientIDFromOpenIDConnectProvider",
        "2010-05-08",
    );
    #[allow(unused_mut)]
    let mut scope_559 = writer.prefix("OpenIDConnectProviderArn");
    if let Some(var_560) = &input.open_id_connect_provider_arn {
        scope_559.string(var_560);
    }
    #[allow(unused_mut)]
    let mut scope_561 = writer.prefix("ClientID");
    if let Some(var_562) = &input.client_id {
        scope_561.string(var_562);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_remove_role_from_instance_profile(
    input: &crate::input::RemoveRoleFromInstanceProfileInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "RemoveRoleFromInstanceProfile", "2010-05-08");
    #[allow(unused_mut)]
    let mut scope_563 = writer.prefix("InstanceProfileName");
    if let Some(var_564) = &input.instance_profile_name {
        scope_563.string(var_564);
    }
    #[allow(unused_mut)]
    let mut scope_565 = writer.prefix("RoleName");
    if let Some(var_566) = &input.role_name {
        scope_565.string(var_566);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_remove_user_from_group(
    input: &crate::input::RemoveUserFromGroupInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "RemoveUserFromGroup", "2010-05-08");
    #[allow(unused_mut)]
    let mut scope_567 = writer.prefix("GroupName");
    if let Some(var_568) = &input.group_name {
        scope_567.string(var_568);
    }
    #[allow(unused_mut)]
    let mut scope_569 = writer.prefix("UserName");
    if let Some(var_570) = &input.user_name {
        scope_569.string(var_570);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_reset_service_specific_credential(
    input: &crate::input::ResetServiceSpecificCredentialInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "ResetServiceSpecificCredential", "2010-05-08");
    #[allow(unused_mut)]
    let mut scope_571 = writer.prefix("UserName");
    if let Some(var_572) = &input.user_name {
        scope_571.string(var_572);
    }
    #[allow(unused_mut)]
    let mut scope_573 = writer.prefix("ServiceSpecificCredentialId");
    if let Some(var_574) = &input.service_specific_credential_id {
        scope_573.string(var_574);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_resync_mfa_device(
    input: &crate::input::ResyncMfaDeviceInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "ResyncMFADevice", "2010-05-08");
    #[allow(unused_mut)]
    let mut scope_575 = writer.prefix("UserName");
    if let Some(var_576) = &input.user_name {
        scope_575.string(var_576);
    }
    #[allow(unused_mut)]
    let mut scope_577 = writer.prefix("SerialNumber");
    if let Some(var_578) = &input.serial_number {
        scope_577.string(var_578);
    }
    #[allow(unused_mut)]
    let mut scope_579 = writer.prefix("AuthenticationCode1");
    if let Some(var_580) = &input.authentication_code1 {
        scope_579.string(var_580);
    }
    #[allow(unused_mut)]
    let mut scope_581 = writer.prefix("AuthenticationCode2");
    if let Some(var_582) = &input.authentication_code2 {
        scope_581.string(var_582);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_set_default_policy_version(
    input: &crate::input::SetDefaultPolicyVersionInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "SetDefaultPolicyVersion", "2010-05-08");
    #[allow(unused_mut)]
    let mut scope_583 = writer.prefix("PolicyArn");
    if let Some(var_584) = &input.policy_arn {
        scope_583.string(var_584);
    }
    #[allow(unused_mut)]
    let mut scope_585 = writer.prefix("VersionId");
    if let Some(var_586) = &input.version_id {
        scope_585.string(var_586);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_set_security_token_service_preferences(
    input: &crate::input::SetSecurityTokenServicePreferencesInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(
        &mut out,
        "SetSecurityTokenServicePreferences",
        "2010-05-08",
    );
    #[allow(unused_mut)]
    let mut scope_587 = writer.prefix("GlobalEndpointTokenVersion");
    if let Some(var_588) = &input.global_endpoint_token_version {
        scope_587.string(var_588.as_str());
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_simulate_custom_policy(
    input: &crate::input::SimulateCustomPolicyInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "SimulateCustomPolicy", "2010-05-08");
    #[allow(unused_mut)]
    let mut scope_589 = writer.prefix("PolicyInputList");
    if let Some(var_590) = &input.policy_input_list {
        let mut list_592 = scope_589.start_list(false, None);
        for item_591 in var_590 {
            #[allow(unused_mut)]
            let mut entry_593 = list_592.entry();
            entry_593.string(item_591);
        }
        list_592.finish();
    }
    #[allow(unused_mut)]
    let mut scope_594 = writer.prefix("PermissionsBoundaryPolicyInputList");
    if let Some(var_595) = &input.permissions_boundary_policy_input_list {
        let mut list_597 = scope_594.start_list(false, None);
        for item_596 in var_595 {
            #[allow(unused_mut)]
            let mut entry_598 = list_597.entry();
            entry_598.string(item_596);
        }
        list_597.finish();
    }
    #[allow(unused_mut)]
    let mut scope_599 = writer.prefix("ActionNames");
    if let Some(var_600) = &input.action_names {
        let mut list_602 = scope_599.start_list(false, None);
        for item_601 in var_600 {
            #[allow(unused_mut)]
            let mut entry_603 = list_602.entry();
            entry_603.string(item_601);
        }
        list_602.finish();
    }
    #[allow(unused_mut)]
    let mut scope_604 = writer.prefix("ResourceArns");
    if let Some(var_605) = &input.resource_arns {
        let mut list_607 = scope_604.start_list(false, None);
        for item_606 in var_605 {
            #[allow(unused_mut)]
            let mut entry_608 = list_607.entry();
            entry_608.string(item_606);
        }
        list_607.finish();
    }
    #[allow(unused_mut)]
    let mut scope_609 = writer.prefix("ResourcePolicy");
    if let Some(var_610) = &input.resource_policy {
        scope_609.string(var_610);
    }
    #[allow(unused_mut)]
    let mut scope_611 = writer.prefix("ResourceOwner");
    if let Some(var_612) = &input.resource_owner {
        scope_611.string(var_612);
    }
    #[allow(unused_mut)]
    let mut scope_613 = writer.prefix("CallerArn");
    if let Some(var_614) = &input.caller_arn {
        scope_613.string(var_614);
    }
    #[allow(unused_mut)]
    let mut scope_615 = writer.prefix("ContextEntries");
    if let Some(var_616) = &input.context_entries {
        let mut list_618 = scope_615.start_list(false, None);
        for item_617 in var_616 {
            #[allow(unused_mut)]
            let mut entry_619 = list_618.entry();
            crate::query_ser::serialize_structure_crate_model_context_entry(entry_619, item_617);
        }
        list_618.finish();
    }
    #[allow(unused_mut)]
    let mut scope_620 = writer.prefix("ResourceHandlingOption");
    if let Some(var_621) = &input.resource_handling_option {
        scope_620.string(var_621);
    }
    #[allow(unused_mut)]
    let mut scope_622 = writer.prefix("MaxItems");
    if let Some(var_623) = &input.max_items {
        scope_622.number(
            #[allow(clippy::useless_conversion)]
            smithy_types::Number::NegInt((*var_623).into()),
        );
    }
    #[allow(unused_mut)]
    let mut scope_624 = writer.prefix("Marker");
    if let Some(var_625) = &input.marker {
        scope_624.string(var_625);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_simulate_principal_policy(
    input: &crate::input::SimulatePrincipalPolicyInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "SimulatePrincipalPolicy", "2010-05-08");
    #[allow(unused_mut)]
    let mut scope_626 = writer.prefix("PolicySourceArn");
    if let Some(var_627) = &input.policy_source_arn {
        scope_626.string(var_627);
    }
    #[allow(unused_mut)]
    let mut scope_628 = writer.prefix("PolicyInputList");
    if let Some(var_629) = &input.policy_input_list {
        let mut list_631 = scope_628.start_list(false, None);
        for item_630 in var_629 {
            #[allow(unused_mut)]
            let mut entry_632 = list_631.entry();
            entry_632.string(item_630);
        }
        list_631.finish();
    }
    #[allow(unused_mut)]
    let mut scope_633 = writer.prefix("PermissionsBoundaryPolicyInputList");
    if let Some(var_634) = &input.permissions_boundary_policy_input_list {
        let mut list_636 = scope_633.start_list(false, None);
        for item_635 in var_634 {
            #[allow(unused_mut)]
            let mut entry_637 = list_636.entry();
            entry_637.string(item_635);
        }
        list_636.finish();
    }
    #[allow(unused_mut)]
    let mut scope_638 = writer.prefix("ActionNames");
    if let Some(var_639) = &input.action_names {
        let mut list_641 = scope_638.start_list(false, None);
        for item_640 in var_639 {
            #[allow(unused_mut)]
            let mut entry_642 = list_641.entry();
            entry_642.string(item_640);
        }
        list_641.finish();
    }
    #[allow(unused_mut)]
    let mut scope_643 = writer.prefix("ResourceArns");
    if let Some(var_644) = &input.resource_arns {
        let mut list_646 = scope_643.start_list(false, None);
        for item_645 in var_644 {
            #[allow(unused_mut)]
            let mut entry_647 = list_646.entry();
            entry_647.string(item_645);
        }
        list_646.finish();
    }
    #[allow(unused_mut)]
    let mut scope_648 = writer.prefix("ResourcePolicy");
    if let Some(var_649) = &input.resource_policy {
        scope_648.string(var_649);
    }
    #[allow(unused_mut)]
    let mut scope_650 = writer.prefix("ResourceOwner");
    if let Some(var_651) = &input.resource_owner {
        scope_650.string(var_651);
    }
    #[allow(unused_mut)]
    let mut scope_652 = writer.prefix("CallerArn");
    if let Some(var_653) = &input.caller_arn {
        scope_652.string(var_653);
    }
    #[allow(unused_mut)]
    let mut scope_654 = writer.prefix("ContextEntries");
    if let Some(var_655) = &input.context_entries {
        let mut list_657 = scope_654.start_list(false, None);
        for item_656 in var_655 {
            #[allow(unused_mut)]
            let mut entry_658 = list_657.entry();
            crate::query_ser::serialize_structure_crate_model_context_entry(entry_658, item_656);
        }
        list_657.finish();
    }
    #[allow(unused_mut)]
    let mut scope_659 = writer.prefix("ResourceHandlingOption");
    if let Some(var_660) = &input.resource_handling_option {
        scope_659.string(var_660);
    }
    #[allow(unused_mut)]
    let mut scope_661 = writer.prefix("MaxItems");
    if let Some(var_662) = &input.max_items {
        scope_661.number(
            #[allow(clippy::useless_conversion)]
            smithy_types::Number::NegInt((*var_662).into()),
        );
    }
    #[allow(unused_mut)]
    let mut scope_663 = writer.prefix("Marker");
    if let Some(var_664) = &input.marker {
        scope_663.string(var_664);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_tag_instance_profile(
    input: &crate::input::TagInstanceProfileInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "TagInstanceProfile", "2010-05-08");
    #[allow(unused_mut)]
    let mut scope_665 = writer.prefix("InstanceProfileName");
    if let Some(var_666) = &input.instance_profile_name {
        scope_665.string(var_666);
    }
    #[allow(unused_mut)]
    let mut scope_667 = writer.prefix("Tags");
    if let Some(var_668) = &input.tags {
        let mut list_670 = scope_667.start_list(false, None);
        for item_669 in var_668 {
            #[allow(unused_mut)]
            let mut entry_671 = list_670.entry();
            crate::query_ser::serialize_structure_crate_model_tag(entry_671, item_669);
        }
        list_670.finish();
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_tag_mfa_device(
    input: &crate::input::TagMfaDeviceInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "TagMFADevice", "2010-05-08");
    #[allow(unused_mut)]
    let mut scope_672 = writer.prefix("SerialNumber");
    if let Some(var_673) = &input.serial_number {
        scope_672.string(var_673);
    }
    #[allow(unused_mut)]
    let mut scope_674 = writer.prefix("Tags");
    if let Some(var_675) = &input.tags {
        let mut list_677 = scope_674.start_list(false, None);
        for item_676 in var_675 {
            #[allow(unused_mut)]
            let mut entry_678 = list_677.entry();
            crate::query_ser::serialize_structure_crate_model_tag(entry_678, item_676);
        }
        list_677.finish();
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_tag_open_id_connect_provider(
    input: &crate::input::TagOpenIdConnectProviderInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "TagOpenIDConnectProvider", "2010-05-08");
    #[allow(unused_mut)]
    let mut scope_679 = writer.prefix("OpenIDConnectProviderArn");
    if let Some(var_680) = &input.open_id_connect_provider_arn {
        scope_679.string(var_680);
    }
    #[allow(unused_mut)]
    let mut scope_681 = writer.prefix("Tags");
    if let Some(var_682) = &input.tags {
        let mut list_684 = scope_681.start_list(false, None);
        for item_683 in var_682 {
            #[allow(unused_mut)]
            let mut entry_685 = list_684.entry();
            crate::query_ser::serialize_structure_crate_model_tag(entry_685, item_683);
        }
        list_684.finish();
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_tag_policy(
    input: &crate::input::TagPolicyInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "TagPolicy", "2010-05-08");
    #[allow(unused_mut)]
    let mut scope_686 = writer.prefix("PolicyArn");
    if let Some(var_687) = &input.policy_arn {
        scope_686.string(var_687);
    }
    #[allow(unused_mut)]
    let mut scope_688 = writer.prefix("Tags");
    if let Some(var_689) = &input.tags {
        let mut list_691 = scope_688.start_list(false, None);
        for item_690 in var_689 {
            #[allow(unused_mut)]
            let mut entry_692 = list_691.entry();
            crate::query_ser::serialize_structure_crate_model_tag(entry_692, item_690);
        }
        list_691.finish();
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_tag_role(
    input: &crate::input::TagRoleInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "TagRole", "2010-05-08");
    #[allow(unused_mut)]
    let mut scope_693 = writer.prefix("RoleName");
    if let Some(var_694) = &input.role_name {
        scope_693.string(var_694);
    }
    #[allow(unused_mut)]
    let mut scope_695 = writer.prefix("Tags");
    if let Some(var_696) = &input.tags {
        let mut list_698 = scope_695.start_list(false, None);
        for item_697 in var_696 {
            #[allow(unused_mut)]
            let mut entry_699 = list_698.entry();
            crate::query_ser::serialize_structure_crate_model_tag(entry_699, item_697);
        }
        list_698.finish();
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_tag_saml_provider(
    input: &crate::input::TagSamlProviderInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "TagSAMLProvider", "2010-05-08");
    #[allow(unused_mut)]
    let mut scope_700 = writer.prefix("SAMLProviderArn");
    if let Some(var_701) = &input.saml_provider_arn {
        scope_700.string(var_701);
    }
    #[allow(unused_mut)]
    let mut scope_702 = writer.prefix("Tags");
    if let Some(var_703) = &input.tags {
        let mut list_705 = scope_702.start_list(false, None);
        for item_704 in var_703 {
            #[allow(unused_mut)]
            let mut entry_706 = list_705.entry();
            crate::query_ser::serialize_structure_crate_model_tag(entry_706, item_704);
        }
        list_705.finish();
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_tag_server_certificate(
    input: &crate::input::TagServerCertificateInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "TagServerCertificate", "2010-05-08");
    #[allow(unused_mut)]
    let mut scope_707 = writer.prefix("ServerCertificateName");
    if let Some(var_708) = &input.server_certificate_name {
        scope_707.string(var_708);
    }
    #[allow(unused_mut)]
    let mut scope_709 = writer.prefix("Tags");
    if let Some(var_710) = &input.tags {
        let mut list_712 = scope_709.start_list(false, None);
        for item_711 in var_710 {
            #[allow(unused_mut)]
            let mut entry_713 = list_712.entry();
            crate::query_ser::serialize_structure_crate_model_tag(entry_713, item_711);
        }
        list_712.finish();
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_tag_user(
    input: &crate::input::TagUserInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "TagUser", "2010-05-08");
    #[allow(unused_mut)]
    let mut scope_714 = writer.prefix("UserName");
    if let Some(var_715) = &input.user_name {
        scope_714.string(var_715);
    }
    #[allow(unused_mut)]
    let mut scope_716 = writer.prefix("Tags");
    if let Some(var_717) = &input.tags {
        let mut list_719 = scope_716.start_list(false, None);
        for item_718 in var_717 {
            #[allow(unused_mut)]
            let mut entry_720 = list_719.entry();
            crate::query_ser::serialize_structure_crate_model_tag(entry_720, item_718);
        }
        list_719.finish();
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_untag_instance_profile(
    input: &crate::input::UntagInstanceProfileInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "UntagInstanceProfile", "2010-05-08");
    #[allow(unused_mut)]
    let mut scope_721 = writer.prefix("InstanceProfileName");
    if let Some(var_722) = &input.instance_profile_name {
        scope_721.string(var_722);
    }
    #[allow(unused_mut)]
    let mut scope_723 = writer.prefix("TagKeys");
    if let Some(var_724) = &input.tag_keys {
        let mut list_726 = scope_723.start_list(false, None);
        for item_725 in var_724 {
            #[allow(unused_mut)]
            let mut entry_727 = list_726.entry();
            entry_727.string(item_725);
        }
        list_726.finish();
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_untag_mfa_device(
    input: &crate::input::UntagMfaDeviceInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "UntagMFADevice", "2010-05-08");
    #[allow(unused_mut)]
    let mut scope_728 = writer.prefix("SerialNumber");
    if let Some(var_729) = &input.serial_number {
        scope_728.string(var_729);
    }
    #[allow(unused_mut)]
    let mut scope_730 = writer.prefix("TagKeys");
    if let Some(var_731) = &input.tag_keys {
        let mut list_733 = scope_730.start_list(false, None);
        for item_732 in var_731 {
            #[allow(unused_mut)]
            let mut entry_734 = list_733.entry();
            entry_734.string(item_732);
        }
        list_733.finish();
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_untag_open_id_connect_provider(
    input: &crate::input::UntagOpenIdConnectProviderInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "UntagOpenIDConnectProvider", "2010-05-08");
    #[allow(unused_mut)]
    let mut scope_735 = writer.prefix("OpenIDConnectProviderArn");
    if let Some(var_736) = &input.open_id_connect_provider_arn {
        scope_735.string(var_736);
    }
    #[allow(unused_mut)]
    let mut scope_737 = writer.prefix("TagKeys");
    if let Some(var_738) = &input.tag_keys {
        let mut list_740 = scope_737.start_list(false, None);
        for item_739 in var_738 {
            #[allow(unused_mut)]
            let mut entry_741 = list_740.entry();
            entry_741.string(item_739);
        }
        list_740.finish();
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_untag_policy(
    input: &crate::input::UntagPolicyInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "UntagPolicy", "2010-05-08");
    #[allow(unused_mut)]
    let mut scope_742 = writer.prefix("PolicyArn");
    if let Some(var_743) = &input.policy_arn {
        scope_742.string(var_743);
    }
    #[allow(unused_mut)]
    let mut scope_744 = writer.prefix("TagKeys");
    if let Some(var_745) = &input.tag_keys {
        let mut list_747 = scope_744.start_list(false, None);
        for item_746 in var_745 {
            #[allow(unused_mut)]
            let mut entry_748 = list_747.entry();
            entry_748.string(item_746);
        }
        list_747.finish();
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_untag_role(
    input: &crate::input::UntagRoleInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "UntagRole", "2010-05-08");
    #[allow(unused_mut)]
    let mut scope_749 = writer.prefix("RoleName");
    if let Some(var_750) = &input.role_name {
        scope_749.string(var_750);
    }
    #[allow(unused_mut)]
    let mut scope_751 = writer.prefix("TagKeys");
    if let Some(var_752) = &input.tag_keys {
        let mut list_754 = scope_751.start_list(false, None);
        for item_753 in var_752 {
            #[allow(unused_mut)]
            let mut entry_755 = list_754.entry();
            entry_755.string(item_753);
        }
        list_754.finish();
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_untag_saml_provider(
    input: &crate::input::UntagSamlProviderInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "UntagSAMLProvider", "2010-05-08");
    #[allow(unused_mut)]
    let mut scope_756 = writer.prefix("SAMLProviderArn");
    if let Some(var_757) = &input.saml_provider_arn {
        scope_756.string(var_757);
    }
    #[allow(unused_mut)]
    let mut scope_758 = writer.prefix("TagKeys");
    if let Some(var_759) = &input.tag_keys {
        let mut list_761 = scope_758.start_list(false, None);
        for item_760 in var_759 {
            #[allow(unused_mut)]
            let mut entry_762 = list_761.entry();
            entry_762.string(item_760);
        }
        list_761.finish();
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_untag_server_certificate(
    input: &crate::input::UntagServerCertificateInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "UntagServerCertificate", "2010-05-08");
    #[allow(unused_mut)]
    let mut scope_763 = writer.prefix("ServerCertificateName");
    if let Some(var_764) = &input.server_certificate_name {
        scope_763.string(var_764);
    }
    #[allow(unused_mut)]
    let mut scope_765 = writer.prefix("TagKeys");
    if let Some(var_766) = &input.tag_keys {
        let mut list_768 = scope_765.start_list(false, None);
        for item_767 in var_766 {
            #[allow(unused_mut)]
            let mut entry_769 = list_768.entry();
            entry_769.string(item_767);
        }
        list_768.finish();
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_untag_user(
    input: &crate::input::UntagUserInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "UntagUser", "2010-05-08");
    #[allow(unused_mut)]
    let mut scope_770 = writer.prefix("UserName");
    if let Some(var_771) = &input.user_name {
        scope_770.string(var_771);
    }
    #[allow(unused_mut)]
    let mut scope_772 = writer.prefix("TagKeys");
    if let Some(var_773) = &input.tag_keys {
        let mut list_775 = scope_772.start_list(false, None);
        for item_774 in var_773 {
            #[allow(unused_mut)]
            let mut entry_776 = list_775.entry();
            entry_776.string(item_774);
        }
        list_775.finish();
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_update_access_key(
    input: &crate::input::UpdateAccessKeyInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "UpdateAccessKey", "2010-05-08");
    #[allow(unused_mut)]
    let mut scope_777 = writer.prefix("UserName");
    if let Some(var_778) = &input.user_name {
        scope_777.string(var_778);
    }
    #[allow(unused_mut)]
    let mut scope_779 = writer.prefix("AccessKeyId");
    if let Some(var_780) = &input.access_key_id {
        scope_779.string(var_780);
    }
    #[allow(unused_mut)]
    let mut scope_781 = writer.prefix("Status");
    if let Some(var_782) = &input.status {
        scope_781.string(var_782.as_str());
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_update_account_password_policy(
    input: &crate::input::UpdateAccountPasswordPolicyInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "UpdateAccountPasswordPolicy", "2010-05-08");
    #[allow(unused_mut)]
    let mut scope_783 = writer.prefix("MinimumPasswordLength");
    if let Some(var_784) = &input.minimum_password_length {
        scope_783.number(
            #[allow(clippy::useless_conversion)]
            smithy_types::Number::NegInt((*var_784).into()),
        );
    }
    #[allow(unused_mut)]
    let mut scope_785 = writer.prefix("RequireSymbols");
    if input.require_symbols {
        scope_785.boolean(input.require_symbols);
    }
    #[allow(unused_mut)]
    let mut scope_786 = writer.prefix("RequireNumbers");
    if input.require_numbers {
        scope_786.boolean(input.require_numbers);
    }
    #[allow(unused_mut)]
    let mut scope_787 = writer.prefix("RequireUppercaseCharacters");
    if input.require_uppercase_characters {
        scope_787.boolean(input.require_uppercase_characters);
    }
    #[allow(unused_mut)]
    let mut scope_788 = writer.prefix("RequireLowercaseCharacters");
    if input.require_lowercase_characters {
        scope_788.boolean(input.require_lowercase_characters);
    }
    #[allow(unused_mut)]
    let mut scope_789 = writer.prefix("AllowUsersToChangePassword");
    if input.allow_users_to_change_password {
        scope_789.boolean(input.allow_users_to_change_password);
    }
    #[allow(unused_mut)]
    let mut scope_790 = writer.prefix("MaxPasswordAge");
    if let Some(var_791) = &input.max_password_age {
        scope_790.number(
            #[allow(clippy::useless_conversion)]
            smithy_types::Number::NegInt((*var_791).into()),
        );
    }
    #[allow(unused_mut)]
    let mut scope_792 = writer.prefix("PasswordReusePrevention");
    if let Some(var_793) = &input.password_reuse_prevention {
        scope_792.number(
            #[allow(clippy::useless_conversion)]
            smithy_types::Number::NegInt((*var_793).into()),
        );
    }
    #[allow(unused_mut)]
    let mut scope_794 = writer.prefix("HardExpiry");
    if let Some(var_795) = &input.hard_expiry {
        scope_794.boolean(*var_795);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_update_assume_role_policy(
    input: &crate::input::UpdateAssumeRolePolicyInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "UpdateAssumeRolePolicy", "2010-05-08");
    #[allow(unused_mut)]
    let mut scope_796 = writer.prefix("RoleName");
    if let Some(var_797) = &input.role_name {
        scope_796.string(var_797);
    }
    #[allow(unused_mut)]
    let mut scope_798 = writer.prefix("PolicyDocument");
    if let Some(var_799) = &input.policy_document {
        scope_798.string(var_799);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_update_group(
    input: &crate::input::UpdateGroupInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "UpdateGroup", "2010-05-08");
    #[allow(unused_mut)]
    let mut scope_800 = writer.prefix("GroupName");
    if let Some(var_801) = &input.group_name {
        scope_800.string(var_801);
    }
    #[allow(unused_mut)]
    let mut scope_802 = writer.prefix("NewPath");
    if let Some(var_803) = &input.new_path {
        scope_802.string(var_803);
    }
    #[allow(unused_mut)]
    let mut scope_804 = writer.prefix("NewGroupName");
    if let Some(var_805) = &input.new_group_name {
        scope_804.string(var_805);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_update_login_profile(
    input: &crate::input::UpdateLoginProfileInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "UpdateLoginProfile", "2010-05-08");
    #[allow(unused_mut)]
    let mut scope_806 = writer.prefix("UserName");
    if let Some(var_807) = &input.user_name {
        scope_806.string(var_807);
    }
    #[allow(unused_mut)]
    let mut scope_808 = writer.prefix("Password");
    if let Some(var_809) = &input.password {
        scope_808.string(var_809);
    }
    #[allow(unused_mut)]
    let mut scope_810 = writer.prefix("PasswordResetRequired");
    if let Some(var_811) = &input.password_reset_required {
        scope_810.boolean(*var_811);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_update_open_id_connect_provider_thumbprint(
    input: &crate::input::UpdateOpenIdConnectProviderThumbprintInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(
        &mut out,
        "UpdateOpenIDConnectProviderThumbprint",
        "2010-05-08",
    );
    #[allow(unused_mut)]
    let mut scope_812 = writer.prefix("OpenIDConnectProviderArn");
    if let Some(var_813) = &input.open_id_connect_provider_arn {
        scope_812.string(var_813);
    }
    #[allow(unused_mut)]
    let mut scope_814 = writer.prefix("ThumbprintList");
    if let Some(var_815) = &input.thumbprint_list {
        let mut list_817 = scope_814.start_list(false, None);
        for item_816 in var_815 {
            #[allow(unused_mut)]
            let mut entry_818 = list_817.entry();
            entry_818.string(item_816);
        }
        list_817.finish();
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_update_role(
    input: &crate::input::UpdateRoleInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "UpdateRole", "2010-05-08");
    #[allow(unused_mut)]
    let mut scope_819 = writer.prefix("RoleName");
    if let Some(var_820) = &input.role_name {
        scope_819.string(var_820);
    }
    #[allow(unused_mut)]
    let mut scope_821 = writer.prefix("Description");
    if let Some(var_822) = &input.description {
        scope_821.string(var_822);
    }
    #[allow(unused_mut)]
    let mut scope_823 = writer.prefix("MaxSessionDuration");
    if let Some(var_824) = &input.max_session_duration {
        scope_823.number(
            #[allow(clippy::useless_conversion)]
            smithy_types::Number::NegInt((*var_824).into()),
        );
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_update_role_description(
    input: &crate::input::UpdateRoleDescriptionInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "UpdateRoleDescription", "2010-05-08");
    #[allow(unused_mut)]
    let mut scope_825 = writer.prefix("RoleName");
    if let Some(var_826) = &input.role_name {
        scope_825.string(var_826);
    }
    #[allow(unused_mut)]
    let mut scope_827 = writer.prefix("Description");
    if let Some(var_828) = &input.description {
        scope_827.string(var_828);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_update_saml_provider(
    input: &crate::input::UpdateSamlProviderInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "UpdateSAMLProvider", "2010-05-08");
    #[allow(unused_mut)]
    let mut scope_829 = writer.prefix("SAMLMetadataDocument");
    if let Some(var_830) = &input.saml_metadata_document {
        scope_829.string(var_830);
    }
    #[allow(unused_mut)]
    let mut scope_831 = writer.prefix("SAMLProviderArn");
    if let Some(var_832) = &input.saml_provider_arn {
        scope_831.string(var_832);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_update_server_certificate(
    input: &crate::input::UpdateServerCertificateInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "UpdateServerCertificate", "2010-05-08");
    #[allow(unused_mut)]
    let mut scope_833 = writer.prefix("ServerCertificateName");
    if let Some(var_834) = &input.server_certificate_name {
        scope_833.string(var_834);
    }
    #[allow(unused_mut)]
    let mut scope_835 = writer.prefix("NewPath");
    if let Some(var_836) = &input.new_path {
        scope_835.string(var_836);
    }
    #[allow(unused_mut)]
    let mut scope_837 = writer.prefix("NewServerCertificateName");
    if let Some(var_838) = &input.new_server_certificate_name {
        scope_837.string(var_838);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_update_service_specific_credential(
    input: &crate::input::UpdateServiceSpecificCredentialInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "UpdateServiceSpecificCredential", "2010-05-08");
    #[allow(unused_mut)]
    let mut scope_839 = writer.prefix("UserName");
    if let Some(var_840) = &input.user_name {
        scope_839.string(var_840);
    }
    #[allow(unused_mut)]
    let mut scope_841 = writer.prefix("ServiceSpecificCredentialId");
    if let Some(var_842) = &input.service_specific_credential_id {
        scope_841.string(var_842);
    }
    #[allow(unused_mut)]
    let mut scope_843 = writer.prefix("Status");
    if let Some(var_844) = &input.status {
        scope_843.string(var_844.as_str());
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_update_signing_certificate(
    input: &crate::input::UpdateSigningCertificateInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "UpdateSigningCertificate", "2010-05-08");
    #[allow(unused_mut)]
    let mut scope_845 = writer.prefix("UserName");
    if let Some(var_846) = &input.user_name {
        scope_845.string(var_846);
    }
    #[allow(unused_mut)]
    let mut scope_847 = writer.prefix("CertificateId");
    if let Some(var_848) = &input.certificate_id {
        scope_847.string(var_848);
    }
    #[allow(unused_mut)]
    let mut scope_849 = writer.prefix("Status");
    if let Some(var_850) = &input.status {
        scope_849.string(var_850.as_str());
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_update_ssh_public_key(
    input: &crate::input::UpdateSshPublicKeyInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "UpdateSSHPublicKey", "2010-05-08");
    #[allow(unused_mut)]
    let mut scope_851 = writer.prefix("UserName");
    if let Some(var_852) = &input.user_name {
        scope_851.string(var_852);
    }
    #[allow(unused_mut)]
    let mut scope_853 = writer.prefix("SSHPublicKeyId");
    if let Some(var_854) = &input.ssh_public_key_id {
        scope_853.string(var_854);
    }
    #[allow(unused_mut)]
    let mut scope_855 = writer.prefix("Status");
    if let Some(var_856) = &input.status {
        scope_855.string(var_856.as_str());
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_update_user(
    input: &crate::input::UpdateUserInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "UpdateUser", "2010-05-08");
    #[allow(unused_mut)]
    let mut scope_857 = writer.prefix("UserName");
    if let Some(var_858) = &input.user_name {
        scope_857.string(var_858);
    }
    #[allow(unused_mut)]
    let mut scope_859 = writer.prefix("NewPath");
    if let Some(var_860) = &input.new_path {
        scope_859.string(var_860);
    }
    #[allow(unused_mut)]
    let mut scope_861 = writer.prefix("NewUserName");
    if let Some(var_862) = &input.new_user_name {
        scope_861.string(var_862);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_upload_server_certificate(
    input: &crate::input::UploadServerCertificateInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "UploadServerCertificate", "2010-05-08");
    #[allow(unused_mut)]
    let mut scope_863 = writer.prefix("Path");
    if let Some(var_864) = &input.path {
        scope_863.string(var_864);
    }
    #[allow(unused_mut)]
    let mut scope_865 = writer.prefix("ServerCertificateName");
    if let Some(var_866) = &input.server_certificate_name {
        scope_865.string(var_866);
    }
    #[allow(unused_mut)]
    let mut scope_867 = writer.prefix("CertificateBody");
    if let Some(var_868) = &input.certificate_body {
        scope_867.string(var_868);
    }
    #[allow(unused_mut)]
    let mut scope_869 = writer.prefix("PrivateKey");
    if let Some(var_870) = &input.private_key {
        scope_869.string(var_870);
    }
    #[allow(unused_mut)]
    let mut scope_871 = writer.prefix("CertificateChain");
    if let Some(var_872) = &input.certificate_chain {
        scope_871.string(var_872);
    }
    #[allow(unused_mut)]
    let mut scope_873 = writer.prefix("Tags");
    if let Some(var_874) = &input.tags {
        let mut list_876 = scope_873.start_list(false, None);
        for item_875 in var_874 {
            #[allow(unused_mut)]
            let mut entry_877 = list_876.entry();
            crate::query_ser::serialize_structure_crate_model_tag(entry_877, item_875);
        }
        list_876.finish();
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_upload_signing_certificate(
    input: &crate::input::UploadSigningCertificateInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "UploadSigningCertificate", "2010-05-08");
    #[allow(unused_mut)]
    let mut scope_878 = writer.prefix("UserName");
    if let Some(var_879) = &input.user_name {
        scope_878.string(var_879);
    }
    #[allow(unused_mut)]
    let mut scope_880 = writer.prefix("CertificateBody");
    if let Some(var_881) = &input.certificate_body {
        scope_880.string(var_881);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_upload_ssh_public_key(
    input: &crate::input::UploadSshPublicKeyInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "UploadSSHPublicKey", "2010-05-08");
    #[allow(unused_mut)]
    let mut scope_882 = writer.prefix("UserName");
    if let Some(var_883) = &input.user_name {
        scope_882.string(var_883);
    }
    #[allow(unused_mut)]
    let mut scope_884 = writer.prefix("SSHPublicKeyBody");
    if let Some(var_885) = &input.ssh_public_key_body {
        scope_884.string(var_885);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_add_client_id_to_open_id_connect_provider_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::AddClientIdToOpenIdConnectProviderOutput,
    crate::error::AddClientIDToOpenIDConnectProviderError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::AddClientIDToOpenIDConnectProviderError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::AddClientIDToOpenIDConnectProviderError::unhandled(generic))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InvalidInput" => crate::error::AddClientIDToOpenIDConnectProviderError {
            meta: generic,
            kind: crate::error::AddClientIDToOpenIDConnectProviderErrorKind::InvalidInputException(
                {
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output = crate::error::invalid_input_exception::Builder::default();
                        let _ = response;
                        output = crate::xml_deser::deser_structure_crate_error_invalid_input_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::AddClientIDToOpenIDConnectProviderError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                },
            ),
        },
        "LimitExceeded" => crate::error::AddClientIDToOpenIDConnectProviderError {
            meta: generic,
            kind: crate::error::AddClientIDToOpenIDConnectProviderErrorKind::LimitExceededException(
                {
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output = crate::error::limit_exceeded_exception::Builder::default();
                        let _ = response;
                        output = crate::xml_deser::deser_structure_crate_error_limit_exceeded_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::AddClientIDToOpenIDConnectProviderError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                },
            ),
        },
        "NoSuchEntity" => crate::error::AddClientIDToOpenIDConnectProviderError {
            meta: generic,
            kind: crate::error::AddClientIDToOpenIDConnectProviderErrorKind::NoSuchEntityException(
                {
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output = crate::error::no_such_entity_exception::Builder::default();
                        let _ = response;
                        output = crate::xml_deser::deser_structure_crate_error_no_such_entity_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::AddClientIDToOpenIDConnectProviderError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                },
            ),
        },
        "ServiceFailure" => crate::error::AddClientIDToOpenIDConnectProviderError {
            meta: generic,
            kind:
                crate::error::AddClientIDToOpenIDConnectProviderErrorKind::ServiceFailureException(
                    {
                        #[allow(unused_mut)]
                        let mut tmp = {
                            #[allow(unused_mut)]
                            let mut output =
                                crate::error::service_failure_exception::Builder::default();
                            let _ = response;
                            output = crate::xml_deser::deser_structure_crate_error_service_failure_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::AddClientIDToOpenIDConnectProviderError::unhandled)?;
                            output.build()
                        };
                        if (&tmp.message).is_none() {
                            tmp.message = _error_message;
                        }
                        tmp
                    },
                ),
        },
        _ => crate::error::AddClientIDToOpenIDConnectProviderError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_add_client_id_to_open_id_connect_provider_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::AddClientIdToOpenIdConnectProviderOutput,
    crate::error::AddClientIDToOpenIDConnectProviderError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::add_client_id_to_open_id_connect_provider_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_add_role_to_instance_profile_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::AddRoleToInstanceProfileOutput,
    crate::error::AddRoleToInstanceProfileError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::AddRoleToInstanceProfileError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::AddRoleToInstanceProfileError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "EntityAlreadyExists" => crate::error::AddRoleToInstanceProfileError {
            meta: generic,
            kind: crate::error::AddRoleToInstanceProfileErrorKind::EntityAlreadyExistsException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::entity_already_exists_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_entity_already_exists_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::AddRoleToInstanceProfileError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "LimitExceeded" => crate::error::AddRoleToInstanceProfileError {
            meta: generic,
            kind: crate::error::AddRoleToInstanceProfileErrorKind::LimitExceededException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_limit_exceeded_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::AddRoleToInstanceProfileError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "NoSuchEntity" => crate::error::AddRoleToInstanceProfileError {
            meta: generic,
            kind: crate::error::AddRoleToInstanceProfileErrorKind::NoSuchEntityException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::no_such_entity_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_no_such_entity_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::AddRoleToInstanceProfileError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ServiceFailure" => crate::error::AddRoleToInstanceProfileError {
            meta: generic,
            kind: crate::error::AddRoleToInstanceProfileErrorKind::ServiceFailureException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::service_failure_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_service_failure_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::AddRoleToInstanceProfileError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "UnmodifiableEntity" => crate::error::AddRoleToInstanceProfileError {
            meta: generic,
            kind: crate::error::AddRoleToInstanceProfileErrorKind::UnmodifiableEntityException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::unmodifiable_entity_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_unmodifiable_entity_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::AddRoleToInstanceProfileError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::AddRoleToInstanceProfileError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_add_role_to_instance_profile_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::AddRoleToInstanceProfileOutput,
    crate::error::AddRoleToInstanceProfileError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::add_role_to_instance_profile_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_add_user_to_group_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::AddUserToGroupOutput, crate::error::AddUserToGroupError> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::AddUserToGroupError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::AddUserToGroupError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "LimitExceeded" => crate::error::AddUserToGroupError {
            meta: generic,
            kind: crate::error::AddUserToGroupErrorKind::LimitExceededException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_limit_exceeded_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::AddUserToGroupError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "NoSuchEntity" => crate::error::AddUserToGroupError {
            meta: generic,
            kind: crate::error::AddUserToGroupErrorKind::NoSuchEntityException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::no_such_entity_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_no_such_entity_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::AddUserToGroupError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ServiceFailure" => crate::error::AddUserToGroupError {
            meta: generic,
            kind: crate::error::AddUserToGroupErrorKind::ServiceFailureException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::service_failure_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_service_failure_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::AddUserToGroupError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::AddUserToGroupError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_add_user_to_group_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::AddUserToGroupOutput, crate::error::AddUserToGroupError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::add_user_to_group_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_attach_group_policy_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::AttachGroupPolicyOutput, crate::error::AttachGroupPolicyError>
{
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::AttachGroupPolicyError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::AttachGroupPolicyError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InvalidInput" => crate::error::AttachGroupPolicyError {
            meta: generic,
            kind: crate::error::AttachGroupPolicyErrorKind::InvalidInputException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_input_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_input_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::AttachGroupPolicyError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "LimitExceeded" => crate::error::AttachGroupPolicyError {
            meta: generic,
            kind: crate::error::AttachGroupPolicyErrorKind::LimitExceededException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_limit_exceeded_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::AttachGroupPolicyError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "NoSuchEntity" => crate::error::AttachGroupPolicyError {
            meta: generic,
            kind: crate::error::AttachGroupPolicyErrorKind::NoSuchEntityException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::no_such_entity_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_no_such_entity_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::AttachGroupPolicyError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "PolicyNotAttachable" => crate::error::AttachGroupPolicyError {
            meta: generic,
            kind: crate::error::AttachGroupPolicyErrorKind::PolicyNotAttachableException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::policy_not_attachable_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_policy_not_attachable_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::AttachGroupPolicyError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ServiceFailure" => crate::error::AttachGroupPolicyError {
            meta: generic,
            kind: crate::error::AttachGroupPolicyErrorKind::ServiceFailureException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::service_failure_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_service_failure_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::AttachGroupPolicyError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::AttachGroupPolicyError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_attach_group_policy_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::AttachGroupPolicyOutput, crate::error::AttachGroupPolicyError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::attach_group_policy_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_attach_role_policy_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::AttachRolePolicyOutput, crate::error::AttachRolePolicyError>
{
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::AttachRolePolicyError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::AttachRolePolicyError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InvalidInput" => crate::error::AttachRolePolicyError {
            meta: generic,
            kind: crate::error::AttachRolePolicyErrorKind::InvalidInputException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_input_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_input_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::AttachRolePolicyError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "LimitExceeded" => crate::error::AttachRolePolicyError {
            meta: generic,
            kind: crate::error::AttachRolePolicyErrorKind::LimitExceededException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_limit_exceeded_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::AttachRolePolicyError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "NoSuchEntity" => crate::error::AttachRolePolicyError {
            meta: generic,
            kind: crate::error::AttachRolePolicyErrorKind::NoSuchEntityException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::no_such_entity_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_no_such_entity_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::AttachRolePolicyError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "PolicyNotAttachable" => crate::error::AttachRolePolicyError {
            meta: generic,
            kind: crate::error::AttachRolePolicyErrorKind::PolicyNotAttachableException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::policy_not_attachable_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_policy_not_attachable_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::AttachRolePolicyError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ServiceFailure" => crate::error::AttachRolePolicyError {
            meta: generic,
            kind: crate::error::AttachRolePolicyErrorKind::ServiceFailureException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::service_failure_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_service_failure_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::AttachRolePolicyError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "UnmodifiableEntity" => crate::error::AttachRolePolicyError {
            meta: generic,
            kind: crate::error::AttachRolePolicyErrorKind::UnmodifiableEntityException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::unmodifiable_entity_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_unmodifiable_entity_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::AttachRolePolicyError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::AttachRolePolicyError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_attach_role_policy_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::AttachRolePolicyOutput, crate::error::AttachRolePolicyError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::attach_role_policy_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_attach_user_policy_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::AttachUserPolicyOutput, crate::error::AttachUserPolicyError>
{
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::AttachUserPolicyError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::AttachUserPolicyError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InvalidInput" => crate::error::AttachUserPolicyError {
            meta: generic,
            kind: crate::error::AttachUserPolicyErrorKind::InvalidInputException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_input_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_input_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::AttachUserPolicyError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "LimitExceeded" => crate::error::AttachUserPolicyError {
            meta: generic,
            kind: crate::error::AttachUserPolicyErrorKind::LimitExceededException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_limit_exceeded_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::AttachUserPolicyError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "NoSuchEntity" => crate::error::AttachUserPolicyError {
            meta: generic,
            kind: crate::error::AttachUserPolicyErrorKind::NoSuchEntityException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::no_such_entity_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_no_such_entity_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::AttachUserPolicyError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "PolicyNotAttachable" => crate::error::AttachUserPolicyError {
            meta: generic,
            kind: crate::error::AttachUserPolicyErrorKind::PolicyNotAttachableException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::policy_not_attachable_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_policy_not_attachable_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::AttachUserPolicyError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ServiceFailure" => crate::error::AttachUserPolicyError {
            meta: generic,
            kind: crate::error::AttachUserPolicyErrorKind::ServiceFailureException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::service_failure_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_service_failure_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::AttachUserPolicyError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::AttachUserPolicyError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_attach_user_policy_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::AttachUserPolicyOutput, crate::error::AttachUserPolicyError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::attach_user_policy_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_change_password_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ChangePasswordOutput, crate::error::ChangePasswordError> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::ChangePasswordError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ChangePasswordError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "EntityTemporarilyUnmodifiable" => crate::error::ChangePasswordError {
            meta: generic,
            kind: crate::error::ChangePasswordErrorKind::EntityTemporarilyUnmodifiableException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::entity_temporarily_unmodifiable_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_entity_temporarily_unmodifiable_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::ChangePasswordError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidUserType" => crate::error::ChangePasswordError {
            meta: generic,
            kind: crate::error::ChangePasswordErrorKind::InvalidUserTypeException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_user_type_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_user_type_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::ChangePasswordError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "LimitExceeded" => crate::error::ChangePasswordError {
            meta: generic,
            kind: crate::error::ChangePasswordErrorKind::LimitExceededException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_limit_exceeded_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::ChangePasswordError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "NoSuchEntity" => crate::error::ChangePasswordError {
            meta: generic,
            kind: crate::error::ChangePasswordErrorKind::NoSuchEntityException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::no_such_entity_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_no_such_entity_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::ChangePasswordError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "PasswordPolicyViolation" => crate::error::ChangePasswordError {
            meta: generic,
            kind: crate::error::ChangePasswordErrorKind::PasswordPolicyViolationException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::password_policy_violation_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_password_policy_violation_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::ChangePasswordError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ServiceFailure" => crate::error::ChangePasswordError {
            meta: generic,
            kind: crate::error::ChangePasswordErrorKind::ServiceFailureException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::service_failure_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_service_failure_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::ChangePasswordError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::ChangePasswordError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_change_password_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ChangePasswordOutput, crate::error::ChangePasswordError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::change_password_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_access_key_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateAccessKeyOutput, crate::error::CreateAccessKeyError> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::CreateAccessKeyError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::CreateAccessKeyError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "LimitExceeded" => crate::error::CreateAccessKeyError {
            meta: generic,
            kind: crate::error::CreateAccessKeyErrorKind::LimitExceededException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_limit_exceeded_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateAccessKeyError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "NoSuchEntity" => crate::error::CreateAccessKeyError {
            meta: generic,
            kind: crate::error::CreateAccessKeyErrorKind::NoSuchEntityException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::no_such_entity_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_no_such_entity_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateAccessKeyError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ServiceFailure" => crate::error::CreateAccessKeyError {
            meta: generic,
            kind: crate::error::CreateAccessKeyErrorKind::ServiceFailureException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::service_failure_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_service_failure_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateAccessKeyError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::CreateAccessKeyError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_access_key_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateAccessKeyOutput, crate::error::CreateAccessKeyError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_access_key_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_create_access_key(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreateAccessKeyError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_account_alias_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateAccountAliasOutput,
    crate::error::CreateAccountAliasError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::CreateAccountAliasError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::CreateAccountAliasError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "EntityAlreadyExists" => crate::error::CreateAccountAliasError {
            meta: generic,
            kind: crate::error::CreateAccountAliasErrorKind::EntityAlreadyExistsException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::entity_already_exists_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_entity_already_exists_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateAccountAliasError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "LimitExceeded" => crate::error::CreateAccountAliasError {
            meta: generic,
            kind: crate::error::CreateAccountAliasErrorKind::LimitExceededException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_limit_exceeded_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateAccountAliasError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ServiceFailure" => crate::error::CreateAccountAliasError {
            meta: generic,
            kind: crate::error::CreateAccountAliasErrorKind::ServiceFailureException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::service_failure_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_service_failure_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateAccountAliasError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::CreateAccountAliasError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_account_alias_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateAccountAliasOutput,
    crate::error::CreateAccountAliasError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_account_alias_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_group_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateGroupOutput, crate::error::CreateGroupError> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::CreateGroupError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::CreateGroupError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "EntityAlreadyExists" => crate::error::CreateGroupError {
            meta: generic,
            kind: crate::error::CreateGroupErrorKind::EntityAlreadyExistsException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::entity_already_exists_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_entity_already_exists_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateGroupError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "LimitExceeded" => crate::error::CreateGroupError {
            meta: generic,
            kind: crate::error::CreateGroupErrorKind::LimitExceededException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_limit_exceeded_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateGroupError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "NoSuchEntity" => crate::error::CreateGroupError {
            meta: generic,
            kind: crate::error::CreateGroupErrorKind::NoSuchEntityException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::no_such_entity_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_no_such_entity_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateGroupError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ServiceFailure" => crate::error::CreateGroupError {
            meta: generic,
            kind: crate::error::CreateGroupErrorKind::ServiceFailureException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::service_failure_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_service_failure_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateGroupError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::CreateGroupError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_group_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateGroupOutput, crate::error::CreateGroupError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_group_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_create_group(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreateGroupError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_instance_profile_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateInstanceProfileOutput,
    crate::error::CreateInstanceProfileError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::CreateInstanceProfileError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::CreateInstanceProfileError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ConcurrentModification" => crate::error::CreateInstanceProfileError {
            meta: generic,
            kind: crate::error::CreateInstanceProfileErrorKind::ConcurrentModificationException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::concurrent_modification_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_concurrent_modification_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateInstanceProfileError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "EntityAlreadyExists" => crate::error::CreateInstanceProfileError {
            meta: generic,
            kind: crate::error::CreateInstanceProfileErrorKind::EntityAlreadyExistsException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::entity_already_exists_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_entity_already_exists_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateInstanceProfileError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidInput" => crate::error::CreateInstanceProfileError {
            meta: generic,
            kind: crate::error::CreateInstanceProfileErrorKind::InvalidInputException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_input_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_input_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateInstanceProfileError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "LimitExceeded" => crate::error::CreateInstanceProfileError {
            meta: generic,
            kind: crate::error::CreateInstanceProfileErrorKind::LimitExceededException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_limit_exceeded_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateInstanceProfileError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ServiceFailure" => crate::error::CreateInstanceProfileError {
            meta: generic,
            kind: crate::error::CreateInstanceProfileErrorKind::ServiceFailureException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::service_failure_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_service_failure_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateInstanceProfileError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::CreateInstanceProfileError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_instance_profile_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateInstanceProfileOutput,
    crate::error::CreateInstanceProfileError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_instance_profile_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_create_instance_profile(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreateInstanceProfileError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_login_profile_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateLoginProfileOutput,
    crate::error::CreateLoginProfileError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::CreateLoginProfileError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::CreateLoginProfileError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "EntityAlreadyExists" => crate::error::CreateLoginProfileError {
            meta: generic,
            kind: crate::error::CreateLoginProfileErrorKind::EntityAlreadyExistsException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::entity_already_exists_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_entity_already_exists_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateLoginProfileError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "LimitExceeded" => crate::error::CreateLoginProfileError {
            meta: generic,
            kind: crate::error::CreateLoginProfileErrorKind::LimitExceededException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_limit_exceeded_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateLoginProfileError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "NoSuchEntity" => crate::error::CreateLoginProfileError {
            meta: generic,
            kind: crate::error::CreateLoginProfileErrorKind::NoSuchEntityException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::no_such_entity_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_no_such_entity_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateLoginProfileError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "PasswordPolicyViolation" => crate::error::CreateLoginProfileError {
            meta: generic,
            kind: crate::error::CreateLoginProfileErrorKind::PasswordPolicyViolationException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::password_policy_violation_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_password_policy_violation_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateLoginProfileError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ServiceFailure" => crate::error::CreateLoginProfileError {
            meta: generic,
            kind: crate::error::CreateLoginProfileErrorKind::ServiceFailureException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::service_failure_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_service_failure_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateLoginProfileError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::CreateLoginProfileError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_login_profile_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateLoginProfileOutput,
    crate::error::CreateLoginProfileError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_login_profile_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_create_login_profile(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreateLoginProfileError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_open_id_connect_provider_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateOpenIdConnectProviderOutput,
    crate::error::CreateOpenIDConnectProviderError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::CreateOpenIDConnectProviderError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::CreateOpenIDConnectProviderError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ConcurrentModification" => crate::error::CreateOpenIDConnectProviderError {
            meta: generic,
            kind:
                crate::error::CreateOpenIDConnectProviderErrorKind::ConcurrentModificationException(
                    {
                        #[allow(unused_mut)]
                        let mut tmp = {
                            #[allow(unused_mut)]
                            let mut output =
                                crate::error::concurrent_modification_exception::Builder::default();
                            let _ = response;
                            output = crate::xml_deser::deser_structure_crate_error_concurrent_modification_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateOpenIDConnectProviderError::unhandled)?;
                            output.build()
                        };
                        if (&tmp.message).is_none() {
                            tmp.message = _error_message;
                        }
                        tmp
                    },
                ),
        },
        "EntityAlreadyExists" => crate::error::CreateOpenIDConnectProviderError {
            meta: generic,
            kind: crate::error::CreateOpenIDConnectProviderErrorKind::EntityAlreadyExistsException(
                {
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::entity_already_exists_exception::Builder::default();
                        let _ = response;
                        output = crate::xml_deser::deser_structure_crate_error_entity_already_exists_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateOpenIDConnectProviderError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                },
            ),
        },
        "InvalidInput" => crate::error::CreateOpenIDConnectProviderError {
            meta: generic,
            kind: crate::error::CreateOpenIDConnectProviderErrorKind::InvalidInputException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_input_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_input_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateOpenIDConnectProviderError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "LimitExceeded" => crate::error::CreateOpenIDConnectProviderError {
            meta: generic,
            kind: crate::error::CreateOpenIDConnectProviderErrorKind::LimitExceededException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_limit_exceeded_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateOpenIDConnectProviderError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ServiceFailure" => crate::error::CreateOpenIDConnectProviderError {
            meta: generic,
            kind: crate::error::CreateOpenIDConnectProviderErrorKind::ServiceFailureException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::service_failure_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_service_failure_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateOpenIDConnectProviderError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::CreateOpenIDConnectProviderError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_open_id_connect_provider_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateOpenIdConnectProviderOutput,
    crate::error::CreateOpenIDConnectProviderError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_open_id_connect_provider_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_create_open_id_connect_provider(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreateOpenIDConnectProviderError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_policy_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreatePolicyOutput, crate::error::CreatePolicyError> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::CreatePolicyError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::CreatePolicyError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ConcurrentModification" => crate::error::CreatePolicyError {
            meta: generic,
            kind: crate::error::CreatePolicyErrorKind::ConcurrentModificationException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::concurrent_modification_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_concurrent_modification_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::CreatePolicyError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "EntityAlreadyExists" => crate::error::CreatePolicyError {
            meta: generic,
            kind: crate::error::CreatePolicyErrorKind::EntityAlreadyExistsException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::entity_already_exists_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_entity_already_exists_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::CreatePolicyError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidInput" => crate::error::CreatePolicyError {
            meta: generic,
            kind: crate::error::CreatePolicyErrorKind::InvalidInputException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_input_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_input_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::CreatePolicyError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "LimitExceeded" => crate::error::CreatePolicyError {
            meta: generic,
            kind: crate::error::CreatePolicyErrorKind::LimitExceededException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_limit_exceeded_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::CreatePolicyError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "MalformedPolicyDocument" => crate::error::CreatePolicyError {
            meta: generic,
            kind: crate::error::CreatePolicyErrorKind::MalformedPolicyDocumentException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::malformed_policy_document_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_malformed_policy_document_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::CreatePolicyError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ServiceFailure" => crate::error::CreatePolicyError {
            meta: generic,
            kind: crate::error::CreatePolicyErrorKind::ServiceFailureException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::service_failure_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_service_failure_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::CreatePolicyError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::CreatePolicyError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_policy_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreatePolicyOutput, crate::error::CreatePolicyError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_policy_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_create_policy(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreatePolicyError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_policy_version_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreatePolicyVersionOutput,
    crate::error::CreatePolicyVersionError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::CreatePolicyVersionError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::CreatePolicyVersionError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InvalidInput" => crate::error::CreatePolicyVersionError {
            meta: generic,
            kind: crate::error::CreatePolicyVersionErrorKind::InvalidInputException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_input_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_input_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::CreatePolicyVersionError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "LimitExceeded" => crate::error::CreatePolicyVersionError {
            meta: generic,
            kind: crate::error::CreatePolicyVersionErrorKind::LimitExceededException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_limit_exceeded_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::CreatePolicyVersionError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "MalformedPolicyDocument" => crate::error::CreatePolicyVersionError {
            meta: generic,
            kind: crate::error::CreatePolicyVersionErrorKind::MalformedPolicyDocumentException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::malformed_policy_document_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_malformed_policy_document_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::CreatePolicyVersionError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "NoSuchEntity" => crate::error::CreatePolicyVersionError {
            meta: generic,
            kind: crate::error::CreatePolicyVersionErrorKind::NoSuchEntityException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::no_such_entity_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_no_such_entity_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::CreatePolicyVersionError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ServiceFailure" => crate::error::CreatePolicyVersionError {
            meta: generic,
            kind: crate::error::CreatePolicyVersionErrorKind::ServiceFailureException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::service_failure_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_service_failure_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::CreatePolicyVersionError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::CreatePolicyVersionError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_policy_version_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreatePolicyVersionOutput,
    crate::error::CreatePolicyVersionError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_policy_version_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_create_policy_version(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreatePolicyVersionError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_role_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateRoleOutput, crate::error::CreateRoleError> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::CreateRoleError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::CreateRoleError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ConcurrentModification" => crate::error::CreateRoleError {
            meta: generic,
            kind: crate::error::CreateRoleErrorKind::ConcurrentModificationException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::concurrent_modification_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_concurrent_modification_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateRoleError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "EntityAlreadyExists" => crate::error::CreateRoleError {
            meta: generic,
            kind: crate::error::CreateRoleErrorKind::EntityAlreadyExistsException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::entity_already_exists_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_entity_already_exists_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateRoleError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidInput" => crate::error::CreateRoleError {
            meta: generic,
            kind: crate::error::CreateRoleErrorKind::InvalidInputException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_input_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_input_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateRoleError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "LimitExceeded" => crate::error::CreateRoleError {
            meta: generic,
            kind: crate::error::CreateRoleErrorKind::LimitExceededException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_limit_exceeded_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateRoleError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "MalformedPolicyDocument" => crate::error::CreateRoleError {
            meta: generic,
            kind: crate::error::CreateRoleErrorKind::MalformedPolicyDocumentException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::malformed_policy_document_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_malformed_policy_document_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateRoleError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ServiceFailure" => crate::error::CreateRoleError {
            meta: generic,
            kind: crate::error::CreateRoleErrorKind::ServiceFailureException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::service_failure_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_service_failure_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateRoleError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::CreateRoleError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_role_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateRoleOutput, crate::error::CreateRoleError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_role_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_create_role(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreateRoleError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_saml_provider_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateSamlProviderOutput,
    crate::error::CreateSAMLProviderError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::CreateSAMLProviderError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::CreateSAMLProviderError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ConcurrentModification" => crate::error::CreateSAMLProviderError {
            meta: generic,
            kind: crate::error::CreateSAMLProviderErrorKind::ConcurrentModificationException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::concurrent_modification_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_concurrent_modification_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateSAMLProviderError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "EntityAlreadyExists" => crate::error::CreateSAMLProviderError {
            meta: generic,
            kind: crate::error::CreateSAMLProviderErrorKind::EntityAlreadyExistsException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::entity_already_exists_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_entity_already_exists_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateSAMLProviderError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidInput" => crate::error::CreateSAMLProviderError {
            meta: generic,
            kind: crate::error::CreateSAMLProviderErrorKind::InvalidInputException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_input_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_input_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateSAMLProviderError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "LimitExceeded" => crate::error::CreateSAMLProviderError {
            meta: generic,
            kind: crate::error::CreateSAMLProviderErrorKind::LimitExceededException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_limit_exceeded_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateSAMLProviderError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ServiceFailure" => crate::error::CreateSAMLProviderError {
            meta: generic,
            kind: crate::error::CreateSAMLProviderErrorKind::ServiceFailureException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::service_failure_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_service_failure_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateSAMLProviderError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::CreateSAMLProviderError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_saml_provider_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateSamlProviderOutput,
    crate::error::CreateSAMLProviderError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_saml_provider_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_create_saml_provider(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreateSAMLProviderError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_service_linked_role_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateServiceLinkedRoleOutput,
    crate::error::CreateServiceLinkedRoleError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::CreateServiceLinkedRoleError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::CreateServiceLinkedRoleError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InvalidInput" => crate::error::CreateServiceLinkedRoleError {
            meta: generic,
            kind: crate::error::CreateServiceLinkedRoleErrorKind::InvalidInputException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_input_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_input_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateServiceLinkedRoleError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "LimitExceeded" => crate::error::CreateServiceLinkedRoleError {
            meta: generic,
            kind: crate::error::CreateServiceLinkedRoleErrorKind::LimitExceededException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_limit_exceeded_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateServiceLinkedRoleError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "NoSuchEntity" => crate::error::CreateServiceLinkedRoleError {
            meta: generic,
            kind: crate::error::CreateServiceLinkedRoleErrorKind::NoSuchEntityException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::no_such_entity_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_no_such_entity_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateServiceLinkedRoleError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ServiceFailure" => crate::error::CreateServiceLinkedRoleError {
            meta: generic,
            kind: crate::error::CreateServiceLinkedRoleErrorKind::ServiceFailureException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::service_failure_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_service_failure_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateServiceLinkedRoleError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::CreateServiceLinkedRoleError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_service_linked_role_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateServiceLinkedRoleOutput,
    crate::error::CreateServiceLinkedRoleError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_service_linked_role_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_create_service_linked_role(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreateServiceLinkedRoleError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_service_specific_credential_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateServiceSpecificCredentialOutput,
    crate::error::CreateServiceSpecificCredentialError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::CreateServiceSpecificCredentialError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::CreateServiceSpecificCredentialError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "LimitExceeded" => crate::error::CreateServiceSpecificCredentialError {
            meta: generic,
            kind: crate::error::CreateServiceSpecificCredentialErrorKind::LimitExceededException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_limit_exceeded_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateServiceSpecificCredentialError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "NoSuchEntity" => crate::error::CreateServiceSpecificCredentialError {
            meta: generic,
            kind: crate::error::CreateServiceSpecificCredentialErrorKind::NoSuchEntityException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::no_such_entity_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_no_such_entity_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateServiceSpecificCredentialError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "NotSupportedService" => crate::error::CreateServiceSpecificCredentialError {
            meta: generic,
            kind:
                crate::error::CreateServiceSpecificCredentialErrorKind::ServiceNotSupportedException(
                    {
                        #[allow(unused_mut)]
                        let mut tmp = {
                            #[allow(unused_mut)]
                            let mut output =
                                crate::error::service_not_supported_exception::Builder::default();
                            let _ = response;
                            output = crate::xml_deser::deser_structure_crate_error_service_not_supported_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateServiceSpecificCredentialError::unhandled)?;
                            output.build()
                        };
                        if (&tmp.message).is_none() {
                            tmp.message = _error_message;
                        }
                        tmp
                    },
                ),
        },
        _ => crate::error::CreateServiceSpecificCredentialError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_service_specific_credential_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateServiceSpecificCredentialOutput,
    crate::error::CreateServiceSpecificCredentialError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::create_service_specific_credential_output::Builder::default();
        let _ = response;
        output =
            crate::xml_deser::deser_operation_crate_operation_create_service_specific_credential(
                response.body().as_ref(),
                output,
            )
            .map_err(crate::error::CreateServiceSpecificCredentialError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_user_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateUserOutput, crate::error::CreateUserError> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::CreateUserError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::CreateUserError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ConcurrentModification" => crate::error::CreateUserError {
            meta: generic,
            kind: crate::error::CreateUserErrorKind::ConcurrentModificationException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::concurrent_modification_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_concurrent_modification_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateUserError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "EntityAlreadyExists" => crate::error::CreateUserError {
            meta: generic,
            kind: crate::error::CreateUserErrorKind::EntityAlreadyExistsException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::entity_already_exists_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_entity_already_exists_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateUserError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidInput" => crate::error::CreateUserError {
            meta: generic,
            kind: crate::error::CreateUserErrorKind::InvalidInputException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_input_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_input_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateUserError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "LimitExceeded" => crate::error::CreateUserError {
            meta: generic,
            kind: crate::error::CreateUserErrorKind::LimitExceededException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_limit_exceeded_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateUserError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "NoSuchEntity" => crate::error::CreateUserError {
            meta: generic,
            kind: crate::error::CreateUserErrorKind::NoSuchEntityException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::no_such_entity_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_no_such_entity_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateUserError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ServiceFailure" => crate::error::CreateUserError {
            meta: generic,
            kind: crate::error::CreateUserErrorKind::ServiceFailureException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::service_failure_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_service_failure_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateUserError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::CreateUserError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_user_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateUserOutput, crate::error::CreateUserError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_user_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_create_user(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreateUserError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_virtual_mfa_device_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateVirtualMfaDeviceOutput,
    crate::error::CreateVirtualMFADeviceError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::CreateVirtualMFADeviceError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::CreateVirtualMFADeviceError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ConcurrentModification" => crate::error::CreateVirtualMFADeviceError {
            meta: generic,
            kind: crate::error::CreateVirtualMFADeviceErrorKind::ConcurrentModificationException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::concurrent_modification_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_concurrent_modification_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateVirtualMFADeviceError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "EntityAlreadyExists" => crate::error::CreateVirtualMFADeviceError {
            meta: generic,
            kind: crate::error::CreateVirtualMFADeviceErrorKind::EntityAlreadyExistsException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::entity_already_exists_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_entity_already_exists_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateVirtualMFADeviceError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidInput" => crate::error::CreateVirtualMFADeviceError {
            meta: generic,
            kind: crate::error::CreateVirtualMFADeviceErrorKind::InvalidInputException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_input_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_input_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateVirtualMFADeviceError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "LimitExceeded" => crate::error::CreateVirtualMFADeviceError {
            meta: generic,
            kind: crate::error::CreateVirtualMFADeviceErrorKind::LimitExceededException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_limit_exceeded_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateVirtualMFADeviceError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ServiceFailure" => crate::error::CreateVirtualMFADeviceError {
            meta: generic,
            kind: crate::error::CreateVirtualMFADeviceErrorKind::ServiceFailureException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::service_failure_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_service_failure_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateVirtualMFADeviceError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::CreateVirtualMFADeviceError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_virtual_mfa_device_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateVirtualMfaDeviceOutput,
    crate::error::CreateVirtualMFADeviceError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_virtual_mfa_device_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_create_virtual_mfa_device(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreateVirtualMFADeviceError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_deactivate_mfa_device_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeactivateMfaDeviceOutput,
    crate::error::DeactivateMFADeviceError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::DeactivateMFADeviceError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DeactivateMFADeviceError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "EntityTemporarilyUnmodifiable" => crate::error::DeactivateMFADeviceError {
            meta: generic,
            kind:
                crate::error::DeactivateMFADeviceErrorKind::EntityTemporarilyUnmodifiableException(
                    {
                        #[allow(unused_mut)]
                        let mut tmp = {
                            #[allow(unused_mut)]let mut output = crate::error::entity_temporarily_unmodifiable_exception::Builder::default();
                            let _ = response;
                            output = crate::xml_deser::deser_structure_crate_error_entity_temporarily_unmodifiable_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::DeactivateMFADeviceError::unhandled)?;
                            output.build()
                        };
                        if (&tmp.message).is_none() {
                            tmp.message = _error_message;
                        }
                        tmp
                    },
                ),
        },
        "LimitExceeded" => crate::error::DeactivateMFADeviceError {
            meta: generic,
            kind: crate::error::DeactivateMFADeviceErrorKind::LimitExceededException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_limit_exceeded_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::DeactivateMFADeviceError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "NoSuchEntity" => crate::error::DeactivateMFADeviceError {
            meta: generic,
            kind: crate::error::DeactivateMFADeviceErrorKind::NoSuchEntityException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::no_such_entity_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_no_such_entity_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::DeactivateMFADeviceError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ServiceFailure" => crate::error::DeactivateMFADeviceError {
            meta: generic,
            kind: crate::error::DeactivateMFADeviceErrorKind::ServiceFailureException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::service_failure_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_service_failure_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::DeactivateMFADeviceError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::DeactivateMFADeviceError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_deactivate_mfa_device_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeactivateMfaDeviceOutput,
    crate::error::DeactivateMFADeviceError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::deactivate_mfa_device_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_access_key_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteAccessKeyOutput, crate::error::DeleteAccessKeyError> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::DeleteAccessKeyError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DeleteAccessKeyError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "LimitExceeded" => crate::error::DeleteAccessKeyError {
            meta: generic,
            kind: crate::error::DeleteAccessKeyErrorKind::LimitExceededException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_limit_exceeded_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteAccessKeyError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "NoSuchEntity" => crate::error::DeleteAccessKeyError {
            meta: generic,
            kind: crate::error::DeleteAccessKeyErrorKind::NoSuchEntityException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::no_such_entity_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_no_such_entity_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteAccessKeyError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ServiceFailure" => crate::error::DeleteAccessKeyError {
            meta: generic,
            kind: crate::error::DeleteAccessKeyErrorKind::ServiceFailureException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::service_failure_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_service_failure_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteAccessKeyError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::DeleteAccessKeyError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_access_key_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteAccessKeyOutput, crate::error::DeleteAccessKeyError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_access_key_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_account_alias_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteAccountAliasOutput,
    crate::error::DeleteAccountAliasError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::DeleteAccountAliasError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DeleteAccountAliasError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "LimitExceeded" => crate::error::DeleteAccountAliasError {
            meta: generic,
            kind: crate::error::DeleteAccountAliasErrorKind::LimitExceededException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_limit_exceeded_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteAccountAliasError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "NoSuchEntity" => crate::error::DeleteAccountAliasError {
            meta: generic,
            kind: crate::error::DeleteAccountAliasErrorKind::NoSuchEntityException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::no_such_entity_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_no_such_entity_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteAccountAliasError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ServiceFailure" => crate::error::DeleteAccountAliasError {
            meta: generic,
            kind: crate::error::DeleteAccountAliasErrorKind::ServiceFailureException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::service_failure_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_service_failure_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteAccountAliasError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::DeleteAccountAliasError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_account_alias_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteAccountAliasOutput,
    crate::error::DeleteAccountAliasError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_account_alias_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_account_password_policy_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteAccountPasswordPolicyOutput,
    crate::error::DeleteAccountPasswordPolicyError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::DeleteAccountPasswordPolicyError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DeleteAccountPasswordPolicyError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "LimitExceeded" => crate::error::DeleteAccountPasswordPolicyError {
            meta: generic,
            kind: crate::error::DeleteAccountPasswordPolicyErrorKind::LimitExceededException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_limit_exceeded_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteAccountPasswordPolicyError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "NoSuchEntity" => crate::error::DeleteAccountPasswordPolicyError {
            meta: generic,
            kind: crate::error::DeleteAccountPasswordPolicyErrorKind::NoSuchEntityException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::no_such_entity_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_no_such_entity_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteAccountPasswordPolicyError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ServiceFailure" => crate::error::DeleteAccountPasswordPolicyError {
            meta: generic,
            kind: crate::error::DeleteAccountPasswordPolicyErrorKind::ServiceFailureException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::service_failure_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_service_failure_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteAccountPasswordPolicyError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::DeleteAccountPasswordPolicyError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_account_password_policy_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteAccountPasswordPolicyOutput,
    crate::error::DeleteAccountPasswordPolicyError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_account_password_policy_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_group_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteGroupOutput, crate::error::DeleteGroupError> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::DeleteGroupError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DeleteGroupError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DeleteConflict" => crate::error::DeleteGroupError {
            meta: generic,
            kind: crate::error::DeleteGroupErrorKind::DeleteConflictException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::delete_conflict_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_delete_conflict_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteGroupError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "LimitExceeded" => crate::error::DeleteGroupError {
            meta: generic,
            kind: crate::error::DeleteGroupErrorKind::LimitExceededException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_limit_exceeded_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteGroupError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "NoSuchEntity" => crate::error::DeleteGroupError {
            meta: generic,
            kind: crate::error::DeleteGroupErrorKind::NoSuchEntityException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::no_such_entity_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_no_such_entity_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteGroupError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ServiceFailure" => crate::error::DeleteGroupError {
            meta: generic,
            kind: crate::error::DeleteGroupErrorKind::ServiceFailureException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::service_failure_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_service_failure_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteGroupError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::DeleteGroupError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_group_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteGroupOutput, crate::error::DeleteGroupError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_group_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_group_policy_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteGroupPolicyOutput, crate::error::DeleteGroupPolicyError>
{
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::DeleteGroupPolicyError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DeleteGroupPolicyError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "LimitExceeded" => crate::error::DeleteGroupPolicyError {
            meta: generic,
            kind: crate::error::DeleteGroupPolicyErrorKind::LimitExceededException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_limit_exceeded_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteGroupPolicyError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "NoSuchEntity" => crate::error::DeleteGroupPolicyError {
            meta: generic,
            kind: crate::error::DeleteGroupPolicyErrorKind::NoSuchEntityException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::no_such_entity_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_no_such_entity_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteGroupPolicyError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ServiceFailure" => crate::error::DeleteGroupPolicyError {
            meta: generic,
            kind: crate::error::DeleteGroupPolicyErrorKind::ServiceFailureException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::service_failure_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_service_failure_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteGroupPolicyError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::DeleteGroupPolicyError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_group_policy_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteGroupPolicyOutput, crate::error::DeleteGroupPolicyError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_group_policy_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_instance_profile_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteInstanceProfileOutput,
    crate::error::DeleteInstanceProfileError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::DeleteInstanceProfileError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DeleteInstanceProfileError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DeleteConflict" => crate::error::DeleteInstanceProfileError {
            meta: generic,
            kind: crate::error::DeleteInstanceProfileErrorKind::DeleteConflictException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::delete_conflict_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_delete_conflict_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteInstanceProfileError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "LimitExceeded" => crate::error::DeleteInstanceProfileError {
            meta: generic,
            kind: crate::error::DeleteInstanceProfileErrorKind::LimitExceededException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_limit_exceeded_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteInstanceProfileError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "NoSuchEntity" => crate::error::DeleteInstanceProfileError {
            meta: generic,
            kind: crate::error::DeleteInstanceProfileErrorKind::NoSuchEntityException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::no_such_entity_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_no_such_entity_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteInstanceProfileError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ServiceFailure" => crate::error::DeleteInstanceProfileError {
            meta: generic,
            kind: crate::error::DeleteInstanceProfileErrorKind::ServiceFailureException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::service_failure_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_service_failure_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteInstanceProfileError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::DeleteInstanceProfileError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_instance_profile_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteInstanceProfileOutput,
    crate::error::DeleteInstanceProfileError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_instance_profile_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_login_profile_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteLoginProfileOutput,
    crate::error::DeleteLoginProfileError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::DeleteLoginProfileError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DeleteLoginProfileError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "EntityTemporarilyUnmodifiable" => crate::error::DeleteLoginProfileError {
            meta: generic,
            kind: crate::error::DeleteLoginProfileErrorKind::EntityTemporarilyUnmodifiableException(
                {
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]let mut output = crate::error::entity_temporarily_unmodifiable_exception::Builder::default();
                        let _ = response;
                        output = crate::xml_deser::deser_structure_crate_error_entity_temporarily_unmodifiable_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteLoginProfileError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                },
            ),
        },
        "LimitExceeded" => crate::error::DeleteLoginProfileError {
            meta: generic,
            kind: crate::error::DeleteLoginProfileErrorKind::LimitExceededException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_limit_exceeded_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteLoginProfileError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "NoSuchEntity" => crate::error::DeleteLoginProfileError {
            meta: generic,
            kind: crate::error::DeleteLoginProfileErrorKind::NoSuchEntityException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::no_such_entity_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_no_such_entity_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteLoginProfileError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ServiceFailure" => crate::error::DeleteLoginProfileError {
            meta: generic,
            kind: crate::error::DeleteLoginProfileErrorKind::ServiceFailureException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::service_failure_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_service_failure_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteLoginProfileError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::DeleteLoginProfileError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_login_profile_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteLoginProfileOutput,
    crate::error::DeleteLoginProfileError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_login_profile_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_open_id_connect_provider_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteOpenIdConnectProviderOutput,
    crate::error::DeleteOpenIDConnectProviderError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::DeleteOpenIDConnectProviderError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DeleteOpenIDConnectProviderError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InvalidInput" => crate::error::DeleteOpenIDConnectProviderError {
            meta: generic,
            kind: crate::error::DeleteOpenIDConnectProviderErrorKind::InvalidInputException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_input_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_input_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteOpenIDConnectProviderError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "NoSuchEntity" => crate::error::DeleteOpenIDConnectProviderError {
            meta: generic,
            kind: crate::error::DeleteOpenIDConnectProviderErrorKind::NoSuchEntityException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::no_such_entity_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_no_such_entity_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteOpenIDConnectProviderError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ServiceFailure" => crate::error::DeleteOpenIDConnectProviderError {
            meta: generic,
            kind: crate::error::DeleteOpenIDConnectProviderErrorKind::ServiceFailureException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::service_failure_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_service_failure_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteOpenIDConnectProviderError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::DeleteOpenIDConnectProviderError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_open_id_connect_provider_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteOpenIdConnectProviderOutput,
    crate::error::DeleteOpenIDConnectProviderError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_open_id_connect_provider_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_policy_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeletePolicyOutput, crate::error::DeletePolicyError> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::DeletePolicyError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DeletePolicyError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DeleteConflict" => crate::error::DeletePolicyError {
            meta: generic,
            kind: crate::error::DeletePolicyErrorKind::DeleteConflictException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::delete_conflict_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_delete_conflict_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::DeletePolicyError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidInput" => crate::error::DeletePolicyError {
            meta: generic,
            kind: crate::error::DeletePolicyErrorKind::InvalidInputException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_input_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_input_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::DeletePolicyError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "LimitExceeded" => crate::error::DeletePolicyError {
            meta: generic,
            kind: crate::error::DeletePolicyErrorKind::LimitExceededException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_limit_exceeded_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::DeletePolicyError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "NoSuchEntity" => crate::error::DeletePolicyError {
            meta: generic,
            kind: crate::error::DeletePolicyErrorKind::NoSuchEntityException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::no_such_entity_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_no_such_entity_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::DeletePolicyError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ServiceFailure" => crate::error::DeletePolicyError {
            meta: generic,
            kind: crate::error::DeletePolicyErrorKind::ServiceFailureException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::service_failure_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_service_failure_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::DeletePolicyError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::DeletePolicyError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_policy_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeletePolicyOutput, crate::error::DeletePolicyError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_policy_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_policy_version_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeletePolicyVersionOutput,
    crate::error::DeletePolicyVersionError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::DeletePolicyVersionError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DeletePolicyVersionError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DeleteConflict" => crate::error::DeletePolicyVersionError {
            meta: generic,
            kind: crate::error::DeletePolicyVersionErrorKind::DeleteConflictException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::delete_conflict_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_delete_conflict_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::DeletePolicyVersionError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidInput" => crate::error::DeletePolicyVersionError {
            meta: generic,
            kind: crate::error::DeletePolicyVersionErrorKind::InvalidInputException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_input_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_input_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::DeletePolicyVersionError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "LimitExceeded" => crate::error::DeletePolicyVersionError {
            meta: generic,
            kind: crate::error::DeletePolicyVersionErrorKind::LimitExceededException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_limit_exceeded_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::DeletePolicyVersionError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "NoSuchEntity" => crate::error::DeletePolicyVersionError {
            meta: generic,
            kind: crate::error::DeletePolicyVersionErrorKind::NoSuchEntityException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::no_such_entity_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_no_such_entity_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::DeletePolicyVersionError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ServiceFailure" => crate::error::DeletePolicyVersionError {
            meta: generic,
            kind: crate::error::DeletePolicyVersionErrorKind::ServiceFailureException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::service_failure_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_service_failure_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::DeletePolicyVersionError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::DeletePolicyVersionError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_policy_version_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeletePolicyVersionOutput,
    crate::error::DeletePolicyVersionError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_policy_version_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_role_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteRoleOutput, crate::error::DeleteRoleError> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::DeleteRoleError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DeleteRoleError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ConcurrentModification" => crate::error::DeleteRoleError {
            meta: generic,
            kind: crate::error::DeleteRoleErrorKind::ConcurrentModificationException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::concurrent_modification_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_concurrent_modification_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteRoleError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "DeleteConflict" => crate::error::DeleteRoleError {
            meta: generic,
            kind: crate::error::DeleteRoleErrorKind::DeleteConflictException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::delete_conflict_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_delete_conflict_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteRoleError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "LimitExceeded" => crate::error::DeleteRoleError {
            meta: generic,
            kind: crate::error::DeleteRoleErrorKind::LimitExceededException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_limit_exceeded_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteRoleError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "NoSuchEntity" => crate::error::DeleteRoleError {
            meta: generic,
            kind: crate::error::DeleteRoleErrorKind::NoSuchEntityException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::no_such_entity_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_no_such_entity_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteRoleError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ServiceFailure" => crate::error::DeleteRoleError {
            meta: generic,
            kind: crate::error::DeleteRoleErrorKind::ServiceFailureException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::service_failure_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_service_failure_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteRoleError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "UnmodifiableEntity" => crate::error::DeleteRoleError {
            meta: generic,
            kind: crate::error::DeleteRoleErrorKind::UnmodifiableEntityException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::unmodifiable_entity_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_unmodifiable_entity_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteRoleError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::DeleteRoleError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_role_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteRoleOutput, crate::error::DeleteRoleError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_role_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_role_permissions_boundary_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteRolePermissionsBoundaryOutput,
    crate::error::DeleteRolePermissionsBoundaryError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::DeleteRolePermissionsBoundaryError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DeleteRolePermissionsBoundaryError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "NoSuchEntity" => crate::error::DeleteRolePermissionsBoundaryError {
            meta: generic,
            kind: crate::error::DeleteRolePermissionsBoundaryErrorKind::NoSuchEntityException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::no_such_entity_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_no_such_entity_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteRolePermissionsBoundaryError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ServiceFailure" => crate::error::DeleteRolePermissionsBoundaryError {
            meta: generic,
            kind: crate::error::DeleteRolePermissionsBoundaryErrorKind::ServiceFailureException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::service_failure_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_service_failure_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteRolePermissionsBoundaryError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "UnmodifiableEntity" => crate::error::DeleteRolePermissionsBoundaryError {
            meta: generic,
            kind: crate::error::DeleteRolePermissionsBoundaryErrorKind::UnmodifiableEntityException(
                {
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::unmodifiable_entity_exception::Builder::default();
                        let _ = response;
                        output = crate::xml_deser::deser_structure_crate_error_unmodifiable_entity_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteRolePermissionsBoundaryError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                },
            ),
        },
        _ => crate::error::DeleteRolePermissionsBoundaryError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_role_permissions_boundary_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteRolePermissionsBoundaryOutput,
    crate::error::DeleteRolePermissionsBoundaryError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_role_permissions_boundary_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_role_policy_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteRolePolicyOutput, crate::error::DeleteRolePolicyError>
{
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::DeleteRolePolicyError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DeleteRolePolicyError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "LimitExceeded" => crate::error::DeleteRolePolicyError {
            meta: generic,
            kind: crate::error::DeleteRolePolicyErrorKind::LimitExceededException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_limit_exceeded_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteRolePolicyError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "NoSuchEntity" => crate::error::DeleteRolePolicyError {
            meta: generic,
            kind: crate::error::DeleteRolePolicyErrorKind::NoSuchEntityException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::no_such_entity_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_no_such_entity_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteRolePolicyError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ServiceFailure" => crate::error::DeleteRolePolicyError {
            meta: generic,
            kind: crate::error::DeleteRolePolicyErrorKind::ServiceFailureException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::service_failure_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_service_failure_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteRolePolicyError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "UnmodifiableEntity" => crate::error::DeleteRolePolicyError {
            meta: generic,
            kind: crate::error::DeleteRolePolicyErrorKind::UnmodifiableEntityException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::unmodifiable_entity_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_unmodifiable_entity_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteRolePolicyError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::DeleteRolePolicyError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_role_policy_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteRolePolicyOutput, crate::error::DeleteRolePolicyError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_role_policy_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_saml_provider_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteSamlProviderOutput,
    crate::error::DeleteSAMLProviderError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::DeleteSAMLProviderError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DeleteSAMLProviderError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InvalidInput" => crate::error::DeleteSAMLProviderError {
            meta: generic,
            kind: crate::error::DeleteSAMLProviderErrorKind::InvalidInputException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_input_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_input_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteSAMLProviderError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "LimitExceeded" => crate::error::DeleteSAMLProviderError {
            meta: generic,
            kind: crate::error::DeleteSAMLProviderErrorKind::LimitExceededException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_limit_exceeded_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteSAMLProviderError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "NoSuchEntity" => crate::error::DeleteSAMLProviderError {
            meta: generic,
            kind: crate::error::DeleteSAMLProviderErrorKind::NoSuchEntityException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::no_such_entity_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_no_such_entity_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteSAMLProviderError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ServiceFailure" => crate::error::DeleteSAMLProviderError {
            meta: generic,
            kind: crate::error::DeleteSAMLProviderErrorKind::ServiceFailureException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::service_failure_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_service_failure_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteSAMLProviderError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::DeleteSAMLProviderError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_saml_provider_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteSamlProviderOutput,
    crate::error::DeleteSAMLProviderError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_saml_provider_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_server_certificate_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteServerCertificateOutput,
    crate::error::DeleteServerCertificateError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::DeleteServerCertificateError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DeleteServerCertificateError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DeleteConflict" => crate::error::DeleteServerCertificateError {
            meta: generic,
            kind: crate::error::DeleteServerCertificateErrorKind::DeleteConflictException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::delete_conflict_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_delete_conflict_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteServerCertificateError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "LimitExceeded" => crate::error::DeleteServerCertificateError {
            meta: generic,
            kind: crate::error::DeleteServerCertificateErrorKind::LimitExceededException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_limit_exceeded_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteServerCertificateError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "NoSuchEntity" => crate::error::DeleteServerCertificateError {
            meta: generic,
            kind: crate::error::DeleteServerCertificateErrorKind::NoSuchEntityException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::no_such_entity_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_no_such_entity_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteServerCertificateError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ServiceFailure" => crate::error::DeleteServerCertificateError {
            meta: generic,
            kind: crate::error::DeleteServerCertificateErrorKind::ServiceFailureException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::service_failure_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_service_failure_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteServerCertificateError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::DeleteServerCertificateError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_server_certificate_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteServerCertificateOutput,
    crate::error::DeleteServerCertificateError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_server_certificate_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_service_linked_role_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteServiceLinkedRoleOutput,
    crate::error::DeleteServiceLinkedRoleError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::DeleteServiceLinkedRoleError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DeleteServiceLinkedRoleError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "LimitExceeded" => crate::error::DeleteServiceLinkedRoleError {
            meta: generic,
            kind: crate::error::DeleteServiceLinkedRoleErrorKind::LimitExceededException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_limit_exceeded_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteServiceLinkedRoleError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "NoSuchEntity" => crate::error::DeleteServiceLinkedRoleError {
            meta: generic,
            kind: crate::error::DeleteServiceLinkedRoleErrorKind::NoSuchEntityException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::no_such_entity_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_no_such_entity_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteServiceLinkedRoleError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ServiceFailure" => crate::error::DeleteServiceLinkedRoleError {
            meta: generic,
            kind: crate::error::DeleteServiceLinkedRoleErrorKind::ServiceFailureException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::service_failure_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_service_failure_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteServiceLinkedRoleError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::DeleteServiceLinkedRoleError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_service_linked_role_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteServiceLinkedRoleOutput,
    crate::error::DeleteServiceLinkedRoleError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_service_linked_role_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_delete_service_linked_role(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DeleteServiceLinkedRoleError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_service_specific_credential_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteServiceSpecificCredentialOutput,
    crate::error::DeleteServiceSpecificCredentialError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::DeleteServiceSpecificCredentialError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DeleteServiceSpecificCredentialError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "NoSuchEntity" => crate::error::DeleteServiceSpecificCredentialError {
            meta: generic,
            kind: crate::error::DeleteServiceSpecificCredentialErrorKind::NoSuchEntityException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::no_such_entity_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_no_such_entity_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteServiceSpecificCredentialError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::DeleteServiceSpecificCredentialError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_service_specific_credential_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteServiceSpecificCredentialOutput,
    crate::error::DeleteServiceSpecificCredentialError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::delete_service_specific_credential_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_signing_certificate_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteSigningCertificateOutput,
    crate::error::DeleteSigningCertificateError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::DeleteSigningCertificateError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DeleteSigningCertificateError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "LimitExceeded" => crate::error::DeleteSigningCertificateError {
            meta: generic,
            kind: crate::error::DeleteSigningCertificateErrorKind::LimitExceededException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_limit_exceeded_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteSigningCertificateError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "NoSuchEntity" => crate::error::DeleteSigningCertificateError {
            meta: generic,
            kind: crate::error::DeleteSigningCertificateErrorKind::NoSuchEntityException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::no_such_entity_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_no_such_entity_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteSigningCertificateError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ServiceFailure" => crate::error::DeleteSigningCertificateError {
            meta: generic,
            kind: crate::error::DeleteSigningCertificateErrorKind::ServiceFailureException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::service_failure_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_service_failure_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteSigningCertificateError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::DeleteSigningCertificateError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_signing_certificate_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteSigningCertificateOutput,
    crate::error::DeleteSigningCertificateError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_signing_certificate_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_ssh_public_key_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteSshPublicKeyOutput,
    crate::error::DeleteSSHPublicKeyError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::DeleteSSHPublicKeyError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DeleteSSHPublicKeyError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "NoSuchEntity" => crate::error::DeleteSSHPublicKeyError {
            meta: generic,
            kind: crate::error::DeleteSSHPublicKeyErrorKind::NoSuchEntityException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::no_such_entity_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_no_such_entity_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteSSHPublicKeyError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::DeleteSSHPublicKeyError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_ssh_public_key_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteSshPublicKeyOutput,
    crate::error::DeleteSSHPublicKeyError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_ssh_public_key_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_user_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteUserOutput, crate::error::DeleteUserError> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::DeleteUserError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DeleteUserError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ConcurrentModification" => crate::error::DeleteUserError {
            meta: generic,
            kind: crate::error::DeleteUserErrorKind::ConcurrentModificationException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::concurrent_modification_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_concurrent_modification_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteUserError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "DeleteConflict" => crate::error::DeleteUserError {
            meta: generic,
            kind: crate::error::DeleteUserErrorKind::DeleteConflictException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::delete_conflict_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_delete_conflict_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteUserError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "LimitExceeded" => crate::error::DeleteUserError {
            meta: generic,
            kind: crate::error::DeleteUserErrorKind::LimitExceededException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_limit_exceeded_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteUserError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "NoSuchEntity" => crate::error::DeleteUserError {
            meta: generic,
            kind: crate::error::DeleteUserErrorKind::NoSuchEntityException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::no_such_entity_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_no_such_entity_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteUserError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ServiceFailure" => crate::error::DeleteUserError {
            meta: generic,
            kind: crate::error::DeleteUserErrorKind::ServiceFailureException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::service_failure_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_service_failure_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteUserError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::DeleteUserError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_user_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteUserOutput, crate::error::DeleteUserError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_user_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_user_permissions_boundary_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteUserPermissionsBoundaryOutput,
    crate::error::DeleteUserPermissionsBoundaryError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::DeleteUserPermissionsBoundaryError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DeleteUserPermissionsBoundaryError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "NoSuchEntity" => crate::error::DeleteUserPermissionsBoundaryError {
            meta: generic,
            kind: crate::error::DeleteUserPermissionsBoundaryErrorKind::NoSuchEntityException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::no_such_entity_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_no_such_entity_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteUserPermissionsBoundaryError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ServiceFailure" => crate::error::DeleteUserPermissionsBoundaryError {
            meta: generic,
            kind: crate::error::DeleteUserPermissionsBoundaryErrorKind::ServiceFailureException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::service_failure_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_service_failure_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteUserPermissionsBoundaryError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::DeleteUserPermissionsBoundaryError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_user_permissions_boundary_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteUserPermissionsBoundaryOutput,
    crate::error::DeleteUserPermissionsBoundaryError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_user_permissions_boundary_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_user_policy_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteUserPolicyOutput, crate::error::DeleteUserPolicyError>
{
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::DeleteUserPolicyError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DeleteUserPolicyError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "LimitExceeded" => crate::error::DeleteUserPolicyError {
            meta: generic,
            kind: crate::error::DeleteUserPolicyErrorKind::LimitExceededException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_limit_exceeded_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteUserPolicyError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "NoSuchEntity" => crate::error::DeleteUserPolicyError {
            meta: generic,
            kind: crate::error::DeleteUserPolicyErrorKind::NoSuchEntityException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::no_such_entity_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_no_such_entity_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteUserPolicyError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ServiceFailure" => crate::error::DeleteUserPolicyError {
            meta: generic,
            kind: crate::error::DeleteUserPolicyErrorKind::ServiceFailureException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::service_failure_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_service_failure_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteUserPolicyError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::DeleteUserPolicyError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_user_policy_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteUserPolicyOutput, crate::error::DeleteUserPolicyError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_user_policy_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_virtual_mfa_device_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteVirtualMfaDeviceOutput,
    crate::error::DeleteVirtualMFADeviceError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::DeleteVirtualMFADeviceError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DeleteVirtualMFADeviceError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DeleteConflict" => crate::error::DeleteVirtualMFADeviceError {
            meta: generic,
            kind: crate::error::DeleteVirtualMFADeviceErrorKind::DeleteConflictException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::delete_conflict_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_delete_conflict_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteVirtualMFADeviceError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "LimitExceeded" => crate::error::DeleteVirtualMFADeviceError {
            meta: generic,
            kind: crate::error::DeleteVirtualMFADeviceErrorKind::LimitExceededException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_limit_exceeded_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteVirtualMFADeviceError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "NoSuchEntity" => crate::error::DeleteVirtualMFADeviceError {
            meta: generic,
            kind: crate::error::DeleteVirtualMFADeviceErrorKind::NoSuchEntityException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::no_such_entity_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_no_such_entity_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteVirtualMFADeviceError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ServiceFailure" => crate::error::DeleteVirtualMFADeviceError {
            meta: generic,
            kind: crate::error::DeleteVirtualMFADeviceErrorKind::ServiceFailureException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::service_failure_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_service_failure_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteVirtualMFADeviceError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::DeleteVirtualMFADeviceError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_virtual_mfa_device_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteVirtualMfaDeviceOutput,
    crate::error::DeleteVirtualMFADeviceError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_virtual_mfa_device_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_detach_group_policy_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DetachGroupPolicyOutput, crate::error::DetachGroupPolicyError>
{
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::DetachGroupPolicyError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DetachGroupPolicyError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InvalidInput" => crate::error::DetachGroupPolicyError {
            meta: generic,
            kind: crate::error::DetachGroupPolicyErrorKind::InvalidInputException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_input_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_input_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::DetachGroupPolicyError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "LimitExceeded" => crate::error::DetachGroupPolicyError {
            meta: generic,
            kind: crate::error::DetachGroupPolicyErrorKind::LimitExceededException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_limit_exceeded_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::DetachGroupPolicyError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "NoSuchEntity" => crate::error::DetachGroupPolicyError {
            meta: generic,
            kind: crate::error::DetachGroupPolicyErrorKind::NoSuchEntityException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::no_such_entity_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_no_such_entity_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::DetachGroupPolicyError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ServiceFailure" => crate::error::DetachGroupPolicyError {
            meta: generic,
            kind: crate::error::DetachGroupPolicyErrorKind::ServiceFailureException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::service_failure_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_service_failure_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::DetachGroupPolicyError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::DetachGroupPolicyError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_detach_group_policy_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DetachGroupPolicyOutput, crate::error::DetachGroupPolicyError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::detach_group_policy_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_detach_role_policy_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DetachRolePolicyOutput, crate::error::DetachRolePolicyError>
{
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::DetachRolePolicyError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DetachRolePolicyError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InvalidInput" => crate::error::DetachRolePolicyError {
            meta: generic,
            kind: crate::error::DetachRolePolicyErrorKind::InvalidInputException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_input_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_input_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::DetachRolePolicyError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "LimitExceeded" => crate::error::DetachRolePolicyError {
            meta: generic,
            kind: crate::error::DetachRolePolicyErrorKind::LimitExceededException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_limit_exceeded_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::DetachRolePolicyError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "NoSuchEntity" => crate::error::DetachRolePolicyError {
            meta: generic,
            kind: crate::error::DetachRolePolicyErrorKind::NoSuchEntityException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::no_such_entity_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_no_such_entity_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::DetachRolePolicyError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ServiceFailure" => crate::error::DetachRolePolicyError {
            meta: generic,
            kind: crate::error::DetachRolePolicyErrorKind::ServiceFailureException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::service_failure_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_service_failure_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::DetachRolePolicyError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "UnmodifiableEntity" => crate::error::DetachRolePolicyError {
            meta: generic,
            kind: crate::error::DetachRolePolicyErrorKind::UnmodifiableEntityException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::unmodifiable_entity_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_unmodifiable_entity_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::DetachRolePolicyError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::DetachRolePolicyError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_detach_role_policy_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DetachRolePolicyOutput, crate::error::DetachRolePolicyError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::detach_role_policy_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_detach_user_policy_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DetachUserPolicyOutput, crate::error::DetachUserPolicyError>
{
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::DetachUserPolicyError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DetachUserPolicyError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InvalidInput" => crate::error::DetachUserPolicyError {
            meta: generic,
            kind: crate::error::DetachUserPolicyErrorKind::InvalidInputException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_input_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_input_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::DetachUserPolicyError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "LimitExceeded" => crate::error::DetachUserPolicyError {
            meta: generic,
            kind: crate::error::DetachUserPolicyErrorKind::LimitExceededException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_limit_exceeded_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::DetachUserPolicyError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "NoSuchEntity" => crate::error::DetachUserPolicyError {
            meta: generic,
            kind: crate::error::DetachUserPolicyErrorKind::NoSuchEntityException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::no_such_entity_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_no_such_entity_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::DetachUserPolicyError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ServiceFailure" => crate::error::DetachUserPolicyError {
            meta: generic,
            kind: crate::error::DetachUserPolicyErrorKind::ServiceFailureException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::service_failure_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_service_failure_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::DetachUserPolicyError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::DetachUserPolicyError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_detach_user_policy_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DetachUserPolicyOutput, crate::error::DetachUserPolicyError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::detach_user_policy_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_enable_mfa_device_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::EnableMfaDeviceOutput, crate::error::EnableMFADeviceError> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::EnableMFADeviceError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::EnableMFADeviceError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "EntityAlreadyExists" => crate::error::EnableMFADeviceError {
            meta: generic,
            kind: crate::error::EnableMFADeviceErrorKind::EntityAlreadyExistsException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::entity_already_exists_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_entity_already_exists_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::EnableMFADeviceError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "EntityTemporarilyUnmodifiable" => crate::error::EnableMFADeviceError {
            meta: generic,
            kind: crate::error::EnableMFADeviceErrorKind::EntityTemporarilyUnmodifiableException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::entity_temporarily_unmodifiable_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_entity_temporarily_unmodifiable_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::EnableMFADeviceError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidAuthenticationCode" => crate::error::EnableMFADeviceError {
            meta: generic,
            kind: crate::error::EnableMFADeviceErrorKind::InvalidAuthenticationCodeException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_authentication_code_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_authentication_code_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::EnableMFADeviceError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "LimitExceeded" => crate::error::EnableMFADeviceError {
            meta: generic,
            kind: crate::error::EnableMFADeviceErrorKind::LimitExceededException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_limit_exceeded_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::EnableMFADeviceError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "NoSuchEntity" => crate::error::EnableMFADeviceError {
            meta: generic,
            kind: crate::error::EnableMFADeviceErrorKind::NoSuchEntityException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::no_such_entity_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_no_such_entity_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::EnableMFADeviceError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ServiceFailure" => crate::error::EnableMFADeviceError {
            meta: generic,
            kind: crate::error::EnableMFADeviceErrorKind::ServiceFailureException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::service_failure_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_service_failure_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::EnableMFADeviceError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::EnableMFADeviceError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_enable_mfa_device_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::EnableMfaDeviceOutput, crate::error::EnableMFADeviceError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::enable_mfa_device_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_generate_credential_report_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GenerateCredentialReportOutput,
    crate::error::GenerateCredentialReportError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::GenerateCredentialReportError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::GenerateCredentialReportError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "LimitExceeded" => crate::error::GenerateCredentialReportError {
            meta: generic,
            kind: crate::error::GenerateCredentialReportErrorKind::LimitExceededException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_limit_exceeded_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::GenerateCredentialReportError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ServiceFailure" => crate::error::GenerateCredentialReportError {
            meta: generic,
            kind: crate::error::GenerateCredentialReportErrorKind::ServiceFailureException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::service_failure_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_service_failure_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::GenerateCredentialReportError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::GenerateCredentialReportError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_generate_credential_report_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GenerateCredentialReportOutput,
    crate::error::GenerateCredentialReportError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::generate_credential_report_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_generate_credential_report(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::GenerateCredentialReportError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_generate_organizations_access_report_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GenerateOrganizationsAccessReportOutput,
    crate::error::GenerateOrganizationsAccessReportError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::GenerateOrganizationsAccessReportError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::GenerateOrganizationsAccessReportError::unhandled(generic))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ReportGenerationLimitExceeded" => crate::error::GenerateOrganizationsAccessReportError { meta: generic, kind: crate::error::GenerateOrganizationsAccessReportErrorKind::ReportGenerationLimitExceededException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::report_generation_limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_report_generation_limit_exceeded_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::GenerateOrganizationsAccessReportError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::GenerateOrganizationsAccessReportError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_generate_organizations_access_report_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GenerateOrganizationsAccessReportOutput,
    crate::error::GenerateOrganizationsAccessReportError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::generate_organizations_access_report_output::Builder::default();
        let _ = response;
        output =
            crate::xml_deser::deser_operation_crate_operation_generate_organizations_access_report(
                response.body().as_ref(),
                output,
            )
            .map_err(crate::error::GenerateOrganizationsAccessReportError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_generate_service_last_accessed_details_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GenerateServiceLastAccessedDetailsOutput,
    crate::error::GenerateServiceLastAccessedDetailsError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::GenerateServiceLastAccessedDetailsError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::GenerateServiceLastAccessedDetailsError::unhandled(generic))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InvalidInput" => crate::error::GenerateServiceLastAccessedDetailsError {
            meta: generic,
            kind: crate::error::GenerateServiceLastAccessedDetailsErrorKind::InvalidInputException(
                {
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output = crate::error::invalid_input_exception::Builder::default();
                        let _ = response;
                        output = crate::xml_deser::deser_structure_crate_error_invalid_input_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::GenerateServiceLastAccessedDetailsError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                },
            ),
        },
        "NoSuchEntity" => crate::error::GenerateServiceLastAccessedDetailsError {
            meta: generic,
            kind: crate::error::GenerateServiceLastAccessedDetailsErrorKind::NoSuchEntityException(
                {
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output = crate::error::no_such_entity_exception::Builder::default();
                        let _ = response;
                        output = crate::xml_deser::deser_structure_crate_error_no_such_entity_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::GenerateServiceLastAccessedDetailsError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                },
            ),
        },
        _ => crate::error::GenerateServiceLastAccessedDetailsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_generate_service_last_accessed_details_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GenerateServiceLastAccessedDetailsOutput,
    crate::error::GenerateServiceLastAccessedDetailsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::generate_service_last_accessed_details_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_generate_service_last_accessed_details(response.body().as_ref(), output).map_err(crate::error::GenerateServiceLastAccessedDetailsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_access_key_last_used_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetAccessKeyLastUsedOutput,
    crate::error::GetAccessKeyLastUsedError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::GetAccessKeyLastUsedError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::GetAccessKeyLastUsedError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "NoSuchEntity" => crate::error::GetAccessKeyLastUsedError {
            meta: generic,
            kind: crate::error::GetAccessKeyLastUsedErrorKind::NoSuchEntityException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::no_such_entity_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_no_such_entity_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::GetAccessKeyLastUsedError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::GetAccessKeyLastUsedError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_access_key_last_used_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetAccessKeyLastUsedOutput,
    crate::error::GetAccessKeyLastUsedError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_access_key_last_used_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_get_access_key_last_used(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::GetAccessKeyLastUsedError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_account_authorization_details_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetAccountAuthorizationDetailsOutput,
    crate::error::GetAccountAuthorizationDetailsError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::GetAccountAuthorizationDetailsError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::GetAccountAuthorizationDetailsError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ServiceFailure" => crate::error::GetAccountAuthorizationDetailsError {
            meta: generic,
            kind: crate::error::GetAccountAuthorizationDetailsErrorKind::ServiceFailureException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::service_failure_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_service_failure_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::GetAccountAuthorizationDetailsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::GetAccountAuthorizationDetailsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_account_authorization_details_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetAccountAuthorizationDetailsOutput,
    crate::error::GetAccountAuthorizationDetailsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::get_account_authorization_details_output::Builder::default();
        let _ = response;
        output =
            crate::xml_deser::deser_operation_crate_operation_get_account_authorization_details(
                response.body().as_ref(),
                output,
            )
            .map_err(crate::error::GetAccountAuthorizationDetailsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_account_password_policy_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetAccountPasswordPolicyOutput,
    crate::error::GetAccountPasswordPolicyError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::GetAccountPasswordPolicyError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::GetAccountPasswordPolicyError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "NoSuchEntity" => crate::error::GetAccountPasswordPolicyError {
            meta: generic,
            kind: crate::error::GetAccountPasswordPolicyErrorKind::NoSuchEntityException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::no_such_entity_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_no_such_entity_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::GetAccountPasswordPolicyError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ServiceFailure" => crate::error::GetAccountPasswordPolicyError {
            meta: generic,
            kind: crate::error::GetAccountPasswordPolicyErrorKind::ServiceFailureException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::service_failure_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_service_failure_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::GetAccountPasswordPolicyError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::GetAccountPasswordPolicyError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_account_password_policy_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetAccountPasswordPolicyOutput,
    crate::error::GetAccountPasswordPolicyError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_account_password_policy_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_get_account_password_policy(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::GetAccountPasswordPolicyError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_account_summary_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetAccountSummaryOutput, crate::error::GetAccountSummaryError>
{
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::GetAccountSummaryError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::GetAccountSummaryError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ServiceFailure" => crate::error::GetAccountSummaryError {
            meta: generic,
            kind: crate::error::GetAccountSummaryErrorKind::ServiceFailureException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::service_failure_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_service_failure_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::GetAccountSummaryError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::GetAccountSummaryError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_account_summary_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetAccountSummaryOutput, crate::error::GetAccountSummaryError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_account_summary_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_get_account_summary(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::GetAccountSummaryError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_context_keys_for_custom_policy_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetContextKeysForCustomPolicyOutput,
    crate::error::GetContextKeysForCustomPolicyError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::GetContextKeysForCustomPolicyError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::GetContextKeysForCustomPolicyError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InvalidInput" => crate::error::GetContextKeysForCustomPolicyError {
            meta: generic,
            kind: crate::error::GetContextKeysForCustomPolicyErrorKind::InvalidInputException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_input_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_input_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::GetContextKeysForCustomPolicyError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::GetContextKeysForCustomPolicyError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_context_keys_for_custom_policy_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetContextKeysForCustomPolicyOutput,
    crate::error::GetContextKeysForCustomPolicyError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::get_context_keys_for_custom_policy_output::Builder::default();
        let _ = response;
        output =
            crate::xml_deser::deser_operation_crate_operation_get_context_keys_for_custom_policy(
                response.body().as_ref(),
                output,
            )
            .map_err(crate::error::GetContextKeysForCustomPolicyError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_context_keys_for_principal_policy_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetContextKeysForPrincipalPolicyOutput,
    crate::error::GetContextKeysForPrincipalPolicyError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::GetContextKeysForPrincipalPolicyError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::GetContextKeysForPrincipalPolicyError::unhandled(generic))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InvalidInput" => crate::error::GetContextKeysForPrincipalPolicyError {
            meta: generic,
            kind: crate::error::GetContextKeysForPrincipalPolicyErrorKind::InvalidInputException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_input_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_input_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::GetContextKeysForPrincipalPolicyError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "NoSuchEntity" => crate::error::GetContextKeysForPrincipalPolicyError {
            meta: generic,
            kind: crate::error::GetContextKeysForPrincipalPolicyErrorKind::NoSuchEntityException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::no_such_entity_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_no_such_entity_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::GetContextKeysForPrincipalPolicyError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::GetContextKeysForPrincipalPolicyError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_context_keys_for_principal_policy_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetContextKeysForPrincipalPolicyOutput,
    crate::error::GetContextKeysForPrincipalPolicyError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::get_context_keys_for_principal_policy_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_get_context_keys_for_principal_policy(response.body().as_ref(), output).map_err(crate::error::GetContextKeysForPrincipalPolicyError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_credential_report_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetCredentialReportOutput,
    crate::error::GetCredentialReportError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::GetCredentialReportError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::GetCredentialReportError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ReportExpired" => crate::error::GetCredentialReportError {
            meta: generic,
            kind: crate::error::GetCredentialReportErrorKind::CredentialReportExpiredException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::credential_report_expired_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_credential_report_expired_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::GetCredentialReportError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ReportNotPresent" => {
            crate::error::GetCredentialReportError {
                meta: generic,
                kind:
                    crate::error::GetCredentialReportErrorKind::CredentialReportNotPresentException(
                        {
                            #[allow(unused_mut)]
                            let mut tmp = {
                                #[allow(unused_mut)]let mut output = crate::error::credential_report_not_present_exception::Builder::default();
                                let _ = response;
                                output = crate::xml_deser::deser_structure_crate_error_credential_report_not_present_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::GetCredentialReportError::unhandled)?;
                                output.build()
                            };
                            if (&tmp.message).is_none() {
                                tmp.message = _error_message;
                            }
                            tmp
                        },
                    ),
            }
        }
        "ReportInProgress" => crate::error::GetCredentialReportError {
            meta: generic,
            kind: crate::error::GetCredentialReportErrorKind::CredentialReportNotReadyException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::credential_report_not_ready_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_credential_report_not_ready_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::GetCredentialReportError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ServiceFailure" => crate::error::GetCredentialReportError {
            meta: generic,
            kind: crate::error::GetCredentialReportErrorKind::ServiceFailureException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::service_failure_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_service_failure_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::GetCredentialReportError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::GetCredentialReportError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_credential_report_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetCredentialReportOutput,
    crate::error::GetCredentialReportError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_credential_report_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_get_credential_report(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::GetCredentialReportError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_group_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetGroupOutput, crate::error::GetGroupError> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::GetGroupError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::GetGroupError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "NoSuchEntity" => crate::error::GetGroupError {
            meta: generic,
            kind: crate::error::GetGroupErrorKind::NoSuchEntityException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::no_such_entity_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_no_such_entity_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::GetGroupError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ServiceFailure" => crate::error::GetGroupError {
            meta: generic,
            kind: crate::error::GetGroupErrorKind::ServiceFailureException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::service_failure_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_service_failure_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::GetGroupError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::GetGroupError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_group_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetGroupOutput, crate::error::GetGroupError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_group_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_get_group(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::GetGroupError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_group_policy_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetGroupPolicyOutput, crate::error::GetGroupPolicyError> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::GetGroupPolicyError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::GetGroupPolicyError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "NoSuchEntity" => crate::error::GetGroupPolicyError {
            meta: generic,
            kind: crate::error::GetGroupPolicyErrorKind::NoSuchEntityException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::no_such_entity_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_no_such_entity_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::GetGroupPolicyError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ServiceFailure" => crate::error::GetGroupPolicyError {
            meta: generic,
            kind: crate::error::GetGroupPolicyErrorKind::ServiceFailureException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::service_failure_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_service_failure_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::GetGroupPolicyError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::GetGroupPolicyError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_group_policy_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetGroupPolicyOutput, crate::error::GetGroupPolicyError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_group_policy_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_get_group_policy(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::GetGroupPolicyError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_instance_profile_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetInstanceProfileOutput,
    crate::error::GetInstanceProfileError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::GetInstanceProfileError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::GetInstanceProfileError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "NoSuchEntity" => crate::error::GetInstanceProfileError {
            meta: generic,
            kind: crate::error::GetInstanceProfileErrorKind::NoSuchEntityException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::no_such_entity_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_no_such_entity_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::GetInstanceProfileError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ServiceFailure" => crate::error::GetInstanceProfileError {
            meta: generic,
            kind: crate::error::GetInstanceProfileErrorKind::ServiceFailureException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::service_failure_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_service_failure_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::GetInstanceProfileError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::GetInstanceProfileError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_instance_profile_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetInstanceProfileOutput,
    crate::error::GetInstanceProfileError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_instance_profile_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_get_instance_profile(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::GetInstanceProfileError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_login_profile_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetLoginProfileOutput, crate::error::GetLoginProfileError> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::GetLoginProfileError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::GetLoginProfileError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "NoSuchEntity" => crate::error::GetLoginProfileError {
            meta: generic,
            kind: crate::error::GetLoginProfileErrorKind::NoSuchEntityException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::no_such_entity_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_no_such_entity_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::GetLoginProfileError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ServiceFailure" => crate::error::GetLoginProfileError {
            meta: generic,
            kind: crate::error::GetLoginProfileErrorKind::ServiceFailureException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::service_failure_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_service_failure_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::GetLoginProfileError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::GetLoginProfileError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_login_profile_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetLoginProfileOutput, crate::error::GetLoginProfileError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_login_profile_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_get_login_profile(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::GetLoginProfileError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_open_id_connect_provider_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetOpenIdConnectProviderOutput,
    crate::error::GetOpenIDConnectProviderError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::GetOpenIDConnectProviderError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::GetOpenIDConnectProviderError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InvalidInput" => crate::error::GetOpenIDConnectProviderError {
            meta: generic,
            kind: crate::error::GetOpenIDConnectProviderErrorKind::InvalidInputException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_input_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_input_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::GetOpenIDConnectProviderError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "NoSuchEntity" => crate::error::GetOpenIDConnectProviderError {
            meta: generic,
            kind: crate::error::GetOpenIDConnectProviderErrorKind::NoSuchEntityException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::no_such_entity_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_no_such_entity_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::GetOpenIDConnectProviderError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ServiceFailure" => crate::error::GetOpenIDConnectProviderError {
            meta: generic,
            kind: crate::error::GetOpenIDConnectProviderErrorKind::ServiceFailureException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::service_failure_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_service_failure_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::GetOpenIDConnectProviderError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::GetOpenIDConnectProviderError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_open_id_connect_provider_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetOpenIdConnectProviderOutput,
    crate::error::GetOpenIDConnectProviderError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_open_id_connect_provider_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_get_open_id_connect_provider(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::GetOpenIDConnectProviderError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_organizations_access_report_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetOrganizationsAccessReportOutput,
    crate::error::GetOrganizationsAccessReportError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::GetOrganizationsAccessReportError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::GetOrganizationsAccessReportError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "NoSuchEntity" => crate::error::GetOrganizationsAccessReportError {
            meta: generic,
            kind: crate::error::GetOrganizationsAccessReportErrorKind::NoSuchEntityException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::no_such_entity_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_no_such_entity_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::GetOrganizationsAccessReportError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::GetOrganizationsAccessReportError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_organizations_access_report_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetOrganizationsAccessReportOutput,
    crate::error::GetOrganizationsAccessReportError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_organizations_access_report_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_get_organizations_access_report(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::GetOrganizationsAccessReportError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_policy_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetPolicyOutput, crate::error::GetPolicyError> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::GetPolicyError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::GetPolicyError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InvalidInput" => crate::error::GetPolicyError {
            meta: generic,
            kind: crate::error::GetPolicyErrorKind::InvalidInputException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_input_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_input_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::GetPolicyError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "NoSuchEntity" => crate::error::GetPolicyError {
            meta: generic,
            kind: crate::error::GetPolicyErrorKind::NoSuchEntityException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::no_such_entity_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_no_such_entity_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::GetPolicyError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ServiceFailure" => crate::error::GetPolicyError {
            meta: generic,
            kind: crate::error::GetPolicyErrorKind::ServiceFailureException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::service_failure_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_service_failure_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::GetPolicyError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::GetPolicyError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_policy_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetPolicyOutput, crate::error::GetPolicyError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_policy_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_get_policy(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::GetPolicyError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_policy_version_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetPolicyVersionOutput, crate::error::GetPolicyVersionError>
{
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::GetPolicyVersionError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::GetPolicyVersionError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InvalidInput" => crate::error::GetPolicyVersionError {
            meta: generic,
            kind: crate::error::GetPolicyVersionErrorKind::InvalidInputException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_input_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_input_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::GetPolicyVersionError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "NoSuchEntity" => crate::error::GetPolicyVersionError {
            meta: generic,
            kind: crate::error::GetPolicyVersionErrorKind::NoSuchEntityException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::no_such_entity_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_no_such_entity_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::GetPolicyVersionError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ServiceFailure" => crate::error::GetPolicyVersionError {
            meta: generic,
            kind: crate::error::GetPolicyVersionErrorKind::ServiceFailureException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::service_failure_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_service_failure_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::GetPolicyVersionError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::GetPolicyVersionError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_policy_version_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetPolicyVersionOutput, crate::error::GetPolicyVersionError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_policy_version_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_get_policy_version(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::GetPolicyVersionError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_role_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetRoleOutput, crate::error::GetRoleError> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::GetRoleError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::GetRoleError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "NoSuchEntity" => crate::error::GetRoleError {
            meta: generic,
            kind: crate::error::GetRoleErrorKind::NoSuchEntityException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::no_such_entity_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_no_such_entity_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::GetRoleError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ServiceFailure" => crate::error::GetRoleError {
            meta: generic,
            kind: crate::error::GetRoleErrorKind::ServiceFailureException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::service_failure_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_service_failure_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::GetRoleError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::GetRoleError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_role_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetRoleOutput, crate::error::GetRoleError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_role_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_get_role(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::GetRoleError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_role_policy_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetRolePolicyOutput, crate::error::GetRolePolicyError> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::GetRolePolicyError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::GetRolePolicyError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "NoSuchEntity" => crate::error::GetRolePolicyError {
            meta: generic,
            kind: crate::error::GetRolePolicyErrorKind::NoSuchEntityException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::no_such_entity_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_no_such_entity_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::GetRolePolicyError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ServiceFailure" => crate::error::GetRolePolicyError {
            meta: generic,
            kind: crate::error::GetRolePolicyErrorKind::ServiceFailureException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::service_failure_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_service_failure_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::GetRolePolicyError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::GetRolePolicyError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_role_policy_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetRolePolicyOutput, crate::error::GetRolePolicyError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_role_policy_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_get_role_policy(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::GetRolePolicyError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_saml_provider_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetSamlProviderOutput, crate::error::GetSAMLProviderError> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::GetSAMLProviderError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::GetSAMLProviderError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InvalidInput" => crate::error::GetSAMLProviderError {
            meta: generic,
            kind: crate::error::GetSAMLProviderErrorKind::InvalidInputException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_input_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_input_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::GetSAMLProviderError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "NoSuchEntity" => crate::error::GetSAMLProviderError {
            meta: generic,
            kind: crate::error::GetSAMLProviderErrorKind::NoSuchEntityException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::no_such_entity_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_no_such_entity_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::GetSAMLProviderError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ServiceFailure" => crate::error::GetSAMLProviderError {
            meta: generic,
            kind: crate::error::GetSAMLProviderErrorKind::ServiceFailureException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::service_failure_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_service_failure_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::GetSAMLProviderError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::GetSAMLProviderError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_saml_provider_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetSamlProviderOutput, crate::error::GetSAMLProviderError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_saml_provider_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_get_saml_provider(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::GetSAMLProviderError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_server_certificate_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetServerCertificateOutput,
    crate::error::GetServerCertificateError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::GetServerCertificateError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::GetServerCertificateError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "NoSuchEntity" => crate::error::GetServerCertificateError {
            meta: generic,
            kind: crate::error::GetServerCertificateErrorKind::NoSuchEntityException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::no_such_entity_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_no_such_entity_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::GetServerCertificateError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ServiceFailure" => crate::error::GetServerCertificateError {
            meta: generic,
            kind: crate::error::GetServerCertificateErrorKind::ServiceFailureException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::service_failure_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_service_failure_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::GetServerCertificateError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::GetServerCertificateError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_server_certificate_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetServerCertificateOutput,
    crate::error::GetServerCertificateError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_server_certificate_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_get_server_certificate(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::GetServerCertificateError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_service_last_accessed_details_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetServiceLastAccessedDetailsOutput,
    crate::error::GetServiceLastAccessedDetailsError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::GetServiceLastAccessedDetailsError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::GetServiceLastAccessedDetailsError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InvalidInput" => crate::error::GetServiceLastAccessedDetailsError {
            meta: generic,
            kind: crate::error::GetServiceLastAccessedDetailsErrorKind::InvalidInputException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_input_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_input_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::GetServiceLastAccessedDetailsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "NoSuchEntity" => crate::error::GetServiceLastAccessedDetailsError {
            meta: generic,
            kind: crate::error::GetServiceLastAccessedDetailsErrorKind::NoSuchEntityException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::no_such_entity_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_no_such_entity_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::GetServiceLastAccessedDetailsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::GetServiceLastAccessedDetailsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_service_last_accessed_details_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetServiceLastAccessedDetailsOutput,
    crate::error::GetServiceLastAccessedDetailsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::get_service_last_accessed_details_output::Builder::default();
        let _ = response;
        output =
            crate::xml_deser::deser_operation_crate_operation_get_service_last_accessed_details(
                response.body().as_ref(),
                output,
            )
            .map_err(crate::error::GetServiceLastAccessedDetailsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_service_last_accessed_details_with_entities_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetServiceLastAccessedDetailsWithEntitiesOutput,
    crate::error::GetServiceLastAccessedDetailsWithEntitiesError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::GetServiceLastAccessedDetailsWithEntitiesError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(
                crate::error::GetServiceLastAccessedDetailsWithEntitiesError::unhandled(generic),
            )
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InvalidInput" => crate::error::GetServiceLastAccessedDetailsWithEntitiesError { meta: generic, kind: crate::error::GetServiceLastAccessedDetailsWithEntitiesErrorKind::InvalidInputException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_input_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_input_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::GetServiceLastAccessedDetailsWithEntitiesError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "NoSuchEntity" => crate::error::GetServiceLastAccessedDetailsWithEntitiesError { meta: generic, kind: crate::error::GetServiceLastAccessedDetailsWithEntitiesErrorKind::NoSuchEntityException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::no_such_entity_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_no_such_entity_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::GetServiceLastAccessedDetailsWithEntitiesError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::GetServiceLastAccessedDetailsWithEntitiesError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_service_last_accessed_details_with_entities_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetServiceLastAccessedDetailsWithEntitiesOutput,
    crate::error::GetServiceLastAccessedDetailsWithEntitiesError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::get_service_last_accessed_details_with_entities_output::Builder::default(
            );
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_get_service_last_accessed_details_with_entities(response.body().as_ref(), output).map_err(crate::error::GetServiceLastAccessedDetailsWithEntitiesError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_service_linked_role_deletion_status_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetServiceLinkedRoleDeletionStatusOutput,
    crate::error::GetServiceLinkedRoleDeletionStatusError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::GetServiceLinkedRoleDeletionStatusError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::GetServiceLinkedRoleDeletionStatusError::unhandled(generic))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InvalidInput" => crate::error::GetServiceLinkedRoleDeletionStatusError {
            meta: generic,
            kind: crate::error::GetServiceLinkedRoleDeletionStatusErrorKind::InvalidInputException(
                {
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output = crate::error::invalid_input_exception::Builder::default();
                        let _ = response;
                        output = crate::xml_deser::deser_structure_crate_error_invalid_input_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::GetServiceLinkedRoleDeletionStatusError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                },
            ),
        },
        "NoSuchEntity" => crate::error::GetServiceLinkedRoleDeletionStatusError {
            meta: generic,
            kind: crate::error::GetServiceLinkedRoleDeletionStatusErrorKind::NoSuchEntityException(
                {
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output = crate::error::no_such_entity_exception::Builder::default();
                        let _ = response;
                        output = crate::xml_deser::deser_structure_crate_error_no_such_entity_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::GetServiceLinkedRoleDeletionStatusError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                },
            ),
        },
        "ServiceFailure" => crate::error::GetServiceLinkedRoleDeletionStatusError {
            meta: generic,
            kind:
                crate::error::GetServiceLinkedRoleDeletionStatusErrorKind::ServiceFailureException(
                    {
                        #[allow(unused_mut)]
                        let mut tmp = {
                            #[allow(unused_mut)]
                            let mut output =
                                crate::error::service_failure_exception::Builder::default();
                            let _ = response;
                            output = crate::xml_deser::deser_structure_crate_error_service_failure_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::GetServiceLinkedRoleDeletionStatusError::unhandled)?;
                            output.build()
                        };
                        if (&tmp.message).is_none() {
                            tmp.message = _error_message;
                        }
                        tmp
                    },
                ),
        },
        _ => crate::error::GetServiceLinkedRoleDeletionStatusError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_service_linked_role_deletion_status_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetServiceLinkedRoleDeletionStatusOutput,
    crate::error::GetServiceLinkedRoleDeletionStatusError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::get_service_linked_role_deletion_status_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_get_service_linked_role_deletion_status(response.body().as_ref(), output).map_err(crate::error::GetServiceLinkedRoleDeletionStatusError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_ssh_public_key_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetSshPublicKeyOutput, crate::error::GetSSHPublicKeyError> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::GetSSHPublicKeyError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::GetSSHPublicKeyError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "NoSuchEntity" => crate::error::GetSSHPublicKeyError {
            meta: generic,
            kind: crate::error::GetSSHPublicKeyErrorKind::NoSuchEntityException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::no_such_entity_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_no_such_entity_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::GetSSHPublicKeyError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "UnrecognizedPublicKeyEncoding" => crate::error::GetSSHPublicKeyError {
            meta: generic,
            kind: crate::error::GetSSHPublicKeyErrorKind::UnrecognizedPublicKeyEncodingException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::unrecognized_public_key_encoding_exception::Builder::default(
                        );
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_unrecognized_public_key_encoding_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::GetSSHPublicKeyError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::GetSSHPublicKeyError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_ssh_public_key_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetSshPublicKeyOutput, crate::error::GetSSHPublicKeyError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_ssh_public_key_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_get_ssh_public_key(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::GetSSHPublicKeyError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_user_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetUserOutput, crate::error::GetUserError> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::GetUserError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::GetUserError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "NoSuchEntity" => crate::error::GetUserError {
            meta: generic,
            kind: crate::error::GetUserErrorKind::NoSuchEntityException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::no_such_entity_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_no_such_entity_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::GetUserError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ServiceFailure" => crate::error::GetUserError {
            meta: generic,
            kind: crate::error::GetUserErrorKind::ServiceFailureException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::service_failure_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_service_failure_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::GetUserError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::GetUserError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_user_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetUserOutput, crate::error::GetUserError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_user_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_get_user(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::GetUserError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_user_policy_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetUserPolicyOutput, crate::error::GetUserPolicyError> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::GetUserPolicyError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::GetUserPolicyError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "NoSuchEntity" => crate::error::GetUserPolicyError {
            meta: generic,
            kind: crate::error::GetUserPolicyErrorKind::NoSuchEntityException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::no_such_entity_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_no_such_entity_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::GetUserPolicyError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ServiceFailure" => crate::error::GetUserPolicyError {
            meta: generic,
            kind: crate::error::GetUserPolicyErrorKind::ServiceFailureException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::service_failure_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_service_failure_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::GetUserPolicyError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::GetUserPolicyError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_user_policy_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetUserPolicyOutput, crate::error::GetUserPolicyError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_user_policy_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_get_user_policy(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::GetUserPolicyError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_access_keys_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListAccessKeysOutput, crate::error::ListAccessKeysError> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::ListAccessKeysError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ListAccessKeysError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "NoSuchEntity" => crate::error::ListAccessKeysError {
            meta: generic,
            kind: crate::error::ListAccessKeysErrorKind::NoSuchEntityException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::no_such_entity_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_no_such_entity_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::ListAccessKeysError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ServiceFailure" => crate::error::ListAccessKeysError {
            meta: generic,
            kind: crate::error::ListAccessKeysErrorKind::ServiceFailureException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::service_failure_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_service_failure_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::ListAccessKeysError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::ListAccessKeysError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_access_keys_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListAccessKeysOutput, crate::error::ListAccessKeysError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_access_keys_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_list_access_keys(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListAccessKeysError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_account_aliases_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListAccountAliasesOutput,
    crate::error::ListAccountAliasesError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::ListAccountAliasesError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ListAccountAliasesError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ServiceFailure" => crate::error::ListAccountAliasesError {
            meta: generic,
            kind: crate::error::ListAccountAliasesErrorKind::ServiceFailureException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::service_failure_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_service_failure_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::ListAccountAliasesError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::ListAccountAliasesError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_account_aliases_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListAccountAliasesOutput,
    crate::error::ListAccountAliasesError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_account_aliases_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_list_account_aliases(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListAccountAliasesError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_attached_group_policies_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListAttachedGroupPoliciesOutput,
    crate::error::ListAttachedGroupPoliciesError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::ListAttachedGroupPoliciesError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::ListAttachedGroupPoliciesError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InvalidInput" => crate::error::ListAttachedGroupPoliciesError {
            meta: generic,
            kind: crate::error::ListAttachedGroupPoliciesErrorKind::InvalidInputException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_input_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_input_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::ListAttachedGroupPoliciesError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "NoSuchEntity" => crate::error::ListAttachedGroupPoliciesError {
            meta: generic,
            kind: crate::error::ListAttachedGroupPoliciesErrorKind::NoSuchEntityException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::no_such_entity_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_no_such_entity_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::ListAttachedGroupPoliciesError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ServiceFailure" => crate::error::ListAttachedGroupPoliciesError {
            meta: generic,
            kind: crate::error::ListAttachedGroupPoliciesErrorKind::ServiceFailureException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::service_failure_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_service_failure_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::ListAttachedGroupPoliciesError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::ListAttachedGroupPoliciesError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_attached_group_policies_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListAttachedGroupPoliciesOutput,
    crate::error::ListAttachedGroupPoliciesError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_attached_group_policies_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_list_attached_group_policies(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListAttachedGroupPoliciesError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_attached_role_policies_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListAttachedRolePoliciesOutput,
    crate::error::ListAttachedRolePoliciesError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::ListAttachedRolePoliciesError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::ListAttachedRolePoliciesError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InvalidInput" => crate::error::ListAttachedRolePoliciesError {
            meta: generic,
            kind: crate::error::ListAttachedRolePoliciesErrorKind::InvalidInputException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_input_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_input_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::ListAttachedRolePoliciesError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "NoSuchEntity" => crate::error::ListAttachedRolePoliciesError {
            meta: generic,
            kind: crate::error::ListAttachedRolePoliciesErrorKind::NoSuchEntityException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::no_such_entity_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_no_such_entity_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::ListAttachedRolePoliciesError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ServiceFailure" => crate::error::ListAttachedRolePoliciesError {
            meta: generic,
            kind: crate::error::ListAttachedRolePoliciesErrorKind::ServiceFailureException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::service_failure_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_service_failure_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::ListAttachedRolePoliciesError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::ListAttachedRolePoliciesError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_attached_role_policies_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListAttachedRolePoliciesOutput,
    crate::error::ListAttachedRolePoliciesError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_attached_role_policies_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_list_attached_role_policies(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListAttachedRolePoliciesError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_attached_user_policies_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListAttachedUserPoliciesOutput,
    crate::error::ListAttachedUserPoliciesError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::ListAttachedUserPoliciesError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::ListAttachedUserPoliciesError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InvalidInput" => crate::error::ListAttachedUserPoliciesError {
            meta: generic,
            kind: crate::error::ListAttachedUserPoliciesErrorKind::InvalidInputException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_input_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_input_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::ListAttachedUserPoliciesError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "NoSuchEntity" => crate::error::ListAttachedUserPoliciesError {
            meta: generic,
            kind: crate::error::ListAttachedUserPoliciesErrorKind::NoSuchEntityException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::no_such_entity_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_no_such_entity_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::ListAttachedUserPoliciesError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ServiceFailure" => crate::error::ListAttachedUserPoliciesError {
            meta: generic,
            kind: crate::error::ListAttachedUserPoliciesErrorKind::ServiceFailureException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::service_failure_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_service_failure_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::ListAttachedUserPoliciesError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::ListAttachedUserPoliciesError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_attached_user_policies_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListAttachedUserPoliciesOutput,
    crate::error::ListAttachedUserPoliciesError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_attached_user_policies_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_list_attached_user_policies(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListAttachedUserPoliciesError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_entities_for_policy_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListEntitiesForPolicyOutput,
    crate::error::ListEntitiesForPolicyError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::ListEntitiesForPolicyError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ListEntitiesForPolicyError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InvalidInput" => crate::error::ListEntitiesForPolicyError {
            meta: generic,
            kind: crate::error::ListEntitiesForPolicyErrorKind::InvalidInputException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_input_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_input_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::ListEntitiesForPolicyError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "NoSuchEntity" => crate::error::ListEntitiesForPolicyError {
            meta: generic,
            kind: crate::error::ListEntitiesForPolicyErrorKind::NoSuchEntityException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::no_such_entity_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_no_such_entity_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::ListEntitiesForPolicyError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ServiceFailure" => crate::error::ListEntitiesForPolicyError {
            meta: generic,
            kind: crate::error::ListEntitiesForPolicyErrorKind::ServiceFailureException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::service_failure_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_service_failure_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::ListEntitiesForPolicyError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::ListEntitiesForPolicyError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_entities_for_policy_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListEntitiesForPolicyOutput,
    crate::error::ListEntitiesForPolicyError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_entities_for_policy_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_list_entities_for_policy(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListEntitiesForPolicyError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_group_policies_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListGroupPoliciesOutput, crate::error::ListGroupPoliciesError>
{
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::ListGroupPoliciesError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ListGroupPoliciesError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "NoSuchEntity" => crate::error::ListGroupPoliciesError {
            meta: generic,
            kind: crate::error::ListGroupPoliciesErrorKind::NoSuchEntityException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::no_such_entity_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_no_such_entity_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::ListGroupPoliciesError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ServiceFailure" => crate::error::ListGroupPoliciesError {
            meta: generic,
            kind: crate::error::ListGroupPoliciesErrorKind::ServiceFailureException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::service_failure_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_service_failure_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::ListGroupPoliciesError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::ListGroupPoliciesError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_group_policies_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListGroupPoliciesOutput, crate::error::ListGroupPoliciesError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_group_policies_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_list_group_policies(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListGroupPoliciesError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_groups_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListGroupsOutput, crate::error::ListGroupsError> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::ListGroupsError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ListGroupsError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ServiceFailure" => crate::error::ListGroupsError {
            meta: generic,
            kind: crate::error::ListGroupsErrorKind::ServiceFailureException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::service_failure_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_service_failure_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::ListGroupsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::ListGroupsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_groups_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListGroupsOutput, crate::error::ListGroupsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_groups_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_list_groups(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListGroupsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_groups_for_user_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListGroupsForUserOutput, crate::error::ListGroupsForUserError>
{
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::ListGroupsForUserError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ListGroupsForUserError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "NoSuchEntity" => crate::error::ListGroupsForUserError {
            meta: generic,
            kind: crate::error::ListGroupsForUserErrorKind::NoSuchEntityException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::no_such_entity_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_no_such_entity_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::ListGroupsForUserError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ServiceFailure" => crate::error::ListGroupsForUserError {
            meta: generic,
            kind: crate::error::ListGroupsForUserErrorKind::ServiceFailureException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::service_failure_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_service_failure_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::ListGroupsForUserError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::ListGroupsForUserError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_groups_for_user_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListGroupsForUserOutput, crate::error::ListGroupsForUserError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_groups_for_user_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_list_groups_for_user(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListGroupsForUserError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_instance_profiles_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListInstanceProfilesOutput,
    crate::error::ListInstanceProfilesError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::ListInstanceProfilesError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ListInstanceProfilesError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ServiceFailure" => crate::error::ListInstanceProfilesError {
            meta: generic,
            kind: crate::error::ListInstanceProfilesErrorKind::ServiceFailureException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::service_failure_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_service_failure_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::ListInstanceProfilesError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::ListInstanceProfilesError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_instance_profiles_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListInstanceProfilesOutput,
    crate::error::ListInstanceProfilesError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_instance_profiles_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_list_instance_profiles(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListInstanceProfilesError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_instance_profiles_for_role_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListInstanceProfilesForRoleOutput,
    crate::error::ListInstanceProfilesForRoleError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::ListInstanceProfilesForRoleError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::ListInstanceProfilesForRoleError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "NoSuchEntity" => crate::error::ListInstanceProfilesForRoleError {
            meta: generic,
            kind: crate::error::ListInstanceProfilesForRoleErrorKind::NoSuchEntityException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::no_such_entity_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_no_such_entity_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::ListInstanceProfilesForRoleError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ServiceFailure" => crate::error::ListInstanceProfilesForRoleError {
            meta: generic,
            kind: crate::error::ListInstanceProfilesForRoleErrorKind::ServiceFailureException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::service_failure_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_service_failure_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::ListInstanceProfilesForRoleError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::ListInstanceProfilesForRoleError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_instance_profiles_for_role_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListInstanceProfilesForRoleOutput,
    crate::error::ListInstanceProfilesForRoleError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_instance_profiles_for_role_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_list_instance_profiles_for_role(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListInstanceProfilesForRoleError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_instance_profile_tags_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListInstanceProfileTagsOutput,
    crate::error::ListInstanceProfileTagsError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::ListInstanceProfileTagsError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::ListInstanceProfileTagsError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "NoSuchEntity" => crate::error::ListInstanceProfileTagsError {
            meta: generic,
            kind: crate::error::ListInstanceProfileTagsErrorKind::NoSuchEntityException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::no_such_entity_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_no_such_entity_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::ListInstanceProfileTagsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ServiceFailure" => crate::error::ListInstanceProfileTagsError {
            meta: generic,
            kind: crate::error::ListInstanceProfileTagsErrorKind::ServiceFailureException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::service_failure_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_service_failure_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::ListInstanceProfileTagsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::ListInstanceProfileTagsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_instance_profile_tags_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListInstanceProfileTagsOutput,
    crate::error::ListInstanceProfileTagsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_instance_profile_tags_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_list_instance_profile_tags(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListInstanceProfileTagsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_mfa_devices_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListMfaDevicesOutput, crate::error::ListMFADevicesError> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::ListMFADevicesError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ListMFADevicesError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "NoSuchEntity" => crate::error::ListMFADevicesError {
            meta: generic,
            kind: crate::error::ListMFADevicesErrorKind::NoSuchEntityException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::no_such_entity_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_no_such_entity_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::ListMFADevicesError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ServiceFailure" => crate::error::ListMFADevicesError {
            meta: generic,
            kind: crate::error::ListMFADevicesErrorKind::ServiceFailureException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::service_failure_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_service_failure_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::ListMFADevicesError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::ListMFADevicesError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_mfa_devices_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListMfaDevicesOutput, crate::error::ListMFADevicesError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_mfa_devices_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_list_mfa_devices(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListMFADevicesError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_mfa_device_tags_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListMfaDeviceTagsOutput, crate::error::ListMFADeviceTagsError>
{
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::ListMFADeviceTagsError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ListMFADeviceTagsError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InvalidInput" => crate::error::ListMFADeviceTagsError {
            meta: generic,
            kind: crate::error::ListMFADeviceTagsErrorKind::InvalidInputException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_input_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_input_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::ListMFADeviceTagsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "NoSuchEntity" => crate::error::ListMFADeviceTagsError {
            meta: generic,
            kind: crate::error::ListMFADeviceTagsErrorKind::NoSuchEntityException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::no_such_entity_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_no_such_entity_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::ListMFADeviceTagsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ServiceFailure" => crate::error::ListMFADeviceTagsError {
            meta: generic,
            kind: crate::error::ListMFADeviceTagsErrorKind::ServiceFailureException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::service_failure_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_service_failure_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::ListMFADeviceTagsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::ListMFADeviceTagsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_mfa_device_tags_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListMfaDeviceTagsOutput, crate::error::ListMFADeviceTagsError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_mfa_device_tags_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_list_mfa_device_tags(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListMFADeviceTagsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_open_id_connect_providers_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListOpenIdConnectProvidersOutput,
    crate::error::ListOpenIDConnectProvidersError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::ListOpenIDConnectProvidersError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::ListOpenIDConnectProvidersError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ServiceFailure" => crate::error::ListOpenIDConnectProvidersError {
            meta: generic,
            kind: crate::error::ListOpenIDConnectProvidersErrorKind::ServiceFailureException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::service_failure_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_service_failure_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::ListOpenIDConnectProvidersError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::ListOpenIDConnectProvidersError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_open_id_connect_providers_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListOpenIdConnectProvidersOutput,
    crate::error::ListOpenIDConnectProvidersError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_open_id_connect_providers_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_list_open_id_connect_providers(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListOpenIDConnectProvidersError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_open_id_connect_provider_tags_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListOpenIdConnectProviderTagsOutput,
    crate::error::ListOpenIDConnectProviderTagsError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::ListOpenIDConnectProviderTagsError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::ListOpenIDConnectProviderTagsError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InvalidInput" => crate::error::ListOpenIDConnectProviderTagsError {
            meta: generic,
            kind: crate::error::ListOpenIDConnectProviderTagsErrorKind::InvalidInputException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_input_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_input_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::ListOpenIDConnectProviderTagsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "NoSuchEntity" => crate::error::ListOpenIDConnectProviderTagsError {
            meta: generic,
            kind: crate::error::ListOpenIDConnectProviderTagsErrorKind::NoSuchEntityException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::no_such_entity_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_no_such_entity_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::ListOpenIDConnectProviderTagsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ServiceFailure" => crate::error::ListOpenIDConnectProviderTagsError {
            meta: generic,
            kind: crate::error::ListOpenIDConnectProviderTagsErrorKind::ServiceFailureException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::service_failure_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_service_failure_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::ListOpenIDConnectProviderTagsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::ListOpenIDConnectProviderTagsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_open_id_connect_provider_tags_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListOpenIdConnectProviderTagsOutput,
    crate::error::ListOpenIDConnectProviderTagsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::list_open_id_connect_provider_tags_output::Builder::default();
        let _ = response;
        output =
            crate::xml_deser::deser_operation_crate_operation_list_open_id_connect_provider_tags(
                response.body().as_ref(),
                output,
            )
            .map_err(crate::error::ListOpenIDConnectProviderTagsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_policies_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListPoliciesOutput, crate::error::ListPoliciesError> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::ListPoliciesError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ListPoliciesError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ServiceFailure" => crate::error::ListPoliciesError {
            meta: generic,
            kind: crate::error::ListPoliciesErrorKind::ServiceFailureException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::service_failure_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_service_failure_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::ListPoliciesError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::ListPoliciesError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_policies_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListPoliciesOutput, crate::error::ListPoliciesError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_policies_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_list_policies(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListPoliciesError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_policies_granting_service_access_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListPoliciesGrantingServiceAccessOutput,
    crate::error::ListPoliciesGrantingServiceAccessError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::ListPoliciesGrantingServiceAccessError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::ListPoliciesGrantingServiceAccessError::unhandled(generic))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InvalidInput" => crate::error::ListPoliciesGrantingServiceAccessError {
            meta: generic,
            kind: crate::error::ListPoliciesGrantingServiceAccessErrorKind::InvalidInputException(
                {
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output = crate::error::invalid_input_exception::Builder::default();
                        let _ = response;
                        output = crate::xml_deser::deser_structure_crate_error_invalid_input_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::ListPoliciesGrantingServiceAccessError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                },
            ),
        },
        "NoSuchEntity" => crate::error::ListPoliciesGrantingServiceAccessError {
            meta: generic,
            kind: crate::error::ListPoliciesGrantingServiceAccessErrorKind::NoSuchEntityException(
                {
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output = crate::error::no_such_entity_exception::Builder::default();
                        let _ = response;
                        output = crate::xml_deser::deser_structure_crate_error_no_such_entity_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::ListPoliciesGrantingServiceAccessError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                },
            ),
        },
        _ => crate::error::ListPoliciesGrantingServiceAccessError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_policies_granting_service_access_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListPoliciesGrantingServiceAccessOutput,
    crate::error::ListPoliciesGrantingServiceAccessError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::list_policies_granting_service_access_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_list_policies_granting_service_access(response.body().as_ref(), output).map_err(crate::error::ListPoliciesGrantingServiceAccessError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_policy_tags_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListPolicyTagsOutput, crate::error::ListPolicyTagsError> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::ListPolicyTagsError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ListPolicyTagsError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InvalidInput" => crate::error::ListPolicyTagsError {
            meta: generic,
            kind: crate::error::ListPolicyTagsErrorKind::InvalidInputException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_input_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_input_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::ListPolicyTagsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "NoSuchEntity" => crate::error::ListPolicyTagsError {
            meta: generic,
            kind: crate::error::ListPolicyTagsErrorKind::NoSuchEntityException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::no_such_entity_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_no_such_entity_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::ListPolicyTagsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ServiceFailure" => crate::error::ListPolicyTagsError {
            meta: generic,
            kind: crate::error::ListPolicyTagsErrorKind::ServiceFailureException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::service_failure_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_service_failure_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::ListPolicyTagsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::ListPolicyTagsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_policy_tags_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListPolicyTagsOutput, crate::error::ListPolicyTagsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_policy_tags_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_list_policy_tags(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListPolicyTagsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_policy_versions_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListPolicyVersionsOutput,
    crate::error::ListPolicyVersionsError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::ListPolicyVersionsError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ListPolicyVersionsError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InvalidInput" => crate::error::ListPolicyVersionsError {
            meta: generic,
            kind: crate::error::ListPolicyVersionsErrorKind::InvalidInputException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_input_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_input_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::ListPolicyVersionsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "NoSuchEntity" => crate::error::ListPolicyVersionsError {
            meta: generic,
            kind: crate::error::ListPolicyVersionsErrorKind::NoSuchEntityException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::no_such_entity_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_no_such_entity_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::ListPolicyVersionsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ServiceFailure" => crate::error::ListPolicyVersionsError {
            meta: generic,
            kind: crate::error::ListPolicyVersionsErrorKind::ServiceFailureException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::service_failure_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_service_failure_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::ListPolicyVersionsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::ListPolicyVersionsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_policy_versions_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListPolicyVersionsOutput,
    crate::error::ListPolicyVersionsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_policy_versions_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_list_policy_versions(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListPolicyVersionsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_role_policies_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListRolePoliciesOutput, crate::error::ListRolePoliciesError>
{
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::ListRolePoliciesError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ListRolePoliciesError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "NoSuchEntity" => crate::error::ListRolePoliciesError {
            meta: generic,
            kind: crate::error::ListRolePoliciesErrorKind::NoSuchEntityException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::no_such_entity_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_no_such_entity_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::ListRolePoliciesError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ServiceFailure" => crate::error::ListRolePoliciesError {
            meta: generic,
            kind: crate::error::ListRolePoliciesErrorKind::ServiceFailureException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::service_failure_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_service_failure_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::ListRolePoliciesError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::ListRolePoliciesError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_role_policies_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListRolePoliciesOutput, crate::error::ListRolePoliciesError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_role_policies_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_list_role_policies(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListRolePoliciesError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_roles_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListRolesOutput, crate::error::ListRolesError> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::ListRolesError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ListRolesError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ServiceFailure" => crate::error::ListRolesError {
            meta: generic,
            kind: crate::error::ListRolesErrorKind::ServiceFailureException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::service_failure_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_service_failure_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::ListRolesError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::ListRolesError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_roles_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListRolesOutput, crate::error::ListRolesError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_roles_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_list_roles(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListRolesError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_role_tags_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListRoleTagsOutput, crate::error::ListRoleTagsError> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::ListRoleTagsError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ListRoleTagsError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "NoSuchEntity" => crate::error::ListRoleTagsError {
            meta: generic,
            kind: crate::error::ListRoleTagsErrorKind::NoSuchEntityException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::no_such_entity_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_no_such_entity_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::ListRoleTagsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ServiceFailure" => crate::error::ListRoleTagsError {
            meta: generic,
            kind: crate::error::ListRoleTagsErrorKind::ServiceFailureException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::service_failure_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_service_failure_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::ListRoleTagsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::ListRoleTagsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_role_tags_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListRoleTagsOutput, crate::error::ListRoleTagsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_role_tags_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_list_role_tags(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListRoleTagsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_saml_providers_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListSamlProvidersOutput, crate::error::ListSAMLProvidersError>
{
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::ListSAMLProvidersError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ListSAMLProvidersError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ServiceFailure" => crate::error::ListSAMLProvidersError {
            meta: generic,
            kind: crate::error::ListSAMLProvidersErrorKind::ServiceFailureException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::service_failure_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_service_failure_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::ListSAMLProvidersError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::ListSAMLProvidersError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_saml_providers_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListSamlProvidersOutput, crate::error::ListSAMLProvidersError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_saml_providers_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_list_saml_providers(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListSAMLProvidersError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_saml_provider_tags_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListSamlProviderTagsOutput,
    crate::error::ListSAMLProviderTagsError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::ListSAMLProviderTagsError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ListSAMLProviderTagsError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InvalidInput" => crate::error::ListSAMLProviderTagsError {
            meta: generic,
            kind: crate::error::ListSAMLProviderTagsErrorKind::InvalidInputException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_input_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_input_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::ListSAMLProviderTagsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "NoSuchEntity" => crate::error::ListSAMLProviderTagsError {
            meta: generic,
            kind: crate::error::ListSAMLProviderTagsErrorKind::NoSuchEntityException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::no_such_entity_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_no_such_entity_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::ListSAMLProviderTagsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ServiceFailure" => crate::error::ListSAMLProviderTagsError {
            meta: generic,
            kind: crate::error::ListSAMLProviderTagsErrorKind::ServiceFailureException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::service_failure_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_service_failure_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::ListSAMLProviderTagsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::ListSAMLProviderTagsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_saml_provider_tags_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListSamlProviderTagsOutput,
    crate::error::ListSAMLProviderTagsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_saml_provider_tags_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_list_saml_provider_tags(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListSAMLProviderTagsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_server_certificates_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListServerCertificatesOutput,
    crate::error::ListServerCertificatesError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::ListServerCertificatesError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::ListServerCertificatesError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ServiceFailure" => crate::error::ListServerCertificatesError {
            meta: generic,
            kind: crate::error::ListServerCertificatesErrorKind::ServiceFailureException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::service_failure_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_service_failure_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::ListServerCertificatesError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::ListServerCertificatesError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_server_certificates_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListServerCertificatesOutput,
    crate::error::ListServerCertificatesError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_server_certificates_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_list_server_certificates(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListServerCertificatesError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_server_certificate_tags_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListServerCertificateTagsOutput,
    crate::error::ListServerCertificateTagsError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::ListServerCertificateTagsError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::ListServerCertificateTagsError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "NoSuchEntity" => crate::error::ListServerCertificateTagsError {
            meta: generic,
            kind: crate::error::ListServerCertificateTagsErrorKind::NoSuchEntityException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::no_such_entity_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_no_such_entity_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::ListServerCertificateTagsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ServiceFailure" => crate::error::ListServerCertificateTagsError {
            meta: generic,
            kind: crate::error::ListServerCertificateTagsErrorKind::ServiceFailureException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::service_failure_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_service_failure_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::ListServerCertificateTagsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::ListServerCertificateTagsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_server_certificate_tags_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListServerCertificateTagsOutput,
    crate::error::ListServerCertificateTagsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_server_certificate_tags_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_list_server_certificate_tags(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListServerCertificateTagsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_service_specific_credentials_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListServiceSpecificCredentialsOutput,
    crate::error::ListServiceSpecificCredentialsError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::ListServiceSpecificCredentialsError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ListServiceSpecificCredentialsError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "NoSuchEntity" => crate::error::ListServiceSpecificCredentialsError {
            meta: generic,
            kind: crate::error::ListServiceSpecificCredentialsErrorKind::NoSuchEntityException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::no_such_entity_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_no_such_entity_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::ListServiceSpecificCredentialsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "NotSupportedService" => crate::error::ListServiceSpecificCredentialsError {
            meta: generic,
            kind:
                crate::error::ListServiceSpecificCredentialsErrorKind::ServiceNotSupportedException(
                    {
                        #[allow(unused_mut)]
                        let mut tmp = {
                            #[allow(unused_mut)]
                            let mut output =
                                crate::error::service_not_supported_exception::Builder::default();
                            let _ = response;
                            output = crate::xml_deser::deser_structure_crate_error_service_not_supported_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::ListServiceSpecificCredentialsError::unhandled)?;
                            output.build()
                        };
                        if (&tmp.message).is_none() {
                            tmp.message = _error_message;
                        }
                        tmp
                    },
                ),
        },
        _ => crate::error::ListServiceSpecificCredentialsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_service_specific_credentials_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListServiceSpecificCredentialsOutput,
    crate::error::ListServiceSpecificCredentialsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::list_service_specific_credentials_output::Builder::default();
        let _ = response;
        output =
            crate::xml_deser::deser_operation_crate_operation_list_service_specific_credentials(
                response.body().as_ref(),
                output,
            )
            .map_err(crate::error::ListServiceSpecificCredentialsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_signing_certificates_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListSigningCertificatesOutput,
    crate::error::ListSigningCertificatesError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::ListSigningCertificatesError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::ListSigningCertificatesError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "NoSuchEntity" => crate::error::ListSigningCertificatesError {
            meta: generic,
            kind: crate::error::ListSigningCertificatesErrorKind::NoSuchEntityException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::no_such_entity_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_no_such_entity_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::ListSigningCertificatesError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ServiceFailure" => crate::error::ListSigningCertificatesError {
            meta: generic,
            kind: crate::error::ListSigningCertificatesErrorKind::ServiceFailureException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::service_failure_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_service_failure_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::ListSigningCertificatesError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::ListSigningCertificatesError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_signing_certificates_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListSigningCertificatesOutput,
    crate::error::ListSigningCertificatesError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_signing_certificates_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_list_signing_certificates(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListSigningCertificatesError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_ssh_public_keys_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListSshPublicKeysOutput, crate::error::ListSSHPublicKeysError>
{
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::ListSSHPublicKeysError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ListSSHPublicKeysError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "NoSuchEntity" => crate::error::ListSSHPublicKeysError {
            meta: generic,
            kind: crate::error::ListSSHPublicKeysErrorKind::NoSuchEntityException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::no_such_entity_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_no_such_entity_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::ListSSHPublicKeysError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::ListSSHPublicKeysError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_ssh_public_keys_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListSshPublicKeysOutput, crate::error::ListSSHPublicKeysError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_ssh_public_keys_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_list_ssh_public_keys(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListSSHPublicKeysError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_user_policies_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListUserPoliciesOutput, crate::error::ListUserPoliciesError>
{
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::ListUserPoliciesError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ListUserPoliciesError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "NoSuchEntity" => crate::error::ListUserPoliciesError {
            meta: generic,
            kind: crate::error::ListUserPoliciesErrorKind::NoSuchEntityException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::no_such_entity_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_no_such_entity_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::ListUserPoliciesError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ServiceFailure" => crate::error::ListUserPoliciesError {
            meta: generic,
            kind: crate::error::ListUserPoliciesErrorKind::ServiceFailureException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::service_failure_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_service_failure_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::ListUserPoliciesError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::ListUserPoliciesError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_user_policies_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListUserPoliciesOutput, crate::error::ListUserPoliciesError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_user_policies_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_list_user_policies(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListUserPoliciesError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_users_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListUsersOutput, crate::error::ListUsersError> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::ListUsersError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ListUsersError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ServiceFailure" => crate::error::ListUsersError {
            meta: generic,
            kind: crate::error::ListUsersErrorKind::ServiceFailureException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::service_failure_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_service_failure_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::ListUsersError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::ListUsersError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_users_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListUsersOutput, crate::error::ListUsersError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_users_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_list_users(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListUsersError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_user_tags_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListUserTagsOutput, crate::error::ListUserTagsError> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::ListUserTagsError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ListUserTagsError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "NoSuchEntity" => crate::error::ListUserTagsError {
            meta: generic,
            kind: crate::error::ListUserTagsErrorKind::NoSuchEntityException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::no_such_entity_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_no_such_entity_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::ListUserTagsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ServiceFailure" => crate::error::ListUserTagsError {
            meta: generic,
            kind: crate::error::ListUserTagsErrorKind::ServiceFailureException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::service_failure_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_service_failure_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::ListUserTagsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::ListUserTagsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_user_tags_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListUserTagsOutput, crate::error::ListUserTagsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_user_tags_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_list_user_tags(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListUserTagsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_virtual_mfa_devices_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListVirtualMfaDevicesOutput,
    crate::error::ListVirtualMFADevicesError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::ListVirtualMFADevicesError::unhandled)?;
    Err(crate::error::ListVirtualMFADevicesError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_virtual_mfa_devices_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListVirtualMfaDevicesOutput,
    crate::error::ListVirtualMFADevicesError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_virtual_mfa_devices_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_list_virtual_mfa_devices(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListVirtualMFADevicesError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_put_group_policy_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::PutGroupPolicyOutput, crate::error::PutGroupPolicyError> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::PutGroupPolicyError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::PutGroupPolicyError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "LimitExceeded" => crate::error::PutGroupPolicyError {
            meta: generic,
            kind: crate::error::PutGroupPolicyErrorKind::LimitExceededException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_limit_exceeded_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::PutGroupPolicyError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "MalformedPolicyDocument" => crate::error::PutGroupPolicyError {
            meta: generic,
            kind: crate::error::PutGroupPolicyErrorKind::MalformedPolicyDocumentException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::malformed_policy_document_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_malformed_policy_document_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::PutGroupPolicyError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "NoSuchEntity" => crate::error::PutGroupPolicyError {
            meta: generic,
            kind: crate::error::PutGroupPolicyErrorKind::NoSuchEntityException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::no_such_entity_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_no_such_entity_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::PutGroupPolicyError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ServiceFailure" => crate::error::PutGroupPolicyError {
            meta: generic,
            kind: crate::error::PutGroupPolicyErrorKind::ServiceFailureException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::service_failure_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_service_failure_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::PutGroupPolicyError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::PutGroupPolicyError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_put_group_policy_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::PutGroupPolicyOutput, crate::error::PutGroupPolicyError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::put_group_policy_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_put_role_permissions_boundary_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::PutRolePermissionsBoundaryOutput,
    crate::error::PutRolePermissionsBoundaryError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::PutRolePermissionsBoundaryError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::PutRolePermissionsBoundaryError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InvalidInput" => crate::error::PutRolePermissionsBoundaryError {
            meta: generic,
            kind: crate::error::PutRolePermissionsBoundaryErrorKind::InvalidInputException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_input_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_input_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::PutRolePermissionsBoundaryError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "NoSuchEntity" => crate::error::PutRolePermissionsBoundaryError {
            meta: generic,
            kind: crate::error::PutRolePermissionsBoundaryErrorKind::NoSuchEntityException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::no_such_entity_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_no_such_entity_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::PutRolePermissionsBoundaryError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "PolicyNotAttachable" => crate::error::PutRolePermissionsBoundaryError {
            meta: generic,
            kind: crate::error::PutRolePermissionsBoundaryErrorKind::PolicyNotAttachableException(
                {
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::policy_not_attachable_exception::Builder::default();
                        let _ = response;
                        output = crate::xml_deser::deser_structure_crate_error_policy_not_attachable_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::PutRolePermissionsBoundaryError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                },
            ),
        },
        "ServiceFailure" => crate::error::PutRolePermissionsBoundaryError {
            meta: generic,
            kind: crate::error::PutRolePermissionsBoundaryErrorKind::ServiceFailureException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::service_failure_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_service_failure_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::PutRolePermissionsBoundaryError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "UnmodifiableEntity" => crate::error::PutRolePermissionsBoundaryError {
            meta: generic,
            kind: crate::error::PutRolePermissionsBoundaryErrorKind::UnmodifiableEntityException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::unmodifiable_entity_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_unmodifiable_entity_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::PutRolePermissionsBoundaryError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::PutRolePermissionsBoundaryError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_put_role_permissions_boundary_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::PutRolePermissionsBoundaryOutput,
    crate::error::PutRolePermissionsBoundaryError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::put_role_permissions_boundary_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_put_role_policy_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::PutRolePolicyOutput, crate::error::PutRolePolicyError> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::PutRolePolicyError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::PutRolePolicyError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "LimitExceeded" => crate::error::PutRolePolicyError {
            meta: generic,
            kind: crate::error::PutRolePolicyErrorKind::LimitExceededException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_limit_exceeded_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::PutRolePolicyError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "MalformedPolicyDocument" => crate::error::PutRolePolicyError {
            meta: generic,
            kind: crate::error::PutRolePolicyErrorKind::MalformedPolicyDocumentException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::malformed_policy_document_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_malformed_policy_document_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::PutRolePolicyError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "NoSuchEntity" => crate::error::PutRolePolicyError {
            meta: generic,
            kind: crate::error::PutRolePolicyErrorKind::NoSuchEntityException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::no_such_entity_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_no_such_entity_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::PutRolePolicyError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ServiceFailure" => crate::error::PutRolePolicyError {
            meta: generic,
            kind: crate::error::PutRolePolicyErrorKind::ServiceFailureException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::service_failure_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_service_failure_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::PutRolePolicyError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "UnmodifiableEntity" => crate::error::PutRolePolicyError {
            meta: generic,
            kind: crate::error::PutRolePolicyErrorKind::UnmodifiableEntityException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::unmodifiable_entity_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_unmodifiable_entity_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::PutRolePolicyError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::PutRolePolicyError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_put_role_policy_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::PutRolePolicyOutput, crate::error::PutRolePolicyError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::put_role_policy_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_put_user_permissions_boundary_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::PutUserPermissionsBoundaryOutput,
    crate::error::PutUserPermissionsBoundaryError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::PutUserPermissionsBoundaryError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::PutUserPermissionsBoundaryError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InvalidInput" => crate::error::PutUserPermissionsBoundaryError {
            meta: generic,
            kind: crate::error::PutUserPermissionsBoundaryErrorKind::InvalidInputException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_input_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_input_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::PutUserPermissionsBoundaryError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "NoSuchEntity" => crate::error::PutUserPermissionsBoundaryError {
            meta: generic,
            kind: crate::error::PutUserPermissionsBoundaryErrorKind::NoSuchEntityException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::no_such_entity_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_no_such_entity_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::PutUserPermissionsBoundaryError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "PolicyNotAttachable" => crate::error::PutUserPermissionsBoundaryError {
            meta: generic,
            kind: crate::error::PutUserPermissionsBoundaryErrorKind::PolicyNotAttachableException(
                {
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::policy_not_attachable_exception::Builder::default();
                        let _ = response;
                        output = crate::xml_deser::deser_structure_crate_error_policy_not_attachable_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::PutUserPermissionsBoundaryError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                },
            ),
        },
        "ServiceFailure" => crate::error::PutUserPermissionsBoundaryError {
            meta: generic,
            kind: crate::error::PutUserPermissionsBoundaryErrorKind::ServiceFailureException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::service_failure_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_service_failure_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::PutUserPermissionsBoundaryError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::PutUserPermissionsBoundaryError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_put_user_permissions_boundary_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::PutUserPermissionsBoundaryOutput,
    crate::error::PutUserPermissionsBoundaryError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::put_user_permissions_boundary_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_put_user_policy_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::PutUserPolicyOutput, crate::error::PutUserPolicyError> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::PutUserPolicyError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::PutUserPolicyError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "LimitExceeded" => crate::error::PutUserPolicyError {
            meta: generic,
            kind: crate::error::PutUserPolicyErrorKind::LimitExceededException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_limit_exceeded_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::PutUserPolicyError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "MalformedPolicyDocument" => crate::error::PutUserPolicyError {
            meta: generic,
            kind: crate::error::PutUserPolicyErrorKind::MalformedPolicyDocumentException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::malformed_policy_document_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_malformed_policy_document_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::PutUserPolicyError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "NoSuchEntity" => crate::error::PutUserPolicyError {
            meta: generic,
            kind: crate::error::PutUserPolicyErrorKind::NoSuchEntityException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::no_such_entity_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_no_such_entity_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::PutUserPolicyError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ServiceFailure" => crate::error::PutUserPolicyError {
            meta: generic,
            kind: crate::error::PutUserPolicyErrorKind::ServiceFailureException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::service_failure_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_service_failure_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::PutUserPolicyError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::PutUserPolicyError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_put_user_policy_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::PutUserPolicyOutput, crate::error::PutUserPolicyError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::put_user_policy_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_remove_client_id_from_open_id_connect_provider_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::RemoveClientIdFromOpenIdConnectProviderOutput,
    crate::error::RemoveClientIDFromOpenIDConnectProviderError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::RemoveClientIDFromOpenIDConnectProviderError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(
                crate::error::RemoveClientIDFromOpenIDConnectProviderError::unhandled(generic),
            )
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InvalidInput" => crate::error::RemoveClientIDFromOpenIDConnectProviderError { meta: generic, kind: crate::error::RemoveClientIDFromOpenIDConnectProviderErrorKind::InvalidInputException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_input_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_input_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::RemoveClientIDFromOpenIDConnectProviderError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "NoSuchEntity" => crate::error::RemoveClientIDFromOpenIDConnectProviderError { meta: generic, kind: crate::error::RemoveClientIDFromOpenIDConnectProviderErrorKind::NoSuchEntityException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::no_such_entity_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_no_such_entity_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::RemoveClientIDFromOpenIDConnectProviderError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ServiceFailure" => crate::error::RemoveClientIDFromOpenIDConnectProviderError { meta: generic, kind: crate::error::RemoveClientIDFromOpenIDConnectProviderErrorKind::ServiceFailureException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::service_failure_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_service_failure_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::RemoveClientIDFromOpenIDConnectProviderError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::RemoveClientIDFromOpenIDConnectProviderError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_remove_client_id_from_open_id_connect_provider_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::RemoveClientIdFromOpenIdConnectProviderOutput,
    crate::error::RemoveClientIDFromOpenIDConnectProviderError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::remove_client_id_from_open_id_connect_provider_output::Builder::default(
            );
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_remove_role_from_instance_profile_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::RemoveRoleFromInstanceProfileOutput,
    crate::error::RemoveRoleFromInstanceProfileError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::RemoveRoleFromInstanceProfileError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::RemoveRoleFromInstanceProfileError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "LimitExceeded" => crate::error::RemoveRoleFromInstanceProfileError {
            meta: generic,
            kind: crate::error::RemoveRoleFromInstanceProfileErrorKind::LimitExceededException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_limit_exceeded_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::RemoveRoleFromInstanceProfileError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "NoSuchEntity" => crate::error::RemoveRoleFromInstanceProfileError {
            meta: generic,
            kind: crate::error::RemoveRoleFromInstanceProfileErrorKind::NoSuchEntityException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::no_such_entity_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_no_such_entity_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::RemoveRoleFromInstanceProfileError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ServiceFailure" => crate::error::RemoveRoleFromInstanceProfileError {
            meta: generic,
            kind: crate::error::RemoveRoleFromInstanceProfileErrorKind::ServiceFailureException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::service_failure_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_service_failure_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::RemoveRoleFromInstanceProfileError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "UnmodifiableEntity" => crate::error::RemoveRoleFromInstanceProfileError {
            meta: generic,
            kind: crate::error::RemoveRoleFromInstanceProfileErrorKind::UnmodifiableEntityException(
                {
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::unmodifiable_entity_exception::Builder::default();
                        let _ = response;
                        output = crate::xml_deser::deser_structure_crate_error_unmodifiable_entity_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::RemoveRoleFromInstanceProfileError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                },
            ),
        },
        _ => crate::error::RemoveRoleFromInstanceProfileError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_remove_role_from_instance_profile_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::RemoveRoleFromInstanceProfileOutput,
    crate::error::RemoveRoleFromInstanceProfileError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::remove_role_from_instance_profile_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_remove_user_from_group_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::RemoveUserFromGroupOutput,
    crate::error::RemoveUserFromGroupError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::RemoveUserFromGroupError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::RemoveUserFromGroupError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "LimitExceeded" => crate::error::RemoveUserFromGroupError {
            meta: generic,
            kind: crate::error::RemoveUserFromGroupErrorKind::LimitExceededException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_limit_exceeded_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::RemoveUserFromGroupError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "NoSuchEntity" => crate::error::RemoveUserFromGroupError {
            meta: generic,
            kind: crate::error::RemoveUserFromGroupErrorKind::NoSuchEntityException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::no_such_entity_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_no_such_entity_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::RemoveUserFromGroupError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ServiceFailure" => crate::error::RemoveUserFromGroupError {
            meta: generic,
            kind: crate::error::RemoveUserFromGroupErrorKind::ServiceFailureException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::service_failure_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_service_failure_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::RemoveUserFromGroupError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::RemoveUserFromGroupError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_remove_user_from_group_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::RemoveUserFromGroupOutput,
    crate::error::RemoveUserFromGroupError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::remove_user_from_group_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_reset_service_specific_credential_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ResetServiceSpecificCredentialOutput,
    crate::error::ResetServiceSpecificCredentialError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::ResetServiceSpecificCredentialError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ResetServiceSpecificCredentialError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "NoSuchEntity" => crate::error::ResetServiceSpecificCredentialError {
            meta: generic,
            kind: crate::error::ResetServiceSpecificCredentialErrorKind::NoSuchEntityException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::no_such_entity_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_no_such_entity_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::ResetServiceSpecificCredentialError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::ResetServiceSpecificCredentialError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_reset_service_specific_credential_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ResetServiceSpecificCredentialOutput,
    crate::error::ResetServiceSpecificCredentialError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::reset_service_specific_credential_output::Builder::default();
        let _ = response;
        output =
            crate::xml_deser::deser_operation_crate_operation_reset_service_specific_credential(
                response.body().as_ref(),
                output,
            )
            .map_err(crate::error::ResetServiceSpecificCredentialError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_resync_mfa_device_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ResyncMfaDeviceOutput, crate::error::ResyncMFADeviceError> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::ResyncMFADeviceError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ResyncMFADeviceError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InvalidAuthenticationCode" => crate::error::ResyncMFADeviceError {
            meta: generic,
            kind: crate::error::ResyncMFADeviceErrorKind::InvalidAuthenticationCodeException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_authentication_code_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_authentication_code_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::ResyncMFADeviceError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "LimitExceeded" => crate::error::ResyncMFADeviceError {
            meta: generic,
            kind: crate::error::ResyncMFADeviceErrorKind::LimitExceededException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_limit_exceeded_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::ResyncMFADeviceError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "NoSuchEntity" => crate::error::ResyncMFADeviceError {
            meta: generic,
            kind: crate::error::ResyncMFADeviceErrorKind::NoSuchEntityException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::no_such_entity_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_no_such_entity_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::ResyncMFADeviceError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ServiceFailure" => crate::error::ResyncMFADeviceError {
            meta: generic,
            kind: crate::error::ResyncMFADeviceErrorKind::ServiceFailureException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::service_failure_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_service_failure_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::ResyncMFADeviceError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::ResyncMFADeviceError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_resync_mfa_device_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ResyncMfaDeviceOutput, crate::error::ResyncMFADeviceError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::resync_mfa_device_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_set_default_policy_version_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::SetDefaultPolicyVersionOutput,
    crate::error::SetDefaultPolicyVersionError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::SetDefaultPolicyVersionError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::SetDefaultPolicyVersionError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InvalidInput" => crate::error::SetDefaultPolicyVersionError {
            meta: generic,
            kind: crate::error::SetDefaultPolicyVersionErrorKind::InvalidInputException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_input_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_input_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::SetDefaultPolicyVersionError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "LimitExceeded" => crate::error::SetDefaultPolicyVersionError {
            meta: generic,
            kind: crate::error::SetDefaultPolicyVersionErrorKind::LimitExceededException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_limit_exceeded_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::SetDefaultPolicyVersionError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "NoSuchEntity" => crate::error::SetDefaultPolicyVersionError {
            meta: generic,
            kind: crate::error::SetDefaultPolicyVersionErrorKind::NoSuchEntityException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::no_such_entity_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_no_such_entity_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::SetDefaultPolicyVersionError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ServiceFailure" => crate::error::SetDefaultPolicyVersionError {
            meta: generic,
            kind: crate::error::SetDefaultPolicyVersionErrorKind::ServiceFailureException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::service_failure_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_service_failure_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::SetDefaultPolicyVersionError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::SetDefaultPolicyVersionError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_set_default_policy_version_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::SetDefaultPolicyVersionOutput,
    crate::error::SetDefaultPolicyVersionError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::set_default_policy_version_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_set_security_token_service_preferences_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::SetSecurityTokenServicePreferencesOutput,
    crate::error::SetSecurityTokenServicePreferencesError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::SetSecurityTokenServicePreferencesError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::SetSecurityTokenServicePreferencesError::unhandled(generic))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ServiceFailure" => crate::error::SetSecurityTokenServicePreferencesError {
            meta: generic,
            kind:
                crate::error::SetSecurityTokenServicePreferencesErrorKind::ServiceFailureException(
                    {
                        #[allow(unused_mut)]
                        let mut tmp = {
                            #[allow(unused_mut)]
                            let mut output =
                                crate::error::service_failure_exception::Builder::default();
                            let _ = response;
                            output = crate::xml_deser::deser_structure_crate_error_service_failure_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::SetSecurityTokenServicePreferencesError::unhandled)?;
                            output.build()
                        };
                        if (&tmp.message).is_none() {
                            tmp.message = _error_message;
                        }
                        tmp
                    },
                ),
        },
        _ => crate::error::SetSecurityTokenServicePreferencesError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_set_security_token_service_preferences_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::SetSecurityTokenServicePreferencesOutput,
    crate::error::SetSecurityTokenServicePreferencesError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::set_security_token_service_preferences_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_simulate_custom_policy_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::SimulateCustomPolicyOutput,
    crate::error::SimulateCustomPolicyError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::SimulateCustomPolicyError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::SimulateCustomPolicyError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InvalidInput" => crate::error::SimulateCustomPolicyError {
            meta: generic,
            kind: crate::error::SimulateCustomPolicyErrorKind::InvalidInputException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_input_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_input_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::SimulateCustomPolicyError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "PolicyEvaluation" => crate::error::SimulateCustomPolicyError {
            meta: generic,
            kind: crate::error::SimulateCustomPolicyErrorKind::PolicyEvaluationException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::policy_evaluation_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_policy_evaluation_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::SimulateCustomPolicyError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::SimulateCustomPolicyError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_simulate_custom_policy_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::SimulateCustomPolicyOutput,
    crate::error::SimulateCustomPolicyError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::simulate_custom_policy_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_simulate_custom_policy(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::SimulateCustomPolicyError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_simulate_principal_policy_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::SimulatePrincipalPolicyOutput,
    crate::error::SimulatePrincipalPolicyError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::SimulatePrincipalPolicyError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::SimulatePrincipalPolicyError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InvalidInput" => crate::error::SimulatePrincipalPolicyError {
            meta: generic,
            kind: crate::error::SimulatePrincipalPolicyErrorKind::InvalidInputException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_input_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_input_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::SimulatePrincipalPolicyError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "NoSuchEntity" => crate::error::SimulatePrincipalPolicyError {
            meta: generic,
            kind: crate::error::SimulatePrincipalPolicyErrorKind::NoSuchEntityException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::no_such_entity_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_no_such_entity_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::SimulatePrincipalPolicyError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "PolicyEvaluation" => crate::error::SimulatePrincipalPolicyError {
            meta: generic,
            kind: crate::error::SimulatePrincipalPolicyErrorKind::PolicyEvaluationException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::policy_evaluation_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_policy_evaluation_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::SimulatePrincipalPolicyError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::SimulatePrincipalPolicyError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_simulate_principal_policy_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::SimulatePrincipalPolicyOutput,
    crate::error::SimulatePrincipalPolicyError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::simulate_principal_policy_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_simulate_principal_policy(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::SimulatePrincipalPolicyError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_tag_instance_profile_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::TagInstanceProfileOutput,
    crate::error::TagInstanceProfileError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::TagInstanceProfileError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::TagInstanceProfileError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ConcurrentModification" => crate::error::TagInstanceProfileError {
            meta: generic,
            kind: crate::error::TagInstanceProfileErrorKind::ConcurrentModificationException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::concurrent_modification_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_concurrent_modification_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::TagInstanceProfileError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidInput" => crate::error::TagInstanceProfileError {
            meta: generic,
            kind: crate::error::TagInstanceProfileErrorKind::InvalidInputException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_input_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_input_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::TagInstanceProfileError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "LimitExceeded" => crate::error::TagInstanceProfileError {
            meta: generic,
            kind: crate::error::TagInstanceProfileErrorKind::LimitExceededException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_limit_exceeded_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::TagInstanceProfileError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "NoSuchEntity" => crate::error::TagInstanceProfileError {
            meta: generic,
            kind: crate::error::TagInstanceProfileErrorKind::NoSuchEntityException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::no_such_entity_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_no_such_entity_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::TagInstanceProfileError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ServiceFailure" => crate::error::TagInstanceProfileError {
            meta: generic,
            kind: crate::error::TagInstanceProfileErrorKind::ServiceFailureException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::service_failure_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_service_failure_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::TagInstanceProfileError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::TagInstanceProfileError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_tag_instance_profile_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::TagInstanceProfileOutput,
    crate::error::TagInstanceProfileError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::tag_instance_profile_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_tag_mfa_device_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::TagMfaDeviceOutput, crate::error::TagMFADeviceError> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::TagMFADeviceError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::TagMFADeviceError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ConcurrentModification" => crate::error::TagMFADeviceError {
            meta: generic,
            kind: crate::error::TagMFADeviceErrorKind::ConcurrentModificationException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::concurrent_modification_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_concurrent_modification_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::TagMFADeviceError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidInput" => crate::error::TagMFADeviceError {
            meta: generic,
            kind: crate::error::TagMFADeviceErrorKind::InvalidInputException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_input_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_input_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::TagMFADeviceError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "LimitExceeded" => crate::error::TagMFADeviceError {
            meta: generic,
            kind: crate::error::TagMFADeviceErrorKind::LimitExceededException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_limit_exceeded_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::TagMFADeviceError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "NoSuchEntity" => crate::error::TagMFADeviceError {
            meta: generic,
            kind: crate::error::TagMFADeviceErrorKind::NoSuchEntityException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::no_such_entity_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_no_such_entity_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::TagMFADeviceError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ServiceFailure" => crate::error::TagMFADeviceError {
            meta: generic,
            kind: crate::error::TagMFADeviceErrorKind::ServiceFailureException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::service_failure_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_service_failure_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::TagMFADeviceError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::TagMFADeviceError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_tag_mfa_device_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::TagMfaDeviceOutput, crate::error::TagMFADeviceError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::tag_mfa_device_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_tag_open_id_connect_provider_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::TagOpenIdConnectProviderOutput,
    crate::error::TagOpenIDConnectProviderError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::TagOpenIDConnectProviderError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::TagOpenIDConnectProviderError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ConcurrentModification" => crate::error::TagOpenIDConnectProviderError {
            meta: generic,
            kind: crate::error::TagOpenIDConnectProviderErrorKind::ConcurrentModificationException(
                {
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::concurrent_modification_exception::Builder::default();
                        let _ = response;
                        output = crate::xml_deser::deser_structure_crate_error_concurrent_modification_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::TagOpenIDConnectProviderError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                },
            ),
        },
        "InvalidInput" => crate::error::TagOpenIDConnectProviderError {
            meta: generic,
            kind: crate::error::TagOpenIDConnectProviderErrorKind::InvalidInputException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_input_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_input_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::TagOpenIDConnectProviderError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "LimitExceeded" => crate::error::TagOpenIDConnectProviderError {
            meta: generic,
            kind: crate::error::TagOpenIDConnectProviderErrorKind::LimitExceededException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_limit_exceeded_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::TagOpenIDConnectProviderError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "NoSuchEntity" => crate::error::TagOpenIDConnectProviderError {
            meta: generic,
            kind: crate::error::TagOpenIDConnectProviderErrorKind::NoSuchEntityException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::no_such_entity_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_no_such_entity_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::TagOpenIDConnectProviderError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ServiceFailure" => crate::error::TagOpenIDConnectProviderError {
            meta: generic,
            kind: crate::error::TagOpenIDConnectProviderErrorKind::ServiceFailureException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::service_failure_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_service_failure_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::TagOpenIDConnectProviderError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::TagOpenIDConnectProviderError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_tag_open_id_connect_provider_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::TagOpenIdConnectProviderOutput,
    crate::error::TagOpenIDConnectProviderError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::tag_open_id_connect_provider_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_tag_policy_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::TagPolicyOutput, crate::error::TagPolicyError> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::TagPolicyError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::TagPolicyError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ConcurrentModification" => crate::error::TagPolicyError {
            meta: generic,
            kind: crate::error::TagPolicyErrorKind::ConcurrentModificationException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::concurrent_modification_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_concurrent_modification_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::TagPolicyError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidInput" => crate::error::TagPolicyError {
            meta: generic,
            kind: crate::error::TagPolicyErrorKind::InvalidInputException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_input_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_input_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::TagPolicyError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "LimitExceeded" => crate::error::TagPolicyError {
            meta: generic,
            kind: crate::error::TagPolicyErrorKind::LimitExceededException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_limit_exceeded_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::TagPolicyError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "NoSuchEntity" => crate::error::TagPolicyError {
            meta: generic,
            kind: crate::error::TagPolicyErrorKind::NoSuchEntityException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::no_such_entity_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_no_such_entity_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::TagPolicyError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ServiceFailure" => crate::error::TagPolicyError {
            meta: generic,
            kind: crate::error::TagPolicyErrorKind::ServiceFailureException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::service_failure_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_service_failure_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::TagPolicyError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::TagPolicyError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_tag_policy_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::TagPolicyOutput, crate::error::TagPolicyError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::tag_policy_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_tag_role_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::TagRoleOutput, crate::error::TagRoleError> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::TagRoleError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::TagRoleError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ConcurrentModification" => crate::error::TagRoleError {
            meta: generic,
            kind: crate::error::TagRoleErrorKind::ConcurrentModificationException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::concurrent_modification_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_concurrent_modification_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::TagRoleError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidInput" => crate::error::TagRoleError {
            meta: generic,
            kind: crate::error::TagRoleErrorKind::InvalidInputException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_input_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_input_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::TagRoleError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "LimitExceeded" => crate::error::TagRoleError {
            meta: generic,
            kind: crate::error::TagRoleErrorKind::LimitExceededException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_limit_exceeded_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::TagRoleError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "NoSuchEntity" => crate::error::TagRoleError {
            meta: generic,
            kind: crate::error::TagRoleErrorKind::NoSuchEntityException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::no_such_entity_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_no_such_entity_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::TagRoleError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ServiceFailure" => crate::error::TagRoleError {
            meta: generic,
            kind: crate::error::TagRoleErrorKind::ServiceFailureException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::service_failure_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_service_failure_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::TagRoleError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::TagRoleError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_tag_role_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::TagRoleOutput, crate::error::TagRoleError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::tag_role_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_tag_saml_provider_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::TagSamlProviderOutput, crate::error::TagSAMLProviderError> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::TagSAMLProviderError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::TagSAMLProviderError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ConcurrentModification" => crate::error::TagSAMLProviderError {
            meta: generic,
            kind: crate::error::TagSAMLProviderErrorKind::ConcurrentModificationException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::concurrent_modification_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_concurrent_modification_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::TagSAMLProviderError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidInput" => crate::error::TagSAMLProviderError {
            meta: generic,
            kind: crate::error::TagSAMLProviderErrorKind::InvalidInputException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_input_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_input_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::TagSAMLProviderError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "LimitExceeded" => crate::error::TagSAMLProviderError {
            meta: generic,
            kind: crate::error::TagSAMLProviderErrorKind::LimitExceededException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_limit_exceeded_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::TagSAMLProviderError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "NoSuchEntity" => crate::error::TagSAMLProviderError {
            meta: generic,
            kind: crate::error::TagSAMLProviderErrorKind::NoSuchEntityException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::no_such_entity_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_no_such_entity_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::TagSAMLProviderError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ServiceFailure" => crate::error::TagSAMLProviderError {
            meta: generic,
            kind: crate::error::TagSAMLProviderErrorKind::ServiceFailureException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::service_failure_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_service_failure_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::TagSAMLProviderError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::TagSAMLProviderError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_tag_saml_provider_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::TagSamlProviderOutput, crate::error::TagSAMLProviderError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::tag_saml_provider_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_tag_server_certificate_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::TagServerCertificateOutput,
    crate::error::TagServerCertificateError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::TagServerCertificateError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::TagServerCertificateError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ConcurrentModification" => crate::error::TagServerCertificateError {
            meta: generic,
            kind: crate::error::TagServerCertificateErrorKind::ConcurrentModificationException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::concurrent_modification_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_concurrent_modification_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::TagServerCertificateError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidInput" => crate::error::TagServerCertificateError {
            meta: generic,
            kind: crate::error::TagServerCertificateErrorKind::InvalidInputException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_input_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_input_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::TagServerCertificateError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "LimitExceeded" => crate::error::TagServerCertificateError {
            meta: generic,
            kind: crate::error::TagServerCertificateErrorKind::LimitExceededException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_limit_exceeded_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::TagServerCertificateError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "NoSuchEntity" => crate::error::TagServerCertificateError {
            meta: generic,
            kind: crate::error::TagServerCertificateErrorKind::NoSuchEntityException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::no_such_entity_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_no_such_entity_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::TagServerCertificateError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ServiceFailure" => crate::error::TagServerCertificateError {
            meta: generic,
            kind: crate::error::TagServerCertificateErrorKind::ServiceFailureException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::service_failure_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_service_failure_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::TagServerCertificateError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::TagServerCertificateError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_tag_server_certificate_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::TagServerCertificateOutput,
    crate::error::TagServerCertificateError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::tag_server_certificate_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_tag_user_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::TagUserOutput, crate::error::TagUserError> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::TagUserError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::TagUserError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ConcurrentModification" => crate::error::TagUserError {
            meta: generic,
            kind: crate::error::TagUserErrorKind::ConcurrentModificationException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::concurrent_modification_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_concurrent_modification_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::TagUserError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidInput" => crate::error::TagUserError {
            meta: generic,
            kind: crate::error::TagUserErrorKind::InvalidInputException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_input_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_input_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::TagUserError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "LimitExceeded" => crate::error::TagUserError {
            meta: generic,
            kind: crate::error::TagUserErrorKind::LimitExceededException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_limit_exceeded_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::TagUserError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "NoSuchEntity" => crate::error::TagUserError {
            meta: generic,
            kind: crate::error::TagUserErrorKind::NoSuchEntityException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::no_such_entity_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_no_such_entity_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::TagUserError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ServiceFailure" => crate::error::TagUserError {
            meta: generic,
            kind: crate::error::TagUserErrorKind::ServiceFailureException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::service_failure_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_service_failure_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::TagUserError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::TagUserError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_tag_user_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::TagUserOutput, crate::error::TagUserError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::tag_user_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_untag_instance_profile_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UntagInstanceProfileOutput,
    crate::error::UntagInstanceProfileError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::UntagInstanceProfileError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::UntagInstanceProfileError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ConcurrentModification" => crate::error::UntagInstanceProfileError {
            meta: generic,
            kind: crate::error::UntagInstanceProfileErrorKind::ConcurrentModificationException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::concurrent_modification_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_concurrent_modification_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::UntagInstanceProfileError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidInput" => crate::error::UntagInstanceProfileError {
            meta: generic,
            kind: crate::error::UntagInstanceProfileErrorKind::InvalidInputException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_input_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_input_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::UntagInstanceProfileError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "NoSuchEntity" => crate::error::UntagInstanceProfileError {
            meta: generic,
            kind: crate::error::UntagInstanceProfileErrorKind::NoSuchEntityException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::no_such_entity_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_no_such_entity_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::UntagInstanceProfileError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ServiceFailure" => crate::error::UntagInstanceProfileError {
            meta: generic,
            kind: crate::error::UntagInstanceProfileErrorKind::ServiceFailureException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::service_failure_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_service_failure_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::UntagInstanceProfileError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::UntagInstanceProfileError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_untag_instance_profile_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UntagInstanceProfileOutput,
    crate::error::UntagInstanceProfileError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::untag_instance_profile_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_untag_mfa_device_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::UntagMfaDeviceOutput, crate::error::UntagMFADeviceError> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::UntagMFADeviceError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::UntagMFADeviceError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ConcurrentModification" => crate::error::UntagMFADeviceError {
            meta: generic,
            kind: crate::error::UntagMFADeviceErrorKind::ConcurrentModificationException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::concurrent_modification_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_concurrent_modification_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::UntagMFADeviceError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidInput" => crate::error::UntagMFADeviceError {
            meta: generic,
            kind: crate::error::UntagMFADeviceErrorKind::InvalidInputException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_input_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_input_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::UntagMFADeviceError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "NoSuchEntity" => crate::error::UntagMFADeviceError {
            meta: generic,
            kind: crate::error::UntagMFADeviceErrorKind::NoSuchEntityException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::no_such_entity_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_no_such_entity_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::UntagMFADeviceError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ServiceFailure" => crate::error::UntagMFADeviceError {
            meta: generic,
            kind: crate::error::UntagMFADeviceErrorKind::ServiceFailureException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::service_failure_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_service_failure_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::UntagMFADeviceError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::UntagMFADeviceError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_untag_mfa_device_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::UntagMfaDeviceOutput, crate::error::UntagMFADeviceError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::untag_mfa_device_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_untag_open_id_connect_provider_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UntagOpenIdConnectProviderOutput,
    crate::error::UntagOpenIDConnectProviderError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::UntagOpenIDConnectProviderError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::UntagOpenIDConnectProviderError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ConcurrentModification" => crate::error::UntagOpenIDConnectProviderError {
            meta: generic,
            kind:
                crate::error::UntagOpenIDConnectProviderErrorKind::ConcurrentModificationException(
                    {
                        #[allow(unused_mut)]
                        let mut tmp = {
                            #[allow(unused_mut)]
                            let mut output =
                                crate::error::concurrent_modification_exception::Builder::default();
                            let _ = response;
                            output = crate::xml_deser::deser_structure_crate_error_concurrent_modification_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::UntagOpenIDConnectProviderError::unhandled)?;
                            output.build()
                        };
                        if (&tmp.message).is_none() {
                            tmp.message = _error_message;
                        }
                        tmp
                    },
                ),
        },
        "InvalidInput" => crate::error::UntagOpenIDConnectProviderError {
            meta: generic,
            kind: crate::error::UntagOpenIDConnectProviderErrorKind::InvalidInputException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_input_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_input_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::UntagOpenIDConnectProviderError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "NoSuchEntity" => crate::error::UntagOpenIDConnectProviderError {
            meta: generic,
            kind: crate::error::UntagOpenIDConnectProviderErrorKind::NoSuchEntityException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::no_such_entity_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_no_such_entity_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::UntagOpenIDConnectProviderError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ServiceFailure" => crate::error::UntagOpenIDConnectProviderError {
            meta: generic,
            kind: crate::error::UntagOpenIDConnectProviderErrorKind::ServiceFailureException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::service_failure_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_service_failure_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::UntagOpenIDConnectProviderError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::UntagOpenIDConnectProviderError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_untag_open_id_connect_provider_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UntagOpenIdConnectProviderOutput,
    crate::error::UntagOpenIDConnectProviderError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::untag_open_id_connect_provider_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_untag_policy_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::UntagPolicyOutput, crate::error::UntagPolicyError> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::UntagPolicyError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::UntagPolicyError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ConcurrentModification" => crate::error::UntagPolicyError {
            meta: generic,
            kind: crate::error::UntagPolicyErrorKind::ConcurrentModificationException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::concurrent_modification_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_concurrent_modification_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::UntagPolicyError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidInput" => crate::error::UntagPolicyError {
            meta: generic,
            kind: crate::error::UntagPolicyErrorKind::InvalidInputException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_input_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_input_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::UntagPolicyError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "NoSuchEntity" => crate::error::UntagPolicyError {
            meta: generic,
            kind: crate::error::UntagPolicyErrorKind::NoSuchEntityException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::no_such_entity_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_no_such_entity_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::UntagPolicyError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ServiceFailure" => crate::error::UntagPolicyError {
            meta: generic,
            kind: crate::error::UntagPolicyErrorKind::ServiceFailureException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::service_failure_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_service_failure_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::UntagPolicyError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::UntagPolicyError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_untag_policy_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::UntagPolicyOutput, crate::error::UntagPolicyError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::untag_policy_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_untag_role_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::UntagRoleOutput, crate::error::UntagRoleError> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::UntagRoleError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::UntagRoleError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ConcurrentModification" => crate::error::UntagRoleError {
            meta: generic,
            kind: crate::error::UntagRoleErrorKind::ConcurrentModificationException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::concurrent_modification_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_concurrent_modification_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::UntagRoleError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "NoSuchEntity" => crate::error::UntagRoleError {
            meta: generic,
            kind: crate::error::UntagRoleErrorKind::NoSuchEntityException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::no_such_entity_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_no_such_entity_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::UntagRoleError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ServiceFailure" => crate::error::UntagRoleError {
            meta: generic,
            kind: crate::error::UntagRoleErrorKind::ServiceFailureException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::service_failure_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_service_failure_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::UntagRoleError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::UntagRoleError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_untag_role_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::UntagRoleOutput, crate::error::UntagRoleError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::untag_role_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_untag_saml_provider_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::UntagSamlProviderOutput, crate::error::UntagSAMLProviderError>
{
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::UntagSAMLProviderError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::UntagSAMLProviderError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ConcurrentModification" => crate::error::UntagSAMLProviderError {
            meta: generic,
            kind: crate::error::UntagSAMLProviderErrorKind::ConcurrentModificationException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::concurrent_modification_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_concurrent_modification_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::UntagSAMLProviderError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidInput" => crate::error::UntagSAMLProviderError {
            meta: generic,
            kind: crate::error::UntagSAMLProviderErrorKind::InvalidInputException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_input_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_input_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::UntagSAMLProviderError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "NoSuchEntity" => crate::error::UntagSAMLProviderError {
            meta: generic,
            kind: crate::error::UntagSAMLProviderErrorKind::NoSuchEntityException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::no_such_entity_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_no_such_entity_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::UntagSAMLProviderError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ServiceFailure" => crate::error::UntagSAMLProviderError {
            meta: generic,
            kind: crate::error::UntagSAMLProviderErrorKind::ServiceFailureException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::service_failure_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_service_failure_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::UntagSAMLProviderError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::UntagSAMLProviderError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_untag_saml_provider_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::UntagSamlProviderOutput, crate::error::UntagSAMLProviderError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::untag_saml_provider_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_untag_server_certificate_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UntagServerCertificateOutput,
    crate::error::UntagServerCertificateError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::UntagServerCertificateError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::UntagServerCertificateError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ConcurrentModification" => crate::error::UntagServerCertificateError {
            meta: generic,
            kind: crate::error::UntagServerCertificateErrorKind::ConcurrentModificationException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::concurrent_modification_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_concurrent_modification_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::UntagServerCertificateError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidInput" => crate::error::UntagServerCertificateError {
            meta: generic,
            kind: crate::error::UntagServerCertificateErrorKind::InvalidInputException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_input_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_input_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::UntagServerCertificateError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "NoSuchEntity" => crate::error::UntagServerCertificateError {
            meta: generic,
            kind: crate::error::UntagServerCertificateErrorKind::NoSuchEntityException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::no_such_entity_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_no_such_entity_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::UntagServerCertificateError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ServiceFailure" => crate::error::UntagServerCertificateError {
            meta: generic,
            kind: crate::error::UntagServerCertificateErrorKind::ServiceFailureException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::service_failure_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_service_failure_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::UntagServerCertificateError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::UntagServerCertificateError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_untag_server_certificate_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UntagServerCertificateOutput,
    crate::error::UntagServerCertificateError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::untag_server_certificate_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_untag_user_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::UntagUserOutput, crate::error::UntagUserError> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::UntagUserError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::UntagUserError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ConcurrentModification" => crate::error::UntagUserError {
            meta: generic,
            kind: crate::error::UntagUserErrorKind::ConcurrentModificationException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::concurrent_modification_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_concurrent_modification_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::UntagUserError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "NoSuchEntity" => crate::error::UntagUserError {
            meta: generic,
            kind: crate::error::UntagUserErrorKind::NoSuchEntityException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::no_such_entity_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_no_such_entity_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::UntagUserError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ServiceFailure" => crate::error::UntagUserError {
            meta: generic,
            kind: crate::error::UntagUserErrorKind::ServiceFailureException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::service_failure_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_service_failure_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::UntagUserError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::UntagUserError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_untag_user_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::UntagUserOutput, crate::error::UntagUserError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::untag_user_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_access_key_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::UpdateAccessKeyOutput, crate::error::UpdateAccessKeyError> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::UpdateAccessKeyError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::UpdateAccessKeyError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "LimitExceeded" => crate::error::UpdateAccessKeyError {
            meta: generic,
            kind: crate::error::UpdateAccessKeyErrorKind::LimitExceededException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_limit_exceeded_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateAccessKeyError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "NoSuchEntity" => crate::error::UpdateAccessKeyError {
            meta: generic,
            kind: crate::error::UpdateAccessKeyErrorKind::NoSuchEntityException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::no_such_entity_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_no_such_entity_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateAccessKeyError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ServiceFailure" => crate::error::UpdateAccessKeyError {
            meta: generic,
            kind: crate::error::UpdateAccessKeyErrorKind::ServiceFailureException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::service_failure_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_service_failure_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateAccessKeyError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::UpdateAccessKeyError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_access_key_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::UpdateAccessKeyOutput, crate::error::UpdateAccessKeyError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::update_access_key_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_account_password_policy_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdateAccountPasswordPolicyOutput,
    crate::error::UpdateAccountPasswordPolicyError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::UpdateAccountPasswordPolicyError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::UpdateAccountPasswordPolicyError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "LimitExceeded" => crate::error::UpdateAccountPasswordPolicyError {
            meta: generic,
            kind: crate::error::UpdateAccountPasswordPolicyErrorKind::LimitExceededException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_limit_exceeded_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateAccountPasswordPolicyError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "MalformedPolicyDocument" => crate::error::UpdateAccountPasswordPolicyError {
            meta: generic,
            kind:
                crate::error::UpdateAccountPasswordPolicyErrorKind::MalformedPolicyDocumentException(
                    {
                        #[allow(unused_mut)]
                        let mut tmp = {
                            #[allow(unused_mut)]
                            let mut output =
                                crate::error::malformed_policy_document_exception::Builder::default(
                                );
                            let _ = response;
                            output = crate::xml_deser::deser_structure_crate_error_malformed_policy_document_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateAccountPasswordPolicyError::unhandled)?;
                            output.build()
                        };
                        if (&tmp.message).is_none() {
                            tmp.message = _error_message;
                        }
                        tmp
                    },
                ),
        },
        "NoSuchEntity" => crate::error::UpdateAccountPasswordPolicyError {
            meta: generic,
            kind: crate::error::UpdateAccountPasswordPolicyErrorKind::NoSuchEntityException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::no_such_entity_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_no_such_entity_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateAccountPasswordPolicyError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ServiceFailure" => crate::error::UpdateAccountPasswordPolicyError {
            meta: generic,
            kind: crate::error::UpdateAccountPasswordPolicyErrorKind::ServiceFailureException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::service_failure_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_service_failure_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateAccountPasswordPolicyError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::UpdateAccountPasswordPolicyError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_account_password_policy_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdateAccountPasswordPolicyOutput,
    crate::error::UpdateAccountPasswordPolicyError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::update_account_password_policy_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_assume_role_policy_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdateAssumeRolePolicyOutput,
    crate::error::UpdateAssumeRolePolicyError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::UpdateAssumeRolePolicyError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::UpdateAssumeRolePolicyError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "LimitExceeded" => crate::error::UpdateAssumeRolePolicyError {
            meta: generic,
            kind: crate::error::UpdateAssumeRolePolicyErrorKind::LimitExceededException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_limit_exceeded_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateAssumeRolePolicyError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "MalformedPolicyDocument" => crate::error::UpdateAssumeRolePolicyError {
            meta: generic,
            kind: crate::error::UpdateAssumeRolePolicyErrorKind::MalformedPolicyDocumentException(
                {
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::malformed_policy_document_exception::Builder::default();
                        let _ = response;
                        output = crate::xml_deser::deser_structure_crate_error_malformed_policy_document_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateAssumeRolePolicyError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                },
            ),
        },
        "NoSuchEntity" => crate::error::UpdateAssumeRolePolicyError {
            meta: generic,
            kind: crate::error::UpdateAssumeRolePolicyErrorKind::NoSuchEntityException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::no_such_entity_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_no_such_entity_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateAssumeRolePolicyError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ServiceFailure" => crate::error::UpdateAssumeRolePolicyError {
            meta: generic,
            kind: crate::error::UpdateAssumeRolePolicyErrorKind::ServiceFailureException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::service_failure_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_service_failure_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateAssumeRolePolicyError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "UnmodifiableEntity" => crate::error::UpdateAssumeRolePolicyError {
            meta: generic,
            kind: crate::error::UpdateAssumeRolePolicyErrorKind::UnmodifiableEntityException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::unmodifiable_entity_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_unmodifiable_entity_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateAssumeRolePolicyError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::UpdateAssumeRolePolicyError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_assume_role_policy_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdateAssumeRolePolicyOutput,
    crate::error::UpdateAssumeRolePolicyError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::update_assume_role_policy_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_group_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::UpdateGroupOutput, crate::error::UpdateGroupError> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::UpdateGroupError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::UpdateGroupError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "EntityAlreadyExists" => crate::error::UpdateGroupError {
            meta: generic,
            kind: crate::error::UpdateGroupErrorKind::EntityAlreadyExistsException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::entity_already_exists_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_entity_already_exists_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateGroupError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "LimitExceeded" => crate::error::UpdateGroupError {
            meta: generic,
            kind: crate::error::UpdateGroupErrorKind::LimitExceededException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_limit_exceeded_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateGroupError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "NoSuchEntity" => crate::error::UpdateGroupError {
            meta: generic,
            kind: crate::error::UpdateGroupErrorKind::NoSuchEntityException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::no_such_entity_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_no_such_entity_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateGroupError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ServiceFailure" => crate::error::UpdateGroupError {
            meta: generic,
            kind: crate::error::UpdateGroupErrorKind::ServiceFailureException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::service_failure_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_service_failure_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateGroupError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::UpdateGroupError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_group_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::UpdateGroupOutput, crate::error::UpdateGroupError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::update_group_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_login_profile_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdateLoginProfileOutput,
    crate::error::UpdateLoginProfileError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::UpdateLoginProfileError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::UpdateLoginProfileError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "EntityTemporarilyUnmodifiable" => crate::error::UpdateLoginProfileError {
            meta: generic,
            kind: crate::error::UpdateLoginProfileErrorKind::EntityTemporarilyUnmodifiableException(
                {
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]let mut output = crate::error::entity_temporarily_unmodifiable_exception::Builder::default();
                        let _ = response;
                        output = crate::xml_deser::deser_structure_crate_error_entity_temporarily_unmodifiable_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateLoginProfileError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                },
            ),
        },
        "LimitExceeded" => crate::error::UpdateLoginProfileError {
            meta: generic,
            kind: crate::error::UpdateLoginProfileErrorKind::LimitExceededException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_limit_exceeded_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateLoginProfileError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "NoSuchEntity" => crate::error::UpdateLoginProfileError {
            meta: generic,
            kind: crate::error::UpdateLoginProfileErrorKind::NoSuchEntityException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::no_such_entity_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_no_such_entity_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateLoginProfileError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "PasswordPolicyViolation" => crate::error::UpdateLoginProfileError {
            meta: generic,
            kind: crate::error::UpdateLoginProfileErrorKind::PasswordPolicyViolationException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::password_policy_violation_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_password_policy_violation_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateLoginProfileError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ServiceFailure" => crate::error::UpdateLoginProfileError {
            meta: generic,
            kind: crate::error::UpdateLoginProfileErrorKind::ServiceFailureException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::service_failure_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_service_failure_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateLoginProfileError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::UpdateLoginProfileError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_login_profile_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdateLoginProfileOutput,
    crate::error::UpdateLoginProfileError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::update_login_profile_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_open_id_connect_provider_thumbprint_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdateOpenIdConnectProviderThumbprintOutput,
    crate::error::UpdateOpenIDConnectProviderThumbprintError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::UpdateOpenIDConnectProviderThumbprintError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(
                crate::error::UpdateOpenIDConnectProviderThumbprintError::unhandled(generic),
            )
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InvalidInput" => crate::error::UpdateOpenIDConnectProviderThumbprintError { meta: generic, kind: crate::error::UpdateOpenIDConnectProviderThumbprintErrorKind::InvalidInputException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_input_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_input_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateOpenIDConnectProviderThumbprintError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "NoSuchEntity" => crate::error::UpdateOpenIDConnectProviderThumbprintError { meta: generic, kind: crate::error::UpdateOpenIDConnectProviderThumbprintErrorKind::NoSuchEntityException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::no_such_entity_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_no_such_entity_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateOpenIDConnectProviderThumbprintError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ServiceFailure" => crate::error::UpdateOpenIDConnectProviderThumbprintError { meta: generic, kind: crate::error::UpdateOpenIDConnectProviderThumbprintErrorKind::ServiceFailureException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::service_failure_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_service_failure_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateOpenIDConnectProviderThumbprintError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::UpdateOpenIDConnectProviderThumbprintError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_open_id_connect_provider_thumbprint_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdateOpenIdConnectProviderThumbprintOutput,
    crate::error::UpdateOpenIDConnectProviderThumbprintError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::update_open_id_connect_provider_thumbprint_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_role_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::UpdateRoleOutput, crate::error::UpdateRoleError> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::UpdateRoleError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::UpdateRoleError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "NoSuchEntity" => crate::error::UpdateRoleError {
            meta: generic,
            kind: crate::error::UpdateRoleErrorKind::NoSuchEntityException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::no_such_entity_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_no_such_entity_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateRoleError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ServiceFailure" => crate::error::UpdateRoleError {
            meta: generic,
            kind: crate::error::UpdateRoleErrorKind::ServiceFailureException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::service_failure_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_service_failure_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateRoleError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "UnmodifiableEntity" => crate::error::UpdateRoleError {
            meta: generic,
            kind: crate::error::UpdateRoleErrorKind::UnmodifiableEntityException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::unmodifiable_entity_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_unmodifiable_entity_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateRoleError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::UpdateRoleError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_role_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::UpdateRoleOutput, crate::error::UpdateRoleError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::update_role_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_role_description_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdateRoleDescriptionOutput,
    crate::error::UpdateRoleDescriptionError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::UpdateRoleDescriptionError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::UpdateRoleDescriptionError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "NoSuchEntity" => crate::error::UpdateRoleDescriptionError {
            meta: generic,
            kind: crate::error::UpdateRoleDescriptionErrorKind::NoSuchEntityException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::no_such_entity_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_no_such_entity_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateRoleDescriptionError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ServiceFailure" => crate::error::UpdateRoleDescriptionError {
            meta: generic,
            kind: crate::error::UpdateRoleDescriptionErrorKind::ServiceFailureException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::service_failure_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_service_failure_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateRoleDescriptionError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "UnmodifiableEntity" => crate::error::UpdateRoleDescriptionError {
            meta: generic,
            kind: crate::error::UpdateRoleDescriptionErrorKind::UnmodifiableEntityException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::unmodifiable_entity_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_unmodifiable_entity_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateRoleDescriptionError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::UpdateRoleDescriptionError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_role_description_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdateRoleDescriptionOutput,
    crate::error::UpdateRoleDescriptionError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::update_role_description_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_update_role_description(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::UpdateRoleDescriptionError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_saml_provider_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdateSamlProviderOutput,
    crate::error::UpdateSAMLProviderError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::UpdateSAMLProviderError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::UpdateSAMLProviderError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InvalidInput" => crate::error::UpdateSAMLProviderError {
            meta: generic,
            kind: crate::error::UpdateSAMLProviderErrorKind::InvalidInputException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_input_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_input_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateSAMLProviderError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "LimitExceeded" => crate::error::UpdateSAMLProviderError {
            meta: generic,
            kind: crate::error::UpdateSAMLProviderErrorKind::LimitExceededException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_limit_exceeded_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateSAMLProviderError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "NoSuchEntity" => crate::error::UpdateSAMLProviderError {
            meta: generic,
            kind: crate::error::UpdateSAMLProviderErrorKind::NoSuchEntityException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::no_such_entity_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_no_such_entity_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateSAMLProviderError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ServiceFailure" => crate::error::UpdateSAMLProviderError {
            meta: generic,
            kind: crate::error::UpdateSAMLProviderErrorKind::ServiceFailureException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::service_failure_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_service_failure_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateSAMLProviderError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::UpdateSAMLProviderError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_saml_provider_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdateSamlProviderOutput,
    crate::error::UpdateSAMLProviderError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::update_saml_provider_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_update_saml_provider(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::UpdateSAMLProviderError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_server_certificate_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdateServerCertificateOutput,
    crate::error::UpdateServerCertificateError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::UpdateServerCertificateError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::UpdateServerCertificateError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "EntityAlreadyExists" => crate::error::UpdateServerCertificateError {
            meta: generic,
            kind: crate::error::UpdateServerCertificateErrorKind::EntityAlreadyExistsException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::entity_already_exists_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_entity_already_exists_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateServerCertificateError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "LimitExceeded" => crate::error::UpdateServerCertificateError {
            meta: generic,
            kind: crate::error::UpdateServerCertificateErrorKind::LimitExceededException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_limit_exceeded_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateServerCertificateError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "NoSuchEntity" => crate::error::UpdateServerCertificateError {
            meta: generic,
            kind: crate::error::UpdateServerCertificateErrorKind::NoSuchEntityException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::no_such_entity_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_no_such_entity_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateServerCertificateError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ServiceFailure" => crate::error::UpdateServerCertificateError {
            meta: generic,
            kind: crate::error::UpdateServerCertificateErrorKind::ServiceFailureException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::service_failure_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_service_failure_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateServerCertificateError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::UpdateServerCertificateError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_server_certificate_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdateServerCertificateOutput,
    crate::error::UpdateServerCertificateError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::update_server_certificate_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_service_specific_credential_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdateServiceSpecificCredentialOutput,
    crate::error::UpdateServiceSpecificCredentialError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::UpdateServiceSpecificCredentialError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::UpdateServiceSpecificCredentialError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "NoSuchEntity" => crate::error::UpdateServiceSpecificCredentialError {
            meta: generic,
            kind: crate::error::UpdateServiceSpecificCredentialErrorKind::NoSuchEntityException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::no_such_entity_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_no_such_entity_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateServiceSpecificCredentialError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::UpdateServiceSpecificCredentialError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_service_specific_credential_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdateServiceSpecificCredentialOutput,
    crate::error::UpdateServiceSpecificCredentialError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::update_service_specific_credential_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_signing_certificate_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdateSigningCertificateOutput,
    crate::error::UpdateSigningCertificateError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::UpdateSigningCertificateError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::UpdateSigningCertificateError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "LimitExceeded" => crate::error::UpdateSigningCertificateError {
            meta: generic,
            kind: crate::error::UpdateSigningCertificateErrorKind::LimitExceededException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_limit_exceeded_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateSigningCertificateError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "NoSuchEntity" => crate::error::UpdateSigningCertificateError {
            meta: generic,
            kind: crate::error::UpdateSigningCertificateErrorKind::NoSuchEntityException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::no_such_entity_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_no_such_entity_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateSigningCertificateError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ServiceFailure" => crate::error::UpdateSigningCertificateError {
            meta: generic,
            kind: crate::error::UpdateSigningCertificateErrorKind::ServiceFailureException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::service_failure_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_service_failure_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateSigningCertificateError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::UpdateSigningCertificateError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_signing_certificate_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdateSigningCertificateOutput,
    crate::error::UpdateSigningCertificateError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::update_signing_certificate_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_ssh_public_key_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdateSshPublicKeyOutput,
    crate::error::UpdateSSHPublicKeyError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::UpdateSSHPublicKeyError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::UpdateSSHPublicKeyError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "NoSuchEntity" => crate::error::UpdateSSHPublicKeyError {
            meta: generic,
            kind: crate::error::UpdateSSHPublicKeyErrorKind::NoSuchEntityException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::no_such_entity_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_no_such_entity_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateSSHPublicKeyError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::UpdateSSHPublicKeyError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_ssh_public_key_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdateSshPublicKeyOutput,
    crate::error::UpdateSSHPublicKeyError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::update_ssh_public_key_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_user_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::UpdateUserOutput, crate::error::UpdateUserError> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::UpdateUserError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::UpdateUserError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ConcurrentModification" => crate::error::UpdateUserError {
            meta: generic,
            kind: crate::error::UpdateUserErrorKind::ConcurrentModificationException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::concurrent_modification_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_concurrent_modification_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateUserError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "EntityAlreadyExists" => crate::error::UpdateUserError {
            meta: generic,
            kind: crate::error::UpdateUserErrorKind::EntityAlreadyExistsException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::entity_already_exists_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_entity_already_exists_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateUserError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "EntityTemporarilyUnmodifiable" => {
            crate::error::UpdateUserError {
                meta: generic,
                kind: crate::error::UpdateUserErrorKind::EntityTemporarilyUnmodifiableException({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]let mut output = crate::error::entity_temporarily_unmodifiable_exception::Builder::default();
                        let _ = response;
                        output = crate::xml_deser::deser_structure_crate_error_entity_temporarily_unmodifiable_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateUserError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        "LimitExceeded" => crate::error::UpdateUserError {
            meta: generic,
            kind: crate::error::UpdateUserErrorKind::LimitExceededException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_limit_exceeded_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateUserError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "NoSuchEntity" => crate::error::UpdateUserError {
            meta: generic,
            kind: crate::error::UpdateUserErrorKind::NoSuchEntityException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::no_such_entity_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_no_such_entity_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateUserError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ServiceFailure" => crate::error::UpdateUserError {
            meta: generic,
            kind: crate::error::UpdateUserErrorKind::ServiceFailureException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::service_failure_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_service_failure_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateUserError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::UpdateUserError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_user_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::UpdateUserOutput, crate::error::UpdateUserError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::update_user_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_upload_server_certificate_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UploadServerCertificateOutput,
    crate::error::UploadServerCertificateError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::UploadServerCertificateError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::UploadServerCertificateError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ConcurrentModification" => crate::error::UploadServerCertificateError {
            meta: generic,
            kind: crate::error::UploadServerCertificateErrorKind::ConcurrentModificationException(
                {
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::concurrent_modification_exception::Builder::default();
                        let _ = response;
                        output = crate::xml_deser::deser_structure_crate_error_concurrent_modification_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::UploadServerCertificateError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                },
            ),
        },
        "EntityAlreadyExists" => crate::error::UploadServerCertificateError {
            meta: generic,
            kind: crate::error::UploadServerCertificateErrorKind::EntityAlreadyExistsException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::entity_already_exists_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_entity_already_exists_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::UploadServerCertificateError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidInput" => crate::error::UploadServerCertificateError {
            meta: generic,
            kind: crate::error::UploadServerCertificateErrorKind::InvalidInputException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_input_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_input_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::UploadServerCertificateError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "KeyPairMismatch" => crate::error::UploadServerCertificateError {
            meta: generic,
            kind: crate::error::UploadServerCertificateErrorKind::KeyPairMismatchException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::key_pair_mismatch_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_key_pair_mismatch_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::UploadServerCertificateError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "LimitExceeded" => crate::error::UploadServerCertificateError {
            meta: generic,
            kind: crate::error::UploadServerCertificateErrorKind::LimitExceededException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_limit_exceeded_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::UploadServerCertificateError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "MalformedCertificate" => crate::error::UploadServerCertificateError {
            meta: generic,
            kind: crate::error::UploadServerCertificateErrorKind::MalformedCertificateException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::malformed_certificate_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_malformed_certificate_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::UploadServerCertificateError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ServiceFailure" => crate::error::UploadServerCertificateError {
            meta: generic,
            kind: crate::error::UploadServerCertificateErrorKind::ServiceFailureException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::service_failure_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_service_failure_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::UploadServerCertificateError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::UploadServerCertificateError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_upload_server_certificate_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UploadServerCertificateOutput,
    crate::error::UploadServerCertificateError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::upload_server_certificate_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_upload_server_certificate(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::UploadServerCertificateError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_upload_signing_certificate_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UploadSigningCertificateOutput,
    crate::error::UploadSigningCertificateError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::UploadSigningCertificateError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::UploadSigningCertificateError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DuplicateCertificate" => crate::error::UploadSigningCertificateError {
            meta: generic,
            kind: crate::error::UploadSigningCertificateErrorKind::DuplicateCertificateException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::duplicate_certificate_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_duplicate_certificate_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::UploadSigningCertificateError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "EntityAlreadyExists" => crate::error::UploadSigningCertificateError {
            meta: generic,
            kind: crate::error::UploadSigningCertificateErrorKind::EntityAlreadyExistsException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::entity_already_exists_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_entity_already_exists_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::UploadSigningCertificateError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidCertificate" => crate::error::UploadSigningCertificateError {
            meta: generic,
            kind: crate::error::UploadSigningCertificateErrorKind::InvalidCertificateException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_certificate_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_certificate_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::UploadSigningCertificateError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "LimitExceeded" => crate::error::UploadSigningCertificateError {
            meta: generic,
            kind: crate::error::UploadSigningCertificateErrorKind::LimitExceededException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_limit_exceeded_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::UploadSigningCertificateError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "MalformedCertificate" => crate::error::UploadSigningCertificateError {
            meta: generic,
            kind: crate::error::UploadSigningCertificateErrorKind::MalformedCertificateException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::malformed_certificate_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_malformed_certificate_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::UploadSigningCertificateError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "NoSuchEntity" => crate::error::UploadSigningCertificateError {
            meta: generic,
            kind: crate::error::UploadSigningCertificateErrorKind::NoSuchEntityException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::no_such_entity_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_no_such_entity_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::UploadSigningCertificateError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ServiceFailure" => crate::error::UploadSigningCertificateError {
            meta: generic,
            kind: crate::error::UploadSigningCertificateErrorKind::ServiceFailureException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::service_failure_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_service_failure_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::UploadSigningCertificateError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::UploadSigningCertificateError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_upload_signing_certificate_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UploadSigningCertificateOutput,
    crate::error::UploadSigningCertificateError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::upload_signing_certificate_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_upload_signing_certificate(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::UploadSigningCertificateError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_upload_ssh_public_key_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UploadSshPublicKeyOutput,
    crate::error::UploadSSHPublicKeyError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::UploadSSHPublicKeyError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::UploadSSHPublicKeyError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DuplicateSSHPublicKey" => crate::error::UploadSSHPublicKeyError {
            meta: generic,
            kind: crate::error::UploadSSHPublicKeyErrorKind::DuplicateSshPublicKeyException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::duplicate_ssh_public_key_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_duplicate_ssh_public_key_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::UploadSSHPublicKeyError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidPublicKey" => crate::error::UploadSSHPublicKeyError {
            meta: generic,
            kind: crate::error::UploadSSHPublicKeyErrorKind::InvalidPublicKeyException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_public_key_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_public_key_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::UploadSSHPublicKeyError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "LimitExceeded" => crate::error::UploadSSHPublicKeyError {
            meta: generic,
            kind: crate::error::UploadSSHPublicKeyErrorKind::LimitExceededException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_limit_exceeded_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::UploadSSHPublicKeyError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "NoSuchEntity" => crate::error::UploadSSHPublicKeyError {
            meta: generic,
            kind: crate::error::UploadSSHPublicKeyErrorKind::NoSuchEntityException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::no_such_entity_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_no_such_entity_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::UploadSSHPublicKeyError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "UnrecognizedPublicKeyEncoding" => crate::error::UploadSSHPublicKeyError {
            meta: generic,
            kind: crate::error::UploadSSHPublicKeyErrorKind::UnrecognizedPublicKeyEncodingException(
                {
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]let mut output = crate::error::unrecognized_public_key_encoding_exception::Builder::default();
                        let _ = response;
                        output = crate::xml_deser::deser_structure_crate_error_unrecognized_public_key_encoding_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::UploadSSHPublicKeyError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                },
            ),
        },
        _ => crate::error::UploadSSHPublicKeyError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_upload_ssh_public_key_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UploadSshPublicKeyOutput,
    crate::error::UploadSSHPublicKeyError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::upload_ssh_public_key_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_upload_ssh_public_key(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::UploadSSHPublicKeyError::unhandled)?;
        output.build()
    })
}
