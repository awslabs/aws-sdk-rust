// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
use std::fmt::Write;
/// See [`AddClientIDToOpenIDConnectProviderInput`](crate::input::AddClientIDToOpenIDConnectProviderInput)
pub mod add_client_id_to_open_id_connect_provider_input {
    /// A builder for [`AddClientIDToOpenIDConnectProviderInput`](crate::input::AddClientIDToOpenIDConnectProviderInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) open_id_connect_provider_arn: std::option::Option<std::string::String>,
        pub(crate) client_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the IAM OpenID Connect (OIDC) provider resource to
        /// add the client ID to. You can get a list of OIDC provider ARNs by using the <a>ListOpenIDConnectProviders</a> operation.</p>
        pub fn open_id_connect_provider_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.open_id_connect_provider_arn = Some(inp.into());
            self
        }
        pub fn set_open_id_connect_provider_arn(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.open_id_connect_provider_arn = inp;
            self
        }
        /// <p>The client ID (also known as audience) to add to the IAM OpenID Connect provider
        /// resource.</p>
        pub fn client_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.client_id = Some(inp.into());
            self
        }
        pub fn set_client_id(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.client_id = inp;
            self
        }
        /// Consumes the builder and constructs a [`AddClientIDToOpenIDConnectProviderInput`](crate::input::AddClientIDToOpenIDConnectProviderInput)
        pub fn build(
            self,
        ) -> Result<
            crate::input::AddClientIDToOpenIDConnectProviderInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::AddClientIDToOpenIDConnectProviderInput {
                open_id_connect_provider_arn: self.open_id_connect_provider_arn,
                client_id: self.client_id,
            })
        }
    }
}
#[doc(hidden)]
pub type AddClientIDToOpenIDConnectProviderInputOperationOutputAlias =
    crate::operation::AddClientIDToOpenIDConnectProvider;
#[doc(hidden)]
pub type AddClientIDToOpenIDConnectProviderInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl AddClientIDToOpenIDConnectProviderInput {
    /// Consumes the builder and constructs an Operation<[`AddClientIDToOpenIDConnectProvider`](crate::operation::AddClientIDToOpenIDConnectProvider)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> Result<
        smithy_http::operation::Operation<
            crate::operation::AddClientIDToOpenIDConnectProvider,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body =
                crate::operation_ser::serialize_operation_add_client_id_to_open_id_connect_provider(&self).map_err(|err|smithy_http::operation::BuildError::SerializationError(err.into()))?
            ;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::AddClientIDToOpenIDConnectProvider::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "AddClientIDToOpenIDConnectProvider",
                "iam",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) {
        write!(output, "/").expect("formatting should succeed")
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri);
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let builder = http::request::Builder::new();
        let builder = builder.header("Content-Type", "application/x-www-form-urlencoded");
        self.update_http_builder(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`AddClientIDToOpenIDConnectProviderInput`](crate::input::AddClientIDToOpenIDConnectProviderInput)
    pub fn builder() -> crate::input::add_client_id_to_open_id_connect_provider_input::Builder {
        crate::input::add_client_id_to_open_id_connect_provider_input::Builder::default()
    }
}

/// See [`AddRoleToInstanceProfileInput`](crate::input::AddRoleToInstanceProfileInput)
pub mod add_role_to_instance_profile_input {
    /// A builder for [`AddRoleToInstanceProfileInput`](crate::input::AddRoleToInstanceProfileInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) instance_profile_name: std::option::Option<std::string::String>,
        pub(crate) role_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the instance profile to update.</p>
        /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
        /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
        pub fn instance_profile_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.instance_profile_name = Some(inp.into());
            self
        }
        pub fn set_instance_profile_name(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.instance_profile_name = inp;
            self
        }
        /// <p>The name of the role to add.</p>
        /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
        /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
        pub fn role_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.role_name = Some(inp.into());
            self
        }
        pub fn set_role_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.role_name = inp;
            self
        }
        /// Consumes the builder and constructs a [`AddRoleToInstanceProfileInput`](crate::input::AddRoleToInstanceProfileInput)
        pub fn build(
            self,
        ) -> Result<crate::input::AddRoleToInstanceProfileInput, smithy_http::operation::BuildError>
        {
            Ok(crate::input::AddRoleToInstanceProfileInput {
                instance_profile_name: self.instance_profile_name,
                role_name: self.role_name,
            })
        }
    }
}
#[doc(hidden)]
pub type AddRoleToInstanceProfileInputOperationOutputAlias =
    crate::operation::AddRoleToInstanceProfile;
#[doc(hidden)]
pub type AddRoleToInstanceProfileInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl AddRoleToInstanceProfileInput {
    /// Consumes the builder and constructs an Operation<[`AddRoleToInstanceProfile`](crate::operation::AddRoleToInstanceProfile)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> Result<
        smithy_http::operation::Operation<
            crate::operation::AddRoleToInstanceProfile,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body =
                crate::operation_ser::serialize_operation_add_role_to_instance_profile(&self)
                    .map_err(|err| {
                        smithy_http::operation::BuildError::SerializationError(err.into())
                    })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::AddRoleToInstanceProfile::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "AddRoleToInstanceProfile",
                "iam",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) {
        write!(output, "/").expect("formatting should succeed")
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri);
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let builder = http::request::Builder::new();
        let builder = builder.header("Content-Type", "application/x-www-form-urlencoded");
        self.update_http_builder(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`AddRoleToInstanceProfileInput`](crate::input::AddRoleToInstanceProfileInput)
    pub fn builder() -> crate::input::add_role_to_instance_profile_input::Builder {
        crate::input::add_role_to_instance_profile_input::Builder::default()
    }
}

/// See [`AddUserToGroupInput`](crate::input::AddUserToGroupInput)
pub mod add_user_to_group_input {
    /// A builder for [`AddUserToGroupInput`](crate::input::AddUserToGroupInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) group_name: std::option::Option<std::string::String>,
        pub(crate) user_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the group to update.</p>
        /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
        /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
        pub fn group_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.group_name = Some(inp.into());
            self
        }
        pub fn set_group_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.group_name = inp;
            self
        }
        /// <p>The name of the user to add.</p>
        /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
        /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
        pub fn user_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.user_name = Some(inp.into());
            self
        }
        pub fn set_user_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.user_name = inp;
            self
        }
        /// Consumes the builder and constructs a [`AddUserToGroupInput`](crate::input::AddUserToGroupInput)
        pub fn build(
            self,
        ) -> Result<crate::input::AddUserToGroupInput, smithy_http::operation::BuildError> {
            Ok(crate::input::AddUserToGroupInput {
                group_name: self.group_name,
                user_name: self.user_name,
            })
        }
    }
}
#[doc(hidden)]
pub type AddUserToGroupInputOperationOutputAlias = crate::operation::AddUserToGroup;
#[doc(hidden)]
pub type AddUserToGroupInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl AddUserToGroupInput {
    /// Consumes the builder and constructs an Operation<[`AddUserToGroup`](crate::operation::AddUserToGroup)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> Result<
        smithy_http::operation::Operation<
            crate::operation::AddUserToGroup,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = crate::operation_ser::serialize_operation_add_user_to_group(&self).map_err(
                |err| smithy_http::operation::BuildError::SerializationError(err.into()),
            )?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::AddUserToGroup::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "AddUserToGroup",
                "iam",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) {
        write!(output, "/").expect("formatting should succeed")
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri);
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let builder = http::request::Builder::new();
        let builder = builder.header("Content-Type", "application/x-www-form-urlencoded");
        self.update_http_builder(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`AddUserToGroupInput`](crate::input::AddUserToGroupInput)
    pub fn builder() -> crate::input::add_user_to_group_input::Builder {
        crate::input::add_user_to_group_input::Builder::default()
    }
}

/// See [`AttachGroupPolicyInput`](crate::input::AttachGroupPolicyInput)
pub mod attach_group_policy_input {
    /// A builder for [`AttachGroupPolicyInput`](crate::input::AttachGroupPolicyInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) group_name: std::option::Option<std::string::String>,
        pub(crate) policy_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name (friendly name, not ARN) of the group to attach the policy to.</p>
        /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
        /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
        pub fn group_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.group_name = Some(inp.into());
            self
        }
        pub fn set_group_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.group_name = inp;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the IAM policy you want to attach.</p>
        /// <p>For more information about ARNs, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">Amazon Resource Names (ARNs)</a> in the <i>AWS General Reference</i>.</p>
        pub fn policy_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.policy_arn = Some(inp.into());
            self
        }
        pub fn set_policy_arn(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.policy_arn = inp;
            self
        }
        /// Consumes the builder and constructs a [`AttachGroupPolicyInput`](crate::input::AttachGroupPolicyInput)
        pub fn build(
            self,
        ) -> Result<crate::input::AttachGroupPolicyInput, smithy_http::operation::BuildError>
        {
            Ok(crate::input::AttachGroupPolicyInput {
                group_name: self.group_name,
                policy_arn: self.policy_arn,
            })
        }
    }
}
#[doc(hidden)]
pub type AttachGroupPolicyInputOperationOutputAlias = crate::operation::AttachGroupPolicy;
#[doc(hidden)]
pub type AttachGroupPolicyInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl AttachGroupPolicyInput {
    /// Consumes the builder and constructs an Operation<[`AttachGroupPolicy`](crate::operation::AttachGroupPolicy)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> Result<
        smithy_http::operation::Operation<
            crate::operation::AttachGroupPolicy,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = crate::operation_ser::serialize_operation_attach_group_policy(&self)
                .map_err(|err| {
                    smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::AttachGroupPolicy::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "AttachGroupPolicy",
                "iam",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) {
        write!(output, "/").expect("formatting should succeed")
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri);
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let builder = http::request::Builder::new();
        let builder = builder.header("Content-Type", "application/x-www-form-urlencoded");
        self.update_http_builder(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`AttachGroupPolicyInput`](crate::input::AttachGroupPolicyInput)
    pub fn builder() -> crate::input::attach_group_policy_input::Builder {
        crate::input::attach_group_policy_input::Builder::default()
    }
}

/// See [`AttachRolePolicyInput`](crate::input::AttachRolePolicyInput)
pub mod attach_role_policy_input {
    /// A builder for [`AttachRolePolicyInput`](crate::input::AttachRolePolicyInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) role_name: std::option::Option<std::string::String>,
        pub(crate) policy_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name (friendly name, not ARN) of the role to attach the policy to.</p>
        /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
        /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
        pub fn role_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.role_name = Some(inp.into());
            self
        }
        pub fn set_role_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.role_name = inp;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the IAM policy you want to attach.</p>
        /// <p>For more information about ARNs, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">Amazon Resource Names (ARNs)</a> in the <i>AWS General Reference</i>.</p>
        pub fn policy_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.policy_arn = Some(inp.into());
            self
        }
        pub fn set_policy_arn(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.policy_arn = inp;
            self
        }
        /// Consumes the builder and constructs a [`AttachRolePolicyInput`](crate::input::AttachRolePolicyInput)
        pub fn build(
            self,
        ) -> Result<crate::input::AttachRolePolicyInput, smithy_http::operation::BuildError>
        {
            Ok(crate::input::AttachRolePolicyInput {
                role_name: self.role_name,
                policy_arn: self.policy_arn,
            })
        }
    }
}
#[doc(hidden)]
pub type AttachRolePolicyInputOperationOutputAlias = crate::operation::AttachRolePolicy;
#[doc(hidden)]
pub type AttachRolePolicyInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl AttachRolePolicyInput {
    /// Consumes the builder and constructs an Operation<[`AttachRolePolicy`](crate::operation::AttachRolePolicy)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> Result<
        smithy_http::operation::Operation<
            crate::operation::AttachRolePolicy,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = crate::operation_ser::serialize_operation_attach_role_policy(&self)
                .map_err(|err| {
                    smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::AttachRolePolicy::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "AttachRolePolicy",
                "iam",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) {
        write!(output, "/").expect("formatting should succeed")
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri);
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let builder = http::request::Builder::new();
        let builder = builder.header("Content-Type", "application/x-www-form-urlencoded");
        self.update_http_builder(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`AttachRolePolicyInput`](crate::input::AttachRolePolicyInput)
    pub fn builder() -> crate::input::attach_role_policy_input::Builder {
        crate::input::attach_role_policy_input::Builder::default()
    }
}

/// See [`AttachUserPolicyInput`](crate::input::AttachUserPolicyInput)
pub mod attach_user_policy_input {
    /// A builder for [`AttachUserPolicyInput`](crate::input::AttachUserPolicyInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) user_name: std::option::Option<std::string::String>,
        pub(crate) policy_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name (friendly name, not ARN) of the IAM user to attach the policy to.</p>
        /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
        /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
        pub fn user_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.user_name = Some(inp.into());
            self
        }
        pub fn set_user_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.user_name = inp;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the IAM policy you want to attach.</p>
        /// <p>For more information about ARNs, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">Amazon Resource Names (ARNs)</a> in the <i>AWS General Reference</i>.</p>
        pub fn policy_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.policy_arn = Some(inp.into());
            self
        }
        pub fn set_policy_arn(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.policy_arn = inp;
            self
        }
        /// Consumes the builder and constructs a [`AttachUserPolicyInput`](crate::input::AttachUserPolicyInput)
        pub fn build(
            self,
        ) -> Result<crate::input::AttachUserPolicyInput, smithy_http::operation::BuildError>
        {
            Ok(crate::input::AttachUserPolicyInput {
                user_name: self.user_name,
                policy_arn: self.policy_arn,
            })
        }
    }
}
#[doc(hidden)]
pub type AttachUserPolicyInputOperationOutputAlias = crate::operation::AttachUserPolicy;
#[doc(hidden)]
pub type AttachUserPolicyInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl AttachUserPolicyInput {
    /// Consumes the builder and constructs an Operation<[`AttachUserPolicy`](crate::operation::AttachUserPolicy)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> Result<
        smithy_http::operation::Operation<
            crate::operation::AttachUserPolicy,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = crate::operation_ser::serialize_operation_attach_user_policy(&self)
                .map_err(|err| {
                    smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::AttachUserPolicy::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "AttachUserPolicy",
                "iam",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) {
        write!(output, "/").expect("formatting should succeed")
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri);
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let builder = http::request::Builder::new();
        let builder = builder.header("Content-Type", "application/x-www-form-urlencoded");
        self.update_http_builder(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`AttachUserPolicyInput`](crate::input::AttachUserPolicyInput)
    pub fn builder() -> crate::input::attach_user_policy_input::Builder {
        crate::input::attach_user_policy_input::Builder::default()
    }
}

/// See [`ChangePasswordInput`](crate::input::ChangePasswordInput)
pub mod change_password_input {
    /// A builder for [`ChangePasswordInput`](crate::input::ChangePasswordInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) old_password: std::option::Option<std::string::String>,
        pub(crate) new_password: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The IAM user's current password.</p>
        pub fn old_password(mut self, inp: impl Into<std::string::String>) -> Self {
            self.old_password = Some(inp.into());
            self
        }
        pub fn set_old_password(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.old_password = inp;
            self
        }
        /// <p>The new password. The new password must conform to the AWS account's password
        /// policy, if one exists.</p>
        /// <p>The <a href="http://wikipedia.org/wiki/regex">regex pattern</a>
        /// that is used to validate this parameter is a string of characters. That string can include almost any printable
        /// ASCII character from the space (<code>\u0020</code>) through the end of the ASCII character range (<code>\u00FF</code>).
        /// You can also include the tab (<code>\u0009</code>), line feed (<code>\u000A</code>), and carriage return (<code>\u000D</code>)
        /// characters. Any of these characters are valid in a password. However, many tools, such
        /// as the AWS Management Console, might restrict the ability to type certain characters because they have
        /// special meaning within that tool.</p>
        pub fn new_password(mut self, inp: impl Into<std::string::String>) -> Self {
            self.new_password = Some(inp.into());
            self
        }
        pub fn set_new_password(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.new_password = inp;
            self
        }
        /// Consumes the builder and constructs a [`ChangePasswordInput`](crate::input::ChangePasswordInput)
        pub fn build(
            self,
        ) -> Result<crate::input::ChangePasswordInput, smithy_http::operation::BuildError> {
            Ok(crate::input::ChangePasswordInput {
                old_password: self.old_password,
                new_password: self.new_password,
            })
        }
    }
}
#[doc(hidden)]
pub type ChangePasswordInputOperationOutputAlias = crate::operation::ChangePassword;
#[doc(hidden)]
pub type ChangePasswordInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl ChangePasswordInput {
    /// Consumes the builder and constructs an Operation<[`ChangePassword`](crate::operation::ChangePassword)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> Result<
        smithy_http::operation::Operation<
            crate::operation::ChangePassword,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = crate::operation_ser::serialize_operation_change_password(&self).map_err(
                |err| smithy_http::operation::BuildError::SerializationError(err.into()),
            )?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::ChangePassword::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "ChangePassword",
                "iam",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) {
        write!(output, "/").expect("formatting should succeed")
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri);
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let builder = http::request::Builder::new();
        let builder = builder.header("Content-Type", "application/x-www-form-urlencoded");
        self.update_http_builder(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`ChangePasswordInput`](crate::input::ChangePasswordInput)
    pub fn builder() -> crate::input::change_password_input::Builder {
        crate::input::change_password_input::Builder::default()
    }
}

/// See [`CreateAccessKeyInput`](crate::input::CreateAccessKeyInput)
pub mod create_access_key_input {
    /// A builder for [`CreateAccessKeyInput`](crate::input::CreateAccessKeyInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) user_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the IAM user that the new key will belong to.</p>
        /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
        /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
        pub fn user_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.user_name = Some(inp.into());
            self
        }
        pub fn set_user_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.user_name = inp;
            self
        }
        /// Consumes the builder and constructs a [`CreateAccessKeyInput`](crate::input::CreateAccessKeyInput)
        pub fn build(
            self,
        ) -> Result<crate::input::CreateAccessKeyInput, smithy_http::operation::BuildError>
        {
            Ok(crate::input::CreateAccessKeyInput {
                user_name: self.user_name,
            })
        }
    }
}
#[doc(hidden)]
pub type CreateAccessKeyInputOperationOutputAlias = crate::operation::CreateAccessKey;
#[doc(hidden)]
pub type CreateAccessKeyInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl CreateAccessKeyInput {
    /// Consumes the builder and constructs an Operation<[`CreateAccessKey`](crate::operation::CreateAccessKey)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> Result<
        smithy_http::operation::Operation<
            crate::operation::CreateAccessKey,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = crate::operation_ser::serialize_operation_create_access_key(&self).map_err(
                |err| smithy_http::operation::BuildError::SerializationError(err.into()),
            )?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::CreateAccessKey::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "CreateAccessKey",
                "iam",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) {
        write!(output, "/").expect("formatting should succeed")
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri);
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let builder = http::request::Builder::new();
        let builder = builder.header("Content-Type", "application/x-www-form-urlencoded");
        self.update_http_builder(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`CreateAccessKeyInput`](crate::input::CreateAccessKeyInput)
    pub fn builder() -> crate::input::create_access_key_input::Builder {
        crate::input::create_access_key_input::Builder::default()
    }
}

/// See [`CreateAccountAliasInput`](crate::input::CreateAccountAliasInput)
pub mod create_account_alias_input {
    /// A builder for [`CreateAccountAliasInput`](crate::input::CreateAccountAliasInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) account_alias: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The account alias to create.</p>
        /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of
        /// lowercase letters, digits, and dashes. You cannot start or finish with a dash, nor can you have
        /// two dashes in a row.</p>
        pub fn account_alias(mut self, inp: impl Into<std::string::String>) -> Self {
            self.account_alias = Some(inp.into());
            self
        }
        pub fn set_account_alias(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.account_alias = inp;
            self
        }
        /// Consumes the builder and constructs a [`CreateAccountAliasInput`](crate::input::CreateAccountAliasInput)
        pub fn build(
            self,
        ) -> Result<crate::input::CreateAccountAliasInput, smithy_http::operation::BuildError>
        {
            Ok(crate::input::CreateAccountAliasInput {
                account_alias: self.account_alias,
            })
        }
    }
}
#[doc(hidden)]
pub type CreateAccountAliasInputOperationOutputAlias = crate::operation::CreateAccountAlias;
#[doc(hidden)]
pub type CreateAccountAliasInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl CreateAccountAliasInput {
    /// Consumes the builder and constructs an Operation<[`CreateAccountAlias`](crate::operation::CreateAccountAlias)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> Result<
        smithy_http::operation::Operation<
            crate::operation::CreateAccountAlias,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = crate::operation_ser::serialize_operation_create_account_alias(&self)
                .map_err(|err| {
                    smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::CreateAccountAlias::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "CreateAccountAlias",
                "iam",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) {
        write!(output, "/").expect("formatting should succeed")
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri);
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let builder = http::request::Builder::new();
        let builder = builder.header("Content-Type", "application/x-www-form-urlencoded");
        self.update_http_builder(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`CreateAccountAliasInput`](crate::input::CreateAccountAliasInput)
    pub fn builder() -> crate::input::create_account_alias_input::Builder {
        crate::input::create_account_alias_input::Builder::default()
    }
}

/// See [`CreateGroupInput`](crate::input::CreateGroupInput)
pub mod create_group_input {
    /// A builder for [`CreateGroupInput`](crate::input::CreateGroupInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) path: std::option::Option<std::string::String>,
        pub(crate) group_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p> The path to the group. For more information about paths, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html">IAM
        /// identifiers</a> in the <i>IAM User Guide</i>.</p>
        /// <p>This parameter is optional. If it is not included, it defaults to a slash (/).</p>
        /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting
        /// of either a forward slash (/) by itself or a string that must begin and end with forward slashes.
        /// In addition, it can contain any ASCII character from the ! (<code>\u0021</code>) through the DEL character (<code>\u007F</code>), including
        /// most punctuation characters, digits, and upper and lowercased letters.</p>
        pub fn path(mut self, inp: impl Into<std::string::String>) -> Self {
            self.path = Some(inp.into());
            self
        }
        pub fn set_path(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.path = inp;
            self
        }
        /// <p>The name of the group to create. Do not include the path in this value.</p>
        /// <p>IAM user, group, role, and policy names must be unique within the account. Names are
        /// not distinguished by case. For example, you cannot create resources named both
        /// "MyResource" and "myresource".</p>
        pub fn group_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.group_name = Some(inp.into());
            self
        }
        pub fn set_group_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.group_name = inp;
            self
        }
        /// Consumes the builder and constructs a [`CreateGroupInput`](crate::input::CreateGroupInput)
        pub fn build(
            self,
        ) -> Result<crate::input::CreateGroupInput, smithy_http::operation::BuildError> {
            Ok(crate::input::CreateGroupInput {
                path: self.path,
                group_name: self.group_name,
            })
        }
    }
}
#[doc(hidden)]
pub type CreateGroupInputOperationOutputAlias = crate::operation::CreateGroup;
#[doc(hidden)]
pub type CreateGroupInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl CreateGroupInput {
    /// Consumes the builder and constructs an Operation<[`CreateGroup`](crate::operation::CreateGroup)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> Result<
        smithy_http::operation::Operation<
            crate::operation::CreateGroup,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body =
                crate::operation_ser::serialize_operation_create_group(&self).map_err(|err| {
                    smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::CreateGroup::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new("CreateGroup", "iam"));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) {
        write!(output, "/").expect("formatting should succeed")
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri);
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let builder = http::request::Builder::new();
        let builder = builder.header("Content-Type", "application/x-www-form-urlencoded");
        self.update_http_builder(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`CreateGroupInput`](crate::input::CreateGroupInput)
    pub fn builder() -> crate::input::create_group_input::Builder {
        crate::input::create_group_input::Builder::default()
    }
}

/// See [`CreateInstanceProfileInput`](crate::input::CreateInstanceProfileInput)
pub mod create_instance_profile_input {
    /// A builder for [`CreateInstanceProfileInput`](crate::input::CreateInstanceProfileInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) instance_profile_name: std::option::Option<std::string::String>,
        pub(crate) path: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    }
    impl Builder {
        /// <p>The name of the instance profile to create.</p>
        /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
        /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
        pub fn instance_profile_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.instance_profile_name = Some(inp.into());
            self
        }
        pub fn set_instance_profile_name(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.instance_profile_name = inp;
            self
        }
        /// <p> The path to the instance profile. For more information about paths, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html">IAM
        /// Identifiers</a> in the <i>IAM User Guide</i>.</p>
        /// <p>This parameter is optional. If it is not included, it defaults to a slash (/).</p>
        /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting
        /// of either a forward slash (/) by itself or a string that must begin and end with forward slashes.
        /// In addition, it can contain any ASCII character from the ! (<code>\u0021</code>) through the DEL character (<code>\u007F</code>), including
        /// most punctuation characters, digits, and upper and lowercased letters.</p>
        pub fn path(mut self, inp: impl Into<std::string::String>) -> Self {
            self.path = Some(inp.into());
            self
        }
        pub fn set_path(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.path = inp;
            self
        }
        pub fn tags(mut self, inp: impl Into<crate::model::Tag>) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(inp.into());
            self.tags = Some(v);
            self
        }
        pub fn set_tags(
            mut self,
            inp: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = inp;
            self
        }
        /// Consumes the builder and constructs a [`CreateInstanceProfileInput`](crate::input::CreateInstanceProfileInput)
        pub fn build(
            self,
        ) -> Result<crate::input::CreateInstanceProfileInput, smithy_http::operation::BuildError>
        {
            Ok(crate::input::CreateInstanceProfileInput {
                instance_profile_name: self.instance_profile_name,
                path: self.path,
                tags: self.tags,
            })
        }
    }
}
#[doc(hidden)]
pub type CreateInstanceProfileInputOperationOutputAlias = crate::operation::CreateInstanceProfile;
#[doc(hidden)]
pub type CreateInstanceProfileInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl CreateInstanceProfileInput {
    /// Consumes the builder and constructs an Operation<[`CreateInstanceProfile`](crate::operation::CreateInstanceProfile)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> Result<
        smithy_http::operation::Operation<
            crate::operation::CreateInstanceProfile,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = crate::operation_ser::serialize_operation_create_instance_profile(&self)
                .map_err(|err| {
                    smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::CreateInstanceProfile::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "CreateInstanceProfile",
                "iam",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) {
        write!(output, "/").expect("formatting should succeed")
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri);
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let builder = http::request::Builder::new();
        let builder = builder.header("Content-Type", "application/x-www-form-urlencoded");
        self.update_http_builder(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`CreateInstanceProfileInput`](crate::input::CreateInstanceProfileInput)
    pub fn builder() -> crate::input::create_instance_profile_input::Builder {
        crate::input::create_instance_profile_input::Builder::default()
    }
}

/// See [`CreateLoginProfileInput`](crate::input::CreateLoginProfileInput)
pub mod create_login_profile_input {
    /// A builder for [`CreateLoginProfileInput`](crate::input::CreateLoginProfileInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) user_name: std::option::Option<std::string::String>,
        pub(crate) password: std::option::Option<std::string::String>,
        pub(crate) password_reset_required: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>The name of the IAM user to create a password for. The user must already
        /// exist.</p>
        /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
        /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
        pub fn user_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.user_name = Some(inp.into());
            self
        }
        pub fn set_user_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.user_name = inp;
            self
        }
        /// <p>The new password for the user.</p>
        /// <p>The <a href="http://wikipedia.org/wiki/regex">regex pattern</a>
        /// that is used to validate this parameter is a string of characters. That string can include almost any printable
        /// ASCII character from the space (<code>\u0020</code>) through the end of the ASCII character range (<code>\u00FF</code>).
        /// You can also include the tab (<code>\u0009</code>), line feed (<code>\u000A</code>), and carriage return (<code>\u000D</code>)
        /// characters. Any of these characters are valid in a password. However, many tools, such
        /// as the AWS Management Console, might restrict the ability to type certain characters because they have
        /// special meaning within that tool.</p>
        pub fn password(mut self, inp: impl Into<std::string::String>) -> Self {
            self.password = Some(inp.into());
            self
        }
        pub fn set_password(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.password = inp;
            self
        }
        /// <p>Specifies whether the user is required to set a new password on next sign-in.</p>
        pub fn password_reset_required(mut self, inp: bool) -> Self {
            self.password_reset_required = Some(inp);
            self
        }
        pub fn set_password_reset_required(mut self, inp: bool) -> Self {
            self.password_reset_required = Some(inp);
            self
        }
        /// Consumes the builder and constructs a [`CreateLoginProfileInput`](crate::input::CreateLoginProfileInput)
        pub fn build(
            self,
        ) -> Result<crate::input::CreateLoginProfileInput, smithy_http::operation::BuildError>
        {
            Ok(crate::input::CreateLoginProfileInput {
                user_name: self.user_name,
                password: self.password,
                password_reset_required: self.password_reset_required.unwrap_or_default(),
            })
        }
    }
}
#[doc(hidden)]
pub type CreateLoginProfileInputOperationOutputAlias = crate::operation::CreateLoginProfile;
#[doc(hidden)]
pub type CreateLoginProfileInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl CreateLoginProfileInput {
    /// Consumes the builder and constructs an Operation<[`CreateLoginProfile`](crate::operation::CreateLoginProfile)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> Result<
        smithy_http::operation::Operation<
            crate::operation::CreateLoginProfile,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = crate::operation_ser::serialize_operation_create_login_profile(&self)
                .map_err(|err| {
                    smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::CreateLoginProfile::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "CreateLoginProfile",
                "iam",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) {
        write!(output, "/").expect("formatting should succeed")
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri);
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let builder = http::request::Builder::new();
        let builder = builder.header("Content-Type", "application/x-www-form-urlencoded");
        self.update_http_builder(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`CreateLoginProfileInput`](crate::input::CreateLoginProfileInput)
    pub fn builder() -> crate::input::create_login_profile_input::Builder {
        crate::input::create_login_profile_input::Builder::default()
    }
}

/// See [`CreateOpenIDConnectProviderInput`](crate::input::CreateOpenIDConnectProviderInput)
pub mod create_open_id_connect_provider_input {
    /// A builder for [`CreateOpenIDConnectProviderInput`](crate::input::CreateOpenIDConnectProviderInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) url: std::option::Option<std::string::String>,
        pub(crate) client_id_list: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) thumbprint_list: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    }
    impl Builder {
        /// <p>The URL of the identity provider. The URL must begin with <code>https://</code> and
        /// should correspond to the <code>iss</code> claim in the provider's OpenID Connect ID
        /// tokens. Per the OIDC standard, path components are allowed but query parameters are not.
        /// Typically the URL consists of only a hostname, like
        /// <code>https://server.example.org</code> or <code>https://example.com</code>.</p>
        /// <p>You cannot register the same provider multiple times in a single AWS account. If you
        /// try to submit a URL that has already been used for an OpenID Connect provider in the
        /// AWS account, you will get an error.</p>
        pub fn url(mut self, inp: impl Into<std::string::String>) -> Self {
            self.url = Some(inp.into());
            self
        }
        pub fn set_url(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.url = inp;
            self
        }
        pub fn client_id_list(mut self, inp: impl Into<std::string::String>) -> Self {
            let mut v = self.client_id_list.unwrap_or_default();
            v.push(inp.into());
            self.client_id_list = Some(v);
            self
        }
        pub fn set_client_id_list(
            mut self,
            inp: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.client_id_list = inp;
            self
        }
        pub fn thumbprint_list(mut self, inp: impl Into<std::string::String>) -> Self {
            let mut v = self.thumbprint_list.unwrap_or_default();
            v.push(inp.into());
            self.thumbprint_list = Some(v);
            self
        }
        pub fn set_thumbprint_list(
            mut self,
            inp: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.thumbprint_list = inp;
            self
        }
        pub fn tags(mut self, inp: impl Into<crate::model::Tag>) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(inp.into());
            self.tags = Some(v);
            self
        }
        pub fn set_tags(
            mut self,
            inp: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = inp;
            self
        }
        /// Consumes the builder and constructs a [`CreateOpenIDConnectProviderInput`](crate::input::CreateOpenIDConnectProviderInput)
        pub fn build(
            self,
        ) -> Result<
            crate::input::CreateOpenIDConnectProviderInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::CreateOpenIDConnectProviderInput {
                url: self.url,
                client_id_list: self.client_id_list,
                thumbprint_list: self.thumbprint_list,
                tags: self.tags,
            })
        }
    }
}
#[doc(hidden)]
pub type CreateOpenIDConnectProviderInputOperationOutputAlias =
    crate::operation::CreateOpenIDConnectProvider;
#[doc(hidden)]
pub type CreateOpenIDConnectProviderInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl CreateOpenIDConnectProviderInput {
    /// Consumes the builder and constructs an Operation<[`CreateOpenIDConnectProvider`](crate::operation::CreateOpenIDConnectProvider)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> Result<
        smithy_http::operation::Operation<
            crate::operation::CreateOpenIDConnectProvider,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body =
                crate::operation_ser::serialize_operation_create_open_id_connect_provider(&self)
                    .map_err(|err| {
                        smithy_http::operation::BuildError::SerializationError(err.into())
                    })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::CreateOpenIDConnectProvider::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "CreateOpenIDConnectProvider",
                "iam",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) {
        write!(output, "/").expect("formatting should succeed")
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri);
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let builder = http::request::Builder::new();
        let builder = builder.header("Content-Type", "application/x-www-form-urlencoded");
        self.update_http_builder(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`CreateOpenIDConnectProviderInput`](crate::input::CreateOpenIDConnectProviderInput)
    pub fn builder() -> crate::input::create_open_id_connect_provider_input::Builder {
        crate::input::create_open_id_connect_provider_input::Builder::default()
    }
}

/// See [`CreatePolicyInput`](crate::input::CreatePolicyInput)
pub mod create_policy_input {
    /// A builder for [`CreatePolicyInput`](crate::input::CreatePolicyInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) policy_name: std::option::Option<std::string::String>,
        pub(crate) path: std::option::Option<std::string::String>,
        pub(crate) policy_document: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    }
    impl Builder {
        /// <p>The friendly name of the policy.</p>
        /// <p>IAM user, group, role, and policy names must be unique within the account. Names are
        /// not distinguished by case. For example, you cannot create resources named both
        /// "MyResource" and "myresource".</p>
        pub fn policy_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.policy_name = Some(inp.into());
            self
        }
        pub fn set_policy_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.policy_name = inp;
            self
        }
        /// <p>The path for the policy.</p>
        /// <p>For more information about paths, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html">IAM identifiers</a> in the
        /// <i>IAM User Guide</i>.</p>
        /// <p>This parameter is optional. If it is not included, it defaults to a slash (/).</p>
        /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting
        /// of either a forward slash (/) by itself or a string that must begin and end with forward slashes.
        /// In addition, it can contain any ASCII character from the ! (<code>\u0021</code>) through the DEL character (<code>\u007F</code>), including
        /// most punctuation characters, digits, and upper and lowercased letters.</p>
        pub fn path(mut self, inp: impl Into<std::string::String>) -> Self {
            self.path = Some(inp.into());
            self
        }
        pub fn set_path(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.path = inp;
            self
        }
        /// <p>The JSON policy document that you want to use as the content for the new
        /// policy.</p>
        /// <p>You must provide policies in JSON format in IAM. However, for AWS CloudFormation
        /// templates formatted in YAML, you can provide the policy in JSON or YAML format. AWS
        /// CloudFormation always converts a YAML policy to JSON format before submitting it to
        /// IAM.</p>
        /// <p>To learn more about JSON policy grammar, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_policies_grammar.html">Grammar of the IAM JSON policy language</a> in the
        /// <i>IAM User Guide</i>. </p>
        /// <p>The <a href="http://wikipedia.org/wiki/regex">regex pattern</a>
        /// used to validate this parameter is a string of characters consisting of the following:</p>
        /// <ul>
        /// <li>
        /// <p>Any printable ASCII
        /// character ranging from the space character (<code>\u0020</code>) through the end of the ASCII character range</p>
        /// </li>
        /// <li>
        /// <p>The printable characters in the Basic Latin and  Latin-1 Supplement character set
        /// (through <code>\u00FF</code>)</p>
        /// </li>
        /// <li>
        /// <p>The special characters tab (<code>\u0009</code>), line feed (<code>\u000A</code>), and
        /// carriage return (<code>\u000D</code>)</p>
        /// </li>
        /// </ul>
        pub fn policy_document(mut self, inp: impl Into<std::string::String>) -> Self {
            self.policy_document = Some(inp.into());
            self
        }
        pub fn set_policy_document(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.policy_document = inp;
            self
        }
        /// <p>A friendly description of the policy.</p>
        /// <p>Typically used to store information about the permissions defined in the policy. For
        /// example, "Grants access to production DynamoDB tables."</p>
        /// <p>The policy description is immutable. After a value is assigned, it cannot be
        /// changed.</p>
        pub fn description(mut self, inp: impl Into<std::string::String>) -> Self {
            self.description = Some(inp.into());
            self
        }
        pub fn set_description(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.description = inp;
            self
        }
        pub fn tags(mut self, inp: impl Into<crate::model::Tag>) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(inp.into());
            self.tags = Some(v);
            self
        }
        pub fn set_tags(
            mut self,
            inp: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = inp;
            self
        }
        /// Consumes the builder and constructs a [`CreatePolicyInput`](crate::input::CreatePolicyInput)
        pub fn build(
            self,
        ) -> Result<crate::input::CreatePolicyInput, smithy_http::operation::BuildError> {
            Ok(crate::input::CreatePolicyInput {
                policy_name: self.policy_name,
                path: self.path,
                policy_document: self.policy_document,
                description: self.description,
                tags: self.tags,
            })
        }
    }
}
#[doc(hidden)]
pub type CreatePolicyInputOperationOutputAlias = crate::operation::CreatePolicy;
#[doc(hidden)]
pub type CreatePolicyInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl CreatePolicyInput {
    /// Consumes the builder and constructs an Operation<[`CreatePolicy`](crate::operation::CreatePolicy)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> Result<
        smithy_http::operation::Operation<
            crate::operation::CreatePolicy,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body =
                crate::operation_ser::serialize_operation_create_policy(&self).map_err(|err| {
                    smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::CreatePolicy::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new("CreatePolicy", "iam"));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) {
        write!(output, "/").expect("formatting should succeed")
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri);
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let builder = http::request::Builder::new();
        let builder = builder.header("Content-Type", "application/x-www-form-urlencoded");
        self.update_http_builder(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`CreatePolicyInput`](crate::input::CreatePolicyInput)
    pub fn builder() -> crate::input::create_policy_input::Builder {
        crate::input::create_policy_input::Builder::default()
    }
}

/// See [`CreatePolicyVersionInput`](crate::input::CreatePolicyVersionInput)
pub mod create_policy_version_input {
    /// A builder for [`CreatePolicyVersionInput`](crate::input::CreatePolicyVersionInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) policy_arn: std::option::Option<std::string::String>,
        pub(crate) policy_document: std::option::Option<std::string::String>,
        pub(crate) set_as_default: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the IAM policy to which you want to add a new
        /// version.</p>
        /// <p>For more information about ARNs, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">Amazon Resource Names (ARNs)</a> in the <i>AWS General Reference</i>.</p>
        pub fn policy_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.policy_arn = Some(inp.into());
            self
        }
        pub fn set_policy_arn(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.policy_arn = inp;
            self
        }
        /// <p>The JSON policy document that you want to use as the content for this new version of
        /// the policy.</p>
        /// <p>You must provide policies in JSON format in IAM. However, for AWS CloudFormation
        /// templates formatted in YAML, you can provide the policy in JSON or YAML format. AWS
        /// CloudFormation always converts a YAML policy to JSON format before submitting it to
        /// IAM.</p>
        /// <p>The <a href="http://wikipedia.org/wiki/regex">regex pattern</a>
        /// used to validate this parameter is a string of characters consisting of the following:</p>
        /// <ul>
        /// <li>
        /// <p>Any printable ASCII
        /// character ranging from the space character (<code>\u0020</code>) through the end of the ASCII character range</p>
        /// </li>
        /// <li>
        /// <p>The printable characters in the Basic Latin and  Latin-1 Supplement character set
        /// (through <code>\u00FF</code>)</p>
        /// </li>
        /// <li>
        /// <p>The special characters tab (<code>\u0009</code>), line feed (<code>\u000A</code>), and
        /// carriage return (<code>\u000D</code>)</p>
        /// </li>
        /// </ul>
        pub fn policy_document(mut self, inp: impl Into<std::string::String>) -> Self {
            self.policy_document = Some(inp.into());
            self
        }
        pub fn set_policy_document(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.policy_document = inp;
            self
        }
        /// <p>Specifies whether to set this version as the policy's default version.</p>
        /// <p>When this parameter is <code>true</code>, the new policy version becomes the operative
        /// version. That is, it becomes the version that is in effect for the IAM users, groups,
        /// and roles that the policy is attached to.</p>
        /// <p>For more information about managed policy versions, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/policies-managed-versions.html">Versioning for managed
        /// policies</a> in the <i>IAM User Guide</i>.</p>
        pub fn set_as_default(mut self, inp: bool) -> Self {
            self.set_as_default = Some(inp);
            self
        }
        pub fn set_set_as_default(mut self, inp: bool) -> Self {
            self.set_as_default = Some(inp);
            self
        }
        /// Consumes the builder and constructs a [`CreatePolicyVersionInput`](crate::input::CreatePolicyVersionInput)
        pub fn build(
            self,
        ) -> Result<crate::input::CreatePolicyVersionInput, smithy_http::operation::BuildError>
        {
            Ok(crate::input::CreatePolicyVersionInput {
                policy_arn: self.policy_arn,
                policy_document: self.policy_document,
                set_as_default: self.set_as_default.unwrap_or_default(),
            })
        }
    }
}
#[doc(hidden)]
pub type CreatePolicyVersionInputOperationOutputAlias = crate::operation::CreatePolicyVersion;
#[doc(hidden)]
pub type CreatePolicyVersionInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl CreatePolicyVersionInput {
    /// Consumes the builder and constructs an Operation<[`CreatePolicyVersion`](crate::operation::CreatePolicyVersion)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> Result<
        smithy_http::operation::Operation<
            crate::operation::CreatePolicyVersion,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = crate::operation_ser::serialize_operation_create_policy_version(&self)
                .map_err(|err| {
                    smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::CreatePolicyVersion::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "CreatePolicyVersion",
                "iam",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) {
        write!(output, "/").expect("formatting should succeed")
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri);
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let builder = http::request::Builder::new();
        let builder = builder.header("Content-Type", "application/x-www-form-urlencoded");
        self.update_http_builder(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`CreatePolicyVersionInput`](crate::input::CreatePolicyVersionInput)
    pub fn builder() -> crate::input::create_policy_version_input::Builder {
        crate::input::create_policy_version_input::Builder::default()
    }
}

/// See [`CreateRoleInput`](crate::input::CreateRoleInput)
pub mod create_role_input {
    /// A builder for [`CreateRoleInput`](crate::input::CreateRoleInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) path: std::option::Option<std::string::String>,
        pub(crate) role_name: std::option::Option<std::string::String>,
        pub(crate) assume_role_policy_document: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) max_session_duration: std::option::Option<i32>,
        pub(crate) permissions_boundary: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    }
    impl Builder {
        /// <p> The path to the role. For more information about paths, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html">IAM
        /// Identifiers</a> in the <i>IAM User Guide</i>.</p>
        /// <p>This parameter is optional. If it is not included, it defaults to a slash (/).</p>
        /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting
        /// of either a forward slash (/) by itself or a string that must begin and end with forward slashes.
        /// In addition, it can contain any ASCII character from the ! (<code>\u0021</code>) through the DEL character (<code>\u007F</code>), including
        /// most punctuation characters, digits, and upper and lowercased letters.</p>
        pub fn path(mut self, inp: impl Into<std::string::String>) -> Self {
            self.path = Some(inp.into());
            self
        }
        pub fn set_path(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.path = inp;
            self
        }
        /// <p>The name of the role to create.</p>
        /// <p>IAM user, group, role, and policy names must be unique within the account. Names are
        /// not distinguished by case. For example, you cannot create resources named both
        /// "MyResource" and "myresource".</p>
        pub fn role_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.role_name = Some(inp.into());
            self
        }
        pub fn set_role_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.role_name = inp;
            self
        }
        /// <p>The trust relationship policy document that grants an entity permission to assume the
        /// role.</p>
        /// <p>In IAM, you must provide a JSON policy that has been converted to a string. However,
        /// for AWS CloudFormation templates formatted in YAML, you can provide the policy in JSON
        /// or YAML format. AWS CloudFormation always converts a YAML policy to JSON format before
        /// submitting it to IAM.</p>
        /// <p>The <a href="http://wikipedia.org/wiki/regex">regex pattern</a>
        /// used to validate this parameter is a string of characters consisting of the following:</p>
        /// <ul>
        /// <li>
        /// <p>Any printable ASCII
        /// character ranging from the space character (<code>\u0020</code>) through the end of the ASCII character range</p>
        /// </li>
        /// <li>
        /// <p>The printable characters in the Basic Latin and  Latin-1 Supplement character set
        /// (through <code>\u00FF</code>)</p>
        /// </li>
        /// <li>
        /// <p>The special characters tab (<code>\u0009</code>), line feed (<code>\u000A</code>), and
        /// carriage return (<code>\u000D</code>)</p>
        /// </li>
        /// </ul>
        /// <p> Upon success, the response includes the same trust policy in JSON format.</p>
        pub fn assume_role_policy_document(mut self, inp: impl Into<std::string::String>) -> Self {
            self.assume_role_policy_document = Some(inp.into());
            self
        }
        pub fn set_assume_role_policy_document(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.assume_role_policy_document = inp;
            self
        }
        /// <p>A description of the role.</p>
        pub fn description(mut self, inp: impl Into<std::string::String>) -> Self {
            self.description = Some(inp.into());
            self
        }
        pub fn set_description(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.description = inp;
            self
        }
        /// <p>The maximum session duration (in seconds) that you want to set for the specified role.
        /// If you do not specify a value for this setting, the default maximum of one hour is
        /// applied. This setting can have a value from 1 hour to 12 hours.</p>
        /// <p>Anyone who assumes the role from the AWS CLI or API can use the
        /// <code>DurationSeconds</code> API parameter or the <code>duration-seconds</code> CLI
        /// parameter to request a longer session. The <code>MaxSessionDuration</code> setting
        /// determines the maximum duration that can be requested using the
        /// <code>DurationSeconds</code> parameter. If users don't specify a value for the
        /// <code>DurationSeconds</code> parameter, their security credentials are valid for one
        /// hour by default. This applies when you use the <code>AssumeRole*</code> API operations
        /// or the <code>assume-role*</code> CLI operations but does not apply when you use those
        /// operations to create a console URL. For more information, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_use.html">Using IAM
        /// roles</a> in the <i>IAM User Guide</i>.</p>
        pub fn max_session_duration(mut self, inp: i32) -> Self {
            self.max_session_duration = Some(inp);
            self
        }
        pub fn set_max_session_duration(mut self, inp: std::option::Option<i32>) -> Self {
            self.max_session_duration = inp;
            self
        }
        /// <p>The ARN of the policy that is used to set the permissions boundary for the
        /// role.</p>
        pub fn permissions_boundary(mut self, inp: impl Into<std::string::String>) -> Self {
            self.permissions_boundary = Some(inp.into());
            self
        }
        pub fn set_permissions_boundary(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.permissions_boundary = inp;
            self
        }
        pub fn tags(mut self, inp: impl Into<crate::model::Tag>) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(inp.into());
            self.tags = Some(v);
            self
        }
        pub fn set_tags(
            mut self,
            inp: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = inp;
            self
        }
        /// Consumes the builder and constructs a [`CreateRoleInput`](crate::input::CreateRoleInput)
        pub fn build(
            self,
        ) -> Result<crate::input::CreateRoleInput, smithy_http::operation::BuildError> {
            Ok(crate::input::CreateRoleInput {
                path: self.path,
                role_name: self.role_name,
                assume_role_policy_document: self.assume_role_policy_document,
                description: self.description,
                max_session_duration: self.max_session_duration,
                permissions_boundary: self.permissions_boundary,
                tags: self.tags,
            })
        }
    }
}
#[doc(hidden)]
pub type CreateRoleInputOperationOutputAlias = crate::operation::CreateRole;
#[doc(hidden)]
pub type CreateRoleInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl CreateRoleInput {
    /// Consumes the builder and constructs an Operation<[`CreateRole`](crate::operation::CreateRole)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> Result<
        smithy_http::operation::Operation<
            crate::operation::CreateRole,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body =
                crate::operation_ser::serialize_operation_create_role(&self).map_err(|err| {
                    smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::CreateRole::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new("CreateRole", "iam"));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) {
        write!(output, "/").expect("formatting should succeed")
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri);
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let builder = http::request::Builder::new();
        let builder = builder.header("Content-Type", "application/x-www-form-urlencoded");
        self.update_http_builder(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`CreateRoleInput`](crate::input::CreateRoleInput)
    pub fn builder() -> crate::input::create_role_input::Builder {
        crate::input::create_role_input::Builder::default()
    }
}

/// See [`CreateSAMLProviderInput`](crate::input::CreateSAMLProviderInput)
pub mod create_saml_provider_input {
    /// A builder for [`CreateSAMLProviderInput`](crate::input::CreateSAMLProviderInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) saml_metadata_document: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    }
    impl Builder {
        /// <p>An XML document generated by an identity provider (IdP) that supports SAML 2.0. The
        /// document includes the issuer's name, expiration information, and keys that can be used
        /// to validate the SAML authentication response (assertions) that are received from the
        /// IdP. You must generate the metadata document using the identity management software that
        /// is used as your organization's IdP.</p>
        /// <p>For more information, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_providers_saml.html">About SAML 2.0-based
        /// federation</a> in the <i>IAM User Guide</i>
        /// </p>
        pub fn saml_metadata_document(mut self, inp: impl Into<std::string::String>) -> Self {
            self.saml_metadata_document = Some(inp.into());
            self
        }
        pub fn set_saml_metadata_document(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.saml_metadata_document = inp;
            self
        }
        /// <p>The name of the provider to create.</p>
        /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
        /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
        pub fn name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.name = Some(inp.into());
            self
        }
        pub fn set_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.name = inp;
            self
        }
        pub fn tags(mut self, inp: impl Into<crate::model::Tag>) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(inp.into());
            self.tags = Some(v);
            self
        }
        pub fn set_tags(
            mut self,
            inp: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = inp;
            self
        }
        /// Consumes the builder and constructs a [`CreateSAMLProviderInput`](crate::input::CreateSAMLProviderInput)
        pub fn build(
            self,
        ) -> Result<crate::input::CreateSAMLProviderInput, smithy_http::operation::BuildError>
        {
            Ok(crate::input::CreateSAMLProviderInput {
                saml_metadata_document: self.saml_metadata_document,
                name: self.name,
                tags: self.tags,
            })
        }
    }
}
#[doc(hidden)]
pub type CreateSAMLProviderInputOperationOutputAlias = crate::operation::CreateSAMLProvider;
#[doc(hidden)]
pub type CreateSAMLProviderInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl CreateSAMLProviderInput {
    /// Consumes the builder and constructs an Operation<[`CreateSAMLProvider`](crate::operation::CreateSAMLProvider)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> Result<
        smithy_http::operation::Operation<
            crate::operation::CreateSAMLProvider,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = crate::operation_ser::serialize_operation_create_saml_provider(&self)
                .map_err(|err| {
                    smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::CreateSAMLProvider::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "CreateSAMLProvider",
                "iam",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) {
        write!(output, "/").expect("formatting should succeed")
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri);
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let builder = http::request::Builder::new();
        let builder = builder.header("Content-Type", "application/x-www-form-urlencoded");
        self.update_http_builder(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`CreateSAMLProviderInput`](crate::input::CreateSAMLProviderInput)
    pub fn builder() -> crate::input::create_saml_provider_input::Builder {
        crate::input::create_saml_provider_input::Builder::default()
    }
}

/// See [`CreateServiceLinkedRoleInput`](crate::input::CreateServiceLinkedRoleInput)
pub mod create_service_linked_role_input {
    /// A builder for [`CreateServiceLinkedRoleInput`](crate::input::CreateServiceLinkedRoleInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) aws_service_name: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) custom_suffix: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The service principal for the AWS service to which this role is attached. You use a
        /// string similar to a URL but without the http:// in front. For example:
        /// <code>elasticbeanstalk.amazonaws.com</code>. </p>
        /// <p>Service principals are unique and case-sensitive. To find the exact service principal
        /// for your service-linked role, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_aws-services-that-work-with-iam.html">AWS services
        /// that work with IAM</a> in the <i>IAM User Guide</i>. Look for
        /// the services that have <b>Yes </b>in the <b>Service-Linked Role</b> column. Choose the <b>Yes</b> link to view the service-linked role documentation for that
        /// service.</p>
        pub fn aws_service_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.aws_service_name = Some(inp.into());
            self
        }
        pub fn set_aws_service_name(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.aws_service_name = inp;
            self
        }
        /// <p>The description of the role.</p>
        pub fn description(mut self, inp: impl Into<std::string::String>) -> Self {
            self.description = Some(inp.into());
            self
        }
        pub fn set_description(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.description = inp;
            self
        }
        /// <p></p>
        /// <p>A string that you provide, which is combined with the service-provided prefix to form
        /// the complete role name. If you make multiple requests for the same service, then you
        /// must supply a different <code>CustomSuffix</code> for each request. Otherwise the
        /// request fails with a duplicate role name error. For example, you could add
        /// <code>-1</code> or <code>-debug</code> to the suffix.</p>
        /// <p>Some services do not support the <code>CustomSuffix</code> parameter. If you provide
        /// an optional suffix and the operation fails, try the operation again without the
        /// suffix.</p>
        pub fn custom_suffix(mut self, inp: impl Into<std::string::String>) -> Self {
            self.custom_suffix = Some(inp.into());
            self
        }
        pub fn set_custom_suffix(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.custom_suffix = inp;
            self
        }
        /// Consumes the builder and constructs a [`CreateServiceLinkedRoleInput`](crate::input::CreateServiceLinkedRoleInput)
        pub fn build(
            self,
        ) -> Result<crate::input::CreateServiceLinkedRoleInput, smithy_http::operation::BuildError>
        {
            Ok(crate::input::CreateServiceLinkedRoleInput {
                aws_service_name: self.aws_service_name,
                description: self.description,
                custom_suffix: self.custom_suffix,
            })
        }
    }
}
#[doc(hidden)]
pub type CreateServiceLinkedRoleInputOperationOutputAlias =
    crate::operation::CreateServiceLinkedRole;
#[doc(hidden)]
pub type CreateServiceLinkedRoleInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl CreateServiceLinkedRoleInput {
    /// Consumes the builder and constructs an Operation<[`CreateServiceLinkedRole`](crate::operation::CreateServiceLinkedRole)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> Result<
        smithy_http::operation::Operation<
            crate::operation::CreateServiceLinkedRole,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = crate::operation_ser::serialize_operation_create_service_linked_role(&self)
                .map_err(|err| {
                    smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::CreateServiceLinkedRole::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "CreateServiceLinkedRole",
                "iam",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) {
        write!(output, "/").expect("formatting should succeed")
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri);
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let builder = http::request::Builder::new();
        let builder = builder.header("Content-Type", "application/x-www-form-urlencoded");
        self.update_http_builder(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`CreateServiceLinkedRoleInput`](crate::input::CreateServiceLinkedRoleInput)
    pub fn builder() -> crate::input::create_service_linked_role_input::Builder {
        crate::input::create_service_linked_role_input::Builder::default()
    }
}

/// See [`CreateServiceSpecificCredentialInput`](crate::input::CreateServiceSpecificCredentialInput)
pub mod create_service_specific_credential_input {
    /// A builder for [`CreateServiceSpecificCredentialInput`](crate::input::CreateServiceSpecificCredentialInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) user_name: std::option::Option<std::string::String>,
        pub(crate) service_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the IAM user that is to be associated with the credentials. The new
        /// service-specific credentials have the same permissions as the associated user except
        /// that they can be used only to access the specified service.</p>
        /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
        /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
        pub fn user_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.user_name = Some(inp.into());
            self
        }
        pub fn set_user_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.user_name = inp;
            self
        }
        /// <p>The name of the AWS service that is to be associated with the credentials. The
        /// service you specify here is the only service that can be accessed using these
        /// credentials.</p>
        pub fn service_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.service_name = Some(inp.into());
            self
        }
        pub fn set_service_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.service_name = inp;
            self
        }
        /// Consumes the builder and constructs a [`CreateServiceSpecificCredentialInput`](crate::input::CreateServiceSpecificCredentialInput)
        pub fn build(
            self,
        ) -> Result<
            crate::input::CreateServiceSpecificCredentialInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::CreateServiceSpecificCredentialInput {
                user_name: self.user_name,
                service_name: self.service_name,
            })
        }
    }
}
#[doc(hidden)]
pub type CreateServiceSpecificCredentialInputOperationOutputAlias =
    crate::operation::CreateServiceSpecificCredential;
#[doc(hidden)]
pub type CreateServiceSpecificCredentialInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl CreateServiceSpecificCredentialInput {
    /// Consumes the builder and constructs an Operation<[`CreateServiceSpecificCredential`](crate::operation::CreateServiceSpecificCredential)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> Result<
        smithy_http::operation::Operation<
            crate::operation::CreateServiceSpecificCredential,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body =
                crate::operation_ser::serialize_operation_create_service_specific_credential(&self)
                    .map_err(|err| {
                        smithy_http::operation::BuildError::SerializationError(err.into())
                    })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::CreateServiceSpecificCredential::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "CreateServiceSpecificCredential",
                "iam",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) {
        write!(output, "/").expect("formatting should succeed")
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri);
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let builder = http::request::Builder::new();
        let builder = builder.header("Content-Type", "application/x-www-form-urlencoded");
        self.update_http_builder(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`CreateServiceSpecificCredentialInput`](crate::input::CreateServiceSpecificCredentialInput)
    pub fn builder() -> crate::input::create_service_specific_credential_input::Builder {
        crate::input::create_service_specific_credential_input::Builder::default()
    }
}

/// See [`CreateUserInput`](crate::input::CreateUserInput)
pub mod create_user_input {
    /// A builder for [`CreateUserInput`](crate::input::CreateUserInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) path: std::option::Option<std::string::String>,
        pub(crate) user_name: std::option::Option<std::string::String>,
        pub(crate) permissions_boundary: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    }
    impl Builder {
        /// <p> The path for the user name. For more information about paths, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html">IAM
        /// identifiers</a> in the <i>IAM User Guide</i>.</p>
        /// <p>This parameter is optional. If it is not included, it defaults to a slash (/).</p>
        /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting
        /// of either a forward slash (/) by itself or a string that must begin and end with forward slashes.
        /// In addition, it can contain any ASCII character from the ! (<code>\u0021</code>) through the DEL character (<code>\u007F</code>), including
        /// most punctuation characters, digits, and upper and lowercased letters.</p>
        pub fn path(mut self, inp: impl Into<std::string::String>) -> Self {
            self.path = Some(inp.into());
            self
        }
        pub fn set_path(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.path = inp;
            self
        }
        /// <p>The name of the user to create.</p>
        /// <p>IAM user, group, role, and policy names must be unique within the account. Names are
        /// not distinguished by case. For example, you cannot create resources named both
        /// "MyResource" and "myresource".</p>
        pub fn user_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.user_name = Some(inp.into());
            self
        }
        pub fn set_user_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.user_name = inp;
            self
        }
        /// <p>The ARN of the policy that is used to set the permissions boundary for the
        /// user.</p>
        pub fn permissions_boundary(mut self, inp: impl Into<std::string::String>) -> Self {
            self.permissions_boundary = Some(inp.into());
            self
        }
        pub fn set_permissions_boundary(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.permissions_boundary = inp;
            self
        }
        pub fn tags(mut self, inp: impl Into<crate::model::Tag>) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(inp.into());
            self.tags = Some(v);
            self
        }
        pub fn set_tags(
            mut self,
            inp: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = inp;
            self
        }
        /// Consumes the builder and constructs a [`CreateUserInput`](crate::input::CreateUserInput)
        pub fn build(
            self,
        ) -> Result<crate::input::CreateUserInput, smithy_http::operation::BuildError> {
            Ok(crate::input::CreateUserInput {
                path: self.path,
                user_name: self.user_name,
                permissions_boundary: self.permissions_boundary,
                tags: self.tags,
            })
        }
    }
}
#[doc(hidden)]
pub type CreateUserInputOperationOutputAlias = crate::operation::CreateUser;
#[doc(hidden)]
pub type CreateUserInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl CreateUserInput {
    /// Consumes the builder and constructs an Operation<[`CreateUser`](crate::operation::CreateUser)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> Result<
        smithy_http::operation::Operation<
            crate::operation::CreateUser,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body =
                crate::operation_ser::serialize_operation_create_user(&self).map_err(|err| {
                    smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::CreateUser::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new("CreateUser", "iam"));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) {
        write!(output, "/").expect("formatting should succeed")
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri);
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let builder = http::request::Builder::new();
        let builder = builder.header("Content-Type", "application/x-www-form-urlencoded");
        self.update_http_builder(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`CreateUserInput`](crate::input::CreateUserInput)
    pub fn builder() -> crate::input::create_user_input::Builder {
        crate::input::create_user_input::Builder::default()
    }
}

/// See [`CreateVirtualMFADeviceInput`](crate::input::CreateVirtualMFADeviceInput)
pub mod create_virtual_mfa_device_input {
    /// A builder for [`CreateVirtualMFADeviceInput`](crate::input::CreateVirtualMFADeviceInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) path: std::option::Option<std::string::String>,
        pub(crate) virtual_mfa_device_name: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    }
    impl Builder {
        /// <p> The path for the virtual MFA device. For more information about paths, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html">IAM
        /// identifiers</a> in the <i>IAM User Guide</i>.</p>
        /// <p>This parameter is optional. If it is not included, it defaults to a slash (/).</p>
        /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting
        /// of either a forward slash (/) by itself or a string that must begin and end with forward slashes.
        /// In addition, it can contain any ASCII character from the ! (<code>\u0021</code>) through the DEL character (<code>\u007F</code>), including
        /// most punctuation characters, digits, and upper and lowercased letters.</p>
        pub fn path(mut self, inp: impl Into<std::string::String>) -> Self {
            self.path = Some(inp.into());
            self
        }
        pub fn set_path(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.path = inp;
            self
        }
        /// <p>The name of the virtual MFA device. Use with path to uniquely identify a virtual MFA
        /// device.</p>
        /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
        /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
        pub fn virtual_mfa_device_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.virtual_mfa_device_name = Some(inp.into());
            self
        }
        pub fn set_virtual_mfa_device_name(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.virtual_mfa_device_name = inp;
            self
        }
        pub fn tags(mut self, inp: impl Into<crate::model::Tag>) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(inp.into());
            self.tags = Some(v);
            self
        }
        pub fn set_tags(
            mut self,
            inp: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = inp;
            self
        }
        /// Consumes the builder and constructs a [`CreateVirtualMFADeviceInput`](crate::input::CreateVirtualMFADeviceInput)
        pub fn build(
            self,
        ) -> Result<crate::input::CreateVirtualMFADeviceInput, smithy_http::operation::BuildError>
        {
            Ok(crate::input::CreateVirtualMFADeviceInput {
                path: self.path,
                virtual_mfa_device_name: self.virtual_mfa_device_name,
                tags: self.tags,
            })
        }
    }
}
#[doc(hidden)]
pub type CreateVirtualMFADeviceInputOperationOutputAlias = crate::operation::CreateVirtualMFADevice;
#[doc(hidden)]
pub type CreateVirtualMFADeviceInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl CreateVirtualMFADeviceInput {
    /// Consumes the builder and constructs an Operation<[`CreateVirtualMFADevice`](crate::operation::CreateVirtualMFADevice)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> Result<
        smithy_http::operation::Operation<
            crate::operation::CreateVirtualMFADevice,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = crate::operation_ser::serialize_operation_create_virtual_mfa_device(&self)
                .map_err(|err| {
                smithy_http::operation::BuildError::SerializationError(err.into())
            })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::CreateVirtualMFADevice::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "CreateVirtualMFADevice",
                "iam",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) {
        write!(output, "/").expect("formatting should succeed")
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri);
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let builder = http::request::Builder::new();
        let builder = builder.header("Content-Type", "application/x-www-form-urlencoded");
        self.update_http_builder(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`CreateVirtualMFADeviceInput`](crate::input::CreateVirtualMFADeviceInput)
    pub fn builder() -> crate::input::create_virtual_mfa_device_input::Builder {
        crate::input::create_virtual_mfa_device_input::Builder::default()
    }
}

/// See [`DeactivateMFADeviceInput`](crate::input::DeactivateMFADeviceInput)
pub mod deactivate_mfa_device_input {
    /// A builder for [`DeactivateMFADeviceInput`](crate::input::DeactivateMFADeviceInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) user_name: std::option::Option<std::string::String>,
        pub(crate) serial_number: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the user whose MFA device you want to deactivate.</p>
        /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
        /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
        pub fn user_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.user_name = Some(inp.into());
            self
        }
        pub fn set_user_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.user_name = inp;
            self
        }
        /// <p>The serial number that uniquely identifies the MFA device. For virtual MFA devices,
        /// the serial number is the device ARN.</p>
        /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting
        /// of upper and lowercase alphanumeric characters with no spaces. You can also include any of the
        /// following characters: =,.@:/-</p>
        pub fn serial_number(mut self, inp: impl Into<std::string::String>) -> Self {
            self.serial_number = Some(inp.into());
            self
        }
        pub fn set_serial_number(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.serial_number = inp;
            self
        }
        /// Consumes the builder and constructs a [`DeactivateMFADeviceInput`](crate::input::DeactivateMFADeviceInput)
        pub fn build(
            self,
        ) -> Result<crate::input::DeactivateMFADeviceInput, smithy_http::operation::BuildError>
        {
            Ok(crate::input::DeactivateMFADeviceInput {
                user_name: self.user_name,
                serial_number: self.serial_number,
            })
        }
    }
}
#[doc(hidden)]
pub type DeactivateMFADeviceInputOperationOutputAlias = crate::operation::DeactivateMFADevice;
#[doc(hidden)]
pub type DeactivateMFADeviceInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl DeactivateMFADeviceInput {
    /// Consumes the builder and constructs an Operation<[`DeactivateMFADevice`](crate::operation::DeactivateMFADevice)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> Result<
        smithy_http::operation::Operation<
            crate::operation::DeactivateMFADevice,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = crate::operation_ser::serialize_operation_deactivate_mfa_device(&self)
                .map_err(|err| {
                    smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::DeactivateMFADevice::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "DeactivateMFADevice",
                "iam",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) {
        write!(output, "/").expect("formatting should succeed")
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri);
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let builder = http::request::Builder::new();
        let builder = builder.header("Content-Type", "application/x-www-form-urlencoded");
        self.update_http_builder(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`DeactivateMFADeviceInput`](crate::input::DeactivateMFADeviceInput)
    pub fn builder() -> crate::input::deactivate_mfa_device_input::Builder {
        crate::input::deactivate_mfa_device_input::Builder::default()
    }
}

/// See [`DeleteAccessKeyInput`](crate::input::DeleteAccessKeyInput)
pub mod delete_access_key_input {
    /// A builder for [`DeleteAccessKeyInput`](crate::input::DeleteAccessKeyInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) user_name: std::option::Option<std::string::String>,
        pub(crate) access_key_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the user whose access key pair you want to delete.</p>
        /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
        /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
        pub fn user_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.user_name = Some(inp.into());
            self
        }
        pub fn set_user_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.user_name = inp;
            self
        }
        /// <p>The access key ID for the access key ID and secret access key you want to
        /// delete.</p>
        /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters that can
        /// consist of any upper or lowercased letter or digit.</p>
        pub fn access_key_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.access_key_id = Some(inp.into());
            self
        }
        pub fn set_access_key_id(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.access_key_id = inp;
            self
        }
        /// Consumes the builder and constructs a [`DeleteAccessKeyInput`](crate::input::DeleteAccessKeyInput)
        pub fn build(
            self,
        ) -> Result<crate::input::DeleteAccessKeyInput, smithy_http::operation::BuildError>
        {
            Ok(crate::input::DeleteAccessKeyInput {
                user_name: self.user_name,
                access_key_id: self.access_key_id,
            })
        }
    }
}
#[doc(hidden)]
pub type DeleteAccessKeyInputOperationOutputAlias = crate::operation::DeleteAccessKey;
#[doc(hidden)]
pub type DeleteAccessKeyInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl DeleteAccessKeyInput {
    /// Consumes the builder and constructs an Operation<[`DeleteAccessKey`](crate::operation::DeleteAccessKey)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> Result<
        smithy_http::operation::Operation<
            crate::operation::DeleteAccessKey,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = crate::operation_ser::serialize_operation_delete_access_key(&self).map_err(
                |err| smithy_http::operation::BuildError::SerializationError(err.into()),
            )?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::DeleteAccessKey::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "DeleteAccessKey",
                "iam",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) {
        write!(output, "/").expect("formatting should succeed")
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri);
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let builder = http::request::Builder::new();
        let builder = builder.header("Content-Type", "application/x-www-form-urlencoded");
        self.update_http_builder(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`DeleteAccessKeyInput`](crate::input::DeleteAccessKeyInput)
    pub fn builder() -> crate::input::delete_access_key_input::Builder {
        crate::input::delete_access_key_input::Builder::default()
    }
}

/// See [`DeleteAccountAliasInput`](crate::input::DeleteAccountAliasInput)
pub mod delete_account_alias_input {
    /// A builder for [`DeleteAccountAliasInput`](crate::input::DeleteAccountAliasInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) account_alias: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the account alias to delete.</p>
        /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of
        /// lowercase letters, digits, and dashes. You cannot start or finish with a dash, nor can you have
        /// two dashes in a row.</p>
        pub fn account_alias(mut self, inp: impl Into<std::string::String>) -> Self {
            self.account_alias = Some(inp.into());
            self
        }
        pub fn set_account_alias(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.account_alias = inp;
            self
        }
        /// Consumes the builder and constructs a [`DeleteAccountAliasInput`](crate::input::DeleteAccountAliasInput)
        pub fn build(
            self,
        ) -> Result<crate::input::DeleteAccountAliasInput, smithy_http::operation::BuildError>
        {
            Ok(crate::input::DeleteAccountAliasInput {
                account_alias: self.account_alias,
            })
        }
    }
}
#[doc(hidden)]
pub type DeleteAccountAliasInputOperationOutputAlias = crate::operation::DeleteAccountAlias;
#[doc(hidden)]
pub type DeleteAccountAliasInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl DeleteAccountAliasInput {
    /// Consumes the builder and constructs an Operation<[`DeleteAccountAlias`](crate::operation::DeleteAccountAlias)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> Result<
        smithy_http::operation::Operation<
            crate::operation::DeleteAccountAlias,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = crate::operation_ser::serialize_operation_delete_account_alias(&self)
                .map_err(|err| {
                    smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::DeleteAccountAlias::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "DeleteAccountAlias",
                "iam",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) {
        write!(output, "/").expect("formatting should succeed")
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri);
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let builder = http::request::Builder::new();
        let builder = builder.header("Content-Type", "application/x-www-form-urlencoded");
        self.update_http_builder(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`DeleteAccountAliasInput`](crate::input::DeleteAccountAliasInput)
    pub fn builder() -> crate::input::delete_account_alias_input::Builder {
        crate::input::delete_account_alias_input::Builder::default()
    }
}

/// See [`DeleteAccountPasswordPolicyInput`](crate::input::DeleteAccountPasswordPolicyInput)
pub mod delete_account_password_policy_input {
    /// A builder for [`DeleteAccountPasswordPolicyInput`](crate::input::DeleteAccountPasswordPolicyInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {}
    impl Builder {
        /// Consumes the builder and constructs a [`DeleteAccountPasswordPolicyInput`](crate::input::DeleteAccountPasswordPolicyInput)
        pub fn build(
            self,
        ) -> Result<
            crate::input::DeleteAccountPasswordPolicyInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DeleteAccountPasswordPolicyInput {})
        }
    }
}
#[doc(hidden)]
pub type DeleteAccountPasswordPolicyInputOperationOutputAlias =
    crate::operation::DeleteAccountPasswordPolicy;
#[doc(hidden)]
pub type DeleteAccountPasswordPolicyInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl DeleteAccountPasswordPolicyInput {
    /// Consumes the builder and constructs an Operation<[`DeleteAccountPasswordPolicy`](crate::operation::DeleteAccountPasswordPolicy)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> Result<
        smithy_http::operation::Operation<
            crate::operation::DeleteAccountPasswordPolicy,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body =
                crate::operation_ser::serialize_operation_delete_account_password_policy(&self)
                    .map_err(|err| {
                        smithy_http::operation::BuildError::SerializationError(err.into())
                    })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::DeleteAccountPasswordPolicy::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "DeleteAccountPasswordPolicy",
                "iam",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) {
        write!(output, "/").expect("formatting should succeed")
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri);
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let builder = http::request::Builder::new();
        let builder = builder.header("Content-Type", "application/x-www-form-urlencoded");
        self.update_http_builder(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`DeleteAccountPasswordPolicyInput`](crate::input::DeleteAccountPasswordPolicyInput)
    pub fn builder() -> crate::input::delete_account_password_policy_input::Builder {
        crate::input::delete_account_password_policy_input::Builder::default()
    }
}

/// See [`DeleteGroupInput`](crate::input::DeleteGroupInput)
pub mod delete_group_input {
    /// A builder for [`DeleteGroupInput`](crate::input::DeleteGroupInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) group_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the IAM group to delete.</p>
        /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
        /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
        pub fn group_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.group_name = Some(inp.into());
            self
        }
        pub fn set_group_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.group_name = inp;
            self
        }
        /// Consumes the builder and constructs a [`DeleteGroupInput`](crate::input::DeleteGroupInput)
        pub fn build(
            self,
        ) -> Result<crate::input::DeleteGroupInput, smithy_http::operation::BuildError> {
            Ok(crate::input::DeleteGroupInput {
                group_name: self.group_name,
            })
        }
    }
}
#[doc(hidden)]
pub type DeleteGroupInputOperationOutputAlias = crate::operation::DeleteGroup;
#[doc(hidden)]
pub type DeleteGroupInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl DeleteGroupInput {
    /// Consumes the builder and constructs an Operation<[`DeleteGroup`](crate::operation::DeleteGroup)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> Result<
        smithy_http::operation::Operation<
            crate::operation::DeleteGroup,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body =
                crate::operation_ser::serialize_operation_delete_group(&self).map_err(|err| {
                    smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::DeleteGroup::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new("DeleteGroup", "iam"));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) {
        write!(output, "/").expect("formatting should succeed")
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri);
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let builder = http::request::Builder::new();
        let builder = builder.header("Content-Type", "application/x-www-form-urlencoded");
        self.update_http_builder(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`DeleteGroupInput`](crate::input::DeleteGroupInput)
    pub fn builder() -> crate::input::delete_group_input::Builder {
        crate::input::delete_group_input::Builder::default()
    }
}

/// See [`DeleteGroupPolicyInput`](crate::input::DeleteGroupPolicyInput)
pub mod delete_group_policy_input {
    /// A builder for [`DeleteGroupPolicyInput`](crate::input::DeleteGroupPolicyInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) group_name: std::option::Option<std::string::String>,
        pub(crate) policy_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name (friendly name, not ARN) identifying the group that the policy is embedded
        /// in.</p>
        /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
        /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
        pub fn group_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.group_name = Some(inp.into());
            self
        }
        pub fn set_group_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.group_name = inp;
            self
        }
        /// <p>The name identifying the policy document to delete.</p>
        /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
        /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
        pub fn policy_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.policy_name = Some(inp.into());
            self
        }
        pub fn set_policy_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.policy_name = inp;
            self
        }
        /// Consumes the builder and constructs a [`DeleteGroupPolicyInput`](crate::input::DeleteGroupPolicyInput)
        pub fn build(
            self,
        ) -> Result<crate::input::DeleteGroupPolicyInput, smithy_http::operation::BuildError>
        {
            Ok(crate::input::DeleteGroupPolicyInput {
                group_name: self.group_name,
                policy_name: self.policy_name,
            })
        }
    }
}
#[doc(hidden)]
pub type DeleteGroupPolicyInputOperationOutputAlias = crate::operation::DeleteGroupPolicy;
#[doc(hidden)]
pub type DeleteGroupPolicyInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl DeleteGroupPolicyInput {
    /// Consumes the builder and constructs an Operation<[`DeleteGroupPolicy`](crate::operation::DeleteGroupPolicy)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> Result<
        smithy_http::operation::Operation<
            crate::operation::DeleteGroupPolicy,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = crate::operation_ser::serialize_operation_delete_group_policy(&self)
                .map_err(|err| {
                    smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::DeleteGroupPolicy::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "DeleteGroupPolicy",
                "iam",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) {
        write!(output, "/").expect("formatting should succeed")
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri);
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let builder = http::request::Builder::new();
        let builder = builder.header("Content-Type", "application/x-www-form-urlencoded");
        self.update_http_builder(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`DeleteGroupPolicyInput`](crate::input::DeleteGroupPolicyInput)
    pub fn builder() -> crate::input::delete_group_policy_input::Builder {
        crate::input::delete_group_policy_input::Builder::default()
    }
}

/// See [`DeleteInstanceProfileInput`](crate::input::DeleteInstanceProfileInput)
pub mod delete_instance_profile_input {
    /// A builder for [`DeleteInstanceProfileInput`](crate::input::DeleteInstanceProfileInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) instance_profile_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the instance profile to delete.</p>
        /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
        /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
        pub fn instance_profile_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.instance_profile_name = Some(inp.into());
            self
        }
        pub fn set_instance_profile_name(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.instance_profile_name = inp;
            self
        }
        /// Consumes the builder and constructs a [`DeleteInstanceProfileInput`](crate::input::DeleteInstanceProfileInput)
        pub fn build(
            self,
        ) -> Result<crate::input::DeleteInstanceProfileInput, smithy_http::operation::BuildError>
        {
            Ok(crate::input::DeleteInstanceProfileInput {
                instance_profile_name: self.instance_profile_name,
            })
        }
    }
}
#[doc(hidden)]
pub type DeleteInstanceProfileInputOperationOutputAlias = crate::operation::DeleteInstanceProfile;
#[doc(hidden)]
pub type DeleteInstanceProfileInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl DeleteInstanceProfileInput {
    /// Consumes the builder and constructs an Operation<[`DeleteInstanceProfile`](crate::operation::DeleteInstanceProfile)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> Result<
        smithy_http::operation::Operation<
            crate::operation::DeleteInstanceProfile,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = crate::operation_ser::serialize_operation_delete_instance_profile(&self)
                .map_err(|err| {
                    smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::DeleteInstanceProfile::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "DeleteInstanceProfile",
                "iam",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) {
        write!(output, "/").expect("formatting should succeed")
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri);
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let builder = http::request::Builder::new();
        let builder = builder.header("Content-Type", "application/x-www-form-urlencoded");
        self.update_http_builder(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`DeleteInstanceProfileInput`](crate::input::DeleteInstanceProfileInput)
    pub fn builder() -> crate::input::delete_instance_profile_input::Builder {
        crate::input::delete_instance_profile_input::Builder::default()
    }
}

/// See [`DeleteLoginProfileInput`](crate::input::DeleteLoginProfileInput)
pub mod delete_login_profile_input {
    /// A builder for [`DeleteLoginProfileInput`](crate::input::DeleteLoginProfileInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) user_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the user whose password you want to delete.</p>
        /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
        /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
        pub fn user_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.user_name = Some(inp.into());
            self
        }
        pub fn set_user_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.user_name = inp;
            self
        }
        /// Consumes the builder and constructs a [`DeleteLoginProfileInput`](crate::input::DeleteLoginProfileInput)
        pub fn build(
            self,
        ) -> Result<crate::input::DeleteLoginProfileInput, smithy_http::operation::BuildError>
        {
            Ok(crate::input::DeleteLoginProfileInput {
                user_name: self.user_name,
            })
        }
    }
}
#[doc(hidden)]
pub type DeleteLoginProfileInputOperationOutputAlias = crate::operation::DeleteLoginProfile;
#[doc(hidden)]
pub type DeleteLoginProfileInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl DeleteLoginProfileInput {
    /// Consumes the builder and constructs an Operation<[`DeleteLoginProfile`](crate::operation::DeleteLoginProfile)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> Result<
        smithy_http::operation::Operation<
            crate::operation::DeleteLoginProfile,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = crate::operation_ser::serialize_operation_delete_login_profile(&self)
                .map_err(|err| {
                    smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::DeleteLoginProfile::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "DeleteLoginProfile",
                "iam",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) {
        write!(output, "/").expect("formatting should succeed")
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri);
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let builder = http::request::Builder::new();
        let builder = builder.header("Content-Type", "application/x-www-form-urlencoded");
        self.update_http_builder(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`DeleteLoginProfileInput`](crate::input::DeleteLoginProfileInput)
    pub fn builder() -> crate::input::delete_login_profile_input::Builder {
        crate::input::delete_login_profile_input::Builder::default()
    }
}

/// See [`DeleteOpenIDConnectProviderInput`](crate::input::DeleteOpenIDConnectProviderInput)
pub mod delete_open_id_connect_provider_input {
    /// A builder for [`DeleteOpenIDConnectProviderInput`](crate::input::DeleteOpenIDConnectProviderInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) open_id_connect_provider_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the IAM OpenID Connect provider resource object to
        /// delete. You can get a list of OpenID Connect provider resource ARNs by using the <a>ListOpenIDConnectProviders</a> operation.</p>
        pub fn open_id_connect_provider_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.open_id_connect_provider_arn = Some(inp.into());
            self
        }
        pub fn set_open_id_connect_provider_arn(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.open_id_connect_provider_arn = inp;
            self
        }
        /// Consumes the builder and constructs a [`DeleteOpenIDConnectProviderInput`](crate::input::DeleteOpenIDConnectProviderInput)
        pub fn build(
            self,
        ) -> Result<
            crate::input::DeleteOpenIDConnectProviderInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DeleteOpenIDConnectProviderInput {
                open_id_connect_provider_arn: self.open_id_connect_provider_arn,
            })
        }
    }
}
#[doc(hidden)]
pub type DeleteOpenIDConnectProviderInputOperationOutputAlias =
    crate::operation::DeleteOpenIDConnectProvider;
#[doc(hidden)]
pub type DeleteOpenIDConnectProviderInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl DeleteOpenIDConnectProviderInput {
    /// Consumes the builder and constructs an Operation<[`DeleteOpenIDConnectProvider`](crate::operation::DeleteOpenIDConnectProvider)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> Result<
        smithy_http::operation::Operation<
            crate::operation::DeleteOpenIDConnectProvider,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body =
                crate::operation_ser::serialize_operation_delete_open_id_connect_provider(&self)
                    .map_err(|err| {
                        smithy_http::operation::BuildError::SerializationError(err.into())
                    })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::DeleteOpenIDConnectProvider::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "DeleteOpenIDConnectProvider",
                "iam",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) {
        write!(output, "/").expect("formatting should succeed")
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri);
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let builder = http::request::Builder::new();
        let builder = builder.header("Content-Type", "application/x-www-form-urlencoded");
        self.update_http_builder(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`DeleteOpenIDConnectProviderInput`](crate::input::DeleteOpenIDConnectProviderInput)
    pub fn builder() -> crate::input::delete_open_id_connect_provider_input::Builder {
        crate::input::delete_open_id_connect_provider_input::Builder::default()
    }
}

/// See [`DeletePolicyInput`](crate::input::DeletePolicyInput)
pub mod delete_policy_input {
    /// A builder for [`DeletePolicyInput`](crate::input::DeletePolicyInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) policy_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the IAM policy you want to delete.</p>
        /// <p>For more information about ARNs, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">Amazon Resource Names (ARNs)</a> in the <i>AWS General Reference</i>.</p>
        pub fn policy_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.policy_arn = Some(inp.into());
            self
        }
        pub fn set_policy_arn(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.policy_arn = inp;
            self
        }
        /// Consumes the builder and constructs a [`DeletePolicyInput`](crate::input::DeletePolicyInput)
        pub fn build(
            self,
        ) -> Result<crate::input::DeletePolicyInput, smithy_http::operation::BuildError> {
            Ok(crate::input::DeletePolicyInput {
                policy_arn: self.policy_arn,
            })
        }
    }
}
#[doc(hidden)]
pub type DeletePolicyInputOperationOutputAlias = crate::operation::DeletePolicy;
#[doc(hidden)]
pub type DeletePolicyInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl DeletePolicyInput {
    /// Consumes the builder and constructs an Operation<[`DeletePolicy`](crate::operation::DeletePolicy)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> Result<
        smithy_http::operation::Operation<
            crate::operation::DeletePolicy,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body =
                crate::operation_ser::serialize_operation_delete_policy(&self).map_err(|err| {
                    smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::DeletePolicy::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new("DeletePolicy", "iam"));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) {
        write!(output, "/").expect("formatting should succeed")
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri);
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let builder = http::request::Builder::new();
        let builder = builder.header("Content-Type", "application/x-www-form-urlencoded");
        self.update_http_builder(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`DeletePolicyInput`](crate::input::DeletePolicyInput)
    pub fn builder() -> crate::input::delete_policy_input::Builder {
        crate::input::delete_policy_input::Builder::default()
    }
}

/// See [`DeletePolicyVersionInput`](crate::input::DeletePolicyVersionInput)
pub mod delete_policy_version_input {
    /// A builder for [`DeletePolicyVersionInput`](crate::input::DeletePolicyVersionInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) policy_arn: std::option::Option<std::string::String>,
        pub(crate) version_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the IAM policy from which you want to delete a
        /// version.</p>
        /// <p>For more information about ARNs, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">Amazon Resource Names (ARNs)</a> in the <i>AWS General Reference</i>.</p>
        pub fn policy_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.policy_arn = Some(inp.into());
            self
        }
        pub fn set_policy_arn(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.policy_arn = inp;
            self
        }
        /// <p>The policy version to delete.</p>
        /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters that
        /// consists of the lowercase letter 'v' followed by one or two digits, and optionally
        /// followed by a period '.' and a string of letters and digits.</p>
        /// <p>For more information about managed policy versions, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/policies-managed-versions.html">Versioning for managed
        /// policies</a> in the <i>IAM User Guide</i>.</p>
        pub fn version_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.version_id = Some(inp.into());
            self
        }
        pub fn set_version_id(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.version_id = inp;
            self
        }
        /// Consumes the builder and constructs a [`DeletePolicyVersionInput`](crate::input::DeletePolicyVersionInput)
        pub fn build(
            self,
        ) -> Result<crate::input::DeletePolicyVersionInput, smithy_http::operation::BuildError>
        {
            Ok(crate::input::DeletePolicyVersionInput {
                policy_arn: self.policy_arn,
                version_id: self.version_id,
            })
        }
    }
}
#[doc(hidden)]
pub type DeletePolicyVersionInputOperationOutputAlias = crate::operation::DeletePolicyVersion;
#[doc(hidden)]
pub type DeletePolicyVersionInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl DeletePolicyVersionInput {
    /// Consumes the builder and constructs an Operation<[`DeletePolicyVersion`](crate::operation::DeletePolicyVersion)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> Result<
        smithy_http::operation::Operation<
            crate::operation::DeletePolicyVersion,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = crate::operation_ser::serialize_operation_delete_policy_version(&self)
                .map_err(|err| {
                    smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::DeletePolicyVersion::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "DeletePolicyVersion",
                "iam",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) {
        write!(output, "/").expect("formatting should succeed")
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri);
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let builder = http::request::Builder::new();
        let builder = builder.header("Content-Type", "application/x-www-form-urlencoded");
        self.update_http_builder(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`DeletePolicyVersionInput`](crate::input::DeletePolicyVersionInput)
    pub fn builder() -> crate::input::delete_policy_version_input::Builder {
        crate::input::delete_policy_version_input::Builder::default()
    }
}

/// See [`DeleteRoleInput`](crate::input::DeleteRoleInput)
pub mod delete_role_input {
    /// A builder for [`DeleteRoleInput`](crate::input::DeleteRoleInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) role_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the role to delete.</p>
        /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
        /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
        pub fn role_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.role_name = Some(inp.into());
            self
        }
        pub fn set_role_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.role_name = inp;
            self
        }
        /// Consumes the builder and constructs a [`DeleteRoleInput`](crate::input::DeleteRoleInput)
        pub fn build(
            self,
        ) -> Result<crate::input::DeleteRoleInput, smithy_http::operation::BuildError> {
            Ok(crate::input::DeleteRoleInput {
                role_name: self.role_name,
            })
        }
    }
}
#[doc(hidden)]
pub type DeleteRoleInputOperationOutputAlias = crate::operation::DeleteRole;
#[doc(hidden)]
pub type DeleteRoleInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl DeleteRoleInput {
    /// Consumes the builder and constructs an Operation<[`DeleteRole`](crate::operation::DeleteRole)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> Result<
        smithy_http::operation::Operation<
            crate::operation::DeleteRole,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body =
                crate::operation_ser::serialize_operation_delete_role(&self).map_err(|err| {
                    smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::DeleteRole::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new("DeleteRole", "iam"));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) {
        write!(output, "/").expect("formatting should succeed")
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri);
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let builder = http::request::Builder::new();
        let builder = builder.header("Content-Type", "application/x-www-form-urlencoded");
        self.update_http_builder(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`DeleteRoleInput`](crate::input::DeleteRoleInput)
    pub fn builder() -> crate::input::delete_role_input::Builder {
        crate::input::delete_role_input::Builder::default()
    }
}

/// See [`DeleteRolePermissionsBoundaryInput`](crate::input::DeleteRolePermissionsBoundaryInput)
pub mod delete_role_permissions_boundary_input {
    /// A builder for [`DeleteRolePermissionsBoundaryInput`](crate::input::DeleteRolePermissionsBoundaryInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) role_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name (friendly name, not ARN) of the IAM role from which you want to remove the
        /// permissions boundary.</p>
        pub fn role_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.role_name = Some(inp.into());
            self
        }
        pub fn set_role_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.role_name = inp;
            self
        }
        /// Consumes the builder and constructs a [`DeleteRolePermissionsBoundaryInput`](crate::input::DeleteRolePermissionsBoundaryInput)
        pub fn build(
            self,
        ) -> Result<
            crate::input::DeleteRolePermissionsBoundaryInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DeleteRolePermissionsBoundaryInput {
                role_name: self.role_name,
            })
        }
    }
}
#[doc(hidden)]
pub type DeleteRolePermissionsBoundaryInputOperationOutputAlias =
    crate::operation::DeleteRolePermissionsBoundary;
#[doc(hidden)]
pub type DeleteRolePermissionsBoundaryInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl DeleteRolePermissionsBoundaryInput {
    /// Consumes the builder and constructs an Operation<[`DeleteRolePermissionsBoundary`](crate::operation::DeleteRolePermissionsBoundary)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> Result<
        smithy_http::operation::Operation<
            crate::operation::DeleteRolePermissionsBoundary,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body =
                crate::operation_ser::serialize_operation_delete_role_permissions_boundary(&self)
                    .map_err(|err| {
                    smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::DeleteRolePermissionsBoundary::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "DeleteRolePermissionsBoundary",
                "iam",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) {
        write!(output, "/").expect("formatting should succeed")
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri);
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let builder = http::request::Builder::new();
        let builder = builder.header("Content-Type", "application/x-www-form-urlencoded");
        self.update_http_builder(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`DeleteRolePermissionsBoundaryInput`](crate::input::DeleteRolePermissionsBoundaryInput)
    pub fn builder() -> crate::input::delete_role_permissions_boundary_input::Builder {
        crate::input::delete_role_permissions_boundary_input::Builder::default()
    }
}

/// See [`DeleteRolePolicyInput`](crate::input::DeleteRolePolicyInput)
pub mod delete_role_policy_input {
    /// A builder for [`DeleteRolePolicyInput`](crate::input::DeleteRolePolicyInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) role_name: std::option::Option<std::string::String>,
        pub(crate) policy_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name (friendly name, not ARN) identifying the role that the policy is embedded
        /// in.</p>
        /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
        /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
        pub fn role_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.role_name = Some(inp.into());
            self
        }
        pub fn set_role_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.role_name = inp;
            self
        }
        /// <p>The name of the inline policy to delete from the specified IAM role.</p>
        /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
        /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
        pub fn policy_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.policy_name = Some(inp.into());
            self
        }
        pub fn set_policy_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.policy_name = inp;
            self
        }
        /// Consumes the builder and constructs a [`DeleteRolePolicyInput`](crate::input::DeleteRolePolicyInput)
        pub fn build(
            self,
        ) -> Result<crate::input::DeleteRolePolicyInput, smithy_http::operation::BuildError>
        {
            Ok(crate::input::DeleteRolePolicyInput {
                role_name: self.role_name,
                policy_name: self.policy_name,
            })
        }
    }
}
#[doc(hidden)]
pub type DeleteRolePolicyInputOperationOutputAlias = crate::operation::DeleteRolePolicy;
#[doc(hidden)]
pub type DeleteRolePolicyInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl DeleteRolePolicyInput {
    /// Consumes the builder and constructs an Operation<[`DeleteRolePolicy`](crate::operation::DeleteRolePolicy)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> Result<
        smithy_http::operation::Operation<
            crate::operation::DeleteRolePolicy,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = crate::operation_ser::serialize_operation_delete_role_policy(&self)
                .map_err(|err| {
                    smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::DeleteRolePolicy::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "DeleteRolePolicy",
                "iam",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) {
        write!(output, "/").expect("formatting should succeed")
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri);
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let builder = http::request::Builder::new();
        let builder = builder.header("Content-Type", "application/x-www-form-urlencoded");
        self.update_http_builder(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`DeleteRolePolicyInput`](crate::input::DeleteRolePolicyInput)
    pub fn builder() -> crate::input::delete_role_policy_input::Builder {
        crate::input::delete_role_policy_input::Builder::default()
    }
}

/// See [`DeleteSAMLProviderInput`](crate::input::DeleteSAMLProviderInput)
pub mod delete_saml_provider_input {
    /// A builder for [`DeleteSAMLProviderInput`](crate::input::DeleteSAMLProviderInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) saml_provider_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the SAML provider to delete.</p>
        pub fn saml_provider_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.saml_provider_arn = Some(inp.into());
            self
        }
        pub fn set_saml_provider_arn(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.saml_provider_arn = inp;
            self
        }
        /// Consumes the builder and constructs a [`DeleteSAMLProviderInput`](crate::input::DeleteSAMLProviderInput)
        pub fn build(
            self,
        ) -> Result<crate::input::DeleteSAMLProviderInput, smithy_http::operation::BuildError>
        {
            Ok(crate::input::DeleteSAMLProviderInput {
                saml_provider_arn: self.saml_provider_arn,
            })
        }
    }
}
#[doc(hidden)]
pub type DeleteSAMLProviderInputOperationOutputAlias = crate::operation::DeleteSAMLProvider;
#[doc(hidden)]
pub type DeleteSAMLProviderInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl DeleteSAMLProviderInput {
    /// Consumes the builder and constructs an Operation<[`DeleteSAMLProvider`](crate::operation::DeleteSAMLProvider)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> Result<
        smithy_http::operation::Operation<
            crate::operation::DeleteSAMLProvider,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = crate::operation_ser::serialize_operation_delete_saml_provider(&self)
                .map_err(|err| {
                    smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::DeleteSAMLProvider::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "DeleteSAMLProvider",
                "iam",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) {
        write!(output, "/").expect("formatting should succeed")
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri);
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let builder = http::request::Builder::new();
        let builder = builder.header("Content-Type", "application/x-www-form-urlencoded");
        self.update_http_builder(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`DeleteSAMLProviderInput`](crate::input::DeleteSAMLProviderInput)
    pub fn builder() -> crate::input::delete_saml_provider_input::Builder {
        crate::input::delete_saml_provider_input::Builder::default()
    }
}

/// See [`DeleteServerCertificateInput`](crate::input::DeleteServerCertificateInput)
pub mod delete_server_certificate_input {
    /// A builder for [`DeleteServerCertificateInput`](crate::input::DeleteServerCertificateInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) server_certificate_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the server certificate you want to delete.</p>
        /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
        /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
        pub fn server_certificate_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.server_certificate_name = Some(inp.into());
            self
        }
        pub fn set_server_certificate_name(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.server_certificate_name = inp;
            self
        }
        /// Consumes the builder and constructs a [`DeleteServerCertificateInput`](crate::input::DeleteServerCertificateInput)
        pub fn build(
            self,
        ) -> Result<crate::input::DeleteServerCertificateInput, smithy_http::operation::BuildError>
        {
            Ok(crate::input::DeleteServerCertificateInput {
                server_certificate_name: self.server_certificate_name,
            })
        }
    }
}
#[doc(hidden)]
pub type DeleteServerCertificateInputOperationOutputAlias =
    crate::operation::DeleteServerCertificate;
#[doc(hidden)]
pub type DeleteServerCertificateInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl DeleteServerCertificateInput {
    /// Consumes the builder and constructs an Operation<[`DeleteServerCertificate`](crate::operation::DeleteServerCertificate)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> Result<
        smithy_http::operation::Operation<
            crate::operation::DeleteServerCertificate,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = crate::operation_ser::serialize_operation_delete_server_certificate(&self)
                .map_err(|err| {
                smithy_http::operation::BuildError::SerializationError(err.into())
            })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::DeleteServerCertificate::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "DeleteServerCertificate",
                "iam",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) {
        write!(output, "/").expect("formatting should succeed")
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri);
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let builder = http::request::Builder::new();
        let builder = builder.header("Content-Type", "application/x-www-form-urlencoded");
        self.update_http_builder(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`DeleteServerCertificateInput`](crate::input::DeleteServerCertificateInput)
    pub fn builder() -> crate::input::delete_server_certificate_input::Builder {
        crate::input::delete_server_certificate_input::Builder::default()
    }
}

/// See [`DeleteServiceLinkedRoleInput`](crate::input::DeleteServiceLinkedRoleInput)
pub mod delete_service_linked_role_input {
    /// A builder for [`DeleteServiceLinkedRoleInput`](crate::input::DeleteServiceLinkedRoleInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) role_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the service-linked role to be deleted.</p>
        pub fn role_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.role_name = Some(inp.into());
            self
        }
        pub fn set_role_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.role_name = inp;
            self
        }
        /// Consumes the builder and constructs a [`DeleteServiceLinkedRoleInput`](crate::input::DeleteServiceLinkedRoleInput)
        pub fn build(
            self,
        ) -> Result<crate::input::DeleteServiceLinkedRoleInput, smithy_http::operation::BuildError>
        {
            Ok(crate::input::DeleteServiceLinkedRoleInput {
                role_name: self.role_name,
            })
        }
    }
}
#[doc(hidden)]
pub type DeleteServiceLinkedRoleInputOperationOutputAlias =
    crate::operation::DeleteServiceLinkedRole;
#[doc(hidden)]
pub type DeleteServiceLinkedRoleInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl DeleteServiceLinkedRoleInput {
    /// Consumes the builder and constructs an Operation<[`DeleteServiceLinkedRole`](crate::operation::DeleteServiceLinkedRole)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> Result<
        smithy_http::operation::Operation<
            crate::operation::DeleteServiceLinkedRole,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = crate::operation_ser::serialize_operation_delete_service_linked_role(&self)
                .map_err(|err| {
                    smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::DeleteServiceLinkedRole::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "DeleteServiceLinkedRole",
                "iam",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) {
        write!(output, "/").expect("formatting should succeed")
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri);
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let builder = http::request::Builder::new();
        let builder = builder.header("Content-Type", "application/x-www-form-urlencoded");
        self.update_http_builder(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`DeleteServiceLinkedRoleInput`](crate::input::DeleteServiceLinkedRoleInput)
    pub fn builder() -> crate::input::delete_service_linked_role_input::Builder {
        crate::input::delete_service_linked_role_input::Builder::default()
    }
}

/// See [`DeleteServiceSpecificCredentialInput`](crate::input::DeleteServiceSpecificCredentialInput)
pub mod delete_service_specific_credential_input {
    /// A builder for [`DeleteServiceSpecificCredentialInput`](crate::input::DeleteServiceSpecificCredentialInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) user_name: std::option::Option<std::string::String>,
        pub(crate) service_specific_credential_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the IAM user associated with the service-specific credential. If this
        /// value is not specified, then the operation assumes the user whose credentials are used
        /// to call the operation.</p>
        /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
        /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
        pub fn user_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.user_name = Some(inp.into());
            self
        }
        pub fn set_user_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.user_name = inp;
            self
        }
        /// <p>The unique identifier of the service-specific credential. You can get this value by
        /// calling <a>ListServiceSpecificCredentials</a>.</p>
        /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters that can
        /// consist of any upper or lowercased letter or digit.</p>
        pub fn service_specific_credential_id(
            mut self,
            inp: impl Into<std::string::String>,
        ) -> Self {
            self.service_specific_credential_id = Some(inp.into());
            self
        }
        pub fn set_service_specific_credential_id(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.service_specific_credential_id = inp;
            self
        }
        /// Consumes the builder and constructs a [`DeleteServiceSpecificCredentialInput`](crate::input::DeleteServiceSpecificCredentialInput)
        pub fn build(
            self,
        ) -> Result<
            crate::input::DeleteServiceSpecificCredentialInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DeleteServiceSpecificCredentialInput {
                user_name: self.user_name,
                service_specific_credential_id: self.service_specific_credential_id,
            })
        }
    }
}
#[doc(hidden)]
pub type DeleteServiceSpecificCredentialInputOperationOutputAlias =
    crate::operation::DeleteServiceSpecificCredential;
#[doc(hidden)]
pub type DeleteServiceSpecificCredentialInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl DeleteServiceSpecificCredentialInput {
    /// Consumes the builder and constructs an Operation<[`DeleteServiceSpecificCredential`](crate::operation::DeleteServiceSpecificCredential)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> Result<
        smithy_http::operation::Operation<
            crate::operation::DeleteServiceSpecificCredential,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body =
                crate::operation_ser::serialize_operation_delete_service_specific_credential(&self)
                    .map_err(|err| {
                        smithy_http::operation::BuildError::SerializationError(err.into())
                    })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::DeleteServiceSpecificCredential::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "DeleteServiceSpecificCredential",
                "iam",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) {
        write!(output, "/").expect("formatting should succeed")
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri);
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let builder = http::request::Builder::new();
        let builder = builder.header("Content-Type", "application/x-www-form-urlencoded");
        self.update_http_builder(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`DeleteServiceSpecificCredentialInput`](crate::input::DeleteServiceSpecificCredentialInput)
    pub fn builder() -> crate::input::delete_service_specific_credential_input::Builder {
        crate::input::delete_service_specific_credential_input::Builder::default()
    }
}

/// See [`DeleteSigningCertificateInput`](crate::input::DeleteSigningCertificateInput)
pub mod delete_signing_certificate_input {
    /// A builder for [`DeleteSigningCertificateInput`](crate::input::DeleteSigningCertificateInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) user_name: std::option::Option<std::string::String>,
        pub(crate) certificate_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the user the signing certificate belongs to.</p>
        /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
        /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
        pub fn user_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.user_name = Some(inp.into());
            self
        }
        pub fn set_user_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.user_name = inp;
            self
        }
        /// <p>The ID of the signing certificate to delete.</p>
        /// <p>The format of this parameter, as described by its <a href="http://wikipedia.org/wiki/regex">regex</a> pattern, is a string of
        /// characters that can be upper- or lower-cased letters or digits.</p>
        pub fn certificate_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.certificate_id = Some(inp.into());
            self
        }
        pub fn set_certificate_id(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.certificate_id = inp;
            self
        }
        /// Consumes the builder and constructs a [`DeleteSigningCertificateInput`](crate::input::DeleteSigningCertificateInput)
        pub fn build(
            self,
        ) -> Result<crate::input::DeleteSigningCertificateInput, smithy_http::operation::BuildError>
        {
            Ok(crate::input::DeleteSigningCertificateInput {
                user_name: self.user_name,
                certificate_id: self.certificate_id,
            })
        }
    }
}
#[doc(hidden)]
pub type DeleteSigningCertificateInputOperationOutputAlias =
    crate::operation::DeleteSigningCertificate;
#[doc(hidden)]
pub type DeleteSigningCertificateInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl DeleteSigningCertificateInput {
    /// Consumes the builder and constructs an Operation<[`DeleteSigningCertificate`](crate::operation::DeleteSigningCertificate)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> Result<
        smithy_http::operation::Operation<
            crate::operation::DeleteSigningCertificate,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = crate::operation_ser::serialize_operation_delete_signing_certificate(&self)
                .map_err(|err| {
                    smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::DeleteSigningCertificate::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "DeleteSigningCertificate",
                "iam",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) {
        write!(output, "/").expect("formatting should succeed")
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri);
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let builder = http::request::Builder::new();
        let builder = builder.header("Content-Type", "application/x-www-form-urlencoded");
        self.update_http_builder(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`DeleteSigningCertificateInput`](crate::input::DeleteSigningCertificateInput)
    pub fn builder() -> crate::input::delete_signing_certificate_input::Builder {
        crate::input::delete_signing_certificate_input::Builder::default()
    }
}

/// See [`DeleteSSHPublicKeyInput`](crate::input::DeleteSSHPublicKeyInput)
pub mod delete_ssh_public_key_input {
    /// A builder for [`DeleteSSHPublicKeyInput`](crate::input::DeleteSSHPublicKeyInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) user_name: std::option::Option<std::string::String>,
        pub(crate) ssh_public_key_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the IAM user associated with the SSH public key.</p>
        /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
        /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
        pub fn user_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.user_name = Some(inp.into());
            self
        }
        pub fn set_user_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.user_name = inp;
            self
        }
        /// <p>The unique identifier for the SSH public key.</p>
        /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters that can
        /// consist of any upper or lowercased letter or digit.</p>
        pub fn ssh_public_key_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.ssh_public_key_id = Some(inp.into());
            self
        }
        pub fn set_ssh_public_key_id(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.ssh_public_key_id = inp;
            self
        }
        /// Consumes the builder and constructs a [`DeleteSSHPublicKeyInput`](crate::input::DeleteSSHPublicKeyInput)
        pub fn build(
            self,
        ) -> Result<crate::input::DeleteSSHPublicKeyInput, smithy_http::operation::BuildError>
        {
            Ok(crate::input::DeleteSSHPublicKeyInput {
                user_name: self.user_name,
                ssh_public_key_id: self.ssh_public_key_id,
            })
        }
    }
}
#[doc(hidden)]
pub type DeleteSSHPublicKeyInputOperationOutputAlias = crate::operation::DeleteSSHPublicKey;
#[doc(hidden)]
pub type DeleteSSHPublicKeyInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl DeleteSSHPublicKeyInput {
    /// Consumes the builder and constructs an Operation<[`DeleteSSHPublicKey`](crate::operation::DeleteSSHPublicKey)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> Result<
        smithy_http::operation::Operation<
            crate::operation::DeleteSSHPublicKey,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = crate::operation_ser::serialize_operation_delete_ssh_public_key(&self)
                .map_err(|err| {
                    smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::DeleteSSHPublicKey::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "DeleteSSHPublicKey",
                "iam",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) {
        write!(output, "/").expect("formatting should succeed")
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri);
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let builder = http::request::Builder::new();
        let builder = builder.header("Content-Type", "application/x-www-form-urlencoded");
        self.update_http_builder(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`DeleteSSHPublicKeyInput`](crate::input::DeleteSSHPublicKeyInput)
    pub fn builder() -> crate::input::delete_ssh_public_key_input::Builder {
        crate::input::delete_ssh_public_key_input::Builder::default()
    }
}

/// See [`DeleteUserInput`](crate::input::DeleteUserInput)
pub mod delete_user_input {
    /// A builder for [`DeleteUserInput`](crate::input::DeleteUserInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) user_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the user to delete.</p>
        /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
        /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
        pub fn user_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.user_name = Some(inp.into());
            self
        }
        pub fn set_user_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.user_name = inp;
            self
        }
        /// Consumes the builder and constructs a [`DeleteUserInput`](crate::input::DeleteUserInput)
        pub fn build(
            self,
        ) -> Result<crate::input::DeleteUserInput, smithy_http::operation::BuildError> {
            Ok(crate::input::DeleteUserInput {
                user_name: self.user_name,
            })
        }
    }
}
#[doc(hidden)]
pub type DeleteUserInputOperationOutputAlias = crate::operation::DeleteUser;
#[doc(hidden)]
pub type DeleteUserInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl DeleteUserInput {
    /// Consumes the builder and constructs an Operation<[`DeleteUser`](crate::operation::DeleteUser)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> Result<
        smithy_http::operation::Operation<
            crate::operation::DeleteUser,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body =
                crate::operation_ser::serialize_operation_delete_user(&self).map_err(|err| {
                    smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::DeleteUser::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new("DeleteUser", "iam"));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) {
        write!(output, "/").expect("formatting should succeed")
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri);
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let builder = http::request::Builder::new();
        let builder = builder.header("Content-Type", "application/x-www-form-urlencoded");
        self.update_http_builder(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`DeleteUserInput`](crate::input::DeleteUserInput)
    pub fn builder() -> crate::input::delete_user_input::Builder {
        crate::input::delete_user_input::Builder::default()
    }
}

/// See [`DeleteUserPermissionsBoundaryInput`](crate::input::DeleteUserPermissionsBoundaryInput)
pub mod delete_user_permissions_boundary_input {
    /// A builder for [`DeleteUserPermissionsBoundaryInput`](crate::input::DeleteUserPermissionsBoundaryInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) user_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name (friendly name, not ARN) of the IAM user from which you want to remove the
        /// permissions boundary.</p>
        pub fn user_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.user_name = Some(inp.into());
            self
        }
        pub fn set_user_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.user_name = inp;
            self
        }
        /// Consumes the builder and constructs a [`DeleteUserPermissionsBoundaryInput`](crate::input::DeleteUserPermissionsBoundaryInput)
        pub fn build(
            self,
        ) -> Result<
            crate::input::DeleteUserPermissionsBoundaryInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DeleteUserPermissionsBoundaryInput {
                user_name: self.user_name,
            })
        }
    }
}
#[doc(hidden)]
pub type DeleteUserPermissionsBoundaryInputOperationOutputAlias =
    crate::operation::DeleteUserPermissionsBoundary;
#[doc(hidden)]
pub type DeleteUserPermissionsBoundaryInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl DeleteUserPermissionsBoundaryInput {
    /// Consumes the builder and constructs an Operation<[`DeleteUserPermissionsBoundary`](crate::operation::DeleteUserPermissionsBoundary)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> Result<
        smithy_http::operation::Operation<
            crate::operation::DeleteUserPermissionsBoundary,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body =
                crate::operation_ser::serialize_operation_delete_user_permissions_boundary(&self)
                    .map_err(|err| {
                    smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::DeleteUserPermissionsBoundary::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "DeleteUserPermissionsBoundary",
                "iam",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) {
        write!(output, "/").expect("formatting should succeed")
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri);
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let builder = http::request::Builder::new();
        let builder = builder.header("Content-Type", "application/x-www-form-urlencoded");
        self.update_http_builder(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`DeleteUserPermissionsBoundaryInput`](crate::input::DeleteUserPermissionsBoundaryInput)
    pub fn builder() -> crate::input::delete_user_permissions_boundary_input::Builder {
        crate::input::delete_user_permissions_boundary_input::Builder::default()
    }
}

/// See [`DeleteUserPolicyInput`](crate::input::DeleteUserPolicyInput)
pub mod delete_user_policy_input {
    /// A builder for [`DeleteUserPolicyInput`](crate::input::DeleteUserPolicyInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) user_name: std::option::Option<std::string::String>,
        pub(crate) policy_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name (friendly name, not ARN) identifying the user that the policy is embedded
        /// in.</p>
        /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
        /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
        pub fn user_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.user_name = Some(inp.into());
            self
        }
        pub fn set_user_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.user_name = inp;
            self
        }
        /// <p>The name identifying the policy document to delete.</p>
        /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
        /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
        pub fn policy_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.policy_name = Some(inp.into());
            self
        }
        pub fn set_policy_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.policy_name = inp;
            self
        }
        /// Consumes the builder and constructs a [`DeleteUserPolicyInput`](crate::input::DeleteUserPolicyInput)
        pub fn build(
            self,
        ) -> Result<crate::input::DeleteUserPolicyInput, smithy_http::operation::BuildError>
        {
            Ok(crate::input::DeleteUserPolicyInput {
                user_name: self.user_name,
                policy_name: self.policy_name,
            })
        }
    }
}
#[doc(hidden)]
pub type DeleteUserPolicyInputOperationOutputAlias = crate::operation::DeleteUserPolicy;
#[doc(hidden)]
pub type DeleteUserPolicyInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl DeleteUserPolicyInput {
    /// Consumes the builder and constructs an Operation<[`DeleteUserPolicy`](crate::operation::DeleteUserPolicy)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> Result<
        smithy_http::operation::Operation<
            crate::operation::DeleteUserPolicy,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = crate::operation_ser::serialize_operation_delete_user_policy(&self)
                .map_err(|err| {
                    smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::DeleteUserPolicy::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "DeleteUserPolicy",
                "iam",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) {
        write!(output, "/").expect("formatting should succeed")
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri);
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let builder = http::request::Builder::new();
        let builder = builder.header("Content-Type", "application/x-www-form-urlencoded");
        self.update_http_builder(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`DeleteUserPolicyInput`](crate::input::DeleteUserPolicyInput)
    pub fn builder() -> crate::input::delete_user_policy_input::Builder {
        crate::input::delete_user_policy_input::Builder::default()
    }
}

/// See [`DeleteVirtualMFADeviceInput`](crate::input::DeleteVirtualMFADeviceInput)
pub mod delete_virtual_mfa_device_input {
    /// A builder for [`DeleteVirtualMFADeviceInput`](crate::input::DeleteVirtualMFADeviceInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) serial_number: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The serial number that uniquely identifies the MFA device. For virtual MFA devices,
        /// the serial number is the same as the ARN.</p>
        /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting
        /// of upper and lowercase alphanumeric characters with no spaces. You can also include any of the
        /// following characters: =,.@:/-</p>
        pub fn serial_number(mut self, inp: impl Into<std::string::String>) -> Self {
            self.serial_number = Some(inp.into());
            self
        }
        pub fn set_serial_number(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.serial_number = inp;
            self
        }
        /// Consumes the builder and constructs a [`DeleteVirtualMFADeviceInput`](crate::input::DeleteVirtualMFADeviceInput)
        pub fn build(
            self,
        ) -> Result<crate::input::DeleteVirtualMFADeviceInput, smithy_http::operation::BuildError>
        {
            Ok(crate::input::DeleteVirtualMFADeviceInput {
                serial_number: self.serial_number,
            })
        }
    }
}
#[doc(hidden)]
pub type DeleteVirtualMFADeviceInputOperationOutputAlias = crate::operation::DeleteVirtualMFADevice;
#[doc(hidden)]
pub type DeleteVirtualMFADeviceInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl DeleteVirtualMFADeviceInput {
    /// Consumes the builder and constructs an Operation<[`DeleteVirtualMFADevice`](crate::operation::DeleteVirtualMFADevice)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> Result<
        smithy_http::operation::Operation<
            crate::operation::DeleteVirtualMFADevice,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = crate::operation_ser::serialize_operation_delete_virtual_mfa_device(&self)
                .map_err(|err| {
                smithy_http::operation::BuildError::SerializationError(err.into())
            })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::DeleteVirtualMFADevice::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "DeleteVirtualMFADevice",
                "iam",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) {
        write!(output, "/").expect("formatting should succeed")
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri);
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let builder = http::request::Builder::new();
        let builder = builder.header("Content-Type", "application/x-www-form-urlencoded");
        self.update_http_builder(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`DeleteVirtualMFADeviceInput`](crate::input::DeleteVirtualMFADeviceInput)
    pub fn builder() -> crate::input::delete_virtual_mfa_device_input::Builder {
        crate::input::delete_virtual_mfa_device_input::Builder::default()
    }
}

/// See [`DetachGroupPolicyInput`](crate::input::DetachGroupPolicyInput)
pub mod detach_group_policy_input {
    /// A builder for [`DetachGroupPolicyInput`](crate::input::DetachGroupPolicyInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) group_name: std::option::Option<std::string::String>,
        pub(crate) policy_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name (friendly name, not ARN) of the IAM group to detach the policy from.</p>
        /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
        /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
        pub fn group_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.group_name = Some(inp.into());
            self
        }
        pub fn set_group_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.group_name = inp;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the IAM policy you want to detach.</p>
        /// <p>For more information about ARNs, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">Amazon Resource Names (ARNs)</a> in the <i>AWS General Reference</i>.</p>
        pub fn policy_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.policy_arn = Some(inp.into());
            self
        }
        pub fn set_policy_arn(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.policy_arn = inp;
            self
        }
        /// Consumes the builder and constructs a [`DetachGroupPolicyInput`](crate::input::DetachGroupPolicyInput)
        pub fn build(
            self,
        ) -> Result<crate::input::DetachGroupPolicyInput, smithy_http::operation::BuildError>
        {
            Ok(crate::input::DetachGroupPolicyInput {
                group_name: self.group_name,
                policy_arn: self.policy_arn,
            })
        }
    }
}
#[doc(hidden)]
pub type DetachGroupPolicyInputOperationOutputAlias = crate::operation::DetachGroupPolicy;
#[doc(hidden)]
pub type DetachGroupPolicyInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl DetachGroupPolicyInput {
    /// Consumes the builder and constructs an Operation<[`DetachGroupPolicy`](crate::operation::DetachGroupPolicy)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> Result<
        smithy_http::operation::Operation<
            crate::operation::DetachGroupPolicy,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = crate::operation_ser::serialize_operation_detach_group_policy(&self)
                .map_err(|err| {
                    smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::DetachGroupPolicy::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "DetachGroupPolicy",
                "iam",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) {
        write!(output, "/").expect("formatting should succeed")
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri);
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let builder = http::request::Builder::new();
        let builder = builder.header("Content-Type", "application/x-www-form-urlencoded");
        self.update_http_builder(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`DetachGroupPolicyInput`](crate::input::DetachGroupPolicyInput)
    pub fn builder() -> crate::input::detach_group_policy_input::Builder {
        crate::input::detach_group_policy_input::Builder::default()
    }
}

/// See [`DetachRolePolicyInput`](crate::input::DetachRolePolicyInput)
pub mod detach_role_policy_input {
    /// A builder for [`DetachRolePolicyInput`](crate::input::DetachRolePolicyInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) role_name: std::option::Option<std::string::String>,
        pub(crate) policy_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name (friendly name, not ARN) of the IAM role to detach the policy from.</p>
        /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
        /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
        pub fn role_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.role_name = Some(inp.into());
            self
        }
        pub fn set_role_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.role_name = inp;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the IAM policy you want to detach.</p>
        /// <p>For more information about ARNs, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">Amazon Resource Names (ARNs)</a> in the <i>AWS General Reference</i>.</p>
        pub fn policy_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.policy_arn = Some(inp.into());
            self
        }
        pub fn set_policy_arn(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.policy_arn = inp;
            self
        }
        /// Consumes the builder and constructs a [`DetachRolePolicyInput`](crate::input::DetachRolePolicyInput)
        pub fn build(
            self,
        ) -> Result<crate::input::DetachRolePolicyInput, smithy_http::operation::BuildError>
        {
            Ok(crate::input::DetachRolePolicyInput {
                role_name: self.role_name,
                policy_arn: self.policy_arn,
            })
        }
    }
}
#[doc(hidden)]
pub type DetachRolePolicyInputOperationOutputAlias = crate::operation::DetachRolePolicy;
#[doc(hidden)]
pub type DetachRolePolicyInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl DetachRolePolicyInput {
    /// Consumes the builder and constructs an Operation<[`DetachRolePolicy`](crate::operation::DetachRolePolicy)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> Result<
        smithy_http::operation::Operation<
            crate::operation::DetachRolePolicy,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = crate::operation_ser::serialize_operation_detach_role_policy(&self)
                .map_err(|err| {
                    smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::DetachRolePolicy::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "DetachRolePolicy",
                "iam",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) {
        write!(output, "/").expect("formatting should succeed")
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri);
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let builder = http::request::Builder::new();
        let builder = builder.header("Content-Type", "application/x-www-form-urlencoded");
        self.update_http_builder(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`DetachRolePolicyInput`](crate::input::DetachRolePolicyInput)
    pub fn builder() -> crate::input::detach_role_policy_input::Builder {
        crate::input::detach_role_policy_input::Builder::default()
    }
}

/// See [`DetachUserPolicyInput`](crate::input::DetachUserPolicyInput)
pub mod detach_user_policy_input {
    /// A builder for [`DetachUserPolicyInput`](crate::input::DetachUserPolicyInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) user_name: std::option::Option<std::string::String>,
        pub(crate) policy_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name (friendly name, not ARN) of the IAM user to detach the policy from.</p>
        /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
        /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
        pub fn user_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.user_name = Some(inp.into());
            self
        }
        pub fn set_user_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.user_name = inp;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the IAM policy you want to detach.</p>
        /// <p>For more information about ARNs, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">Amazon Resource Names (ARNs)</a> in the <i>AWS General Reference</i>.</p>
        pub fn policy_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.policy_arn = Some(inp.into());
            self
        }
        pub fn set_policy_arn(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.policy_arn = inp;
            self
        }
        /// Consumes the builder and constructs a [`DetachUserPolicyInput`](crate::input::DetachUserPolicyInput)
        pub fn build(
            self,
        ) -> Result<crate::input::DetachUserPolicyInput, smithy_http::operation::BuildError>
        {
            Ok(crate::input::DetachUserPolicyInput {
                user_name: self.user_name,
                policy_arn: self.policy_arn,
            })
        }
    }
}
#[doc(hidden)]
pub type DetachUserPolicyInputOperationOutputAlias = crate::operation::DetachUserPolicy;
#[doc(hidden)]
pub type DetachUserPolicyInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl DetachUserPolicyInput {
    /// Consumes the builder and constructs an Operation<[`DetachUserPolicy`](crate::operation::DetachUserPolicy)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> Result<
        smithy_http::operation::Operation<
            crate::operation::DetachUserPolicy,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = crate::operation_ser::serialize_operation_detach_user_policy(&self)
                .map_err(|err| {
                    smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::DetachUserPolicy::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "DetachUserPolicy",
                "iam",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) {
        write!(output, "/").expect("formatting should succeed")
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri);
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let builder = http::request::Builder::new();
        let builder = builder.header("Content-Type", "application/x-www-form-urlencoded");
        self.update_http_builder(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`DetachUserPolicyInput`](crate::input::DetachUserPolicyInput)
    pub fn builder() -> crate::input::detach_user_policy_input::Builder {
        crate::input::detach_user_policy_input::Builder::default()
    }
}

/// See [`EnableMFADeviceInput`](crate::input::EnableMFADeviceInput)
pub mod enable_mfa_device_input {
    /// A builder for [`EnableMFADeviceInput`](crate::input::EnableMFADeviceInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) user_name: std::option::Option<std::string::String>,
        pub(crate) serial_number: std::option::Option<std::string::String>,
        pub(crate) authentication_code1: std::option::Option<std::string::String>,
        pub(crate) authentication_code2: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the IAM user for whom you want to enable the MFA device.</p>
        /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
        /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
        pub fn user_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.user_name = Some(inp.into());
            self
        }
        pub fn set_user_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.user_name = inp;
            self
        }
        /// <p>The serial number that uniquely identifies the MFA device. For virtual MFA devices,
        /// the serial number is the device ARN.</p>
        /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting
        /// of upper and lowercase alphanumeric characters with no spaces. You can also include any of the
        /// following characters: =,.@:/-</p>
        pub fn serial_number(mut self, inp: impl Into<std::string::String>) -> Self {
            self.serial_number = Some(inp.into());
            self
        }
        pub fn set_serial_number(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.serial_number = inp;
            self
        }
        /// <p>An authentication code emitted by the device. </p>
        /// <p>The format for this parameter is a string of six digits.</p>
        /// <important>
        /// <p>Submit your request immediately after generating the authentication codes. If you
        /// generate the codes and then wait too long to submit the request, the MFA device
        /// successfully associates with the user but the MFA device becomes out of sync. This
        /// happens because time-based one-time passwords (TOTP) expire after a short period of
        /// time. If this happens, you can <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_mfa_sync.html">resync the
        /// device</a>.</p>
        /// </important>
        pub fn authentication_code1(mut self, inp: impl Into<std::string::String>) -> Self {
            self.authentication_code1 = Some(inp.into());
            self
        }
        pub fn set_authentication_code1(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.authentication_code1 = inp;
            self
        }
        /// <p>A subsequent authentication code emitted by the device.</p>
        /// <p>The format for this parameter is a string of six digits.</p>
        /// <important>
        /// <p>Submit your request immediately after generating the authentication codes. If you
        /// generate the codes and then wait too long to submit the request, the MFA device
        /// successfully associates with the user but the MFA device becomes out of sync. This
        /// happens because time-based one-time passwords (TOTP) expire after a short period of
        /// time. If this happens, you can <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_mfa_sync.html">resync the
        /// device</a>.</p>
        /// </important>
        pub fn authentication_code2(mut self, inp: impl Into<std::string::String>) -> Self {
            self.authentication_code2 = Some(inp.into());
            self
        }
        pub fn set_authentication_code2(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.authentication_code2 = inp;
            self
        }
        /// Consumes the builder and constructs a [`EnableMFADeviceInput`](crate::input::EnableMFADeviceInput)
        pub fn build(
            self,
        ) -> Result<crate::input::EnableMFADeviceInput, smithy_http::operation::BuildError>
        {
            Ok(crate::input::EnableMFADeviceInput {
                user_name: self.user_name,
                serial_number: self.serial_number,
                authentication_code1: self.authentication_code1,
                authentication_code2: self.authentication_code2,
            })
        }
    }
}
#[doc(hidden)]
pub type EnableMFADeviceInputOperationOutputAlias = crate::operation::EnableMFADevice;
#[doc(hidden)]
pub type EnableMFADeviceInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl EnableMFADeviceInput {
    /// Consumes the builder and constructs an Operation<[`EnableMFADevice`](crate::operation::EnableMFADevice)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> Result<
        smithy_http::operation::Operation<
            crate::operation::EnableMFADevice,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = crate::operation_ser::serialize_operation_enable_mfa_device(&self).map_err(
                |err| smithy_http::operation::BuildError::SerializationError(err.into()),
            )?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::EnableMFADevice::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "EnableMFADevice",
                "iam",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) {
        write!(output, "/").expect("formatting should succeed")
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri);
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let builder = http::request::Builder::new();
        let builder = builder.header("Content-Type", "application/x-www-form-urlencoded");
        self.update_http_builder(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`EnableMFADeviceInput`](crate::input::EnableMFADeviceInput)
    pub fn builder() -> crate::input::enable_mfa_device_input::Builder {
        crate::input::enable_mfa_device_input::Builder::default()
    }
}

/// See [`GenerateCredentialReportInput`](crate::input::GenerateCredentialReportInput)
pub mod generate_credential_report_input {
    /// A builder for [`GenerateCredentialReportInput`](crate::input::GenerateCredentialReportInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {}
    impl Builder {
        /// Consumes the builder and constructs a [`GenerateCredentialReportInput`](crate::input::GenerateCredentialReportInput)
        pub fn build(
            self,
        ) -> Result<crate::input::GenerateCredentialReportInput, smithy_http::operation::BuildError>
        {
            Ok(crate::input::GenerateCredentialReportInput {})
        }
    }
}
#[doc(hidden)]
pub type GenerateCredentialReportInputOperationOutputAlias =
    crate::operation::GenerateCredentialReport;
#[doc(hidden)]
pub type GenerateCredentialReportInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl GenerateCredentialReportInput {
    /// Consumes the builder and constructs an Operation<[`GenerateCredentialReport`](crate::operation::GenerateCredentialReport)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> Result<
        smithy_http::operation::Operation<
            crate::operation::GenerateCredentialReport,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = crate::operation_ser::serialize_operation_generate_credential_report(&self)
                .map_err(|err| {
                    smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::GenerateCredentialReport::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "GenerateCredentialReport",
                "iam",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) {
        write!(output, "/").expect("formatting should succeed")
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri);
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let builder = http::request::Builder::new();
        let builder = builder.header("Content-Type", "application/x-www-form-urlencoded");
        self.update_http_builder(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`GenerateCredentialReportInput`](crate::input::GenerateCredentialReportInput)
    pub fn builder() -> crate::input::generate_credential_report_input::Builder {
        crate::input::generate_credential_report_input::Builder::default()
    }
}

/// See [`GenerateOrganizationsAccessReportInput`](crate::input::GenerateOrganizationsAccessReportInput)
pub mod generate_organizations_access_report_input {
    /// A builder for [`GenerateOrganizationsAccessReportInput`](crate::input::GenerateOrganizationsAccessReportInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) entity_path: std::option::Option<std::string::String>,
        pub(crate) organizations_policy_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The path of the AWS Organizations entity (root, OU, or account). You can build an entity path using
        /// the known structure of your organization. For example, assume that your account ID is
        /// <code>123456789012</code> and its parent OU ID is <code>ou-rge0-awsabcde</code>. The
        /// organization root ID is <code>r-f6g7h8i9j0example</code> and your organization ID is
        /// <code>o-a1b2c3d4e5</code>. Your entity path is
        /// <code>o-a1b2c3d4e5/r-f6g7h8i9j0example/ou-rge0-awsabcde/123456789012</code>.</p>
        pub fn entity_path(mut self, inp: impl Into<std::string::String>) -> Self {
            self.entity_path = Some(inp.into());
            self
        }
        pub fn set_entity_path(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.entity_path = inp;
            self
        }
        /// <p>The identifier of the AWS Organizations service control policy (SCP). This parameter is
        /// optional.</p>
        /// <p>This ID is used to generate information about when an account principal that is
        /// limited by the SCP attempted to access an AWS service.</p>
        pub fn organizations_policy_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.organizations_policy_id = Some(inp.into());
            self
        }
        pub fn set_organizations_policy_id(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.organizations_policy_id = inp;
            self
        }
        /// Consumes the builder and constructs a [`GenerateOrganizationsAccessReportInput`](crate::input::GenerateOrganizationsAccessReportInput)
        pub fn build(
            self,
        ) -> Result<
            crate::input::GenerateOrganizationsAccessReportInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::GenerateOrganizationsAccessReportInput {
                entity_path: self.entity_path,
                organizations_policy_id: self.organizations_policy_id,
            })
        }
    }
}
#[doc(hidden)]
pub type GenerateOrganizationsAccessReportInputOperationOutputAlias =
    crate::operation::GenerateOrganizationsAccessReport;
#[doc(hidden)]
pub type GenerateOrganizationsAccessReportInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl GenerateOrganizationsAccessReportInput {
    /// Consumes the builder and constructs an Operation<[`GenerateOrganizationsAccessReport`](crate::operation::GenerateOrganizationsAccessReport)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> Result<
        smithy_http::operation::Operation<
            crate::operation::GenerateOrganizationsAccessReport,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body =
                crate::operation_ser::serialize_operation_generate_organizations_access_report(
                    &self,
                )
                .map_err(|err| {
                    smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::GenerateOrganizationsAccessReport::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "GenerateOrganizationsAccessReport",
                "iam",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) {
        write!(output, "/").expect("formatting should succeed")
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri);
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let builder = http::request::Builder::new();
        let builder = builder.header("Content-Type", "application/x-www-form-urlencoded");
        self.update_http_builder(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`GenerateOrganizationsAccessReportInput`](crate::input::GenerateOrganizationsAccessReportInput)
    pub fn builder() -> crate::input::generate_organizations_access_report_input::Builder {
        crate::input::generate_organizations_access_report_input::Builder::default()
    }
}

/// See [`GenerateServiceLastAccessedDetailsInput`](crate::input::GenerateServiceLastAccessedDetailsInput)
pub mod generate_service_last_accessed_details_input {
    /// A builder for [`GenerateServiceLastAccessedDetailsInput`](crate::input::GenerateServiceLastAccessedDetailsInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) granularity:
            std::option::Option<crate::model::AccessAdvisorUsageGranularityType>,
    }
    impl Builder {
        /// <p>The ARN of the IAM resource (user, group, role, or managed policy) used to generate
        /// information about when the resource was last used in an attempt to access an AWS
        /// service.</p>
        pub fn arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.arn = Some(inp.into());
            self
        }
        pub fn set_arn(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.arn = inp;
            self
        }
        /// <p>The level of detail that you want to generate. You can specify whether you want to
        /// generate information about the last attempt to access services or actions. If you
        /// specify service-level granularity, this operation generates only service data. If you
        /// specify action-level granularity, it generates service and action data. If you don't
        /// include this optional parameter, the operation generates service data.</p>
        pub fn granularity(mut self, inp: crate::model::AccessAdvisorUsageGranularityType) -> Self {
            self.granularity = Some(inp);
            self
        }
        pub fn set_granularity(
            mut self,
            inp: std::option::Option<crate::model::AccessAdvisorUsageGranularityType>,
        ) -> Self {
            self.granularity = inp;
            self
        }
        /// Consumes the builder and constructs a [`GenerateServiceLastAccessedDetailsInput`](crate::input::GenerateServiceLastAccessedDetailsInput)
        pub fn build(
            self,
        ) -> Result<
            crate::input::GenerateServiceLastAccessedDetailsInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::GenerateServiceLastAccessedDetailsInput {
                arn: self.arn,
                granularity: self.granularity,
            })
        }
    }
}
#[doc(hidden)]
pub type GenerateServiceLastAccessedDetailsInputOperationOutputAlias =
    crate::operation::GenerateServiceLastAccessedDetails;
#[doc(hidden)]
pub type GenerateServiceLastAccessedDetailsInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl GenerateServiceLastAccessedDetailsInput {
    /// Consumes the builder and constructs an Operation<[`GenerateServiceLastAccessedDetails`](crate::operation::GenerateServiceLastAccessedDetails)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> Result<
        smithy_http::operation::Operation<
            crate::operation::GenerateServiceLastAccessedDetails,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body =
                crate::operation_ser::serialize_operation_generate_service_last_accessed_details(
                    &self,
                )
                .map_err(|err| {
                    smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::GenerateServiceLastAccessedDetails::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "GenerateServiceLastAccessedDetails",
                "iam",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) {
        write!(output, "/").expect("formatting should succeed")
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri);
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let builder = http::request::Builder::new();
        let builder = builder.header("Content-Type", "application/x-www-form-urlencoded");
        self.update_http_builder(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`GenerateServiceLastAccessedDetailsInput`](crate::input::GenerateServiceLastAccessedDetailsInput)
    pub fn builder() -> crate::input::generate_service_last_accessed_details_input::Builder {
        crate::input::generate_service_last_accessed_details_input::Builder::default()
    }
}

/// See [`GetAccessKeyLastUsedInput`](crate::input::GetAccessKeyLastUsedInput)
pub mod get_access_key_last_used_input {
    /// A builder for [`GetAccessKeyLastUsedInput`](crate::input::GetAccessKeyLastUsedInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) access_key_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The identifier of an access key.</p>
        /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters that can
        /// consist of any upper or lowercased letter or digit.</p>
        pub fn access_key_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.access_key_id = Some(inp.into());
            self
        }
        pub fn set_access_key_id(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.access_key_id = inp;
            self
        }
        /// Consumes the builder and constructs a [`GetAccessKeyLastUsedInput`](crate::input::GetAccessKeyLastUsedInput)
        pub fn build(
            self,
        ) -> Result<crate::input::GetAccessKeyLastUsedInput, smithy_http::operation::BuildError>
        {
            Ok(crate::input::GetAccessKeyLastUsedInput {
                access_key_id: self.access_key_id,
            })
        }
    }
}
#[doc(hidden)]
pub type GetAccessKeyLastUsedInputOperationOutputAlias = crate::operation::GetAccessKeyLastUsed;
#[doc(hidden)]
pub type GetAccessKeyLastUsedInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl GetAccessKeyLastUsedInput {
    /// Consumes the builder and constructs an Operation<[`GetAccessKeyLastUsed`](crate::operation::GetAccessKeyLastUsed)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> Result<
        smithy_http::operation::Operation<
            crate::operation::GetAccessKeyLastUsed,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = crate::operation_ser::serialize_operation_get_access_key_last_used(&self)
                .map_err(|err| {
                    smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::GetAccessKeyLastUsed::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "GetAccessKeyLastUsed",
                "iam",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) {
        write!(output, "/").expect("formatting should succeed")
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri);
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let builder = http::request::Builder::new();
        let builder = builder.header("Content-Type", "application/x-www-form-urlencoded");
        self.update_http_builder(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`GetAccessKeyLastUsedInput`](crate::input::GetAccessKeyLastUsedInput)
    pub fn builder() -> crate::input::get_access_key_last_used_input::Builder {
        crate::input::get_access_key_last_used_input::Builder::default()
    }
}

/// See [`GetAccountAuthorizationDetailsInput`](crate::input::GetAccountAuthorizationDetailsInput)
pub mod get_account_authorization_details_input {
    /// A builder for [`GetAccountAuthorizationDetailsInput`](crate::input::GetAccountAuthorizationDetailsInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) filter: std::option::Option<std::vec::Vec<crate::model::EntityType>>,
        pub(crate) max_items: std::option::Option<i32>,
        pub(crate) marker: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn filter(mut self, inp: impl Into<crate::model::EntityType>) -> Self {
            let mut v = self.filter.unwrap_or_default();
            v.push(inp.into());
            self.filter = Some(v);
            self
        }
        pub fn set_filter(
            mut self,
            inp: std::option::Option<std::vec::Vec<crate::model::EntityType>>,
        ) -> Self {
            self.filter = inp;
            self
        }
        /// <p>Use this only when paginating results to indicate the
        /// maximum number of items you want in the response. If additional items exist beyond the maximum
        /// you specify, the <code>IsTruncated</code> response element is <code>true</code>.</p>
        /// <p>If you do not include this parameter, the number of items defaults to 100. Note that
        /// IAM might return fewer results, even when there are more results available. In that case, the
        /// <code>IsTruncated</code> response element returns <code>true</code>, and <code>Marker</code>
        /// contains a value to include in the subsequent call that tells the service where to continue
        /// from.</p>
        pub fn max_items(mut self, inp: i32) -> Self {
            self.max_items = Some(inp);
            self
        }
        pub fn set_max_items(mut self, inp: std::option::Option<i32>) -> Self {
            self.max_items = inp;
            self
        }
        /// <p>Use this parameter only when paginating results and only after
        /// you receive a response indicating that the results are truncated. Set it to the value of the
        /// <code>Marker</code> element in the response that you received to indicate where the next call
        /// should start.</p>
        pub fn marker(mut self, inp: impl Into<std::string::String>) -> Self {
            self.marker = Some(inp.into());
            self
        }
        pub fn set_marker(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.marker = inp;
            self
        }
        /// Consumes the builder and constructs a [`GetAccountAuthorizationDetailsInput`](crate::input::GetAccountAuthorizationDetailsInput)
        pub fn build(
            self,
        ) -> Result<
            crate::input::GetAccountAuthorizationDetailsInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::GetAccountAuthorizationDetailsInput {
                filter: self.filter,
                max_items: self.max_items,
                marker: self.marker,
            })
        }
    }
}
#[doc(hidden)]
pub type GetAccountAuthorizationDetailsInputOperationOutputAlias =
    crate::operation::GetAccountAuthorizationDetails;
#[doc(hidden)]
pub type GetAccountAuthorizationDetailsInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl GetAccountAuthorizationDetailsInput {
    /// Consumes the builder and constructs an Operation<[`GetAccountAuthorizationDetails`](crate::operation::GetAccountAuthorizationDetails)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> Result<
        smithy_http::operation::Operation<
            crate::operation::GetAccountAuthorizationDetails,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body =
                crate::operation_ser::serialize_operation_get_account_authorization_details(&self)
                    .map_err(|err| {
                        smithy_http::operation::BuildError::SerializationError(err.into())
                    })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::GetAccountAuthorizationDetails::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "GetAccountAuthorizationDetails",
                "iam",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) {
        write!(output, "/").expect("formatting should succeed")
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri);
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let builder = http::request::Builder::new();
        let builder = builder.header("Content-Type", "application/x-www-form-urlencoded");
        self.update_http_builder(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`GetAccountAuthorizationDetailsInput`](crate::input::GetAccountAuthorizationDetailsInput)
    pub fn builder() -> crate::input::get_account_authorization_details_input::Builder {
        crate::input::get_account_authorization_details_input::Builder::default()
    }
}

/// See [`GetAccountPasswordPolicyInput`](crate::input::GetAccountPasswordPolicyInput)
pub mod get_account_password_policy_input {
    /// A builder for [`GetAccountPasswordPolicyInput`](crate::input::GetAccountPasswordPolicyInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {}
    impl Builder {
        /// Consumes the builder and constructs a [`GetAccountPasswordPolicyInput`](crate::input::GetAccountPasswordPolicyInput)
        pub fn build(
            self,
        ) -> Result<crate::input::GetAccountPasswordPolicyInput, smithy_http::operation::BuildError>
        {
            Ok(crate::input::GetAccountPasswordPolicyInput {})
        }
    }
}
#[doc(hidden)]
pub type GetAccountPasswordPolicyInputOperationOutputAlias =
    crate::operation::GetAccountPasswordPolicy;
#[doc(hidden)]
pub type GetAccountPasswordPolicyInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl GetAccountPasswordPolicyInput {
    /// Consumes the builder and constructs an Operation<[`GetAccountPasswordPolicy`](crate::operation::GetAccountPasswordPolicy)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> Result<
        smithy_http::operation::Operation<
            crate::operation::GetAccountPasswordPolicy,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = crate::operation_ser::serialize_operation_get_account_password_policy(&self)
                .map_err(|err| {
                    smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::GetAccountPasswordPolicy::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "GetAccountPasswordPolicy",
                "iam",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) {
        write!(output, "/").expect("formatting should succeed")
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri);
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let builder = http::request::Builder::new();
        let builder = builder.header("Content-Type", "application/x-www-form-urlencoded");
        self.update_http_builder(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`GetAccountPasswordPolicyInput`](crate::input::GetAccountPasswordPolicyInput)
    pub fn builder() -> crate::input::get_account_password_policy_input::Builder {
        crate::input::get_account_password_policy_input::Builder::default()
    }
}

/// See [`GetAccountSummaryInput`](crate::input::GetAccountSummaryInput)
pub mod get_account_summary_input {
    /// A builder for [`GetAccountSummaryInput`](crate::input::GetAccountSummaryInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {}
    impl Builder {
        /// Consumes the builder and constructs a [`GetAccountSummaryInput`](crate::input::GetAccountSummaryInput)
        pub fn build(
            self,
        ) -> Result<crate::input::GetAccountSummaryInput, smithy_http::operation::BuildError>
        {
            Ok(crate::input::GetAccountSummaryInput {})
        }
    }
}
#[doc(hidden)]
pub type GetAccountSummaryInputOperationOutputAlias = crate::operation::GetAccountSummary;
#[doc(hidden)]
pub type GetAccountSummaryInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl GetAccountSummaryInput {
    /// Consumes the builder and constructs an Operation<[`GetAccountSummary`](crate::operation::GetAccountSummary)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> Result<
        smithy_http::operation::Operation<
            crate::operation::GetAccountSummary,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = crate::operation_ser::serialize_operation_get_account_summary(&self)
                .map_err(|err| {
                    smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::GetAccountSummary::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "GetAccountSummary",
                "iam",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) {
        write!(output, "/").expect("formatting should succeed")
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri);
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let builder = http::request::Builder::new();
        let builder = builder.header("Content-Type", "application/x-www-form-urlencoded");
        self.update_http_builder(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`GetAccountSummaryInput`](crate::input::GetAccountSummaryInput)
    pub fn builder() -> crate::input::get_account_summary_input::Builder {
        crate::input::get_account_summary_input::Builder::default()
    }
}

/// See [`GetContextKeysForCustomPolicyInput`](crate::input::GetContextKeysForCustomPolicyInput)
pub mod get_context_keys_for_custom_policy_input {
    /// A builder for [`GetContextKeysForCustomPolicyInput`](crate::input::GetContextKeysForCustomPolicyInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) policy_input_list: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        pub fn policy_input_list(mut self, inp: impl Into<std::string::String>) -> Self {
            let mut v = self.policy_input_list.unwrap_or_default();
            v.push(inp.into());
            self.policy_input_list = Some(v);
            self
        }
        pub fn set_policy_input_list(
            mut self,
            inp: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.policy_input_list = inp;
            self
        }
        /// Consumes the builder and constructs a [`GetContextKeysForCustomPolicyInput`](crate::input::GetContextKeysForCustomPolicyInput)
        pub fn build(
            self,
        ) -> Result<
            crate::input::GetContextKeysForCustomPolicyInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::GetContextKeysForCustomPolicyInput {
                policy_input_list: self.policy_input_list,
            })
        }
    }
}
#[doc(hidden)]
pub type GetContextKeysForCustomPolicyInputOperationOutputAlias =
    crate::operation::GetContextKeysForCustomPolicy;
#[doc(hidden)]
pub type GetContextKeysForCustomPolicyInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl GetContextKeysForCustomPolicyInput {
    /// Consumes the builder and constructs an Operation<[`GetContextKeysForCustomPolicy`](crate::operation::GetContextKeysForCustomPolicy)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> Result<
        smithy_http::operation::Operation<
            crate::operation::GetContextKeysForCustomPolicy,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body =
                crate::operation_ser::serialize_operation_get_context_keys_for_custom_policy(&self)
                    .map_err(|err| {
                        smithy_http::operation::BuildError::SerializationError(err.into())
                    })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::GetContextKeysForCustomPolicy::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "GetContextKeysForCustomPolicy",
                "iam",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) {
        write!(output, "/").expect("formatting should succeed")
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri);
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let builder = http::request::Builder::new();
        let builder = builder.header("Content-Type", "application/x-www-form-urlencoded");
        self.update_http_builder(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`GetContextKeysForCustomPolicyInput`](crate::input::GetContextKeysForCustomPolicyInput)
    pub fn builder() -> crate::input::get_context_keys_for_custom_policy_input::Builder {
        crate::input::get_context_keys_for_custom_policy_input::Builder::default()
    }
}

/// See [`GetContextKeysForPrincipalPolicyInput`](crate::input::GetContextKeysForPrincipalPolicyInput)
pub mod get_context_keys_for_principal_policy_input {
    /// A builder for [`GetContextKeysForPrincipalPolicyInput`](crate::input::GetContextKeysForPrincipalPolicyInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) policy_source_arn: std::option::Option<std::string::String>,
        pub(crate) policy_input_list: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// <p>The ARN of a user, group, or role whose policies contain the context keys that you
        /// want listed. If you specify a user, the list includes context keys that are found in all
        /// policies that are attached to the user. The list also includes all groups that the user
        /// is a member of. If you pick a group or a role, then it includes only those context keys
        /// that are found in policies attached to that entity. Note that all parameters are shown
        /// in unencoded form here for clarity, but must be URL encoded to be included as a part of
        /// a real HTML request.</p>
        /// <p>For more information about ARNs, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">Amazon Resource Names (ARNs)</a> in the <i>AWS General Reference</i>.</p>
        pub fn policy_source_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.policy_source_arn = Some(inp.into());
            self
        }
        pub fn set_policy_source_arn(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.policy_source_arn = inp;
            self
        }
        pub fn policy_input_list(mut self, inp: impl Into<std::string::String>) -> Self {
            let mut v = self.policy_input_list.unwrap_or_default();
            v.push(inp.into());
            self.policy_input_list = Some(v);
            self
        }
        pub fn set_policy_input_list(
            mut self,
            inp: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.policy_input_list = inp;
            self
        }
        /// Consumes the builder and constructs a [`GetContextKeysForPrincipalPolicyInput`](crate::input::GetContextKeysForPrincipalPolicyInput)
        pub fn build(
            self,
        ) -> Result<
            crate::input::GetContextKeysForPrincipalPolicyInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::GetContextKeysForPrincipalPolicyInput {
                policy_source_arn: self.policy_source_arn,
                policy_input_list: self.policy_input_list,
            })
        }
    }
}
#[doc(hidden)]
pub type GetContextKeysForPrincipalPolicyInputOperationOutputAlias =
    crate::operation::GetContextKeysForPrincipalPolicy;
#[doc(hidden)]
pub type GetContextKeysForPrincipalPolicyInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl GetContextKeysForPrincipalPolicyInput {
    /// Consumes the builder and constructs an Operation<[`GetContextKeysForPrincipalPolicy`](crate::operation::GetContextKeysForPrincipalPolicy)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> Result<
        smithy_http::operation::Operation<
            crate::operation::GetContextKeysForPrincipalPolicy,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body =
                crate::operation_ser::serialize_operation_get_context_keys_for_principal_policy(
                    &self,
                )
                .map_err(|err| {
                    smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::GetContextKeysForPrincipalPolicy::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "GetContextKeysForPrincipalPolicy",
                "iam",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) {
        write!(output, "/").expect("formatting should succeed")
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri);
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let builder = http::request::Builder::new();
        let builder = builder.header("Content-Type", "application/x-www-form-urlencoded");
        self.update_http_builder(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`GetContextKeysForPrincipalPolicyInput`](crate::input::GetContextKeysForPrincipalPolicyInput)
    pub fn builder() -> crate::input::get_context_keys_for_principal_policy_input::Builder {
        crate::input::get_context_keys_for_principal_policy_input::Builder::default()
    }
}

/// See [`GetCredentialReportInput`](crate::input::GetCredentialReportInput)
pub mod get_credential_report_input {
    /// A builder for [`GetCredentialReportInput`](crate::input::GetCredentialReportInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {}
    impl Builder {
        /// Consumes the builder and constructs a [`GetCredentialReportInput`](crate::input::GetCredentialReportInput)
        pub fn build(
            self,
        ) -> Result<crate::input::GetCredentialReportInput, smithy_http::operation::BuildError>
        {
            Ok(crate::input::GetCredentialReportInput {})
        }
    }
}
#[doc(hidden)]
pub type GetCredentialReportInputOperationOutputAlias = crate::operation::GetCredentialReport;
#[doc(hidden)]
pub type GetCredentialReportInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl GetCredentialReportInput {
    /// Consumes the builder and constructs an Operation<[`GetCredentialReport`](crate::operation::GetCredentialReport)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> Result<
        smithy_http::operation::Operation<
            crate::operation::GetCredentialReport,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = crate::operation_ser::serialize_operation_get_credential_report(&self)
                .map_err(|err| {
                    smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::GetCredentialReport::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "GetCredentialReport",
                "iam",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) {
        write!(output, "/").expect("formatting should succeed")
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri);
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let builder = http::request::Builder::new();
        let builder = builder.header("Content-Type", "application/x-www-form-urlencoded");
        self.update_http_builder(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`GetCredentialReportInput`](crate::input::GetCredentialReportInput)
    pub fn builder() -> crate::input::get_credential_report_input::Builder {
        crate::input::get_credential_report_input::Builder::default()
    }
}

/// See [`GetGroupInput`](crate::input::GetGroupInput)
pub mod get_group_input {
    /// A builder for [`GetGroupInput`](crate::input::GetGroupInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) group_name: std::option::Option<std::string::String>,
        pub(crate) marker: std::option::Option<std::string::String>,
        pub(crate) max_items: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The name of the group.</p>
        /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
        /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
        pub fn group_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.group_name = Some(inp.into());
            self
        }
        pub fn set_group_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.group_name = inp;
            self
        }
        /// <p>Use this parameter only when paginating results and only after
        /// you receive a response indicating that the results are truncated. Set it to the value of the
        /// <code>Marker</code> element in the response that you received to indicate where the next call
        /// should start.</p>
        pub fn marker(mut self, inp: impl Into<std::string::String>) -> Self {
            self.marker = Some(inp.into());
            self
        }
        pub fn set_marker(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.marker = inp;
            self
        }
        /// <p>Use this only when paginating results to indicate the
        /// maximum number of items you want in the response. If additional items exist beyond the maximum
        /// you specify, the <code>IsTruncated</code> response element is <code>true</code>.</p>
        /// <p>If you do not include this parameter, the number of items defaults to 100. Note that
        /// IAM might return fewer results, even when there are more results available. In that case, the
        /// <code>IsTruncated</code> response element returns <code>true</code>, and <code>Marker</code>
        /// contains a value to include in the subsequent call that tells the service where to continue
        /// from.</p>
        pub fn max_items(mut self, inp: i32) -> Self {
            self.max_items = Some(inp);
            self
        }
        pub fn set_max_items(mut self, inp: std::option::Option<i32>) -> Self {
            self.max_items = inp;
            self
        }
        /// Consumes the builder and constructs a [`GetGroupInput`](crate::input::GetGroupInput)
        pub fn build(
            self,
        ) -> Result<crate::input::GetGroupInput, smithy_http::operation::BuildError> {
            Ok(crate::input::GetGroupInput {
                group_name: self.group_name,
                marker: self.marker,
                max_items: self.max_items,
            })
        }
    }
}
#[doc(hidden)]
pub type GetGroupInputOperationOutputAlias = crate::operation::GetGroup;
#[doc(hidden)]
pub type GetGroupInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl GetGroupInput {
    /// Consumes the builder and constructs an Operation<[`GetGroup`](crate::operation::GetGroup)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> Result<
        smithy_http::operation::Operation<
            crate::operation::GetGroup,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body =
                crate::operation_ser::serialize_operation_get_group(&self).map_err(|err| {
                    smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op =
                smithy_http::operation::Operation::new(request, crate::operation::GetGroup::new())
                    .with_metadata(smithy_http::operation::Metadata::new("GetGroup", "iam"));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) {
        write!(output, "/").expect("formatting should succeed")
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri);
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let builder = http::request::Builder::new();
        let builder = builder.header("Content-Type", "application/x-www-form-urlencoded");
        self.update_http_builder(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`GetGroupInput`](crate::input::GetGroupInput)
    pub fn builder() -> crate::input::get_group_input::Builder {
        crate::input::get_group_input::Builder::default()
    }
}

/// See [`GetGroupPolicyInput`](crate::input::GetGroupPolicyInput)
pub mod get_group_policy_input {
    /// A builder for [`GetGroupPolicyInput`](crate::input::GetGroupPolicyInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) group_name: std::option::Option<std::string::String>,
        pub(crate) policy_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the group the policy is associated with.</p>
        /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
        /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
        pub fn group_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.group_name = Some(inp.into());
            self
        }
        pub fn set_group_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.group_name = inp;
            self
        }
        /// <p>The name of the policy document to get.</p>
        /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
        /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
        pub fn policy_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.policy_name = Some(inp.into());
            self
        }
        pub fn set_policy_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.policy_name = inp;
            self
        }
        /// Consumes the builder and constructs a [`GetGroupPolicyInput`](crate::input::GetGroupPolicyInput)
        pub fn build(
            self,
        ) -> Result<crate::input::GetGroupPolicyInput, smithy_http::operation::BuildError> {
            Ok(crate::input::GetGroupPolicyInput {
                group_name: self.group_name,
                policy_name: self.policy_name,
            })
        }
    }
}
#[doc(hidden)]
pub type GetGroupPolicyInputOperationOutputAlias = crate::operation::GetGroupPolicy;
#[doc(hidden)]
pub type GetGroupPolicyInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl GetGroupPolicyInput {
    /// Consumes the builder and constructs an Operation<[`GetGroupPolicy`](crate::operation::GetGroupPolicy)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> Result<
        smithy_http::operation::Operation<
            crate::operation::GetGroupPolicy,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = crate::operation_ser::serialize_operation_get_group_policy(&self).map_err(
                |err| smithy_http::operation::BuildError::SerializationError(err.into()),
            )?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::GetGroupPolicy::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "GetGroupPolicy",
                "iam",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) {
        write!(output, "/").expect("formatting should succeed")
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri);
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let builder = http::request::Builder::new();
        let builder = builder.header("Content-Type", "application/x-www-form-urlencoded");
        self.update_http_builder(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`GetGroupPolicyInput`](crate::input::GetGroupPolicyInput)
    pub fn builder() -> crate::input::get_group_policy_input::Builder {
        crate::input::get_group_policy_input::Builder::default()
    }
}

/// See [`GetInstanceProfileInput`](crate::input::GetInstanceProfileInput)
pub mod get_instance_profile_input {
    /// A builder for [`GetInstanceProfileInput`](crate::input::GetInstanceProfileInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) instance_profile_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the instance profile to get information about.</p>
        /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
        /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
        pub fn instance_profile_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.instance_profile_name = Some(inp.into());
            self
        }
        pub fn set_instance_profile_name(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.instance_profile_name = inp;
            self
        }
        /// Consumes the builder and constructs a [`GetInstanceProfileInput`](crate::input::GetInstanceProfileInput)
        pub fn build(
            self,
        ) -> Result<crate::input::GetInstanceProfileInput, smithy_http::operation::BuildError>
        {
            Ok(crate::input::GetInstanceProfileInput {
                instance_profile_name: self.instance_profile_name,
            })
        }
    }
}
#[doc(hidden)]
pub type GetInstanceProfileInputOperationOutputAlias = crate::operation::GetInstanceProfile;
#[doc(hidden)]
pub type GetInstanceProfileInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl GetInstanceProfileInput {
    /// Consumes the builder and constructs an Operation<[`GetInstanceProfile`](crate::operation::GetInstanceProfile)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> Result<
        smithy_http::operation::Operation<
            crate::operation::GetInstanceProfile,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = crate::operation_ser::serialize_operation_get_instance_profile(&self)
                .map_err(|err| {
                    smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::GetInstanceProfile::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "GetInstanceProfile",
                "iam",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) {
        write!(output, "/").expect("formatting should succeed")
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri);
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let builder = http::request::Builder::new();
        let builder = builder.header("Content-Type", "application/x-www-form-urlencoded");
        self.update_http_builder(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`GetInstanceProfileInput`](crate::input::GetInstanceProfileInput)
    pub fn builder() -> crate::input::get_instance_profile_input::Builder {
        crate::input::get_instance_profile_input::Builder::default()
    }
}

/// See [`GetLoginProfileInput`](crate::input::GetLoginProfileInput)
pub mod get_login_profile_input {
    /// A builder for [`GetLoginProfileInput`](crate::input::GetLoginProfileInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) user_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the user whose login profile you want to retrieve.</p>
        /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
        /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
        pub fn user_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.user_name = Some(inp.into());
            self
        }
        pub fn set_user_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.user_name = inp;
            self
        }
        /// Consumes the builder and constructs a [`GetLoginProfileInput`](crate::input::GetLoginProfileInput)
        pub fn build(
            self,
        ) -> Result<crate::input::GetLoginProfileInput, smithy_http::operation::BuildError>
        {
            Ok(crate::input::GetLoginProfileInput {
                user_name: self.user_name,
            })
        }
    }
}
#[doc(hidden)]
pub type GetLoginProfileInputOperationOutputAlias = crate::operation::GetLoginProfile;
#[doc(hidden)]
pub type GetLoginProfileInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl GetLoginProfileInput {
    /// Consumes the builder and constructs an Operation<[`GetLoginProfile`](crate::operation::GetLoginProfile)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> Result<
        smithy_http::operation::Operation<
            crate::operation::GetLoginProfile,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = crate::operation_ser::serialize_operation_get_login_profile(&self).map_err(
                |err| smithy_http::operation::BuildError::SerializationError(err.into()),
            )?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::GetLoginProfile::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "GetLoginProfile",
                "iam",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) {
        write!(output, "/").expect("formatting should succeed")
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri);
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let builder = http::request::Builder::new();
        let builder = builder.header("Content-Type", "application/x-www-form-urlencoded");
        self.update_http_builder(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`GetLoginProfileInput`](crate::input::GetLoginProfileInput)
    pub fn builder() -> crate::input::get_login_profile_input::Builder {
        crate::input::get_login_profile_input::Builder::default()
    }
}

/// See [`GetOpenIDConnectProviderInput`](crate::input::GetOpenIDConnectProviderInput)
pub mod get_open_id_connect_provider_input {
    /// A builder for [`GetOpenIDConnectProviderInput`](crate::input::GetOpenIDConnectProviderInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) open_id_connect_provider_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the OIDC provider resource object in IAM to get
        /// information for. You can get a list of OIDC provider resource ARNs by using the <a>ListOpenIDConnectProviders</a> operation.</p>
        /// <p>For more information about ARNs, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">Amazon Resource Names (ARNs)</a> in the <i>AWS General Reference</i>.</p>
        pub fn open_id_connect_provider_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.open_id_connect_provider_arn = Some(inp.into());
            self
        }
        pub fn set_open_id_connect_provider_arn(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.open_id_connect_provider_arn = inp;
            self
        }
        /// Consumes the builder and constructs a [`GetOpenIDConnectProviderInput`](crate::input::GetOpenIDConnectProviderInput)
        pub fn build(
            self,
        ) -> Result<crate::input::GetOpenIDConnectProviderInput, smithy_http::operation::BuildError>
        {
            Ok(crate::input::GetOpenIDConnectProviderInput {
                open_id_connect_provider_arn: self.open_id_connect_provider_arn,
            })
        }
    }
}
#[doc(hidden)]
pub type GetOpenIDConnectProviderInputOperationOutputAlias =
    crate::operation::GetOpenIDConnectProvider;
#[doc(hidden)]
pub type GetOpenIDConnectProviderInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl GetOpenIDConnectProviderInput {
    /// Consumes the builder and constructs an Operation<[`GetOpenIDConnectProvider`](crate::operation::GetOpenIDConnectProvider)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> Result<
        smithy_http::operation::Operation<
            crate::operation::GetOpenIDConnectProvider,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body =
                crate::operation_ser::serialize_operation_get_open_id_connect_provider(&self)
                    .map_err(|err| {
                        smithy_http::operation::BuildError::SerializationError(err.into())
                    })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::GetOpenIDConnectProvider::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "GetOpenIDConnectProvider",
                "iam",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) {
        write!(output, "/").expect("formatting should succeed")
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri);
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let builder = http::request::Builder::new();
        let builder = builder.header("Content-Type", "application/x-www-form-urlencoded");
        self.update_http_builder(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`GetOpenIDConnectProviderInput`](crate::input::GetOpenIDConnectProviderInput)
    pub fn builder() -> crate::input::get_open_id_connect_provider_input::Builder {
        crate::input::get_open_id_connect_provider_input::Builder::default()
    }
}

/// See [`GetOrganizationsAccessReportInput`](crate::input::GetOrganizationsAccessReportInput)
pub mod get_organizations_access_report_input {
    /// A builder for [`GetOrganizationsAccessReportInput`](crate::input::GetOrganizationsAccessReportInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) job_id: std::option::Option<std::string::String>,
        pub(crate) max_items: std::option::Option<i32>,
        pub(crate) marker: std::option::Option<std::string::String>,
        pub(crate) sort_key: std::option::Option<crate::model::SortKeyType>,
    }
    impl Builder {
        /// <p>The identifier of the request generated by the <a>GenerateOrganizationsAccessReport</a> operation.</p>
        pub fn job_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.job_id = Some(inp.into());
            self
        }
        pub fn set_job_id(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.job_id = inp;
            self
        }
        /// <p>Use this only when paginating results to indicate the
        /// maximum number of items you want in the response. If additional items exist beyond the maximum
        /// you specify, the <code>IsTruncated</code> response element is <code>true</code>.</p>
        /// <p>If you do not include this parameter, the number of items defaults to 100. Note that
        /// IAM might return fewer results, even when there are more results available. In that case, the
        /// <code>IsTruncated</code> response element returns <code>true</code>, and <code>Marker</code>
        /// contains a value to include in the subsequent call that tells the service where to continue
        /// from.</p>
        pub fn max_items(mut self, inp: i32) -> Self {
            self.max_items = Some(inp);
            self
        }
        pub fn set_max_items(mut self, inp: std::option::Option<i32>) -> Self {
            self.max_items = inp;
            self
        }
        /// <p>Use this parameter only when paginating results and only after
        /// you receive a response indicating that the results are truncated. Set it to the value of the
        /// <code>Marker</code> element in the response that you received to indicate where the next call
        /// should start.</p>
        pub fn marker(mut self, inp: impl Into<std::string::String>) -> Self {
            self.marker = Some(inp.into());
            self
        }
        pub fn set_marker(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.marker = inp;
            self
        }
        /// <p>The key that is used to sort the results. If you choose the namespace key, the results
        /// are returned in alphabetical order. If you choose the time key, the results are sorted
        /// numerically by the date and time.</p>
        pub fn sort_key(mut self, inp: crate::model::SortKeyType) -> Self {
            self.sort_key = Some(inp);
            self
        }
        pub fn set_sort_key(mut self, inp: std::option::Option<crate::model::SortKeyType>) -> Self {
            self.sort_key = inp;
            self
        }
        /// Consumes the builder and constructs a [`GetOrganizationsAccessReportInput`](crate::input::GetOrganizationsAccessReportInput)
        pub fn build(
            self,
        ) -> Result<
            crate::input::GetOrganizationsAccessReportInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::GetOrganizationsAccessReportInput {
                job_id: self.job_id,
                max_items: self.max_items,
                marker: self.marker,
                sort_key: self.sort_key,
            })
        }
    }
}
#[doc(hidden)]
pub type GetOrganizationsAccessReportInputOperationOutputAlias =
    crate::operation::GetOrganizationsAccessReport;
#[doc(hidden)]
pub type GetOrganizationsAccessReportInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl GetOrganizationsAccessReportInput {
    /// Consumes the builder and constructs an Operation<[`GetOrganizationsAccessReport`](crate::operation::GetOrganizationsAccessReport)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> Result<
        smithy_http::operation::Operation<
            crate::operation::GetOrganizationsAccessReport,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body =
                crate::operation_ser::serialize_operation_get_organizations_access_report(&self)
                    .map_err(|err| {
                        smithy_http::operation::BuildError::SerializationError(err.into())
                    })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::GetOrganizationsAccessReport::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "GetOrganizationsAccessReport",
                "iam",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) {
        write!(output, "/").expect("formatting should succeed")
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri);
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let builder = http::request::Builder::new();
        let builder = builder.header("Content-Type", "application/x-www-form-urlencoded");
        self.update_http_builder(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`GetOrganizationsAccessReportInput`](crate::input::GetOrganizationsAccessReportInput)
    pub fn builder() -> crate::input::get_organizations_access_report_input::Builder {
        crate::input::get_organizations_access_report_input::Builder::default()
    }
}

/// See [`GetPolicyInput`](crate::input::GetPolicyInput)
pub mod get_policy_input {
    /// A builder for [`GetPolicyInput`](crate::input::GetPolicyInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) policy_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the managed policy that you want information
        /// about.</p>
        /// <p>For more information about ARNs, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">Amazon Resource Names (ARNs)</a> in the <i>AWS General Reference</i>.</p>
        pub fn policy_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.policy_arn = Some(inp.into());
            self
        }
        pub fn set_policy_arn(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.policy_arn = inp;
            self
        }
        /// Consumes the builder and constructs a [`GetPolicyInput`](crate::input::GetPolicyInput)
        pub fn build(
            self,
        ) -> Result<crate::input::GetPolicyInput, smithy_http::operation::BuildError> {
            Ok(crate::input::GetPolicyInput {
                policy_arn: self.policy_arn,
            })
        }
    }
}
#[doc(hidden)]
pub type GetPolicyInputOperationOutputAlias = crate::operation::GetPolicy;
#[doc(hidden)]
pub type GetPolicyInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl GetPolicyInput {
    /// Consumes the builder and constructs an Operation<[`GetPolicy`](crate::operation::GetPolicy)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> Result<
        smithy_http::operation::Operation<
            crate::operation::GetPolicy,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body =
                crate::operation_ser::serialize_operation_get_policy(&self).map_err(|err| {
                    smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op =
                smithy_http::operation::Operation::new(request, crate::operation::GetPolicy::new())
                    .with_metadata(smithy_http::operation::Metadata::new("GetPolicy", "iam"));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) {
        write!(output, "/").expect("formatting should succeed")
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri);
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let builder = http::request::Builder::new();
        let builder = builder.header("Content-Type", "application/x-www-form-urlencoded");
        self.update_http_builder(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`GetPolicyInput`](crate::input::GetPolicyInput)
    pub fn builder() -> crate::input::get_policy_input::Builder {
        crate::input::get_policy_input::Builder::default()
    }
}

/// See [`GetPolicyVersionInput`](crate::input::GetPolicyVersionInput)
pub mod get_policy_version_input {
    /// A builder for [`GetPolicyVersionInput`](crate::input::GetPolicyVersionInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) policy_arn: std::option::Option<std::string::String>,
        pub(crate) version_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the managed policy that you want information
        /// about.</p>
        /// <p>For more information about ARNs, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">Amazon Resource Names (ARNs)</a> in the <i>AWS General Reference</i>.</p>
        pub fn policy_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.policy_arn = Some(inp.into());
            self
        }
        pub fn set_policy_arn(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.policy_arn = inp;
            self
        }
        /// <p>Identifies the policy version to retrieve.</p>
        /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters that
        /// consists of the lowercase letter 'v' followed by one or two digits, and optionally
        /// followed by a period '.' and a string of letters and digits.</p>
        pub fn version_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.version_id = Some(inp.into());
            self
        }
        pub fn set_version_id(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.version_id = inp;
            self
        }
        /// Consumes the builder and constructs a [`GetPolicyVersionInput`](crate::input::GetPolicyVersionInput)
        pub fn build(
            self,
        ) -> Result<crate::input::GetPolicyVersionInput, smithy_http::operation::BuildError>
        {
            Ok(crate::input::GetPolicyVersionInput {
                policy_arn: self.policy_arn,
                version_id: self.version_id,
            })
        }
    }
}
#[doc(hidden)]
pub type GetPolicyVersionInputOperationOutputAlias = crate::operation::GetPolicyVersion;
#[doc(hidden)]
pub type GetPolicyVersionInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl GetPolicyVersionInput {
    /// Consumes the builder and constructs an Operation<[`GetPolicyVersion`](crate::operation::GetPolicyVersion)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> Result<
        smithy_http::operation::Operation<
            crate::operation::GetPolicyVersion,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = crate::operation_ser::serialize_operation_get_policy_version(&self)
                .map_err(|err| {
                    smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::GetPolicyVersion::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "GetPolicyVersion",
                "iam",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) {
        write!(output, "/").expect("formatting should succeed")
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri);
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let builder = http::request::Builder::new();
        let builder = builder.header("Content-Type", "application/x-www-form-urlencoded");
        self.update_http_builder(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`GetPolicyVersionInput`](crate::input::GetPolicyVersionInput)
    pub fn builder() -> crate::input::get_policy_version_input::Builder {
        crate::input::get_policy_version_input::Builder::default()
    }
}

/// See [`GetRoleInput`](crate::input::GetRoleInput)
pub mod get_role_input {
    /// A builder for [`GetRoleInput`](crate::input::GetRoleInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) role_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the IAM role to get information about.</p>
        /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
        /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
        pub fn role_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.role_name = Some(inp.into());
            self
        }
        pub fn set_role_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.role_name = inp;
            self
        }
        /// Consumes the builder and constructs a [`GetRoleInput`](crate::input::GetRoleInput)
        pub fn build(
            self,
        ) -> Result<crate::input::GetRoleInput, smithy_http::operation::BuildError> {
            Ok(crate::input::GetRoleInput {
                role_name: self.role_name,
            })
        }
    }
}
#[doc(hidden)]
pub type GetRoleInputOperationOutputAlias = crate::operation::GetRole;
#[doc(hidden)]
pub type GetRoleInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl GetRoleInput {
    /// Consumes the builder and constructs an Operation<[`GetRole`](crate::operation::GetRole)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> Result<
        smithy_http::operation::Operation<crate::operation::GetRole, aws_http::AwsErrorRetryPolicy>,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body =
                crate::operation_ser::serialize_operation_get_role(&self).map_err(|err| {
                    smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op =
                smithy_http::operation::Operation::new(request, crate::operation::GetRole::new())
                    .with_metadata(smithy_http::operation::Metadata::new("GetRole", "iam"));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) {
        write!(output, "/").expect("formatting should succeed")
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri);
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let builder = http::request::Builder::new();
        let builder = builder.header("Content-Type", "application/x-www-form-urlencoded");
        self.update_http_builder(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`GetRoleInput`](crate::input::GetRoleInput)
    pub fn builder() -> crate::input::get_role_input::Builder {
        crate::input::get_role_input::Builder::default()
    }
}

/// See [`GetRolePolicyInput`](crate::input::GetRolePolicyInput)
pub mod get_role_policy_input {
    /// A builder for [`GetRolePolicyInput`](crate::input::GetRolePolicyInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) role_name: std::option::Option<std::string::String>,
        pub(crate) policy_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the role associated with the policy.</p>
        /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
        /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
        pub fn role_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.role_name = Some(inp.into());
            self
        }
        pub fn set_role_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.role_name = inp;
            self
        }
        /// <p>The name of the policy document to get.</p>
        /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
        /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
        pub fn policy_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.policy_name = Some(inp.into());
            self
        }
        pub fn set_policy_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.policy_name = inp;
            self
        }
        /// Consumes the builder and constructs a [`GetRolePolicyInput`](crate::input::GetRolePolicyInput)
        pub fn build(
            self,
        ) -> Result<crate::input::GetRolePolicyInput, smithy_http::operation::BuildError> {
            Ok(crate::input::GetRolePolicyInput {
                role_name: self.role_name,
                policy_name: self.policy_name,
            })
        }
    }
}
#[doc(hidden)]
pub type GetRolePolicyInputOperationOutputAlias = crate::operation::GetRolePolicy;
#[doc(hidden)]
pub type GetRolePolicyInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl GetRolePolicyInput {
    /// Consumes the builder and constructs an Operation<[`GetRolePolicy`](crate::operation::GetRolePolicy)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> Result<
        smithy_http::operation::Operation<
            crate::operation::GetRolePolicy,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = crate::operation_ser::serialize_operation_get_role_policy(&self).map_err(
                |err| smithy_http::operation::BuildError::SerializationError(err.into()),
            )?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::GetRolePolicy::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "GetRolePolicy",
                "iam",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) {
        write!(output, "/").expect("formatting should succeed")
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri);
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let builder = http::request::Builder::new();
        let builder = builder.header("Content-Type", "application/x-www-form-urlencoded");
        self.update_http_builder(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`GetRolePolicyInput`](crate::input::GetRolePolicyInput)
    pub fn builder() -> crate::input::get_role_policy_input::Builder {
        crate::input::get_role_policy_input::Builder::default()
    }
}

/// See [`GetSAMLProviderInput`](crate::input::GetSAMLProviderInput)
pub mod get_saml_provider_input {
    /// A builder for [`GetSAMLProviderInput`](crate::input::GetSAMLProviderInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) saml_provider_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the SAML provider resource object in IAM to get
        /// information about.</p>
        /// <p>For more information about ARNs, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">Amazon Resource Names (ARNs)</a> in the <i>AWS General Reference</i>.</p>
        pub fn saml_provider_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.saml_provider_arn = Some(inp.into());
            self
        }
        pub fn set_saml_provider_arn(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.saml_provider_arn = inp;
            self
        }
        /// Consumes the builder and constructs a [`GetSAMLProviderInput`](crate::input::GetSAMLProviderInput)
        pub fn build(
            self,
        ) -> Result<crate::input::GetSAMLProviderInput, smithy_http::operation::BuildError>
        {
            Ok(crate::input::GetSAMLProviderInput {
                saml_provider_arn: self.saml_provider_arn,
            })
        }
    }
}
#[doc(hidden)]
pub type GetSAMLProviderInputOperationOutputAlias = crate::operation::GetSAMLProvider;
#[doc(hidden)]
pub type GetSAMLProviderInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl GetSAMLProviderInput {
    /// Consumes the builder and constructs an Operation<[`GetSAMLProvider`](crate::operation::GetSAMLProvider)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> Result<
        smithy_http::operation::Operation<
            crate::operation::GetSAMLProvider,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = crate::operation_ser::serialize_operation_get_saml_provider(&self).map_err(
                |err| smithy_http::operation::BuildError::SerializationError(err.into()),
            )?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::GetSAMLProvider::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "GetSAMLProvider",
                "iam",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) {
        write!(output, "/").expect("formatting should succeed")
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri);
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let builder = http::request::Builder::new();
        let builder = builder.header("Content-Type", "application/x-www-form-urlencoded");
        self.update_http_builder(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`GetSAMLProviderInput`](crate::input::GetSAMLProviderInput)
    pub fn builder() -> crate::input::get_saml_provider_input::Builder {
        crate::input::get_saml_provider_input::Builder::default()
    }
}

/// See [`GetServerCertificateInput`](crate::input::GetServerCertificateInput)
pub mod get_server_certificate_input {
    /// A builder for [`GetServerCertificateInput`](crate::input::GetServerCertificateInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) server_certificate_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the server certificate you want to retrieve information about.</p>
        /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
        /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
        pub fn server_certificate_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.server_certificate_name = Some(inp.into());
            self
        }
        pub fn set_server_certificate_name(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.server_certificate_name = inp;
            self
        }
        /// Consumes the builder and constructs a [`GetServerCertificateInput`](crate::input::GetServerCertificateInput)
        pub fn build(
            self,
        ) -> Result<crate::input::GetServerCertificateInput, smithy_http::operation::BuildError>
        {
            Ok(crate::input::GetServerCertificateInput {
                server_certificate_name: self.server_certificate_name,
            })
        }
    }
}
#[doc(hidden)]
pub type GetServerCertificateInputOperationOutputAlias = crate::operation::GetServerCertificate;
#[doc(hidden)]
pub type GetServerCertificateInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl GetServerCertificateInput {
    /// Consumes the builder and constructs an Operation<[`GetServerCertificate`](crate::operation::GetServerCertificate)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> Result<
        smithy_http::operation::Operation<
            crate::operation::GetServerCertificate,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = crate::operation_ser::serialize_operation_get_server_certificate(&self)
                .map_err(|err| {
                    smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::GetServerCertificate::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "GetServerCertificate",
                "iam",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) {
        write!(output, "/").expect("formatting should succeed")
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri);
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let builder = http::request::Builder::new();
        let builder = builder.header("Content-Type", "application/x-www-form-urlencoded");
        self.update_http_builder(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`GetServerCertificateInput`](crate::input::GetServerCertificateInput)
    pub fn builder() -> crate::input::get_server_certificate_input::Builder {
        crate::input::get_server_certificate_input::Builder::default()
    }
}

/// See [`GetServiceLastAccessedDetailsInput`](crate::input::GetServiceLastAccessedDetailsInput)
pub mod get_service_last_accessed_details_input {
    /// A builder for [`GetServiceLastAccessedDetailsInput`](crate::input::GetServiceLastAccessedDetailsInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) job_id: std::option::Option<std::string::String>,
        pub(crate) max_items: std::option::Option<i32>,
        pub(crate) marker: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the request generated by the <a>GenerateServiceLastAccessedDetails</a> operation. The <code>JobId</code>
        /// returned by <code>GenerateServiceLastAccessedDetail</code> must be used by the same role
        /// within a session, or by the same user when used to call
        /// <code>GetServiceLastAccessedDetail</code>.</p>
        pub fn job_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.job_id = Some(inp.into());
            self
        }
        pub fn set_job_id(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.job_id = inp;
            self
        }
        /// <p>Use this only when paginating results to indicate the
        /// maximum number of items you want in the response. If additional items exist beyond the maximum
        /// you specify, the <code>IsTruncated</code> response element is <code>true</code>.</p>
        /// <p>If you do not include this parameter, the number of items defaults to 100. Note that
        /// IAM might return fewer results, even when there are more results available. In that case, the
        /// <code>IsTruncated</code> response element returns <code>true</code>, and <code>Marker</code>
        /// contains a value to include in the subsequent call that tells the service where to continue
        /// from.</p>
        pub fn max_items(mut self, inp: i32) -> Self {
            self.max_items = Some(inp);
            self
        }
        pub fn set_max_items(mut self, inp: std::option::Option<i32>) -> Self {
            self.max_items = inp;
            self
        }
        /// <p>Use this parameter only when paginating results and only after
        /// you receive a response indicating that the results are truncated. Set it to the value of the
        /// <code>Marker</code> element in the response that you received to indicate where the next call
        /// should start.</p>
        pub fn marker(mut self, inp: impl Into<std::string::String>) -> Self {
            self.marker = Some(inp.into());
            self
        }
        pub fn set_marker(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.marker = inp;
            self
        }
        /// Consumes the builder and constructs a [`GetServiceLastAccessedDetailsInput`](crate::input::GetServiceLastAccessedDetailsInput)
        pub fn build(
            self,
        ) -> Result<
            crate::input::GetServiceLastAccessedDetailsInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::GetServiceLastAccessedDetailsInput {
                job_id: self.job_id,
                max_items: self.max_items,
                marker: self.marker,
            })
        }
    }
}
#[doc(hidden)]
pub type GetServiceLastAccessedDetailsInputOperationOutputAlias =
    crate::operation::GetServiceLastAccessedDetails;
#[doc(hidden)]
pub type GetServiceLastAccessedDetailsInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl GetServiceLastAccessedDetailsInput {
    /// Consumes the builder and constructs an Operation<[`GetServiceLastAccessedDetails`](crate::operation::GetServiceLastAccessedDetails)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> Result<
        smithy_http::operation::Operation<
            crate::operation::GetServiceLastAccessedDetails,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body =
                crate::operation_ser::serialize_operation_get_service_last_accessed_details(&self)
                    .map_err(|err| {
                        smithy_http::operation::BuildError::SerializationError(err.into())
                    })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::GetServiceLastAccessedDetails::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "GetServiceLastAccessedDetails",
                "iam",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) {
        write!(output, "/").expect("formatting should succeed")
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri);
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let builder = http::request::Builder::new();
        let builder = builder.header("Content-Type", "application/x-www-form-urlencoded");
        self.update_http_builder(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`GetServiceLastAccessedDetailsInput`](crate::input::GetServiceLastAccessedDetailsInput)
    pub fn builder() -> crate::input::get_service_last_accessed_details_input::Builder {
        crate::input::get_service_last_accessed_details_input::Builder::default()
    }
}

/// See [`GetServiceLastAccessedDetailsWithEntitiesInput`](crate::input::GetServiceLastAccessedDetailsWithEntitiesInput)
pub mod get_service_last_accessed_details_with_entities_input {
    /// A builder for [`GetServiceLastAccessedDetailsWithEntitiesInput`](crate::input::GetServiceLastAccessedDetailsWithEntitiesInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) job_id: std::option::Option<std::string::String>,
        pub(crate) service_namespace: std::option::Option<std::string::String>,
        pub(crate) max_items: std::option::Option<i32>,
        pub(crate) marker: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the request generated by the <code>GenerateServiceLastAccessedDetails</code>
        /// operation.</p>
        pub fn job_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.job_id = Some(inp.into());
            self
        }
        pub fn set_job_id(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.job_id = inp;
            self
        }
        /// <p>The service namespace for an AWS service. Provide the service namespace to learn
        /// when the IAM entity last attempted to access the specified service.</p>
        /// <p>To learn the service namespace for a service, see <a href="https://docs.aws.amazon.com/service-authorization/latest/reference/reference_policies_actions-resources-contextkeys.html">Actions, resources, and condition keys for AWS services</a> in the
        /// <i>IAM User Guide</i>. Choose the name of the service to view
        /// details for that service. In the first paragraph, find the service prefix. For example,
        /// <code>(service prefix: a4b)</code>. For more information about service namespaces,
        /// see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html#genref-aws-service-namespaces">AWS
        /// service namespaces</a> in the <i>AWS General Reference</i>.</p>
        pub fn service_namespace(mut self, inp: impl Into<std::string::String>) -> Self {
            self.service_namespace = Some(inp.into());
            self
        }
        pub fn set_service_namespace(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.service_namespace = inp;
            self
        }
        /// <p>Use this only when paginating results to indicate the
        /// maximum number of items you want in the response. If additional items exist beyond the maximum
        /// you specify, the <code>IsTruncated</code> response element is <code>true</code>.</p>
        /// <p>If you do not include this parameter, the number of items defaults to 100. Note that
        /// IAM might return fewer results, even when there are more results available. In that case, the
        /// <code>IsTruncated</code> response element returns <code>true</code>, and <code>Marker</code>
        /// contains a value to include in the subsequent call that tells the service where to continue
        /// from.</p>
        pub fn max_items(mut self, inp: i32) -> Self {
            self.max_items = Some(inp);
            self
        }
        pub fn set_max_items(mut self, inp: std::option::Option<i32>) -> Self {
            self.max_items = inp;
            self
        }
        /// <p>Use this parameter only when paginating results and only after
        /// you receive a response indicating that the results are truncated. Set it to the value of the
        /// <code>Marker</code> element in the response that you received to indicate where the next call
        /// should start.</p>
        pub fn marker(mut self, inp: impl Into<std::string::String>) -> Self {
            self.marker = Some(inp.into());
            self
        }
        pub fn set_marker(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.marker = inp;
            self
        }
        /// Consumes the builder and constructs a [`GetServiceLastAccessedDetailsWithEntitiesInput`](crate::input::GetServiceLastAccessedDetailsWithEntitiesInput)
        pub fn build(
            self,
        ) -> Result<
            crate::input::GetServiceLastAccessedDetailsWithEntitiesInput,
            smithy_http::operation::BuildError,
        > {
            Ok(
                crate::input::GetServiceLastAccessedDetailsWithEntitiesInput {
                    job_id: self.job_id,
                    service_namespace: self.service_namespace,
                    max_items: self.max_items,
                    marker: self.marker,
                },
            )
        }
    }
}
#[doc(hidden)]
pub type GetServiceLastAccessedDetailsWithEntitiesInputOperationOutputAlias =
    crate::operation::GetServiceLastAccessedDetailsWithEntities;
#[doc(hidden)]
pub type GetServiceLastAccessedDetailsWithEntitiesInputOperationRetryAlias =
    aws_http::AwsErrorRetryPolicy;
impl GetServiceLastAccessedDetailsWithEntitiesInput {
    /// Consumes the builder and constructs an Operation<[`GetServiceLastAccessedDetailsWithEntities`](crate::operation::GetServiceLastAccessedDetailsWithEntities)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> Result<
        smithy_http::operation::Operation<
            crate::operation::GetServiceLastAccessedDetailsWithEntities,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body =
                crate::operation_ser::serialize_operation_get_service_last_accessed_details_with_entities(&self).map_err(|err|smithy_http::operation::BuildError::SerializationError(err.into()))?
            ;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::GetServiceLastAccessedDetailsWithEntities::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "GetServiceLastAccessedDetailsWithEntities",
                "iam",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) {
        write!(output, "/").expect("formatting should succeed")
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri);
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let builder = http::request::Builder::new();
        let builder = builder.header("Content-Type", "application/x-www-form-urlencoded");
        self.update_http_builder(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`GetServiceLastAccessedDetailsWithEntitiesInput`](crate::input::GetServiceLastAccessedDetailsWithEntitiesInput)
    pub fn builder() -> crate::input::get_service_last_accessed_details_with_entities_input::Builder
    {
        crate::input::get_service_last_accessed_details_with_entities_input::Builder::default()
    }
}

/// See [`GetServiceLinkedRoleDeletionStatusInput`](crate::input::GetServiceLinkedRoleDeletionStatusInput)
pub mod get_service_linked_role_deletion_status_input {
    /// A builder for [`GetServiceLinkedRoleDeletionStatusInput`](crate::input::GetServiceLinkedRoleDeletionStatusInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) deletion_task_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The deletion task identifier. This identifier is returned by the <a>DeleteServiceLinkedRole</a> operation in the format
        /// <code>task/aws-service-role/<service-principal-name>/<role-name>/<task-uuid></code>.</p>
        pub fn deletion_task_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.deletion_task_id = Some(inp.into());
            self
        }
        pub fn set_deletion_task_id(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.deletion_task_id = inp;
            self
        }
        /// Consumes the builder and constructs a [`GetServiceLinkedRoleDeletionStatusInput`](crate::input::GetServiceLinkedRoleDeletionStatusInput)
        pub fn build(
            self,
        ) -> Result<
            crate::input::GetServiceLinkedRoleDeletionStatusInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::GetServiceLinkedRoleDeletionStatusInput {
                deletion_task_id: self.deletion_task_id,
            })
        }
    }
}
#[doc(hidden)]
pub type GetServiceLinkedRoleDeletionStatusInputOperationOutputAlias =
    crate::operation::GetServiceLinkedRoleDeletionStatus;
#[doc(hidden)]
pub type GetServiceLinkedRoleDeletionStatusInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl GetServiceLinkedRoleDeletionStatusInput {
    /// Consumes the builder and constructs an Operation<[`GetServiceLinkedRoleDeletionStatus`](crate::operation::GetServiceLinkedRoleDeletionStatus)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> Result<
        smithy_http::operation::Operation<
            crate::operation::GetServiceLinkedRoleDeletionStatus,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body =
                crate::operation_ser::serialize_operation_get_service_linked_role_deletion_status(
                    &self,
                )
                .map_err(|err| {
                    smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::GetServiceLinkedRoleDeletionStatus::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "GetServiceLinkedRoleDeletionStatus",
                "iam",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) {
        write!(output, "/").expect("formatting should succeed")
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri);
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let builder = http::request::Builder::new();
        let builder = builder.header("Content-Type", "application/x-www-form-urlencoded");
        self.update_http_builder(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`GetServiceLinkedRoleDeletionStatusInput`](crate::input::GetServiceLinkedRoleDeletionStatusInput)
    pub fn builder() -> crate::input::get_service_linked_role_deletion_status_input::Builder {
        crate::input::get_service_linked_role_deletion_status_input::Builder::default()
    }
}

/// See [`GetSSHPublicKeyInput`](crate::input::GetSSHPublicKeyInput)
pub mod get_ssh_public_key_input {
    /// A builder for [`GetSSHPublicKeyInput`](crate::input::GetSSHPublicKeyInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) user_name: std::option::Option<std::string::String>,
        pub(crate) ssh_public_key_id: std::option::Option<std::string::String>,
        pub(crate) encoding: std::option::Option<crate::model::EncodingType>,
    }
    impl Builder {
        /// <p>The name of the IAM user associated with the SSH public key.</p>
        /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
        /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
        pub fn user_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.user_name = Some(inp.into());
            self
        }
        pub fn set_user_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.user_name = inp;
            self
        }
        /// <p>The unique identifier for the SSH public key.</p>
        /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters that can
        /// consist of any upper or lowercased letter or digit.</p>
        pub fn ssh_public_key_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.ssh_public_key_id = Some(inp.into());
            self
        }
        pub fn set_ssh_public_key_id(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.ssh_public_key_id = inp;
            self
        }
        /// <p>Specifies the public key encoding format to use in the response. To retrieve the
        /// public key in ssh-rsa format, use <code>SSH</code>. To retrieve the public key in PEM
        /// format, use <code>PEM</code>.</p>
        pub fn encoding(mut self, inp: crate::model::EncodingType) -> Self {
            self.encoding = Some(inp);
            self
        }
        pub fn set_encoding(
            mut self,
            inp: std::option::Option<crate::model::EncodingType>,
        ) -> Self {
            self.encoding = inp;
            self
        }
        /// Consumes the builder and constructs a [`GetSSHPublicKeyInput`](crate::input::GetSSHPublicKeyInput)
        pub fn build(
            self,
        ) -> Result<crate::input::GetSSHPublicKeyInput, smithy_http::operation::BuildError>
        {
            Ok(crate::input::GetSSHPublicKeyInput {
                user_name: self.user_name,
                ssh_public_key_id: self.ssh_public_key_id,
                encoding: self.encoding,
            })
        }
    }
}
#[doc(hidden)]
pub type GetSSHPublicKeyInputOperationOutputAlias = crate::operation::GetSSHPublicKey;
#[doc(hidden)]
pub type GetSSHPublicKeyInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl GetSSHPublicKeyInput {
    /// Consumes the builder and constructs an Operation<[`GetSSHPublicKey`](crate::operation::GetSSHPublicKey)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> Result<
        smithy_http::operation::Operation<
            crate::operation::GetSSHPublicKey,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = crate::operation_ser::serialize_operation_get_ssh_public_key(&self)
                .map_err(|err| {
                    smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::GetSSHPublicKey::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "GetSSHPublicKey",
                "iam",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) {
        write!(output, "/").expect("formatting should succeed")
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri);
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let builder = http::request::Builder::new();
        let builder = builder.header("Content-Type", "application/x-www-form-urlencoded");
        self.update_http_builder(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`GetSSHPublicKeyInput`](crate::input::GetSSHPublicKeyInput)
    pub fn builder() -> crate::input::get_ssh_public_key_input::Builder {
        crate::input::get_ssh_public_key_input::Builder::default()
    }
}

/// See [`GetUserInput`](crate::input::GetUserInput)
pub mod get_user_input {
    /// A builder for [`GetUserInput`](crate::input::GetUserInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) user_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the user to get information about.</p>
        /// <p>This parameter is optional. If it is not included, it defaults to the user making the
        /// request. This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
        /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
        pub fn user_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.user_name = Some(inp.into());
            self
        }
        pub fn set_user_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.user_name = inp;
            self
        }
        /// Consumes the builder and constructs a [`GetUserInput`](crate::input::GetUserInput)
        pub fn build(
            self,
        ) -> Result<crate::input::GetUserInput, smithy_http::operation::BuildError> {
            Ok(crate::input::GetUserInput {
                user_name: self.user_name,
            })
        }
    }
}
#[doc(hidden)]
pub type GetUserInputOperationOutputAlias = crate::operation::GetUser;
#[doc(hidden)]
pub type GetUserInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl GetUserInput {
    /// Consumes the builder and constructs an Operation<[`GetUser`](crate::operation::GetUser)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> Result<
        smithy_http::operation::Operation<crate::operation::GetUser, aws_http::AwsErrorRetryPolicy>,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body =
                crate::operation_ser::serialize_operation_get_user(&self).map_err(|err| {
                    smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op =
                smithy_http::operation::Operation::new(request, crate::operation::GetUser::new())
                    .with_metadata(smithy_http::operation::Metadata::new("GetUser", "iam"));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) {
        write!(output, "/").expect("formatting should succeed")
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri);
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let builder = http::request::Builder::new();
        let builder = builder.header("Content-Type", "application/x-www-form-urlencoded");
        self.update_http_builder(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`GetUserInput`](crate::input::GetUserInput)
    pub fn builder() -> crate::input::get_user_input::Builder {
        crate::input::get_user_input::Builder::default()
    }
}

/// See [`GetUserPolicyInput`](crate::input::GetUserPolicyInput)
pub mod get_user_policy_input {
    /// A builder for [`GetUserPolicyInput`](crate::input::GetUserPolicyInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) user_name: std::option::Option<std::string::String>,
        pub(crate) policy_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the user who the policy is associated with.</p>
        /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
        /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
        pub fn user_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.user_name = Some(inp.into());
            self
        }
        pub fn set_user_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.user_name = inp;
            self
        }
        /// <p>The name of the policy document to get.</p>
        /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
        /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
        pub fn policy_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.policy_name = Some(inp.into());
            self
        }
        pub fn set_policy_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.policy_name = inp;
            self
        }
        /// Consumes the builder and constructs a [`GetUserPolicyInput`](crate::input::GetUserPolicyInput)
        pub fn build(
            self,
        ) -> Result<crate::input::GetUserPolicyInput, smithy_http::operation::BuildError> {
            Ok(crate::input::GetUserPolicyInput {
                user_name: self.user_name,
                policy_name: self.policy_name,
            })
        }
    }
}
#[doc(hidden)]
pub type GetUserPolicyInputOperationOutputAlias = crate::operation::GetUserPolicy;
#[doc(hidden)]
pub type GetUserPolicyInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl GetUserPolicyInput {
    /// Consumes the builder and constructs an Operation<[`GetUserPolicy`](crate::operation::GetUserPolicy)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> Result<
        smithy_http::operation::Operation<
            crate::operation::GetUserPolicy,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = crate::operation_ser::serialize_operation_get_user_policy(&self).map_err(
                |err| smithy_http::operation::BuildError::SerializationError(err.into()),
            )?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::GetUserPolicy::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "GetUserPolicy",
                "iam",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) {
        write!(output, "/").expect("formatting should succeed")
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri);
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let builder = http::request::Builder::new();
        let builder = builder.header("Content-Type", "application/x-www-form-urlencoded");
        self.update_http_builder(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`GetUserPolicyInput`](crate::input::GetUserPolicyInput)
    pub fn builder() -> crate::input::get_user_policy_input::Builder {
        crate::input::get_user_policy_input::Builder::default()
    }
}

/// See [`ListAccessKeysInput`](crate::input::ListAccessKeysInput)
pub mod list_access_keys_input {
    /// A builder for [`ListAccessKeysInput`](crate::input::ListAccessKeysInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) user_name: std::option::Option<std::string::String>,
        pub(crate) marker: std::option::Option<std::string::String>,
        pub(crate) max_items: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The name of the user.</p>
        /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
        /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
        pub fn user_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.user_name = Some(inp.into());
            self
        }
        pub fn set_user_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.user_name = inp;
            self
        }
        /// <p>Use this parameter only when paginating results and only after
        /// you receive a response indicating that the results are truncated. Set it to the value of the
        /// <code>Marker</code> element in the response that you received to indicate where the next call
        /// should start.</p>
        pub fn marker(mut self, inp: impl Into<std::string::String>) -> Self {
            self.marker = Some(inp.into());
            self
        }
        pub fn set_marker(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.marker = inp;
            self
        }
        /// <p>Use this only when paginating results to indicate the
        /// maximum number of items you want in the response. If additional items exist beyond the maximum
        /// you specify, the <code>IsTruncated</code> response element is <code>true</code>.</p>
        /// <p>If you do not include this parameter, the number of items defaults to 100. Note that
        /// IAM might return fewer results, even when there are more results available. In that case, the
        /// <code>IsTruncated</code> response element returns <code>true</code>, and <code>Marker</code>
        /// contains a value to include in the subsequent call that tells the service where to continue
        /// from.</p>
        pub fn max_items(mut self, inp: i32) -> Self {
            self.max_items = Some(inp);
            self
        }
        pub fn set_max_items(mut self, inp: std::option::Option<i32>) -> Self {
            self.max_items = inp;
            self
        }
        /// Consumes the builder and constructs a [`ListAccessKeysInput`](crate::input::ListAccessKeysInput)
        pub fn build(
            self,
        ) -> Result<crate::input::ListAccessKeysInput, smithy_http::operation::BuildError> {
            Ok(crate::input::ListAccessKeysInput {
                user_name: self.user_name,
                marker: self.marker,
                max_items: self.max_items,
            })
        }
    }
}
#[doc(hidden)]
pub type ListAccessKeysInputOperationOutputAlias = crate::operation::ListAccessKeys;
#[doc(hidden)]
pub type ListAccessKeysInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl ListAccessKeysInput {
    /// Consumes the builder and constructs an Operation<[`ListAccessKeys`](crate::operation::ListAccessKeys)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> Result<
        smithy_http::operation::Operation<
            crate::operation::ListAccessKeys,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = crate::operation_ser::serialize_operation_list_access_keys(&self).map_err(
                |err| smithy_http::operation::BuildError::SerializationError(err.into()),
            )?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::ListAccessKeys::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "ListAccessKeys",
                "iam",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) {
        write!(output, "/").expect("formatting should succeed")
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri);
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let builder = http::request::Builder::new();
        let builder = builder.header("Content-Type", "application/x-www-form-urlencoded");
        self.update_http_builder(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`ListAccessKeysInput`](crate::input::ListAccessKeysInput)
    pub fn builder() -> crate::input::list_access_keys_input::Builder {
        crate::input::list_access_keys_input::Builder::default()
    }
}

/// See [`ListAccountAliasesInput`](crate::input::ListAccountAliasesInput)
pub mod list_account_aliases_input {
    /// A builder for [`ListAccountAliasesInput`](crate::input::ListAccountAliasesInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) marker: std::option::Option<std::string::String>,
        pub(crate) max_items: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>Use this parameter only when paginating results and only after
        /// you receive a response indicating that the results are truncated. Set it to the value of the
        /// <code>Marker</code> element in the response that you received to indicate where the next call
        /// should start.</p>
        pub fn marker(mut self, inp: impl Into<std::string::String>) -> Self {
            self.marker = Some(inp.into());
            self
        }
        pub fn set_marker(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.marker = inp;
            self
        }
        /// <p>Use this only when paginating results to indicate the
        /// maximum number of items you want in the response. If additional items exist beyond the maximum
        /// you specify, the <code>IsTruncated</code> response element is <code>true</code>.</p>
        /// <p>If you do not include this parameter, the number of items defaults to 100. Note that
        /// IAM might return fewer results, even when there are more results available. In that case, the
        /// <code>IsTruncated</code> response element returns <code>true</code>, and <code>Marker</code>
        /// contains a value to include in the subsequent call that tells the service where to continue
        /// from.</p>
        pub fn max_items(mut self, inp: i32) -> Self {
            self.max_items = Some(inp);
            self
        }
        pub fn set_max_items(mut self, inp: std::option::Option<i32>) -> Self {
            self.max_items = inp;
            self
        }
        /// Consumes the builder and constructs a [`ListAccountAliasesInput`](crate::input::ListAccountAliasesInput)
        pub fn build(
            self,
        ) -> Result<crate::input::ListAccountAliasesInput, smithy_http::operation::BuildError>
        {
            Ok(crate::input::ListAccountAliasesInput {
                marker: self.marker,
                max_items: self.max_items,
            })
        }
    }
}
#[doc(hidden)]
pub type ListAccountAliasesInputOperationOutputAlias = crate::operation::ListAccountAliases;
#[doc(hidden)]
pub type ListAccountAliasesInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl ListAccountAliasesInput {
    /// Consumes the builder and constructs an Operation<[`ListAccountAliases`](crate::operation::ListAccountAliases)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> Result<
        smithy_http::operation::Operation<
            crate::operation::ListAccountAliases,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = crate::operation_ser::serialize_operation_list_account_aliases(&self)
                .map_err(|err| {
                    smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::ListAccountAliases::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "ListAccountAliases",
                "iam",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) {
        write!(output, "/").expect("formatting should succeed")
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri);
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let builder = http::request::Builder::new();
        let builder = builder.header("Content-Type", "application/x-www-form-urlencoded");
        self.update_http_builder(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`ListAccountAliasesInput`](crate::input::ListAccountAliasesInput)
    pub fn builder() -> crate::input::list_account_aliases_input::Builder {
        crate::input::list_account_aliases_input::Builder::default()
    }
}

/// See [`ListAttachedGroupPoliciesInput`](crate::input::ListAttachedGroupPoliciesInput)
pub mod list_attached_group_policies_input {
    /// A builder for [`ListAttachedGroupPoliciesInput`](crate::input::ListAttachedGroupPoliciesInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) group_name: std::option::Option<std::string::String>,
        pub(crate) path_prefix: std::option::Option<std::string::String>,
        pub(crate) marker: std::option::Option<std::string::String>,
        pub(crate) max_items: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The name (friendly name, not ARN) of the group to list attached policies for.</p>
        /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
        /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
        pub fn group_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.group_name = Some(inp.into());
            self
        }
        pub fn set_group_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.group_name = inp;
            self
        }
        /// <p>The path prefix for filtering the results. This parameter is optional. If it is not
        /// included, it defaults to a slash (/), listing all policies.</p>
        /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting
        /// of either a forward slash (/) by itself or a string that must begin and end with forward slashes.
        /// In addition, it can contain any ASCII character from the ! (<code>\u0021</code>) through the DEL character (<code>\u007F</code>), including
        /// most punctuation characters, digits, and upper and lowercased letters.</p>
        pub fn path_prefix(mut self, inp: impl Into<std::string::String>) -> Self {
            self.path_prefix = Some(inp.into());
            self
        }
        pub fn set_path_prefix(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.path_prefix = inp;
            self
        }
        /// <p>Use this parameter only when paginating results and only after
        /// you receive a response indicating that the results are truncated. Set it to the value of the
        /// <code>Marker</code> element in the response that you received to indicate where the next call
        /// should start.</p>
        pub fn marker(mut self, inp: impl Into<std::string::String>) -> Self {
            self.marker = Some(inp.into());
            self
        }
        pub fn set_marker(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.marker = inp;
            self
        }
        /// <p>Use this only when paginating results to indicate the
        /// maximum number of items you want in the response. If additional items exist beyond the maximum
        /// you specify, the <code>IsTruncated</code> response element is <code>true</code>.</p>
        /// <p>If you do not include this parameter, the number of items defaults to 100. Note that
        /// IAM might return fewer results, even when there are more results available. In that case, the
        /// <code>IsTruncated</code> response element returns <code>true</code>, and <code>Marker</code>
        /// contains a value to include in the subsequent call that tells the service where to continue
        /// from.</p>
        pub fn max_items(mut self, inp: i32) -> Self {
            self.max_items = Some(inp);
            self
        }
        pub fn set_max_items(mut self, inp: std::option::Option<i32>) -> Self {
            self.max_items = inp;
            self
        }
        /// Consumes the builder and constructs a [`ListAttachedGroupPoliciesInput`](crate::input::ListAttachedGroupPoliciesInput)
        pub fn build(
            self,
        ) -> Result<crate::input::ListAttachedGroupPoliciesInput, smithy_http::operation::BuildError>
        {
            Ok(crate::input::ListAttachedGroupPoliciesInput {
                group_name: self.group_name,
                path_prefix: self.path_prefix,
                marker: self.marker,
                max_items: self.max_items,
            })
        }
    }
}
#[doc(hidden)]
pub type ListAttachedGroupPoliciesInputOperationOutputAlias =
    crate::operation::ListAttachedGroupPolicies;
#[doc(hidden)]
pub type ListAttachedGroupPoliciesInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl ListAttachedGroupPoliciesInput {
    /// Consumes the builder and constructs an Operation<[`ListAttachedGroupPolicies`](crate::operation::ListAttachedGroupPolicies)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> Result<
        smithy_http::operation::Operation<
            crate::operation::ListAttachedGroupPolicies,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body =
                crate::operation_ser::serialize_operation_list_attached_group_policies(&self)
                    .map_err(|err| {
                        smithy_http::operation::BuildError::SerializationError(err.into())
                    })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::ListAttachedGroupPolicies::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "ListAttachedGroupPolicies",
                "iam",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) {
        write!(output, "/").expect("formatting should succeed")
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri);
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let builder = http::request::Builder::new();
        let builder = builder.header("Content-Type", "application/x-www-form-urlencoded");
        self.update_http_builder(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`ListAttachedGroupPoliciesInput`](crate::input::ListAttachedGroupPoliciesInput)
    pub fn builder() -> crate::input::list_attached_group_policies_input::Builder {
        crate::input::list_attached_group_policies_input::Builder::default()
    }
}

/// See [`ListAttachedRolePoliciesInput`](crate::input::ListAttachedRolePoliciesInput)
pub mod list_attached_role_policies_input {
    /// A builder for [`ListAttachedRolePoliciesInput`](crate::input::ListAttachedRolePoliciesInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) role_name: std::option::Option<std::string::String>,
        pub(crate) path_prefix: std::option::Option<std::string::String>,
        pub(crate) marker: std::option::Option<std::string::String>,
        pub(crate) max_items: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The name (friendly name, not ARN) of the role to list attached policies for.</p>
        /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
        /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
        pub fn role_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.role_name = Some(inp.into());
            self
        }
        pub fn set_role_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.role_name = inp;
            self
        }
        /// <p>The path prefix for filtering the results. This parameter is optional. If it is not
        /// included, it defaults to a slash (/), listing all policies.</p>
        /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting
        /// of either a forward slash (/) by itself or a string that must begin and end with forward slashes.
        /// In addition, it can contain any ASCII character from the ! (<code>\u0021</code>) through the DEL character (<code>\u007F</code>), including
        /// most punctuation characters, digits, and upper and lowercased letters.</p>
        pub fn path_prefix(mut self, inp: impl Into<std::string::String>) -> Self {
            self.path_prefix = Some(inp.into());
            self
        }
        pub fn set_path_prefix(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.path_prefix = inp;
            self
        }
        /// <p>Use this parameter only when paginating results and only after
        /// you receive a response indicating that the results are truncated. Set it to the value of the
        /// <code>Marker</code> element in the response that you received to indicate where the next call
        /// should start.</p>
        pub fn marker(mut self, inp: impl Into<std::string::String>) -> Self {
            self.marker = Some(inp.into());
            self
        }
        pub fn set_marker(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.marker = inp;
            self
        }
        /// <p>Use this only when paginating results to indicate the
        /// maximum number of items you want in the response. If additional items exist beyond the maximum
        /// you specify, the <code>IsTruncated</code> response element is <code>true</code>.</p>
        /// <p>If you do not include this parameter, the number of items defaults to 100. Note that
        /// IAM might return fewer results, even when there are more results available. In that case, the
        /// <code>IsTruncated</code> response element returns <code>true</code>, and <code>Marker</code>
        /// contains a value to include in the subsequent call that tells the service where to continue
        /// from.</p>
        pub fn max_items(mut self, inp: i32) -> Self {
            self.max_items = Some(inp);
            self
        }
        pub fn set_max_items(mut self, inp: std::option::Option<i32>) -> Self {
            self.max_items = inp;
            self
        }
        /// Consumes the builder and constructs a [`ListAttachedRolePoliciesInput`](crate::input::ListAttachedRolePoliciesInput)
        pub fn build(
            self,
        ) -> Result<crate::input::ListAttachedRolePoliciesInput, smithy_http::operation::BuildError>
        {
            Ok(crate::input::ListAttachedRolePoliciesInput {
                role_name: self.role_name,
                path_prefix: self.path_prefix,
                marker: self.marker,
                max_items: self.max_items,
            })
        }
    }
}
#[doc(hidden)]
pub type ListAttachedRolePoliciesInputOperationOutputAlias =
    crate::operation::ListAttachedRolePolicies;
#[doc(hidden)]
pub type ListAttachedRolePoliciesInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl ListAttachedRolePoliciesInput {
    /// Consumes the builder and constructs an Operation<[`ListAttachedRolePolicies`](crate::operation::ListAttachedRolePolicies)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> Result<
        smithy_http::operation::Operation<
            crate::operation::ListAttachedRolePolicies,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = crate::operation_ser::serialize_operation_list_attached_role_policies(&self)
                .map_err(|err| {
                    smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::ListAttachedRolePolicies::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "ListAttachedRolePolicies",
                "iam",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) {
        write!(output, "/").expect("formatting should succeed")
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri);
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let builder = http::request::Builder::new();
        let builder = builder.header("Content-Type", "application/x-www-form-urlencoded");
        self.update_http_builder(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`ListAttachedRolePoliciesInput`](crate::input::ListAttachedRolePoliciesInput)
    pub fn builder() -> crate::input::list_attached_role_policies_input::Builder {
        crate::input::list_attached_role_policies_input::Builder::default()
    }
}

/// See [`ListAttachedUserPoliciesInput`](crate::input::ListAttachedUserPoliciesInput)
pub mod list_attached_user_policies_input {
    /// A builder for [`ListAttachedUserPoliciesInput`](crate::input::ListAttachedUserPoliciesInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) user_name: std::option::Option<std::string::String>,
        pub(crate) path_prefix: std::option::Option<std::string::String>,
        pub(crate) marker: std::option::Option<std::string::String>,
        pub(crate) max_items: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The name (friendly name, not ARN) of the user to list attached policies for.</p>
        /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
        /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
        pub fn user_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.user_name = Some(inp.into());
            self
        }
        pub fn set_user_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.user_name = inp;
            self
        }
        /// <p>The path prefix for filtering the results. This parameter is optional. If it is not
        /// included, it defaults to a slash (/), listing all policies.</p>
        /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting
        /// of either a forward slash (/) by itself or a string that must begin and end with forward slashes.
        /// In addition, it can contain any ASCII character from the ! (<code>\u0021</code>) through the DEL character (<code>\u007F</code>), including
        /// most punctuation characters, digits, and upper and lowercased letters.</p>
        pub fn path_prefix(mut self, inp: impl Into<std::string::String>) -> Self {
            self.path_prefix = Some(inp.into());
            self
        }
        pub fn set_path_prefix(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.path_prefix = inp;
            self
        }
        /// <p>Use this parameter only when paginating results and only after
        /// you receive a response indicating that the results are truncated. Set it to the value of the
        /// <code>Marker</code> element in the response that you received to indicate where the next call
        /// should start.</p>
        pub fn marker(mut self, inp: impl Into<std::string::String>) -> Self {
            self.marker = Some(inp.into());
            self
        }
        pub fn set_marker(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.marker = inp;
            self
        }
        /// <p>Use this only when paginating results to indicate the
        /// maximum number of items you want in the response. If additional items exist beyond the maximum
        /// you specify, the <code>IsTruncated</code> response element is <code>true</code>.</p>
        /// <p>If you do not include this parameter, the number of items defaults to 100. Note that
        /// IAM might return fewer results, even when there are more results available. In that case, the
        /// <code>IsTruncated</code> response element returns <code>true</code>, and <code>Marker</code>
        /// contains a value to include in the subsequent call that tells the service where to continue
        /// from.</p>
        pub fn max_items(mut self, inp: i32) -> Self {
            self.max_items = Some(inp);
            self
        }
        pub fn set_max_items(mut self, inp: std::option::Option<i32>) -> Self {
            self.max_items = inp;
            self
        }
        /// Consumes the builder and constructs a [`ListAttachedUserPoliciesInput`](crate::input::ListAttachedUserPoliciesInput)
        pub fn build(
            self,
        ) -> Result<crate::input::ListAttachedUserPoliciesInput, smithy_http::operation::BuildError>
        {
            Ok(crate::input::ListAttachedUserPoliciesInput {
                user_name: self.user_name,
                path_prefix: self.path_prefix,
                marker: self.marker,
                max_items: self.max_items,
            })
        }
    }
}
#[doc(hidden)]
pub type ListAttachedUserPoliciesInputOperationOutputAlias =
    crate::operation::ListAttachedUserPolicies;
#[doc(hidden)]
pub type ListAttachedUserPoliciesInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl ListAttachedUserPoliciesInput {
    /// Consumes the builder and constructs an Operation<[`ListAttachedUserPolicies`](crate::operation::ListAttachedUserPolicies)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> Result<
        smithy_http::operation::Operation<
            crate::operation::ListAttachedUserPolicies,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = crate::operation_ser::serialize_operation_list_attached_user_policies(&self)
                .map_err(|err| {
                    smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::ListAttachedUserPolicies::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "ListAttachedUserPolicies",
                "iam",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) {
        write!(output, "/").expect("formatting should succeed")
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri);
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let builder = http::request::Builder::new();
        let builder = builder.header("Content-Type", "application/x-www-form-urlencoded");
        self.update_http_builder(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`ListAttachedUserPoliciesInput`](crate::input::ListAttachedUserPoliciesInput)
    pub fn builder() -> crate::input::list_attached_user_policies_input::Builder {
        crate::input::list_attached_user_policies_input::Builder::default()
    }
}

/// See [`ListEntitiesForPolicyInput`](crate::input::ListEntitiesForPolicyInput)
pub mod list_entities_for_policy_input {
    /// A builder for [`ListEntitiesForPolicyInput`](crate::input::ListEntitiesForPolicyInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) policy_arn: std::option::Option<std::string::String>,
        pub(crate) entity_filter: std::option::Option<crate::model::EntityType>,
        pub(crate) path_prefix: std::option::Option<std::string::String>,
        pub(crate) policy_usage_filter: std::option::Option<crate::model::PolicyUsageType>,
        pub(crate) marker: std::option::Option<std::string::String>,
        pub(crate) max_items: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the IAM policy for which you want the
        /// versions.</p>
        /// <p>For more information about ARNs, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">Amazon Resource Names (ARNs)</a> in the <i>AWS General Reference</i>.</p>
        pub fn policy_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.policy_arn = Some(inp.into());
            self
        }
        pub fn set_policy_arn(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.policy_arn = inp;
            self
        }
        /// <p>The entity type to use for filtering the results.</p>
        /// <p>For example, when <code>EntityFilter</code> is <code>Role</code>, only the roles that
        /// are attached to the specified policy are returned. This parameter is optional. If it is
        /// not included, all attached entities (users, groups, and roles) are returned. The
        /// argument for this parameter must be one of the valid values listed below.</p>
        pub fn entity_filter(mut self, inp: crate::model::EntityType) -> Self {
            self.entity_filter = Some(inp);
            self
        }
        pub fn set_entity_filter(
            mut self,
            inp: std::option::Option<crate::model::EntityType>,
        ) -> Self {
            self.entity_filter = inp;
            self
        }
        /// <p>The path prefix for filtering the results. This parameter is optional. If it is not
        /// included, it defaults to a slash (/), listing all entities.</p>
        /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting
        /// of either a forward slash (/) by itself or a string that must begin and end with forward slashes.
        /// In addition, it can contain any ASCII character from the ! (<code>\u0021</code>) through the DEL character (<code>\u007F</code>), including
        /// most punctuation characters, digits, and upper and lowercased letters.</p>
        pub fn path_prefix(mut self, inp: impl Into<std::string::String>) -> Self {
            self.path_prefix = Some(inp.into());
            self
        }
        pub fn set_path_prefix(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.path_prefix = inp;
            self
        }
        /// <p>The policy usage method to use for filtering the results.</p>
        /// <p>To list only permissions policies,
        /// set <code>PolicyUsageFilter</code> to <code>PermissionsPolicy</code>. To list only
        /// the policies used to set permissions boundaries, set the value
        /// to <code>PermissionsBoundary</code>.</p>
        /// <p>This parameter is optional. If it is not included, all policies are returned. </p>
        pub fn policy_usage_filter(mut self, inp: crate::model::PolicyUsageType) -> Self {
            self.policy_usage_filter = Some(inp);
            self
        }
        pub fn set_policy_usage_filter(
            mut self,
            inp: std::option::Option<crate::model::PolicyUsageType>,
        ) -> Self {
            self.policy_usage_filter = inp;
            self
        }
        /// <p>Use this parameter only when paginating results and only after
        /// you receive a response indicating that the results are truncated. Set it to the value of the
        /// <code>Marker</code> element in the response that you received to indicate where the next call
        /// should start.</p>
        pub fn marker(mut self, inp: impl Into<std::string::String>) -> Self {
            self.marker = Some(inp.into());
            self
        }
        pub fn set_marker(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.marker = inp;
            self
        }
        /// <p>Use this only when paginating results to indicate the
        /// maximum number of items you want in the response. If additional items exist beyond the maximum
        /// you specify, the <code>IsTruncated</code> response element is <code>true</code>.</p>
        /// <p>If you do not include this parameter, the number of items defaults to 100. Note that
        /// IAM might return fewer results, even when there are more results available. In that case, the
        /// <code>IsTruncated</code> response element returns <code>true</code>, and <code>Marker</code>
        /// contains a value to include in the subsequent call that tells the service where to continue
        /// from.</p>
        pub fn max_items(mut self, inp: i32) -> Self {
            self.max_items = Some(inp);
            self
        }
        pub fn set_max_items(mut self, inp: std::option::Option<i32>) -> Self {
            self.max_items = inp;
            self
        }
        /// Consumes the builder and constructs a [`ListEntitiesForPolicyInput`](crate::input::ListEntitiesForPolicyInput)
        pub fn build(
            self,
        ) -> Result<crate::input::ListEntitiesForPolicyInput, smithy_http::operation::BuildError>
        {
            Ok(crate::input::ListEntitiesForPolicyInput {
                policy_arn: self.policy_arn,
                entity_filter: self.entity_filter,
                path_prefix: self.path_prefix,
                policy_usage_filter: self.policy_usage_filter,
                marker: self.marker,
                max_items: self.max_items,
            })
        }
    }
}
#[doc(hidden)]
pub type ListEntitiesForPolicyInputOperationOutputAlias = crate::operation::ListEntitiesForPolicy;
#[doc(hidden)]
pub type ListEntitiesForPolicyInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl ListEntitiesForPolicyInput {
    /// Consumes the builder and constructs an Operation<[`ListEntitiesForPolicy`](crate::operation::ListEntitiesForPolicy)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> Result<
        smithy_http::operation::Operation<
            crate::operation::ListEntitiesForPolicy,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = crate::operation_ser::serialize_operation_list_entities_for_policy(&self)
                .map_err(|err| {
                    smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::ListEntitiesForPolicy::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "ListEntitiesForPolicy",
                "iam",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) {
        write!(output, "/").expect("formatting should succeed")
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri);
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let builder = http::request::Builder::new();
        let builder = builder.header("Content-Type", "application/x-www-form-urlencoded");
        self.update_http_builder(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`ListEntitiesForPolicyInput`](crate::input::ListEntitiesForPolicyInput)
    pub fn builder() -> crate::input::list_entities_for_policy_input::Builder {
        crate::input::list_entities_for_policy_input::Builder::default()
    }
}

/// See [`ListGroupPoliciesInput`](crate::input::ListGroupPoliciesInput)
pub mod list_group_policies_input {
    /// A builder for [`ListGroupPoliciesInput`](crate::input::ListGroupPoliciesInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) group_name: std::option::Option<std::string::String>,
        pub(crate) marker: std::option::Option<std::string::String>,
        pub(crate) max_items: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The name of the group to list policies for.</p>
        /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
        /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
        pub fn group_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.group_name = Some(inp.into());
            self
        }
        pub fn set_group_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.group_name = inp;
            self
        }
        /// <p>Use this parameter only when paginating results and only after
        /// you receive a response indicating that the results are truncated. Set it to the value of the
        /// <code>Marker</code> element in the response that you received to indicate where the next call
        /// should start.</p>
        pub fn marker(mut self, inp: impl Into<std::string::String>) -> Self {
            self.marker = Some(inp.into());
            self
        }
        pub fn set_marker(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.marker = inp;
            self
        }
        /// <p>Use this only when paginating results to indicate the
        /// maximum number of items you want in the response. If additional items exist beyond the maximum
        /// you specify, the <code>IsTruncated</code> response element is <code>true</code>.</p>
        /// <p>If you do not include this parameter, the number of items defaults to 100. Note that
        /// IAM might return fewer results, even when there are more results available. In that case, the
        /// <code>IsTruncated</code> response element returns <code>true</code>, and <code>Marker</code>
        /// contains a value to include in the subsequent call that tells the service where to continue
        /// from.</p>
        pub fn max_items(mut self, inp: i32) -> Self {
            self.max_items = Some(inp);
            self
        }
        pub fn set_max_items(mut self, inp: std::option::Option<i32>) -> Self {
            self.max_items = inp;
            self
        }
        /// Consumes the builder and constructs a [`ListGroupPoliciesInput`](crate::input::ListGroupPoliciesInput)
        pub fn build(
            self,
        ) -> Result<crate::input::ListGroupPoliciesInput, smithy_http::operation::BuildError>
        {
            Ok(crate::input::ListGroupPoliciesInput {
                group_name: self.group_name,
                marker: self.marker,
                max_items: self.max_items,
            })
        }
    }
}
#[doc(hidden)]
pub type ListGroupPoliciesInputOperationOutputAlias = crate::operation::ListGroupPolicies;
#[doc(hidden)]
pub type ListGroupPoliciesInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl ListGroupPoliciesInput {
    /// Consumes the builder and constructs an Operation<[`ListGroupPolicies`](crate::operation::ListGroupPolicies)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> Result<
        smithy_http::operation::Operation<
            crate::operation::ListGroupPolicies,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = crate::operation_ser::serialize_operation_list_group_policies(&self)
                .map_err(|err| {
                    smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::ListGroupPolicies::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "ListGroupPolicies",
                "iam",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) {
        write!(output, "/").expect("formatting should succeed")
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri);
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let builder = http::request::Builder::new();
        let builder = builder.header("Content-Type", "application/x-www-form-urlencoded");
        self.update_http_builder(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`ListGroupPoliciesInput`](crate::input::ListGroupPoliciesInput)
    pub fn builder() -> crate::input::list_group_policies_input::Builder {
        crate::input::list_group_policies_input::Builder::default()
    }
}

/// See [`ListGroupsInput`](crate::input::ListGroupsInput)
pub mod list_groups_input {
    /// A builder for [`ListGroupsInput`](crate::input::ListGroupsInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) path_prefix: std::option::Option<std::string::String>,
        pub(crate) marker: std::option::Option<std::string::String>,
        pub(crate) max_items: std::option::Option<i32>,
    }
    impl Builder {
        /// <p> The path prefix for filtering the results. For example, the prefix
        /// <code>/division_abc/subdivision_xyz/</code> gets all groups whose path starts with
        /// <code>/division_abc/subdivision_xyz/</code>.</p>
        /// <p>This parameter is optional. If it is not included, it defaults to a slash (/), listing
        /// all groups. This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting
        /// of either a forward slash (/) by itself or a string that must begin and end with forward slashes.
        /// In addition, it can contain any ASCII character from the ! (<code>\u0021</code>) through the DEL character (<code>\u007F</code>), including
        /// most punctuation characters, digits, and upper and lowercased letters.</p>
        pub fn path_prefix(mut self, inp: impl Into<std::string::String>) -> Self {
            self.path_prefix = Some(inp.into());
            self
        }
        pub fn set_path_prefix(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.path_prefix = inp;
            self
        }
        /// <p>Use this parameter only when paginating results and only after
        /// you receive a response indicating that the results are truncated. Set it to the value of the
        /// <code>Marker</code> element in the response that you received to indicate where the next call
        /// should start.</p>
        pub fn marker(mut self, inp: impl Into<std::string::String>) -> Self {
            self.marker = Some(inp.into());
            self
        }
        pub fn set_marker(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.marker = inp;
            self
        }
        /// <p>Use this only when paginating results to indicate the
        /// maximum number of items you want in the response. If additional items exist beyond the maximum
        /// you specify, the <code>IsTruncated</code> response element is <code>true</code>.</p>
        /// <p>If you do not include this parameter, the number of items defaults to 100. Note that
        /// IAM might return fewer results, even when there are more results available. In that case, the
        /// <code>IsTruncated</code> response element returns <code>true</code>, and <code>Marker</code>
        /// contains a value to include in the subsequent call that tells the service where to continue
        /// from.</p>
        pub fn max_items(mut self, inp: i32) -> Self {
            self.max_items = Some(inp);
            self
        }
        pub fn set_max_items(mut self, inp: std::option::Option<i32>) -> Self {
            self.max_items = inp;
            self
        }
        /// Consumes the builder and constructs a [`ListGroupsInput`](crate::input::ListGroupsInput)
        pub fn build(
            self,
        ) -> Result<crate::input::ListGroupsInput, smithy_http::operation::BuildError> {
            Ok(crate::input::ListGroupsInput {
                path_prefix: self.path_prefix,
                marker: self.marker,
                max_items: self.max_items,
            })
        }
    }
}
#[doc(hidden)]
pub type ListGroupsInputOperationOutputAlias = crate::operation::ListGroups;
#[doc(hidden)]
pub type ListGroupsInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl ListGroupsInput {
    /// Consumes the builder and constructs an Operation<[`ListGroups`](crate::operation::ListGroups)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> Result<
        smithy_http::operation::Operation<
            crate::operation::ListGroups,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body =
                crate::operation_ser::serialize_operation_list_groups(&self).map_err(|err| {
                    smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::ListGroups::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new("ListGroups", "iam"));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) {
        write!(output, "/").expect("formatting should succeed")
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri);
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let builder = http::request::Builder::new();
        let builder = builder.header("Content-Type", "application/x-www-form-urlencoded");
        self.update_http_builder(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`ListGroupsInput`](crate::input::ListGroupsInput)
    pub fn builder() -> crate::input::list_groups_input::Builder {
        crate::input::list_groups_input::Builder::default()
    }
}

/// See [`ListGroupsForUserInput`](crate::input::ListGroupsForUserInput)
pub mod list_groups_for_user_input {
    /// A builder for [`ListGroupsForUserInput`](crate::input::ListGroupsForUserInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) user_name: std::option::Option<std::string::String>,
        pub(crate) marker: std::option::Option<std::string::String>,
        pub(crate) max_items: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The name of the user to list groups for.</p>
        /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
        /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
        pub fn user_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.user_name = Some(inp.into());
            self
        }
        pub fn set_user_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.user_name = inp;
            self
        }
        /// <p>Use this parameter only when paginating results and only after
        /// you receive a response indicating that the results are truncated. Set it to the value of the
        /// <code>Marker</code> element in the response that you received to indicate where the next call
        /// should start.</p>
        pub fn marker(mut self, inp: impl Into<std::string::String>) -> Self {
            self.marker = Some(inp.into());
            self
        }
        pub fn set_marker(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.marker = inp;
            self
        }
        /// <p>Use this only when paginating results to indicate the
        /// maximum number of items you want in the response. If additional items exist beyond the maximum
        /// you specify, the <code>IsTruncated</code> response element is <code>true</code>.</p>
        /// <p>If you do not include this parameter, the number of items defaults to 100. Note that
        /// IAM might return fewer results, even when there are more results available. In that case, the
        /// <code>IsTruncated</code> response element returns <code>true</code>, and <code>Marker</code>
        /// contains a value to include in the subsequent call that tells the service where to continue
        /// from.</p>
        pub fn max_items(mut self, inp: i32) -> Self {
            self.max_items = Some(inp);
            self
        }
        pub fn set_max_items(mut self, inp: std::option::Option<i32>) -> Self {
            self.max_items = inp;
            self
        }
        /// Consumes the builder and constructs a [`ListGroupsForUserInput`](crate::input::ListGroupsForUserInput)
        pub fn build(
            self,
        ) -> Result<crate::input::ListGroupsForUserInput, smithy_http::operation::BuildError>
        {
            Ok(crate::input::ListGroupsForUserInput {
                user_name: self.user_name,
                marker: self.marker,
                max_items: self.max_items,
            })
        }
    }
}
#[doc(hidden)]
pub type ListGroupsForUserInputOperationOutputAlias = crate::operation::ListGroupsForUser;
#[doc(hidden)]
pub type ListGroupsForUserInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl ListGroupsForUserInput {
    /// Consumes the builder and constructs an Operation<[`ListGroupsForUser`](crate::operation::ListGroupsForUser)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> Result<
        smithy_http::operation::Operation<
            crate::operation::ListGroupsForUser,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = crate::operation_ser::serialize_operation_list_groups_for_user(&self)
                .map_err(|err| {
                    smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::ListGroupsForUser::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "ListGroupsForUser",
                "iam",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) {
        write!(output, "/").expect("formatting should succeed")
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri);
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let builder = http::request::Builder::new();
        let builder = builder.header("Content-Type", "application/x-www-form-urlencoded");
        self.update_http_builder(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`ListGroupsForUserInput`](crate::input::ListGroupsForUserInput)
    pub fn builder() -> crate::input::list_groups_for_user_input::Builder {
        crate::input::list_groups_for_user_input::Builder::default()
    }
}

/// See [`ListInstanceProfilesInput`](crate::input::ListInstanceProfilesInput)
pub mod list_instance_profiles_input {
    /// A builder for [`ListInstanceProfilesInput`](crate::input::ListInstanceProfilesInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) path_prefix: std::option::Option<std::string::String>,
        pub(crate) marker: std::option::Option<std::string::String>,
        pub(crate) max_items: std::option::Option<i32>,
    }
    impl Builder {
        /// <p> The path prefix for filtering the results. For example, the prefix
        /// <code>/application_abc/component_xyz/</code> gets all instance profiles whose path
        /// starts with <code>/application_abc/component_xyz/</code>.</p>
        /// <p>This parameter is optional. If it is not included, it defaults to a slash (/), listing
        /// all instance profiles. This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting
        /// of either a forward slash (/) by itself or a string that must begin and end with forward slashes.
        /// In addition, it can contain any ASCII character from the ! (<code>\u0021</code>) through the DEL character (<code>\u007F</code>), including
        /// most punctuation characters, digits, and upper and lowercased letters.</p>
        pub fn path_prefix(mut self, inp: impl Into<std::string::String>) -> Self {
            self.path_prefix = Some(inp.into());
            self
        }
        pub fn set_path_prefix(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.path_prefix = inp;
            self
        }
        /// <p>Use this parameter only when paginating results and only after
        /// you receive a response indicating that the results are truncated. Set it to the value of the
        /// <code>Marker</code> element in the response that you received to indicate where the next call
        /// should start.</p>
        pub fn marker(mut self, inp: impl Into<std::string::String>) -> Self {
            self.marker = Some(inp.into());
            self
        }
        pub fn set_marker(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.marker = inp;
            self
        }
        /// <p>Use this only when paginating results to indicate the
        /// maximum number of items you want in the response. If additional items exist beyond the maximum
        /// you specify, the <code>IsTruncated</code> response element is <code>true</code>.</p>
        /// <p>If you do not include this parameter, the number of items defaults to 100. Note that
        /// IAM might return fewer results, even when there are more results available. In that case, the
        /// <code>IsTruncated</code> response element returns <code>true</code>, and <code>Marker</code>
        /// contains a value to include in the subsequent call that tells the service where to continue
        /// from.</p>
        pub fn max_items(mut self, inp: i32) -> Self {
            self.max_items = Some(inp);
            self
        }
        pub fn set_max_items(mut self, inp: std::option::Option<i32>) -> Self {
            self.max_items = inp;
            self
        }
        /// Consumes the builder and constructs a [`ListInstanceProfilesInput`](crate::input::ListInstanceProfilesInput)
        pub fn build(
            self,
        ) -> Result<crate::input::ListInstanceProfilesInput, smithy_http::operation::BuildError>
        {
            Ok(crate::input::ListInstanceProfilesInput {
                path_prefix: self.path_prefix,
                marker: self.marker,
                max_items: self.max_items,
            })
        }
    }
}
#[doc(hidden)]
pub type ListInstanceProfilesInputOperationOutputAlias = crate::operation::ListInstanceProfiles;
#[doc(hidden)]
pub type ListInstanceProfilesInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl ListInstanceProfilesInput {
    /// Consumes the builder and constructs an Operation<[`ListInstanceProfiles`](crate::operation::ListInstanceProfiles)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> Result<
        smithy_http::operation::Operation<
            crate::operation::ListInstanceProfiles,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = crate::operation_ser::serialize_operation_list_instance_profiles(&self)
                .map_err(|err| {
                    smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::ListInstanceProfiles::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "ListInstanceProfiles",
                "iam",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) {
        write!(output, "/").expect("formatting should succeed")
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri);
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let builder = http::request::Builder::new();
        let builder = builder.header("Content-Type", "application/x-www-form-urlencoded");
        self.update_http_builder(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`ListInstanceProfilesInput`](crate::input::ListInstanceProfilesInput)
    pub fn builder() -> crate::input::list_instance_profiles_input::Builder {
        crate::input::list_instance_profiles_input::Builder::default()
    }
}

/// See [`ListInstanceProfilesForRoleInput`](crate::input::ListInstanceProfilesForRoleInput)
pub mod list_instance_profiles_for_role_input {
    /// A builder for [`ListInstanceProfilesForRoleInput`](crate::input::ListInstanceProfilesForRoleInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) role_name: std::option::Option<std::string::String>,
        pub(crate) marker: std::option::Option<std::string::String>,
        pub(crate) max_items: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The name of the role to list instance profiles for.</p>
        /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
        /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
        pub fn role_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.role_name = Some(inp.into());
            self
        }
        pub fn set_role_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.role_name = inp;
            self
        }
        /// <p>Use this parameter only when paginating results and only after
        /// you receive a response indicating that the results are truncated. Set it to the value of the
        /// <code>Marker</code> element in the response that you received to indicate where the next call
        /// should start.</p>
        pub fn marker(mut self, inp: impl Into<std::string::String>) -> Self {
            self.marker = Some(inp.into());
            self
        }
        pub fn set_marker(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.marker = inp;
            self
        }
        /// <p>Use this only when paginating results to indicate the
        /// maximum number of items you want in the response. If additional items exist beyond the maximum
        /// you specify, the <code>IsTruncated</code> response element is <code>true</code>.</p>
        /// <p>If you do not include this parameter, the number of items defaults to 100. Note that
        /// IAM might return fewer results, even when there are more results available. In that case, the
        /// <code>IsTruncated</code> response element returns <code>true</code>, and <code>Marker</code>
        /// contains a value to include in the subsequent call that tells the service where to continue
        /// from.</p>
        pub fn max_items(mut self, inp: i32) -> Self {
            self.max_items = Some(inp);
            self
        }
        pub fn set_max_items(mut self, inp: std::option::Option<i32>) -> Self {
            self.max_items = inp;
            self
        }
        /// Consumes the builder and constructs a [`ListInstanceProfilesForRoleInput`](crate::input::ListInstanceProfilesForRoleInput)
        pub fn build(
            self,
        ) -> Result<
            crate::input::ListInstanceProfilesForRoleInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::ListInstanceProfilesForRoleInput {
                role_name: self.role_name,
                marker: self.marker,
                max_items: self.max_items,
            })
        }
    }
}
#[doc(hidden)]
pub type ListInstanceProfilesForRoleInputOperationOutputAlias =
    crate::operation::ListInstanceProfilesForRole;
#[doc(hidden)]
pub type ListInstanceProfilesForRoleInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl ListInstanceProfilesForRoleInput {
    /// Consumes the builder and constructs an Operation<[`ListInstanceProfilesForRole`](crate::operation::ListInstanceProfilesForRole)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> Result<
        smithy_http::operation::Operation<
            crate::operation::ListInstanceProfilesForRole,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body =
                crate::operation_ser::serialize_operation_list_instance_profiles_for_role(&self)
                    .map_err(|err| {
                        smithy_http::operation::BuildError::SerializationError(err.into())
                    })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::ListInstanceProfilesForRole::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "ListInstanceProfilesForRole",
                "iam",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) {
        write!(output, "/").expect("formatting should succeed")
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri);
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let builder = http::request::Builder::new();
        let builder = builder.header("Content-Type", "application/x-www-form-urlencoded");
        self.update_http_builder(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`ListInstanceProfilesForRoleInput`](crate::input::ListInstanceProfilesForRoleInput)
    pub fn builder() -> crate::input::list_instance_profiles_for_role_input::Builder {
        crate::input::list_instance_profiles_for_role_input::Builder::default()
    }
}

/// See [`ListInstanceProfileTagsInput`](crate::input::ListInstanceProfileTagsInput)
pub mod list_instance_profile_tags_input {
    /// A builder for [`ListInstanceProfileTagsInput`](crate::input::ListInstanceProfileTagsInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) instance_profile_name: std::option::Option<std::string::String>,
        pub(crate) marker: std::option::Option<std::string::String>,
        pub(crate) max_items: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The name of the IAM instance profile whose tags you want to see.</p>
        /// <p>This parameter accepts (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters that consist of upper and lowercase alphanumeric
        /// characters with no spaces. You can also include any of the following characters: =,.@-</p>
        pub fn instance_profile_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.instance_profile_name = Some(inp.into());
            self
        }
        pub fn set_instance_profile_name(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.instance_profile_name = inp;
            self
        }
        /// <p>Use this parameter only when paginating results and only after
        /// you receive a response indicating that the results are truncated. Set it to the value of the
        /// <code>Marker</code> element in the response that you received to indicate where the next call
        /// should start.</p>
        pub fn marker(mut self, inp: impl Into<std::string::String>) -> Self {
            self.marker = Some(inp.into());
            self
        }
        pub fn set_marker(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.marker = inp;
            self
        }
        /// <p>(Optional) Use this only when paginating results to indicate the
        /// maximum number of items that you want in the response. If additional items exist beyond the maximum that you specify, the <code>IsTruncated</code> response element is <code>true</code>.</p>
        /// <p>If you do not include this parameter, it defaults to 100. Note that
        /// IAM might return fewer results, even when more results are available. In that case, the
        /// <code>IsTruncated</code> response element returns <code>true</code>, and <code>Marker</code>
        /// contains a value to include in the subsequent call that tells the service where to continue
        /// from.</p>
        pub fn max_items(mut self, inp: i32) -> Self {
            self.max_items = Some(inp);
            self
        }
        pub fn set_max_items(mut self, inp: std::option::Option<i32>) -> Self {
            self.max_items = inp;
            self
        }
        /// Consumes the builder and constructs a [`ListInstanceProfileTagsInput`](crate::input::ListInstanceProfileTagsInput)
        pub fn build(
            self,
        ) -> Result<crate::input::ListInstanceProfileTagsInput, smithy_http::operation::BuildError>
        {
            Ok(crate::input::ListInstanceProfileTagsInput {
                instance_profile_name: self.instance_profile_name,
                marker: self.marker,
                max_items: self.max_items,
            })
        }
    }
}
#[doc(hidden)]
pub type ListInstanceProfileTagsInputOperationOutputAlias =
    crate::operation::ListInstanceProfileTags;
#[doc(hidden)]
pub type ListInstanceProfileTagsInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl ListInstanceProfileTagsInput {
    /// Consumes the builder and constructs an Operation<[`ListInstanceProfileTags`](crate::operation::ListInstanceProfileTags)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> Result<
        smithy_http::operation::Operation<
            crate::operation::ListInstanceProfileTags,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = crate::operation_ser::serialize_operation_list_instance_profile_tags(&self)
                .map_err(|err| {
                    smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::ListInstanceProfileTags::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "ListInstanceProfileTags",
                "iam",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) {
        write!(output, "/").expect("formatting should succeed")
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri);
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let builder = http::request::Builder::new();
        let builder = builder.header("Content-Type", "application/x-www-form-urlencoded");
        self.update_http_builder(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`ListInstanceProfileTagsInput`](crate::input::ListInstanceProfileTagsInput)
    pub fn builder() -> crate::input::list_instance_profile_tags_input::Builder {
        crate::input::list_instance_profile_tags_input::Builder::default()
    }
}

/// See [`ListMFADevicesInput`](crate::input::ListMFADevicesInput)
pub mod list_mfa_devices_input {
    /// A builder for [`ListMFADevicesInput`](crate::input::ListMFADevicesInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) user_name: std::option::Option<std::string::String>,
        pub(crate) marker: std::option::Option<std::string::String>,
        pub(crate) max_items: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The name of the user whose MFA devices you want to list.</p>
        /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
        /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
        pub fn user_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.user_name = Some(inp.into());
            self
        }
        pub fn set_user_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.user_name = inp;
            self
        }
        /// <p>Use this parameter only when paginating results and only after
        /// you receive a response indicating that the results are truncated. Set it to the value of the
        /// <code>Marker</code> element in the response that you received to indicate where the next call
        /// should start.</p>
        pub fn marker(mut self, inp: impl Into<std::string::String>) -> Self {
            self.marker = Some(inp.into());
            self
        }
        pub fn set_marker(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.marker = inp;
            self
        }
        /// <p>Use this only when paginating results to indicate the
        /// maximum number of items you want in the response. If additional items exist beyond the maximum
        /// you specify, the <code>IsTruncated</code> response element is <code>true</code>.</p>
        /// <p>If you do not include this parameter, the number of items defaults to 100. Note that
        /// IAM might return fewer results, even when there are more results available. In that case, the
        /// <code>IsTruncated</code> response element returns <code>true</code>, and <code>Marker</code>
        /// contains a value to include in the subsequent call that tells the service where to continue
        /// from.</p>
        pub fn max_items(mut self, inp: i32) -> Self {
            self.max_items = Some(inp);
            self
        }
        pub fn set_max_items(mut self, inp: std::option::Option<i32>) -> Self {
            self.max_items = inp;
            self
        }
        /// Consumes the builder and constructs a [`ListMFADevicesInput`](crate::input::ListMFADevicesInput)
        pub fn build(
            self,
        ) -> Result<crate::input::ListMFADevicesInput, smithy_http::operation::BuildError> {
            Ok(crate::input::ListMFADevicesInput {
                user_name: self.user_name,
                marker: self.marker,
                max_items: self.max_items,
            })
        }
    }
}
#[doc(hidden)]
pub type ListMFADevicesInputOperationOutputAlias = crate::operation::ListMFADevices;
#[doc(hidden)]
pub type ListMFADevicesInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl ListMFADevicesInput {
    /// Consumes the builder and constructs an Operation<[`ListMFADevices`](crate::operation::ListMFADevices)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> Result<
        smithy_http::operation::Operation<
            crate::operation::ListMFADevices,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = crate::operation_ser::serialize_operation_list_mfa_devices(&self).map_err(
                |err| smithy_http::operation::BuildError::SerializationError(err.into()),
            )?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::ListMFADevices::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "ListMFADevices",
                "iam",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) {
        write!(output, "/").expect("formatting should succeed")
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri);
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let builder = http::request::Builder::new();
        let builder = builder.header("Content-Type", "application/x-www-form-urlencoded");
        self.update_http_builder(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`ListMFADevicesInput`](crate::input::ListMFADevicesInput)
    pub fn builder() -> crate::input::list_mfa_devices_input::Builder {
        crate::input::list_mfa_devices_input::Builder::default()
    }
}

/// See [`ListMFADeviceTagsInput`](crate::input::ListMFADeviceTagsInput)
pub mod list_mfa_device_tags_input {
    /// A builder for [`ListMFADeviceTagsInput`](crate::input::ListMFADeviceTagsInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) serial_number: std::option::Option<std::string::String>,
        pub(crate) marker: std::option::Option<std::string::String>,
        pub(crate) max_items: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The unique identifier for the IAM virtual MFA device whose tags you want to see.
        /// For virtual MFA devices, the serial number is the same as the ARN.</p>
        /// <p>This parameter accepts (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters that consist of upper and lowercase alphanumeric
        /// characters with no spaces. You can also include any of the following characters: =,.@-</p>
        pub fn serial_number(mut self, inp: impl Into<std::string::String>) -> Self {
            self.serial_number = Some(inp.into());
            self
        }
        pub fn set_serial_number(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.serial_number = inp;
            self
        }
        /// <p>Use this parameter only when paginating results and only after
        /// you receive a response indicating that the results are truncated. Set it to the value of the
        /// <code>Marker</code> element in the response that you received to indicate where the next call
        /// should start.</p>
        pub fn marker(mut self, inp: impl Into<std::string::String>) -> Self {
            self.marker = Some(inp.into());
            self
        }
        pub fn set_marker(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.marker = inp;
            self
        }
        /// <p>(Optional) Use this only when paginating results to indicate the
        /// maximum number of items that you want in the response. If additional items exist beyond the maximum that you specify, the <code>IsTruncated</code> response element is <code>true</code>.</p>
        /// <p>If you do not include this parameter, it defaults to 100. Note that
        /// IAM might return fewer results, even when more results are available. In that case, the
        /// <code>IsTruncated</code> response element returns <code>true</code>, and <code>Marker</code>
        /// contains a value to include in the subsequent call that tells the service where to continue
        /// from.</p>
        pub fn max_items(mut self, inp: i32) -> Self {
            self.max_items = Some(inp);
            self
        }
        pub fn set_max_items(mut self, inp: std::option::Option<i32>) -> Self {
            self.max_items = inp;
            self
        }
        /// Consumes the builder and constructs a [`ListMFADeviceTagsInput`](crate::input::ListMFADeviceTagsInput)
        pub fn build(
            self,
        ) -> Result<crate::input::ListMFADeviceTagsInput, smithy_http::operation::BuildError>
        {
            Ok(crate::input::ListMFADeviceTagsInput {
                serial_number: self.serial_number,
                marker: self.marker,
                max_items: self.max_items,
            })
        }
    }
}
#[doc(hidden)]
pub type ListMFADeviceTagsInputOperationOutputAlias = crate::operation::ListMFADeviceTags;
#[doc(hidden)]
pub type ListMFADeviceTagsInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl ListMFADeviceTagsInput {
    /// Consumes the builder and constructs an Operation<[`ListMFADeviceTags`](crate::operation::ListMFADeviceTags)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> Result<
        smithy_http::operation::Operation<
            crate::operation::ListMFADeviceTags,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = crate::operation_ser::serialize_operation_list_mfa_device_tags(&self)
                .map_err(|err| {
                    smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::ListMFADeviceTags::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "ListMFADeviceTags",
                "iam",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) {
        write!(output, "/").expect("formatting should succeed")
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri);
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let builder = http::request::Builder::new();
        let builder = builder.header("Content-Type", "application/x-www-form-urlencoded");
        self.update_http_builder(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`ListMFADeviceTagsInput`](crate::input::ListMFADeviceTagsInput)
    pub fn builder() -> crate::input::list_mfa_device_tags_input::Builder {
        crate::input::list_mfa_device_tags_input::Builder::default()
    }
}

/// See [`ListOpenIDConnectProvidersInput`](crate::input::ListOpenIDConnectProvidersInput)
pub mod list_open_id_connect_providers_input {
    /// A builder for [`ListOpenIDConnectProvidersInput`](crate::input::ListOpenIDConnectProvidersInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {}
    impl Builder {
        /// Consumes the builder and constructs a [`ListOpenIDConnectProvidersInput`](crate::input::ListOpenIDConnectProvidersInput)
        pub fn build(
            self,
        ) -> Result<crate::input::ListOpenIDConnectProvidersInput, smithy_http::operation::BuildError>
        {
            Ok(crate::input::ListOpenIDConnectProvidersInput {})
        }
    }
}
#[doc(hidden)]
pub type ListOpenIDConnectProvidersInputOperationOutputAlias =
    crate::operation::ListOpenIDConnectProviders;
#[doc(hidden)]
pub type ListOpenIDConnectProvidersInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl ListOpenIDConnectProvidersInput {
    /// Consumes the builder and constructs an Operation<[`ListOpenIDConnectProviders`](crate::operation::ListOpenIDConnectProviders)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> Result<
        smithy_http::operation::Operation<
            crate::operation::ListOpenIDConnectProviders,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body =
                crate::operation_ser::serialize_operation_list_open_id_connect_providers(&self)
                    .map_err(|err| {
                        smithy_http::operation::BuildError::SerializationError(err.into())
                    })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::ListOpenIDConnectProviders::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "ListOpenIDConnectProviders",
                "iam",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) {
        write!(output, "/").expect("formatting should succeed")
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri);
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let builder = http::request::Builder::new();
        let builder = builder.header("Content-Type", "application/x-www-form-urlencoded");
        self.update_http_builder(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`ListOpenIDConnectProvidersInput`](crate::input::ListOpenIDConnectProvidersInput)
    pub fn builder() -> crate::input::list_open_id_connect_providers_input::Builder {
        crate::input::list_open_id_connect_providers_input::Builder::default()
    }
}

/// See [`ListOpenIDConnectProviderTagsInput`](crate::input::ListOpenIDConnectProviderTagsInput)
pub mod list_open_id_connect_provider_tags_input {
    /// A builder for [`ListOpenIDConnectProviderTagsInput`](crate::input::ListOpenIDConnectProviderTagsInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) open_id_connect_provider_arn: std::option::Option<std::string::String>,
        pub(crate) marker: std::option::Option<std::string::String>,
        pub(crate) max_items: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The ARN of the OpenID Connect (OIDC) identity provider whose tags you want to
        /// see.</p>
        /// <p>This parameter accepts (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters that consist of upper and lowercase alphanumeric
        /// characters with no spaces. You can also include any of the following characters: =,.@-</p>
        pub fn open_id_connect_provider_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.open_id_connect_provider_arn = Some(inp.into());
            self
        }
        pub fn set_open_id_connect_provider_arn(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.open_id_connect_provider_arn = inp;
            self
        }
        /// <p>Use this parameter only when paginating results and only after
        /// you receive a response indicating that the results are truncated. Set it to the value of the
        /// <code>Marker</code> element in the response that you received to indicate where the next call
        /// should start.</p>
        pub fn marker(mut self, inp: impl Into<std::string::String>) -> Self {
            self.marker = Some(inp.into());
            self
        }
        pub fn set_marker(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.marker = inp;
            self
        }
        /// <p>(Optional) Use this only when paginating results to indicate the
        /// maximum number of items that you want in the response. If additional items exist beyond the maximum that you specify, the <code>IsTruncated</code> response element is <code>true</code>.</p>
        /// <p>If you do not include this parameter, it defaults to 100. Note that
        /// IAM might return fewer results, even when more results are available. In that case, the
        /// <code>IsTruncated</code> response element returns <code>true</code>, and <code>Marker</code>
        /// contains a value to include in the subsequent call that tells the service where to continue
        /// from.</p>
        pub fn max_items(mut self, inp: i32) -> Self {
            self.max_items = Some(inp);
            self
        }
        pub fn set_max_items(mut self, inp: std::option::Option<i32>) -> Self {
            self.max_items = inp;
            self
        }
        /// Consumes the builder and constructs a [`ListOpenIDConnectProviderTagsInput`](crate::input::ListOpenIDConnectProviderTagsInput)
        pub fn build(
            self,
        ) -> Result<
            crate::input::ListOpenIDConnectProviderTagsInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::ListOpenIDConnectProviderTagsInput {
                open_id_connect_provider_arn: self.open_id_connect_provider_arn,
                marker: self.marker,
                max_items: self.max_items,
            })
        }
    }
}
#[doc(hidden)]
pub type ListOpenIDConnectProviderTagsInputOperationOutputAlias =
    crate::operation::ListOpenIDConnectProviderTags;
#[doc(hidden)]
pub type ListOpenIDConnectProviderTagsInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl ListOpenIDConnectProviderTagsInput {
    /// Consumes the builder and constructs an Operation<[`ListOpenIDConnectProviderTags`](crate::operation::ListOpenIDConnectProviderTags)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> Result<
        smithy_http::operation::Operation<
            crate::operation::ListOpenIDConnectProviderTags,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body =
                crate::operation_ser::serialize_operation_list_open_id_connect_provider_tags(&self)
                    .map_err(|err| {
                        smithy_http::operation::BuildError::SerializationError(err.into())
                    })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::ListOpenIDConnectProviderTags::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "ListOpenIDConnectProviderTags",
                "iam",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) {
        write!(output, "/").expect("formatting should succeed")
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri);
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let builder = http::request::Builder::new();
        let builder = builder.header("Content-Type", "application/x-www-form-urlencoded");
        self.update_http_builder(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`ListOpenIDConnectProviderTagsInput`](crate::input::ListOpenIDConnectProviderTagsInput)
    pub fn builder() -> crate::input::list_open_id_connect_provider_tags_input::Builder {
        crate::input::list_open_id_connect_provider_tags_input::Builder::default()
    }
}

/// See [`ListPoliciesInput`](crate::input::ListPoliciesInput)
pub mod list_policies_input {
    /// A builder for [`ListPoliciesInput`](crate::input::ListPoliciesInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) scope: std::option::Option<crate::model::PolicyScopeType>,
        pub(crate) only_attached: std::option::Option<bool>,
        pub(crate) path_prefix: std::option::Option<std::string::String>,
        pub(crate) policy_usage_filter: std::option::Option<crate::model::PolicyUsageType>,
        pub(crate) marker: std::option::Option<std::string::String>,
        pub(crate) max_items: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The scope to use for filtering the results.</p>
        /// <p>To list only AWS managed policies, set <code>Scope</code> to <code>AWS</code>. To
        /// list only the customer managed policies in your AWS account, set <code>Scope</code> to
        /// <code>Local</code>.</p>
        /// <p>This parameter is optional. If it is not included, or if it is set to
        /// <code>All</code>, all policies are returned.</p>
        pub fn scope(mut self, inp: crate::model::PolicyScopeType) -> Self {
            self.scope = Some(inp);
            self
        }
        pub fn set_scope(
            mut self,
            inp: std::option::Option<crate::model::PolicyScopeType>,
        ) -> Self {
            self.scope = inp;
            self
        }
        /// <p>A flag to filter the results to only the attached policies.</p>
        /// <p>When <code>OnlyAttached</code> is <code>true</code>, the returned list contains only
        /// the policies that are attached to an IAM user, group, or role. When
        /// <code>OnlyAttached</code> is <code>false</code>, or when the parameter is not
        /// included, all policies are returned.</p>
        pub fn only_attached(mut self, inp: bool) -> Self {
            self.only_attached = Some(inp);
            self
        }
        pub fn set_only_attached(mut self, inp: bool) -> Self {
            self.only_attached = Some(inp);
            self
        }
        /// <p>The path prefix for filtering the results. This parameter is optional. If it is not
        /// included, it defaults to a slash (/), listing all policies. This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting
        /// of either a forward slash (/) by itself or a string that must begin and end with forward slashes.
        /// In addition, it can contain any ASCII character from the ! (<code>\u0021</code>) through the DEL character (<code>\u007F</code>), including
        /// most punctuation characters, digits, and upper and lowercased letters.</p>
        pub fn path_prefix(mut self, inp: impl Into<std::string::String>) -> Self {
            self.path_prefix = Some(inp.into());
            self
        }
        pub fn set_path_prefix(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.path_prefix = inp;
            self
        }
        /// <p>The policy usage method to use for filtering the results.</p>
        /// <p>To list only permissions policies,
        /// set <code>PolicyUsageFilter</code> to <code>PermissionsPolicy</code>. To list only
        /// the policies used to set permissions boundaries, set the value
        /// to <code>PermissionsBoundary</code>.</p>
        /// <p>This parameter is optional. If it is not included, all policies are returned. </p>
        pub fn policy_usage_filter(mut self, inp: crate::model::PolicyUsageType) -> Self {
            self.policy_usage_filter = Some(inp);
            self
        }
        pub fn set_policy_usage_filter(
            mut self,
            inp: std::option::Option<crate::model::PolicyUsageType>,
        ) -> Self {
            self.policy_usage_filter = inp;
            self
        }
        /// <p>Use this parameter only when paginating results and only after
        /// you receive a response indicating that the results are truncated. Set it to the value of the
        /// <code>Marker</code> element in the response that you received to indicate where the next call
        /// should start.</p>
        pub fn marker(mut self, inp: impl Into<std::string::String>) -> Self {
            self.marker = Some(inp.into());
            self
        }
        pub fn set_marker(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.marker = inp;
            self
        }
        /// <p>Use this only when paginating results to indicate the
        /// maximum number of items you want in the response. If additional items exist beyond the maximum
        /// you specify, the <code>IsTruncated</code> response element is <code>true</code>.</p>
        /// <p>If you do not include this parameter, the number of items defaults to 100. Note that
        /// IAM might return fewer results, even when there are more results available. In that case, the
        /// <code>IsTruncated</code> response element returns <code>true</code>, and <code>Marker</code>
        /// contains a value to include in the subsequent call that tells the service where to continue
        /// from.</p>
        pub fn max_items(mut self, inp: i32) -> Self {
            self.max_items = Some(inp);
            self
        }
        pub fn set_max_items(mut self, inp: std::option::Option<i32>) -> Self {
            self.max_items = inp;
            self
        }
        /// Consumes the builder and constructs a [`ListPoliciesInput`](crate::input::ListPoliciesInput)
        pub fn build(
            self,
        ) -> Result<crate::input::ListPoliciesInput, smithy_http::operation::BuildError> {
            Ok(crate::input::ListPoliciesInput {
                scope: self.scope,
                only_attached: self.only_attached.unwrap_or_default(),
                path_prefix: self.path_prefix,
                policy_usage_filter: self.policy_usage_filter,
                marker: self.marker,
                max_items: self.max_items,
            })
        }
    }
}
#[doc(hidden)]
pub type ListPoliciesInputOperationOutputAlias = crate::operation::ListPolicies;
#[doc(hidden)]
pub type ListPoliciesInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl ListPoliciesInput {
    /// Consumes the builder and constructs an Operation<[`ListPolicies`](crate::operation::ListPolicies)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> Result<
        smithy_http::operation::Operation<
            crate::operation::ListPolicies,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body =
                crate::operation_ser::serialize_operation_list_policies(&self).map_err(|err| {
                    smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::ListPolicies::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new("ListPolicies", "iam"));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) {
        write!(output, "/").expect("formatting should succeed")
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri);
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let builder = http::request::Builder::new();
        let builder = builder.header("Content-Type", "application/x-www-form-urlencoded");
        self.update_http_builder(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`ListPoliciesInput`](crate::input::ListPoliciesInput)
    pub fn builder() -> crate::input::list_policies_input::Builder {
        crate::input::list_policies_input::Builder::default()
    }
}

/// See [`ListPoliciesGrantingServiceAccessInput`](crate::input::ListPoliciesGrantingServiceAccessInput)
pub mod list_policies_granting_service_access_input {
    /// A builder for [`ListPoliciesGrantingServiceAccessInput`](crate::input::ListPoliciesGrantingServiceAccessInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) marker: std::option::Option<std::string::String>,
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) service_namespaces: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// <p>Use this parameter only when paginating results and only after
        /// you receive a response indicating that the results are truncated. Set it to the value of the
        /// <code>Marker</code> element in the response that you received to indicate where the next call
        /// should start.</p>
        pub fn marker(mut self, inp: impl Into<std::string::String>) -> Self {
            self.marker = Some(inp.into());
            self
        }
        pub fn set_marker(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.marker = inp;
            self
        }
        /// <p>The ARN of the IAM identity (user, group, or role) whose policies you want to
        /// list.</p>
        pub fn arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.arn = Some(inp.into());
            self
        }
        pub fn set_arn(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.arn = inp;
            self
        }
        pub fn service_namespaces(mut self, inp: impl Into<std::string::String>) -> Self {
            let mut v = self.service_namespaces.unwrap_or_default();
            v.push(inp.into());
            self.service_namespaces = Some(v);
            self
        }
        pub fn set_service_namespaces(
            mut self,
            inp: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.service_namespaces = inp;
            self
        }
        /// Consumes the builder and constructs a [`ListPoliciesGrantingServiceAccessInput`](crate::input::ListPoliciesGrantingServiceAccessInput)
        pub fn build(
            self,
        ) -> Result<
            crate::input::ListPoliciesGrantingServiceAccessInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::ListPoliciesGrantingServiceAccessInput {
                marker: self.marker,
                arn: self.arn,
                service_namespaces: self.service_namespaces,
            })
        }
    }
}
#[doc(hidden)]
pub type ListPoliciesGrantingServiceAccessInputOperationOutputAlias =
    crate::operation::ListPoliciesGrantingServiceAccess;
#[doc(hidden)]
pub type ListPoliciesGrantingServiceAccessInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl ListPoliciesGrantingServiceAccessInput {
    /// Consumes the builder and constructs an Operation<[`ListPoliciesGrantingServiceAccess`](crate::operation::ListPoliciesGrantingServiceAccess)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> Result<
        smithy_http::operation::Operation<
            crate::operation::ListPoliciesGrantingServiceAccess,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body =
                crate::operation_ser::serialize_operation_list_policies_granting_service_access(
                    &self,
                )
                .map_err(|err| {
                    smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::ListPoliciesGrantingServiceAccess::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "ListPoliciesGrantingServiceAccess",
                "iam",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) {
        write!(output, "/").expect("formatting should succeed")
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri);
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let builder = http::request::Builder::new();
        let builder = builder.header("Content-Type", "application/x-www-form-urlencoded");
        self.update_http_builder(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`ListPoliciesGrantingServiceAccessInput`](crate::input::ListPoliciesGrantingServiceAccessInput)
    pub fn builder() -> crate::input::list_policies_granting_service_access_input::Builder {
        crate::input::list_policies_granting_service_access_input::Builder::default()
    }
}

/// See [`ListPolicyTagsInput`](crate::input::ListPolicyTagsInput)
pub mod list_policy_tags_input {
    /// A builder for [`ListPolicyTagsInput`](crate::input::ListPolicyTagsInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) policy_arn: std::option::Option<std::string::String>,
        pub(crate) marker: std::option::Option<std::string::String>,
        pub(crate) max_items: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The ARN of the IAM customer managed policy whose tags you want to see.</p>
        /// <p>This parameter accepts (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters that consist of upper and lowercase alphanumeric
        /// characters with no spaces. You can also include any of the following characters: =,.@-</p>
        pub fn policy_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.policy_arn = Some(inp.into());
            self
        }
        pub fn set_policy_arn(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.policy_arn = inp;
            self
        }
        /// <p>Use this parameter only when paginating results and only after
        /// you receive a response indicating that the results are truncated. Set it to the value of the
        /// <code>Marker</code> element in the response that you received to indicate where the next call
        /// should start.</p>
        pub fn marker(mut self, inp: impl Into<std::string::String>) -> Self {
            self.marker = Some(inp.into());
            self
        }
        pub fn set_marker(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.marker = inp;
            self
        }
        /// <p>(Optional) Use this only when paginating results to indicate the
        /// maximum number of items that you want in the response. If additional items exist beyond the maximum that you specify, the <code>IsTruncated</code> response element is <code>true</code>.</p>
        /// <p>If you do not include this parameter, it defaults to 100. Note that
        /// IAM might return fewer results, even when more results are available. In that case, the
        /// <code>IsTruncated</code> response element returns <code>true</code>, and <code>Marker</code>
        /// contains a value to include in the subsequent call that tells the service where to continue
        /// from.</p>
        pub fn max_items(mut self, inp: i32) -> Self {
            self.max_items = Some(inp);
            self
        }
        pub fn set_max_items(mut self, inp: std::option::Option<i32>) -> Self {
            self.max_items = inp;
            self
        }
        /// Consumes the builder and constructs a [`ListPolicyTagsInput`](crate::input::ListPolicyTagsInput)
        pub fn build(
            self,
        ) -> Result<crate::input::ListPolicyTagsInput, smithy_http::operation::BuildError> {
            Ok(crate::input::ListPolicyTagsInput {
                policy_arn: self.policy_arn,
                marker: self.marker,
                max_items: self.max_items,
            })
        }
    }
}
#[doc(hidden)]
pub type ListPolicyTagsInputOperationOutputAlias = crate::operation::ListPolicyTags;
#[doc(hidden)]
pub type ListPolicyTagsInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl ListPolicyTagsInput {
    /// Consumes the builder and constructs an Operation<[`ListPolicyTags`](crate::operation::ListPolicyTags)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> Result<
        smithy_http::operation::Operation<
            crate::operation::ListPolicyTags,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = crate::operation_ser::serialize_operation_list_policy_tags(&self).map_err(
                |err| smithy_http::operation::BuildError::SerializationError(err.into()),
            )?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::ListPolicyTags::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "ListPolicyTags",
                "iam",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) {
        write!(output, "/").expect("formatting should succeed")
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri);
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let builder = http::request::Builder::new();
        let builder = builder.header("Content-Type", "application/x-www-form-urlencoded");
        self.update_http_builder(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`ListPolicyTagsInput`](crate::input::ListPolicyTagsInput)
    pub fn builder() -> crate::input::list_policy_tags_input::Builder {
        crate::input::list_policy_tags_input::Builder::default()
    }
}

/// See [`ListPolicyVersionsInput`](crate::input::ListPolicyVersionsInput)
pub mod list_policy_versions_input {
    /// A builder for [`ListPolicyVersionsInput`](crate::input::ListPolicyVersionsInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) policy_arn: std::option::Option<std::string::String>,
        pub(crate) marker: std::option::Option<std::string::String>,
        pub(crate) max_items: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the IAM policy for which you want the
        /// versions.</p>
        /// <p>For more information about ARNs, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">Amazon Resource Names (ARNs)</a> in the <i>AWS General Reference</i>.</p>
        pub fn policy_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.policy_arn = Some(inp.into());
            self
        }
        pub fn set_policy_arn(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.policy_arn = inp;
            self
        }
        /// <p>Use this parameter only when paginating results and only after
        /// you receive a response indicating that the results are truncated. Set it to the value of the
        /// <code>Marker</code> element in the response that you received to indicate where the next call
        /// should start.</p>
        pub fn marker(mut self, inp: impl Into<std::string::String>) -> Self {
            self.marker = Some(inp.into());
            self
        }
        pub fn set_marker(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.marker = inp;
            self
        }
        /// <p>Use this only when paginating results to indicate the
        /// maximum number of items you want in the response. If additional items exist beyond the maximum
        /// you specify, the <code>IsTruncated</code> response element is <code>true</code>.</p>
        /// <p>If you do not include this parameter, the number of items defaults to 100. Note that
        /// IAM might return fewer results, even when there are more results available. In that case, the
        /// <code>IsTruncated</code> response element returns <code>true</code>, and <code>Marker</code>
        /// contains a value to include in the subsequent call that tells the service where to continue
        /// from.</p>
        pub fn max_items(mut self, inp: i32) -> Self {
            self.max_items = Some(inp);
            self
        }
        pub fn set_max_items(mut self, inp: std::option::Option<i32>) -> Self {
            self.max_items = inp;
            self
        }
        /// Consumes the builder and constructs a [`ListPolicyVersionsInput`](crate::input::ListPolicyVersionsInput)
        pub fn build(
            self,
        ) -> Result<crate::input::ListPolicyVersionsInput, smithy_http::operation::BuildError>
        {
            Ok(crate::input::ListPolicyVersionsInput {
                policy_arn: self.policy_arn,
                marker: self.marker,
                max_items: self.max_items,
            })
        }
    }
}
#[doc(hidden)]
pub type ListPolicyVersionsInputOperationOutputAlias = crate::operation::ListPolicyVersions;
#[doc(hidden)]
pub type ListPolicyVersionsInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl ListPolicyVersionsInput {
    /// Consumes the builder and constructs an Operation<[`ListPolicyVersions`](crate::operation::ListPolicyVersions)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> Result<
        smithy_http::operation::Operation<
            crate::operation::ListPolicyVersions,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = crate::operation_ser::serialize_operation_list_policy_versions(&self)
                .map_err(|err| {
                    smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::ListPolicyVersions::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "ListPolicyVersions",
                "iam",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) {
        write!(output, "/").expect("formatting should succeed")
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri);
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let builder = http::request::Builder::new();
        let builder = builder.header("Content-Type", "application/x-www-form-urlencoded");
        self.update_http_builder(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`ListPolicyVersionsInput`](crate::input::ListPolicyVersionsInput)
    pub fn builder() -> crate::input::list_policy_versions_input::Builder {
        crate::input::list_policy_versions_input::Builder::default()
    }
}

/// See [`ListRolePoliciesInput`](crate::input::ListRolePoliciesInput)
pub mod list_role_policies_input {
    /// A builder for [`ListRolePoliciesInput`](crate::input::ListRolePoliciesInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) role_name: std::option::Option<std::string::String>,
        pub(crate) marker: std::option::Option<std::string::String>,
        pub(crate) max_items: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The name of the role to list policies for.</p>
        /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
        /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
        pub fn role_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.role_name = Some(inp.into());
            self
        }
        pub fn set_role_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.role_name = inp;
            self
        }
        /// <p>Use this parameter only when paginating results and only after
        /// you receive a response indicating that the results are truncated. Set it to the value of the
        /// <code>Marker</code> element in the response that you received to indicate where the next call
        /// should start.</p>
        pub fn marker(mut self, inp: impl Into<std::string::String>) -> Self {
            self.marker = Some(inp.into());
            self
        }
        pub fn set_marker(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.marker = inp;
            self
        }
        /// <p>Use this only when paginating results to indicate the
        /// maximum number of items you want in the response. If additional items exist beyond the maximum
        /// you specify, the <code>IsTruncated</code> response element is <code>true</code>.</p>
        /// <p>If you do not include this parameter, the number of items defaults to 100. Note that
        /// IAM might return fewer results, even when there are more results available. In that case, the
        /// <code>IsTruncated</code> response element returns <code>true</code>, and <code>Marker</code>
        /// contains a value to include in the subsequent call that tells the service where to continue
        /// from.</p>
        pub fn max_items(mut self, inp: i32) -> Self {
            self.max_items = Some(inp);
            self
        }
        pub fn set_max_items(mut self, inp: std::option::Option<i32>) -> Self {
            self.max_items = inp;
            self
        }
        /// Consumes the builder and constructs a [`ListRolePoliciesInput`](crate::input::ListRolePoliciesInput)
        pub fn build(
            self,
        ) -> Result<crate::input::ListRolePoliciesInput, smithy_http::operation::BuildError>
        {
            Ok(crate::input::ListRolePoliciesInput {
                role_name: self.role_name,
                marker: self.marker,
                max_items: self.max_items,
            })
        }
    }
}
#[doc(hidden)]
pub type ListRolePoliciesInputOperationOutputAlias = crate::operation::ListRolePolicies;
#[doc(hidden)]
pub type ListRolePoliciesInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl ListRolePoliciesInput {
    /// Consumes the builder and constructs an Operation<[`ListRolePolicies`](crate::operation::ListRolePolicies)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> Result<
        smithy_http::operation::Operation<
            crate::operation::ListRolePolicies,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = crate::operation_ser::serialize_operation_list_role_policies(&self)
                .map_err(|err| {
                    smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::ListRolePolicies::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "ListRolePolicies",
                "iam",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) {
        write!(output, "/").expect("formatting should succeed")
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri);
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let builder = http::request::Builder::new();
        let builder = builder.header("Content-Type", "application/x-www-form-urlencoded");
        self.update_http_builder(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`ListRolePoliciesInput`](crate::input::ListRolePoliciesInput)
    pub fn builder() -> crate::input::list_role_policies_input::Builder {
        crate::input::list_role_policies_input::Builder::default()
    }
}

/// See [`ListRolesInput`](crate::input::ListRolesInput)
pub mod list_roles_input {
    /// A builder for [`ListRolesInput`](crate::input::ListRolesInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) path_prefix: std::option::Option<std::string::String>,
        pub(crate) marker: std::option::Option<std::string::String>,
        pub(crate) max_items: std::option::Option<i32>,
    }
    impl Builder {
        /// <p> The path prefix for filtering the results. For example, the prefix
        /// <code>/application_abc/component_xyz/</code> gets all roles whose path starts with
        /// <code>/application_abc/component_xyz/</code>.</p>
        /// <p>This parameter is optional. If it is not included, it defaults to a slash (/), listing
        /// all roles. This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting
        /// of either a forward slash (/) by itself or a string that must begin and end with forward slashes.
        /// In addition, it can contain any ASCII character from the ! (<code>\u0021</code>) through the DEL character (<code>\u007F</code>), including
        /// most punctuation characters, digits, and upper and lowercased letters.</p>
        pub fn path_prefix(mut self, inp: impl Into<std::string::String>) -> Self {
            self.path_prefix = Some(inp.into());
            self
        }
        pub fn set_path_prefix(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.path_prefix = inp;
            self
        }
        /// <p>Use this parameter only when paginating results and only after
        /// you receive a response indicating that the results are truncated. Set it to the value of the
        /// <code>Marker</code> element in the response that you received to indicate where the next call
        /// should start.</p>
        pub fn marker(mut self, inp: impl Into<std::string::String>) -> Self {
            self.marker = Some(inp.into());
            self
        }
        pub fn set_marker(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.marker = inp;
            self
        }
        /// <p>Use this only when paginating results to indicate the
        /// maximum number of items you want in the response. If additional items exist beyond the maximum
        /// you specify, the <code>IsTruncated</code> response element is <code>true</code>.</p>
        /// <p>If you do not include this parameter, the number of items defaults to 100. Note that
        /// IAM might return fewer results, even when there are more results available. In that case, the
        /// <code>IsTruncated</code> response element returns <code>true</code>, and <code>Marker</code>
        /// contains a value to include in the subsequent call that tells the service where to continue
        /// from.</p>
        pub fn max_items(mut self, inp: i32) -> Self {
            self.max_items = Some(inp);
            self
        }
        pub fn set_max_items(mut self, inp: std::option::Option<i32>) -> Self {
            self.max_items = inp;
            self
        }
        /// Consumes the builder and constructs a [`ListRolesInput`](crate::input::ListRolesInput)
        pub fn build(
            self,
        ) -> Result<crate::input::ListRolesInput, smithy_http::operation::BuildError> {
            Ok(crate::input::ListRolesInput {
                path_prefix: self.path_prefix,
                marker: self.marker,
                max_items: self.max_items,
            })
        }
    }
}
#[doc(hidden)]
pub type ListRolesInputOperationOutputAlias = crate::operation::ListRoles;
#[doc(hidden)]
pub type ListRolesInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl ListRolesInput {
    /// Consumes the builder and constructs an Operation<[`ListRoles`](crate::operation::ListRoles)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> Result<
        smithy_http::operation::Operation<
            crate::operation::ListRoles,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body =
                crate::operation_ser::serialize_operation_list_roles(&self).map_err(|err| {
                    smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op =
                smithy_http::operation::Operation::new(request, crate::operation::ListRoles::new())
                    .with_metadata(smithy_http::operation::Metadata::new("ListRoles", "iam"));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) {
        write!(output, "/").expect("formatting should succeed")
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri);
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let builder = http::request::Builder::new();
        let builder = builder.header("Content-Type", "application/x-www-form-urlencoded");
        self.update_http_builder(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`ListRolesInput`](crate::input::ListRolesInput)
    pub fn builder() -> crate::input::list_roles_input::Builder {
        crate::input::list_roles_input::Builder::default()
    }
}

/// See [`ListRoleTagsInput`](crate::input::ListRoleTagsInput)
pub mod list_role_tags_input {
    /// A builder for [`ListRoleTagsInput`](crate::input::ListRoleTagsInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) role_name: std::option::Option<std::string::String>,
        pub(crate) marker: std::option::Option<std::string::String>,
        pub(crate) max_items: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The name of the IAM role for which you want to see the list of tags.</p>
        /// <p>This parameter accepts (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters that consist of upper and lowercase alphanumeric
        /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
        pub fn role_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.role_name = Some(inp.into());
            self
        }
        pub fn set_role_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.role_name = inp;
            self
        }
        /// <p>Use this parameter only when paginating results and only after
        /// you receive a response indicating that the results are truncated. Set it to the value of the
        /// <code>Marker</code> element in the response that you received to indicate where the next call
        /// should start.</p>
        pub fn marker(mut self, inp: impl Into<std::string::String>) -> Self {
            self.marker = Some(inp.into());
            self
        }
        pub fn set_marker(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.marker = inp;
            self
        }
        /// <p>(Optional) Use this only when paginating results to indicate the
        /// maximum number of items that you want in the response. If additional items exist beyond the maximum that you specify, the <code>IsTruncated</code> response element is <code>true</code>.</p>
        /// <p>If you do not include this parameter, it defaults to 100. Note that
        /// IAM might return fewer results, even when more results are available. In that case, the
        /// <code>IsTruncated</code> response element returns <code>true</code>, and <code>Marker</code>
        /// contains a value to include in the subsequent call that tells the service where to continue
        /// from.</p>
        pub fn max_items(mut self, inp: i32) -> Self {
            self.max_items = Some(inp);
            self
        }
        pub fn set_max_items(mut self, inp: std::option::Option<i32>) -> Self {
            self.max_items = inp;
            self
        }
        /// Consumes the builder and constructs a [`ListRoleTagsInput`](crate::input::ListRoleTagsInput)
        pub fn build(
            self,
        ) -> Result<crate::input::ListRoleTagsInput, smithy_http::operation::BuildError> {
            Ok(crate::input::ListRoleTagsInput {
                role_name: self.role_name,
                marker: self.marker,
                max_items: self.max_items,
            })
        }
    }
}
#[doc(hidden)]
pub type ListRoleTagsInputOperationOutputAlias = crate::operation::ListRoleTags;
#[doc(hidden)]
pub type ListRoleTagsInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl ListRoleTagsInput {
    /// Consumes the builder and constructs an Operation<[`ListRoleTags`](crate::operation::ListRoleTags)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> Result<
        smithy_http::operation::Operation<
            crate::operation::ListRoleTags,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body =
                crate::operation_ser::serialize_operation_list_role_tags(&self).map_err(|err| {
                    smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::ListRoleTags::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new("ListRoleTags", "iam"));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) {
        write!(output, "/").expect("formatting should succeed")
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri);
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let builder = http::request::Builder::new();
        let builder = builder.header("Content-Type", "application/x-www-form-urlencoded");
        self.update_http_builder(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`ListRoleTagsInput`](crate::input::ListRoleTagsInput)
    pub fn builder() -> crate::input::list_role_tags_input::Builder {
        crate::input::list_role_tags_input::Builder::default()
    }
}

/// See [`ListSAMLProvidersInput`](crate::input::ListSAMLProvidersInput)
pub mod list_saml_providers_input {
    /// A builder for [`ListSAMLProvidersInput`](crate::input::ListSAMLProvidersInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {}
    impl Builder {
        /// Consumes the builder and constructs a [`ListSAMLProvidersInput`](crate::input::ListSAMLProvidersInput)
        pub fn build(
            self,
        ) -> Result<crate::input::ListSAMLProvidersInput, smithy_http::operation::BuildError>
        {
            Ok(crate::input::ListSAMLProvidersInput {})
        }
    }
}
#[doc(hidden)]
pub type ListSAMLProvidersInputOperationOutputAlias = crate::operation::ListSAMLProviders;
#[doc(hidden)]
pub type ListSAMLProvidersInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl ListSAMLProvidersInput {
    /// Consumes the builder and constructs an Operation<[`ListSAMLProviders`](crate::operation::ListSAMLProviders)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> Result<
        smithy_http::operation::Operation<
            crate::operation::ListSAMLProviders,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = crate::operation_ser::serialize_operation_list_saml_providers(&self)
                .map_err(|err| {
                    smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::ListSAMLProviders::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "ListSAMLProviders",
                "iam",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) {
        write!(output, "/").expect("formatting should succeed")
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri);
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let builder = http::request::Builder::new();
        let builder = builder.header("Content-Type", "application/x-www-form-urlencoded");
        self.update_http_builder(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`ListSAMLProvidersInput`](crate::input::ListSAMLProvidersInput)
    pub fn builder() -> crate::input::list_saml_providers_input::Builder {
        crate::input::list_saml_providers_input::Builder::default()
    }
}

/// See [`ListSAMLProviderTagsInput`](crate::input::ListSAMLProviderTagsInput)
pub mod list_saml_provider_tags_input {
    /// A builder for [`ListSAMLProviderTagsInput`](crate::input::ListSAMLProviderTagsInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) saml_provider_arn: std::option::Option<std::string::String>,
        pub(crate) marker: std::option::Option<std::string::String>,
        pub(crate) max_items: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The ARN of the Security Assertion Markup Language (SAML) identity provider whose tags
        /// you want to see.</p>
        /// <p>This parameter accepts (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters that consist of upper and lowercase alphanumeric
        /// characters with no spaces. You can also include any of the following characters: =,.@-</p>
        pub fn saml_provider_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.saml_provider_arn = Some(inp.into());
            self
        }
        pub fn set_saml_provider_arn(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.saml_provider_arn = inp;
            self
        }
        /// <p>Use this parameter only when paginating results and only after
        /// you receive a response indicating that the results are truncated. Set it to the value of the
        /// <code>Marker</code> element in the response that you received to indicate where the next call
        /// should start.</p>
        pub fn marker(mut self, inp: impl Into<std::string::String>) -> Self {
            self.marker = Some(inp.into());
            self
        }
        pub fn set_marker(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.marker = inp;
            self
        }
        /// <p>(Optional) Use this only when paginating results to indicate the
        /// maximum number of items that you want in the response. If additional items exist beyond the maximum that you specify, the <code>IsTruncated</code> response element is <code>true</code>.</p>
        /// <p>If you do not include this parameter, it defaults to 100. Note that
        /// IAM might return fewer results, even when more results are available. In that case, the
        /// <code>IsTruncated</code> response element returns <code>true</code>, and <code>Marker</code>
        /// contains a value to include in the subsequent call that tells the service where to continue
        /// from.</p>
        pub fn max_items(mut self, inp: i32) -> Self {
            self.max_items = Some(inp);
            self
        }
        pub fn set_max_items(mut self, inp: std::option::Option<i32>) -> Self {
            self.max_items = inp;
            self
        }
        /// Consumes the builder and constructs a [`ListSAMLProviderTagsInput`](crate::input::ListSAMLProviderTagsInput)
        pub fn build(
            self,
        ) -> Result<crate::input::ListSAMLProviderTagsInput, smithy_http::operation::BuildError>
        {
            Ok(crate::input::ListSAMLProviderTagsInput {
                saml_provider_arn: self.saml_provider_arn,
                marker: self.marker,
                max_items: self.max_items,
            })
        }
    }
}
#[doc(hidden)]
pub type ListSAMLProviderTagsInputOperationOutputAlias = crate::operation::ListSAMLProviderTags;
#[doc(hidden)]
pub type ListSAMLProviderTagsInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl ListSAMLProviderTagsInput {
    /// Consumes the builder and constructs an Operation<[`ListSAMLProviderTags`](crate::operation::ListSAMLProviderTags)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> Result<
        smithy_http::operation::Operation<
            crate::operation::ListSAMLProviderTags,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = crate::operation_ser::serialize_operation_list_saml_provider_tags(&self)
                .map_err(|err| {
                    smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::ListSAMLProviderTags::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "ListSAMLProviderTags",
                "iam",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) {
        write!(output, "/").expect("formatting should succeed")
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri);
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let builder = http::request::Builder::new();
        let builder = builder.header("Content-Type", "application/x-www-form-urlencoded");
        self.update_http_builder(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`ListSAMLProviderTagsInput`](crate::input::ListSAMLProviderTagsInput)
    pub fn builder() -> crate::input::list_saml_provider_tags_input::Builder {
        crate::input::list_saml_provider_tags_input::Builder::default()
    }
}

/// See [`ListServerCertificatesInput`](crate::input::ListServerCertificatesInput)
pub mod list_server_certificates_input {
    /// A builder for [`ListServerCertificatesInput`](crate::input::ListServerCertificatesInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) path_prefix: std::option::Option<std::string::String>,
        pub(crate) marker: std::option::Option<std::string::String>,
        pub(crate) max_items: std::option::Option<i32>,
    }
    impl Builder {
        /// <p> The path prefix for filtering the results. For example:
        /// <code>/company/servercerts</code> would get all server certificates for which the
        /// path starts with <code>/company/servercerts</code>.</p>
        /// <p>This parameter is optional. If it is not included, it defaults to a slash (/), listing
        /// all server certificates. This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting
        /// of either a forward slash (/) by itself or a string that must begin and end with forward slashes.
        /// In addition, it can contain any ASCII character from the ! (<code>\u0021</code>) through the DEL character (<code>\u007F</code>), including
        /// most punctuation characters, digits, and upper and lowercased letters.</p>
        pub fn path_prefix(mut self, inp: impl Into<std::string::String>) -> Self {
            self.path_prefix = Some(inp.into());
            self
        }
        pub fn set_path_prefix(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.path_prefix = inp;
            self
        }
        /// <p>Use this parameter only when paginating results and only after
        /// you receive a response indicating that the results are truncated. Set it to the value of the
        /// <code>Marker</code> element in the response that you received to indicate where the next call
        /// should start.</p>
        pub fn marker(mut self, inp: impl Into<std::string::String>) -> Self {
            self.marker = Some(inp.into());
            self
        }
        pub fn set_marker(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.marker = inp;
            self
        }
        /// <p>Use this only when paginating results to indicate the
        /// maximum number of items you want in the response. If additional items exist beyond the maximum
        /// you specify, the <code>IsTruncated</code> response element is <code>true</code>.</p>
        /// <p>If you do not include this parameter, the number of items defaults to 100. Note that
        /// IAM might return fewer results, even when there are more results available. In that case, the
        /// <code>IsTruncated</code> response element returns <code>true</code>, and <code>Marker</code>
        /// contains a value to include in the subsequent call that tells the service where to continue
        /// from.</p>
        pub fn max_items(mut self, inp: i32) -> Self {
            self.max_items = Some(inp);
            self
        }
        pub fn set_max_items(mut self, inp: std::option::Option<i32>) -> Self {
            self.max_items = inp;
            self
        }
        /// Consumes the builder and constructs a [`ListServerCertificatesInput`](crate::input::ListServerCertificatesInput)
        pub fn build(
            self,
        ) -> Result<crate::input::ListServerCertificatesInput, smithy_http::operation::BuildError>
        {
            Ok(crate::input::ListServerCertificatesInput {
                path_prefix: self.path_prefix,
                marker: self.marker,
                max_items: self.max_items,
            })
        }
    }
}
#[doc(hidden)]
pub type ListServerCertificatesInputOperationOutputAlias = crate::operation::ListServerCertificates;
#[doc(hidden)]
pub type ListServerCertificatesInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl ListServerCertificatesInput {
    /// Consumes the builder and constructs an Operation<[`ListServerCertificates`](crate::operation::ListServerCertificates)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> Result<
        smithy_http::operation::Operation<
            crate::operation::ListServerCertificates,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = crate::operation_ser::serialize_operation_list_server_certificates(&self)
                .map_err(|err| {
                    smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::ListServerCertificates::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "ListServerCertificates",
                "iam",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) {
        write!(output, "/").expect("formatting should succeed")
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri);
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let builder = http::request::Builder::new();
        let builder = builder.header("Content-Type", "application/x-www-form-urlencoded");
        self.update_http_builder(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`ListServerCertificatesInput`](crate::input::ListServerCertificatesInput)
    pub fn builder() -> crate::input::list_server_certificates_input::Builder {
        crate::input::list_server_certificates_input::Builder::default()
    }
}

/// See [`ListServerCertificateTagsInput`](crate::input::ListServerCertificateTagsInput)
pub mod list_server_certificate_tags_input {
    /// A builder for [`ListServerCertificateTagsInput`](crate::input::ListServerCertificateTagsInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) server_certificate_name: std::option::Option<std::string::String>,
        pub(crate) marker: std::option::Option<std::string::String>,
        pub(crate) max_items: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The name of the IAM server certificate whose tags you want to see.</p>
        /// <p>This parameter accepts (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters that consist of upper and lowercase alphanumeric
        /// characters with no spaces. You can also include any of the following characters: =,.@-</p>
        pub fn server_certificate_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.server_certificate_name = Some(inp.into());
            self
        }
        pub fn set_server_certificate_name(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.server_certificate_name = inp;
            self
        }
        /// <p>Use this parameter only when paginating results and only after
        /// you receive a response indicating that the results are truncated. Set it to the value of the
        /// <code>Marker</code> element in the response that you received to indicate where the next call
        /// should start.</p>
        pub fn marker(mut self, inp: impl Into<std::string::String>) -> Self {
            self.marker = Some(inp.into());
            self
        }
        pub fn set_marker(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.marker = inp;
            self
        }
        /// <p>(Optional) Use this only when paginating results to indicate the
        /// maximum number of items that you want in the response. If additional items exist beyond the maximum that you specify, the <code>IsTruncated</code> response element is <code>true</code>.</p>
        /// <p>If you do not include this parameter, it defaults to 100. Note that
        /// IAM might return fewer results, even when more results are available. In that case, the
        /// <code>IsTruncated</code> response element returns <code>true</code>, and <code>Marker</code>
        /// contains a value to include in the subsequent call that tells the service where to continue
        /// from.</p>
        pub fn max_items(mut self, inp: i32) -> Self {
            self.max_items = Some(inp);
            self
        }
        pub fn set_max_items(mut self, inp: std::option::Option<i32>) -> Self {
            self.max_items = inp;
            self
        }
        /// Consumes the builder and constructs a [`ListServerCertificateTagsInput`](crate::input::ListServerCertificateTagsInput)
        pub fn build(
            self,
        ) -> Result<crate::input::ListServerCertificateTagsInput, smithy_http::operation::BuildError>
        {
            Ok(crate::input::ListServerCertificateTagsInput {
                server_certificate_name: self.server_certificate_name,
                marker: self.marker,
                max_items: self.max_items,
            })
        }
    }
}
#[doc(hidden)]
pub type ListServerCertificateTagsInputOperationOutputAlias =
    crate::operation::ListServerCertificateTags;
#[doc(hidden)]
pub type ListServerCertificateTagsInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl ListServerCertificateTagsInput {
    /// Consumes the builder and constructs an Operation<[`ListServerCertificateTags`](crate::operation::ListServerCertificateTags)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> Result<
        smithy_http::operation::Operation<
            crate::operation::ListServerCertificateTags,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body =
                crate::operation_ser::serialize_operation_list_server_certificate_tags(&self)
                    .map_err(|err| {
                        smithy_http::operation::BuildError::SerializationError(err.into())
                    })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::ListServerCertificateTags::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "ListServerCertificateTags",
                "iam",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) {
        write!(output, "/").expect("formatting should succeed")
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri);
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let builder = http::request::Builder::new();
        let builder = builder.header("Content-Type", "application/x-www-form-urlencoded");
        self.update_http_builder(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`ListServerCertificateTagsInput`](crate::input::ListServerCertificateTagsInput)
    pub fn builder() -> crate::input::list_server_certificate_tags_input::Builder {
        crate::input::list_server_certificate_tags_input::Builder::default()
    }
}

/// See [`ListServiceSpecificCredentialsInput`](crate::input::ListServiceSpecificCredentialsInput)
pub mod list_service_specific_credentials_input {
    /// A builder for [`ListServiceSpecificCredentialsInput`](crate::input::ListServiceSpecificCredentialsInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) user_name: std::option::Option<std::string::String>,
        pub(crate) service_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the user whose service-specific credentials you want information about. If
        /// this value is not specified, then the operation assumes the user whose credentials are
        /// used to call the operation.</p>
        /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
        /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
        pub fn user_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.user_name = Some(inp.into());
            self
        }
        pub fn set_user_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.user_name = inp;
            self
        }
        /// <p>Filters the returned results to only those for the specified AWS service. If not
        /// specified, then AWS returns service-specific credentials for all services.</p>
        pub fn service_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.service_name = Some(inp.into());
            self
        }
        pub fn set_service_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.service_name = inp;
            self
        }
        /// Consumes the builder and constructs a [`ListServiceSpecificCredentialsInput`](crate::input::ListServiceSpecificCredentialsInput)
        pub fn build(
            self,
        ) -> Result<
            crate::input::ListServiceSpecificCredentialsInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::ListServiceSpecificCredentialsInput {
                user_name: self.user_name,
                service_name: self.service_name,
            })
        }
    }
}
#[doc(hidden)]
pub type ListServiceSpecificCredentialsInputOperationOutputAlias =
    crate::operation::ListServiceSpecificCredentials;
#[doc(hidden)]
pub type ListServiceSpecificCredentialsInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl ListServiceSpecificCredentialsInput {
    /// Consumes the builder and constructs an Operation<[`ListServiceSpecificCredentials`](crate::operation::ListServiceSpecificCredentials)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> Result<
        smithy_http::operation::Operation<
            crate::operation::ListServiceSpecificCredentials,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body =
                crate::operation_ser::serialize_operation_list_service_specific_credentials(&self)
                    .map_err(|err| {
                        smithy_http::operation::BuildError::SerializationError(err.into())
                    })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::ListServiceSpecificCredentials::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "ListServiceSpecificCredentials",
                "iam",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) {
        write!(output, "/").expect("formatting should succeed")
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri);
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let builder = http::request::Builder::new();
        let builder = builder.header("Content-Type", "application/x-www-form-urlencoded");
        self.update_http_builder(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`ListServiceSpecificCredentialsInput`](crate::input::ListServiceSpecificCredentialsInput)
    pub fn builder() -> crate::input::list_service_specific_credentials_input::Builder {
        crate::input::list_service_specific_credentials_input::Builder::default()
    }
}

/// See [`ListSigningCertificatesInput`](crate::input::ListSigningCertificatesInput)
pub mod list_signing_certificates_input {
    /// A builder for [`ListSigningCertificatesInput`](crate::input::ListSigningCertificatesInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) user_name: std::option::Option<std::string::String>,
        pub(crate) marker: std::option::Option<std::string::String>,
        pub(crate) max_items: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The name of the IAM user whose signing certificates you want to examine.</p>
        /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
        /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
        pub fn user_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.user_name = Some(inp.into());
            self
        }
        pub fn set_user_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.user_name = inp;
            self
        }
        /// <p>Use this parameter only when paginating results and only after
        /// you receive a response indicating that the results are truncated. Set it to the value of the
        /// <code>Marker</code> element in the response that you received to indicate where the next call
        /// should start.</p>
        pub fn marker(mut self, inp: impl Into<std::string::String>) -> Self {
            self.marker = Some(inp.into());
            self
        }
        pub fn set_marker(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.marker = inp;
            self
        }
        /// <p>Use this only when paginating results to indicate the
        /// maximum number of items you want in the response. If additional items exist beyond the maximum
        /// you specify, the <code>IsTruncated</code> response element is <code>true</code>.</p>
        /// <p>If you do not include this parameter, the number of items defaults to 100. Note that
        /// IAM might return fewer results, even when there are more results available. In that case, the
        /// <code>IsTruncated</code> response element returns <code>true</code>, and <code>Marker</code>
        /// contains a value to include in the subsequent call that tells the service where to continue
        /// from.</p>
        pub fn max_items(mut self, inp: i32) -> Self {
            self.max_items = Some(inp);
            self
        }
        pub fn set_max_items(mut self, inp: std::option::Option<i32>) -> Self {
            self.max_items = inp;
            self
        }
        /// Consumes the builder and constructs a [`ListSigningCertificatesInput`](crate::input::ListSigningCertificatesInput)
        pub fn build(
            self,
        ) -> Result<crate::input::ListSigningCertificatesInput, smithy_http::operation::BuildError>
        {
            Ok(crate::input::ListSigningCertificatesInput {
                user_name: self.user_name,
                marker: self.marker,
                max_items: self.max_items,
            })
        }
    }
}
#[doc(hidden)]
pub type ListSigningCertificatesInputOperationOutputAlias =
    crate::operation::ListSigningCertificates;
#[doc(hidden)]
pub type ListSigningCertificatesInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl ListSigningCertificatesInput {
    /// Consumes the builder and constructs an Operation<[`ListSigningCertificates`](crate::operation::ListSigningCertificates)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> Result<
        smithy_http::operation::Operation<
            crate::operation::ListSigningCertificates,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = crate::operation_ser::serialize_operation_list_signing_certificates(&self)
                .map_err(|err| {
                smithy_http::operation::BuildError::SerializationError(err.into())
            })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::ListSigningCertificates::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "ListSigningCertificates",
                "iam",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) {
        write!(output, "/").expect("formatting should succeed")
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri);
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let builder = http::request::Builder::new();
        let builder = builder.header("Content-Type", "application/x-www-form-urlencoded");
        self.update_http_builder(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`ListSigningCertificatesInput`](crate::input::ListSigningCertificatesInput)
    pub fn builder() -> crate::input::list_signing_certificates_input::Builder {
        crate::input::list_signing_certificates_input::Builder::default()
    }
}

/// See [`ListSSHPublicKeysInput`](crate::input::ListSSHPublicKeysInput)
pub mod list_ssh_public_keys_input {
    /// A builder for [`ListSSHPublicKeysInput`](crate::input::ListSSHPublicKeysInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) user_name: std::option::Option<std::string::String>,
        pub(crate) marker: std::option::Option<std::string::String>,
        pub(crate) max_items: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The name of the IAM user to list SSH public keys for. If none is specified, the
        /// <code>UserName</code> field is determined implicitly based on the AWS access key
        /// used to sign the request.</p>
        /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
        /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
        pub fn user_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.user_name = Some(inp.into());
            self
        }
        pub fn set_user_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.user_name = inp;
            self
        }
        /// <p>Use this parameter only when paginating results and only after
        /// you receive a response indicating that the results are truncated. Set it to the value of the
        /// <code>Marker</code> element in the response that you received to indicate where the next call
        /// should start.</p>
        pub fn marker(mut self, inp: impl Into<std::string::String>) -> Self {
            self.marker = Some(inp.into());
            self
        }
        pub fn set_marker(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.marker = inp;
            self
        }
        /// <p>Use this only when paginating results to indicate the
        /// maximum number of items you want in the response. If additional items exist beyond the maximum
        /// you specify, the <code>IsTruncated</code> response element is <code>true</code>.</p>
        /// <p>If you do not include this parameter, the number of items defaults to 100. Note that
        /// IAM might return fewer results, even when there are more results available. In that case, the
        /// <code>IsTruncated</code> response element returns <code>true</code>, and <code>Marker</code>
        /// contains a value to include in the subsequent call that tells the service where to continue
        /// from.</p>
        pub fn max_items(mut self, inp: i32) -> Self {
            self.max_items = Some(inp);
            self
        }
        pub fn set_max_items(mut self, inp: std::option::Option<i32>) -> Self {
            self.max_items = inp;
            self
        }
        /// Consumes the builder and constructs a [`ListSSHPublicKeysInput`](crate::input::ListSSHPublicKeysInput)
        pub fn build(
            self,
        ) -> Result<crate::input::ListSSHPublicKeysInput, smithy_http::operation::BuildError>
        {
            Ok(crate::input::ListSSHPublicKeysInput {
                user_name: self.user_name,
                marker: self.marker,
                max_items: self.max_items,
            })
        }
    }
}
#[doc(hidden)]
pub type ListSSHPublicKeysInputOperationOutputAlias = crate::operation::ListSSHPublicKeys;
#[doc(hidden)]
pub type ListSSHPublicKeysInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl ListSSHPublicKeysInput {
    /// Consumes the builder and constructs an Operation<[`ListSSHPublicKeys`](crate::operation::ListSSHPublicKeys)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> Result<
        smithy_http::operation::Operation<
            crate::operation::ListSSHPublicKeys,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = crate::operation_ser::serialize_operation_list_ssh_public_keys(&self)
                .map_err(|err| {
                    smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::ListSSHPublicKeys::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "ListSSHPublicKeys",
                "iam",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) {
        write!(output, "/").expect("formatting should succeed")
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri);
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let builder = http::request::Builder::new();
        let builder = builder.header("Content-Type", "application/x-www-form-urlencoded");
        self.update_http_builder(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`ListSSHPublicKeysInput`](crate::input::ListSSHPublicKeysInput)
    pub fn builder() -> crate::input::list_ssh_public_keys_input::Builder {
        crate::input::list_ssh_public_keys_input::Builder::default()
    }
}

/// See [`ListUserPoliciesInput`](crate::input::ListUserPoliciesInput)
pub mod list_user_policies_input {
    /// A builder for [`ListUserPoliciesInput`](crate::input::ListUserPoliciesInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) user_name: std::option::Option<std::string::String>,
        pub(crate) marker: std::option::Option<std::string::String>,
        pub(crate) max_items: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The name of the user to list policies for.</p>
        /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
        /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
        pub fn user_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.user_name = Some(inp.into());
            self
        }
        pub fn set_user_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.user_name = inp;
            self
        }
        /// <p>Use this parameter only when paginating results and only after
        /// you receive a response indicating that the results are truncated. Set it to the value of the
        /// <code>Marker</code> element in the response that you received to indicate where the next call
        /// should start.</p>
        pub fn marker(mut self, inp: impl Into<std::string::String>) -> Self {
            self.marker = Some(inp.into());
            self
        }
        pub fn set_marker(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.marker = inp;
            self
        }
        /// <p>Use this only when paginating results to indicate the
        /// maximum number of items you want in the response. If additional items exist beyond the maximum
        /// you specify, the <code>IsTruncated</code> response element is <code>true</code>.</p>
        /// <p>If you do not include this parameter, the number of items defaults to 100. Note that
        /// IAM might return fewer results, even when there are more results available. In that case, the
        /// <code>IsTruncated</code> response element returns <code>true</code>, and <code>Marker</code>
        /// contains a value to include in the subsequent call that tells the service where to continue
        /// from.</p>
        pub fn max_items(mut self, inp: i32) -> Self {
            self.max_items = Some(inp);
            self
        }
        pub fn set_max_items(mut self, inp: std::option::Option<i32>) -> Self {
            self.max_items = inp;
            self
        }
        /// Consumes the builder and constructs a [`ListUserPoliciesInput`](crate::input::ListUserPoliciesInput)
        pub fn build(
            self,
        ) -> Result<crate::input::ListUserPoliciesInput, smithy_http::operation::BuildError>
        {
            Ok(crate::input::ListUserPoliciesInput {
                user_name: self.user_name,
                marker: self.marker,
                max_items: self.max_items,
            })
        }
    }
}
#[doc(hidden)]
pub type ListUserPoliciesInputOperationOutputAlias = crate::operation::ListUserPolicies;
#[doc(hidden)]
pub type ListUserPoliciesInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl ListUserPoliciesInput {
    /// Consumes the builder and constructs an Operation<[`ListUserPolicies`](crate::operation::ListUserPolicies)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> Result<
        smithy_http::operation::Operation<
            crate::operation::ListUserPolicies,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = crate::operation_ser::serialize_operation_list_user_policies(&self)
                .map_err(|err| {
                    smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::ListUserPolicies::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "ListUserPolicies",
                "iam",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) {
        write!(output, "/").expect("formatting should succeed")
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri);
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let builder = http::request::Builder::new();
        let builder = builder.header("Content-Type", "application/x-www-form-urlencoded");
        self.update_http_builder(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`ListUserPoliciesInput`](crate::input::ListUserPoliciesInput)
    pub fn builder() -> crate::input::list_user_policies_input::Builder {
        crate::input::list_user_policies_input::Builder::default()
    }
}

/// See [`ListUsersInput`](crate::input::ListUsersInput)
pub mod list_users_input {
    /// A builder for [`ListUsersInput`](crate::input::ListUsersInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) path_prefix: std::option::Option<std::string::String>,
        pub(crate) marker: std::option::Option<std::string::String>,
        pub(crate) max_items: std::option::Option<i32>,
    }
    impl Builder {
        /// <p> The path prefix for filtering the results. For example:
        /// <code>/division_abc/subdivision_xyz/</code>, which would get all user names whose
        /// path starts with <code>/division_abc/subdivision_xyz/</code>.</p>
        /// <p>This parameter is optional. If it is not included, it defaults to a slash (/), listing
        /// all user names. This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting
        /// of either a forward slash (/) by itself or a string that must begin and end with forward slashes.
        /// In addition, it can contain any ASCII character from the ! (<code>\u0021</code>) through the DEL character (<code>\u007F</code>), including
        /// most punctuation characters, digits, and upper and lowercased letters.</p>
        pub fn path_prefix(mut self, inp: impl Into<std::string::String>) -> Self {
            self.path_prefix = Some(inp.into());
            self
        }
        pub fn set_path_prefix(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.path_prefix = inp;
            self
        }
        /// <p>Use this parameter only when paginating results and only after
        /// you receive a response indicating that the results are truncated. Set it to the value of the
        /// <code>Marker</code> element in the response that you received to indicate where the next call
        /// should start.</p>
        pub fn marker(mut self, inp: impl Into<std::string::String>) -> Self {
            self.marker = Some(inp.into());
            self
        }
        pub fn set_marker(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.marker = inp;
            self
        }
        /// <p>Use this only when paginating results to indicate the
        /// maximum number of items you want in the response. If additional items exist beyond the maximum
        /// you specify, the <code>IsTruncated</code> response element is <code>true</code>.</p>
        /// <p>If you do not include this parameter, the number of items defaults to 100. Note that
        /// IAM might return fewer results, even when there are more results available. In that case, the
        /// <code>IsTruncated</code> response element returns <code>true</code>, and <code>Marker</code>
        /// contains a value to include in the subsequent call that tells the service where to continue
        /// from.</p>
        pub fn max_items(mut self, inp: i32) -> Self {
            self.max_items = Some(inp);
            self
        }
        pub fn set_max_items(mut self, inp: std::option::Option<i32>) -> Self {
            self.max_items = inp;
            self
        }
        /// Consumes the builder and constructs a [`ListUsersInput`](crate::input::ListUsersInput)
        pub fn build(
            self,
        ) -> Result<crate::input::ListUsersInput, smithy_http::operation::BuildError> {
            Ok(crate::input::ListUsersInput {
                path_prefix: self.path_prefix,
                marker: self.marker,
                max_items: self.max_items,
            })
        }
    }
}
#[doc(hidden)]
pub type ListUsersInputOperationOutputAlias = crate::operation::ListUsers;
#[doc(hidden)]
pub type ListUsersInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl ListUsersInput {
    /// Consumes the builder and constructs an Operation<[`ListUsers`](crate::operation::ListUsers)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> Result<
        smithy_http::operation::Operation<
            crate::operation::ListUsers,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body =
                crate::operation_ser::serialize_operation_list_users(&self).map_err(|err| {
                    smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op =
                smithy_http::operation::Operation::new(request, crate::operation::ListUsers::new())
                    .with_metadata(smithy_http::operation::Metadata::new("ListUsers", "iam"));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) {
        write!(output, "/").expect("formatting should succeed")
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri);
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let builder = http::request::Builder::new();
        let builder = builder.header("Content-Type", "application/x-www-form-urlencoded");
        self.update_http_builder(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`ListUsersInput`](crate::input::ListUsersInput)
    pub fn builder() -> crate::input::list_users_input::Builder {
        crate::input::list_users_input::Builder::default()
    }
}

/// See [`ListUserTagsInput`](crate::input::ListUserTagsInput)
pub mod list_user_tags_input {
    /// A builder for [`ListUserTagsInput`](crate::input::ListUserTagsInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) user_name: std::option::Option<std::string::String>,
        pub(crate) marker: std::option::Option<std::string::String>,
        pub(crate) max_items: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The name of the IAM user whose tags you want to see.</p>
        /// <p>This parameter accepts (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters that consist of upper and lowercase alphanumeric
        /// characters with no spaces. You can also include any of the following characters: =,.@-</p>
        pub fn user_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.user_name = Some(inp.into());
            self
        }
        pub fn set_user_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.user_name = inp;
            self
        }
        /// <p>Use this parameter only when paginating results and only after
        /// you receive a response indicating that the results are truncated. Set it to the value of the
        /// <code>Marker</code> element in the response that you received to indicate where the next call
        /// should start.</p>
        pub fn marker(mut self, inp: impl Into<std::string::String>) -> Self {
            self.marker = Some(inp.into());
            self
        }
        pub fn set_marker(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.marker = inp;
            self
        }
        /// <p>(Optional) Use this only when paginating results to indicate the
        /// maximum number of items that you want in the response. If additional items exist beyond the maximum that you specify, the <code>IsTruncated</code> response element is <code>true</code>.</p>
        /// <p>If you do not include this parameter, it defaults to 100. Note that
        /// IAM might return fewer results, even when more results are available. In that case, the
        /// <code>IsTruncated</code> response element returns <code>true</code>, and <code>Marker</code>
        /// contains a value to include in the subsequent call that tells the service where to continue
        /// from.</p>
        pub fn max_items(mut self, inp: i32) -> Self {
            self.max_items = Some(inp);
            self
        }
        pub fn set_max_items(mut self, inp: std::option::Option<i32>) -> Self {
            self.max_items = inp;
            self
        }
        /// Consumes the builder and constructs a [`ListUserTagsInput`](crate::input::ListUserTagsInput)
        pub fn build(
            self,
        ) -> Result<crate::input::ListUserTagsInput, smithy_http::operation::BuildError> {
            Ok(crate::input::ListUserTagsInput {
                user_name: self.user_name,
                marker: self.marker,
                max_items: self.max_items,
            })
        }
    }
}
#[doc(hidden)]
pub type ListUserTagsInputOperationOutputAlias = crate::operation::ListUserTags;
#[doc(hidden)]
pub type ListUserTagsInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl ListUserTagsInput {
    /// Consumes the builder and constructs an Operation<[`ListUserTags`](crate::operation::ListUserTags)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> Result<
        smithy_http::operation::Operation<
            crate::operation::ListUserTags,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body =
                crate::operation_ser::serialize_operation_list_user_tags(&self).map_err(|err| {
                    smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::ListUserTags::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new("ListUserTags", "iam"));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) {
        write!(output, "/").expect("formatting should succeed")
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri);
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let builder = http::request::Builder::new();
        let builder = builder.header("Content-Type", "application/x-www-form-urlencoded");
        self.update_http_builder(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`ListUserTagsInput`](crate::input::ListUserTagsInput)
    pub fn builder() -> crate::input::list_user_tags_input::Builder {
        crate::input::list_user_tags_input::Builder::default()
    }
}

/// See [`ListVirtualMFADevicesInput`](crate::input::ListVirtualMFADevicesInput)
pub mod list_virtual_mfa_devices_input {
    /// A builder for [`ListVirtualMFADevicesInput`](crate::input::ListVirtualMFADevicesInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) assignment_status: std::option::Option<crate::model::AssignmentStatusType>,
        pub(crate) marker: std::option::Option<std::string::String>,
        pub(crate) max_items: std::option::Option<i32>,
    }
    impl Builder {
        /// <p> The status (<code>Unassigned</code> or <code>Assigned</code>) of the devices to list.
        /// If you do not specify an <code>AssignmentStatus</code>, the operation defaults to
        /// <code>Any</code>, which lists both assigned and unassigned virtual MFA
        /// devices.,</p>
        pub fn assignment_status(mut self, inp: crate::model::AssignmentStatusType) -> Self {
            self.assignment_status = Some(inp);
            self
        }
        pub fn set_assignment_status(
            mut self,
            inp: std::option::Option<crate::model::AssignmentStatusType>,
        ) -> Self {
            self.assignment_status = inp;
            self
        }
        /// <p>Use this parameter only when paginating results and only after
        /// you receive a response indicating that the results are truncated. Set it to the value of the
        /// <code>Marker</code> element in the response that you received to indicate where the next call
        /// should start.</p>
        pub fn marker(mut self, inp: impl Into<std::string::String>) -> Self {
            self.marker = Some(inp.into());
            self
        }
        pub fn set_marker(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.marker = inp;
            self
        }
        /// <p>Use this only when paginating results to indicate the
        /// maximum number of items you want in the response. If additional items exist beyond the maximum
        /// you specify, the <code>IsTruncated</code> response element is <code>true</code>.</p>
        /// <p>If you do not include this parameter, the number of items defaults to 100. Note that
        /// IAM might return fewer results, even when there are more results available. In that case, the
        /// <code>IsTruncated</code> response element returns <code>true</code>, and <code>Marker</code>
        /// contains a value to include in the subsequent call that tells the service where to continue
        /// from.</p>
        pub fn max_items(mut self, inp: i32) -> Self {
            self.max_items = Some(inp);
            self
        }
        pub fn set_max_items(mut self, inp: std::option::Option<i32>) -> Self {
            self.max_items = inp;
            self
        }
        /// Consumes the builder and constructs a [`ListVirtualMFADevicesInput`](crate::input::ListVirtualMFADevicesInput)
        pub fn build(
            self,
        ) -> Result<crate::input::ListVirtualMFADevicesInput, smithy_http::operation::BuildError>
        {
            Ok(crate::input::ListVirtualMFADevicesInput {
                assignment_status: self.assignment_status,
                marker: self.marker,
                max_items: self.max_items,
            })
        }
    }
}
#[doc(hidden)]
pub type ListVirtualMFADevicesInputOperationOutputAlias = crate::operation::ListVirtualMFADevices;
#[doc(hidden)]
pub type ListVirtualMFADevicesInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl ListVirtualMFADevicesInput {
    /// Consumes the builder and constructs an Operation<[`ListVirtualMFADevices`](crate::operation::ListVirtualMFADevices)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> Result<
        smithy_http::operation::Operation<
            crate::operation::ListVirtualMFADevices,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = crate::operation_ser::serialize_operation_list_virtual_mfa_devices(&self)
                .map_err(|err| {
                    smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::ListVirtualMFADevices::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "ListVirtualMFADevices",
                "iam",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) {
        write!(output, "/").expect("formatting should succeed")
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri);
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let builder = http::request::Builder::new();
        let builder = builder.header("Content-Type", "application/x-www-form-urlencoded");
        self.update_http_builder(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`ListVirtualMFADevicesInput`](crate::input::ListVirtualMFADevicesInput)
    pub fn builder() -> crate::input::list_virtual_mfa_devices_input::Builder {
        crate::input::list_virtual_mfa_devices_input::Builder::default()
    }
}

/// See [`PutGroupPolicyInput`](crate::input::PutGroupPolicyInput)
pub mod put_group_policy_input {
    /// A builder for [`PutGroupPolicyInput`](crate::input::PutGroupPolicyInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) group_name: std::option::Option<std::string::String>,
        pub(crate) policy_name: std::option::Option<std::string::String>,
        pub(crate) policy_document: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the group to associate the policy with.</p>
        /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
        /// characters with no spaces. You can also include any of the following characters: _+=,.@-.</p>
        pub fn group_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.group_name = Some(inp.into());
            self
        }
        pub fn set_group_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.group_name = inp;
            self
        }
        /// <p>The name of the policy document.</p>
        /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
        /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
        pub fn policy_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.policy_name = Some(inp.into());
            self
        }
        pub fn set_policy_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.policy_name = inp;
            self
        }
        /// <p>The policy document.</p>
        /// <p>You must provide policies in JSON format in IAM. However, for AWS CloudFormation
        /// templates formatted in YAML, you can provide the policy in JSON or YAML format. AWS
        /// CloudFormation always converts a YAML policy to JSON format before submitting it to
        /// IAM.</p>
        /// <p>The <a href="http://wikipedia.org/wiki/regex">regex pattern</a>
        /// used to validate this parameter is a string of characters consisting of the following:</p>
        /// <ul>
        /// <li>
        /// <p>Any printable ASCII
        /// character ranging from the space character (<code>\u0020</code>) through the end of the ASCII character range</p>
        /// </li>
        /// <li>
        /// <p>The printable characters in the Basic Latin and  Latin-1 Supplement character set
        /// (through <code>\u00FF</code>)</p>
        /// </li>
        /// <li>
        /// <p>The special characters tab (<code>\u0009</code>), line feed (<code>\u000A</code>), and
        /// carriage return (<code>\u000D</code>)</p>
        /// </li>
        /// </ul>
        pub fn policy_document(mut self, inp: impl Into<std::string::String>) -> Self {
            self.policy_document = Some(inp.into());
            self
        }
        pub fn set_policy_document(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.policy_document = inp;
            self
        }
        /// Consumes the builder and constructs a [`PutGroupPolicyInput`](crate::input::PutGroupPolicyInput)
        pub fn build(
            self,
        ) -> Result<crate::input::PutGroupPolicyInput, smithy_http::operation::BuildError> {
            Ok(crate::input::PutGroupPolicyInput {
                group_name: self.group_name,
                policy_name: self.policy_name,
                policy_document: self.policy_document,
            })
        }
    }
}
#[doc(hidden)]
pub type PutGroupPolicyInputOperationOutputAlias = crate::operation::PutGroupPolicy;
#[doc(hidden)]
pub type PutGroupPolicyInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl PutGroupPolicyInput {
    /// Consumes the builder and constructs an Operation<[`PutGroupPolicy`](crate::operation::PutGroupPolicy)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> Result<
        smithy_http::operation::Operation<
            crate::operation::PutGroupPolicy,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = crate::operation_ser::serialize_operation_put_group_policy(&self).map_err(
                |err| smithy_http::operation::BuildError::SerializationError(err.into()),
            )?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::PutGroupPolicy::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "PutGroupPolicy",
                "iam",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) {
        write!(output, "/").expect("formatting should succeed")
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri);
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let builder = http::request::Builder::new();
        let builder = builder.header("Content-Type", "application/x-www-form-urlencoded");
        self.update_http_builder(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`PutGroupPolicyInput`](crate::input::PutGroupPolicyInput)
    pub fn builder() -> crate::input::put_group_policy_input::Builder {
        crate::input::put_group_policy_input::Builder::default()
    }
}

/// See [`PutRolePermissionsBoundaryInput`](crate::input::PutRolePermissionsBoundaryInput)
pub mod put_role_permissions_boundary_input {
    /// A builder for [`PutRolePermissionsBoundaryInput`](crate::input::PutRolePermissionsBoundaryInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) role_name: std::option::Option<std::string::String>,
        pub(crate) permissions_boundary: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name (friendly name, not ARN) of the IAM role for which you want to set the
        /// permissions boundary.</p>
        pub fn role_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.role_name = Some(inp.into());
            self
        }
        pub fn set_role_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.role_name = inp;
            self
        }
        /// <p>The ARN of the policy that is used to set the permissions boundary for the
        /// role.</p>
        pub fn permissions_boundary(mut self, inp: impl Into<std::string::String>) -> Self {
            self.permissions_boundary = Some(inp.into());
            self
        }
        pub fn set_permissions_boundary(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.permissions_boundary = inp;
            self
        }
        /// Consumes the builder and constructs a [`PutRolePermissionsBoundaryInput`](crate::input::PutRolePermissionsBoundaryInput)
        pub fn build(
            self,
        ) -> Result<crate::input::PutRolePermissionsBoundaryInput, smithy_http::operation::BuildError>
        {
            Ok(crate::input::PutRolePermissionsBoundaryInput {
                role_name: self.role_name,
                permissions_boundary: self.permissions_boundary,
            })
        }
    }
}
#[doc(hidden)]
pub type PutRolePermissionsBoundaryInputOperationOutputAlias =
    crate::operation::PutRolePermissionsBoundary;
#[doc(hidden)]
pub type PutRolePermissionsBoundaryInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl PutRolePermissionsBoundaryInput {
    /// Consumes the builder and constructs an Operation<[`PutRolePermissionsBoundary`](crate::operation::PutRolePermissionsBoundary)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> Result<
        smithy_http::operation::Operation<
            crate::operation::PutRolePermissionsBoundary,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body =
                crate::operation_ser::serialize_operation_put_role_permissions_boundary(&self)
                    .map_err(|err| {
                        smithy_http::operation::BuildError::SerializationError(err.into())
                    })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::PutRolePermissionsBoundary::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "PutRolePermissionsBoundary",
                "iam",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) {
        write!(output, "/").expect("formatting should succeed")
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri);
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let builder = http::request::Builder::new();
        let builder = builder.header("Content-Type", "application/x-www-form-urlencoded");
        self.update_http_builder(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`PutRolePermissionsBoundaryInput`](crate::input::PutRolePermissionsBoundaryInput)
    pub fn builder() -> crate::input::put_role_permissions_boundary_input::Builder {
        crate::input::put_role_permissions_boundary_input::Builder::default()
    }
}

/// See [`PutRolePolicyInput`](crate::input::PutRolePolicyInput)
pub mod put_role_policy_input {
    /// A builder for [`PutRolePolicyInput`](crate::input::PutRolePolicyInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) role_name: std::option::Option<std::string::String>,
        pub(crate) policy_name: std::option::Option<std::string::String>,
        pub(crate) policy_document: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the role to associate the policy with.</p>
        /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
        /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
        pub fn role_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.role_name = Some(inp.into());
            self
        }
        pub fn set_role_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.role_name = inp;
            self
        }
        /// <p>The name of the policy document.</p>
        /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
        /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
        pub fn policy_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.policy_name = Some(inp.into());
            self
        }
        pub fn set_policy_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.policy_name = inp;
            self
        }
        /// <p>The policy document.</p>
        /// <p>You must provide policies in JSON format in IAM. However, for AWS CloudFormation
        /// templates formatted in YAML, you can provide the policy in JSON or YAML format. AWS
        /// CloudFormation always converts a YAML policy to JSON format before submitting it to
        /// IAM.</p>
        /// <p>The <a href="http://wikipedia.org/wiki/regex">regex pattern</a>
        /// used to validate this parameter is a string of characters consisting of the following:</p>
        /// <ul>
        /// <li>
        /// <p>Any printable ASCII
        /// character ranging from the space character (<code>\u0020</code>) through the end of the ASCII character range</p>
        /// </li>
        /// <li>
        /// <p>The printable characters in the Basic Latin and  Latin-1 Supplement character set
        /// (through <code>\u00FF</code>)</p>
        /// </li>
        /// <li>
        /// <p>The special characters tab (<code>\u0009</code>), line feed (<code>\u000A</code>), and
        /// carriage return (<code>\u000D</code>)</p>
        /// </li>
        /// </ul>
        pub fn policy_document(mut self, inp: impl Into<std::string::String>) -> Self {
            self.policy_document = Some(inp.into());
            self
        }
        pub fn set_policy_document(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.policy_document = inp;
            self
        }
        /// Consumes the builder and constructs a [`PutRolePolicyInput`](crate::input::PutRolePolicyInput)
        pub fn build(
            self,
        ) -> Result<crate::input::PutRolePolicyInput, smithy_http::operation::BuildError> {
            Ok(crate::input::PutRolePolicyInput {
                role_name: self.role_name,
                policy_name: self.policy_name,
                policy_document: self.policy_document,
            })
        }
    }
}
#[doc(hidden)]
pub type PutRolePolicyInputOperationOutputAlias = crate::operation::PutRolePolicy;
#[doc(hidden)]
pub type PutRolePolicyInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl PutRolePolicyInput {
    /// Consumes the builder and constructs an Operation<[`PutRolePolicy`](crate::operation::PutRolePolicy)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> Result<
        smithy_http::operation::Operation<
            crate::operation::PutRolePolicy,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = crate::operation_ser::serialize_operation_put_role_policy(&self).map_err(
                |err| smithy_http::operation::BuildError::SerializationError(err.into()),
            )?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::PutRolePolicy::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "PutRolePolicy",
                "iam",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) {
        write!(output, "/").expect("formatting should succeed")
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri);
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let builder = http::request::Builder::new();
        let builder = builder.header("Content-Type", "application/x-www-form-urlencoded");
        self.update_http_builder(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`PutRolePolicyInput`](crate::input::PutRolePolicyInput)
    pub fn builder() -> crate::input::put_role_policy_input::Builder {
        crate::input::put_role_policy_input::Builder::default()
    }
}

/// See [`PutUserPermissionsBoundaryInput`](crate::input::PutUserPermissionsBoundaryInput)
pub mod put_user_permissions_boundary_input {
    /// A builder for [`PutUserPermissionsBoundaryInput`](crate::input::PutUserPermissionsBoundaryInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) user_name: std::option::Option<std::string::String>,
        pub(crate) permissions_boundary: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name (friendly name, not ARN) of the IAM user for which you want to set the
        /// permissions boundary.</p>
        pub fn user_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.user_name = Some(inp.into());
            self
        }
        pub fn set_user_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.user_name = inp;
            self
        }
        /// <p>The ARN of the policy that is used to set the permissions boundary for the
        /// user.</p>
        pub fn permissions_boundary(mut self, inp: impl Into<std::string::String>) -> Self {
            self.permissions_boundary = Some(inp.into());
            self
        }
        pub fn set_permissions_boundary(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.permissions_boundary = inp;
            self
        }
        /// Consumes the builder and constructs a [`PutUserPermissionsBoundaryInput`](crate::input::PutUserPermissionsBoundaryInput)
        pub fn build(
            self,
        ) -> Result<crate::input::PutUserPermissionsBoundaryInput, smithy_http::operation::BuildError>
        {
            Ok(crate::input::PutUserPermissionsBoundaryInput {
                user_name: self.user_name,
                permissions_boundary: self.permissions_boundary,
            })
        }
    }
}
#[doc(hidden)]
pub type PutUserPermissionsBoundaryInputOperationOutputAlias =
    crate::operation::PutUserPermissionsBoundary;
#[doc(hidden)]
pub type PutUserPermissionsBoundaryInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl PutUserPermissionsBoundaryInput {
    /// Consumes the builder and constructs an Operation<[`PutUserPermissionsBoundary`](crate::operation::PutUserPermissionsBoundary)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> Result<
        smithy_http::operation::Operation<
            crate::operation::PutUserPermissionsBoundary,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body =
                crate::operation_ser::serialize_operation_put_user_permissions_boundary(&self)
                    .map_err(|err| {
                        smithy_http::operation::BuildError::SerializationError(err.into())
                    })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::PutUserPermissionsBoundary::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "PutUserPermissionsBoundary",
                "iam",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) {
        write!(output, "/").expect("formatting should succeed")
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri);
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let builder = http::request::Builder::new();
        let builder = builder.header("Content-Type", "application/x-www-form-urlencoded");
        self.update_http_builder(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`PutUserPermissionsBoundaryInput`](crate::input::PutUserPermissionsBoundaryInput)
    pub fn builder() -> crate::input::put_user_permissions_boundary_input::Builder {
        crate::input::put_user_permissions_boundary_input::Builder::default()
    }
}

/// See [`PutUserPolicyInput`](crate::input::PutUserPolicyInput)
pub mod put_user_policy_input {
    /// A builder for [`PutUserPolicyInput`](crate::input::PutUserPolicyInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) user_name: std::option::Option<std::string::String>,
        pub(crate) policy_name: std::option::Option<std::string::String>,
        pub(crate) policy_document: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the user to associate the policy with.</p>
        /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
        /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
        pub fn user_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.user_name = Some(inp.into());
            self
        }
        pub fn set_user_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.user_name = inp;
            self
        }
        /// <p>The name of the policy document.</p>
        /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
        /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
        pub fn policy_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.policy_name = Some(inp.into());
            self
        }
        pub fn set_policy_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.policy_name = inp;
            self
        }
        /// <p>The policy document.</p>
        /// <p>You must provide policies in JSON format in IAM. However, for AWS CloudFormation
        /// templates formatted in YAML, you can provide the policy in JSON or YAML format. AWS
        /// CloudFormation always converts a YAML policy to JSON format before submitting it to
        /// IAM.</p>
        /// <p>The <a href="http://wikipedia.org/wiki/regex">regex pattern</a>
        /// used to validate this parameter is a string of characters consisting of the following:</p>
        /// <ul>
        /// <li>
        /// <p>Any printable ASCII
        /// character ranging from the space character (<code>\u0020</code>) through the end of the ASCII character range</p>
        /// </li>
        /// <li>
        /// <p>The printable characters in the Basic Latin and  Latin-1 Supplement character set
        /// (through <code>\u00FF</code>)</p>
        /// </li>
        /// <li>
        /// <p>The special characters tab (<code>\u0009</code>), line feed (<code>\u000A</code>), and
        /// carriage return (<code>\u000D</code>)</p>
        /// </li>
        /// </ul>
        pub fn policy_document(mut self, inp: impl Into<std::string::String>) -> Self {
            self.policy_document = Some(inp.into());
            self
        }
        pub fn set_policy_document(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.policy_document = inp;
            self
        }
        /// Consumes the builder and constructs a [`PutUserPolicyInput`](crate::input::PutUserPolicyInput)
        pub fn build(
            self,
        ) -> Result<crate::input::PutUserPolicyInput, smithy_http::operation::BuildError> {
            Ok(crate::input::PutUserPolicyInput {
                user_name: self.user_name,
                policy_name: self.policy_name,
                policy_document: self.policy_document,
            })
        }
    }
}
#[doc(hidden)]
pub type PutUserPolicyInputOperationOutputAlias = crate::operation::PutUserPolicy;
#[doc(hidden)]
pub type PutUserPolicyInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl PutUserPolicyInput {
    /// Consumes the builder and constructs an Operation<[`PutUserPolicy`](crate::operation::PutUserPolicy)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> Result<
        smithy_http::operation::Operation<
            crate::operation::PutUserPolicy,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = crate::operation_ser::serialize_operation_put_user_policy(&self).map_err(
                |err| smithy_http::operation::BuildError::SerializationError(err.into()),
            )?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::PutUserPolicy::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "PutUserPolicy",
                "iam",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) {
        write!(output, "/").expect("formatting should succeed")
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri);
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let builder = http::request::Builder::new();
        let builder = builder.header("Content-Type", "application/x-www-form-urlencoded");
        self.update_http_builder(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`PutUserPolicyInput`](crate::input::PutUserPolicyInput)
    pub fn builder() -> crate::input::put_user_policy_input::Builder {
        crate::input::put_user_policy_input::Builder::default()
    }
}

/// See [`RemoveClientIDFromOpenIDConnectProviderInput`](crate::input::RemoveClientIDFromOpenIDConnectProviderInput)
pub mod remove_client_id_from_open_id_connect_provider_input {
    /// A builder for [`RemoveClientIDFromOpenIDConnectProviderInput`](crate::input::RemoveClientIDFromOpenIDConnectProviderInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) open_id_connect_provider_arn: std::option::Option<std::string::String>,
        pub(crate) client_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the IAM OIDC provider resource to remove the
        /// client ID from. You can get a list of OIDC provider ARNs by using the <a>ListOpenIDConnectProviders</a> operation.</p>
        /// <p>For more information about ARNs, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">Amazon Resource Names (ARNs)</a> in the <i>AWS General Reference</i>.</p>
        pub fn open_id_connect_provider_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.open_id_connect_provider_arn = Some(inp.into());
            self
        }
        pub fn set_open_id_connect_provider_arn(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.open_id_connect_provider_arn = inp;
            self
        }
        /// <p>The client ID (also known as audience) to remove from the IAM OIDC provider
        /// resource. For more information about client IDs, see <a>CreateOpenIDConnectProvider</a>.</p>
        pub fn client_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.client_id = Some(inp.into());
            self
        }
        pub fn set_client_id(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.client_id = inp;
            self
        }
        /// Consumes the builder and constructs a [`RemoveClientIDFromOpenIDConnectProviderInput`](crate::input::RemoveClientIDFromOpenIDConnectProviderInput)
        pub fn build(
            self,
        ) -> Result<
            crate::input::RemoveClientIDFromOpenIDConnectProviderInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::RemoveClientIDFromOpenIDConnectProviderInput {
                open_id_connect_provider_arn: self.open_id_connect_provider_arn,
                client_id: self.client_id,
            })
        }
    }
}
#[doc(hidden)]
pub type RemoveClientIDFromOpenIDConnectProviderInputOperationOutputAlias =
    crate::operation::RemoveClientIDFromOpenIDConnectProvider;
#[doc(hidden)]
pub type RemoveClientIDFromOpenIDConnectProviderInputOperationRetryAlias =
    aws_http::AwsErrorRetryPolicy;
impl RemoveClientIDFromOpenIDConnectProviderInput {
    /// Consumes the builder and constructs an Operation<[`RemoveClientIDFromOpenIDConnectProvider`](crate::operation::RemoveClientIDFromOpenIDConnectProvider)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> Result<
        smithy_http::operation::Operation<
            crate::operation::RemoveClientIDFromOpenIDConnectProvider,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body =
                crate::operation_ser::serialize_operation_remove_client_id_from_open_id_connect_provider(&self).map_err(|err|smithy_http::operation::BuildError::SerializationError(err.into()))?
            ;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::RemoveClientIDFromOpenIDConnectProvider::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "RemoveClientIDFromOpenIDConnectProvider",
                "iam",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) {
        write!(output, "/").expect("formatting should succeed")
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri);
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let builder = http::request::Builder::new();
        let builder = builder.header("Content-Type", "application/x-www-form-urlencoded");
        self.update_http_builder(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`RemoveClientIDFromOpenIDConnectProviderInput`](crate::input::RemoveClientIDFromOpenIDConnectProviderInput)
    pub fn builder() -> crate::input::remove_client_id_from_open_id_connect_provider_input::Builder
    {
        crate::input::remove_client_id_from_open_id_connect_provider_input::Builder::default()
    }
}

/// See [`RemoveRoleFromInstanceProfileInput`](crate::input::RemoveRoleFromInstanceProfileInput)
pub mod remove_role_from_instance_profile_input {
    /// A builder for [`RemoveRoleFromInstanceProfileInput`](crate::input::RemoveRoleFromInstanceProfileInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) instance_profile_name: std::option::Option<std::string::String>,
        pub(crate) role_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the instance profile to update.</p>
        /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
        /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
        pub fn instance_profile_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.instance_profile_name = Some(inp.into());
            self
        }
        pub fn set_instance_profile_name(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.instance_profile_name = inp;
            self
        }
        /// <p>The name of the role to remove.</p>
        /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
        /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
        pub fn role_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.role_name = Some(inp.into());
            self
        }
        pub fn set_role_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.role_name = inp;
            self
        }
        /// Consumes the builder and constructs a [`RemoveRoleFromInstanceProfileInput`](crate::input::RemoveRoleFromInstanceProfileInput)
        pub fn build(
            self,
        ) -> Result<
            crate::input::RemoveRoleFromInstanceProfileInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::RemoveRoleFromInstanceProfileInput {
                instance_profile_name: self.instance_profile_name,
                role_name: self.role_name,
            })
        }
    }
}
#[doc(hidden)]
pub type RemoveRoleFromInstanceProfileInputOperationOutputAlias =
    crate::operation::RemoveRoleFromInstanceProfile;
#[doc(hidden)]
pub type RemoveRoleFromInstanceProfileInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl RemoveRoleFromInstanceProfileInput {
    /// Consumes the builder and constructs an Operation<[`RemoveRoleFromInstanceProfile`](crate::operation::RemoveRoleFromInstanceProfile)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> Result<
        smithy_http::operation::Operation<
            crate::operation::RemoveRoleFromInstanceProfile,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body =
                crate::operation_ser::serialize_operation_remove_role_from_instance_profile(&self)
                    .map_err(|err| {
                        smithy_http::operation::BuildError::SerializationError(err.into())
                    })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::RemoveRoleFromInstanceProfile::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "RemoveRoleFromInstanceProfile",
                "iam",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) {
        write!(output, "/").expect("formatting should succeed")
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri);
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let builder = http::request::Builder::new();
        let builder = builder.header("Content-Type", "application/x-www-form-urlencoded");
        self.update_http_builder(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`RemoveRoleFromInstanceProfileInput`](crate::input::RemoveRoleFromInstanceProfileInput)
    pub fn builder() -> crate::input::remove_role_from_instance_profile_input::Builder {
        crate::input::remove_role_from_instance_profile_input::Builder::default()
    }
}

/// See [`RemoveUserFromGroupInput`](crate::input::RemoveUserFromGroupInput)
pub mod remove_user_from_group_input {
    /// A builder for [`RemoveUserFromGroupInput`](crate::input::RemoveUserFromGroupInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) group_name: std::option::Option<std::string::String>,
        pub(crate) user_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the group to update.</p>
        /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
        /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
        pub fn group_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.group_name = Some(inp.into());
            self
        }
        pub fn set_group_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.group_name = inp;
            self
        }
        /// <p>The name of the user to remove.</p>
        /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
        /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
        pub fn user_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.user_name = Some(inp.into());
            self
        }
        pub fn set_user_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.user_name = inp;
            self
        }
        /// Consumes the builder and constructs a [`RemoveUserFromGroupInput`](crate::input::RemoveUserFromGroupInput)
        pub fn build(
            self,
        ) -> Result<crate::input::RemoveUserFromGroupInput, smithy_http::operation::BuildError>
        {
            Ok(crate::input::RemoveUserFromGroupInput {
                group_name: self.group_name,
                user_name: self.user_name,
            })
        }
    }
}
#[doc(hidden)]
pub type RemoveUserFromGroupInputOperationOutputAlias = crate::operation::RemoveUserFromGroup;
#[doc(hidden)]
pub type RemoveUserFromGroupInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl RemoveUserFromGroupInput {
    /// Consumes the builder and constructs an Operation<[`RemoveUserFromGroup`](crate::operation::RemoveUserFromGroup)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> Result<
        smithy_http::operation::Operation<
            crate::operation::RemoveUserFromGroup,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = crate::operation_ser::serialize_operation_remove_user_from_group(&self)
                .map_err(|err| {
                    smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::RemoveUserFromGroup::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "RemoveUserFromGroup",
                "iam",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) {
        write!(output, "/").expect("formatting should succeed")
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri);
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let builder = http::request::Builder::new();
        let builder = builder.header("Content-Type", "application/x-www-form-urlencoded");
        self.update_http_builder(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`RemoveUserFromGroupInput`](crate::input::RemoveUserFromGroupInput)
    pub fn builder() -> crate::input::remove_user_from_group_input::Builder {
        crate::input::remove_user_from_group_input::Builder::default()
    }
}

/// See [`ResetServiceSpecificCredentialInput`](crate::input::ResetServiceSpecificCredentialInput)
pub mod reset_service_specific_credential_input {
    /// A builder for [`ResetServiceSpecificCredentialInput`](crate::input::ResetServiceSpecificCredentialInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) user_name: std::option::Option<std::string::String>,
        pub(crate) service_specific_credential_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the IAM user associated with the service-specific credential. If this
        /// value is not specified, then the operation assumes the user whose credentials are used
        /// to call the operation.</p>
        /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
        /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
        pub fn user_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.user_name = Some(inp.into());
            self
        }
        pub fn set_user_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.user_name = inp;
            self
        }
        /// <p>The unique identifier of the service-specific credential.</p>
        /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters that can
        /// consist of any upper or lowercased letter or digit.</p>
        pub fn service_specific_credential_id(
            mut self,
            inp: impl Into<std::string::String>,
        ) -> Self {
            self.service_specific_credential_id = Some(inp.into());
            self
        }
        pub fn set_service_specific_credential_id(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.service_specific_credential_id = inp;
            self
        }
        /// Consumes the builder and constructs a [`ResetServiceSpecificCredentialInput`](crate::input::ResetServiceSpecificCredentialInput)
        pub fn build(
            self,
        ) -> Result<
            crate::input::ResetServiceSpecificCredentialInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::ResetServiceSpecificCredentialInput {
                user_name: self.user_name,
                service_specific_credential_id: self.service_specific_credential_id,
            })
        }
    }
}
#[doc(hidden)]
pub type ResetServiceSpecificCredentialInputOperationOutputAlias =
    crate::operation::ResetServiceSpecificCredential;
#[doc(hidden)]
pub type ResetServiceSpecificCredentialInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl ResetServiceSpecificCredentialInput {
    /// Consumes the builder and constructs an Operation<[`ResetServiceSpecificCredential`](crate::operation::ResetServiceSpecificCredential)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> Result<
        smithy_http::operation::Operation<
            crate::operation::ResetServiceSpecificCredential,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body =
                crate::operation_ser::serialize_operation_reset_service_specific_credential(&self)
                    .map_err(|err| {
                        smithy_http::operation::BuildError::SerializationError(err.into())
                    })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::ResetServiceSpecificCredential::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "ResetServiceSpecificCredential",
                "iam",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) {
        write!(output, "/").expect("formatting should succeed")
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri);
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let builder = http::request::Builder::new();
        let builder = builder.header("Content-Type", "application/x-www-form-urlencoded");
        self.update_http_builder(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`ResetServiceSpecificCredentialInput`](crate::input::ResetServiceSpecificCredentialInput)
    pub fn builder() -> crate::input::reset_service_specific_credential_input::Builder {
        crate::input::reset_service_specific_credential_input::Builder::default()
    }
}

/// See [`ResyncMFADeviceInput`](crate::input::ResyncMFADeviceInput)
pub mod resync_mfa_device_input {
    /// A builder for [`ResyncMFADeviceInput`](crate::input::ResyncMFADeviceInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) user_name: std::option::Option<std::string::String>,
        pub(crate) serial_number: std::option::Option<std::string::String>,
        pub(crate) authentication_code1: std::option::Option<std::string::String>,
        pub(crate) authentication_code2: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the user whose MFA device you want to resynchronize.</p>
        /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
        /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
        pub fn user_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.user_name = Some(inp.into());
            self
        }
        pub fn set_user_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.user_name = inp;
            self
        }
        /// <p>Serial number that uniquely identifies the MFA device.</p>
        /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
        /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
        pub fn serial_number(mut self, inp: impl Into<std::string::String>) -> Self {
            self.serial_number = Some(inp.into());
            self
        }
        pub fn set_serial_number(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.serial_number = inp;
            self
        }
        /// <p>An authentication code emitted by the device.</p>
        /// <p>The format for this parameter is a sequence of six digits.</p>
        pub fn authentication_code1(mut self, inp: impl Into<std::string::String>) -> Self {
            self.authentication_code1 = Some(inp.into());
            self
        }
        pub fn set_authentication_code1(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.authentication_code1 = inp;
            self
        }
        /// <p>A subsequent authentication code emitted by the device.</p>
        /// <p>The format for this parameter is a sequence of six digits.</p>
        pub fn authentication_code2(mut self, inp: impl Into<std::string::String>) -> Self {
            self.authentication_code2 = Some(inp.into());
            self
        }
        pub fn set_authentication_code2(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.authentication_code2 = inp;
            self
        }
        /// Consumes the builder and constructs a [`ResyncMFADeviceInput`](crate::input::ResyncMFADeviceInput)
        pub fn build(
            self,
        ) -> Result<crate::input::ResyncMFADeviceInput, smithy_http::operation::BuildError>
        {
            Ok(crate::input::ResyncMFADeviceInput {
                user_name: self.user_name,
                serial_number: self.serial_number,
                authentication_code1: self.authentication_code1,
                authentication_code2: self.authentication_code2,
            })
        }
    }
}
#[doc(hidden)]
pub type ResyncMFADeviceInputOperationOutputAlias = crate::operation::ResyncMFADevice;
#[doc(hidden)]
pub type ResyncMFADeviceInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl ResyncMFADeviceInput {
    /// Consumes the builder and constructs an Operation<[`ResyncMFADevice`](crate::operation::ResyncMFADevice)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> Result<
        smithy_http::operation::Operation<
            crate::operation::ResyncMFADevice,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = crate::operation_ser::serialize_operation_resync_mfa_device(&self).map_err(
                |err| smithy_http::operation::BuildError::SerializationError(err.into()),
            )?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::ResyncMFADevice::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "ResyncMFADevice",
                "iam",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) {
        write!(output, "/").expect("formatting should succeed")
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri);
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let builder = http::request::Builder::new();
        let builder = builder.header("Content-Type", "application/x-www-form-urlencoded");
        self.update_http_builder(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`ResyncMFADeviceInput`](crate::input::ResyncMFADeviceInput)
    pub fn builder() -> crate::input::resync_mfa_device_input::Builder {
        crate::input::resync_mfa_device_input::Builder::default()
    }
}

/// See [`SetDefaultPolicyVersionInput`](crate::input::SetDefaultPolicyVersionInput)
pub mod set_default_policy_version_input {
    /// A builder for [`SetDefaultPolicyVersionInput`](crate::input::SetDefaultPolicyVersionInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) policy_arn: std::option::Option<std::string::String>,
        pub(crate) version_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the IAM policy whose default version you want to
        /// set.</p>
        /// <p>For more information about ARNs, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">Amazon Resource Names (ARNs)</a> in the <i>AWS General Reference</i>.</p>
        pub fn policy_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.policy_arn = Some(inp.into());
            self
        }
        pub fn set_policy_arn(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.policy_arn = inp;
            self
        }
        /// <p>The version of the policy to set as the default (operative) version.</p>
        /// <p>For more information about managed policy versions, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/policies-managed-versions.html">Versioning for managed
        /// policies</a> in the <i>IAM User Guide</i>.</p>
        pub fn version_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.version_id = Some(inp.into());
            self
        }
        pub fn set_version_id(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.version_id = inp;
            self
        }
        /// Consumes the builder and constructs a [`SetDefaultPolicyVersionInput`](crate::input::SetDefaultPolicyVersionInput)
        pub fn build(
            self,
        ) -> Result<crate::input::SetDefaultPolicyVersionInput, smithy_http::operation::BuildError>
        {
            Ok(crate::input::SetDefaultPolicyVersionInput {
                policy_arn: self.policy_arn,
                version_id: self.version_id,
            })
        }
    }
}
#[doc(hidden)]
pub type SetDefaultPolicyVersionInputOperationOutputAlias =
    crate::operation::SetDefaultPolicyVersion;
#[doc(hidden)]
pub type SetDefaultPolicyVersionInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl SetDefaultPolicyVersionInput {
    /// Consumes the builder and constructs an Operation<[`SetDefaultPolicyVersion`](crate::operation::SetDefaultPolicyVersion)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> Result<
        smithy_http::operation::Operation<
            crate::operation::SetDefaultPolicyVersion,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = crate::operation_ser::serialize_operation_set_default_policy_version(&self)
                .map_err(|err| {
                    smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::SetDefaultPolicyVersion::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "SetDefaultPolicyVersion",
                "iam",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) {
        write!(output, "/").expect("formatting should succeed")
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri);
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let builder = http::request::Builder::new();
        let builder = builder.header("Content-Type", "application/x-www-form-urlencoded");
        self.update_http_builder(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`SetDefaultPolicyVersionInput`](crate::input::SetDefaultPolicyVersionInput)
    pub fn builder() -> crate::input::set_default_policy_version_input::Builder {
        crate::input::set_default_policy_version_input::Builder::default()
    }
}

/// See [`SetSecurityTokenServicePreferencesInput`](crate::input::SetSecurityTokenServicePreferencesInput)
pub mod set_security_token_service_preferences_input {
    /// A builder for [`SetSecurityTokenServicePreferencesInput`](crate::input::SetSecurityTokenServicePreferencesInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) global_endpoint_token_version:
            std::option::Option<crate::model::GlobalEndpointTokenVersion>,
    }
    impl Builder {
        /// <p>The version of the global endpoint token. Version 1 tokens are valid only in AWS
        /// Regions that are available by default. These tokens do not work in manually enabled
        /// Regions, such as Asia Pacific (Hong Kong). Version 2 tokens are valid in all Regions.
        /// However, version 2 tokens are longer and might affect systems where you temporarily
        /// store tokens.</p>
        /// <p>For information, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_temp_enable-regions.html">Activating and
        /// deactivating STS in an AWS region</a> in the
        /// <i>IAM User Guide</i>.</p>
        pub fn global_endpoint_token_version(
            mut self,
            inp: crate::model::GlobalEndpointTokenVersion,
        ) -> Self {
            self.global_endpoint_token_version = Some(inp);
            self
        }
        pub fn set_global_endpoint_token_version(
            mut self,
            inp: std::option::Option<crate::model::GlobalEndpointTokenVersion>,
        ) -> Self {
            self.global_endpoint_token_version = inp;
            self
        }
        /// Consumes the builder and constructs a [`SetSecurityTokenServicePreferencesInput`](crate::input::SetSecurityTokenServicePreferencesInput)
        pub fn build(
            self,
        ) -> Result<
            crate::input::SetSecurityTokenServicePreferencesInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::SetSecurityTokenServicePreferencesInput {
                global_endpoint_token_version: self.global_endpoint_token_version,
            })
        }
    }
}
#[doc(hidden)]
pub type SetSecurityTokenServicePreferencesInputOperationOutputAlias =
    crate::operation::SetSecurityTokenServicePreferences;
#[doc(hidden)]
pub type SetSecurityTokenServicePreferencesInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl SetSecurityTokenServicePreferencesInput {
    /// Consumes the builder and constructs an Operation<[`SetSecurityTokenServicePreferences`](crate::operation::SetSecurityTokenServicePreferences)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> Result<
        smithy_http::operation::Operation<
            crate::operation::SetSecurityTokenServicePreferences,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body =
                crate::operation_ser::serialize_operation_set_security_token_service_preferences(
                    &self,
                )
                .map_err(|err| {
                    smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::SetSecurityTokenServicePreferences::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "SetSecurityTokenServicePreferences",
                "iam",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) {
        write!(output, "/").expect("formatting should succeed")
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri);
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let builder = http::request::Builder::new();
        let builder = builder.header("Content-Type", "application/x-www-form-urlencoded");
        self.update_http_builder(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`SetSecurityTokenServicePreferencesInput`](crate::input::SetSecurityTokenServicePreferencesInput)
    pub fn builder() -> crate::input::set_security_token_service_preferences_input::Builder {
        crate::input::set_security_token_service_preferences_input::Builder::default()
    }
}

/// See [`SimulateCustomPolicyInput`](crate::input::SimulateCustomPolicyInput)
pub mod simulate_custom_policy_input {
    /// A builder for [`SimulateCustomPolicyInput`](crate::input::SimulateCustomPolicyInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) policy_input_list: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) permissions_boundary_policy_input_list:
            std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) action_names: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) resource_arns: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) resource_policy: std::option::Option<std::string::String>,
        pub(crate) resource_owner: std::option::Option<std::string::String>,
        pub(crate) caller_arn: std::option::Option<std::string::String>,
        pub(crate) context_entries: std::option::Option<std::vec::Vec<crate::model::ContextEntry>>,
        pub(crate) resource_handling_option: std::option::Option<std::string::String>,
        pub(crate) max_items: std::option::Option<i32>,
        pub(crate) marker: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn policy_input_list(mut self, inp: impl Into<std::string::String>) -> Self {
            let mut v = self.policy_input_list.unwrap_or_default();
            v.push(inp.into());
            self.policy_input_list = Some(v);
            self
        }
        pub fn set_policy_input_list(
            mut self,
            inp: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.policy_input_list = inp;
            self
        }
        pub fn permissions_boundary_policy_input_list(
            mut self,
            inp: impl Into<std::string::String>,
        ) -> Self {
            let mut v = self
                .permissions_boundary_policy_input_list
                .unwrap_or_default();
            v.push(inp.into());
            self.permissions_boundary_policy_input_list = Some(v);
            self
        }
        pub fn set_permissions_boundary_policy_input_list(
            mut self,
            inp: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.permissions_boundary_policy_input_list = inp;
            self
        }
        pub fn action_names(mut self, inp: impl Into<std::string::String>) -> Self {
            let mut v = self.action_names.unwrap_or_default();
            v.push(inp.into());
            self.action_names = Some(v);
            self
        }
        pub fn set_action_names(
            mut self,
            inp: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.action_names = inp;
            self
        }
        pub fn resource_arns(mut self, inp: impl Into<std::string::String>) -> Self {
            let mut v = self.resource_arns.unwrap_or_default();
            v.push(inp.into());
            self.resource_arns = Some(v);
            self
        }
        pub fn set_resource_arns(
            mut self,
            inp: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.resource_arns = inp;
            self
        }
        /// <p>A resource-based policy to include in the simulation provided as a string. Each
        /// resource in the simulation is treated as if it had this policy attached. You can include
        /// only one resource-based policy in a simulation.</p>
        /// <p>The <a href="http://wikipedia.org/wiki/regex">regex pattern</a>
        /// used to validate this parameter is a string of characters consisting of the following:</p>
        /// <ul>
        /// <li>
        /// <p>Any printable ASCII
        /// character ranging from the space character (<code>\u0020</code>) through the end of the ASCII character range</p>
        /// </li>
        /// <li>
        /// <p>The printable characters in the Basic Latin and  Latin-1 Supplement character set
        /// (through <code>\u00FF</code>)</p>
        /// </li>
        /// <li>
        /// <p>The special characters tab (<code>\u0009</code>), line feed (<code>\u000A</code>), and
        /// carriage return (<code>\u000D</code>)</p>
        /// </li>
        /// </ul>
        pub fn resource_policy(mut self, inp: impl Into<std::string::String>) -> Self {
            self.resource_policy = Some(inp.into());
            self
        }
        pub fn set_resource_policy(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.resource_policy = inp;
            self
        }
        /// <p>An ARN representing the AWS account ID that specifies the owner of any simulated
        /// resource that does not identify its owner in the resource ARN. Examples of resource ARNs
        /// include an S3 bucket or object. If <code>ResourceOwner</code> is specified, it is also
        /// used as the account owner of any <code>ResourcePolicy</code> included in the simulation.
        /// If the <code>ResourceOwner</code> parameter is not specified, then the owner of the
        /// resources and the resource policy defaults to the account of the identity provided in
        /// <code>CallerArn</code>. This parameter is required only if you specify a
        /// resource-based policy and account that owns the resource is different from the account
        /// that owns the simulated calling user <code>CallerArn</code>.</p>
        /// <p>The ARN for an account uses the following syntax:
        /// <code>arn:aws:iam::<i>AWS-account-ID</i>:root</code>. For example,
        /// to represent the account with the 112233445566 ID, use the following ARN:
        /// <code>arn:aws:iam::112233445566-ID:root</code>. </p>
        pub fn resource_owner(mut self, inp: impl Into<std::string::String>) -> Self {
            self.resource_owner = Some(inp.into());
            self
        }
        pub fn set_resource_owner(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.resource_owner = inp;
            self
        }
        /// <p>The ARN of the IAM user that you want to use as the simulated caller of the API
        /// operations. <code>CallerArn</code> is required if you include a
        /// <code>ResourcePolicy</code> so that the policy's <code>Principal</code> element has
        /// a value to use in evaluating the policy.</p>
        /// <p>You can specify only the ARN of an IAM user. You cannot specify the ARN of an
        /// assumed role, federated user, or a service principal.</p>
        pub fn caller_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.caller_arn = Some(inp.into());
            self
        }
        pub fn set_caller_arn(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.caller_arn = inp;
            self
        }
        pub fn context_entries(mut self, inp: impl Into<crate::model::ContextEntry>) -> Self {
            let mut v = self.context_entries.unwrap_or_default();
            v.push(inp.into());
            self.context_entries = Some(v);
            self
        }
        pub fn set_context_entries(
            mut self,
            inp: std::option::Option<std::vec::Vec<crate::model::ContextEntry>>,
        ) -> Self {
            self.context_entries = inp;
            self
        }
        /// <p>Specifies the type of simulation to run. Different API operations that support
        /// resource-based policies require different combinations of resources. By specifying the
        /// type of simulation to run, you enable the policy simulator to enforce the presence of
        /// the required resources to ensure reliable simulation results. If your simulation does
        /// not match one of the following scenarios, then you can omit this parameter. The
        /// following list shows each of the supported scenario values and the resources that you
        /// must define to run the simulation.</p>
        /// <p>Each of the EC2 scenarios requires that you specify instance, image, and
        /// security-group resources. If your scenario includes an EBS volume, then you must specify
        /// that volume as a resource. If the EC2 scenario includes VPC, then you must supply the
        /// network-interface resource. If it includes an IP subnet, then you must specify the
        /// subnet resource. For more information on the EC2 scenario options, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-supported-platforms.html">Supported platforms</a> in the <i>Amazon EC2 User
        /// Guide</i>.</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <b>EC2-Classic-InstanceStore</b>
        /// </p>
        /// <p>instance, image, security-group</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>EC2-Classic-EBS</b>
        /// </p>
        /// <p>instance, image, security-group, volume</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>EC2-VPC-InstanceStore</b>
        /// </p>
        /// <p>instance, image, security-group, network-interface</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>EC2-VPC-InstanceStore-Subnet</b>
        /// </p>
        /// <p>instance, image, security-group, network-interface, subnet</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>EC2-VPC-EBS</b>
        /// </p>
        /// <p>instance, image, security-group, network-interface, volume</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>EC2-VPC-EBS-Subnet</b>
        /// </p>
        /// <p>instance, image, security-group, network-interface, subnet, volume</p>
        /// </li>
        /// </ul>
        pub fn resource_handling_option(mut self, inp: impl Into<std::string::String>) -> Self {
            self.resource_handling_option = Some(inp.into());
            self
        }
        pub fn set_resource_handling_option(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.resource_handling_option = inp;
            self
        }
        /// <p>Use this only when paginating results to indicate the
        /// maximum number of items you want in the response. If additional items exist beyond the maximum
        /// you specify, the <code>IsTruncated</code> response element is <code>true</code>.</p>
        /// <p>If you do not include this parameter, the number of items defaults to 100. Note that
        /// IAM might return fewer results, even when there are more results available. In that case, the
        /// <code>IsTruncated</code> response element returns <code>true</code>, and <code>Marker</code>
        /// contains a value to include in the subsequent call that tells the service where to continue
        /// from.</p>
        pub fn max_items(mut self, inp: i32) -> Self {
            self.max_items = Some(inp);
            self
        }
        pub fn set_max_items(mut self, inp: std::option::Option<i32>) -> Self {
            self.max_items = inp;
            self
        }
        /// <p>Use this parameter only when paginating results and only after
        /// you receive a response indicating that the results are truncated. Set it to the value of the
        /// <code>Marker</code> element in the response that you received to indicate where the next call
        /// should start.</p>
        pub fn marker(mut self, inp: impl Into<std::string::String>) -> Self {
            self.marker = Some(inp.into());
            self
        }
        pub fn set_marker(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.marker = inp;
            self
        }
        /// Consumes the builder and constructs a [`SimulateCustomPolicyInput`](crate::input::SimulateCustomPolicyInput)
        pub fn build(
            self,
        ) -> Result<crate::input::SimulateCustomPolicyInput, smithy_http::operation::BuildError>
        {
            Ok(crate::input::SimulateCustomPolicyInput {
                policy_input_list: self.policy_input_list,
                permissions_boundary_policy_input_list: self.permissions_boundary_policy_input_list,
                action_names: self.action_names,
                resource_arns: self.resource_arns,
                resource_policy: self.resource_policy,
                resource_owner: self.resource_owner,
                caller_arn: self.caller_arn,
                context_entries: self.context_entries,
                resource_handling_option: self.resource_handling_option,
                max_items: self.max_items,
                marker: self.marker,
            })
        }
    }
}
#[doc(hidden)]
pub type SimulateCustomPolicyInputOperationOutputAlias = crate::operation::SimulateCustomPolicy;
#[doc(hidden)]
pub type SimulateCustomPolicyInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl SimulateCustomPolicyInput {
    /// Consumes the builder and constructs an Operation<[`SimulateCustomPolicy`](crate::operation::SimulateCustomPolicy)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> Result<
        smithy_http::operation::Operation<
            crate::operation::SimulateCustomPolicy,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = crate::operation_ser::serialize_operation_simulate_custom_policy(&self)
                .map_err(|err| {
                    smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::SimulateCustomPolicy::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "SimulateCustomPolicy",
                "iam",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) {
        write!(output, "/").expect("formatting should succeed")
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri);
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let builder = http::request::Builder::new();
        let builder = builder.header("Content-Type", "application/x-www-form-urlencoded");
        self.update_http_builder(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`SimulateCustomPolicyInput`](crate::input::SimulateCustomPolicyInput)
    pub fn builder() -> crate::input::simulate_custom_policy_input::Builder {
        crate::input::simulate_custom_policy_input::Builder::default()
    }
}

/// See [`SimulatePrincipalPolicyInput`](crate::input::SimulatePrincipalPolicyInput)
pub mod simulate_principal_policy_input {
    /// A builder for [`SimulatePrincipalPolicyInput`](crate::input::SimulatePrincipalPolicyInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) policy_source_arn: std::option::Option<std::string::String>,
        pub(crate) policy_input_list: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) permissions_boundary_policy_input_list:
            std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) action_names: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) resource_arns: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) resource_policy: std::option::Option<std::string::String>,
        pub(crate) resource_owner: std::option::Option<std::string::String>,
        pub(crate) caller_arn: std::option::Option<std::string::String>,
        pub(crate) context_entries: std::option::Option<std::vec::Vec<crate::model::ContextEntry>>,
        pub(crate) resource_handling_option: std::option::Option<std::string::String>,
        pub(crate) max_items: std::option::Option<i32>,
        pub(crate) marker: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of a user, group, or role whose policies you want to
        /// include in the simulation. If you specify a user, group, or role, the simulation
        /// includes all policies that are associated with that entity. If you specify a user, the
        /// simulation also includes all policies that are attached to any groups the user belongs
        /// to.</p>
        /// <p>For more information about ARNs, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">Amazon Resource Names (ARNs)</a> in the <i>AWS General Reference</i>.</p>
        pub fn policy_source_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.policy_source_arn = Some(inp.into());
            self
        }
        pub fn set_policy_source_arn(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.policy_source_arn = inp;
            self
        }
        pub fn policy_input_list(mut self, inp: impl Into<std::string::String>) -> Self {
            let mut v = self.policy_input_list.unwrap_or_default();
            v.push(inp.into());
            self.policy_input_list = Some(v);
            self
        }
        pub fn set_policy_input_list(
            mut self,
            inp: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.policy_input_list = inp;
            self
        }
        pub fn permissions_boundary_policy_input_list(
            mut self,
            inp: impl Into<std::string::String>,
        ) -> Self {
            let mut v = self
                .permissions_boundary_policy_input_list
                .unwrap_or_default();
            v.push(inp.into());
            self.permissions_boundary_policy_input_list = Some(v);
            self
        }
        pub fn set_permissions_boundary_policy_input_list(
            mut self,
            inp: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.permissions_boundary_policy_input_list = inp;
            self
        }
        pub fn action_names(mut self, inp: impl Into<std::string::String>) -> Self {
            let mut v = self.action_names.unwrap_or_default();
            v.push(inp.into());
            self.action_names = Some(v);
            self
        }
        pub fn set_action_names(
            mut self,
            inp: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.action_names = inp;
            self
        }
        pub fn resource_arns(mut self, inp: impl Into<std::string::String>) -> Self {
            let mut v = self.resource_arns.unwrap_or_default();
            v.push(inp.into());
            self.resource_arns = Some(v);
            self
        }
        pub fn set_resource_arns(
            mut self,
            inp: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.resource_arns = inp;
            self
        }
        /// <p>A resource-based policy to include in the simulation provided as a string. Each
        /// resource in the simulation is treated as if it had this policy attached. You can include
        /// only one resource-based policy in a simulation.</p>
        /// <p>The <a href="http://wikipedia.org/wiki/regex">regex pattern</a>
        /// used to validate this parameter is a string of characters consisting of the following:</p>
        /// <ul>
        /// <li>
        /// <p>Any printable ASCII
        /// character ranging from the space character (<code>\u0020</code>) through the end of the ASCII character range</p>
        /// </li>
        /// <li>
        /// <p>The printable characters in the Basic Latin and  Latin-1 Supplement character set
        /// (through <code>\u00FF</code>)</p>
        /// </li>
        /// <li>
        /// <p>The special characters tab (<code>\u0009</code>), line feed (<code>\u000A</code>), and
        /// carriage return (<code>\u000D</code>)</p>
        /// </li>
        /// </ul>
        pub fn resource_policy(mut self, inp: impl Into<std::string::String>) -> Self {
            self.resource_policy = Some(inp.into());
            self
        }
        pub fn set_resource_policy(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.resource_policy = inp;
            self
        }
        /// <p>An AWS account ID that specifies the owner of any simulated resource that does not
        /// identify its owner in the resource ARN. Examples of resource ARNs include an S3 bucket
        /// or object. If <code>ResourceOwner</code> is specified, it is also used as the account
        /// owner of any <code>ResourcePolicy</code> included in the simulation. If the
        /// <code>ResourceOwner</code> parameter is not specified, then the owner of the
        /// resources and the resource policy defaults to the account of the identity provided in
        /// <code>CallerArn</code>. This parameter is required only if you specify a
        /// resource-based policy and account that owns the resource is different from the account
        /// that owns the simulated calling user <code>CallerArn</code>.</p>
        pub fn resource_owner(mut self, inp: impl Into<std::string::String>) -> Self {
            self.resource_owner = Some(inp.into());
            self
        }
        pub fn set_resource_owner(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.resource_owner = inp;
            self
        }
        /// <p>The ARN of the IAM user that you want to specify as the simulated caller of the API
        /// operations. If you do not specify a <code>CallerArn</code>, it defaults to the ARN of
        /// the user that you specify in <code>PolicySourceArn</code>, if you specified a user. If
        /// you include both a <code>PolicySourceArn</code> (for example,
        /// <code>arn:aws:iam::123456789012:user/David</code>) and a <code>CallerArn</code> (for
        /// example, <code>arn:aws:iam::123456789012:user/Bob</code>), the result is that you
        /// simulate calling the API operations as Bob, as if Bob had David's policies.</p>
        /// <p>You can specify only the ARN of an IAM user. You cannot specify the ARN of an
        /// assumed role, federated user, or a service principal.</p>
        /// <p>
        /// <code>CallerArn</code> is required if you include a <code>ResourcePolicy</code> and
        /// the <code>PolicySourceArn</code> is not the ARN for an IAM user. This is required so
        /// that the resource-based policy's <code>Principal</code> element has a value to use in
        /// evaluating the policy.</p>
        /// <p>For more information about ARNs, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">Amazon Resource Names (ARNs)</a> in the <i>AWS General Reference</i>.</p>
        pub fn caller_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.caller_arn = Some(inp.into());
            self
        }
        pub fn set_caller_arn(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.caller_arn = inp;
            self
        }
        pub fn context_entries(mut self, inp: impl Into<crate::model::ContextEntry>) -> Self {
            let mut v = self.context_entries.unwrap_or_default();
            v.push(inp.into());
            self.context_entries = Some(v);
            self
        }
        pub fn set_context_entries(
            mut self,
            inp: std::option::Option<std::vec::Vec<crate::model::ContextEntry>>,
        ) -> Self {
            self.context_entries = inp;
            self
        }
        /// <p>Specifies the type of simulation to run. Different API operations that support
        /// resource-based policies require different combinations of resources. By specifying the
        /// type of simulation to run, you enable the policy simulator to enforce the presence of
        /// the required resources to ensure reliable simulation results. If your simulation does
        /// not match one of the following scenarios, then you can omit this parameter. The
        /// following list shows each of the supported scenario values and the resources that you
        /// must define to run the simulation.</p>
        /// <p>Each of the EC2 scenarios requires that you specify instance, image, and security
        /// group resources. If your scenario includes an EBS volume, then you must specify that
        /// volume as a resource. If the EC2 scenario includes VPC, then you must supply the network
        /// interface resource. If it includes an IP subnet, then you must specify the subnet
        /// resource. For more information on the EC2 scenario options, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-supported-platforms.html">Supported platforms</a> in the <i>Amazon EC2 User
        /// Guide</i>.</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <b>EC2-Classic-InstanceStore</b>
        /// </p>
        /// <p>instance, image, security group</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>EC2-Classic-EBS</b>
        /// </p>
        /// <p>instance, image, security group, volume</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>EC2-VPC-InstanceStore</b>
        /// </p>
        /// <p>instance, image, security group, network interface</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>EC2-VPC-InstanceStore-Subnet</b>
        /// </p>
        /// <p>instance, image, security group, network interface, subnet</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>EC2-VPC-EBS</b>
        /// </p>
        /// <p>instance, image, security group, network interface, volume</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>EC2-VPC-EBS-Subnet</b>
        /// </p>
        /// <p>instance, image, security group, network interface, subnet, volume</p>
        /// </li>
        /// </ul>
        pub fn resource_handling_option(mut self, inp: impl Into<std::string::String>) -> Self {
            self.resource_handling_option = Some(inp.into());
            self
        }
        pub fn set_resource_handling_option(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.resource_handling_option = inp;
            self
        }
        /// <p>Use this only when paginating results to indicate the
        /// maximum number of items you want in the response. If additional items exist beyond the maximum
        /// you specify, the <code>IsTruncated</code> response element is <code>true</code>.</p>
        /// <p>If you do not include this parameter, the number of items defaults to 100. Note that
        /// IAM might return fewer results, even when there are more results available. In that case, the
        /// <code>IsTruncated</code> response element returns <code>true</code>, and <code>Marker</code>
        /// contains a value to include in the subsequent call that tells the service where to continue
        /// from.</p>
        pub fn max_items(mut self, inp: i32) -> Self {
            self.max_items = Some(inp);
            self
        }
        pub fn set_max_items(mut self, inp: std::option::Option<i32>) -> Self {
            self.max_items = inp;
            self
        }
        /// <p>Use this parameter only when paginating results and only after
        /// you receive a response indicating that the results are truncated. Set it to the value of the
        /// <code>Marker</code> element in the response that you received to indicate where the next call
        /// should start.</p>
        pub fn marker(mut self, inp: impl Into<std::string::String>) -> Self {
            self.marker = Some(inp.into());
            self
        }
        pub fn set_marker(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.marker = inp;
            self
        }
        /// Consumes the builder and constructs a [`SimulatePrincipalPolicyInput`](crate::input::SimulatePrincipalPolicyInput)
        pub fn build(
            self,
        ) -> Result<crate::input::SimulatePrincipalPolicyInput, smithy_http::operation::BuildError>
        {
            Ok(crate::input::SimulatePrincipalPolicyInput {
                policy_source_arn: self.policy_source_arn,
                policy_input_list: self.policy_input_list,
                permissions_boundary_policy_input_list: self.permissions_boundary_policy_input_list,
                action_names: self.action_names,
                resource_arns: self.resource_arns,
                resource_policy: self.resource_policy,
                resource_owner: self.resource_owner,
                caller_arn: self.caller_arn,
                context_entries: self.context_entries,
                resource_handling_option: self.resource_handling_option,
                max_items: self.max_items,
                marker: self.marker,
            })
        }
    }
}
#[doc(hidden)]
pub type SimulatePrincipalPolicyInputOperationOutputAlias =
    crate::operation::SimulatePrincipalPolicy;
#[doc(hidden)]
pub type SimulatePrincipalPolicyInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl SimulatePrincipalPolicyInput {
    /// Consumes the builder and constructs an Operation<[`SimulatePrincipalPolicy`](crate::operation::SimulatePrincipalPolicy)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> Result<
        smithy_http::operation::Operation<
            crate::operation::SimulatePrincipalPolicy,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = crate::operation_ser::serialize_operation_simulate_principal_policy(&self)
                .map_err(|err| {
                smithy_http::operation::BuildError::SerializationError(err.into())
            })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::SimulatePrincipalPolicy::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "SimulatePrincipalPolicy",
                "iam",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) {
        write!(output, "/").expect("formatting should succeed")
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri);
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let builder = http::request::Builder::new();
        let builder = builder.header("Content-Type", "application/x-www-form-urlencoded");
        self.update_http_builder(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`SimulatePrincipalPolicyInput`](crate::input::SimulatePrincipalPolicyInput)
    pub fn builder() -> crate::input::simulate_principal_policy_input::Builder {
        crate::input::simulate_principal_policy_input::Builder::default()
    }
}

/// See [`TagInstanceProfileInput`](crate::input::TagInstanceProfileInput)
pub mod tag_instance_profile_input {
    /// A builder for [`TagInstanceProfileInput`](crate::input::TagInstanceProfileInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) instance_profile_name: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    }
    impl Builder {
        /// <p>The name of the IAM instance profile to which you want to add tags.</p>
        /// <p>This parameter accepts (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters that consist of upper and lowercase alphanumeric
        /// characters with no spaces. You can also include any of the following characters: =,.@-</p>
        pub fn instance_profile_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.instance_profile_name = Some(inp.into());
            self
        }
        pub fn set_instance_profile_name(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.instance_profile_name = inp;
            self
        }
        pub fn tags(mut self, inp: impl Into<crate::model::Tag>) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(inp.into());
            self.tags = Some(v);
            self
        }
        pub fn set_tags(
            mut self,
            inp: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = inp;
            self
        }
        /// Consumes the builder and constructs a [`TagInstanceProfileInput`](crate::input::TagInstanceProfileInput)
        pub fn build(
            self,
        ) -> Result<crate::input::TagInstanceProfileInput, smithy_http::operation::BuildError>
        {
            Ok(crate::input::TagInstanceProfileInput {
                instance_profile_name: self.instance_profile_name,
                tags: self.tags,
            })
        }
    }
}
#[doc(hidden)]
pub type TagInstanceProfileInputOperationOutputAlias = crate::operation::TagInstanceProfile;
#[doc(hidden)]
pub type TagInstanceProfileInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl TagInstanceProfileInput {
    /// Consumes the builder and constructs an Operation<[`TagInstanceProfile`](crate::operation::TagInstanceProfile)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> Result<
        smithy_http::operation::Operation<
            crate::operation::TagInstanceProfile,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = crate::operation_ser::serialize_operation_tag_instance_profile(&self)
                .map_err(|err| {
                    smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::TagInstanceProfile::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "TagInstanceProfile",
                "iam",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) {
        write!(output, "/").expect("formatting should succeed")
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri);
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let builder = http::request::Builder::new();
        let builder = builder.header("Content-Type", "application/x-www-form-urlencoded");
        self.update_http_builder(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`TagInstanceProfileInput`](crate::input::TagInstanceProfileInput)
    pub fn builder() -> crate::input::tag_instance_profile_input::Builder {
        crate::input::tag_instance_profile_input::Builder::default()
    }
}

/// See [`TagMFADeviceInput`](crate::input::TagMFADeviceInput)
pub mod tag_mfa_device_input {
    /// A builder for [`TagMFADeviceInput`](crate::input::TagMFADeviceInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) serial_number: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    }
    impl Builder {
        /// <p>The unique identifier for the IAM virtual MFA device to which you want to add tags.
        /// For virtual MFA devices, the serial number is the same as the ARN.</p>
        /// <p>This parameter accepts (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters that consist of upper and lowercase alphanumeric
        /// characters with no spaces. You can also include any of the following characters: =,.@-</p>
        pub fn serial_number(mut self, inp: impl Into<std::string::String>) -> Self {
            self.serial_number = Some(inp.into());
            self
        }
        pub fn set_serial_number(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.serial_number = inp;
            self
        }
        pub fn tags(mut self, inp: impl Into<crate::model::Tag>) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(inp.into());
            self.tags = Some(v);
            self
        }
        pub fn set_tags(
            mut self,
            inp: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = inp;
            self
        }
        /// Consumes the builder and constructs a [`TagMFADeviceInput`](crate::input::TagMFADeviceInput)
        pub fn build(
            self,
        ) -> Result<crate::input::TagMFADeviceInput, smithy_http::operation::BuildError> {
            Ok(crate::input::TagMFADeviceInput {
                serial_number: self.serial_number,
                tags: self.tags,
            })
        }
    }
}
#[doc(hidden)]
pub type TagMFADeviceInputOperationOutputAlias = crate::operation::TagMFADevice;
#[doc(hidden)]
pub type TagMFADeviceInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl TagMFADeviceInput {
    /// Consumes the builder and constructs an Operation<[`TagMFADevice`](crate::operation::TagMFADevice)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> Result<
        smithy_http::operation::Operation<
            crate::operation::TagMFADevice,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body =
                crate::operation_ser::serialize_operation_tag_mfa_device(&self).map_err(|err| {
                    smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::TagMFADevice::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new("TagMFADevice", "iam"));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) {
        write!(output, "/").expect("formatting should succeed")
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri);
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let builder = http::request::Builder::new();
        let builder = builder.header("Content-Type", "application/x-www-form-urlencoded");
        self.update_http_builder(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`TagMFADeviceInput`](crate::input::TagMFADeviceInput)
    pub fn builder() -> crate::input::tag_mfa_device_input::Builder {
        crate::input::tag_mfa_device_input::Builder::default()
    }
}

/// See [`TagOpenIDConnectProviderInput`](crate::input::TagOpenIDConnectProviderInput)
pub mod tag_open_id_connect_provider_input {
    /// A builder for [`TagOpenIDConnectProviderInput`](crate::input::TagOpenIDConnectProviderInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) open_id_connect_provider_arn: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    }
    impl Builder {
        /// <p>The ARN of the OIDC identity provider in IAM to which you want to add tags.</p>
        /// <p>This parameter accepts (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters that consist of upper and lowercase alphanumeric
        /// characters with no spaces. You can also include any of the following characters: =,.@-</p>
        pub fn open_id_connect_provider_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.open_id_connect_provider_arn = Some(inp.into());
            self
        }
        pub fn set_open_id_connect_provider_arn(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.open_id_connect_provider_arn = inp;
            self
        }
        pub fn tags(mut self, inp: impl Into<crate::model::Tag>) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(inp.into());
            self.tags = Some(v);
            self
        }
        pub fn set_tags(
            mut self,
            inp: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = inp;
            self
        }
        /// Consumes the builder and constructs a [`TagOpenIDConnectProviderInput`](crate::input::TagOpenIDConnectProviderInput)
        pub fn build(
            self,
        ) -> Result<crate::input::TagOpenIDConnectProviderInput, smithy_http::operation::BuildError>
        {
            Ok(crate::input::TagOpenIDConnectProviderInput {
                open_id_connect_provider_arn: self.open_id_connect_provider_arn,
                tags: self.tags,
            })
        }
    }
}
#[doc(hidden)]
pub type TagOpenIDConnectProviderInputOperationOutputAlias =
    crate::operation::TagOpenIDConnectProvider;
#[doc(hidden)]
pub type TagOpenIDConnectProviderInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl TagOpenIDConnectProviderInput {
    /// Consumes the builder and constructs an Operation<[`TagOpenIDConnectProvider`](crate::operation::TagOpenIDConnectProvider)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> Result<
        smithy_http::operation::Operation<
            crate::operation::TagOpenIDConnectProvider,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body =
                crate::operation_ser::serialize_operation_tag_open_id_connect_provider(&self)
                    .map_err(|err| {
                        smithy_http::operation::BuildError::SerializationError(err.into())
                    })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::TagOpenIDConnectProvider::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "TagOpenIDConnectProvider",
                "iam",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) {
        write!(output, "/").expect("formatting should succeed")
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri);
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let builder = http::request::Builder::new();
        let builder = builder.header("Content-Type", "application/x-www-form-urlencoded");
        self.update_http_builder(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`TagOpenIDConnectProviderInput`](crate::input::TagOpenIDConnectProviderInput)
    pub fn builder() -> crate::input::tag_open_id_connect_provider_input::Builder {
        crate::input::tag_open_id_connect_provider_input::Builder::default()
    }
}

/// See [`TagPolicyInput`](crate::input::TagPolicyInput)
pub mod tag_policy_input {
    /// A builder for [`TagPolicyInput`](crate::input::TagPolicyInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) policy_arn: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    }
    impl Builder {
        /// <p>The ARN of the IAM customer managed policy to which you want to add tags.</p>
        /// <p>This parameter accepts (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters that consist of upper and lowercase alphanumeric
        /// characters with no spaces. You can also include any of the following characters: =,.@-</p>
        pub fn policy_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.policy_arn = Some(inp.into());
            self
        }
        pub fn set_policy_arn(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.policy_arn = inp;
            self
        }
        pub fn tags(mut self, inp: impl Into<crate::model::Tag>) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(inp.into());
            self.tags = Some(v);
            self
        }
        pub fn set_tags(
            mut self,
            inp: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = inp;
            self
        }
        /// Consumes the builder and constructs a [`TagPolicyInput`](crate::input::TagPolicyInput)
        pub fn build(
            self,
        ) -> Result<crate::input::TagPolicyInput, smithy_http::operation::BuildError> {
            Ok(crate::input::TagPolicyInput {
                policy_arn: self.policy_arn,
                tags: self.tags,
            })
        }
    }
}
#[doc(hidden)]
pub type TagPolicyInputOperationOutputAlias = crate::operation::TagPolicy;
#[doc(hidden)]
pub type TagPolicyInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl TagPolicyInput {
    /// Consumes the builder and constructs an Operation<[`TagPolicy`](crate::operation::TagPolicy)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> Result<
        smithy_http::operation::Operation<
            crate::operation::TagPolicy,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body =
                crate::operation_ser::serialize_operation_tag_policy(&self).map_err(|err| {
                    smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op =
                smithy_http::operation::Operation::new(request, crate::operation::TagPolicy::new())
                    .with_metadata(smithy_http::operation::Metadata::new("TagPolicy", "iam"));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) {
        write!(output, "/").expect("formatting should succeed")
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri);
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let builder = http::request::Builder::new();
        let builder = builder.header("Content-Type", "application/x-www-form-urlencoded");
        self.update_http_builder(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`TagPolicyInput`](crate::input::TagPolicyInput)
    pub fn builder() -> crate::input::tag_policy_input::Builder {
        crate::input::tag_policy_input::Builder::default()
    }
}

/// See [`TagRoleInput`](crate::input::TagRoleInput)
pub mod tag_role_input {
    /// A builder for [`TagRoleInput`](crate::input::TagRoleInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) role_name: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    }
    impl Builder {
        /// <p>The name of the IAM role to which you want to add tags.</p>
        /// <p>This parameter accepts (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters that consist of upper and lowercase alphanumeric
        /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
        pub fn role_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.role_name = Some(inp.into());
            self
        }
        pub fn set_role_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.role_name = inp;
            self
        }
        pub fn tags(mut self, inp: impl Into<crate::model::Tag>) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(inp.into());
            self.tags = Some(v);
            self
        }
        pub fn set_tags(
            mut self,
            inp: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = inp;
            self
        }
        /// Consumes the builder and constructs a [`TagRoleInput`](crate::input::TagRoleInput)
        pub fn build(
            self,
        ) -> Result<crate::input::TagRoleInput, smithy_http::operation::BuildError> {
            Ok(crate::input::TagRoleInput {
                role_name: self.role_name,
                tags: self.tags,
            })
        }
    }
}
#[doc(hidden)]
pub type TagRoleInputOperationOutputAlias = crate::operation::TagRole;
#[doc(hidden)]
pub type TagRoleInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl TagRoleInput {
    /// Consumes the builder and constructs an Operation<[`TagRole`](crate::operation::TagRole)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> Result<
        smithy_http::operation::Operation<crate::operation::TagRole, aws_http::AwsErrorRetryPolicy>,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body =
                crate::operation_ser::serialize_operation_tag_role(&self).map_err(|err| {
                    smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op =
                smithy_http::operation::Operation::new(request, crate::operation::TagRole::new())
                    .with_metadata(smithy_http::operation::Metadata::new("TagRole", "iam"));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) {
        write!(output, "/").expect("formatting should succeed")
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri);
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let builder = http::request::Builder::new();
        let builder = builder.header("Content-Type", "application/x-www-form-urlencoded");
        self.update_http_builder(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`TagRoleInput`](crate::input::TagRoleInput)
    pub fn builder() -> crate::input::tag_role_input::Builder {
        crate::input::tag_role_input::Builder::default()
    }
}

/// See [`TagSAMLProviderInput`](crate::input::TagSAMLProviderInput)
pub mod tag_saml_provider_input {
    /// A builder for [`TagSAMLProviderInput`](crate::input::TagSAMLProviderInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) saml_provider_arn: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    }
    impl Builder {
        /// <p>The ARN of the SAML identity provider in IAM to which you want to add tags.</p>
        /// <p>This parameter accepts (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters that consist of upper and lowercase alphanumeric
        /// characters with no spaces. You can also include any of the following characters: =,.@-</p>
        pub fn saml_provider_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.saml_provider_arn = Some(inp.into());
            self
        }
        pub fn set_saml_provider_arn(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.saml_provider_arn = inp;
            self
        }
        pub fn tags(mut self, inp: impl Into<crate::model::Tag>) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(inp.into());
            self.tags = Some(v);
            self
        }
        pub fn set_tags(
            mut self,
            inp: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = inp;
            self
        }
        /// Consumes the builder and constructs a [`TagSAMLProviderInput`](crate::input::TagSAMLProviderInput)
        pub fn build(
            self,
        ) -> Result<crate::input::TagSAMLProviderInput, smithy_http::operation::BuildError>
        {
            Ok(crate::input::TagSAMLProviderInput {
                saml_provider_arn: self.saml_provider_arn,
                tags: self.tags,
            })
        }
    }
}
#[doc(hidden)]
pub type TagSAMLProviderInputOperationOutputAlias = crate::operation::TagSAMLProvider;
#[doc(hidden)]
pub type TagSAMLProviderInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl TagSAMLProviderInput {
    /// Consumes the builder and constructs an Operation<[`TagSAMLProvider`](crate::operation::TagSAMLProvider)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> Result<
        smithy_http::operation::Operation<
            crate::operation::TagSAMLProvider,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = crate::operation_ser::serialize_operation_tag_saml_provider(&self).map_err(
                |err| smithy_http::operation::BuildError::SerializationError(err.into()),
            )?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::TagSAMLProvider::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "TagSAMLProvider",
                "iam",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) {
        write!(output, "/").expect("formatting should succeed")
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri);
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let builder = http::request::Builder::new();
        let builder = builder.header("Content-Type", "application/x-www-form-urlencoded");
        self.update_http_builder(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`TagSAMLProviderInput`](crate::input::TagSAMLProviderInput)
    pub fn builder() -> crate::input::tag_saml_provider_input::Builder {
        crate::input::tag_saml_provider_input::Builder::default()
    }
}

/// See [`TagServerCertificateInput`](crate::input::TagServerCertificateInput)
pub mod tag_server_certificate_input {
    /// A builder for [`TagServerCertificateInput`](crate::input::TagServerCertificateInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) server_certificate_name: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    }
    impl Builder {
        /// <p>The name of the IAM server certificate to which you want to add tags.</p>
        /// <p>This parameter accepts (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters that consist of upper and lowercase alphanumeric
        /// characters with no spaces. You can also include any of the following characters: =,.@-</p>
        pub fn server_certificate_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.server_certificate_name = Some(inp.into());
            self
        }
        pub fn set_server_certificate_name(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.server_certificate_name = inp;
            self
        }
        pub fn tags(mut self, inp: impl Into<crate::model::Tag>) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(inp.into());
            self.tags = Some(v);
            self
        }
        pub fn set_tags(
            mut self,
            inp: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = inp;
            self
        }
        /// Consumes the builder and constructs a [`TagServerCertificateInput`](crate::input::TagServerCertificateInput)
        pub fn build(
            self,
        ) -> Result<crate::input::TagServerCertificateInput, smithy_http::operation::BuildError>
        {
            Ok(crate::input::TagServerCertificateInput {
                server_certificate_name: self.server_certificate_name,
                tags: self.tags,
            })
        }
    }
}
#[doc(hidden)]
pub type TagServerCertificateInputOperationOutputAlias = crate::operation::TagServerCertificate;
#[doc(hidden)]
pub type TagServerCertificateInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl TagServerCertificateInput {
    /// Consumes the builder and constructs an Operation<[`TagServerCertificate`](crate::operation::TagServerCertificate)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> Result<
        smithy_http::operation::Operation<
            crate::operation::TagServerCertificate,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = crate::operation_ser::serialize_operation_tag_server_certificate(&self)
                .map_err(|err| {
                    smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::TagServerCertificate::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "TagServerCertificate",
                "iam",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) {
        write!(output, "/").expect("formatting should succeed")
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri);
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let builder = http::request::Builder::new();
        let builder = builder.header("Content-Type", "application/x-www-form-urlencoded");
        self.update_http_builder(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`TagServerCertificateInput`](crate::input::TagServerCertificateInput)
    pub fn builder() -> crate::input::tag_server_certificate_input::Builder {
        crate::input::tag_server_certificate_input::Builder::default()
    }
}

/// See [`TagUserInput`](crate::input::TagUserInput)
pub mod tag_user_input {
    /// A builder for [`TagUserInput`](crate::input::TagUserInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) user_name: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    }
    impl Builder {
        /// <p>The name of the IAM user to which you want to add tags.</p>
        /// <p>This parameter accepts (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters that consist of upper and lowercase alphanumeric
        /// characters with no spaces. You can also include any of the following characters: =,.@-</p>
        pub fn user_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.user_name = Some(inp.into());
            self
        }
        pub fn set_user_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.user_name = inp;
            self
        }
        pub fn tags(mut self, inp: impl Into<crate::model::Tag>) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(inp.into());
            self.tags = Some(v);
            self
        }
        pub fn set_tags(
            mut self,
            inp: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = inp;
            self
        }
        /// Consumes the builder and constructs a [`TagUserInput`](crate::input::TagUserInput)
        pub fn build(
            self,
        ) -> Result<crate::input::TagUserInput, smithy_http::operation::BuildError> {
            Ok(crate::input::TagUserInput {
                user_name: self.user_name,
                tags: self.tags,
            })
        }
    }
}
#[doc(hidden)]
pub type TagUserInputOperationOutputAlias = crate::operation::TagUser;
#[doc(hidden)]
pub type TagUserInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl TagUserInput {
    /// Consumes the builder and constructs an Operation<[`TagUser`](crate::operation::TagUser)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> Result<
        smithy_http::operation::Operation<crate::operation::TagUser, aws_http::AwsErrorRetryPolicy>,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body =
                crate::operation_ser::serialize_operation_tag_user(&self).map_err(|err| {
                    smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op =
                smithy_http::operation::Operation::new(request, crate::operation::TagUser::new())
                    .with_metadata(smithy_http::operation::Metadata::new("TagUser", "iam"));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) {
        write!(output, "/").expect("formatting should succeed")
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri);
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let builder = http::request::Builder::new();
        let builder = builder.header("Content-Type", "application/x-www-form-urlencoded");
        self.update_http_builder(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`TagUserInput`](crate::input::TagUserInput)
    pub fn builder() -> crate::input::tag_user_input::Builder {
        crate::input::tag_user_input::Builder::default()
    }
}

/// See [`UntagInstanceProfileInput`](crate::input::UntagInstanceProfileInput)
pub mod untag_instance_profile_input {
    /// A builder for [`UntagInstanceProfileInput`](crate::input::UntagInstanceProfileInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) instance_profile_name: std::option::Option<std::string::String>,
        pub(crate) tag_keys: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// <p>The name of the IAM instance profile from which you want to remove tags.</p>
        /// <p>This parameter accepts (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters that consist of upper and lowercase alphanumeric
        /// characters with no spaces. You can also include any of the following characters: =,.@-</p>
        pub fn instance_profile_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.instance_profile_name = Some(inp.into());
            self
        }
        pub fn set_instance_profile_name(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.instance_profile_name = inp;
            self
        }
        pub fn tag_keys(mut self, inp: impl Into<std::string::String>) -> Self {
            let mut v = self.tag_keys.unwrap_or_default();
            v.push(inp.into());
            self.tag_keys = Some(v);
            self
        }
        pub fn set_tag_keys(
            mut self,
            inp: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.tag_keys = inp;
            self
        }
        /// Consumes the builder and constructs a [`UntagInstanceProfileInput`](crate::input::UntagInstanceProfileInput)
        pub fn build(
            self,
        ) -> Result<crate::input::UntagInstanceProfileInput, smithy_http::operation::BuildError>
        {
            Ok(crate::input::UntagInstanceProfileInput {
                instance_profile_name: self.instance_profile_name,
                tag_keys: self.tag_keys,
            })
        }
    }
}
#[doc(hidden)]
pub type UntagInstanceProfileInputOperationOutputAlias = crate::operation::UntagInstanceProfile;
#[doc(hidden)]
pub type UntagInstanceProfileInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl UntagInstanceProfileInput {
    /// Consumes the builder and constructs an Operation<[`UntagInstanceProfile`](crate::operation::UntagInstanceProfile)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> Result<
        smithy_http::operation::Operation<
            crate::operation::UntagInstanceProfile,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = crate::operation_ser::serialize_operation_untag_instance_profile(&self)
                .map_err(|err| {
                    smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::UntagInstanceProfile::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "UntagInstanceProfile",
                "iam",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) {
        write!(output, "/").expect("formatting should succeed")
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri);
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let builder = http::request::Builder::new();
        let builder = builder.header("Content-Type", "application/x-www-form-urlencoded");
        self.update_http_builder(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`UntagInstanceProfileInput`](crate::input::UntagInstanceProfileInput)
    pub fn builder() -> crate::input::untag_instance_profile_input::Builder {
        crate::input::untag_instance_profile_input::Builder::default()
    }
}

/// See [`UntagMFADeviceInput`](crate::input::UntagMFADeviceInput)
pub mod untag_mfa_device_input {
    /// A builder for [`UntagMFADeviceInput`](crate::input::UntagMFADeviceInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) serial_number: std::option::Option<std::string::String>,
        pub(crate) tag_keys: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// <p>The unique identifier for the IAM virtual MFA device from which you want to remove
        /// tags. For virtual MFA devices, the serial number is the same as the ARN.</p>
        /// <p>This parameter accepts (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters that consist of upper and lowercase alphanumeric
        /// characters with no spaces. You can also include any of the following characters: =,.@-</p>
        pub fn serial_number(mut self, inp: impl Into<std::string::String>) -> Self {
            self.serial_number = Some(inp.into());
            self
        }
        pub fn set_serial_number(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.serial_number = inp;
            self
        }
        pub fn tag_keys(mut self, inp: impl Into<std::string::String>) -> Self {
            let mut v = self.tag_keys.unwrap_or_default();
            v.push(inp.into());
            self.tag_keys = Some(v);
            self
        }
        pub fn set_tag_keys(
            mut self,
            inp: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.tag_keys = inp;
            self
        }
        /// Consumes the builder and constructs a [`UntagMFADeviceInput`](crate::input::UntagMFADeviceInput)
        pub fn build(
            self,
        ) -> Result<crate::input::UntagMFADeviceInput, smithy_http::operation::BuildError> {
            Ok(crate::input::UntagMFADeviceInput {
                serial_number: self.serial_number,
                tag_keys: self.tag_keys,
            })
        }
    }
}
#[doc(hidden)]
pub type UntagMFADeviceInputOperationOutputAlias = crate::operation::UntagMFADevice;
#[doc(hidden)]
pub type UntagMFADeviceInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl UntagMFADeviceInput {
    /// Consumes the builder and constructs an Operation<[`UntagMFADevice`](crate::operation::UntagMFADevice)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> Result<
        smithy_http::operation::Operation<
            crate::operation::UntagMFADevice,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = crate::operation_ser::serialize_operation_untag_mfa_device(&self).map_err(
                |err| smithy_http::operation::BuildError::SerializationError(err.into()),
            )?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::UntagMFADevice::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "UntagMFADevice",
                "iam",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) {
        write!(output, "/").expect("formatting should succeed")
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri);
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let builder = http::request::Builder::new();
        let builder = builder.header("Content-Type", "application/x-www-form-urlencoded");
        self.update_http_builder(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`UntagMFADeviceInput`](crate::input::UntagMFADeviceInput)
    pub fn builder() -> crate::input::untag_mfa_device_input::Builder {
        crate::input::untag_mfa_device_input::Builder::default()
    }
}

/// See [`UntagOpenIDConnectProviderInput`](crate::input::UntagOpenIDConnectProviderInput)
pub mod untag_open_id_connect_provider_input {
    /// A builder for [`UntagOpenIDConnectProviderInput`](crate::input::UntagOpenIDConnectProviderInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) open_id_connect_provider_arn: std::option::Option<std::string::String>,
        pub(crate) tag_keys: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// <p>The ARN of the OIDC provider in IAM from which you want to remove tags.</p>
        /// <p>This parameter accepts (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters that consist of upper and lowercase alphanumeric
        /// characters with no spaces. You can also include any of the following characters: =,.@-</p>
        pub fn open_id_connect_provider_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.open_id_connect_provider_arn = Some(inp.into());
            self
        }
        pub fn set_open_id_connect_provider_arn(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.open_id_connect_provider_arn = inp;
            self
        }
        pub fn tag_keys(mut self, inp: impl Into<std::string::String>) -> Self {
            let mut v = self.tag_keys.unwrap_or_default();
            v.push(inp.into());
            self.tag_keys = Some(v);
            self
        }
        pub fn set_tag_keys(
            mut self,
            inp: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.tag_keys = inp;
            self
        }
        /// Consumes the builder and constructs a [`UntagOpenIDConnectProviderInput`](crate::input::UntagOpenIDConnectProviderInput)
        pub fn build(
            self,
        ) -> Result<crate::input::UntagOpenIDConnectProviderInput, smithy_http::operation::BuildError>
        {
            Ok(crate::input::UntagOpenIDConnectProviderInput {
                open_id_connect_provider_arn: self.open_id_connect_provider_arn,
                tag_keys: self.tag_keys,
            })
        }
    }
}
#[doc(hidden)]
pub type UntagOpenIDConnectProviderInputOperationOutputAlias =
    crate::operation::UntagOpenIDConnectProvider;
#[doc(hidden)]
pub type UntagOpenIDConnectProviderInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl UntagOpenIDConnectProviderInput {
    /// Consumes the builder and constructs an Operation<[`UntagOpenIDConnectProvider`](crate::operation::UntagOpenIDConnectProvider)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> Result<
        smithy_http::operation::Operation<
            crate::operation::UntagOpenIDConnectProvider,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body =
                crate::operation_ser::serialize_operation_untag_open_id_connect_provider(&self)
                    .map_err(|err| {
                        smithy_http::operation::BuildError::SerializationError(err.into())
                    })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::UntagOpenIDConnectProvider::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "UntagOpenIDConnectProvider",
                "iam",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) {
        write!(output, "/").expect("formatting should succeed")
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri);
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let builder = http::request::Builder::new();
        let builder = builder.header("Content-Type", "application/x-www-form-urlencoded");
        self.update_http_builder(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`UntagOpenIDConnectProviderInput`](crate::input::UntagOpenIDConnectProviderInput)
    pub fn builder() -> crate::input::untag_open_id_connect_provider_input::Builder {
        crate::input::untag_open_id_connect_provider_input::Builder::default()
    }
}

/// See [`UntagPolicyInput`](crate::input::UntagPolicyInput)
pub mod untag_policy_input {
    /// A builder for [`UntagPolicyInput`](crate::input::UntagPolicyInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) policy_arn: std::option::Option<std::string::String>,
        pub(crate) tag_keys: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// <p>The ARN of the IAM customer managed policy from which you want to remove
        /// tags.</p>
        /// <p>This parameter accepts (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters that consist of upper and lowercase alphanumeric
        /// characters with no spaces. You can also include any of the following characters: =,.@-</p>
        pub fn policy_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.policy_arn = Some(inp.into());
            self
        }
        pub fn set_policy_arn(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.policy_arn = inp;
            self
        }
        pub fn tag_keys(mut self, inp: impl Into<std::string::String>) -> Self {
            let mut v = self.tag_keys.unwrap_or_default();
            v.push(inp.into());
            self.tag_keys = Some(v);
            self
        }
        pub fn set_tag_keys(
            mut self,
            inp: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.tag_keys = inp;
            self
        }
        /// Consumes the builder and constructs a [`UntagPolicyInput`](crate::input::UntagPolicyInput)
        pub fn build(
            self,
        ) -> Result<crate::input::UntagPolicyInput, smithy_http::operation::BuildError> {
            Ok(crate::input::UntagPolicyInput {
                policy_arn: self.policy_arn,
                tag_keys: self.tag_keys,
            })
        }
    }
}
#[doc(hidden)]
pub type UntagPolicyInputOperationOutputAlias = crate::operation::UntagPolicy;
#[doc(hidden)]
pub type UntagPolicyInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl UntagPolicyInput {
    /// Consumes the builder and constructs an Operation<[`UntagPolicy`](crate::operation::UntagPolicy)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> Result<
        smithy_http::operation::Operation<
            crate::operation::UntagPolicy,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body =
                crate::operation_ser::serialize_operation_untag_policy(&self).map_err(|err| {
                    smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::UntagPolicy::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new("UntagPolicy", "iam"));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) {
        write!(output, "/").expect("formatting should succeed")
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri);
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let builder = http::request::Builder::new();
        let builder = builder.header("Content-Type", "application/x-www-form-urlencoded");
        self.update_http_builder(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`UntagPolicyInput`](crate::input::UntagPolicyInput)
    pub fn builder() -> crate::input::untag_policy_input::Builder {
        crate::input::untag_policy_input::Builder::default()
    }
}

/// See [`UntagRoleInput`](crate::input::UntagRoleInput)
pub mod untag_role_input {
    /// A builder for [`UntagRoleInput`](crate::input::UntagRoleInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) role_name: std::option::Option<std::string::String>,
        pub(crate) tag_keys: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// <p>The name of the IAM role from which you want to remove tags.</p>
        /// <p>This parameter accepts (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters that consist of upper and lowercase alphanumeric
        /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
        pub fn role_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.role_name = Some(inp.into());
            self
        }
        pub fn set_role_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.role_name = inp;
            self
        }
        pub fn tag_keys(mut self, inp: impl Into<std::string::String>) -> Self {
            let mut v = self.tag_keys.unwrap_or_default();
            v.push(inp.into());
            self.tag_keys = Some(v);
            self
        }
        pub fn set_tag_keys(
            mut self,
            inp: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.tag_keys = inp;
            self
        }
        /// Consumes the builder and constructs a [`UntagRoleInput`](crate::input::UntagRoleInput)
        pub fn build(
            self,
        ) -> Result<crate::input::UntagRoleInput, smithy_http::operation::BuildError> {
            Ok(crate::input::UntagRoleInput {
                role_name: self.role_name,
                tag_keys: self.tag_keys,
            })
        }
    }
}
#[doc(hidden)]
pub type UntagRoleInputOperationOutputAlias = crate::operation::UntagRole;
#[doc(hidden)]
pub type UntagRoleInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl UntagRoleInput {
    /// Consumes the builder and constructs an Operation<[`UntagRole`](crate::operation::UntagRole)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> Result<
        smithy_http::operation::Operation<
            crate::operation::UntagRole,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body =
                crate::operation_ser::serialize_operation_untag_role(&self).map_err(|err| {
                    smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op =
                smithy_http::operation::Operation::new(request, crate::operation::UntagRole::new())
                    .with_metadata(smithy_http::operation::Metadata::new("UntagRole", "iam"));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) {
        write!(output, "/").expect("formatting should succeed")
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri);
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let builder = http::request::Builder::new();
        let builder = builder.header("Content-Type", "application/x-www-form-urlencoded");
        self.update_http_builder(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`UntagRoleInput`](crate::input::UntagRoleInput)
    pub fn builder() -> crate::input::untag_role_input::Builder {
        crate::input::untag_role_input::Builder::default()
    }
}

/// See [`UntagSAMLProviderInput`](crate::input::UntagSAMLProviderInput)
pub mod untag_saml_provider_input {
    /// A builder for [`UntagSAMLProviderInput`](crate::input::UntagSAMLProviderInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) saml_provider_arn: std::option::Option<std::string::String>,
        pub(crate) tag_keys: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// <p>The ARN of the SAML identity provider in IAM from which you want to remove
        /// tags.</p>
        /// <p>This parameter accepts (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters that consist of upper and lowercase alphanumeric
        /// characters with no spaces. You can also include any of the following characters: =,.@-</p>
        pub fn saml_provider_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.saml_provider_arn = Some(inp.into());
            self
        }
        pub fn set_saml_provider_arn(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.saml_provider_arn = inp;
            self
        }
        pub fn tag_keys(mut self, inp: impl Into<std::string::String>) -> Self {
            let mut v = self.tag_keys.unwrap_or_default();
            v.push(inp.into());
            self.tag_keys = Some(v);
            self
        }
        pub fn set_tag_keys(
            mut self,
            inp: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.tag_keys = inp;
            self
        }
        /// Consumes the builder and constructs a [`UntagSAMLProviderInput`](crate::input::UntagSAMLProviderInput)
        pub fn build(
            self,
        ) -> Result<crate::input::UntagSAMLProviderInput, smithy_http::operation::BuildError>
        {
            Ok(crate::input::UntagSAMLProviderInput {
                saml_provider_arn: self.saml_provider_arn,
                tag_keys: self.tag_keys,
            })
        }
    }
}
#[doc(hidden)]
pub type UntagSAMLProviderInputOperationOutputAlias = crate::operation::UntagSAMLProvider;
#[doc(hidden)]
pub type UntagSAMLProviderInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl UntagSAMLProviderInput {
    /// Consumes the builder and constructs an Operation<[`UntagSAMLProvider`](crate::operation::UntagSAMLProvider)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> Result<
        smithy_http::operation::Operation<
            crate::operation::UntagSAMLProvider,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = crate::operation_ser::serialize_operation_untag_saml_provider(&self)
                .map_err(|err| {
                    smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::UntagSAMLProvider::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "UntagSAMLProvider",
                "iam",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) {
        write!(output, "/").expect("formatting should succeed")
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri);
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let builder = http::request::Builder::new();
        let builder = builder.header("Content-Type", "application/x-www-form-urlencoded");
        self.update_http_builder(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`UntagSAMLProviderInput`](crate::input::UntagSAMLProviderInput)
    pub fn builder() -> crate::input::untag_saml_provider_input::Builder {
        crate::input::untag_saml_provider_input::Builder::default()
    }
}

/// See [`UntagServerCertificateInput`](crate::input::UntagServerCertificateInput)
pub mod untag_server_certificate_input {
    /// A builder for [`UntagServerCertificateInput`](crate::input::UntagServerCertificateInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) server_certificate_name: std::option::Option<std::string::String>,
        pub(crate) tag_keys: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// <p>The name of the IAM server certificate from which you want to remove tags.</p>
        /// <p>This parameter accepts (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters that consist of upper and lowercase alphanumeric
        /// characters with no spaces. You can also include any of the following characters: =,.@-</p>
        pub fn server_certificate_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.server_certificate_name = Some(inp.into());
            self
        }
        pub fn set_server_certificate_name(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.server_certificate_name = inp;
            self
        }
        pub fn tag_keys(mut self, inp: impl Into<std::string::String>) -> Self {
            let mut v = self.tag_keys.unwrap_or_default();
            v.push(inp.into());
            self.tag_keys = Some(v);
            self
        }
        pub fn set_tag_keys(
            mut self,
            inp: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.tag_keys = inp;
            self
        }
        /// Consumes the builder and constructs a [`UntagServerCertificateInput`](crate::input::UntagServerCertificateInput)
        pub fn build(
            self,
        ) -> Result<crate::input::UntagServerCertificateInput, smithy_http::operation::BuildError>
        {
            Ok(crate::input::UntagServerCertificateInput {
                server_certificate_name: self.server_certificate_name,
                tag_keys: self.tag_keys,
            })
        }
    }
}
#[doc(hidden)]
pub type UntagServerCertificateInputOperationOutputAlias = crate::operation::UntagServerCertificate;
#[doc(hidden)]
pub type UntagServerCertificateInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl UntagServerCertificateInput {
    /// Consumes the builder and constructs an Operation<[`UntagServerCertificate`](crate::operation::UntagServerCertificate)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> Result<
        smithy_http::operation::Operation<
            crate::operation::UntagServerCertificate,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = crate::operation_ser::serialize_operation_untag_server_certificate(&self)
                .map_err(|err| {
                    smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::UntagServerCertificate::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "UntagServerCertificate",
                "iam",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) {
        write!(output, "/").expect("formatting should succeed")
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri);
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let builder = http::request::Builder::new();
        let builder = builder.header("Content-Type", "application/x-www-form-urlencoded");
        self.update_http_builder(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`UntagServerCertificateInput`](crate::input::UntagServerCertificateInput)
    pub fn builder() -> crate::input::untag_server_certificate_input::Builder {
        crate::input::untag_server_certificate_input::Builder::default()
    }
}

/// See [`UntagUserInput`](crate::input::UntagUserInput)
pub mod untag_user_input {
    /// A builder for [`UntagUserInput`](crate::input::UntagUserInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) user_name: std::option::Option<std::string::String>,
        pub(crate) tag_keys: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// <p>The name of the IAM user from which you want to remove tags.</p>
        /// <p>This parameter accepts (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters that consist of upper and lowercase alphanumeric
        /// characters with no spaces. You can also include any of the following characters: =,.@-</p>
        pub fn user_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.user_name = Some(inp.into());
            self
        }
        pub fn set_user_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.user_name = inp;
            self
        }
        pub fn tag_keys(mut self, inp: impl Into<std::string::String>) -> Self {
            let mut v = self.tag_keys.unwrap_or_default();
            v.push(inp.into());
            self.tag_keys = Some(v);
            self
        }
        pub fn set_tag_keys(
            mut self,
            inp: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.tag_keys = inp;
            self
        }
        /// Consumes the builder and constructs a [`UntagUserInput`](crate::input::UntagUserInput)
        pub fn build(
            self,
        ) -> Result<crate::input::UntagUserInput, smithy_http::operation::BuildError> {
            Ok(crate::input::UntagUserInput {
                user_name: self.user_name,
                tag_keys: self.tag_keys,
            })
        }
    }
}
#[doc(hidden)]
pub type UntagUserInputOperationOutputAlias = crate::operation::UntagUser;
#[doc(hidden)]
pub type UntagUserInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl UntagUserInput {
    /// Consumes the builder and constructs an Operation<[`UntagUser`](crate::operation::UntagUser)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> Result<
        smithy_http::operation::Operation<
            crate::operation::UntagUser,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body =
                crate::operation_ser::serialize_operation_untag_user(&self).map_err(|err| {
                    smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op =
                smithy_http::operation::Operation::new(request, crate::operation::UntagUser::new())
                    .with_metadata(smithy_http::operation::Metadata::new("UntagUser", "iam"));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) {
        write!(output, "/").expect("formatting should succeed")
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri);
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let builder = http::request::Builder::new();
        let builder = builder.header("Content-Type", "application/x-www-form-urlencoded");
        self.update_http_builder(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`UntagUserInput`](crate::input::UntagUserInput)
    pub fn builder() -> crate::input::untag_user_input::Builder {
        crate::input::untag_user_input::Builder::default()
    }
}

/// See [`UpdateAccessKeyInput`](crate::input::UpdateAccessKeyInput)
pub mod update_access_key_input {
    /// A builder for [`UpdateAccessKeyInput`](crate::input::UpdateAccessKeyInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) user_name: std::option::Option<std::string::String>,
        pub(crate) access_key_id: std::option::Option<std::string::String>,
        pub(crate) status: std::option::Option<crate::model::StatusType>,
    }
    impl Builder {
        /// <p>The name of the user whose key you want to update.</p>
        /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
        /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
        pub fn user_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.user_name = Some(inp.into());
            self
        }
        pub fn set_user_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.user_name = inp;
            self
        }
        /// <p>The access key ID of the secret access key you want to update.</p>
        /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters that can
        /// consist of any upper or lowercased letter or digit.</p>
        pub fn access_key_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.access_key_id = Some(inp.into());
            self
        }
        pub fn set_access_key_id(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.access_key_id = inp;
            self
        }
        /// <p> The status you want to assign to the secret access key. <code>Active</code> means
        /// that the key can be used for programmatic calls to AWS, while <code>Inactive</code>
        /// means that the key cannot be used.</p>
        pub fn status(mut self, inp: crate::model::StatusType) -> Self {
            self.status = Some(inp);
            self
        }
        pub fn set_status(mut self, inp: std::option::Option<crate::model::StatusType>) -> Self {
            self.status = inp;
            self
        }
        /// Consumes the builder and constructs a [`UpdateAccessKeyInput`](crate::input::UpdateAccessKeyInput)
        pub fn build(
            self,
        ) -> Result<crate::input::UpdateAccessKeyInput, smithy_http::operation::BuildError>
        {
            Ok(crate::input::UpdateAccessKeyInput {
                user_name: self.user_name,
                access_key_id: self.access_key_id,
                status: self.status,
            })
        }
    }
}
#[doc(hidden)]
pub type UpdateAccessKeyInputOperationOutputAlias = crate::operation::UpdateAccessKey;
#[doc(hidden)]
pub type UpdateAccessKeyInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl UpdateAccessKeyInput {
    /// Consumes the builder and constructs an Operation<[`UpdateAccessKey`](crate::operation::UpdateAccessKey)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> Result<
        smithy_http::operation::Operation<
            crate::operation::UpdateAccessKey,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = crate::operation_ser::serialize_operation_update_access_key(&self).map_err(
                |err| smithy_http::operation::BuildError::SerializationError(err.into()),
            )?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::UpdateAccessKey::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "UpdateAccessKey",
                "iam",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) {
        write!(output, "/").expect("formatting should succeed")
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri);
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let builder = http::request::Builder::new();
        let builder = builder.header("Content-Type", "application/x-www-form-urlencoded");
        self.update_http_builder(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`UpdateAccessKeyInput`](crate::input::UpdateAccessKeyInput)
    pub fn builder() -> crate::input::update_access_key_input::Builder {
        crate::input::update_access_key_input::Builder::default()
    }
}

/// See [`UpdateAccountPasswordPolicyInput`](crate::input::UpdateAccountPasswordPolicyInput)
pub mod update_account_password_policy_input {
    /// A builder for [`UpdateAccountPasswordPolicyInput`](crate::input::UpdateAccountPasswordPolicyInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) minimum_password_length: std::option::Option<i32>,
        pub(crate) require_symbols: std::option::Option<bool>,
        pub(crate) require_numbers: std::option::Option<bool>,
        pub(crate) require_uppercase_characters: std::option::Option<bool>,
        pub(crate) require_lowercase_characters: std::option::Option<bool>,
        pub(crate) allow_users_to_change_password: std::option::Option<bool>,
        pub(crate) max_password_age: std::option::Option<i32>,
        pub(crate) password_reuse_prevention: std::option::Option<i32>,
        pub(crate) hard_expiry: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>The minimum number of characters allowed in an IAM user password.</p>
        /// <p>If you do not specify a value for this parameter, then the operation uses the default
        /// value of <code>6</code>.</p>
        pub fn minimum_password_length(mut self, inp: i32) -> Self {
            self.minimum_password_length = Some(inp);
            self
        }
        pub fn set_minimum_password_length(mut self, inp: std::option::Option<i32>) -> Self {
            self.minimum_password_length = inp;
            self
        }
        /// <p>Specifies whether IAM user passwords must contain at least one of the following
        /// non-alphanumeric characters:</p>
        /// <p>! @ # $ % ^ & * ( ) _ + - = [ ] { } | '</p>
        /// <p>If you do not specify a value for this parameter, then the operation uses the default
        /// value of <code>false</code>. The result is that passwords do not require at least one
        /// symbol character.</p>
        pub fn require_symbols(mut self, inp: bool) -> Self {
            self.require_symbols = Some(inp);
            self
        }
        pub fn set_require_symbols(mut self, inp: bool) -> Self {
            self.require_symbols = Some(inp);
            self
        }
        /// <p>Specifies whether IAM user passwords must contain at least one numeric character (0
        /// to 9).</p>
        /// <p>If you do not specify a value for this parameter, then the operation uses the default
        /// value of <code>false</code>. The result is that passwords do not require at least one
        /// numeric character.</p>
        pub fn require_numbers(mut self, inp: bool) -> Self {
            self.require_numbers = Some(inp);
            self
        }
        pub fn set_require_numbers(mut self, inp: bool) -> Self {
            self.require_numbers = Some(inp);
            self
        }
        /// <p>Specifies whether IAM user passwords must contain at least one uppercase character
        /// from the ISO basic Latin alphabet (A to Z).</p>
        /// <p>If you do not specify a value for this parameter, then the operation uses the default
        /// value of <code>false</code>. The result is that passwords do not require at least one
        /// uppercase character.</p>
        pub fn require_uppercase_characters(mut self, inp: bool) -> Self {
            self.require_uppercase_characters = Some(inp);
            self
        }
        pub fn set_require_uppercase_characters(mut self, inp: bool) -> Self {
            self.require_uppercase_characters = Some(inp);
            self
        }
        /// <p>Specifies whether IAM user passwords must contain at least one lowercase character
        /// from the ISO basic Latin alphabet (a to z).</p>
        /// <p>If you do not specify a value for this parameter, then the operation uses the default
        /// value of <code>false</code>. The result is that passwords do not require at least one
        /// lowercase character.</p>
        pub fn require_lowercase_characters(mut self, inp: bool) -> Self {
            self.require_lowercase_characters = Some(inp);
            self
        }
        pub fn set_require_lowercase_characters(mut self, inp: bool) -> Self {
            self.require_lowercase_characters = Some(inp);
            self
        }
        /// <p> Allows all IAM users in your account to use the AWS Management Console to change their own
        /// passwords. For more information, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/HowToPwdIAMUser.html">Letting IAM users change their own
        /// passwords</a> in the <i>IAM User Guide</i>.</p>
        /// <p>If you do not specify a value for this parameter, then the operation uses the default
        /// value of <code>false</code>. The result is that IAM users in the account do not
        /// automatically have permissions to change their own password.</p>
        pub fn allow_users_to_change_password(mut self, inp: bool) -> Self {
            self.allow_users_to_change_password = Some(inp);
            self
        }
        pub fn set_allow_users_to_change_password(mut self, inp: bool) -> Self {
            self.allow_users_to_change_password = Some(inp);
            self
        }
        /// <p>The number of days that an IAM user password is valid.</p>
        /// <p>If you do not specify a value for this parameter, then the operation uses the default
        /// value of <code>0</code>. The result is that IAM user passwords never expire.</p>
        pub fn max_password_age(mut self, inp: i32) -> Self {
            self.max_password_age = Some(inp);
            self
        }
        pub fn set_max_password_age(mut self, inp: std::option::Option<i32>) -> Self {
            self.max_password_age = inp;
            self
        }
        /// <p>Specifies the number of previous passwords that IAM users are prevented from
        /// reusing.</p>
        /// <p>If you do not specify a value for this parameter, then the operation uses the default
        /// value of <code>0</code>. The result is that IAM users are not prevented from reusing
        /// previous passwords.</p>
        pub fn password_reuse_prevention(mut self, inp: i32) -> Self {
            self.password_reuse_prevention = Some(inp);
            self
        }
        pub fn set_password_reuse_prevention(mut self, inp: std::option::Option<i32>) -> Self {
            self.password_reuse_prevention = inp;
            self
        }
        /// <p>Prevents IAM users from setting a new password after their password has expired. The
        /// IAM user cannot be accessed until an administrator resets the password.</p>
        /// <p>If you do not specify a value for this parameter, then the operation uses the default
        /// value of <code>false</code>. The result is that IAM users can change their passwords
        /// after they expire and continue to sign in as the user.</p>
        pub fn hard_expiry(mut self, inp: bool) -> Self {
            self.hard_expiry = Some(inp);
            self
        }
        pub fn set_hard_expiry(mut self, inp: std::option::Option<bool>) -> Self {
            self.hard_expiry = inp;
            self
        }
        /// Consumes the builder and constructs a [`UpdateAccountPasswordPolicyInput`](crate::input::UpdateAccountPasswordPolicyInput)
        pub fn build(
            self,
        ) -> Result<
            crate::input::UpdateAccountPasswordPolicyInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::UpdateAccountPasswordPolicyInput {
                minimum_password_length: self.minimum_password_length,
                require_symbols: self.require_symbols.unwrap_or_default(),
                require_numbers: self.require_numbers.unwrap_or_default(),
                require_uppercase_characters: self.require_uppercase_characters.unwrap_or_default(),
                require_lowercase_characters: self.require_lowercase_characters.unwrap_or_default(),
                allow_users_to_change_password: self
                    .allow_users_to_change_password
                    .unwrap_or_default(),
                max_password_age: self.max_password_age,
                password_reuse_prevention: self.password_reuse_prevention,
                hard_expiry: self.hard_expiry,
            })
        }
    }
}
#[doc(hidden)]
pub type UpdateAccountPasswordPolicyInputOperationOutputAlias =
    crate::operation::UpdateAccountPasswordPolicy;
#[doc(hidden)]
pub type UpdateAccountPasswordPolicyInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl UpdateAccountPasswordPolicyInput {
    /// Consumes the builder and constructs an Operation<[`UpdateAccountPasswordPolicy`](crate::operation::UpdateAccountPasswordPolicy)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> Result<
        smithy_http::operation::Operation<
            crate::operation::UpdateAccountPasswordPolicy,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body =
                crate::operation_ser::serialize_operation_update_account_password_policy(&self)
                    .map_err(|err| {
                        smithy_http::operation::BuildError::SerializationError(err.into())
                    })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::UpdateAccountPasswordPolicy::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "UpdateAccountPasswordPolicy",
                "iam",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) {
        write!(output, "/").expect("formatting should succeed")
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri);
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let builder = http::request::Builder::new();
        let builder = builder.header("Content-Type", "application/x-www-form-urlencoded");
        self.update_http_builder(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`UpdateAccountPasswordPolicyInput`](crate::input::UpdateAccountPasswordPolicyInput)
    pub fn builder() -> crate::input::update_account_password_policy_input::Builder {
        crate::input::update_account_password_policy_input::Builder::default()
    }
}

/// See [`UpdateAssumeRolePolicyInput`](crate::input::UpdateAssumeRolePolicyInput)
pub mod update_assume_role_policy_input {
    /// A builder for [`UpdateAssumeRolePolicyInput`](crate::input::UpdateAssumeRolePolicyInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) role_name: std::option::Option<std::string::String>,
        pub(crate) policy_document: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the role to update with the new policy.</p>
        /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
        /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
        pub fn role_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.role_name = Some(inp.into());
            self
        }
        pub fn set_role_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.role_name = inp;
            self
        }
        /// <p>The policy that grants an entity permission to assume the role.</p>
        /// <p>You must provide policies in JSON format in IAM. However, for AWS CloudFormation
        /// templates formatted in YAML, you can provide the policy in JSON or YAML format. AWS
        /// CloudFormation always converts a YAML policy to JSON format before submitting it to
        /// IAM.</p>
        /// <p>The <a href="http://wikipedia.org/wiki/regex">regex pattern</a>
        /// used to validate this parameter is a string of characters consisting of the following:</p>
        /// <ul>
        /// <li>
        /// <p>Any printable ASCII
        /// character ranging from the space character (<code>\u0020</code>) through the end of the ASCII character range</p>
        /// </li>
        /// <li>
        /// <p>The printable characters in the Basic Latin and  Latin-1 Supplement character set
        /// (through <code>\u00FF</code>)</p>
        /// </li>
        /// <li>
        /// <p>The special characters tab (<code>\u0009</code>), line feed (<code>\u000A</code>), and
        /// carriage return (<code>\u000D</code>)</p>
        /// </li>
        /// </ul>
        pub fn policy_document(mut self, inp: impl Into<std::string::String>) -> Self {
            self.policy_document = Some(inp.into());
            self
        }
        pub fn set_policy_document(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.policy_document = inp;
            self
        }
        /// Consumes the builder and constructs a [`UpdateAssumeRolePolicyInput`](crate::input::UpdateAssumeRolePolicyInput)
        pub fn build(
            self,
        ) -> Result<crate::input::UpdateAssumeRolePolicyInput, smithy_http::operation::BuildError>
        {
            Ok(crate::input::UpdateAssumeRolePolicyInput {
                role_name: self.role_name,
                policy_document: self.policy_document,
            })
        }
    }
}
#[doc(hidden)]
pub type UpdateAssumeRolePolicyInputOperationOutputAlias = crate::operation::UpdateAssumeRolePolicy;
#[doc(hidden)]
pub type UpdateAssumeRolePolicyInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl UpdateAssumeRolePolicyInput {
    /// Consumes the builder and constructs an Operation<[`UpdateAssumeRolePolicy`](crate::operation::UpdateAssumeRolePolicy)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> Result<
        smithy_http::operation::Operation<
            crate::operation::UpdateAssumeRolePolicy,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = crate::operation_ser::serialize_operation_update_assume_role_policy(&self)
                .map_err(|err| {
                smithy_http::operation::BuildError::SerializationError(err.into())
            })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::UpdateAssumeRolePolicy::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "UpdateAssumeRolePolicy",
                "iam",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) {
        write!(output, "/").expect("formatting should succeed")
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri);
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let builder = http::request::Builder::new();
        let builder = builder.header("Content-Type", "application/x-www-form-urlencoded");
        self.update_http_builder(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`UpdateAssumeRolePolicyInput`](crate::input::UpdateAssumeRolePolicyInput)
    pub fn builder() -> crate::input::update_assume_role_policy_input::Builder {
        crate::input::update_assume_role_policy_input::Builder::default()
    }
}

/// See [`UpdateGroupInput`](crate::input::UpdateGroupInput)
pub mod update_group_input {
    /// A builder for [`UpdateGroupInput`](crate::input::UpdateGroupInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) group_name: std::option::Option<std::string::String>,
        pub(crate) new_path: std::option::Option<std::string::String>,
        pub(crate) new_group_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Name of the IAM group to update. If you're changing the name of the group, this is
        /// the original name.</p>
        /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
        /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
        pub fn group_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.group_name = Some(inp.into());
            self
        }
        pub fn set_group_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.group_name = inp;
            self
        }
        /// <p>New path for the IAM group. Only include this if changing the group's path.</p>
        /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting
        /// of either a forward slash (/) by itself or a string that must begin and end with forward slashes.
        /// In addition, it can contain any ASCII character from the ! (<code>\u0021</code>) through the DEL character (<code>\u007F</code>), including
        /// most punctuation characters, digits, and upper and lowercased letters.</p>
        pub fn new_path(mut self, inp: impl Into<std::string::String>) -> Self {
            self.new_path = Some(inp.into());
            self
        }
        pub fn set_new_path(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.new_path = inp;
            self
        }
        /// <p>New name for the IAM group. Only include this if changing the group's name.</p>
        /// <p>IAM user, group, role, and policy names must be unique within the account. Names are
        /// not distinguished by case. For example, you cannot create resources named both
        /// "MyResource" and "myresource".</p>
        pub fn new_group_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.new_group_name = Some(inp.into());
            self
        }
        pub fn set_new_group_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.new_group_name = inp;
            self
        }
        /// Consumes the builder and constructs a [`UpdateGroupInput`](crate::input::UpdateGroupInput)
        pub fn build(
            self,
        ) -> Result<crate::input::UpdateGroupInput, smithy_http::operation::BuildError> {
            Ok(crate::input::UpdateGroupInput {
                group_name: self.group_name,
                new_path: self.new_path,
                new_group_name: self.new_group_name,
            })
        }
    }
}
#[doc(hidden)]
pub type UpdateGroupInputOperationOutputAlias = crate::operation::UpdateGroup;
#[doc(hidden)]
pub type UpdateGroupInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl UpdateGroupInput {
    /// Consumes the builder and constructs an Operation<[`UpdateGroup`](crate::operation::UpdateGroup)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> Result<
        smithy_http::operation::Operation<
            crate::operation::UpdateGroup,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body =
                crate::operation_ser::serialize_operation_update_group(&self).map_err(|err| {
                    smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::UpdateGroup::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new("UpdateGroup", "iam"));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) {
        write!(output, "/").expect("formatting should succeed")
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri);
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let builder = http::request::Builder::new();
        let builder = builder.header("Content-Type", "application/x-www-form-urlencoded");
        self.update_http_builder(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`UpdateGroupInput`](crate::input::UpdateGroupInput)
    pub fn builder() -> crate::input::update_group_input::Builder {
        crate::input::update_group_input::Builder::default()
    }
}

/// See [`UpdateLoginProfileInput`](crate::input::UpdateLoginProfileInput)
pub mod update_login_profile_input {
    /// A builder for [`UpdateLoginProfileInput`](crate::input::UpdateLoginProfileInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) user_name: std::option::Option<std::string::String>,
        pub(crate) password: std::option::Option<std::string::String>,
        pub(crate) password_reset_required: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>The name of the user whose password you want to update.</p>
        /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
        /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
        pub fn user_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.user_name = Some(inp.into());
            self
        }
        pub fn set_user_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.user_name = inp;
            self
        }
        /// <p>The new password for the specified IAM user.</p>
        /// <p>The <a href="http://wikipedia.org/wiki/regex">regex pattern</a>
        /// used to validate this parameter is a string of characters consisting of the following:</p>
        /// <ul>
        /// <li>
        /// <p>Any printable ASCII
        /// character ranging from the space character (<code>\u0020</code>) through the end of the ASCII character range</p>
        /// </li>
        /// <li>
        /// <p>The printable characters in the Basic Latin and  Latin-1 Supplement character set
        /// (through <code>\u00FF</code>)</p>
        /// </li>
        /// <li>
        /// <p>The special characters tab (<code>\u0009</code>), line feed (<code>\u000A</code>), and
        /// carriage return (<code>\u000D</code>)</p>
        /// </li>
        /// </ul>
        /// <p>However, the format can be further restricted by the account administrator by setting
        /// a password policy on the AWS account. For more information, see <a>UpdateAccountPasswordPolicy</a>.</p>
        pub fn password(mut self, inp: impl Into<std::string::String>) -> Self {
            self.password = Some(inp.into());
            self
        }
        pub fn set_password(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.password = inp;
            self
        }
        /// <p>Allows this new password to be used only once by requiring the specified IAM user to
        /// set a new password on next sign-in.</p>
        pub fn password_reset_required(mut self, inp: bool) -> Self {
            self.password_reset_required = Some(inp);
            self
        }
        pub fn set_password_reset_required(mut self, inp: std::option::Option<bool>) -> Self {
            self.password_reset_required = inp;
            self
        }
        /// Consumes the builder and constructs a [`UpdateLoginProfileInput`](crate::input::UpdateLoginProfileInput)
        pub fn build(
            self,
        ) -> Result<crate::input::UpdateLoginProfileInput, smithy_http::operation::BuildError>
        {
            Ok(crate::input::UpdateLoginProfileInput {
                user_name: self.user_name,
                password: self.password,
                password_reset_required: self.password_reset_required,
            })
        }
    }
}
#[doc(hidden)]
pub type UpdateLoginProfileInputOperationOutputAlias = crate::operation::UpdateLoginProfile;
#[doc(hidden)]
pub type UpdateLoginProfileInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl UpdateLoginProfileInput {
    /// Consumes the builder and constructs an Operation<[`UpdateLoginProfile`](crate::operation::UpdateLoginProfile)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> Result<
        smithy_http::operation::Operation<
            crate::operation::UpdateLoginProfile,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = crate::operation_ser::serialize_operation_update_login_profile(&self)
                .map_err(|err| {
                    smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::UpdateLoginProfile::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "UpdateLoginProfile",
                "iam",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) {
        write!(output, "/").expect("formatting should succeed")
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri);
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let builder = http::request::Builder::new();
        let builder = builder.header("Content-Type", "application/x-www-form-urlencoded");
        self.update_http_builder(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`UpdateLoginProfileInput`](crate::input::UpdateLoginProfileInput)
    pub fn builder() -> crate::input::update_login_profile_input::Builder {
        crate::input::update_login_profile_input::Builder::default()
    }
}

/// See [`UpdateOpenIDConnectProviderThumbprintInput`](crate::input::UpdateOpenIDConnectProviderThumbprintInput)
pub mod update_open_id_connect_provider_thumbprint_input {
    /// A builder for [`UpdateOpenIDConnectProviderThumbprintInput`](crate::input::UpdateOpenIDConnectProviderThumbprintInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) open_id_connect_provider_arn: std::option::Option<std::string::String>,
        pub(crate) thumbprint_list: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the IAM OIDC provider resource object for which
        /// you want to update the thumbprint. You can get a list of OIDC provider ARNs by using the
        /// <a>ListOpenIDConnectProviders</a> operation.</p>
        /// <p>For more information about ARNs, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">Amazon Resource Names (ARNs)</a> in the <i>AWS General Reference</i>.</p>
        pub fn open_id_connect_provider_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.open_id_connect_provider_arn = Some(inp.into());
            self
        }
        pub fn set_open_id_connect_provider_arn(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.open_id_connect_provider_arn = inp;
            self
        }
        pub fn thumbprint_list(mut self, inp: impl Into<std::string::String>) -> Self {
            let mut v = self.thumbprint_list.unwrap_or_default();
            v.push(inp.into());
            self.thumbprint_list = Some(v);
            self
        }
        pub fn set_thumbprint_list(
            mut self,
            inp: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.thumbprint_list = inp;
            self
        }
        /// Consumes the builder and constructs a [`UpdateOpenIDConnectProviderThumbprintInput`](crate::input::UpdateOpenIDConnectProviderThumbprintInput)
        pub fn build(
            self,
        ) -> Result<
            crate::input::UpdateOpenIDConnectProviderThumbprintInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::UpdateOpenIDConnectProviderThumbprintInput {
                open_id_connect_provider_arn: self.open_id_connect_provider_arn,
                thumbprint_list: self.thumbprint_list,
            })
        }
    }
}
#[doc(hidden)]
pub type UpdateOpenIDConnectProviderThumbprintInputOperationOutputAlias =
    crate::operation::UpdateOpenIDConnectProviderThumbprint;
#[doc(hidden)]
pub type UpdateOpenIDConnectProviderThumbprintInputOperationRetryAlias =
    aws_http::AwsErrorRetryPolicy;
impl UpdateOpenIDConnectProviderThumbprintInput {
    /// Consumes the builder and constructs an Operation<[`UpdateOpenIDConnectProviderThumbprint`](crate::operation::UpdateOpenIDConnectProviderThumbprint)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> Result<
        smithy_http::operation::Operation<
            crate::operation::UpdateOpenIDConnectProviderThumbprint,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body =
                crate::operation_ser::serialize_operation_update_open_id_connect_provider_thumbprint(&self).map_err(|err|smithy_http::operation::BuildError::SerializationError(err.into()))?
            ;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::UpdateOpenIDConnectProviderThumbprint::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "UpdateOpenIDConnectProviderThumbprint",
                "iam",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) {
        write!(output, "/").expect("formatting should succeed")
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri);
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let builder = http::request::Builder::new();
        let builder = builder.header("Content-Type", "application/x-www-form-urlencoded");
        self.update_http_builder(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`UpdateOpenIDConnectProviderThumbprintInput`](crate::input::UpdateOpenIDConnectProviderThumbprintInput)
    pub fn builder() -> crate::input::update_open_id_connect_provider_thumbprint_input::Builder {
        crate::input::update_open_id_connect_provider_thumbprint_input::Builder::default()
    }
}

/// See [`UpdateRoleInput`](crate::input::UpdateRoleInput)
pub mod update_role_input {
    /// A builder for [`UpdateRoleInput`](crate::input::UpdateRoleInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) role_name: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) max_session_duration: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The name of the role that you want to modify.</p>
        pub fn role_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.role_name = Some(inp.into());
            self
        }
        pub fn set_role_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.role_name = inp;
            self
        }
        /// <p>The new description that you want to apply to the specified role.</p>
        pub fn description(mut self, inp: impl Into<std::string::String>) -> Self {
            self.description = Some(inp.into());
            self
        }
        pub fn set_description(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.description = inp;
            self
        }
        /// <p>The maximum session duration (in seconds) that you want to set for the specified role.
        /// If you do not specify a value for this setting, the default maximum of one hour is
        /// applied. This setting can have a value from 1 hour to 12 hours.</p>
        /// <p>Anyone who assumes the role from the AWS CLI or API can use the
        /// <code>DurationSeconds</code> API parameter or the <code>duration-seconds</code> CLI
        /// parameter to request a longer session. The <code>MaxSessionDuration</code> setting
        /// determines the maximum duration that can be requested using the
        /// <code>DurationSeconds</code> parameter. If users don't specify a value for the
        /// <code>DurationSeconds</code> parameter, their security credentials are valid for one
        /// hour by default. This applies when you use the <code>AssumeRole*</code> API operations
        /// or the <code>assume-role*</code> CLI operations but does not apply when you use those
        /// operations to create a console URL. For more information, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_use.html">Using IAM
        /// roles</a> in the <i>IAM User Guide</i>.</p>
        pub fn max_session_duration(mut self, inp: i32) -> Self {
            self.max_session_duration = Some(inp);
            self
        }
        pub fn set_max_session_duration(mut self, inp: std::option::Option<i32>) -> Self {
            self.max_session_duration = inp;
            self
        }
        /// Consumes the builder and constructs a [`UpdateRoleInput`](crate::input::UpdateRoleInput)
        pub fn build(
            self,
        ) -> Result<crate::input::UpdateRoleInput, smithy_http::operation::BuildError> {
            Ok(crate::input::UpdateRoleInput {
                role_name: self.role_name,
                description: self.description,
                max_session_duration: self.max_session_duration,
            })
        }
    }
}
#[doc(hidden)]
pub type UpdateRoleInputOperationOutputAlias = crate::operation::UpdateRole;
#[doc(hidden)]
pub type UpdateRoleInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl UpdateRoleInput {
    /// Consumes the builder and constructs an Operation<[`UpdateRole`](crate::operation::UpdateRole)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> Result<
        smithy_http::operation::Operation<
            crate::operation::UpdateRole,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body =
                crate::operation_ser::serialize_operation_update_role(&self).map_err(|err| {
                    smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::UpdateRole::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new("UpdateRole", "iam"));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) {
        write!(output, "/").expect("formatting should succeed")
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri);
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let builder = http::request::Builder::new();
        let builder = builder.header("Content-Type", "application/x-www-form-urlencoded");
        self.update_http_builder(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`UpdateRoleInput`](crate::input::UpdateRoleInput)
    pub fn builder() -> crate::input::update_role_input::Builder {
        crate::input::update_role_input::Builder::default()
    }
}

/// See [`UpdateRoleDescriptionInput`](crate::input::UpdateRoleDescriptionInput)
pub mod update_role_description_input {
    /// A builder for [`UpdateRoleDescriptionInput`](crate::input::UpdateRoleDescriptionInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) role_name: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the role that you want to modify.</p>
        pub fn role_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.role_name = Some(inp.into());
            self
        }
        pub fn set_role_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.role_name = inp;
            self
        }
        /// <p>The new description that you want to apply to the specified role.</p>
        pub fn description(mut self, inp: impl Into<std::string::String>) -> Self {
            self.description = Some(inp.into());
            self
        }
        pub fn set_description(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.description = inp;
            self
        }
        /// Consumes the builder and constructs a [`UpdateRoleDescriptionInput`](crate::input::UpdateRoleDescriptionInput)
        pub fn build(
            self,
        ) -> Result<crate::input::UpdateRoleDescriptionInput, smithy_http::operation::BuildError>
        {
            Ok(crate::input::UpdateRoleDescriptionInput {
                role_name: self.role_name,
                description: self.description,
            })
        }
    }
}
#[doc(hidden)]
pub type UpdateRoleDescriptionInputOperationOutputAlias = crate::operation::UpdateRoleDescription;
#[doc(hidden)]
pub type UpdateRoleDescriptionInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl UpdateRoleDescriptionInput {
    /// Consumes the builder and constructs an Operation<[`UpdateRoleDescription`](crate::operation::UpdateRoleDescription)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> Result<
        smithy_http::operation::Operation<
            crate::operation::UpdateRoleDescription,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = crate::operation_ser::serialize_operation_update_role_description(&self)
                .map_err(|err| {
                    smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::UpdateRoleDescription::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "UpdateRoleDescription",
                "iam",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) {
        write!(output, "/").expect("formatting should succeed")
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri);
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let builder = http::request::Builder::new();
        let builder = builder.header("Content-Type", "application/x-www-form-urlencoded");
        self.update_http_builder(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`UpdateRoleDescriptionInput`](crate::input::UpdateRoleDescriptionInput)
    pub fn builder() -> crate::input::update_role_description_input::Builder {
        crate::input::update_role_description_input::Builder::default()
    }
}

/// See [`UpdateSAMLProviderInput`](crate::input::UpdateSAMLProviderInput)
pub mod update_saml_provider_input {
    /// A builder for [`UpdateSAMLProviderInput`](crate::input::UpdateSAMLProviderInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) saml_metadata_document: std::option::Option<std::string::String>,
        pub(crate) saml_provider_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>An XML document generated by an identity provider (IdP) that supports SAML 2.0. The
        /// document includes the issuer's name, expiration information, and keys that can be used
        /// to validate the SAML authentication response (assertions) that are received from the
        /// IdP. You must generate the metadata document using the identity management software that
        /// is used as your organization's IdP.</p>
        pub fn saml_metadata_document(mut self, inp: impl Into<std::string::String>) -> Self {
            self.saml_metadata_document = Some(inp.into());
            self
        }
        pub fn set_saml_metadata_document(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.saml_metadata_document = inp;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the SAML provider to update.</p>
        /// <p>For more information about ARNs, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">Amazon Resource Names (ARNs)</a> in the <i>AWS General Reference</i>.</p>
        pub fn saml_provider_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.saml_provider_arn = Some(inp.into());
            self
        }
        pub fn set_saml_provider_arn(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.saml_provider_arn = inp;
            self
        }
        /// Consumes the builder and constructs a [`UpdateSAMLProviderInput`](crate::input::UpdateSAMLProviderInput)
        pub fn build(
            self,
        ) -> Result<crate::input::UpdateSAMLProviderInput, smithy_http::operation::BuildError>
        {
            Ok(crate::input::UpdateSAMLProviderInput {
                saml_metadata_document: self.saml_metadata_document,
                saml_provider_arn: self.saml_provider_arn,
            })
        }
    }
}
#[doc(hidden)]
pub type UpdateSAMLProviderInputOperationOutputAlias = crate::operation::UpdateSAMLProvider;
#[doc(hidden)]
pub type UpdateSAMLProviderInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl UpdateSAMLProviderInput {
    /// Consumes the builder and constructs an Operation<[`UpdateSAMLProvider`](crate::operation::UpdateSAMLProvider)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> Result<
        smithy_http::operation::Operation<
            crate::operation::UpdateSAMLProvider,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = crate::operation_ser::serialize_operation_update_saml_provider(&self)
                .map_err(|err| {
                    smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::UpdateSAMLProvider::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "UpdateSAMLProvider",
                "iam",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) {
        write!(output, "/").expect("formatting should succeed")
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri);
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let builder = http::request::Builder::new();
        let builder = builder.header("Content-Type", "application/x-www-form-urlencoded");
        self.update_http_builder(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`UpdateSAMLProviderInput`](crate::input::UpdateSAMLProviderInput)
    pub fn builder() -> crate::input::update_saml_provider_input::Builder {
        crate::input::update_saml_provider_input::Builder::default()
    }
}

/// See [`UpdateServerCertificateInput`](crate::input::UpdateServerCertificateInput)
pub mod update_server_certificate_input {
    /// A builder for [`UpdateServerCertificateInput`](crate::input::UpdateServerCertificateInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) server_certificate_name: std::option::Option<std::string::String>,
        pub(crate) new_path: std::option::Option<std::string::String>,
        pub(crate) new_server_certificate_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the server certificate that you want to update.</p>
        /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
        /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
        pub fn server_certificate_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.server_certificate_name = Some(inp.into());
            self
        }
        pub fn set_server_certificate_name(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.server_certificate_name = inp;
            self
        }
        /// <p>The new path for the server certificate. Include this only if you are updating the
        /// server certificate's path.</p>
        /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting
        /// of either a forward slash (/) by itself or a string that must begin and end with forward slashes.
        /// In addition, it can contain any ASCII character from the ! (<code>\u0021</code>) through the DEL character (<code>\u007F</code>), including
        /// most punctuation characters, digits, and upper and lowercased letters.</p>
        pub fn new_path(mut self, inp: impl Into<std::string::String>) -> Self {
            self.new_path = Some(inp.into());
            self
        }
        pub fn set_new_path(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.new_path = inp;
            self
        }
        /// <p>The new name for the server certificate. Include this only if you are updating the
        /// server certificate's name. The name of the certificate cannot contain any spaces.</p>
        /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
        /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
        pub fn new_server_certificate_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.new_server_certificate_name = Some(inp.into());
            self
        }
        pub fn set_new_server_certificate_name(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.new_server_certificate_name = inp;
            self
        }
        /// Consumes the builder and constructs a [`UpdateServerCertificateInput`](crate::input::UpdateServerCertificateInput)
        pub fn build(
            self,
        ) -> Result<crate::input::UpdateServerCertificateInput, smithy_http::operation::BuildError>
        {
            Ok(crate::input::UpdateServerCertificateInput {
                server_certificate_name: self.server_certificate_name,
                new_path: self.new_path,
                new_server_certificate_name: self.new_server_certificate_name,
            })
        }
    }
}
#[doc(hidden)]
pub type UpdateServerCertificateInputOperationOutputAlias =
    crate::operation::UpdateServerCertificate;
#[doc(hidden)]
pub type UpdateServerCertificateInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl UpdateServerCertificateInput {
    /// Consumes the builder and constructs an Operation<[`UpdateServerCertificate`](crate::operation::UpdateServerCertificate)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> Result<
        smithy_http::operation::Operation<
            crate::operation::UpdateServerCertificate,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = crate::operation_ser::serialize_operation_update_server_certificate(&self)
                .map_err(|err| {
                smithy_http::operation::BuildError::SerializationError(err.into())
            })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::UpdateServerCertificate::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "UpdateServerCertificate",
                "iam",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) {
        write!(output, "/").expect("formatting should succeed")
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri);
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let builder = http::request::Builder::new();
        let builder = builder.header("Content-Type", "application/x-www-form-urlencoded");
        self.update_http_builder(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`UpdateServerCertificateInput`](crate::input::UpdateServerCertificateInput)
    pub fn builder() -> crate::input::update_server_certificate_input::Builder {
        crate::input::update_server_certificate_input::Builder::default()
    }
}

/// See [`UpdateServiceSpecificCredentialInput`](crate::input::UpdateServiceSpecificCredentialInput)
pub mod update_service_specific_credential_input {
    /// A builder for [`UpdateServiceSpecificCredentialInput`](crate::input::UpdateServiceSpecificCredentialInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) user_name: std::option::Option<std::string::String>,
        pub(crate) service_specific_credential_id: std::option::Option<std::string::String>,
        pub(crate) status: std::option::Option<crate::model::StatusType>,
    }
    impl Builder {
        /// <p>The name of the IAM user associated with the service-specific credential. If you do
        /// not specify this value, then the operation assumes the user whose credentials are used
        /// to call the operation.</p>
        /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
        /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
        pub fn user_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.user_name = Some(inp.into());
            self
        }
        pub fn set_user_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.user_name = inp;
            self
        }
        /// <p>The unique identifier of the service-specific credential.</p>
        /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters that can
        /// consist of any upper or lowercased letter or digit.</p>
        pub fn service_specific_credential_id(
            mut self,
            inp: impl Into<std::string::String>,
        ) -> Self {
            self.service_specific_credential_id = Some(inp.into());
            self
        }
        pub fn set_service_specific_credential_id(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.service_specific_credential_id = inp;
            self
        }
        /// <p>The status to be assigned to the service-specific credential.</p>
        pub fn status(mut self, inp: crate::model::StatusType) -> Self {
            self.status = Some(inp);
            self
        }
        pub fn set_status(mut self, inp: std::option::Option<crate::model::StatusType>) -> Self {
            self.status = inp;
            self
        }
        /// Consumes the builder and constructs a [`UpdateServiceSpecificCredentialInput`](crate::input::UpdateServiceSpecificCredentialInput)
        pub fn build(
            self,
        ) -> Result<
            crate::input::UpdateServiceSpecificCredentialInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::UpdateServiceSpecificCredentialInput {
                user_name: self.user_name,
                service_specific_credential_id: self.service_specific_credential_id,
                status: self.status,
            })
        }
    }
}
#[doc(hidden)]
pub type UpdateServiceSpecificCredentialInputOperationOutputAlias =
    crate::operation::UpdateServiceSpecificCredential;
#[doc(hidden)]
pub type UpdateServiceSpecificCredentialInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl UpdateServiceSpecificCredentialInput {
    /// Consumes the builder and constructs an Operation<[`UpdateServiceSpecificCredential`](crate::operation::UpdateServiceSpecificCredential)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> Result<
        smithy_http::operation::Operation<
            crate::operation::UpdateServiceSpecificCredential,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body =
                crate::operation_ser::serialize_operation_update_service_specific_credential(&self)
                    .map_err(|err| {
                        smithy_http::operation::BuildError::SerializationError(err.into())
                    })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::UpdateServiceSpecificCredential::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "UpdateServiceSpecificCredential",
                "iam",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) {
        write!(output, "/").expect("formatting should succeed")
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri);
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let builder = http::request::Builder::new();
        let builder = builder.header("Content-Type", "application/x-www-form-urlencoded");
        self.update_http_builder(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`UpdateServiceSpecificCredentialInput`](crate::input::UpdateServiceSpecificCredentialInput)
    pub fn builder() -> crate::input::update_service_specific_credential_input::Builder {
        crate::input::update_service_specific_credential_input::Builder::default()
    }
}

/// See [`UpdateSigningCertificateInput`](crate::input::UpdateSigningCertificateInput)
pub mod update_signing_certificate_input {
    /// A builder for [`UpdateSigningCertificateInput`](crate::input::UpdateSigningCertificateInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) user_name: std::option::Option<std::string::String>,
        pub(crate) certificate_id: std::option::Option<std::string::String>,
        pub(crate) status: std::option::Option<crate::model::StatusType>,
    }
    impl Builder {
        /// <p>The name of the IAM user the signing certificate belongs to.</p>
        /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
        /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
        pub fn user_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.user_name = Some(inp.into());
            self
        }
        pub fn set_user_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.user_name = inp;
            self
        }
        /// <p>The ID of the signing certificate you want to update.</p>
        /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters that can
        /// consist of any upper or lowercased letter or digit.</p>
        pub fn certificate_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.certificate_id = Some(inp.into());
            self
        }
        pub fn set_certificate_id(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.certificate_id = inp;
            self
        }
        /// <p> The status you want to assign to the certificate. <code>Active</code> means that the
        /// certificate can be used for programmatic calls to AWS <code>Inactive</code> means that
        /// the certificate cannot be used.</p>
        pub fn status(mut self, inp: crate::model::StatusType) -> Self {
            self.status = Some(inp);
            self
        }
        pub fn set_status(mut self, inp: std::option::Option<crate::model::StatusType>) -> Self {
            self.status = inp;
            self
        }
        /// Consumes the builder and constructs a [`UpdateSigningCertificateInput`](crate::input::UpdateSigningCertificateInput)
        pub fn build(
            self,
        ) -> Result<crate::input::UpdateSigningCertificateInput, smithy_http::operation::BuildError>
        {
            Ok(crate::input::UpdateSigningCertificateInput {
                user_name: self.user_name,
                certificate_id: self.certificate_id,
                status: self.status,
            })
        }
    }
}
#[doc(hidden)]
pub type UpdateSigningCertificateInputOperationOutputAlias =
    crate::operation::UpdateSigningCertificate;
#[doc(hidden)]
pub type UpdateSigningCertificateInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl UpdateSigningCertificateInput {
    /// Consumes the builder and constructs an Operation<[`UpdateSigningCertificate`](crate::operation::UpdateSigningCertificate)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> Result<
        smithy_http::operation::Operation<
            crate::operation::UpdateSigningCertificate,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = crate::operation_ser::serialize_operation_update_signing_certificate(&self)
                .map_err(|err| {
                    smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::UpdateSigningCertificate::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "UpdateSigningCertificate",
                "iam",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) {
        write!(output, "/").expect("formatting should succeed")
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri);
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let builder = http::request::Builder::new();
        let builder = builder.header("Content-Type", "application/x-www-form-urlencoded");
        self.update_http_builder(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`UpdateSigningCertificateInput`](crate::input::UpdateSigningCertificateInput)
    pub fn builder() -> crate::input::update_signing_certificate_input::Builder {
        crate::input::update_signing_certificate_input::Builder::default()
    }
}

/// See [`UpdateSSHPublicKeyInput`](crate::input::UpdateSSHPublicKeyInput)
pub mod update_ssh_public_key_input {
    /// A builder for [`UpdateSSHPublicKeyInput`](crate::input::UpdateSSHPublicKeyInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) user_name: std::option::Option<std::string::String>,
        pub(crate) ssh_public_key_id: std::option::Option<std::string::String>,
        pub(crate) status: std::option::Option<crate::model::StatusType>,
    }
    impl Builder {
        /// <p>The name of the IAM user associated with the SSH public key.</p>
        /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
        /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
        pub fn user_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.user_name = Some(inp.into());
            self
        }
        pub fn set_user_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.user_name = inp;
            self
        }
        /// <p>The unique identifier for the SSH public key.</p>
        /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters that can
        /// consist of any upper or lowercased letter or digit.</p>
        pub fn ssh_public_key_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.ssh_public_key_id = Some(inp.into());
            self
        }
        pub fn set_ssh_public_key_id(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.ssh_public_key_id = inp;
            self
        }
        /// <p>The status to assign to the SSH public key. <code>Active</code> means that the key can
        /// be used for authentication with an AWS CodeCommit repository. <code>Inactive</code> means that
        /// the key cannot be used.</p>
        pub fn status(mut self, inp: crate::model::StatusType) -> Self {
            self.status = Some(inp);
            self
        }
        pub fn set_status(mut self, inp: std::option::Option<crate::model::StatusType>) -> Self {
            self.status = inp;
            self
        }
        /// Consumes the builder and constructs a [`UpdateSSHPublicKeyInput`](crate::input::UpdateSSHPublicKeyInput)
        pub fn build(
            self,
        ) -> Result<crate::input::UpdateSSHPublicKeyInput, smithy_http::operation::BuildError>
        {
            Ok(crate::input::UpdateSSHPublicKeyInput {
                user_name: self.user_name,
                ssh_public_key_id: self.ssh_public_key_id,
                status: self.status,
            })
        }
    }
}
#[doc(hidden)]
pub type UpdateSSHPublicKeyInputOperationOutputAlias = crate::operation::UpdateSSHPublicKey;
#[doc(hidden)]
pub type UpdateSSHPublicKeyInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl UpdateSSHPublicKeyInput {
    /// Consumes the builder and constructs an Operation<[`UpdateSSHPublicKey`](crate::operation::UpdateSSHPublicKey)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> Result<
        smithy_http::operation::Operation<
            crate::operation::UpdateSSHPublicKey,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = crate::operation_ser::serialize_operation_update_ssh_public_key(&self)
                .map_err(|err| {
                    smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::UpdateSSHPublicKey::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "UpdateSSHPublicKey",
                "iam",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) {
        write!(output, "/").expect("formatting should succeed")
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri);
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let builder = http::request::Builder::new();
        let builder = builder.header("Content-Type", "application/x-www-form-urlencoded");
        self.update_http_builder(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`UpdateSSHPublicKeyInput`](crate::input::UpdateSSHPublicKeyInput)
    pub fn builder() -> crate::input::update_ssh_public_key_input::Builder {
        crate::input::update_ssh_public_key_input::Builder::default()
    }
}

/// See [`UpdateUserInput`](crate::input::UpdateUserInput)
pub mod update_user_input {
    /// A builder for [`UpdateUserInput`](crate::input::UpdateUserInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) user_name: std::option::Option<std::string::String>,
        pub(crate) new_path: std::option::Option<std::string::String>,
        pub(crate) new_user_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Name of the user to update. If you're changing the name of the user, this is the
        /// original user name.</p>
        /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
        /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
        pub fn user_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.user_name = Some(inp.into());
            self
        }
        pub fn set_user_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.user_name = inp;
            self
        }
        /// <p>New path for the IAM user. Include this parameter only if you're changing the user's
        /// path.</p>
        /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting
        /// of either a forward slash (/) by itself or a string that must begin and end with forward slashes.
        /// In addition, it can contain any ASCII character from the ! (<code>\u0021</code>) through the DEL character (<code>\u007F</code>), including
        /// most punctuation characters, digits, and upper and lowercased letters.</p>
        pub fn new_path(mut self, inp: impl Into<std::string::String>) -> Self {
            self.new_path = Some(inp.into());
            self
        }
        pub fn set_new_path(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.new_path = inp;
            self
        }
        /// <p>New name for the user. Include this parameter only if you're changing the user's
        /// name.</p>
        /// <p>IAM user, group, role, and policy names must be unique within the account. Names are
        /// not distinguished by case. For example, you cannot create resources named both
        /// "MyResource" and "myresource".</p>
        pub fn new_user_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.new_user_name = Some(inp.into());
            self
        }
        pub fn set_new_user_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.new_user_name = inp;
            self
        }
        /// Consumes the builder and constructs a [`UpdateUserInput`](crate::input::UpdateUserInput)
        pub fn build(
            self,
        ) -> Result<crate::input::UpdateUserInput, smithy_http::operation::BuildError> {
            Ok(crate::input::UpdateUserInput {
                user_name: self.user_name,
                new_path: self.new_path,
                new_user_name: self.new_user_name,
            })
        }
    }
}
#[doc(hidden)]
pub type UpdateUserInputOperationOutputAlias = crate::operation::UpdateUser;
#[doc(hidden)]
pub type UpdateUserInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl UpdateUserInput {
    /// Consumes the builder and constructs an Operation<[`UpdateUser`](crate::operation::UpdateUser)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> Result<
        smithy_http::operation::Operation<
            crate::operation::UpdateUser,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body =
                crate::operation_ser::serialize_operation_update_user(&self).map_err(|err| {
                    smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::UpdateUser::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new("UpdateUser", "iam"));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) {
        write!(output, "/").expect("formatting should succeed")
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri);
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let builder = http::request::Builder::new();
        let builder = builder.header("Content-Type", "application/x-www-form-urlencoded");
        self.update_http_builder(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`UpdateUserInput`](crate::input::UpdateUserInput)
    pub fn builder() -> crate::input::update_user_input::Builder {
        crate::input::update_user_input::Builder::default()
    }
}

/// See [`UploadServerCertificateInput`](crate::input::UploadServerCertificateInput)
pub mod upload_server_certificate_input {
    /// A builder for [`UploadServerCertificateInput`](crate::input::UploadServerCertificateInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) path: std::option::Option<std::string::String>,
        pub(crate) server_certificate_name: std::option::Option<std::string::String>,
        pub(crate) certificate_body: std::option::Option<std::string::String>,
        pub(crate) private_key: std::option::Option<std::string::String>,
        pub(crate) certificate_chain: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    }
    impl Builder {
        /// <p>The path for the server certificate. For more information about paths, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html">IAM
        /// identifiers</a> in the <i>IAM User Guide</i>.</p>
        /// <p>This parameter is optional. If it is not included, it defaults to a slash (/).
        /// This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting
        /// of either a forward slash (/) by itself or a string that must begin and end with forward slashes.
        /// In addition, it can contain any ASCII character from the ! (<code>\u0021</code>) through the DEL character (<code>\u007F</code>), including
        /// most punctuation characters, digits, and upper and lowercased letters.</p>
        /// <note>
        /// <p> If you are uploading a server certificate specifically for use with Amazon
        /// CloudFront distributions, you must specify a path using the <code>path</code>
        /// parameter. The path must begin with <code>/cloudfront</code> and must include a
        /// trailing slash (for example, <code>/cloudfront/test/</code>).</p>
        /// </note>
        pub fn path(mut self, inp: impl Into<std::string::String>) -> Self {
            self.path = Some(inp.into());
            self
        }
        pub fn set_path(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.path = inp;
            self
        }
        /// <p>The name for the server certificate. Do not include the path in this value. The name
        /// of the certificate cannot contain any spaces.</p>
        /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
        /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
        pub fn server_certificate_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.server_certificate_name = Some(inp.into());
            self
        }
        pub fn set_server_certificate_name(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.server_certificate_name = inp;
            self
        }
        /// <p>The contents of the public key certificate in PEM-encoded format.</p>
        /// <p>The <a href="http://wikipedia.org/wiki/regex">regex pattern</a>
        /// used to validate this parameter is a string of characters consisting of the following:</p>
        /// <ul>
        /// <li>
        /// <p>Any printable ASCII
        /// character ranging from the space character (<code>\u0020</code>) through the end of the ASCII character range</p>
        /// </li>
        /// <li>
        /// <p>The printable characters in the Basic Latin and  Latin-1 Supplement character set
        /// (through <code>\u00FF</code>)</p>
        /// </li>
        /// <li>
        /// <p>The special characters tab (<code>\u0009</code>), line feed (<code>\u000A</code>), and
        /// carriage return (<code>\u000D</code>)</p>
        /// </li>
        /// </ul>
        pub fn certificate_body(mut self, inp: impl Into<std::string::String>) -> Self {
            self.certificate_body = Some(inp.into());
            self
        }
        pub fn set_certificate_body(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.certificate_body = inp;
            self
        }
        /// <p>The contents of the private key in PEM-encoded format.</p>
        /// <p>The <a href="http://wikipedia.org/wiki/regex">regex pattern</a>
        /// used to validate this parameter is a string of characters consisting of the following:</p>
        /// <ul>
        /// <li>
        /// <p>Any printable ASCII
        /// character ranging from the space character (<code>\u0020</code>) through the end of the ASCII character range</p>
        /// </li>
        /// <li>
        /// <p>The printable characters in the Basic Latin and  Latin-1 Supplement character set
        /// (through <code>\u00FF</code>)</p>
        /// </li>
        /// <li>
        /// <p>The special characters tab (<code>\u0009</code>), line feed (<code>\u000A</code>), and
        /// carriage return (<code>\u000D</code>)</p>
        /// </li>
        /// </ul>
        pub fn private_key(mut self, inp: impl Into<std::string::String>) -> Self {
            self.private_key = Some(inp.into());
            self
        }
        pub fn set_private_key(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.private_key = inp;
            self
        }
        /// <p>The contents of the certificate chain. This is typically a concatenation of the
        /// PEM-encoded public key certificates of the chain.</p>
        /// <p>The <a href="http://wikipedia.org/wiki/regex">regex pattern</a>
        /// used to validate this parameter is a string of characters consisting of the following:</p>
        /// <ul>
        /// <li>
        /// <p>Any printable ASCII
        /// character ranging from the space character (<code>\u0020</code>) through the end of the ASCII character range</p>
        /// </li>
        /// <li>
        /// <p>The printable characters in the Basic Latin and  Latin-1 Supplement character set
        /// (through <code>\u00FF</code>)</p>
        /// </li>
        /// <li>
        /// <p>The special characters tab (<code>\u0009</code>), line feed (<code>\u000A</code>), and
        /// carriage return (<code>\u000D</code>)</p>
        /// </li>
        /// </ul>
        pub fn certificate_chain(mut self, inp: impl Into<std::string::String>) -> Self {
            self.certificate_chain = Some(inp.into());
            self
        }
        pub fn set_certificate_chain(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.certificate_chain = inp;
            self
        }
        pub fn tags(mut self, inp: impl Into<crate::model::Tag>) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(inp.into());
            self.tags = Some(v);
            self
        }
        pub fn set_tags(
            mut self,
            inp: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = inp;
            self
        }
        /// Consumes the builder and constructs a [`UploadServerCertificateInput`](crate::input::UploadServerCertificateInput)
        pub fn build(
            self,
        ) -> Result<crate::input::UploadServerCertificateInput, smithy_http::operation::BuildError>
        {
            Ok(crate::input::UploadServerCertificateInput {
                path: self.path,
                server_certificate_name: self.server_certificate_name,
                certificate_body: self.certificate_body,
                private_key: self.private_key,
                certificate_chain: self.certificate_chain,
                tags: self.tags,
            })
        }
    }
}
#[doc(hidden)]
pub type UploadServerCertificateInputOperationOutputAlias =
    crate::operation::UploadServerCertificate;
#[doc(hidden)]
pub type UploadServerCertificateInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl UploadServerCertificateInput {
    /// Consumes the builder and constructs an Operation<[`UploadServerCertificate`](crate::operation::UploadServerCertificate)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> Result<
        smithy_http::operation::Operation<
            crate::operation::UploadServerCertificate,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = crate::operation_ser::serialize_operation_upload_server_certificate(&self)
                .map_err(|err| {
                smithy_http::operation::BuildError::SerializationError(err.into())
            })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::UploadServerCertificate::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "UploadServerCertificate",
                "iam",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) {
        write!(output, "/").expect("formatting should succeed")
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri);
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let builder = http::request::Builder::new();
        let builder = builder.header("Content-Type", "application/x-www-form-urlencoded");
        self.update_http_builder(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`UploadServerCertificateInput`](crate::input::UploadServerCertificateInput)
    pub fn builder() -> crate::input::upload_server_certificate_input::Builder {
        crate::input::upload_server_certificate_input::Builder::default()
    }
}

/// See [`UploadSigningCertificateInput`](crate::input::UploadSigningCertificateInput)
pub mod upload_signing_certificate_input {
    /// A builder for [`UploadSigningCertificateInput`](crate::input::UploadSigningCertificateInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) user_name: std::option::Option<std::string::String>,
        pub(crate) certificate_body: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the user the signing certificate is for.</p>
        /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
        /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
        pub fn user_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.user_name = Some(inp.into());
            self
        }
        pub fn set_user_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.user_name = inp;
            self
        }
        /// <p>The contents of the signing certificate.</p>
        /// <p>The <a href="http://wikipedia.org/wiki/regex">regex pattern</a>
        /// used to validate this parameter is a string of characters consisting of the following:</p>
        /// <ul>
        /// <li>
        /// <p>Any printable ASCII
        /// character ranging from the space character (<code>\u0020</code>) through the end of the ASCII character range</p>
        /// </li>
        /// <li>
        /// <p>The printable characters in the Basic Latin and  Latin-1 Supplement character set
        /// (through <code>\u00FF</code>)</p>
        /// </li>
        /// <li>
        /// <p>The special characters tab (<code>\u0009</code>), line feed (<code>\u000A</code>), and
        /// carriage return (<code>\u000D</code>)</p>
        /// </li>
        /// </ul>
        pub fn certificate_body(mut self, inp: impl Into<std::string::String>) -> Self {
            self.certificate_body = Some(inp.into());
            self
        }
        pub fn set_certificate_body(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.certificate_body = inp;
            self
        }
        /// Consumes the builder and constructs a [`UploadSigningCertificateInput`](crate::input::UploadSigningCertificateInput)
        pub fn build(
            self,
        ) -> Result<crate::input::UploadSigningCertificateInput, smithy_http::operation::BuildError>
        {
            Ok(crate::input::UploadSigningCertificateInput {
                user_name: self.user_name,
                certificate_body: self.certificate_body,
            })
        }
    }
}
#[doc(hidden)]
pub type UploadSigningCertificateInputOperationOutputAlias =
    crate::operation::UploadSigningCertificate;
#[doc(hidden)]
pub type UploadSigningCertificateInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl UploadSigningCertificateInput {
    /// Consumes the builder and constructs an Operation<[`UploadSigningCertificate`](crate::operation::UploadSigningCertificate)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> Result<
        smithy_http::operation::Operation<
            crate::operation::UploadSigningCertificate,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = crate::operation_ser::serialize_operation_upload_signing_certificate(&self)
                .map_err(|err| {
                    smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::UploadSigningCertificate::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "UploadSigningCertificate",
                "iam",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) {
        write!(output, "/").expect("formatting should succeed")
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri);
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let builder = http::request::Builder::new();
        let builder = builder.header("Content-Type", "application/x-www-form-urlencoded");
        self.update_http_builder(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`UploadSigningCertificateInput`](crate::input::UploadSigningCertificateInput)
    pub fn builder() -> crate::input::upload_signing_certificate_input::Builder {
        crate::input::upload_signing_certificate_input::Builder::default()
    }
}

/// See [`UploadSSHPublicKeyInput`](crate::input::UploadSSHPublicKeyInput)
pub mod upload_ssh_public_key_input {
    /// A builder for [`UploadSSHPublicKeyInput`](crate::input::UploadSSHPublicKeyInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) user_name: std::option::Option<std::string::String>,
        pub(crate) ssh_public_key_body: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the IAM user to associate the SSH public key with.</p>
        /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
        /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
        pub fn user_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.user_name = Some(inp.into());
            self
        }
        pub fn set_user_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.user_name = inp;
            self
        }
        /// <p>The SSH public key. The public key must be encoded in ssh-rsa format or PEM format.
        /// The minimum bit-length of the public key is 2048 bits. For example, you can generate a
        /// 2048-bit key, and the resulting PEM file is 1679 bytes long.</p>
        /// <p>The <a href="http://wikipedia.org/wiki/regex">regex pattern</a>
        /// used to validate this parameter is a string of characters consisting of the following:</p>
        /// <ul>
        /// <li>
        /// <p>Any printable ASCII
        /// character ranging from the space character (<code>\u0020</code>) through the end of the ASCII character range</p>
        /// </li>
        /// <li>
        /// <p>The printable characters in the Basic Latin and  Latin-1 Supplement character set
        /// (through <code>\u00FF</code>)</p>
        /// </li>
        /// <li>
        /// <p>The special characters tab (<code>\u0009</code>), line feed (<code>\u000A</code>), and
        /// carriage return (<code>\u000D</code>)</p>
        /// </li>
        /// </ul>
        pub fn ssh_public_key_body(mut self, inp: impl Into<std::string::String>) -> Self {
            self.ssh_public_key_body = Some(inp.into());
            self
        }
        pub fn set_ssh_public_key_body(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.ssh_public_key_body = inp;
            self
        }
        /// Consumes the builder and constructs a [`UploadSSHPublicKeyInput`](crate::input::UploadSSHPublicKeyInput)
        pub fn build(
            self,
        ) -> Result<crate::input::UploadSSHPublicKeyInput, smithy_http::operation::BuildError>
        {
            Ok(crate::input::UploadSSHPublicKeyInput {
                user_name: self.user_name,
                ssh_public_key_body: self.ssh_public_key_body,
            })
        }
    }
}
#[doc(hidden)]
pub type UploadSSHPublicKeyInputOperationOutputAlias = crate::operation::UploadSSHPublicKey;
#[doc(hidden)]
pub type UploadSSHPublicKeyInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl UploadSSHPublicKeyInput {
    /// Consumes the builder and constructs an Operation<[`UploadSSHPublicKey`](crate::operation::UploadSSHPublicKey)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> Result<
        smithy_http::operation::Operation<
            crate::operation::UploadSSHPublicKey,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = crate::operation_ser::serialize_operation_upload_ssh_public_key(&self)
                .map_err(|err| {
                    smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::UploadSSHPublicKey::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "UploadSSHPublicKey",
                "iam",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) {
        write!(output, "/").expect("formatting should succeed")
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri);
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let builder = http::request::Builder::new();
        let builder = builder.header("Content-Type", "application/x-www-form-urlencoded");
        self.update_http_builder(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`UploadSSHPublicKeyInput`](crate::input::UploadSSHPublicKeyInput)
    pub fn builder() -> crate::input::upload_ssh_public_key_input::Builder {
        crate::input::upload_ssh_public_key_input::Builder::default()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UploadSSHPublicKeyInput {
    /// <p>The name of the IAM user to associate the SSH public key with.</p>
    /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
    /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
    pub user_name: std::option::Option<std::string::String>,
    /// <p>The SSH public key. The public key must be encoded in ssh-rsa format or PEM format.
    /// The minimum bit-length of the public key is 2048 bits. For example, you can generate a
    /// 2048-bit key, and the resulting PEM file is 1679 bytes long.</p>
    /// <p>The <a href="http://wikipedia.org/wiki/regex">regex pattern</a>
    /// used to validate this parameter is a string of characters consisting of the following:</p>
    /// <ul>
    /// <li>
    /// <p>Any printable ASCII
    /// character ranging from the space character (<code>\u0020</code>) through the end of the ASCII character range</p>
    /// </li>
    /// <li>
    /// <p>The printable characters in the Basic Latin and  Latin-1 Supplement character set
    /// (through <code>\u00FF</code>)</p>
    /// </li>
    /// <li>
    /// <p>The special characters tab (<code>\u0009</code>), line feed (<code>\u000A</code>), and
    /// carriage return (<code>\u000D</code>)</p>
    /// </li>
    /// </ul>
    pub ssh_public_key_body: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for UploadSSHPublicKeyInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UploadSSHPublicKeyInput");
        formatter.field("user_name", &self.user_name);
        formatter.field("ssh_public_key_body", &self.ssh_public_key_body);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UploadSigningCertificateInput {
    /// <p>The name of the user the signing certificate is for.</p>
    /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
    /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
    pub user_name: std::option::Option<std::string::String>,
    /// <p>The contents of the signing certificate.</p>
    /// <p>The <a href="http://wikipedia.org/wiki/regex">regex pattern</a>
    /// used to validate this parameter is a string of characters consisting of the following:</p>
    /// <ul>
    /// <li>
    /// <p>Any printable ASCII
    /// character ranging from the space character (<code>\u0020</code>) through the end of the ASCII character range</p>
    /// </li>
    /// <li>
    /// <p>The printable characters in the Basic Latin and  Latin-1 Supplement character set
    /// (through <code>\u00FF</code>)</p>
    /// </li>
    /// <li>
    /// <p>The special characters tab (<code>\u0009</code>), line feed (<code>\u000A</code>), and
    /// carriage return (<code>\u000D</code>)</p>
    /// </li>
    /// </ul>
    pub certificate_body: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for UploadSigningCertificateInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UploadSigningCertificateInput");
        formatter.field("user_name", &self.user_name);
        formatter.field("certificate_body", &self.certificate_body);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UploadServerCertificateInput {
    /// <p>The path for the server certificate. For more information about paths, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html">IAM
    /// identifiers</a> in the <i>IAM User Guide</i>.</p>
    /// <p>This parameter is optional. If it is not included, it defaults to a slash (/).
    /// This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting
    /// of either a forward slash (/) by itself or a string that must begin and end with forward slashes.
    /// In addition, it can contain any ASCII character from the ! (<code>\u0021</code>) through the DEL character (<code>\u007F</code>), including
    /// most punctuation characters, digits, and upper and lowercased letters.</p>
    /// <note>
    /// <p> If you are uploading a server certificate specifically for use with Amazon
    /// CloudFront distributions, you must specify a path using the <code>path</code>
    /// parameter. The path must begin with <code>/cloudfront</code> and must include a
    /// trailing slash (for example, <code>/cloudfront/test/</code>).</p>
    /// </note>
    pub path: std::option::Option<std::string::String>,
    /// <p>The name for the server certificate. Do not include the path in this value. The name
    /// of the certificate cannot contain any spaces.</p>
    /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
    /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
    pub server_certificate_name: std::option::Option<std::string::String>,
    /// <p>The contents of the public key certificate in PEM-encoded format.</p>
    /// <p>The <a href="http://wikipedia.org/wiki/regex">regex pattern</a>
    /// used to validate this parameter is a string of characters consisting of the following:</p>
    /// <ul>
    /// <li>
    /// <p>Any printable ASCII
    /// character ranging from the space character (<code>\u0020</code>) through the end of the ASCII character range</p>
    /// </li>
    /// <li>
    /// <p>The printable characters in the Basic Latin and  Latin-1 Supplement character set
    /// (through <code>\u00FF</code>)</p>
    /// </li>
    /// <li>
    /// <p>The special characters tab (<code>\u0009</code>), line feed (<code>\u000A</code>), and
    /// carriage return (<code>\u000D</code>)</p>
    /// </li>
    /// </ul>
    pub certificate_body: std::option::Option<std::string::String>,
    /// <p>The contents of the private key in PEM-encoded format.</p>
    /// <p>The <a href="http://wikipedia.org/wiki/regex">regex pattern</a>
    /// used to validate this parameter is a string of characters consisting of the following:</p>
    /// <ul>
    /// <li>
    /// <p>Any printable ASCII
    /// character ranging from the space character (<code>\u0020</code>) through the end of the ASCII character range</p>
    /// </li>
    /// <li>
    /// <p>The printable characters in the Basic Latin and  Latin-1 Supplement character set
    /// (through <code>\u00FF</code>)</p>
    /// </li>
    /// <li>
    /// <p>The special characters tab (<code>\u0009</code>), line feed (<code>\u000A</code>), and
    /// carriage return (<code>\u000D</code>)</p>
    /// </li>
    /// </ul>
    pub private_key: std::option::Option<std::string::String>,
    /// <p>The contents of the certificate chain. This is typically a concatenation of the
    /// PEM-encoded public key certificates of the chain.</p>
    /// <p>The <a href="http://wikipedia.org/wiki/regex">regex pattern</a>
    /// used to validate this parameter is a string of characters consisting of the following:</p>
    /// <ul>
    /// <li>
    /// <p>Any printable ASCII
    /// character ranging from the space character (<code>\u0020</code>) through the end of the ASCII character range</p>
    /// </li>
    /// <li>
    /// <p>The printable characters in the Basic Latin and  Latin-1 Supplement character set
    /// (through <code>\u00FF</code>)</p>
    /// </li>
    /// <li>
    /// <p>The special characters tab (<code>\u0009</code>), line feed (<code>\u000A</code>), and
    /// carriage return (<code>\u000D</code>)</p>
    /// </li>
    /// </ul>
    pub certificate_chain: std::option::Option<std::string::String>,
    /// <p>A list of tags that you want to attach to the new IAM server certificate resource.
    /// Each tag consists of a key name and an associated value. For more information about tagging, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_tags.html">Tagging IAM resources</a> in the
    /// <i>IAM User Guide</i>.</p>
    /// <note>
    /// <p>If any one of the tags is invalid or if you exceed the allowed maximum number of tags, then the entire request
    /// fails and the resource is not created.</p>
    /// </note>
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
}
impl std::fmt::Debug for UploadServerCertificateInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UploadServerCertificateInput");
        formatter.field("path", &self.path);
        formatter.field("server_certificate_name", &self.server_certificate_name);
        formatter.field("certificate_body", &self.certificate_body);
        formatter.field("private_key", &"*** Sensitive Data Redacted ***");
        formatter.field("certificate_chain", &self.certificate_chain);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateUserInput {
    /// <p>Name of the user to update. If you're changing the name of the user, this is the
    /// original user name.</p>
    /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
    /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
    pub user_name: std::option::Option<std::string::String>,
    /// <p>New path for the IAM user. Include this parameter only if you're changing the user's
    /// path.</p>
    /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting
    /// of either a forward slash (/) by itself or a string that must begin and end with forward slashes.
    /// In addition, it can contain any ASCII character from the ! (<code>\u0021</code>) through the DEL character (<code>\u007F</code>), including
    /// most punctuation characters, digits, and upper and lowercased letters.</p>
    pub new_path: std::option::Option<std::string::String>,
    /// <p>New name for the user. Include this parameter only if you're changing the user's
    /// name.</p>
    /// <p>IAM user, group, role, and policy names must be unique within the account. Names are
    /// not distinguished by case. For example, you cannot create resources named both
    /// "MyResource" and "myresource".</p>
    pub new_user_name: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for UpdateUserInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateUserInput");
        formatter.field("user_name", &self.user_name);
        formatter.field("new_path", &self.new_path);
        formatter.field("new_user_name", &self.new_user_name);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateSSHPublicKeyInput {
    /// <p>The name of the IAM user associated with the SSH public key.</p>
    /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
    /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
    pub user_name: std::option::Option<std::string::String>,
    /// <p>The unique identifier for the SSH public key.</p>
    /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters that can
    /// consist of any upper or lowercased letter or digit.</p>
    pub ssh_public_key_id: std::option::Option<std::string::String>,
    /// <p>The status to assign to the SSH public key. <code>Active</code> means that the key can
    /// be used for authentication with an AWS CodeCommit repository. <code>Inactive</code> means that
    /// the key cannot be used.</p>
    pub status: std::option::Option<crate::model::StatusType>,
}
impl std::fmt::Debug for UpdateSSHPublicKeyInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateSSHPublicKeyInput");
        formatter.field("user_name", &self.user_name);
        formatter.field("ssh_public_key_id", &self.ssh_public_key_id);
        formatter.field("status", &self.status);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateSigningCertificateInput {
    /// <p>The name of the IAM user the signing certificate belongs to.</p>
    /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
    /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
    pub user_name: std::option::Option<std::string::String>,
    /// <p>The ID of the signing certificate you want to update.</p>
    /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters that can
    /// consist of any upper or lowercased letter or digit.</p>
    pub certificate_id: std::option::Option<std::string::String>,
    /// <p> The status you want to assign to the certificate. <code>Active</code> means that the
    /// certificate can be used for programmatic calls to AWS <code>Inactive</code> means that
    /// the certificate cannot be used.</p>
    pub status: std::option::Option<crate::model::StatusType>,
}
impl std::fmt::Debug for UpdateSigningCertificateInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateSigningCertificateInput");
        formatter.field("user_name", &self.user_name);
        formatter.field("certificate_id", &self.certificate_id);
        formatter.field("status", &self.status);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateServiceSpecificCredentialInput {
    /// <p>The name of the IAM user associated with the service-specific credential. If you do
    /// not specify this value, then the operation assumes the user whose credentials are used
    /// to call the operation.</p>
    /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
    /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
    pub user_name: std::option::Option<std::string::String>,
    /// <p>The unique identifier of the service-specific credential.</p>
    /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters that can
    /// consist of any upper or lowercased letter or digit.</p>
    pub service_specific_credential_id: std::option::Option<std::string::String>,
    /// <p>The status to be assigned to the service-specific credential.</p>
    pub status: std::option::Option<crate::model::StatusType>,
}
impl std::fmt::Debug for UpdateServiceSpecificCredentialInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateServiceSpecificCredentialInput");
        formatter.field("user_name", &self.user_name);
        formatter.field(
            "service_specific_credential_id",
            &self.service_specific_credential_id,
        );
        formatter.field("status", &self.status);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateServerCertificateInput {
    /// <p>The name of the server certificate that you want to update.</p>
    /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
    /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
    pub server_certificate_name: std::option::Option<std::string::String>,
    /// <p>The new path for the server certificate. Include this only if you are updating the
    /// server certificate's path.</p>
    /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting
    /// of either a forward slash (/) by itself or a string that must begin and end with forward slashes.
    /// In addition, it can contain any ASCII character from the ! (<code>\u0021</code>) through the DEL character (<code>\u007F</code>), including
    /// most punctuation characters, digits, and upper and lowercased letters.</p>
    pub new_path: std::option::Option<std::string::String>,
    /// <p>The new name for the server certificate. Include this only if you are updating the
    /// server certificate's name. The name of the certificate cannot contain any spaces.</p>
    /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
    /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
    pub new_server_certificate_name: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for UpdateServerCertificateInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateServerCertificateInput");
        formatter.field("server_certificate_name", &self.server_certificate_name);
        formatter.field("new_path", &self.new_path);
        formatter.field(
            "new_server_certificate_name",
            &self.new_server_certificate_name,
        );
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateSAMLProviderInput {
    /// <p>An XML document generated by an identity provider (IdP) that supports SAML 2.0. The
    /// document includes the issuer's name, expiration information, and keys that can be used
    /// to validate the SAML authentication response (assertions) that are received from the
    /// IdP. You must generate the metadata document using the identity management software that
    /// is used as your organization's IdP.</p>
    pub saml_metadata_document: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the SAML provider to update.</p>
    /// <p>For more information about ARNs, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">Amazon Resource Names (ARNs)</a> in the <i>AWS General Reference</i>.</p>
    pub saml_provider_arn: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for UpdateSAMLProviderInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateSAMLProviderInput");
        formatter.field("saml_metadata_document", &self.saml_metadata_document);
        formatter.field("saml_provider_arn", &self.saml_provider_arn);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateRoleDescriptionInput {
    /// <p>The name of the role that you want to modify.</p>
    pub role_name: std::option::Option<std::string::String>,
    /// <p>The new description that you want to apply to the specified role.</p>
    pub description: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for UpdateRoleDescriptionInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateRoleDescriptionInput");
        formatter.field("role_name", &self.role_name);
        formatter.field("description", &self.description);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateRoleInput {
    /// <p>The name of the role that you want to modify.</p>
    pub role_name: std::option::Option<std::string::String>,
    /// <p>The new description that you want to apply to the specified role.</p>
    pub description: std::option::Option<std::string::String>,
    /// <p>The maximum session duration (in seconds) that you want to set for the specified role.
    /// If you do not specify a value for this setting, the default maximum of one hour is
    /// applied. This setting can have a value from 1 hour to 12 hours.</p>
    /// <p>Anyone who assumes the role from the AWS CLI or API can use the
    /// <code>DurationSeconds</code> API parameter or the <code>duration-seconds</code> CLI
    /// parameter to request a longer session. The <code>MaxSessionDuration</code> setting
    /// determines the maximum duration that can be requested using the
    /// <code>DurationSeconds</code> parameter. If users don't specify a value for the
    /// <code>DurationSeconds</code> parameter, their security credentials are valid for one
    /// hour by default. This applies when you use the <code>AssumeRole*</code> API operations
    /// or the <code>assume-role*</code> CLI operations but does not apply when you use those
    /// operations to create a console URL. For more information, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_use.html">Using IAM
    /// roles</a> in the <i>IAM User Guide</i>.</p>
    pub max_session_duration: std::option::Option<i32>,
}
impl std::fmt::Debug for UpdateRoleInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateRoleInput");
        formatter.field("role_name", &self.role_name);
        formatter.field("description", &self.description);
        formatter.field("max_session_duration", &self.max_session_duration);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateOpenIDConnectProviderThumbprintInput {
    /// <p>The Amazon Resource Name (ARN) of the IAM OIDC provider resource object for which
    /// you want to update the thumbprint. You can get a list of OIDC provider ARNs by using the
    /// <a>ListOpenIDConnectProviders</a> operation.</p>
    /// <p>For more information about ARNs, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">Amazon Resource Names (ARNs)</a> in the <i>AWS General Reference</i>.</p>
    pub open_id_connect_provider_arn: std::option::Option<std::string::String>,
    /// <p>A list of certificate thumbprints that are associated with the specified IAM OpenID
    /// Connect provider. For more information, see <a>CreateOpenIDConnectProvider</a>. </p>
    pub thumbprint_list: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl std::fmt::Debug for UpdateOpenIDConnectProviderThumbprintInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateOpenIDConnectProviderThumbprintInput");
        formatter.field(
            "open_id_connect_provider_arn",
            &self.open_id_connect_provider_arn,
        );
        formatter.field("thumbprint_list", &self.thumbprint_list);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateLoginProfileInput {
    /// <p>The name of the user whose password you want to update.</p>
    /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
    /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
    pub user_name: std::option::Option<std::string::String>,
    /// <p>The new password for the specified IAM user.</p>
    /// <p>The <a href="http://wikipedia.org/wiki/regex">regex pattern</a>
    /// used to validate this parameter is a string of characters consisting of the following:</p>
    /// <ul>
    /// <li>
    /// <p>Any printable ASCII
    /// character ranging from the space character (<code>\u0020</code>) through the end of the ASCII character range</p>
    /// </li>
    /// <li>
    /// <p>The printable characters in the Basic Latin and  Latin-1 Supplement character set
    /// (through <code>\u00FF</code>)</p>
    /// </li>
    /// <li>
    /// <p>The special characters tab (<code>\u0009</code>), line feed (<code>\u000A</code>), and
    /// carriage return (<code>\u000D</code>)</p>
    /// </li>
    /// </ul>
    /// <p>However, the format can be further restricted by the account administrator by setting
    /// a password policy on the AWS account. For more information, see <a>UpdateAccountPasswordPolicy</a>.</p>
    pub password: std::option::Option<std::string::String>,
    /// <p>Allows this new password to be used only once by requiring the specified IAM user to
    /// set a new password on next sign-in.</p>
    pub password_reset_required: std::option::Option<bool>,
}
impl std::fmt::Debug for UpdateLoginProfileInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateLoginProfileInput");
        formatter.field("user_name", &self.user_name);
        formatter.field("password", &"*** Sensitive Data Redacted ***");
        formatter.field("password_reset_required", &self.password_reset_required);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateGroupInput {
    /// <p>Name of the IAM group to update. If you're changing the name of the group, this is
    /// the original name.</p>
    /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
    /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
    pub group_name: std::option::Option<std::string::String>,
    /// <p>New path for the IAM group. Only include this if changing the group's path.</p>
    /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting
    /// of either a forward slash (/) by itself or a string that must begin and end with forward slashes.
    /// In addition, it can contain any ASCII character from the ! (<code>\u0021</code>) through the DEL character (<code>\u007F</code>), including
    /// most punctuation characters, digits, and upper and lowercased letters.</p>
    pub new_path: std::option::Option<std::string::String>,
    /// <p>New name for the IAM group. Only include this if changing the group's name.</p>
    /// <p>IAM user, group, role, and policy names must be unique within the account. Names are
    /// not distinguished by case. For example, you cannot create resources named both
    /// "MyResource" and "myresource".</p>
    pub new_group_name: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for UpdateGroupInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateGroupInput");
        formatter.field("group_name", &self.group_name);
        formatter.field("new_path", &self.new_path);
        formatter.field("new_group_name", &self.new_group_name);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateAssumeRolePolicyInput {
    /// <p>The name of the role to update with the new policy.</p>
    /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
    /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
    pub role_name: std::option::Option<std::string::String>,
    /// <p>The policy that grants an entity permission to assume the role.</p>
    /// <p>You must provide policies in JSON format in IAM. However, for AWS CloudFormation
    /// templates formatted in YAML, you can provide the policy in JSON or YAML format. AWS
    /// CloudFormation always converts a YAML policy to JSON format before submitting it to
    /// IAM.</p>
    /// <p>The <a href="http://wikipedia.org/wiki/regex">regex pattern</a>
    /// used to validate this parameter is a string of characters consisting of the following:</p>
    /// <ul>
    /// <li>
    /// <p>Any printable ASCII
    /// character ranging from the space character (<code>\u0020</code>) through the end of the ASCII character range</p>
    /// </li>
    /// <li>
    /// <p>The printable characters in the Basic Latin and  Latin-1 Supplement character set
    /// (through <code>\u00FF</code>)</p>
    /// </li>
    /// <li>
    /// <p>The special characters tab (<code>\u0009</code>), line feed (<code>\u000A</code>), and
    /// carriage return (<code>\u000D</code>)</p>
    /// </li>
    /// </ul>
    pub policy_document: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for UpdateAssumeRolePolicyInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateAssumeRolePolicyInput");
        formatter.field("role_name", &self.role_name);
        formatter.field("policy_document", &self.policy_document);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateAccountPasswordPolicyInput {
    /// <p>The minimum number of characters allowed in an IAM user password.</p>
    /// <p>If you do not specify a value for this parameter, then the operation uses the default
    /// value of <code>6</code>.</p>
    pub minimum_password_length: std::option::Option<i32>,
    /// <p>Specifies whether IAM user passwords must contain at least one of the following
    /// non-alphanumeric characters:</p>
    /// <p>! @ # $ % ^ & * ( ) _ + - = [ ] { } | '</p>
    /// <p>If you do not specify a value for this parameter, then the operation uses the default
    /// value of <code>false</code>. The result is that passwords do not require at least one
    /// symbol character.</p>
    pub require_symbols: bool,
    /// <p>Specifies whether IAM user passwords must contain at least one numeric character (0
    /// to 9).</p>
    /// <p>If you do not specify a value for this parameter, then the operation uses the default
    /// value of <code>false</code>. The result is that passwords do not require at least one
    /// numeric character.</p>
    pub require_numbers: bool,
    /// <p>Specifies whether IAM user passwords must contain at least one uppercase character
    /// from the ISO basic Latin alphabet (A to Z).</p>
    /// <p>If you do not specify a value for this parameter, then the operation uses the default
    /// value of <code>false</code>. The result is that passwords do not require at least one
    /// uppercase character.</p>
    pub require_uppercase_characters: bool,
    /// <p>Specifies whether IAM user passwords must contain at least one lowercase character
    /// from the ISO basic Latin alphabet (a to z).</p>
    /// <p>If you do not specify a value for this parameter, then the operation uses the default
    /// value of <code>false</code>. The result is that passwords do not require at least one
    /// lowercase character.</p>
    pub require_lowercase_characters: bool,
    /// <p> Allows all IAM users in your account to use the AWS Management Console to change their own
    /// passwords. For more information, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/HowToPwdIAMUser.html">Letting IAM users change their own
    /// passwords</a> in the <i>IAM User Guide</i>.</p>
    /// <p>If you do not specify a value for this parameter, then the operation uses the default
    /// value of <code>false</code>. The result is that IAM users in the account do not
    /// automatically have permissions to change their own password.</p>
    pub allow_users_to_change_password: bool,
    /// <p>The number of days that an IAM user password is valid.</p>
    /// <p>If you do not specify a value for this parameter, then the operation uses the default
    /// value of <code>0</code>. The result is that IAM user passwords never expire.</p>
    pub max_password_age: std::option::Option<i32>,
    /// <p>Specifies the number of previous passwords that IAM users are prevented from
    /// reusing.</p>
    /// <p>If you do not specify a value for this parameter, then the operation uses the default
    /// value of <code>0</code>. The result is that IAM users are not prevented from reusing
    /// previous passwords.</p>
    pub password_reuse_prevention: std::option::Option<i32>,
    /// <p>Prevents IAM users from setting a new password after their password has expired. The
    /// IAM user cannot be accessed until an administrator resets the password.</p>
    /// <p>If you do not specify a value for this parameter, then the operation uses the default
    /// value of <code>false</code>. The result is that IAM users can change their passwords
    /// after they expire and continue to sign in as the user.</p>
    pub hard_expiry: std::option::Option<bool>,
}
impl std::fmt::Debug for UpdateAccountPasswordPolicyInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateAccountPasswordPolicyInput");
        formatter.field("minimum_password_length", &self.minimum_password_length);
        formatter.field("require_symbols", &self.require_symbols);
        formatter.field("require_numbers", &self.require_numbers);
        formatter.field(
            "require_uppercase_characters",
            &self.require_uppercase_characters,
        );
        formatter.field(
            "require_lowercase_characters",
            &self.require_lowercase_characters,
        );
        formatter.field(
            "allow_users_to_change_password",
            &self.allow_users_to_change_password,
        );
        formatter.field("max_password_age", &self.max_password_age);
        formatter.field("password_reuse_prevention", &self.password_reuse_prevention);
        formatter.field("hard_expiry", &self.hard_expiry);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateAccessKeyInput {
    /// <p>The name of the user whose key you want to update.</p>
    /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
    /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
    pub user_name: std::option::Option<std::string::String>,
    /// <p>The access key ID of the secret access key you want to update.</p>
    /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters that can
    /// consist of any upper or lowercased letter or digit.</p>
    pub access_key_id: std::option::Option<std::string::String>,
    /// <p> The status you want to assign to the secret access key. <code>Active</code> means
    /// that the key can be used for programmatic calls to AWS, while <code>Inactive</code>
    /// means that the key cannot be used.</p>
    pub status: std::option::Option<crate::model::StatusType>,
}
impl std::fmt::Debug for UpdateAccessKeyInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateAccessKeyInput");
        formatter.field("user_name", &self.user_name);
        formatter.field("access_key_id", &self.access_key_id);
        formatter.field("status", &self.status);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UntagUserInput {
    /// <p>The name of the IAM user from which you want to remove tags.</p>
    /// <p>This parameter accepts (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters that consist of upper and lowercase alphanumeric
    /// characters with no spaces. You can also include any of the following characters: =,.@-</p>
    pub user_name: std::option::Option<std::string::String>,
    /// <p>A list of key names as a simple array of strings. The tags with matching keys are
    /// removed from the specified user.</p>
    pub tag_keys: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl std::fmt::Debug for UntagUserInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UntagUserInput");
        formatter.field("user_name", &self.user_name);
        formatter.field("tag_keys", &self.tag_keys);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UntagServerCertificateInput {
    /// <p>The name of the IAM server certificate from which you want to remove tags.</p>
    /// <p>This parameter accepts (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters that consist of upper and lowercase alphanumeric
    /// characters with no spaces. You can also include any of the following characters: =,.@-</p>
    pub server_certificate_name: std::option::Option<std::string::String>,
    /// <p>A list of key names as a simple array of strings. The tags with matching keys are
    /// removed from the specified IAM server certificate.</p>
    pub tag_keys: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl std::fmt::Debug for UntagServerCertificateInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UntagServerCertificateInput");
        formatter.field("server_certificate_name", &self.server_certificate_name);
        formatter.field("tag_keys", &self.tag_keys);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UntagSAMLProviderInput {
    /// <p>The ARN of the SAML identity provider in IAM from which you want to remove
    /// tags.</p>
    /// <p>This parameter accepts (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters that consist of upper and lowercase alphanumeric
    /// characters with no spaces. You can also include any of the following characters: =,.@-</p>
    pub saml_provider_arn: std::option::Option<std::string::String>,
    /// <p>A list of key names as a simple array of strings. The tags with matching keys are
    /// removed from the specified SAML identity provider.</p>
    pub tag_keys: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl std::fmt::Debug for UntagSAMLProviderInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UntagSAMLProviderInput");
        formatter.field("saml_provider_arn", &self.saml_provider_arn);
        formatter.field("tag_keys", &self.tag_keys);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UntagRoleInput {
    /// <p>The name of the IAM role from which you want to remove tags.</p>
    /// <p>This parameter accepts (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters that consist of upper and lowercase alphanumeric
    /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
    pub role_name: std::option::Option<std::string::String>,
    /// <p>A list of key names as a simple array of strings. The tags with matching keys are
    /// removed from the specified role.</p>
    pub tag_keys: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl std::fmt::Debug for UntagRoleInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UntagRoleInput");
        formatter.field("role_name", &self.role_name);
        formatter.field("tag_keys", &self.tag_keys);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UntagPolicyInput {
    /// <p>The ARN of the IAM customer managed policy from which you want to remove
    /// tags.</p>
    /// <p>This parameter accepts (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters that consist of upper and lowercase alphanumeric
    /// characters with no spaces. You can also include any of the following characters: =,.@-</p>
    pub policy_arn: std::option::Option<std::string::String>,
    /// <p>A list of key names as a simple array of strings. The tags with matching keys are
    /// removed from the specified policy.</p>
    pub tag_keys: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl std::fmt::Debug for UntagPolicyInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UntagPolicyInput");
        formatter.field("policy_arn", &self.policy_arn);
        formatter.field("tag_keys", &self.tag_keys);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UntagOpenIDConnectProviderInput {
    /// <p>The ARN of the OIDC provider in IAM from which you want to remove tags.</p>
    /// <p>This parameter accepts (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters that consist of upper and lowercase alphanumeric
    /// characters with no spaces. You can also include any of the following characters: =,.@-</p>
    pub open_id_connect_provider_arn: std::option::Option<std::string::String>,
    /// <p>A list of key names as a simple array of strings. The tags with matching keys are
    /// removed from the specified OIDC provider.</p>
    pub tag_keys: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl std::fmt::Debug for UntagOpenIDConnectProviderInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UntagOpenIDConnectProviderInput");
        formatter.field(
            "open_id_connect_provider_arn",
            &self.open_id_connect_provider_arn,
        );
        formatter.field("tag_keys", &self.tag_keys);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UntagMFADeviceInput {
    /// <p>The unique identifier for the IAM virtual MFA device from which you want to remove
    /// tags. For virtual MFA devices, the serial number is the same as the ARN.</p>
    /// <p>This parameter accepts (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters that consist of upper and lowercase alphanumeric
    /// characters with no spaces. You can also include any of the following characters: =,.@-</p>
    pub serial_number: std::option::Option<std::string::String>,
    /// <p>A list of key names as a simple array of strings. The tags with matching keys are
    /// removed from the specified instance profile.</p>
    pub tag_keys: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl std::fmt::Debug for UntagMFADeviceInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UntagMFADeviceInput");
        formatter.field("serial_number", &self.serial_number);
        formatter.field("tag_keys", &self.tag_keys);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UntagInstanceProfileInput {
    /// <p>The name of the IAM instance profile from which you want to remove tags.</p>
    /// <p>This parameter accepts (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters that consist of upper and lowercase alphanumeric
    /// characters with no spaces. You can also include any of the following characters: =,.@-</p>
    pub instance_profile_name: std::option::Option<std::string::String>,
    /// <p>A list of key names as a simple array of strings. The tags with matching keys are
    /// removed from the specified instance profile.</p>
    pub tag_keys: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl std::fmt::Debug for UntagInstanceProfileInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UntagInstanceProfileInput");
        formatter.field("instance_profile_name", &self.instance_profile_name);
        formatter.field("tag_keys", &self.tag_keys);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TagUserInput {
    /// <p>The name of the IAM user to which you want to add tags.</p>
    /// <p>This parameter accepts (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters that consist of upper and lowercase alphanumeric
    /// characters with no spaces. You can also include any of the following characters: =,.@-</p>
    pub user_name: std::option::Option<std::string::String>,
    /// <p>The list of tags that you want to attach to the IAM user. Each tag consists of a key name and an associated value.</p>
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
}
impl std::fmt::Debug for TagUserInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TagUserInput");
        formatter.field("user_name", &self.user_name);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TagServerCertificateInput {
    /// <p>The name of the IAM server certificate to which you want to add tags.</p>
    /// <p>This parameter accepts (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters that consist of upper and lowercase alphanumeric
    /// characters with no spaces. You can also include any of the following characters: =,.@-</p>
    pub server_certificate_name: std::option::Option<std::string::String>,
    /// <p>The list of tags that you want to attach to the IAM server certificate.
    /// Each tag consists of a key name and an associated value.</p>
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
}
impl std::fmt::Debug for TagServerCertificateInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TagServerCertificateInput");
        formatter.field("server_certificate_name", &self.server_certificate_name);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TagSAMLProviderInput {
    /// <p>The ARN of the SAML identity provider in IAM to which you want to add tags.</p>
    /// <p>This parameter accepts (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters that consist of upper and lowercase alphanumeric
    /// characters with no spaces. You can also include any of the following characters: =,.@-</p>
    pub saml_provider_arn: std::option::Option<std::string::String>,
    /// <p>The list of tags that you want to attach to the SAML identity provider in IAM.
    /// Each tag consists of a key name and an associated value.</p>
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
}
impl std::fmt::Debug for TagSAMLProviderInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TagSAMLProviderInput");
        formatter.field("saml_provider_arn", &self.saml_provider_arn);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TagRoleInput {
    /// <p>The name of the IAM role to which you want to add tags.</p>
    /// <p>This parameter accepts (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters that consist of upper and lowercase alphanumeric
    /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
    pub role_name: std::option::Option<std::string::String>,
    /// <p>The list of tags that you want to attach to the IAM role. Each tag consists of a key name and an associated value.</p>
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
}
impl std::fmt::Debug for TagRoleInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TagRoleInput");
        formatter.field("role_name", &self.role_name);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TagPolicyInput {
    /// <p>The ARN of the IAM customer managed policy to which you want to add tags.</p>
    /// <p>This parameter accepts (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters that consist of upper and lowercase alphanumeric
    /// characters with no spaces. You can also include any of the following characters: =,.@-</p>
    pub policy_arn: std::option::Option<std::string::String>,
    /// <p>The list of tags that you want to attach to the IAM customer managed policy.
    /// Each tag consists of a key name and an associated value.</p>
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
}
impl std::fmt::Debug for TagPolicyInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TagPolicyInput");
        formatter.field("policy_arn", &self.policy_arn);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TagOpenIDConnectProviderInput {
    /// <p>The ARN of the OIDC identity provider in IAM to which you want to add tags.</p>
    /// <p>This parameter accepts (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters that consist of upper and lowercase alphanumeric
    /// characters with no spaces. You can also include any of the following characters: =,.@-</p>
    pub open_id_connect_provider_arn: std::option::Option<std::string::String>,
    /// <p>The list of tags that you want to attach to the OIDC identity provider in IAM.
    /// Each tag consists of a key name and an associated value.</p>
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
}
impl std::fmt::Debug for TagOpenIDConnectProviderInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TagOpenIDConnectProviderInput");
        formatter.field(
            "open_id_connect_provider_arn",
            &self.open_id_connect_provider_arn,
        );
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TagMFADeviceInput {
    /// <p>The unique identifier for the IAM virtual MFA device to which you want to add tags.
    /// For virtual MFA devices, the serial number is the same as the ARN.</p>
    /// <p>This parameter accepts (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters that consist of upper and lowercase alphanumeric
    /// characters with no spaces. You can also include any of the following characters: =,.@-</p>
    pub serial_number: std::option::Option<std::string::String>,
    /// <p>The list of tags that you want to attach to the IAM virtual MFA device.
    /// Each tag consists of a key name and an associated value.</p>
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
}
impl std::fmt::Debug for TagMFADeviceInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TagMFADeviceInput");
        formatter.field("serial_number", &self.serial_number);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TagInstanceProfileInput {
    /// <p>The name of the IAM instance profile to which you want to add tags.</p>
    /// <p>This parameter accepts (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters that consist of upper and lowercase alphanumeric
    /// characters with no spaces. You can also include any of the following characters: =,.@-</p>
    pub instance_profile_name: std::option::Option<std::string::String>,
    /// <p>The list of tags that you want to attach to the IAM instance profile.
    /// Each tag consists of a key name and an associated value.</p>
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
}
impl std::fmt::Debug for TagInstanceProfileInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TagInstanceProfileInput");
        formatter.field("instance_profile_name", &self.instance_profile_name);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SimulatePrincipalPolicyInput {
    /// <p>The Amazon Resource Name (ARN) of a user, group, or role whose policies you want to
    /// include in the simulation. If you specify a user, group, or role, the simulation
    /// includes all policies that are associated with that entity. If you specify a user, the
    /// simulation also includes all policies that are attached to any groups the user belongs
    /// to.</p>
    /// <p>For more information about ARNs, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">Amazon Resource Names (ARNs)</a> in the <i>AWS General Reference</i>.</p>
    pub policy_source_arn: std::option::Option<std::string::String>,
    /// <p>An optional list of additional policy documents to include in the simulation. Each
    /// document is specified as a string containing the complete, valid JSON text of an IAM
    /// policy.</p>
    /// <p>The <a href="http://wikipedia.org/wiki/regex">regex pattern</a>
    /// used to validate this parameter is a string of characters consisting of the following:</p>
    /// <ul>
    /// <li>
    /// <p>Any printable ASCII
    /// character ranging from the space character (<code>\u0020</code>) through the end of the ASCII character range</p>
    /// </li>
    /// <li>
    /// <p>The printable characters in the Basic Latin and  Latin-1 Supplement character set
    /// (through <code>\u00FF</code>)</p>
    /// </li>
    /// <li>
    /// <p>The special characters tab (<code>\u0009</code>), line feed (<code>\u000A</code>), and
    /// carriage return (<code>\u000D</code>)</p>
    /// </li>
    /// </ul>
    pub policy_input_list: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The IAM permissions boundary policy to simulate. The permissions boundary sets the
    /// maximum permissions that the entity can have. You can input only one permissions
    /// boundary when you pass a policy to this operation. An IAM entity can only have one
    /// permissions boundary in effect at a time. For example, if a permissions boundary is
    /// attached to an entity and you pass in a different permissions boundary policy using this
    /// parameter, then the new permissions boundary policy is used for the simulation. For more
    /// information about permissions boundaries, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies_boundaries.html">Permissions boundaries for IAM
    /// entities</a> in the <i>IAM User Guide</i>. The policy input is
    /// specified as a string containing the complete, valid JSON text of a permissions boundary
    /// policy.</p>
    /// <p>The <a href="http://wikipedia.org/wiki/regex">regex pattern</a>
    /// used to validate this parameter is a string of characters consisting of the following:</p>
    /// <ul>
    /// <li>
    /// <p>Any printable ASCII
    /// character ranging from the space character (<code>\u0020</code>) through the end of the ASCII character range</p>
    /// </li>
    /// <li>
    /// <p>The printable characters in the Basic Latin and  Latin-1 Supplement character set
    /// (through <code>\u00FF</code>)</p>
    /// </li>
    /// <li>
    /// <p>The special characters tab (<code>\u0009</code>), line feed (<code>\u000A</code>), and
    /// carriage return (<code>\u000D</code>)</p>
    /// </li>
    /// </ul>
    pub permissions_boundary_policy_input_list:
        std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>A list of names of API operations to evaluate in the simulation. Each operation is
    /// evaluated for each resource. Each operation must include the service identifier, such as
    /// <code>iam:CreateUser</code>.</p>
    pub action_names: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>A list of ARNs of AWS resources to include in the simulation. If this parameter is
    /// not provided, then the value defaults to <code>*</code> (all resources). Each API in the
    /// <code>ActionNames</code> parameter is evaluated for each resource in this list. The
    /// simulation determines the access result (allowed or denied) of each combination and
    /// reports it in the response. You can simulate resources that don't exist in your
    /// account.</p>
    /// <p>The simulation does not automatically retrieve policies for the specified resources.
    /// If you want to include a resource policy in the simulation, then you must include the
    /// policy as a string in the <code>ResourcePolicy</code> parameter.</p>
    /// <p>For more information about ARNs, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">Amazon Resource Names (ARNs)</a> in the <i>AWS General Reference</i>.</p>
    pub resource_arns: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>A resource-based policy to include in the simulation provided as a string. Each
    /// resource in the simulation is treated as if it had this policy attached. You can include
    /// only one resource-based policy in a simulation.</p>
    /// <p>The <a href="http://wikipedia.org/wiki/regex">regex pattern</a>
    /// used to validate this parameter is a string of characters consisting of the following:</p>
    /// <ul>
    /// <li>
    /// <p>Any printable ASCII
    /// character ranging from the space character (<code>\u0020</code>) through the end of the ASCII character range</p>
    /// </li>
    /// <li>
    /// <p>The printable characters in the Basic Latin and  Latin-1 Supplement character set
    /// (through <code>\u00FF</code>)</p>
    /// </li>
    /// <li>
    /// <p>The special characters tab (<code>\u0009</code>), line feed (<code>\u000A</code>), and
    /// carriage return (<code>\u000D</code>)</p>
    /// </li>
    /// </ul>
    pub resource_policy: std::option::Option<std::string::String>,
    /// <p>An AWS account ID that specifies the owner of any simulated resource that does not
    /// identify its owner in the resource ARN. Examples of resource ARNs include an S3 bucket
    /// or object. If <code>ResourceOwner</code> is specified, it is also used as the account
    /// owner of any <code>ResourcePolicy</code> included in the simulation. If the
    /// <code>ResourceOwner</code> parameter is not specified, then the owner of the
    /// resources and the resource policy defaults to the account of the identity provided in
    /// <code>CallerArn</code>. This parameter is required only if you specify a
    /// resource-based policy and account that owns the resource is different from the account
    /// that owns the simulated calling user <code>CallerArn</code>.</p>
    pub resource_owner: std::option::Option<std::string::String>,
    /// <p>The ARN of the IAM user that you want to specify as the simulated caller of the API
    /// operations. If you do not specify a <code>CallerArn</code>, it defaults to the ARN of
    /// the user that you specify in <code>PolicySourceArn</code>, if you specified a user. If
    /// you include both a <code>PolicySourceArn</code> (for example,
    /// <code>arn:aws:iam::123456789012:user/David</code>) and a <code>CallerArn</code> (for
    /// example, <code>arn:aws:iam::123456789012:user/Bob</code>), the result is that you
    /// simulate calling the API operations as Bob, as if Bob had David's policies.</p>
    /// <p>You can specify only the ARN of an IAM user. You cannot specify the ARN of an
    /// assumed role, federated user, or a service principal.</p>
    /// <p>
    /// <code>CallerArn</code> is required if you include a <code>ResourcePolicy</code> and
    /// the <code>PolicySourceArn</code> is not the ARN for an IAM user. This is required so
    /// that the resource-based policy's <code>Principal</code> element has a value to use in
    /// evaluating the policy.</p>
    /// <p>For more information about ARNs, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">Amazon Resource Names (ARNs)</a> in the <i>AWS General Reference</i>.</p>
    pub caller_arn: std::option::Option<std::string::String>,
    /// <p>A list of context keys and corresponding values for the simulation to use. Whenever a
    /// context key is evaluated in one of the simulated IAM permissions policies, the
    /// corresponding value is supplied.</p>
    pub context_entries: std::option::Option<std::vec::Vec<crate::model::ContextEntry>>,
    /// <p>Specifies the type of simulation to run. Different API operations that support
    /// resource-based policies require different combinations of resources. By specifying the
    /// type of simulation to run, you enable the policy simulator to enforce the presence of
    /// the required resources to ensure reliable simulation results. If your simulation does
    /// not match one of the following scenarios, then you can omit this parameter. The
    /// following list shows each of the supported scenario values and the resources that you
    /// must define to run the simulation.</p>
    /// <p>Each of the EC2 scenarios requires that you specify instance, image, and security
    /// group resources. If your scenario includes an EBS volume, then you must specify that
    /// volume as a resource. If the EC2 scenario includes VPC, then you must supply the network
    /// interface resource. If it includes an IP subnet, then you must specify the subnet
    /// resource. For more information on the EC2 scenario options, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-supported-platforms.html">Supported platforms</a> in the <i>Amazon EC2 User
    /// Guide</i>.</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <b>EC2-Classic-InstanceStore</b>
    /// </p>
    /// <p>instance, image, security group</p>
    /// </li>
    /// <li>
    /// <p>
    /// <b>EC2-Classic-EBS</b>
    /// </p>
    /// <p>instance, image, security group, volume</p>
    /// </li>
    /// <li>
    /// <p>
    /// <b>EC2-VPC-InstanceStore</b>
    /// </p>
    /// <p>instance, image, security group, network interface</p>
    /// </li>
    /// <li>
    /// <p>
    /// <b>EC2-VPC-InstanceStore-Subnet</b>
    /// </p>
    /// <p>instance, image, security group, network interface, subnet</p>
    /// </li>
    /// <li>
    /// <p>
    /// <b>EC2-VPC-EBS</b>
    /// </p>
    /// <p>instance, image, security group, network interface, volume</p>
    /// </li>
    /// <li>
    /// <p>
    /// <b>EC2-VPC-EBS-Subnet</b>
    /// </p>
    /// <p>instance, image, security group, network interface, subnet, volume</p>
    /// </li>
    /// </ul>
    pub resource_handling_option: std::option::Option<std::string::String>,
    /// <p>Use this only when paginating results to indicate the
    /// maximum number of items you want in the response. If additional items exist beyond the maximum
    /// you specify, the <code>IsTruncated</code> response element is <code>true</code>.</p>
    /// <p>If you do not include this parameter, the number of items defaults to 100. Note that
    /// IAM might return fewer results, even when there are more results available. In that case, the
    /// <code>IsTruncated</code> response element returns <code>true</code>, and <code>Marker</code>
    /// contains a value to include in the subsequent call that tells the service where to continue
    /// from.</p>
    pub max_items: std::option::Option<i32>,
    /// <p>Use this parameter only when paginating results and only after
    /// you receive a response indicating that the results are truncated. Set it to the value of the
    /// <code>Marker</code> element in the response that you received to indicate where the next call
    /// should start.</p>
    pub marker: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for SimulatePrincipalPolicyInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SimulatePrincipalPolicyInput");
        formatter.field("policy_source_arn", &self.policy_source_arn);
        formatter.field("policy_input_list", &self.policy_input_list);
        formatter.field(
            "permissions_boundary_policy_input_list",
            &self.permissions_boundary_policy_input_list,
        );
        formatter.field("action_names", &self.action_names);
        formatter.field("resource_arns", &self.resource_arns);
        formatter.field("resource_policy", &self.resource_policy);
        formatter.field("resource_owner", &self.resource_owner);
        formatter.field("caller_arn", &self.caller_arn);
        formatter.field("context_entries", &self.context_entries);
        formatter.field("resource_handling_option", &self.resource_handling_option);
        formatter.field("max_items", &self.max_items);
        formatter.field("marker", &self.marker);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SimulateCustomPolicyInput {
    /// <p>A list of policy documents to include in the simulation. Each document is specified as
    /// a string containing the complete, valid JSON text of an IAM policy. Do not include any
    /// resource-based policies in this parameter. Any resource-based policy must be submitted
    /// with the <code>ResourcePolicy</code> parameter. The policies cannot be "scope-down"
    /// policies, such as you could include in a call to <a href="https://docs.aws.amazon.com/IAM/latest/APIReference/API_GetFederationToken.html">GetFederationToken</a> or one of
    /// the <a href="https://docs.aws.amazon.com/IAM/latest/APIReference/API_AssumeRole.html">AssumeRole</a> API operations. In other words, do not use policies designed to
    /// restrict what a user can do while using the temporary credentials.</p>
    /// <p>The <a href="http://wikipedia.org/wiki/regex">regex pattern</a>
    /// used to validate this parameter is a string of characters consisting of the following:</p>
    /// <ul>
    /// <li>
    /// <p>Any printable ASCII
    /// character ranging from the space character (<code>\u0020</code>) through the end of the ASCII character range</p>
    /// </li>
    /// <li>
    /// <p>The printable characters in the Basic Latin and  Latin-1 Supplement character set
    /// (through <code>\u00FF</code>)</p>
    /// </li>
    /// <li>
    /// <p>The special characters tab (<code>\u0009</code>), line feed (<code>\u000A</code>), and
    /// carriage return (<code>\u000D</code>)</p>
    /// </li>
    /// </ul>
    pub policy_input_list: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The IAM permissions boundary policy to simulate. The permissions boundary sets the
    /// maximum permissions that an IAM entity can have. You can input only one permissions
    /// boundary when you pass a policy to this operation. For more information about
    /// permissions boundaries, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies_boundaries.html">Permissions boundaries for IAM
    /// entities</a> in the <i>IAM User Guide</i>. The policy input is
    /// specified as a string that contains the complete, valid JSON text of a permissions
    /// boundary policy.</p>
    /// <p>The <a href="http://wikipedia.org/wiki/regex">regex pattern</a>
    /// used to validate this parameter is a string of characters consisting of the following:</p>
    /// <ul>
    /// <li>
    /// <p>Any printable ASCII
    /// character ranging from the space character (<code>\u0020</code>) through the end of the ASCII character range</p>
    /// </li>
    /// <li>
    /// <p>The printable characters in the Basic Latin and  Latin-1 Supplement character set
    /// (through <code>\u00FF</code>)</p>
    /// </li>
    /// <li>
    /// <p>The special characters tab (<code>\u0009</code>), line feed (<code>\u000A</code>), and
    /// carriage return (<code>\u000D</code>)</p>
    /// </li>
    /// </ul>
    pub permissions_boundary_policy_input_list:
        std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>A list of names of API operations to evaluate in the simulation. Each operation is
    /// evaluated against each resource. Each operation must include the service identifier,
    /// such as <code>iam:CreateUser</code>. This operation does not support using wildcards (*)
    /// in an action name.</p>
    pub action_names: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>A list of ARNs of AWS resources to include in the simulation. If this parameter is
    /// not provided, then the value defaults to <code>*</code> (all resources). Each API in the
    /// <code>ActionNames</code> parameter is evaluated for each resource in this list. The
    /// simulation determines the access result (allowed or denied) of each combination and
    /// reports it in the response. You can simulate resources that don't exist in your
    /// account.</p>
    /// <p>The simulation does not automatically retrieve policies for the specified resources.
    /// If you want to include a resource policy in the simulation, then you must include the
    /// policy as a string in the <code>ResourcePolicy</code> parameter.</p>
    /// <p>If you include a <code>ResourcePolicy</code>, then it must be applicable to all of the
    /// resources included in the simulation or you receive an invalid input error.</p>
    /// <p>For more information about ARNs, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">Amazon Resource Names (ARNs)</a> in the <i>AWS General Reference</i>.</p>
    pub resource_arns: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>A resource-based policy to include in the simulation provided as a string. Each
    /// resource in the simulation is treated as if it had this policy attached. You can include
    /// only one resource-based policy in a simulation.</p>
    /// <p>The <a href="http://wikipedia.org/wiki/regex">regex pattern</a>
    /// used to validate this parameter is a string of characters consisting of the following:</p>
    /// <ul>
    /// <li>
    /// <p>Any printable ASCII
    /// character ranging from the space character (<code>\u0020</code>) through the end of the ASCII character range</p>
    /// </li>
    /// <li>
    /// <p>The printable characters in the Basic Latin and  Latin-1 Supplement character set
    /// (through <code>\u00FF</code>)</p>
    /// </li>
    /// <li>
    /// <p>The special characters tab (<code>\u0009</code>), line feed (<code>\u000A</code>), and
    /// carriage return (<code>\u000D</code>)</p>
    /// </li>
    /// </ul>
    pub resource_policy: std::option::Option<std::string::String>,
    /// <p>An ARN representing the AWS account ID that specifies the owner of any simulated
    /// resource that does not identify its owner in the resource ARN. Examples of resource ARNs
    /// include an S3 bucket or object. If <code>ResourceOwner</code> is specified, it is also
    /// used as the account owner of any <code>ResourcePolicy</code> included in the simulation.
    /// If the <code>ResourceOwner</code> parameter is not specified, then the owner of the
    /// resources and the resource policy defaults to the account of the identity provided in
    /// <code>CallerArn</code>. This parameter is required only if you specify a
    /// resource-based policy and account that owns the resource is different from the account
    /// that owns the simulated calling user <code>CallerArn</code>.</p>
    /// <p>The ARN for an account uses the following syntax:
    /// <code>arn:aws:iam::<i>AWS-account-ID</i>:root</code>. For example,
    /// to represent the account with the 112233445566 ID, use the following ARN:
    /// <code>arn:aws:iam::112233445566-ID:root</code>. </p>
    pub resource_owner: std::option::Option<std::string::String>,
    /// <p>The ARN of the IAM user that you want to use as the simulated caller of the API
    /// operations. <code>CallerArn</code> is required if you include a
    /// <code>ResourcePolicy</code> so that the policy's <code>Principal</code> element has
    /// a value to use in evaluating the policy.</p>
    /// <p>You can specify only the ARN of an IAM user. You cannot specify the ARN of an
    /// assumed role, federated user, or a service principal.</p>
    pub caller_arn: std::option::Option<std::string::String>,
    /// <p>A list of context keys and corresponding values for the simulation to use. Whenever a
    /// context key is evaluated in one of the simulated IAM permissions policies, the
    /// corresponding value is supplied.</p>
    pub context_entries: std::option::Option<std::vec::Vec<crate::model::ContextEntry>>,
    /// <p>Specifies the type of simulation to run. Different API operations that support
    /// resource-based policies require different combinations of resources. By specifying the
    /// type of simulation to run, you enable the policy simulator to enforce the presence of
    /// the required resources to ensure reliable simulation results. If your simulation does
    /// not match one of the following scenarios, then you can omit this parameter. The
    /// following list shows each of the supported scenario values and the resources that you
    /// must define to run the simulation.</p>
    /// <p>Each of the EC2 scenarios requires that you specify instance, image, and
    /// security-group resources. If your scenario includes an EBS volume, then you must specify
    /// that volume as a resource. If the EC2 scenario includes VPC, then you must supply the
    /// network-interface resource. If it includes an IP subnet, then you must specify the
    /// subnet resource. For more information on the EC2 scenario options, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-supported-platforms.html">Supported platforms</a> in the <i>Amazon EC2 User
    /// Guide</i>.</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <b>EC2-Classic-InstanceStore</b>
    /// </p>
    /// <p>instance, image, security-group</p>
    /// </li>
    /// <li>
    /// <p>
    /// <b>EC2-Classic-EBS</b>
    /// </p>
    /// <p>instance, image, security-group, volume</p>
    /// </li>
    /// <li>
    /// <p>
    /// <b>EC2-VPC-InstanceStore</b>
    /// </p>
    /// <p>instance, image, security-group, network-interface</p>
    /// </li>
    /// <li>
    /// <p>
    /// <b>EC2-VPC-InstanceStore-Subnet</b>
    /// </p>
    /// <p>instance, image, security-group, network-interface, subnet</p>
    /// </li>
    /// <li>
    /// <p>
    /// <b>EC2-VPC-EBS</b>
    /// </p>
    /// <p>instance, image, security-group, network-interface, volume</p>
    /// </li>
    /// <li>
    /// <p>
    /// <b>EC2-VPC-EBS-Subnet</b>
    /// </p>
    /// <p>instance, image, security-group, network-interface, subnet, volume</p>
    /// </li>
    /// </ul>
    pub resource_handling_option: std::option::Option<std::string::String>,
    /// <p>Use this only when paginating results to indicate the
    /// maximum number of items you want in the response. If additional items exist beyond the maximum
    /// you specify, the <code>IsTruncated</code> response element is <code>true</code>.</p>
    /// <p>If you do not include this parameter, the number of items defaults to 100. Note that
    /// IAM might return fewer results, even when there are more results available. In that case, the
    /// <code>IsTruncated</code> response element returns <code>true</code>, and <code>Marker</code>
    /// contains a value to include in the subsequent call that tells the service where to continue
    /// from.</p>
    pub max_items: std::option::Option<i32>,
    /// <p>Use this parameter only when paginating results and only after
    /// you receive a response indicating that the results are truncated. Set it to the value of the
    /// <code>Marker</code> element in the response that you received to indicate where the next call
    /// should start.</p>
    pub marker: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for SimulateCustomPolicyInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SimulateCustomPolicyInput");
        formatter.field("policy_input_list", &self.policy_input_list);
        formatter.field(
            "permissions_boundary_policy_input_list",
            &self.permissions_boundary_policy_input_list,
        );
        formatter.field("action_names", &self.action_names);
        formatter.field("resource_arns", &self.resource_arns);
        formatter.field("resource_policy", &self.resource_policy);
        formatter.field("resource_owner", &self.resource_owner);
        formatter.field("caller_arn", &self.caller_arn);
        formatter.field("context_entries", &self.context_entries);
        formatter.field("resource_handling_option", &self.resource_handling_option);
        formatter.field("max_items", &self.max_items);
        formatter.field("marker", &self.marker);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SetSecurityTokenServicePreferencesInput {
    /// <p>The version of the global endpoint token. Version 1 tokens are valid only in AWS
    /// Regions that are available by default. These tokens do not work in manually enabled
    /// Regions, such as Asia Pacific (Hong Kong). Version 2 tokens are valid in all Regions.
    /// However, version 2 tokens are longer and might affect systems where you temporarily
    /// store tokens.</p>
    /// <p>For information, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_temp_enable-regions.html">Activating and
    /// deactivating STS in an AWS region</a> in the
    /// <i>IAM User Guide</i>.</p>
    pub global_endpoint_token_version:
        std::option::Option<crate::model::GlobalEndpointTokenVersion>,
}
impl std::fmt::Debug for SetSecurityTokenServicePreferencesInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SetSecurityTokenServicePreferencesInput");
        formatter.field(
            "global_endpoint_token_version",
            &self.global_endpoint_token_version,
        );
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SetDefaultPolicyVersionInput {
    /// <p>The Amazon Resource Name (ARN) of the IAM policy whose default version you want to
    /// set.</p>
    /// <p>For more information about ARNs, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">Amazon Resource Names (ARNs)</a> in the <i>AWS General Reference</i>.</p>
    pub policy_arn: std::option::Option<std::string::String>,
    /// <p>The version of the policy to set as the default (operative) version.</p>
    /// <p>For more information about managed policy versions, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/policies-managed-versions.html">Versioning for managed
    /// policies</a> in the <i>IAM User Guide</i>.</p>
    pub version_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for SetDefaultPolicyVersionInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SetDefaultPolicyVersionInput");
        formatter.field("policy_arn", &self.policy_arn);
        formatter.field("version_id", &self.version_id);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ResyncMFADeviceInput {
    /// <p>The name of the user whose MFA device you want to resynchronize.</p>
    /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
    /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
    pub user_name: std::option::Option<std::string::String>,
    /// <p>Serial number that uniquely identifies the MFA device.</p>
    /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
    /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
    pub serial_number: std::option::Option<std::string::String>,
    /// <p>An authentication code emitted by the device.</p>
    /// <p>The format for this parameter is a sequence of six digits.</p>
    pub authentication_code1: std::option::Option<std::string::String>,
    /// <p>A subsequent authentication code emitted by the device.</p>
    /// <p>The format for this parameter is a sequence of six digits.</p>
    pub authentication_code2: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ResyncMFADeviceInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ResyncMFADeviceInput");
        formatter.field("user_name", &self.user_name);
        formatter.field("serial_number", &self.serial_number);
        formatter.field("authentication_code1", &self.authentication_code1);
        formatter.field("authentication_code2", &self.authentication_code2);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ResetServiceSpecificCredentialInput {
    /// <p>The name of the IAM user associated with the service-specific credential. If this
    /// value is not specified, then the operation assumes the user whose credentials are used
    /// to call the operation.</p>
    /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
    /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
    pub user_name: std::option::Option<std::string::String>,
    /// <p>The unique identifier of the service-specific credential.</p>
    /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters that can
    /// consist of any upper or lowercased letter or digit.</p>
    pub service_specific_credential_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ResetServiceSpecificCredentialInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ResetServiceSpecificCredentialInput");
        formatter.field("user_name", &self.user_name);
        formatter.field(
            "service_specific_credential_id",
            &self.service_specific_credential_id,
        );
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct RemoveUserFromGroupInput {
    /// <p>The name of the group to update.</p>
    /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
    /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
    pub group_name: std::option::Option<std::string::String>,
    /// <p>The name of the user to remove.</p>
    /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
    /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
    pub user_name: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for RemoveUserFromGroupInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("RemoveUserFromGroupInput");
        formatter.field("group_name", &self.group_name);
        formatter.field("user_name", &self.user_name);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct RemoveRoleFromInstanceProfileInput {
    /// <p>The name of the instance profile to update.</p>
    /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
    /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
    pub instance_profile_name: std::option::Option<std::string::String>,
    /// <p>The name of the role to remove.</p>
    /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
    /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
    pub role_name: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for RemoveRoleFromInstanceProfileInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("RemoveRoleFromInstanceProfileInput");
        formatter.field("instance_profile_name", &self.instance_profile_name);
        formatter.field("role_name", &self.role_name);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct RemoveClientIDFromOpenIDConnectProviderInput {
    /// <p>The Amazon Resource Name (ARN) of the IAM OIDC provider resource to remove the
    /// client ID from. You can get a list of OIDC provider ARNs by using the <a>ListOpenIDConnectProviders</a> operation.</p>
    /// <p>For more information about ARNs, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">Amazon Resource Names (ARNs)</a> in the <i>AWS General Reference</i>.</p>
    pub open_id_connect_provider_arn: std::option::Option<std::string::String>,
    /// <p>The client ID (also known as audience) to remove from the IAM OIDC provider
    /// resource. For more information about client IDs, see <a>CreateOpenIDConnectProvider</a>.</p>
    pub client_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for RemoveClientIDFromOpenIDConnectProviderInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("RemoveClientIDFromOpenIDConnectProviderInput");
        formatter.field(
            "open_id_connect_provider_arn",
            &self.open_id_connect_provider_arn,
        );
        formatter.field("client_id", &self.client_id);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PutUserPolicyInput {
    /// <p>The name of the user to associate the policy with.</p>
    /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
    /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
    pub user_name: std::option::Option<std::string::String>,
    /// <p>The name of the policy document.</p>
    /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
    /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
    pub policy_name: std::option::Option<std::string::String>,
    /// <p>The policy document.</p>
    /// <p>You must provide policies in JSON format in IAM. However, for AWS CloudFormation
    /// templates formatted in YAML, you can provide the policy in JSON or YAML format. AWS
    /// CloudFormation always converts a YAML policy to JSON format before submitting it to
    /// IAM.</p>
    /// <p>The <a href="http://wikipedia.org/wiki/regex">regex pattern</a>
    /// used to validate this parameter is a string of characters consisting of the following:</p>
    /// <ul>
    /// <li>
    /// <p>Any printable ASCII
    /// character ranging from the space character (<code>\u0020</code>) through the end of the ASCII character range</p>
    /// </li>
    /// <li>
    /// <p>The printable characters in the Basic Latin and  Latin-1 Supplement character set
    /// (through <code>\u00FF</code>)</p>
    /// </li>
    /// <li>
    /// <p>The special characters tab (<code>\u0009</code>), line feed (<code>\u000A</code>), and
    /// carriage return (<code>\u000D</code>)</p>
    /// </li>
    /// </ul>
    pub policy_document: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for PutUserPolicyInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PutUserPolicyInput");
        formatter.field("user_name", &self.user_name);
        formatter.field("policy_name", &self.policy_name);
        formatter.field("policy_document", &self.policy_document);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PutUserPermissionsBoundaryInput {
    /// <p>The name (friendly name, not ARN) of the IAM user for which you want to set the
    /// permissions boundary.</p>
    pub user_name: std::option::Option<std::string::String>,
    /// <p>The ARN of the policy that is used to set the permissions boundary for the
    /// user.</p>
    pub permissions_boundary: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for PutUserPermissionsBoundaryInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PutUserPermissionsBoundaryInput");
        formatter.field("user_name", &self.user_name);
        formatter.field("permissions_boundary", &self.permissions_boundary);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PutRolePolicyInput {
    /// <p>The name of the role to associate the policy with.</p>
    /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
    /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
    pub role_name: std::option::Option<std::string::String>,
    /// <p>The name of the policy document.</p>
    /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
    /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
    pub policy_name: std::option::Option<std::string::String>,
    /// <p>The policy document.</p>
    /// <p>You must provide policies in JSON format in IAM. However, for AWS CloudFormation
    /// templates formatted in YAML, you can provide the policy in JSON or YAML format. AWS
    /// CloudFormation always converts a YAML policy to JSON format before submitting it to
    /// IAM.</p>
    /// <p>The <a href="http://wikipedia.org/wiki/regex">regex pattern</a>
    /// used to validate this parameter is a string of characters consisting of the following:</p>
    /// <ul>
    /// <li>
    /// <p>Any printable ASCII
    /// character ranging from the space character (<code>\u0020</code>) through the end of the ASCII character range</p>
    /// </li>
    /// <li>
    /// <p>The printable characters in the Basic Latin and  Latin-1 Supplement character set
    /// (through <code>\u00FF</code>)</p>
    /// </li>
    /// <li>
    /// <p>The special characters tab (<code>\u0009</code>), line feed (<code>\u000A</code>), and
    /// carriage return (<code>\u000D</code>)</p>
    /// </li>
    /// </ul>
    pub policy_document: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for PutRolePolicyInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PutRolePolicyInput");
        formatter.field("role_name", &self.role_name);
        formatter.field("policy_name", &self.policy_name);
        formatter.field("policy_document", &self.policy_document);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PutRolePermissionsBoundaryInput {
    /// <p>The name (friendly name, not ARN) of the IAM role for which you want to set the
    /// permissions boundary.</p>
    pub role_name: std::option::Option<std::string::String>,
    /// <p>The ARN of the policy that is used to set the permissions boundary for the
    /// role.</p>
    pub permissions_boundary: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for PutRolePermissionsBoundaryInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PutRolePermissionsBoundaryInput");
        formatter.field("role_name", &self.role_name);
        formatter.field("permissions_boundary", &self.permissions_boundary);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PutGroupPolicyInput {
    /// <p>The name of the group to associate the policy with.</p>
    /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
    /// characters with no spaces. You can also include any of the following characters: _+=,.@-.</p>
    pub group_name: std::option::Option<std::string::String>,
    /// <p>The name of the policy document.</p>
    /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
    /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
    pub policy_name: std::option::Option<std::string::String>,
    /// <p>The policy document.</p>
    /// <p>You must provide policies in JSON format in IAM. However, for AWS CloudFormation
    /// templates formatted in YAML, you can provide the policy in JSON or YAML format. AWS
    /// CloudFormation always converts a YAML policy to JSON format before submitting it to
    /// IAM.</p>
    /// <p>The <a href="http://wikipedia.org/wiki/regex">regex pattern</a>
    /// used to validate this parameter is a string of characters consisting of the following:</p>
    /// <ul>
    /// <li>
    /// <p>Any printable ASCII
    /// character ranging from the space character (<code>\u0020</code>) through the end of the ASCII character range</p>
    /// </li>
    /// <li>
    /// <p>The printable characters in the Basic Latin and  Latin-1 Supplement character set
    /// (through <code>\u00FF</code>)</p>
    /// </li>
    /// <li>
    /// <p>The special characters tab (<code>\u0009</code>), line feed (<code>\u000A</code>), and
    /// carriage return (<code>\u000D</code>)</p>
    /// </li>
    /// </ul>
    pub policy_document: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for PutGroupPolicyInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PutGroupPolicyInput");
        formatter.field("group_name", &self.group_name);
        formatter.field("policy_name", &self.policy_name);
        formatter.field("policy_document", &self.policy_document);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListVirtualMFADevicesInput {
    /// <p> The status (<code>Unassigned</code> or <code>Assigned</code>) of the devices to list.
    /// If you do not specify an <code>AssignmentStatus</code>, the operation defaults to
    /// <code>Any</code>, which lists both assigned and unassigned virtual MFA
    /// devices.,</p>
    pub assignment_status: std::option::Option<crate::model::AssignmentStatusType>,
    /// <p>Use this parameter only when paginating results and only after
    /// you receive a response indicating that the results are truncated. Set it to the value of the
    /// <code>Marker</code> element in the response that you received to indicate where the next call
    /// should start.</p>
    pub marker: std::option::Option<std::string::String>,
    /// <p>Use this only when paginating results to indicate the
    /// maximum number of items you want in the response. If additional items exist beyond the maximum
    /// you specify, the <code>IsTruncated</code> response element is <code>true</code>.</p>
    /// <p>If you do not include this parameter, the number of items defaults to 100. Note that
    /// IAM might return fewer results, even when there are more results available. In that case, the
    /// <code>IsTruncated</code> response element returns <code>true</code>, and <code>Marker</code>
    /// contains a value to include in the subsequent call that tells the service where to continue
    /// from.</p>
    pub max_items: std::option::Option<i32>,
}
impl std::fmt::Debug for ListVirtualMFADevicesInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListVirtualMFADevicesInput");
        formatter.field("assignment_status", &self.assignment_status);
        formatter.field("marker", &self.marker);
        formatter.field("max_items", &self.max_items);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListUserTagsInput {
    /// <p>The name of the IAM user whose tags you want to see.</p>
    /// <p>This parameter accepts (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters that consist of upper and lowercase alphanumeric
    /// characters with no spaces. You can also include any of the following characters: =,.@-</p>
    pub user_name: std::option::Option<std::string::String>,
    /// <p>Use this parameter only when paginating results and only after
    /// you receive a response indicating that the results are truncated. Set it to the value of the
    /// <code>Marker</code> element in the response that you received to indicate where the next call
    /// should start.</p>
    pub marker: std::option::Option<std::string::String>,
    /// <p>(Optional) Use this only when paginating results to indicate the
    /// maximum number of items that you want in the response. If additional items exist beyond the maximum that you specify, the <code>IsTruncated</code> response element is <code>true</code>.</p>
    /// <p>If you do not include this parameter, it defaults to 100. Note that
    /// IAM might return fewer results, even when more results are available. In that case, the
    /// <code>IsTruncated</code> response element returns <code>true</code>, and <code>Marker</code>
    /// contains a value to include in the subsequent call that tells the service where to continue
    /// from.</p>
    pub max_items: std::option::Option<i32>,
}
impl std::fmt::Debug for ListUserTagsInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListUserTagsInput");
        formatter.field("user_name", &self.user_name);
        formatter.field("marker", &self.marker);
        formatter.field("max_items", &self.max_items);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListUsersInput {
    /// <p> The path prefix for filtering the results. For example:
    /// <code>/division_abc/subdivision_xyz/</code>, which would get all user names whose
    /// path starts with <code>/division_abc/subdivision_xyz/</code>.</p>
    /// <p>This parameter is optional. If it is not included, it defaults to a slash (/), listing
    /// all user names. This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting
    /// of either a forward slash (/) by itself or a string that must begin and end with forward slashes.
    /// In addition, it can contain any ASCII character from the ! (<code>\u0021</code>) through the DEL character (<code>\u007F</code>), including
    /// most punctuation characters, digits, and upper and lowercased letters.</p>
    pub path_prefix: std::option::Option<std::string::String>,
    /// <p>Use this parameter only when paginating results and only after
    /// you receive a response indicating that the results are truncated. Set it to the value of the
    /// <code>Marker</code> element in the response that you received to indicate where the next call
    /// should start.</p>
    pub marker: std::option::Option<std::string::String>,
    /// <p>Use this only when paginating results to indicate the
    /// maximum number of items you want in the response. If additional items exist beyond the maximum
    /// you specify, the <code>IsTruncated</code> response element is <code>true</code>.</p>
    /// <p>If you do not include this parameter, the number of items defaults to 100. Note that
    /// IAM might return fewer results, even when there are more results available. In that case, the
    /// <code>IsTruncated</code> response element returns <code>true</code>, and <code>Marker</code>
    /// contains a value to include in the subsequent call that tells the service where to continue
    /// from.</p>
    pub max_items: std::option::Option<i32>,
}
impl std::fmt::Debug for ListUsersInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListUsersInput");
        formatter.field("path_prefix", &self.path_prefix);
        formatter.field("marker", &self.marker);
        formatter.field("max_items", &self.max_items);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListUserPoliciesInput {
    /// <p>The name of the user to list policies for.</p>
    /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
    /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
    pub user_name: std::option::Option<std::string::String>,
    /// <p>Use this parameter only when paginating results and only after
    /// you receive a response indicating that the results are truncated. Set it to the value of the
    /// <code>Marker</code> element in the response that you received to indicate where the next call
    /// should start.</p>
    pub marker: std::option::Option<std::string::String>,
    /// <p>Use this only when paginating results to indicate the
    /// maximum number of items you want in the response. If additional items exist beyond the maximum
    /// you specify, the <code>IsTruncated</code> response element is <code>true</code>.</p>
    /// <p>If you do not include this parameter, the number of items defaults to 100. Note that
    /// IAM might return fewer results, even when there are more results available. In that case, the
    /// <code>IsTruncated</code> response element returns <code>true</code>, and <code>Marker</code>
    /// contains a value to include in the subsequent call that tells the service where to continue
    /// from.</p>
    pub max_items: std::option::Option<i32>,
}
impl std::fmt::Debug for ListUserPoliciesInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListUserPoliciesInput");
        formatter.field("user_name", &self.user_name);
        formatter.field("marker", &self.marker);
        formatter.field("max_items", &self.max_items);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListSSHPublicKeysInput {
    /// <p>The name of the IAM user to list SSH public keys for. If none is specified, the
    /// <code>UserName</code> field is determined implicitly based on the AWS access key
    /// used to sign the request.</p>
    /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
    /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
    pub user_name: std::option::Option<std::string::String>,
    /// <p>Use this parameter only when paginating results and only after
    /// you receive a response indicating that the results are truncated. Set it to the value of the
    /// <code>Marker</code> element in the response that you received to indicate where the next call
    /// should start.</p>
    pub marker: std::option::Option<std::string::String>,
    /// <p>Use this only when paginating results to indicate the
    /// maximum number of items you want in the response. If additional items exist beyond the maximum
    /// you specify, the <code>IsTruncated</code> response element is <code>true</code>.</p>
    /// <p>If you do not include this parameter, the number of items defaults to 100. Note that
    /// IAM might return fewer results, even when there are more results available. In that case, the
    /// <code>IsTruncated</code> response element returns <code>true</code>, and <code>Marker</code>
    /// contains a value to include in the subsequent call that tells the service where to continue
    /// from.</p>
    pub max_items: std::option::Option<i32>,
}
impl std::fmt::Debug for ListSSHPublicKeysInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListSSHPublicKeysInput");
        formatter.field("user_name", &self.user_name);
        formatter.field("marker", &self.marker);
        formatter.field("max_items", &self.max_items);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListSigningCertificatesInput {
    /// <p>The name of the IAM user whose signing certificates you want to examine.</p>
    /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
    /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
    pub user_name: std::option::Option<std::string::String>,
    /// <p>Use this parameter only when paginating results and only after
    /// you receive a response indicating that the results are truncated. Set it to the value of the
    /// <code>Marker</code> element in the response that you received to indicate where the next call
    /// should start.</p>
    pub marker: std::option::Option<std::string::String>,
    /// <p>Use this only when paginating results to indicate the
    /// maximum number of items you want in the response. If additional items exist beyond the maximum
    /// you specify, the <code>IsTruncated</code> response element is <code>true</code>.</p>
    /// <p>If you do not include this parameter, the number of items defaults to 100. Note that
    /// IAM might return fewer results, even when there are more results available. In that case, the
    /// <code>IsTruncated</code> response element returns <code>true</code>, and <code>Marker</code>
    /// contains a value to include in the subsequent call that tells the service where to continue
    /// from.</p>
    pub max_items: std::option::Option<i32>,
}
impl std::fmt::Debug for ListSigningCertificatesInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListSigningCertificatesInput");
        formatter.field("user_name", &self.user_name);
        formatter.field("marker", &self.marker);
        formatter.field("max_items", &self.max_items);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListServiceSpecificCredentialsInput {
    /// <p>The name of the user whose service-specific credentials you want information about. If
    /// this value is not specified, then the operation assumes the user whose credentials are
    /// used to call the operation.</p>
    /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
    /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
    pub user_name: std::option::Option<std::string::String>,
    /// <p>Filters the returned results to only those for the specified AWS service. If not
    /// specified, then AWS returns service-specific credentials for all services.</p>
    pub service_name: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ListServiceSpecificCredentialsInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListServiceSpecificCredentialsInput");
        formatter.field("user_name", &self.user_name);
        formatter.field("service_name", &self.service_name);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListServerCertificateTagsInput {
    /// <p>The name of the IAM server certificate whose tags you want to see.</p>
    /// <p>This parameter accepts (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters that consist of upper and lowercase alphanumeric
    /// characters with no spaces. You can also include any of the following characters: =,.@-</p>
    pub server_certificate_name: std::option::Option<std::string::String>,
    /// <p>Use this parameter only when paginating results and only after
    /// you receive a response indicating that the results are truncated. Set it to the value of the
    /// <code>Marker</code> element in the response that you received to indicate where the next call
    /// should start.</p>
    pub marker: std::option::Option<std::string::String>,
    /// <p>(Optional) Use this only when paginating results to indicate the
    /// maximum number of items that you want in the response. If additional items exist beyond the maximum that you specify, the <code>IsTruncated</code> response element is <code>true</code>.</p>
    /// <p>If you do not include this parameter, it defaults to 100. Note that
    /// IAM might return fewer results, even when more results are available. In that case, the
    /// <code>IsTruncated</code> response element returns <code>true</code>, and <code>Marker</code>
    /// contains a value to include in the subsequent call that tells the service where to continue
    /// from.</p>
    pub max_items: std::option::Option<i32>,
}
impl std::fmt::Debug for ListServerCertificateTagsInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListServerCertificateTagsInput");
        formatter.field("server_certificate_name", &self.server_certificate_name);
        formatter.field("marker", &self.marker);
        formatter.field("max_items", &self.max_items);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListServerCertificatesInput {
    /// <p> The path prefix for filtering the results. For example:
    /// <code>/company/servercerts</code> would get all server certificates for which the
    /// path starts with <code>/company/servercerts</code>.</p>
    /// <p>This parameter is optional. If it is not included, it defaults to a slash (/), listing
    /// all server certificates. This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting
    /// of either a forward slash (/) by itself or a string that must begin and end with forward slashes.
    /// In addition, it can contain any ASCII character from the ! (<code>\u0021</code>) through the DEL character (<code>\u007F</code>), including
    /// most punctuation characters, digits, and upper and lowercased letters.</p>
    pub path_prefix: std::option::Option<std::string::String>,
    /// <p>Use this parameter only when paginating results and only after
    /// you receive a response indicating that the results are truncated. Set it to the value of the
    /// <code>Marker</code> element in the response that you received to indicate where the next call
    /// should start.</p>
    pub marker: std::option::Option<std::string::String>,
    /// <p>Use this only when paginating results to indicate the
    /// maximum number of items you want in the response. If additional items exist beyond the maximum
    /// you specify, the <code>IsTruncated</code> response element is <code>true</code>.</p>
    /// <p>If you do not include this parameter, the number of items defaults to 100. Note that
    /// IAM might return fewer results, even when there are more results available. In that case, the
    /// <code>IsTruncated</code> response element returns <code>true</code>, and <code>Marker</code>
    /// contains a value to include in the subsequent call that tells the service where to continue
    /// from.</p>
    pub max_items: std::option::Option<i32>,
}
impl std::fmt::Debug for ListServerCertificatesInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListServerCertificatesInput");
        formatter.field("path_prefix", &self.path_prefix);
        formatter.field("marker", &self.marker);
        formatter.field("max_items", &self.max_items);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListSAMLProviderTagsInput {
    /// <p>The ARN of the Security Assertion Markup Language (SAML) identity provider whose tags
    /// you want to see.</p>
    /// <p>This parameter accepts (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters that consist of upper and lowercase alphanumeric
    /// characters with no spaces. You can also include any of the following characters: =,.@-</p>
    pub saml_provider_arn: std::option::Option<std::string::String>,
    /// <p>Use this parameter only when paginating results and only after
    /// you receive a response indicating that the results are truncated. Set it to the value of the
    /// <code>Marker</code> element in the response that you received to indicate where the next call
    /// should start.</p>
    pub marker: std::option::Option<std::string::String>,
    /// <p>(Optional) Use this only when paginating results to indicate the
    /// maximum number of items that you want in the response. If additional items exist beyond the maximum that you specify, the <code>IsTruncated</code> response element is <code>true</code>.</p>
    /// <p>If you do not include this parameter, it defaults to 100. Note that
    /// IAM might return fewer results, even when more results are available. In that case, the
    /// <code>IsTruncated</code> response element returns <code>true</code>, and <code>Marker</code>
    /// contains a value to include in the subsequent call that tells the service where to continue
    /// from.</p>
    pub max_items: std::option::Option<i32>,
}
impl std::fmt::Debug for ListSAMLProviderTagsInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListSAMLProviderTagsInput");
        formatter.field("saml_provider_arn", &self.saml_provider_arn);
        formatter.field("marker", &self.marker);
        formatter.field("max_items", &self.max_items);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListSAMLProvidersInput {}
impl std::fmt::Debug for ListSAMLProvidersInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListSAMLProvidersInput");
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListRoleTagsInput {
    /// <p>The name of the IAM role for which you want to see the list of tags.</p>
    /// <p>This parameter accepts (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters that consist of upper and lowercase alphanumeric
    /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
    pub role_name: std::option::Option<std::string::String>,
    /// <p>Use this parameter only when paginating results and only after
    /// you receive a response indicating that the results are truncated. Set it to the value of the
    /// <code>Marker</code> element in the response that you received to indicate where the next call
    /// should start.</p>
    pub marker: std::option::Option<std::string::String>,
    /// <p>(Optional) Use this only when paginating results to indicate the
    /// maximum number of items that you want in the response. If additional items exist beyond the maximum that you specify, the <code>IsTruncated</code> response element is <code>true</code>.</p>
    /// <p>If you do not include this parameter, it defaults to 100. Note that
    /// IAM might return fewer results, even when more results are available. In that case, the
    /// <code>IsTruncated</code> response element returns <code>true</code>, and <code>Marker</code>
    /// contains a value to include in the subsequent call that tells the service where to continue
    /// from.</p>
    pub max_items: std::option::Option<i32>,
}
impl std::fmt::Debug for ListRoleTagsInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListRoleTagsInput");
        formatter.field("role_name", &self.role_name);
        formatter.field("marker", &self.marker);
        formatter.field("max_items", &self.max_items);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListRolesInput {
    /// <p> The path prefix for filtering the results. For example, the prefix
    /// <code>/application_abc/component_xyz/</code> gets all roles whose path starts with
    /// <code>/application_abc/component_xyz/</code>.</p>
    /// <p>This parameter is optional. If it is not included, it defaults to a slash (/), listing
    /// all roles. This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting
    /// of either a forward slash (/) by itself or a string that must begin and end with forward slashes.
    /// In addition, it can contain any ASCII character from the ! (<code>\u0021</code>) through the DEL character (<code>\u007F</code>), including
    /// most punctuation characters, digits, and upper and lowercased letters.</p>
    pub path_prefix: std::option::Option<std::string::String>,
    /// <p>Use this parameter only when paginating results and only after
    /// you receive a response indicating that the results are truncated. Set it to the value of the
    /// <code>Marker</code> element in the response that you received to indicate where the next call
    /// should start.</p>
    pub marker: std::option::Option<std::string::String>,
    /// <p>Use this only when paginating results to indicate the
    /// maximum number of items you want in the response. If additional items exist beyond the maximum
    /// you specify, the <code>IsTruncated</code> response element is <code>true</code>.</p>
    /// <p>If you do not include this parameter, the number of items defaults to 100. Note that
    /// IAM might return fewer results, even when there are more results available. In that case, the
    /// <code>IsTruncated</code> response element returns <code>true</code>, and <code>Marker</code>
    /// contains a value to include in the subsequent call that tells the service where to continue
    /// from.</p>
    pub max_items: std::option::Option<i32>,
}
impl std::fmt::Debug for ListRolesInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListRolesInput");
        formatter.field("path_prefix", &self.path_prefix);
        formatter.field("marker", &self.marker);
        formatter.field("max_items", &self.max_items);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListRolePoliciesInput {
    /// <p>The name of the role to list policies for.</p>
    /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
    /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
    pub role_name: std::option::Option<std::string::String>,
    /// <p>Use this parameter only when paginating results and only after
    /// you receive a response indicating that the results are truncated. Set it to the value of the
    /// <code>Marker</code> element in the response that you received to indicate where the next call
    /// should start.</p>
    pub marker: std::option::Option<std::string::String>,
    /// <p>Use this only when paginating results to indicate the
    /// maximum number of items you want in the response. If additional items exist beyond the maximum
    /// you specify, the <code>IsTruncated</code> response element is <code>true</code>.</p>
    /// <p>If you do not include this parameter, the number of items defaults to 100. Note that
    /// IAM might return fewer results, even when there are more results available. In that case, the
    /// <code>IsTruncated</code> response element returns <code>true</code>, and <code>Marker</code>
    /// contains a value to include in the subsequent call that tells the service where to continue
    /// from.</p>
    pub max_items: std::option::Option<i32>,
}
impl std::fmt::Debug for ListRolePoliciesInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListRolePoliciesInput");
        formatter.field("role_name", &self.role_name);
        formatter.field("marker", &self.marker);
        formatter.field("max_items", &self.max_items);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListPolicyVersionsInput {
    /// <p>The Amazon Resource Name (ARN) of the IAM policy for which you want the
    /// versions.</p>
    /// <p>For more information about ARNs, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">Amazon Resource Names (ARNs)</a> in the <i>AWS General Reference</i>.</p>
    pub policy_arn: std::option::Option<std::string::String>,
    /// <p>Use this parameter only when paginating results and only after
    /// you receive a response indicating that the results are truncated. Set it to the value of the
    /// <code>Marker</code> element in the response that you received to indicate where the next call
    /// should start.</p>
    pub marker: std::option::Option<std::string::String>,
    /// <p>Use this only when paginating results to indicate the
    /// maximum number of items you want in the response. If additional items exist beyond the maximum
    /// you specify, the <code>IsTruncated</code> response element is <code>true</code>.</p>
    /// <p>If you do not include this parameter, the number of items defaults to 100. Note that
    /// IAM might return fewer results, even when there are more results available. In that case, the
    /// <code>IsTruncated</code> response element returns <code>true</code>, and <code>Marker</code>
    /// contains a value to include in the subsequent call that tells the service where to continue
    /// from.</p>
    pub max_items: std::option::Option<i32>,
}
impl std::fmt::Debug for ListPolicyVersionsInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListPolicyVersionsInput");
        formatter.field("policy_arn", &self.policy_arn);
        formatter.field("marker", &self.marker);
        formatter.field("max_items", &self.max_items);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListPolicyTagsInput {
    /// <p>The ARN of the IAM customer managed policy whose tags you want to see.</p>
    /// <p>This parameter accepts (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters that consist of upper and lowercase alphanumeric
    /// characters with no spaces. You can also include any of the following characters: =,.@-</p>
    pub policy_arn: std::option::Option<std::string::String>,
    /// <p>Use this parameter only when paginating results and only after
    /// you receive a response indicating that the results are truncated. Set it to the value of the
    /// <code>Marker</code> element in the response that you received to indicate where the next call
    /// should start.</p>
    pub marker: std::option::Option<std::string::String>,
    /// <p>(Optional) Use this only when paginating results to indicate the
    /// maximum number of items that you want in the response. If additional items exist beyond the maximum that you specify, the <code>IsTruncated</code> response element is <code>true</code>.</p>
    /// <p>If you do not include this parameter, it defaults to 100. Note that
    /// IAM might return fewer results, even when more results are available. In that case, the
    /// <code>IsTruncated</code> response element returns <code>true</code>, and <code>Marker</code>
    /// contains a value to include in the subsequent call that tells the service where to continue
    /// from.</p>
    pub max_items: std::option::Option<i32>,
}
impl std::fmt::Debug for ListPolicyTagsInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListPolicyTagsInput");
        formatter.field("policy_arn", &self.policy_arn);
        formatter.field("marker", &self.marker);
        formatter.field("max_items", &self.max_items);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListPoliciesGrantingServiceAccessInput {
    /// <p>Use this parameter only when paginating results and only after
    /// you receive a response indicating that the results are truncated. Set it to the value of the
    /// <code>Marker</code> element in the response that you received to indicate where the next call
    /// should start.</p>
    pub marker: std::option::Option<std::string::String>,
    /// <p>The ARN of the IAM identity (user, group, or role) whose policies you want to
    /// list.</p>
    pub arn: std::option::Option<std::string::String>,
    /// <p>The service namespace for the AWS services whose policies you want to list.</p>
    /// <p>To learn the service namespace for a service, see <a href="https://docs.aws.amazon.com/service-authorization/latest/reference/reference_policies_actions-resources-contextkeys.html">Actions, resources, and condition keys for AWS services</a> in the
    /// <i>IAM User Guide</i>. Choose the name of the service to view
    /// details for that service. In the first paragraph, find the service prefix. For example,
    /// <code>(service prefix: a4b)</code>. For more information about service namespaces,
    /// see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html#genref-aws-service-namespaces">AWS
    /// service namespaces</a> in the <i>AWS General Reference</i>.</p>
    pub service_namespaces: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl std::fmt::Debug for ListPoliciesGrantingServiceAccessInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListPoliciesGrantingServiceAccessInput");
        formatter.field("marker", &self.marker);
        formatter.field("arn", &self.arn);
        formatter.field("service_namespaces", &self.service_namespaces);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListPoliciesInput {
    /// <p>The scope to use for filtering the results.</p>
    /// <p>To list only AWS managed policies, set <code>Scope</code> to <code>AWS</code>. To
    /// list only the customer managed policies in your AWS account, set <code>Scope</code> to
    /// <code>Local</code>.</p>
    /// <p>This parameter is optional. If it is not included, or if it is set to
    /// <code>All</code>, all policies are returned.</p>
    pub scope: std::option::Option<crate::model::PolicyScopeType>,
    /// <p>A flag to filter the results to only the attached policies.</p>
    /// <p>When <code>OnlyAttached</code> is <code>true</code>, the returned list contains only
    /// the policies that are attached to an IAM user, group, or role. When
    /// <code>OnlyAttached</code> is <code>false</code>, or when the parameter is not
    /// included, all policies are returned.</p>
    pub only_attached: bool,
    /// <p>The path prefix for filtering the results. This parameter is optional. If it is not
    /// included, it defaults to a slash (/), listing all policies. This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting
    /// of either a forward slash (/) by itself or a string that must begin and end with forward slashes.
    /// In addition, it can contain any ASCII character from the ! (<code>\u0021</code>) through the DEL character (<code>\u007F</code>), including
    /// most punctuation characters, digits, and upper and lowercased letters.</p>
    pub path_prefix: std::option::Option<std::string::String>,
    /// <p>The policy usage method to use for filtering the results.</p>
    /// <p>To list only permissions policies,
    /// set <code>PolicyUsageFilter</code> to <code>PermissionsPolicy</code>. To list only
    /// the policies used to set permissions boundaries, set the value
    /// to <code>PermissionsBoundary</code>.</p>
    /// <p>This parameter is optional. If it is not included, all policies are returned. </p>
    pub policy_usage_filter: std::option::Option<crate::model::PolicyUsageType>,
    /// <p>Use this parameter only when paginating results and only after
    /// you receive a response indicating that the results are truncated. Set it to the value of the
    /// <code>Marker</code> element in the response that you received to indicate where the next call
    /// should start.</p>
    pub marker: std::option::Option<std::string::String>,
    /// <p>Use this only when paginating results to indicate the
    /// maximum number of items you want in the response. If additional items exist beyond the maximum
    /// you specify, the <code>IsTruncated</code> response element is <code>true</code>.</p>
    /// <p>If you do not include this parameter, the number of items defaults to 100. Note that
    /// IAM might return fewer results, even when there are more results available. In that case, the
    /// <code>IsTruncated</code> response element returns <code>true</code>, and <code>Marker</code>
    /// contains a value to include in the subsequent call that tells the service where to continue
    /// from.</p>
    pub max_items: std::option::Option<i32>,
}
impl std::fmt::Debug for ListPoliciesInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListPoliciesInput");
        formatter.field("scope", &self.scope);
        formatter.field("only_attached", &self.only_attached);
        formatter.field("path_prefix", &self.path_prefix);
        formatter.field("policy_usage_filter", &self.policy_usage_filter);
        formatter.field("marker", &self.marker);
        formatter.field("max_items", &self.max_items);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListOpenIDConnectProviderTagsInput {
    /// <p>The ARN of the OpenID Connect (OIDC) identity provider whose tags you want to
    /// see.</p>
    /// <p>This parameter accepts (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters that consist of upper and lowercase alphanumeric
    /// characters with no spaces. You can also include any of the following characters: =,.@-</p>
    pub open_id_connect_provider_arn: std::option::Option<std::string::String>,
    /// <p>Use this parameter only when paginating results and only after
    /// you receive a response indicating that the results are truncated. Set it to the value of the
    /// <code>Marker</code> element in the response that you received to indicate where the next call
    /// should start.</p>
    pub marker: std::option::Option<std::string::String>,
    /// <p>(Optional) Use this only when paginating results to indicate the
    /// maximum number of items that you want in the response. If additional items exist beyond the maximum that you specify, the <code>IsTruncated</code> response element is <code>true</code>.</p>
    /// <p>If you do not include this parameter, it defaults to 100. Note that
    /// IAM might return fewer results, even when more results are available. In that case, the
    /// <code>IsTruncated</code> response element returns <code>true</code>, and <code>Marker</code>
    /// contains a value to include in the subsequent call that tells the service where to continue
    /// from.</p>
    pub max_items: std::option::Option<i32>,
}
impl std::fmt::Debug for ListOpenIDConnectProviderTagsInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListOpenIDConnectProviderTagsInput");
        formatter.field(
            "open_id_connect_provider_arn",
            &self.open_id_connect_provider_arn,
        );
        formatter.field("marker", &self.marker);
        formatter.field("max_items", &self.max_items);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListOpenIDConnectProvidersInput {}
impl std::fmt::Debug for ListOpenIDConnectProvidersInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListOpenIDConnectProvidersInput");
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListMFADeviceTagsInput {
    /// <p>The unique identifier for the IAM virtual MFA device whose tags you want to see.
    /// For virtual MFA devices, the serial number is the same as the ARN.</p>
    /// <p>This parameter accepts (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters that consist of upper and lowercase alphanumeric
    /// characters with no spaces. You can also include any of the following characters: =,.@-</p>
    pub serial_number: std::option::Option<std::string::String>,
    /// <p>Use this parameter only when paginating results and only after
    /// you receive a response indicating that the results are truncated. Set it to the value of the
    /// <code>Marker</code> element in the response that you received to indicate where the next call
    /// should start.</p>
    pub marker: std::option::Option<std::string::String>,
    /// <p>(Optional) Use this only when paginating results to indicate the
    /// maximum number of items that you want in the response. If additional items exist beyond the maximum that you specify, the <code>IsTruncated</code> response element is <code>true</code>.</p>
    /// <p>If you do not include this parameter, it defaults to 100. Note that
    /// IAM might return fewer results, even when more results are available. In that case, the
    /// <code>IsTruncated</code> response element returns <code>true</code>, and <code>Marker</code>
    /// contains a value to include in the subsequent call that tells the service where to continue
    /// from.</p>
    pub max_items: std::option::Option<i32>,
}
impl std::fmt::Debug for ListMFADeviceTagsInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListMFADeviceTagsInput");
        formatter.field("serial_number", &self.serial_number);
        formatter.field("marker", &self.marker);
        formatter.field("max_items", &self.max_items);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListMFADevicesInput {
    /// <p>The name of the user whose MFA devices you want to list.</p>
    /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
    /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
    pub user_name: std::option::Option<std::string::String>,
    /// <p>Use this parameter only when paginating results and only after
    /// you receive a response indicating that the results are truncated. Set it to the value of the
    /// <code>Marker</code> element in the response that you received to indicate where the next call
    /// should start.</p>
    pub marker: std::option::Option<std::string::String>,
    /// <p>Use this only when paginating results to indicate the
    /// maximum number of items you want in the response. If additional items exist beyond the maximum
    /// you specify, the <code>IsTruncated</code> response element is <code>true</code>.</p>
    /// <p>If you do not include this parameter, the number of items defaults to 100. Note that
    /// IAM might return fewer results, even when there are more results available. In that case, the
    /// <code>IsTruncated</code> response element returns <code>true</code>, and <code>Marker</code>
    /// contains a value to include in the subsequent call that tells the service where to continue
    /// from.</p>
    pub max_items: std::option::Option<i32>,
}
impl std::fmt::Debug for ListMFADevicesInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListMFADevicesInput");
        formatter.field("user_name", &self.user_name);
        formatter.field("marker", &self.marker);
        formatter.field("max_items", &self.max_items);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListInstanceProfileTagsInput {
    /// <p>The name of the IAM instance profile whose tags you want to see.</p>
    /// <p>This parameter accepts (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters that consist of upper and lowercase alphanumeric
    /// characters with no spaces. You can also include any of the following characters: =,.@-</p>
    pub instance_profile_name: std::option::Option<std::string::String>,
    /// <p>Use this parameter only when paginating results and only after
    /// you receive a response indicating that the results are truncated. Set it to the value of the
    /// <code>Marker</code> element in the response that you received to indicate where the next call
    /// should start.</p>
    pub marker: std::option::Option<std::string::String>,
    /// <p>(Optional) Use this only when paginating results to indicate the
    /// maximum number of items that you want in the response. If additional items exist beyond the maximum that you specify, the <code>IsTruncated</code> response element is <code>true</code>.</p>
    /// <p>If you do not include this parameter, it defaults to 100. Note that
    /// IAM might return fewer results, even when more results are available. In that case, the
    /// <code>IsTruncated</code> response element returns <code>true</code>, and <code>Marker</code>
    /// contains a value to include in the subsequent call that tells the service where to continue
    /// from.</p>
    pub max_items: std::option::Option<i32>,
}
impl std::fmt::Debug for ListInstanceProfileTagsInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListInstanceProfileTagsInput");
        formatter.field("instance_profile_name", &self.instance_profile_name);
        formatter.field("marker", &self.marker);
        formatter.field("max_items", &self.max_items);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListInstanceProfilesForRoleInput {
    /// <p>The name of the role to list instance profiles for.</p>
    /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
    /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
    pub role_name: std::option::Option<std::string::String>,
    /// <p>Use this parameter only when paginating results and only after
    /// you receive a response indicating that the results are truncated. Set it to the value of the
    /// <code>Marker</code> element in the response that you received to indicate where the next call
    /// should start.</p>
    pub marker: std::option::Option<std::string::String>,
    /// <p>Use this only when paginating results to indicate the
    /// maximum number of items you want in the response. If additional items exist beyond the maximum
    /// you specify, the <code>IsTruncated</code> response element is <code>true</code>.</p>
    /// <p>If you do not include this parameter, the number of items defaults to 100. Note that
    /// IAM might return fewer results, even when there are more results available. In that case, the
    /// <code>IsTruncated</code> response element returns <code>true</code>, and <code>Marker</code>
    /// contains a value to include in the subsequent call that tells the service where to continue
    /// from.</p>
    pub max_items: std::option::Option<i32>,
}
impl std::fmt::Debug for ListInstanceProfilesForRoleInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListInstanceProfilesForRoleInput");
        formatter.field("role_name", &self.role_name);
        formatter.field("marker", &self.marker);
        formatter.field("max_items", &self.max_items);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListInstanceProfilesInput {
    /// <p> The path prefix for filtering the results. For example, the prefix
    /// <code>/application_abc/component_xyz/</code> gets all instance profiles whose path
    /// starts with <code>/application_abc/component_xyz/</code>.</p>
    /// <p>This parameter is optional. If it is not included, it defaults to a slash (/), listing
    /// all instance profiles. This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting
    /// of either a forward slash (/) by itself or a string that must begin and end with forward slashes.
    /// In addition, it can contain any ASCII character from the ! (<code>\u0021</code>) through the DEL character (<code>\u007F</code>), including
    /// most punctuation characters, digits, and upper and lowercased letters.</p>
    pub path_prefix: std::option::Option<std::string::String>,
    /// <p>Use this parameter only when paginating results and only after
    /// you receive a response indicating that the results are truncated. Set it to the value of the
    /// <code>Marker</code> element in the response that you received to indicate where the next call
    /// should start.</p>
    pub marker: std::option::Option<std::string::String>,
    /// <p>Use this only when paginating results to indicate the
    /// maximum number of items you want in the response. If additional items exist beyond the maximum
    /// you specify, the <code>IsTruncated</code> response element is <code>true</code>.</p>
    /// <p>If you do not include this parameter, the number of items defaults to 100. Note that
    /// IAM might return fewer results, even when there are more results available. In that case, the
    /// <code>IsTruncated</code> response element returns <code>true</code>, and <code>Marker</code>
    /// contains a value to include in the subsequent call that tells the service where to continue
    /// from.</p>
    pub max_items: std::option::Option<i32>,
}
impl std::fmt::Debug for ListInstanceProfilesInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListInstanceProfilesInput");
        formatter.field("path_prefix", &self.path_prefix);
        formatter.field("marker", &self.marker);
        formatter.field("max_items", &self.max_items);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListGroupsForUserInput {
    /// <p>The name of the user to list groups for.</p>
    /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
    /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
    pub user_name: std::option::Option<std::string::String>,
    /// <p>Use this parameter only when paginating results and only after
    /// you receive a response indicating that the results are truncated. Set it to the value of the
    /// <code>Marker</code> element in the response that you received to indicate where the next call
    /// should start.</p>
    pub marker: std::option::Option<std::string::String>,
    /// <p>Use this only when paginating results to indicate the
    /// maximum number of items you want in the response. If additional items exist beyond the maximum
    /// you specify, the <code>IsTruncated</code> response element is <code>true</code>.</p>
    /// <p>If you do not include this parameter, the number of items defaults to 100. Note that
    /// IAM might return fewer results, even when there are more results available. In that case, the
    /// <code>IsTruncated</code> response element returns <code>true</code>, and <code>Marker</code>
    /// contains a value to include in the subsequent call that tells the service where to continue
    /// from.</p>
    pub max_items: std::option::Option<i32>,
}
impl std::fmt::Debug for ListGroupsForUserInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListGroupsForUserInput");
        formatter.field("user_name", &self.user_name);
        formatter.field("marker", &self.marker);
        formatter.field("max_items", &self.max_items);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListGroupsInput {
    /// <p> The path prefix for filtering the results. For example, the prefix
    /// <code>/division_abc/subdivision_xyz/</code> gets all groups whose path starts with
    /// <code>/division_abc/subdivision_xyz/</code>.</p>
    /// <p>This parameter is optional. If it is not included, it defaults to a slash (/), listing
    /// all groups. This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting
    /// of either a forward slash (/) by itself or a string that must begin and end with forward slashes.
    /// In addition, it can contain any ASCII character from the ! (<code>\u0021</code>) through the DEL character (<code>\u007F</code>), including
    /// most punctuation characters, digits, and upper and lowercased letters.</p>
    pub path_prefix: std::option::Option<std::string::String>,
    /// <p>Use this parameter only when paginating results and only after
    /// you receive a response indicating that the results are truncated. Set it to the value of the
    /// <code>Marker</code> element in the response that you received to indicate where the next call
    /// should start.</p>
    pub marker: std::option::Option<std::string::String>,
    /// <p>Use this only when paginating results to indicate the
    /// maximum number of items you want in the response. If additional items exist beyond the maximum
    /// you specify, the <code>IsTruncated</code> response element is <code>true</code>.</p>
    /// <p>If you do not include this parameter, the number of items defaults to 100. Note that
    /// IAM might return fewer results, even when there are more results available. In that case, the
    /// <code>IsTruncated</code> response element returns <code>true</code>, and <code>Marker</code>
    /// contains a value to include in the subsequent call that tells the service where to continue
    /// from.</p>
    pub max_items: std::option::Option<i32>,
}
impl std::fmt::Debug for ListGroupsInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListGroupsInput");
        formatter.field("path_prefix", &self.path_prefix);
        formatter.field("marker", &self.marker);
        formatter.field("max_items", &self.max_items);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListGroupPoliciesInput {
    /// <p>The name of the group to list policies for.</p>
    /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
    /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
    pub group_name: std::option::Option<std::string::String>,
    /// <p>Use this parameter only when paginating results and only after
    /// you receive a response indicating that the results are truncated. Set it to the value of the
    /// <code>Marker</code> element in the response that you received to indicate where the next call
    /// should start.</p>
    pub marker: std::option::Option<std::string::String>,
    /// <p>Use this only when paginating results to indicate the
    /// maximum number of items you want in the response. If additional items exist beyond the maximum
    /// you specify, the <code>IsTruncated</code> response element is <code>true</code>.</p>
    /// <p>If you do not include this parameter, the number of items defaults to 100. Note that
    /// IAM might return fewer results, even when there are more results available. In that case, the
    /// <code>IsTruncated</code> response element returns <code>true</code>, and <code>Marker</code>
    /// contains a value to include in the subsequent call that tells the service where to continue
    /// from.</p>
    pub max_items: std::option::Option<i32>,
}
impl std::fmt::Debug for ListGroupPoliciesInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListGroupPoliciesInput");
        formatter.field("group_name", &self.group_name);
        formatter.field("marker", &self.marker);
        formatter.field("max_items", &self.max_items);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListEntitiesForPolicyInput {
    /// <p>The Amazon Resource Name (ARN) of the IAM policy for which you want the
    /// versions.</p>
    /// <p>For more information about ARNs, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">Amazon Resource Names (ARNs)</a> in the <i>AWS General Reference</i>.</p>
    pub policy_arn: std::option::Option<std::string::String>,
    /// <p>The entity type to use for filtering the results.</p>
    /// <p>For example, when <code>EntityFilter</code> is <code>Role</code>, only the roles that
    /// are attached to the specified policy are returned. This parameter is optional. If it is
    /// not included, all attached entities (users, groups, and roles) are returned. The
    /// argument for this parameter must be one of the valid values listed below.</p>
    pub entity_filter: std::option::Option<crate::model::EntityType>,
    /// <p>The path prefix for filtering the results. This parameter is optional. If it is not
    /// included, it defaults to a slash (/), listing all entities.</p>
    /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting
    /// of either a forward slash (/) by itself or a string that must begin and end with forward slashes.
    /// In addition, it can contain any ASCII character from the ! (<code>\u0021</code>) through the DEL character (<code>\u007F</code>), including
    /// most punctuation characters, digits, and upper and lowercased letters.</p>
    pub path_prefix: std::option::Option<std::string::String>,
    /// <p>The policy usage method to use for filtering the results.</p>
    /// <p>To list only permissions policies,
    /// set <code>PolicyUsageFilter</code> to <code>PermissionsPolicy</code>. To list only
    /// the policies used to set permissions boundaries, set the value
    /// to <code>PermissionsBoundary</code>.</p>
    /// <p>This parameter is optional. If it is not included, all policies are returned. </p>
    pub policy_usage_filter: std::option::Option<crate::model::PolicyUsageType>,
    /// <p>Use this parameter only when paginating results and only after
    /// you receive a response indicating that the results are truncated. Set it to the value of the
    /// <code>Marker</code> element in the response that you received to indicate where the next call
    /// should start.</p>
    pub marker: std::option::Option<std::string::String>,
    /// <p>Use this only when paginating results to indicate the
    /// maximum number of items you want in the response. If additional items exist beyond the maximum
    /// you specify, the <code>IsTruncated</code> response element is <code>true</code>.</p>
    /// <p>If you do not include this parameter, the number of items defaults to 100. Note that
    /// IAM might return fewer results, even when there are more results available. In that case, the
    /// <code>IsTruncated</code> response element returns <code>true</code>, and <code>Marker</code>
    /// contains a value to include in the subsequent call that tells the service where to continue
    /// from.</p>
    pub max_items: std::option::Option<i32>,
}
impl std::fmt::Debug for ListEntitiesForPolicyInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListEntitiesForPolicyInput");
        formatter.field("policy_arn", &self.policy_arn);
        formatter.field("entity_filter", &self.entity_filter);
        formatter.field("path_prefix", &self.path_prefix);
        formatter.field("policy_usage_filter", &self.policy_usage_filter);
        formatter.field("marker", &self.marker);
        formatter.field("max_items", &self.max_items);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListAttachedUserPoliciesInput {
    /// <p>The name (friendly name, not ARN) of the user to list attached policies for.</p>
    /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
    /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
    pub user_name: std::option::Option<std::string::String>,
    /// <p>The path prefix for filtering the results. This parameter is optional. If it is not
    /// included, it defaults to a slash (/), listing all policies.</p>
    /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting
    /// of either a forward slash (/) by itself or a string that must begin and end with forward slashes.
    /// In addition, it can contain any ASCII character from the ! (<code>\u0021</code>) through the DEL character (<code>\u007F</code>), including
    /// most punctuation characters, digits, and upper and lowercased letters.</p>
    pub path_prefix: std::option::Option<std::string::String>,
    /// <p>Use this parameter only when paginating results and only after
    /// you receive a response indicating that the results are truncated. Set it to the value of the
    /// <code>Marker</code> element in the response that you received to indicate where the next call
    /// should start.</p>
    pub marker: std::option::Option<std::string::String>,
    /// <p>Use this only when paginating results to indicate the
    /// maximum number of items you want in the response. If additional items exist beyond the maximum
    /// you specify, the <code>IsTruncated</code> response element is <code>true</code>.</p>
    /// <p>If you do not include this parameter, the number of items defaults to 100. Note that
    /// IAM might return fewer results, even when there are more results available. In that case, the
    /// <code>IsTruncated</code> response element returns <code>true</code>, and <code>Marker</code>
    /// contains a value to include in the subsequent call that tells the service where to continue
    /// from.</p>
    pub max_items: std::option::Option<i32>,
}
impl std::fmt::Debug for ListAttachedUserPoliciesInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListAttachedUserPoliciesInput");
        formatter.field("user_name", &self.user_name);
        formatter.field("path_prefix", &self.path_prefix);
        formatter.field("marker", &self.marker);
        formatter.field("max_items", &self.max_items);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListAttachedRolePoliciesInput {
    /// <p>The name (friendly name, not ARN) of the role to list attached policies for.</p>
    /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
    /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
    pub role_name: std::option::Option<std::string::String>,
    /// <p>The path prefix for filtering the results. This parameter is optional. If it is not
    /// included, it defaults to a slash (/), listing all policies.</p>
    /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting
    /// of either a forward slash (/) by itself or a string that must begin and end with forward slashes.
    /// In addition, it can contain any ASCII character from the ! (<code>\u0021</code>) through the DEL character (<code>\u007F</code>), including
    /// most punctuation characters, digits, and upper and lowercased letters.</p>
    pub path_prefix: std::option::Option<std::string::String>,
    /// <p>Use this parameter only when paginating results and only after
    /// you receive a response indicating that the results are truncated. Set it to the value of the
    /// <code>Marker</code> element in the response that you received to indicate where the next call
    /// should start.</p>
    pub marker: std::option::Option<std::string::String>,
    /// <p>Use this only when paginating results to indicate the
    /// maximum number of items you want in the response. If additional items exist beyond the maximum
    /// you specify, the <code>IsTruncated</code> response element is <code>true</code>.</p>
    /// <p>If you do not include this parameter, the number of items defaults to 100. Note that
    /// IAM might return fewer results, even when there are more results available. In that case, the
    /// <code>IsTruncated</code> response element returns <code>true</code>, and <code>Marker</code>
    /// contains a value to include in the subsequent call that tells the service where to continue
    /// from.</p>
    pub max_items: std::option::Option<i32>,
}
impl std::fmt::Debug for ListAttachedRolePoliciesInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListAttachedRolePoliciesInput");
        formatter.field("role_name", &self.role_name);
        formatter.field("path_prefix", &self.path_prefix);
        formatter.field("marker", &self.marker);
        formatter.field("max_items", &self.max_items);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListAttachedGroupPoliciesInput {
    /// <p>The name (friendly name, not ARN) of the group to list attached policies for.</p>
    /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
    /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
    pub group_name: std::option::Option<std::string::String>,
    /// <p>The path prefix for filtering the results. This parameter is optional. If it is not
    /// included, it defaults to a slash (/), listing all policies.</p>
    /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting
    /// of either a forward slash (/) by itself or a string that must begin and end with forward slashes.
    /// In addition, it can contain any ASCII character from the ! (<code>\u0021</code>) through the DEL character (<code>\u007F</code>), including
    /// most punctuation characters, digits, and upper and lowercased letters.</p>
    pub path_prefix: std::option::Option<std::string::String>,
    /// <p>Use this parameter only when paginating results and only after
    /// you receive a response indicating that the results are truncated. Set it to the value of the
    /// <code>Marker</code> element in the response that you received to indicate where the next call
    /// should start.</p>
    pub marker: std::option::Option<std::string::String>,
    /// <p>Use this only when paginating results to indicate the
    /// maximum number of items you want in the response. If additional items exist beyond the maximum
    /// you specify, the <code>IsTruncated</code> response element is <code>true</code>.</p>
    /// <p>If you do not include this parameter, the number of items defaults to 100. Note that
    /// IAM might return fewer results, even when there are more results available. In that case, the
    /// <code>IsTruncated</code> response element returns <code>true</code>, and <code>Marker</code>
    /// contains a value to include in the subsequent call that tells the service where to continue
    /// from.</p>
    pub max_items: std::option::Option<i32>,
}
impl std::fmt::Debug for ListAttachedGroupPoliciesInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListAttachedGroupPoliciesInput");
        formatter.field("group_name", &self.group_name);
        formatter.field("path_prefix", &self.path_prefix);
        formatter.field("marker", &self.marker);
        formatter.field("max_items", &self.max_items);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListAccountAliasesInput {
    /// <p>Use this parameter only when paginating results and only after
    /// you receive a response indicating that the results are truncated. Set it to the value of the
    /// <code>Marker</code> element in the response that you received to indicate where the next call
    /// should start.</p>
    pub marker: std::option::Option<std::string::String>,
    /// <p>Use this only when paginating results to indicate the
    /// maximum number of items you want in the response. If additional items exist beyond the maximum
    /// you specify, the <code>IsTruncated</code> response element is <code>true</code>.</p>
    /// <p>If you do not include this parameter, the number of items defaults to 100. Note that
    /// IAM might return fewer results, even when there are more results available. In that case, the
    /// <code>IsTruncated</code> response element returns <code>true</code>, and <code>Marker</code>
    /// contains a value to include in the subsequent call that tells the service where to continue
    /// from.</p>
    pub max_items: std::option::Option<i32>,
}
impl std::fmt::Debug for ListAccountAliasesInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListAccountAliasesInput");
        formatter.field("marker", &self.marker);
        formatter.field("max_items", &self.max_items);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListAccessKeysInput {
    /// <p>The name of the user.</p>
    /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
    /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
    pub user_name: std::option::Option<std::string::String>,
    /// <p>Use this parameter only when paginating results and only after
    /// you receive a response indicating that the results are truncated. Set it to the value of the
    /// <code>Marker</code> element in the response that you received to indicate where the next call
    /// should start.</p>
    pub marker: std::option::Option<std::string::String>,
    /// <p>Use this only when paginating results to indicate the
    /// maximum number of items you want in the response. If additional items exist beyond the maximum
    /// you specify, the <code>IsTruncated</code> response element is <code>true</code>.</p>
    /// <p>If you do not include this parameter, the number of items defaults to 100. Note that
    /// IAM might return fewer results, even when there are more results available. In that case, the
    /// <code>IsTruncated</code> response element returns <code>true</code>, and <code>Marker</code>
    /// contains a value to include in the subsequent call that tells the service where to continue
    /// from.</p>
    pub max_items: std::option::Option<i32>,
}
impl std::fmt::Debug for ListAccessKeysInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListAccessKeysInput");
        formatter.field("user_name", &self.user_name);
        formatter.field("marker", &self.marker);
        formatter.field("max_items", &self.max_items);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetUserPolicyInput {
    /// <p>The name of the user who the policy is associated with.</p>
    /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
    /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
    pub user_name: std::option::Option<std::string::String>,
    /// <p>The name of the policy document to get.</p>
    /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
    /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
    pub policy_name: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for GetUserPolicyInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetUserPolicyInput");
        formatter.field("user_name", &self.user_name);
        formatter.field("policy_name", &self.policy_name);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetUserInput {
    /// <p>The name of the user to get information about.</p>
    /// <p>This parameter is optional. If it is not included, it defaults to the user making the
    /// request. This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
    /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
    pub user_name: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for GetUserInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetUserInput");
        formatter.field("user_name", &self.user_name);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetSSHPublicKeyInput {
    /// <p>The name of the IAM user associated with the SSH public key.</p>
    /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
    /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
    pub user_name: std::option::Option<std::string::String>,
    /// <p>The unique identifier for the SSH public key.</p>
    /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters that can
    /// consist of any upper or lowercased letter or digit.</p>
    pub ssh_public_key_id: std::option::Option<std::string::String>,
    /// <p>Specifies the public key encoding format to use in the response. To retrieve the
    /// public key in ssh-rsa format, use <code>SSH</code>. To retrieve the public key in PEM
    /// format, use <code>PEM</code>.</p>
    pub encoding: std::option::Option<crate::model::EncodingType>,
}
impl std::fmt::Debug for GetSSHPublicKeyInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetSSHPublicKeyInput");
        formatter.field("user_name", &self.user_name);
        formatter.field("ssh_public_key_id", &self.ssh_public_key_id);
        formatter.field("encoding", &self.encoding);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetServiceLinkedRoleDeletionStatusInput {
    /// <p>The deletion task identifier. This identifier is returned by the <a>DeleteServiceLinkedRole</a> operation in the format
    /// <code>task/aws-service-role/<service-principal-name>/<role-name>/<task-uuid></code>.</p>
    pub deletion_task_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for GetServiceLinkedRoleDeletionStatusInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetServiceLinkedRoleDeletionStatusInput");
        formatter.field("deletion_task_id", &self.deletion_task_id);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetServiceLastAccessedDetailsWithEntitiesInput {
    /// <p>The ID of the request generated by the <code>GenerateServiceLastAccessedDetails</code>
    /// operation.</p>
    pub job_id: std::option::Option<std::string::String>,
    /// <p>The service namespace for an AWS service. Provide the service namespace to learn
    /// when the IAM entity last attempted to access the specified service.</p>
    /// <p>To learn the service namespace for a service, see <a href="https://docs.aws.amazon.com/service-authorization/latest/reference/reference_policies_actions-resources-contextkeys.html">Actions, resources, and condition keys for AWS services</a> in the
    /// <i>IAM User Guide</i>. Choose the name of the service to view
    /// details for that service. In the first paragraph, find the service prefix. For example,
    /// <code>(service prefix: a4b)</code>. For more information about service namespaces,
    /// see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html#genref-aws-service-namespaces">AWS
    /// service namespaces</a> in the <i>AWS General Reference</i>.</p>
    pub service_namespace: std::option::Option<std::string::String>,
    /// <p>Use this only when paginating results to indicate the
    /// maximum number of items you want in the response. If additional items exist beyond the maximum
    /// you specify, the <code>IsTruncated</code> response element is <code>true</code>.</p>
    /// <p>If you do not include this parameter, the number of items defaults to 100. Note that
    /// IAM might return fewer results, even when there are more results available. In that case, the
    /// <code>IsTruncated</code> response element returns <code>true</code>, and <code>Marker</code>
    /// contains a value to include in the subsequent call that tells the service where to continue
    /// from.</p>
    pub max_items: std::option::Option<i32>,
    /// <p>Use this parameter only when paginating results and only after
    /// you receive a response indicating that the results are truncated. Set it to the value of the
    /// <code>Marker</code> element in the response that you received to indicate where the next call
    /// should start.</p>
    pub marker: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for GetServiceLastAccessedDetailsWithEntitiesInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetServiceLastAccessedDetailsWithEntitiesInput");
        formatter.field("job_id", &self.job_id);
        formatter.field("service_namespace", &self.service_namespace);
        formatter.field("max_items", &self.max_items);
        formatter.field("marker", &self.marker);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetServiceLastAccessedDetailsInput {
    /// <p>The ID of the request generated by the <a>GenerateServiceLastAccessedDetails</a> operation. The <code>JobId</code>
    /// returned by <code>GenerateServiceLastAccessedDetail</code> must be used by the same role
    /// within a session, or by the same user when used to call
    /// <code>GetServiceLastAccessedDetail</code>.</p>
    pub job_id: std::option::Option<std::string::String>,
    /// <p>Use this only when paginating results to indicate the
    /// maximum number of items you want in the response. If additional items exist beyond the maximum
    /// you specify, the <code>IsTruncated</code> response element is <code>true</code>.</p>
    /// <p>If you do not include this parameter, the number of items defaults to 100. Note that
    /// IAM might return fewer results, even when there are more results available. In that case, the
    /// <code>IsTruncated</code> response element returns <code>true</code>, and <code>Marker</code>
    /// contains a value to include in the subsequent call that tells the service where to continue
    /// from.</p>
    pub max_items: std::option::Option<i32>,
    /// <p>Use this parameter only when paginating results and only after
    /// you receive a response indicating that the results are truncated. Set it to the value of the
    /// <code>Marker</code> element in the response that you received to indicate where the next call
    /// should start.</p>
    pub marker: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for GetServiceLastAccessedDetailsInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetServiceLastAccessedDetailsInput");
        formatter.field("job_id", &self.job_id);
        formatter.field("max_items", &self.max_items);
        formatter.field("marker", &self.marker);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetServerCertificateInput {
    /// <p>The name of the server certificate you want to retrieve information about.</p>
    /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
    /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
    pub server_certificate_name: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for GetServerCertificateInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetServerCertificateInput");
        formatter.field("server_certificate_name", &self.server_certificate_name);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetSAMLProviderInput {
    /// <p>The Amazon Resource Name (ARN) of the SAML provider resource object in IAM to get
    /// information about.</p>
    /// <p>For more information about ARNs, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">Amazon Resource Names (ARNs)</a> in the <i>AWS General Reference</i>.</p>
    pub saml_provider_arn: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for GetSAMLProviderInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetSAMLProviderInput");
        formatter.field("saml_provider_arn", &self.saml_provider_arn);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetRolePolicyInput {
    /// <p>The name of the role associated with the policy.</p>
    /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
    /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
    pub role_name: std::option::Option<std::string::String>,
    /// <p>The name of the policy document to get.</p>
    /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
    /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
    pub policy_name: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for GetRolePolicyInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetRolePolicyInput");
        formatter.field("role_name", &self.role_name);
        formatter.field("policy_name", &self.policy_name);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetRoleInput {
    /// <p>The name of the IAM role to get information about.</p>
    /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
    /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
    pub role_name: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for GetRoleInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetRoleInput");
        formatter.field("role_name", &self.role_name);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetPolicyVersionInput {
    /// <p>The Amazon Resource Name (ARN) of the managed policy that you want information
    /// about.</p>
    /// <p>For more information about ARNs, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">Amazon Resource Names (ARNs)</a> in the <i>AWS General Reference</i>.</p>
    pub policy_arn: std::option::Option<std::string::String>,
    /// <p>Identifies the policy version to retrieve.</p>
    /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters that
    /// consists of the lowercase letter 'v' followed by one or two digits, and optionally
    /// followed by a period '.' and a string of letters and digits.</p>
    pub version_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for GetPolicyVersionInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetPolicyVersionInput");
        formatter.field("policy_arn", &self.policy_arn);
        formatter.field("version_id", &self.version_id);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetPolicyInput {
    /// <p>The Amazon Resource Name (ARN) of the managed policy that you want information
    /// about.</p>
    /// <p>For more information about ARNs, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">Amazon Resource Names (ARNs)</a> in the <i>AWS General Reference</i>.</p>
    pub policy_arn: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for GetPolicyInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetPolicyInput");
        formatter.field("policy_arn", &self.policy_arn);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetOrganizationsAccessReportInput {
    /// <p>The identifier of the request generated by the <a>GenerateOrganizationsAccessReport</a> operation.</p>
    pub job_id: std::option::Option<std::string::String>,
    /// <p>Use this only when paginating results to indicate the
    /// maximum number of items you want in the response. If additional items exist beyond the maximum
    /// you specify, the <code>IsTruncated</code> response element is <code>true</code>.</p>
    /// <p>If you do not include this parameter, the number of items defaults to 100. Note that
    /// IAM might return fewer results, even when there are more results available. In that case, the
    /// <code>IsTruncated</code> response element returns <code>true</code>, and <code>Marker</code>
    /// contains a value to include in the subsequent call that tells the service where to continue
    /// from.</p>
    pub max_items: std::option::Option<i32>,
    /// <p>Use this parameter only when paginating results and only after
    /// you receive a response indicating that the results are truncated. Set it to the value of the
    /// <code>Marker</code> element in the response that you received to indicate where the next call
    /// should start.</p>
    pub marker: std::option::Option<std::string::String>,
    /// <p>The key that is used to sort the results. If you choose the namespace key, the results
    /// are returned in alphabetical order. If you choose the time key, the results are sorted
    /// numerically by the date and time.</p>
    pub sort_key: std::option::Option<crate::model::SortKeyType>,
}
impl std::fmt::Debug for GetOrganizationsAccessReportInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetOrganizationsAccessReportInput");
        formatter.field("job_id", &self.job_id);
        formatter.field("max_items", &self.max_items);
        formatter.field("marker", &self.marker);
        formatter.field("sort_key", &self.sort_key);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetOpenIDConnectProviderInput {
    /// <p>The Amazon Resource Name (ARN) of the OIDC provider resource object in IAM to get
    /// information for. You can get a list of OIDC provider resource ARNs by using the <a>ListOpenIDConnectProviders</a> operation.</p>
    /// <p>For more information about ARNs, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">Amazon Resource Names (ARNs)</a> in the <i>AWS General Reference</i>.</p>
    pub open_id_connect_provider_arn: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for GetOpenIDConnectProviderInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetOpenIDConnectProviderInput");
        formatter.field(
            "open_id_connect_provider_arn",
            &self.open_id_connect_provider_arn,
        );
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetLoginProfileInput {
    /// <p>The name of the user whose login profile you want to retrieve.</p>
    /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
    /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
    pub user_name: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for GetLoginProfileInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetLoginProfileInput");
        formatter.field("user_name", &self.user_name);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetInstanceProfileInput {
    /// <p>The name of the instance profile to get information about.</p>
    /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
    /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
    pub instance_profile_name: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for GetInstanceProfileInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetInstanceProfileInput");
        formatter.field("instance_profile_name", &self.instance_profile_name);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetGroupPolicyInput {
    /// <p>The name of the group the policy is associated with.</p>
    /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
    /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
    pub group_name: std::option::Option<std::string::String>,
    /// <p>The name of the policy document to get.</p>
    /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
    /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
    pub policy_name: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for GetGroupPolicyInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetGroupPolicyInput");
        formatter.field("group_name", &self.group_name);
        formatter.field("policy_name", &self.policy_name);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetGroupInput {
    /// <p>The name of the group.</p>
    /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
    /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
    pub group_name: std::option::Option<std::string::String>,
    /// <p>Use this parameter only when paginating results and only after
    /// you receive a response indicating that the results are truncated. Set it to the value of the
    /// <code>Marker</code> element in the response that you received to indicate where the next call
    /// should start.</p>
    pub marker: std::option::Option<std::string::String>,
    /// <p>Use this only when paginating results to indicate the
    /// maximum number of items you want in the response. If additional items exist beyond the maximum
    /// you specify, the <code>IsTruncated</code> response element is <code>true</code>.</p>
    /// <p>If you do not include this parameter, the number of items defaults to 100. Note that
    /// IAM might return fewer results, even when there are more results available. In that case, the
    /// <code>IsTruncated</code> response element returns <code>true</code>, and <code>Marker</code>
    /// contains a value to include in the subsequent call that tells the service where to continue
    /// from.</p>
    pub max_items: std::option::Option<i32>,
}
impl std::fmt::Debug for GetGroupInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetGroupInput");
        formatter.field("group_name", &self.group_name);
        formatter.field("marker", &self.marker);
        formatter.field("max_items", &self.max_items);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetCredentialReportInput {}
impl std::fmt::Debug for GetCredentialReportInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetCredentialReportInput");
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetContextKeysForPrincipalPolicyInput {
    /// <p>The ARN of a user, group, or role whose policies contain the context keys that you
    /// want listed. If you specify a user, the list includes context keys that are found in all
    /// policies that are attached to the user. The list also includes all groups that the user
    /// is a member of. If you pick a group or a role, then it includes only those context keys
    /// that are found in policies attached to that entity. Note that all parameters are shown
    /// in unencoded form here for clarity, but must be URL encoded to be included as a part of
    /// a real HTML request.</p>
    /// <p>For more information about ARNs, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">Amazon Resource Names (ARNs)</a> in the <i>AWS General Reference</i>.</p>
    pub policy_source_arn: std::option::Option<std::string::String>,
    /// <p>An optional list of additional policies for which you want the list of context keys
    /// that are referenced.</p>
    /// <p>The <a href="http://wikipedia.org/wiki/regex">regex pattern</a>
    /// used to validate this parameter is a string of characters consisting of the following:</p>
    /// <ul>
    /// <li>
    /// <p>Any printable ASCII
    /// character ranging from the space character (<code>\u0020</code>) through the end of the ASCII character range</p>
    /// </li>
    /// <li>
    /// <p>The printable characters in the Basic Latin and  Latin-1 Supplement character set
    /// (through <code>\u00FF</code>)</p>
    /// </li>
    /// <li>
    /// <p>The special characters tab (<code>\u0009</code>), line feed (<code>\u000A</code>), and
    /// carriage return (<code>\u000D</code>)</p>
    /// </li>
    /// </ul>
    pub policy_input_list: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl std::fmt::Debug for GetContextKeysForPrincipalPolicyInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetContextKeysForPrincipalPolicyInput");
        formatter.field("policy_source_arn", &self.policy_source_arn);
        formatter.field("policy_input_list", &self.policy_input_list);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetContextKeysForCustomPolicyInput {
    /// <p>A list of policies for which you want the list of context keys referenced in those
    /// policies. Each document is specified as a string containing the complete, valid JSON
    /// text of an IAM policy.</p>
    /// <p>The <a href="http://wikipedia.org/wiki/regex">regex pattern</a>
    /// used to validate this parameter is a string of characters consisting of the following:</p>
    /// <ul>
    /// <li>
    /// <p>Any printable ASCII
    /// character ranging from the space character (<code>\u0020</code>) through the end of the ASCII character range</p>
    /// </li>
    /// <li>
    /// <p>The printable characters in the Basic Latin and  Latin-1 Supplement character set
    /// (through <code>\u00FF</code>)</p>
    /// </li>
    /// <li>
    /// <p>The special characters tab (<code>\u0009</code>), line feed (<code>\u000A</code>), and
    /// carriage return (<code>\u000D</code>)</p>
    /// </li>
    /// </ul>
    pub policy_input_list: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl std::fmt::Debug for GetContextKeysForCustomPolicyInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetContextKeysForCustomPolicyInput");
        formatter.field("policy_input_list", &self.policy_input_list);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetAccountSummaryInput {}
impl std::fmt::Debug for GetAccountSummaryInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetAccountSummaryInput");
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetAccountPasswordPolicyInput {}
impl std::fmt::Debug for GetAccountPasswordPolicyInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetAccountPasswordPolicyInput");
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetAccountAuthorizationDetailsInput {
    /// <p>A list of entity types used to filter the results. Only the entities that match the
    /// types you specify are included in the output. Use the value
    /// <code>LocalManagedPolicy</code> to include customer managed policies.</p>
    /// <p>The format for this parameter is a comma-separated (if more than one) list of strings.
    /// Each string value in the list must be one of the valid values listed below.</p>
    pub filter: std::option::Option<std::vec::Vec<crate::model::EntityType>>,
    /// <p>Use this only when paginating results to indicate the
    /// maximum number of items you want in the response. If additional items exist beyond the maximum
    /// you specify, the <code>IsTruncated</code> response element is <code>true</code>.</p>
    /// <p>If you do not include this parameter, the number of items defaults to 100. Note that
    /// IAM might return fewer results, even when there are more results available. In that case, the
    /// <code>IsTruncated</code> response element returns <code>true</code>, and <code>Marker</code>
    /// contains a value to include in the subsequent call that tells the service where to continue
    /// from.</p>
    pub max_items: std::option::Option<i32>,
    /// <p>Use this parameter only when paginating results and only after
    /// you receive a response indicating that the results are truncated. Set it to the value of the
    /// <code>Marker</code> element in the response that you received to indicate where the next call
    /// should start.</p>
    pub marker: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for GetAccountAuthorizationDetailsInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetAccountAuthorizationDetailsInput");
        formatter.field("filter", &self.filter);
        formatter.field("max_items", &self.max_items);
        formatter.field("marker", &self.marker);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetAccessKeyLastUsedInput {
    /// <p>The identifier of an access key.</p>
    /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters that can
    /// consist of any upper or lowercased letter or digit.</p>
    pub access_key_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for GetAccessKeyLastUsedInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetAccessKeyLastUsedInput");
        formatter.field("access_key_id", &self.access_key_id);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GenerateServiceLastAccessedDetailsInput {
    /// <p>The ARN of the IAM resource (user, group, role, or managed policy) used to generate
    /// information about when the resource was last used in an attempt to access an AWS
    /// service.</p>
    pub arn: std::option::Option<std::string::String>,
    /// <p>The level of detail that you want to generate. You can specify whether you want to
    /// generate information about the last attempt to access services or actions. If you
    /// specify service-level granularity, this operation generates only service data. If you
    /// specify action-level granularity, it generates service and action data. If you don't
    /// include this optional parameter, the operation generates service data.</p>
    pub granularity: std::option::Option<crate::model::AccessAdvisorUsageGranularityType>,
}
impl std::fmt::Debug for GenerateServiceLastAccessedDetailsInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GenerateServiceLastAccessedDetailsInput");
        formatter.field("arn", &self.arn);
        formatter.field("granularity", &self.granularity);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GenerateOrganizationsAccessReportInput {
    /// <p>The path of the AWS Organizations entity (root, OU, or account). You can build an entity path using
    /// the known structure of your organization. For example, assume that your account ID is
    /// <code>123456789012</code> and its parent OU ID is <code>ou-rge0-awsabcde</code>. The
    /// organization root ID is <code>r-f6g7h8i9j0example</code> and your organization ID is
    /// <code>o-a1b2c3d4e5</code>. Your entity path is
    /// <code>o-a1b2c3d4e5/r-f6g7h8i9j0example/ou-rge0-awsabcde/123456789012</code>.</p>
    pub entity_path: std::option::Option<std::string::String>,
    /// <p>The identifier of the AWS Organizations service control policy (SCP). This parameter is
    /// optional.</p>
    /// <p>This ID is used to generate information about when an account principal that is
    /// limited by the SCP attempted to access an AWS service.</p>
    pub organizations_policy_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for GenerateOrganizationsAccessReportInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GenerateOrganizationsAccessReportInput");
        formatter.field("entity_path", &self.entity_path);
        formatter.field("organizations_policy_id", &self.organizations_policy_id);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GenerateCredentialReportInput {}
impl std::fmt::Debug for GenerateCredentialReportInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GenerateCredentialReportInput");
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct EnableMFADeviceInput {
    /// <p>The name of the IAM user for whom you want to enable the MFA device.</p>
    /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
    /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
    pub user_name: std::option::Option<std::string::String>,
    /// <p>The serial number that uniquely identifies the MFA device. For virtual MFA devices,
    /// the serial number is the device ARN.</p>
    /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting
    /// of upper and lowercase alphanumeric characters with no spaces. You can also include any of the
    /// following characters: =,.@:/-</p>
    pub serial_number: std::option::Option<std::string::String>,
    /// <p>An authentication code emitted by the device. </p>
    /// <p>The format for this parameter is a string of six digits.</p>
    /// <important>
    /// <p>Submit your request immediately after generating the authentication codes. If you
    /// generate the codes and then wait too long to submit the request, the MFA device
    /// successfully associates with the user but the MFA device becomes out of sync. This
    /// happens because time-based one-time passwords (TOTP) expire after a short period of
    /// time. If this happens, you can <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_mfa_sync.html">resync the
    /// device</a>.</p>
    /// </important>
    pub authentication_code1: std::option::Option<std::string::String>,
    /// <p>A subsequent authentication code emitted by the device.</p>
    /// <p>The format for this parameter is a string of six digits.</p>
    /// <important>
    /// <p>Submit your request immediately after generating the authentication codes. If you
    /// generate the codes and then wait too long to submit the request, the MFA device
    /// successfully associates with the user but the MFA device becomes out of sync. This
    /// happens because time-based one-time passwords (TOTP) expire after a short period of
    /// time. If this happens, you can <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_mfa_sync.html">resync the
    /// device</a>.</p>
    /// </important>
    pub authentication_code2: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for EnableMFADeviceInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("EnableMFADeviceInput");
        formatter.field("user_name", &self.user_name);
        formatter.field("serial_number", &self.serial_number);
        formatter.field("authentication_code1", &self.authentication_code1);
        formatter.field("authentication_code2", &self.authentication_code2);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DetachUserPolicyInput {
    /// <p>The name (friendly name, not ARN) of the IAM user to detach the policy from.</p>
    /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
    /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
    pub user_name: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the IAM policy you want to detach.</p>
    /// <p>For more information about ARNs, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">Amazon Resource Names (ARNs)</a> in the <i>AWS General Reference</i>.</p>
    pub policy_arn: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DetachUserPolicyInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DetachUserPolicyInput");
        formatter.field("user_name", &self.user_name);
        formatter.field("policy_arn", &self.policy_arn);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DetachRolePolicyInput {
    /// <p>The name (friendly name, not ARN) of the IAM role to detach the policy from.</p>
    /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
    /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
    pub role_name: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the IAM policy you want to detach.</p>
    /// <p>For more information about ARNs, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">Amazon Resource Names (ARNs)</a> in the <i>AWS General Reference</i>.</p>
    pub policy_arn: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DetachRolePolicyInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DetachRolePolicyInput");
        formatter.field("role_name", &self.role_name);
        formatter.field("policy_arn", &self.policy_arn);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DetachGroupPolicyInput {
    /// <p>The name (friendly name, not ARN) of the IAM group to detach the policy from.</p>
    /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
    /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
    pub group_name: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the IAM policy you want to detach.</p>
    /// <p>For more information about ARNs, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">Amazon Resource Names (ARNs)</a> in the <i>AWS General Reference</i>.</p>
    pub policy_arn: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DetachGroupPolicyInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DetachGroupPolicyInput");
        formatter.field("group_name", &self.group_name);
        formatter.field("policy_arn", &self.policy_arn);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteVirtualMFADeviceInput {
    /// <p>The serial number that uniquely identifies the MFA device. For virtual MFA devices,
    /// the serial number is the same as the ARN.</p>
    /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting
    /// of upper and lowercase alphanumeric characters with no spaces. You can also include any of the
    /// following characters: =,.@:/-</p>
    pub serial_number: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DeleteVirtualMFADeviceInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteVirtualMFADeviceInput");
        formatter.field("serial_number", &self.serial_number);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteUserPolicyInput {
    /// <p>The name (friendly name, not ARN) identifying the user that the policy is embedded
    /// in.</p>
    /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
    /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
    pub user_name: std::option::Option<std::string::String>,
    /// <p>The name identifying the policy document to delete.</p>
    /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
    /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
    pub policy_name: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DeleteUserPolicyInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteUserPolicyInput");
        formatter.field("user_name", &self.user_name);
        formatter.field("policy_name", &self.policy_name);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteUserPermissionsBoundaryInput {
    /// <p>The name (friendly name, not ARN) of the IAM user from which you want to remove the
    /// permissions boundary.</p>
    pub user_name: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DeleteUserPermissionsBoundaryInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteUserPermissionsBoundaryInput");
        formatter.field("user_name", &self.user_name);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteUserInput {
    /// <p>The name of the user to delete.</p>
    /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
    /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
    pub user_name: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DeleteUserInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteUserInput");
        formatter.field("user_name", &self.user_name);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteSSHPublicKeyInput {
    /// <p>The name of the IAM user associated with the SSH public key.</p>
    /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
    /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
    pub user_name: std::option::Option<std::string::String>,
    /// <p>The unique identifier for the SSH public key.</p>
    /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters that can
    /// consist of any upper or lowercased letter or digit.</p>
    pub ssh_public_key_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DeleteSSHPublicKeyInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteSSHPublicKeyInput");
        formatter.field("user_name", &self.user_name);
        formatter.field("ssh_public_key_id", &self.ssh_public_key_id);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteSigningCertificateInput {
    /// <p>The name of the user the signing certificate belongs to.</p>
    /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
    /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
    pub user_name: std::option::Option<std::string::String>,
    /// <p>The ID of the signing certificate to delete.</p>
    /// <p>The format of this parameter, as described by its <a href="http://wikipedia.org/wiki/regex">regex</a> pattern, is a string of
    /// characters that can be upper- or lower-cased letters or digits.</p>
    pub certificate_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DeleteSigningCertificateInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteSigningCertificateInput");
        formatter.field("user_name", &self.user_name);
        formatter.field("certificate_id", &self.certificate_id);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteServiceSpecificCredentialInput {
    /// <p>The name of the IAM user associated with the service-specific credential. If this
    /// value is not specified, then the operation assumes the user whose credentials are used
    /// to call the operation.</p>
    /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
    /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
    pub user_name: std::option::Option<std::string::String>,
    /// <p>The unique identifier of the service-specific credential. You can get this value by
    /// calling <a>ListServiceSpecificCredentials</a>.</p>
    /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters that can
    /// consist of any upper or lowercased letter or digit.</p>
    pub service_specific_credential_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DeleteServiceSpecificCredentialInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteServiceSpecificCredentialInput");
        formatter.field("user_name", &self.user_name);
        formatter.field(
            "service_specific_credential_id",
            &self.service_specific_credential_id,
        );
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteServiceLinkedRoleInput {
    /// <p>The name of the service-linked role to be deleted.</p>
    pub role_name: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DeleteServiceLinkedRoleInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteServiceLinkedRoleInput");
        formatter.field("role_name", &self.role_name);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteServerCertificateInput {
    /// <p>The name of the server certificate you want to delete.</p>
    /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
    /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
    pub server_certificate_name: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DeleteServerCertificateInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteServerCertificateInput");
        formatter.field("server_certificate_name", &self.server_certificate_name);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteSAMLProviderInput {
    /// <p>The Amazon Resource Name (ARN) of the SAML provider to delete.</p>
    pub saml_provider_arn: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DeleteSAMLProviderInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteSAMLProviderInput");
        formatter.field("saml_provider_arn", &self.saml_provider_arn);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteRolePolicyInput {
    /// <p>The name (friendly name, not ARN) identifying the role that the policy is embedded
    /// in.</p>
    /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
    /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
    pub role_name: std::option::Option<std::string::String>,
    /// <p>The name of the inline policy to delete from the specified IAM role.</p>
    /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
    /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
    pub policy_name: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DeleteRolePolicyInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteRolePolicyInput");
        formatter.field("role_name", &self.role_name);
        formatter.field("policy_name", &self.policy_name);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteRolePermissionsBoundaryInput {
    /// <p>The name (friendly name, not ARN) of the IAM role from which you want to remove the
    /// permissions boundary.</p>
    pub role_name: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DeleteRolePermissionsBoundaryInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteRolePermissionsBoundaryInput");
        formatter.field("role_name", &self.role_name);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteRoleInput {
    /// <p>The name of the role to delete.</p>
    /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
    /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
    pub role_name: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DeleteRoleInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteRoleInput");
        formatter.field("role_name", &self.role_name);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeletePolicyVersionInput {
    /// <p>The Amazon Resource Name (ARN) of the IAM policy from which you want to delete a
    /// version.</p>
    /// <p>For more information about ARNs, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">Amazon Resource Names (ARNs)</a> in the <i>AWS General Reference</i>.</p>
    pub policy_arn: std::option::Option<std::string::String>,
    /// <p>The policy version to delete.</p>
    /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters that
    /// consists of the lowercase letter 'v' followed by one or two digits, and optionally
    /// followed by a period '.' and a string of letters and digits.</p>
    /// <p>For more information about managed policy versions, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/policies-managed-versions.html">Versioning for managed
    /// policies</a> in the <i>IAM User Guide</i>.</p>
    pub version_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DeletePolicyVersionInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeletePolicyVersionInput");
        formatter.field("policy_arn", &self.policy_arn);
        formatter.field("version_id", &self.version_id);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeletePolicyInput {
    /// <p>The Amazon Resource Name (ARN) of the IAM policy you want to delete.</p>
    /// <p>For more information about ARNs, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">Amazon Resource Names (ARNs)</a> in the <i>AWS General Reference</i>.</p>
    pub policy_arn: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DeletePolicyInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeletePolicyInput");
        formatter.field("policy_arn", &self.policy_arn);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteOpenIDConnectProviderInput {
    /// <p>The Amazon Resource Name (ARN) of the IAM OpenID Connect provider resource object to
    /// delete. You can get a list of OpenID Connect provider resource ARNs by using the <a>ListOpenIDConnectProviders</a> operation.</p>
    pub open_id_connect_provider_arn: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DeleteOpenIDConnectProviderInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteOpenIDConnectProviderInput");
        formatter.field(
            "open_id_connect_provider_arn",
            &self.open_id_connect_provider_arn,
        );
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteLoginProfileInput {
    /// <p>The name of the user whose password you want to delete.</p>
    /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
    /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
    pub user_name: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DeleteLoginProfileInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteLoginProfileInput");
        formatter.field("user_name", &self.user_name);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteInstanceProfileInput {
    /// <p>The name of the instance profile to delete.</p>
    /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
    /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
    pub instance_profile_name: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DeleteInstanceProfileInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteInstanceProfileInput");
        formatter.field("instance_profile_name", &self.instance_profile_name);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteGroupPolicyInput {
    /// <p>The name (friendly name, not ARN) identifying the group that the policy is embedded
    /// in.</p>
    /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
    /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
    pub group_name: std::option::Option<std::string::String>,
    /// <p>The name identifying the policy document to delete.</p>
    /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
    /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
    pub policy_name: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DeleteGroupPolicyInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteGroupPolicyInput");
        formatter.field("group_name", &self.group_name);
        formatter.field("policy_name", &self.policy_name);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteGroupInput {
    /// <p>The name of the IAM group to delete.</p>
    /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
    /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
    pub group_name: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DeleteGroupInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteGroupInput");
        formatter.field("group_name", &self.group_name);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteAccountPasswordPolicyInput {}
impl std::fmt::Debug for DeleteAccountPasswordPolicyInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteAccountPasswordPolicyInput");
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteAccountAliasInput {
    /// <p>The name of the account alias to delete.</p>
    /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of
    /// lowercase letters, digits, and dashes. You cannot start or finish with a dash, nor can you have
    /// two dashes in a row.</p>
    pub account_alias: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DeleteAccountAliasInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteAccountAliasInput");
        formatter.field("account_alias", &self.account_alias);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteAccessKeyInput {
    /// <p>The name of the user whose access key pair you want to delete.</p>
    /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
    /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
    pub user_name: std::option::Option<std::string::String>,
    /// <p>The access key ID for the access key ID and secret access key you want to
    /// delete.</p>
    /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters that can
    /// consist of any upper or lowercased letter or digit.</p>
    pub access_key_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DeleteAccessKeyInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteAccessKeyInput");
        formatter.field("user_name", &self.user_name);
        formatter.field("access_key_id", &self.access_key_id);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeactivateMFADeviceInput {
    /// <p>The name of the user whose MFA device you want to deactivate.</p>
    /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
    /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
    pub user_name: std::option::Option<std::string::String>,
    /// <p>The serial number that uniquely identifies the MFA device. For virtual MFA devices,
    /// the serial number is the device ARN.</p>
    /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting
    /// of upper and lowercase alphanumeric characters with no spaces. You can also include any of the
    /// following characters: =,.@:/-</p>
    pub serial_number: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DeactivateMFADeviceInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeactivateMFADeviceInput");
        formatter.field("user_name", &self.user_name);
        formatter.field("serial_number", &self.serial_number);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateVirtualMFADeviceInput {
    /// <p> The path for the virtual MFA device. For more information about paths, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html">IAM
    /// identifiers</a> in the <i>IAM User Guide</i>.</p>
    /// <p>This parameter is optional. If it is not included, it defaults to a slash (/).</p>
    /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting
    /// of either a forward slash (/) by itself or a string that must begin and end with forward slashes.
    /// In addition, it can contain any ASCII character from the ! (<code>\u0021</code>) through the DEL character (<code>\u007F</code>), including
    /// most punctuation characters, digits, and upper and lowercased letters.</p>
    pub path: std::option::Option<std::string::String>,
    /// <p>The name of the virtual MFA device. Use with path to uniquely identify a virtual MFA
    /// device.</p>
    /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
    /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
    pub virtual_mfa_device_name: std::option::Option<std::string::String>,
    /// <p>A list of tags that you want to attach to the new IAM virtual MFA device.
    /// Each tag consists of a key name and an associated value. For more information about tagging, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_tags.html">Tagging IAM resources</a> in the
    /// <i>IAM User Guide</i>.</p>
    /// <note>
    /// <p>If any one of the tags is invalid or if you exceed the allowed maximum number of tags, then the entire request
    /// fails and the resource is not created.</p>
    /// </note>
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
}
impl std::fmt::Debug for CreateVirtualMFADeviceInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateVirtualMFADeviceInput");
        formatter.field("path", &self.path);
        formatter.field("virtual_mfa_device_name", &self.virtual_mfa_device_name);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateUserInput {
    /// <p> The path for the user name. For more information about paths, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html">IAM
    /// identifiers</a> in the <i>IAM User Guide</i>.</p>
    /// <p>This parameter is optional. If it is not included, it defaults to a slash (/).</p>
    /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting
    /// of either a forward slash (/) by itself or a string that must begin and end with forward slashes.
    /// In addition, it can contain any ASCII character from the ! (<code>\u0021</code>) through the DEL character (<code>\u007F</code>), including
    /// most punctuation characters, digits, and upper and lowercased letters.</p>
    pub path: std::option::Option<std::string::String>,
    /// <p>The name of the user to create.</p>
    /// <p>IAM user, group, role, and policy names must be unique within the account. Names are
    /// not distinguished by case. For example, you cannot create resources named both
    /// "MyResource" and "myresource".</p>
    pub user_name: std::option::Option<std::string::String>,
    /// <p>The ARN of the policy that is used to set the permissions boundary for the
    /// user.</p>
    pub permissions_boundary: std::option::Option<std::string::String>,
    /// <p>A list of tags that you want to attach to the new user. Each tag consists of a key name and an associated value.
    /// For more information about tagging, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_tags.html">Tagging IAM resources</a> in the
    /// <i>IAM User Guide</i>.</p>
    /// <note>
    /// <p>If any one of the tags is invalid or if you exceed the allowed maximum number of tags, then the entire request
    /// fails and the resource is not created.</p>
    /// </note>
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
}
impl std::fmt::Debug for CreateUserInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateUserInput");
        formatter.field("path", &self.path);
        formatter.field("user_name", &self.user_name);
        formatter.field("permissions_boundary", &self.permissions_boundary);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateServiceSpecificCredentialInput {
    /// <p>The name of the IAM user that is to be associated with the credentials. The new
    /// service-specific credentials have the same permissions as the associated user except
    /// that they can be used only to access the specified service.</p>
    /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
    /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
    pub user_name: std::option::Option<std::string::String>,
    /// <p>The name of the AWS service that is to be associated with the credentials. The
    /// service you specify here is the only service that can be accessed using these
    /// credentials.</p>
    pub service_name: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for CreateServiceSpecificCredentialInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateServiceSpecificCredentialInput");
        formatter.field("user_name", &self.user_name);
        formatter.field("service_name", &self.service_name);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateServiceLinkedRoleInput {
    /// <p>The service principal for the AWS service to which this role is attached. You use a
    /// string similar to a URL but without the http:// in front. For example:
    /// <code>elasticbeanstalk.amazonaws.com</code>. </p>
    /// <p>Service principals are unique and case-sensitive. To find the exact service principal
    /// for your service-linked role, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_aws-services-that-work-with-iam.html">AWS services
    /// that work with IAM</a> in the <i>IAM User Guide</i>. Look for
    /// the services that have <b>Yes </b>in the <b>Service-Linked Role</b> column. Choose the <b>Yes</b> link to view the service-linked role documentation for that
    /// service.</p>
    pub aws_service_name: std::option::Option<std::string::String>,
    /// <p>The description of the role.</p>
    pub description: std::option::Option<std::string::String>,
    /// <p></p>
    /// <p>A string that you provide, which is combined with the service-provided prefix to form
    /// the complete role name. If you make multiple requests for the same service, then you
    /// must supply a different <code>CustomSuffix</code> for each request. Otherwise the
    /// request fails with a duplicate role name error. For example, you could add
    /// <code>-1</code> or <code>-debug</code> to the suffix.</p>
    /// <p>Some services do not support the <code>CustomSuffix</code> parameter. If you provide
    /// an optional suffix and the operation fails, try the operation again without the
    /// suffix.</p>
    pub custom_suffix: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for CreateServiceLinkedRoleInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateServiceLinkedRoleInput");
        formatter.field("aws_service_name", &self.aws_service_name);
        formatter.field("description", &self.description);
        formatter.field("custom_suffix", &self.custom_suffix);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateSAMLProviderInput {
    /// <p>An XML document generated by an identity provider (IdP) that supports SAML 2.0. The
    /// document includes the issuer's name, expiration information, and keys that can be used
    /// to validate the SAML authentication response (assertions) that are received from the
    /// IdP. You must generate the metadata document using the identity management software that
    /// is used as your organization's IdP.</p>
    /// <p>For more information, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_providers_saml.html">About SAML 2.0-based
    /// federation</a> in the <i>IAM User Guide</i>
    /// </p>
    pub saml_metadata_document: std::option::Option<std::string::String>,
    /// <p>The name of the provider to create.</p>
    /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
    /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
    pub name: std::option::Option<std::string::String>,
    /// <p>A list of tags that you want to attach to the new IAM SAML provider.
    /// Each tag consists of a key name and an associated value. For more information about tagging, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_tags.html">Tagging IAM resources</a> in the
    /// <i>IAM User Guide</i>.</p>
    /// <note>
    /// <p>If any one of the tags is invalid or if you exceed the allowed maximum number of tags, then the entire request
    /// fails and the resource is not created.</p>
    /// </note>
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
}
impl std::fmt::Debug for CreateSAMLProviderInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateSAMLProviderInput");
        formatter.field("saml_metadata_document", &self.saml_metadata_document);
        formatter.field("name", &self.name);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateRoleInput {
    /// <p> The path to the role. For more information about paths, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html">IAM
    /// Identifiers</a> in the <i>IAM User Guide</i>.</p>
    /// <p>This parameter is optional. If it is not included, it defaults to a slash (/).</p>
    /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting
    /// of either a forward slash (/) by itself or a string that must begin and end with forward slashes.
    /// In addition, it can contain any ASCII character from the ! (<code>\u0021</code>) through the DEL character (<code>\u007F</code>), including
    /// most punctuation characters, digits, and upper and lowercased letters.</p>
    pub path: std::option::Option<std::string::String>,
    /// <p>The name of the role to create.</p>
    /// <p>IAM user, group, role, and policy names must be unique within the account. Names are
    /// not distinguished by case. For example, you cannot create resources named both
    /// "MyResource" and "myresource".</p>
    pub role_name: std::option::Option<std::string::String>,
    /// <p>The trust relationship policy document that grants an entity permission to assume the
    /// role.</p>
    /// <p>In IAM, you must provide a JSON policy that has been converted to a string. However,
    /// for AWS CloudFormation templates formatted in YAML, you can provide the policy in JSON
    /// or YAML format. AWS CloudFormation always converts a YAML policy to JSON format before
    /// submitting it to IAM.</p>
    /// <p>The <a href="http://wikipedia.org/wiki/regex">regex pattern</a>
    /// used to validate this parameter is a string of characters consisting of the following:</p>
    /// <ul>
    /// <li>
    /// <p>Any printable ASCII
    /// character ranging from the space character (<code>\u0020</code>) through the end of the ASCII character range</p>
    /// </li>
    /// <li>
    /// <p>The printable characters in the Basic Latin and  Latin-1 Supplement character set
    /// (through <code>\u00FF</code>)</p>
    /// </li>
    /// <li>
    /// <p>The special characters tab (<code>\u0009</code>), line feed (<code>\u000A</code>), and
    /// carriage return (<code>\u000D</code>)</p>
    /// </li>
    /// </ul>
    /// <p> Upon success, the response includes the same trust policy in JSON format.</p>
    pub assume_role_policy_document: std::option::Option<std::string::String>,
    /// <p>A description of the role.</p>
    pub description: std::option::Option<std::string::String>,
    /// <p>The maximum session duration (in seconds) that you want to set for the specified role.
    /// If you do not specify a value for this setting, the default maximum of one hour is
    /// applied. This setting can have a value from 1 hour to 12 hours.</p>
    /// <p>Anyone who assumes the role from the AWS CLI or API can use the
    /// <code>DurationSeconds</code> API parameter or the <code>duration-seconds</code> CLI
    /// parameter to request a longer session. The <code>MaxSessionDuration</code> setting
    /// determines the maximum duration that can be requested using the
    /// <code>DurationSeconds</code> parameter. If users don't specify a value for the
    /// <code>DurationSeconds</code> parameter, their security credentials are valid for one
    /// hour by default. This applies when you use the <code>AssumeRole*</code> API operations
    /// or the <code>assume-role*</code> CLI operations but does not apply when you use those
    /// operations to create a console URL. For more information, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_use.html">Using IAM
    /// roles</a> in the <i>IAM User Guide</i>.</p>
    pub max_session_duration: std::option::Option<i32>,
    /// <p>The ARN of the policy that is used to set the permissions boundary for the
    /// role.</p>
    pub permissions_boundary: std::option::Option<std::string::String>,
    /// <p>A list of tags that you want to attach to the new role. Each tag consists of a key name and an associated value.
    /// For more information about tagging, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_tags.html">Tagging IAM resources</a> in the
    /// <i>IAM User Guide</i>.</p>
    /// <note>
    /// <p>If any one of the tags is invalid or if you exceed the allowed maximum number of tags, then the entire request
    /// fails and the resource is not created.</p>
    /// </note>
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
}
impl std::fmt::Debug for CreateRoleInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateRoleInput");
        formatter.field("path", &self.path);
        formatter.field("role_name", &self.role_name);
        formatter.field(
            "assume_role_policy_document",
            &self.assume_role_policy_document,
        );
        formatter.field("description", &self.description);
        formatter.field("max_session_duration", &self.max_session_duration);
        formatter.field("permissions_boundary", &self.permissions_boundary);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreatePolicyVersionInput {
    /// <p>The Amazon Resource Name (ARN) of the IAM policy to which you want to add a new
    /// version.</p>
    /// <p>For more information about ARNs, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">Amazon Resource Names (ARNs)</a> in the <i>AWS General Reference</i>.</p>
    pub policy_arn: std::option::Option<std::string::String>,
    /// <p>The JSON policy document that you want to use as the content for this new version of
    /// the policy.</p>
    /// <p>You must provide policies in JSON format in IAM. However, for AWS CloudFormation
    /// templates formatted in YAML, you can provide the policy in JSON or YAML format. AWS
    /// CloudFormation always converts a YAML policy to JSON format before submitting it to
    /// IAM.</p>
    /// <p>The <a href="http://wikipedia.org/wiki/regex">regex pattern</a>
    /// used to validate this parameter is a string of characters consisting of the following:</p>
    /// <ul>
    /// <li>
    /// <p>Any printable ASCII
    /// character ranging from the space character (<code>\u0020</code>) through the end of the ASCII character range</p>
    /// </li>
    /// <li>
    /// <p>The printable characters in the Basic Latin and  Latin-1 Supplement character set
    /// (through <code>\u00FF</code>)</p>
    /// </li>
    /// <li>
    /// <p>The special characters tab (<code>\u0009</code>), line feed (<code>\u000A</code>), and
    /// carriage return (<code>\u000D</code>)</p>
    /// </li>
    /// </ul>
    pub policy_document: std::option::Option<std::string::String>,
    /// <p>Specifies whether to set this version as the policy's default version.</p>
    /// <p>When this parameter is <code>true</code>, the new policy version becomes the operative
    /// version. That is, it becomes the version that is in effect for the IAM users, groups,
    /// and roles that the policy is attached to.</p>
    /// <p>For more information about managed policy versions, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/policies-managed-versions.html">Versioning for managed
    /// policies</a> in the <i>IAM User Guide</i>.</p>
    pub set_as_default: bool,
}
impl std::fmt::Debug for CreatePolicyVersionInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreatePolicyVersionInput");
        formatter.field("policy_arn", &self.policy_arn);
        formatter.field("policy_document", &self.policy_document);
        formatter.field("set_as_default", &self.set_as_default);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreatePolicyInput {
    /// <p>The friendly name of the policy.</p>
    /// <p>IAM user, group, role, and policy names must be unique within the account. Names are
    /// not distinguished by case. For example, you cannot create resources named both
    /// "MyResource" and "myresource".</p>
    pub policy_name: std::option::Option<std::string::String>,
    /// <p>The path for the policy.</p>
    /// <p>For more information about paths, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html">IAM identifiers</a> in the
    /// <i>IAM User Guide</i>.</p>
    /// <p>This parameter is optional. If it is not included, it defaults to a slash (/).</p>
    /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting
    /// of either a forward slash (/) by itself or a string that must begin and end with forward slashes.
    /// In addition, it can contain any ASCII character from the ! (<code>\u0021</code>) through the DEL character (<code>\u007F</code>), including
    /// most punctuation characters, digits, and upper and lowercased letters.</p>
    pub path: std::option::Option<std::string::String>,
    /// <p>The JSON policy document that you want to use as the content for the new
    /// policy.</p>
    /// <p>You must provide policies in JSON format in IAM. However, for AWS CloudFormation
    /// templates formatted in YAML, you can provide the policy in JSON or YAML format. AWS
    /// CloudFormation always converts a YAML policy to JSON format before submitting it to
    /// IAM.</p>
    /// <p>To learn more about JSON policy grammar, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_policies_grammar.html">Grammar of the IAM JSON policy language</a> in the
    /// <i>IAM User Guide</i>. </p>
    /// <p>The <a href="http://wikipedia.org/wiki/regex">regex pattern</a>
    /// used to validate this parameter is a string of characters consisting of the following:</p>
    /// <ul>
    /// <li>
    /// <p>Any printable ASCII
    /// character ranging from the space character (<code>\u0020</code>) through the end of the ASCII character range</p>
    /// </li>
    /// <li>
    /// <p>The printable characters in the Basic Latin and  Latin-1 Supplement character set
    /// (through <code>\u00FF</code>)</p>
    /// </li>
    /// <li>
    /// <p>The special characters tab (<code>\u0009</code>), line feed (<code>\u000A</code>), and
    /// carriage return (<code>\u000D</code>)</p>
    /// </li>
    /// </ul>
    pub policy_document: std::option::Option<std::string::String>,
    /// <p>A friendly description of the policy.</p>
    /// <p>Typically used to store information about the permissions defined in the policy. For
    /// example, "Grants access to production DynamoDB tables."</p>
    /// <p>The policy description is immutable. After a value is assigned, it cannot be
    /// changed.</p>
    pub description: std::option::Option<std::string::String>,
    /// <p>A list of tags that you want to attach to the new IAM customer managed policy.
    /// Each tag consists of a key name and an associated value. For more information about tagging, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_tags.html">Tagging IAM resources</a> in the
    /// <i>IAM User Guide</i>.</p>
    /// <note>
    /// <p>If any one of the tags is invalid or if you exceed the allowed maximum number of tags, then the entire request
    /// fails and the resource is not created.</p>
    /// </note>
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
}
impl std::fmt::Debug for CreatePolicyInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreatePolicyInput");
        formatter.field("policy_name", &self.policy_name);
        formatter.field("path", &self.path);
        formatter.field("policy_document", &self.policy_document);
        formatter.field("description", &self.description);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateOpenIDConnectProviderInput {
    /// <p>The URL of the identity provider. The URL must begin with <code>https://</code> and
    /// should correspond to the <code>iss</code> claim in the provider's OpenID Connect ID
    /// tokens. Per the OIDC standard, path components are allowed but query parameters are not.
    /// Typically the URL consists of only a hostname, like
    /// <code>https://server.example.org</code> or <code>https://example.com</code>.</p>
    /// <p>You cannot register the same provider multiple times in a single AWS account. If you
    /// try to submit a URL that has already been used for an OpenID Connect provider in the
    /// AWS account, you will get an error.</p>
    pub url: std::option::Option<std::string::String>,
    /// <p>A list of client IDs (also known as audiences). When a mobile or web app registers
    /// with an OpenID Connect provider, they establish a value that identifies the application.
    /// (This is the value that's sent as the <code>client_id</code> parameter on OAuth
    /// requests.)</p>
    /// <p>You can register multiple client IDs with the same provider. For example, you might
    /// have multiple applications that use the same OIDC provider. You cannot register more
    /// than 100 client IDs with a single IAM OIDC provider.</p>
    /// <p>There is no defined format for a client ID. The
    /// <code>CreateOpenIDConnectProviderRequest</code> operation accepts client IDs up to
    /// 255 characters long.</p>
    pub client_id_list: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>A list of server certificate thumbprints for the OpenID Connect (OIDC) identity
    /// provider's server certificates. Typically this list includes only one entry. However,
    /// IAM lets you have up to five thumbprints for an OIDC provider. This lets you maintain
    /// multiple thumbprints if the identity provider is rotating certificates.</p>
    /// <p>The server certificate thumbprint is the hex-encoded SHA-1 hash value of the X.509
    /// certificate used by the domain where the OpenID Connect provider makes its keys
    /// available. It is always a 40-character string.</p>
    /// <p>You must provide at least one thumbprint when creating an IAM OIDC provider. For
    /// example, assume that the OIDC provider is <code>server.example.com</code> and the
    /// provider stores its keys at https://keys.server.example.com/openid-connect. In that
    /// case, the thumbprint string would be the hex-encoded SHA-1 hash value of the certificate
    /// used by https://keys.server.example.com.</p>
    /// <p>For more information about obtaining the OIDC provider's thumbprint, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/identity-providers-oidc-obtain-thumbprint.html">Obtaining the
    /// thumbprint for an OpenID Connect provider</a> in the <i>IAM User
    /// Guide</i>.</p>
    pub thumbprint_list: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>A list of tags that you want to attach to the new IAM OpenID Connect (OIDC) provider.
    /// Each tag consists of a key name and an associated value. For more information about tagging, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_tags.html">Tagging IAM resources</a> in the
    /// <i>IAM User Guide</i>.</p>
    /// <note>
    /// <p>If any one of the tags is invalid or if you exceed the allowed maximum number of tags, then the entire request
    /// fails and the resource is not created.</p>
    /// </note>
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
}
impl std::fmt::Debug for CreateOpenIDConnectProviderInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateOpenIDConnectProviderInput");
        formatter.field("url", &self.url);
        formatter.field("client_id_list", &self.client_id_list);
        formatter.field("thumbprint_list", &self.thumbprint_list);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateLoginProfileInput {
    /// <p>The name of the IAM user to create a password for. The user must already
    /// exist.</p>
    /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
    /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
    pub user_name: std::option::Option<std::string::String>,
    /// <p>The new password for the user.</p>
    /// <p>The <a href="http://wikipedia.org/wiki/regex">regex pattern</a>
    /// that is used to validate this parameter is a string of characters. That string can include almost any printable
    /// ASCII character from the space (<code>\u0020</code>) through the end of the ASCII character range (<code>\u00FF</code>).
    /// You can also include the tab (<code>\u0009</code>), line feed (<code>\u000A</code>), and carriage return (<code>\u000D</code>)
    /// characters. Any of these characters are valid in a password. However, many tools, such
    /// as the AWS Management Console, might restrict the ability to type certain characters because they have
    /// special meaning within that tool.</p>
    pub password: std::option::Option<std::string::String>,
    /// <p>Specifies whether the user is required to set a new password on next sign-in.</p>
    pub password_reset_required: bool,
}
impl std::fmt::Debug for CreateLoginProfileInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateLoginProfileInput");
        formatter.field("user_name", &self.user_name);
        formatter.field("password", &"*** Sensitive Data Redacted ***");
        formatter.field("password_reset_required", &self.password_reset_required);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateInstanceProfileInput {
    /// <p>The name of the instance profile to create.</p>
    /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
    /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
    pub instance_profile_name: std::option::Option<std::string::String>,
    /// <p> The path to the instance profile. For more information about paths, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html">IAM
    /// Identifiers</a> in the <i>IAM User Guide</i>.</p>
    /// <p>This parameter is optional. If it is not included, it defaults to a slash (/).</p>
    /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting
    /// of either a forward slash (/) by itself or a string that must begin and end with forward slashes.
    /// In addition, it can contain any ASCII character from the ! (<code>\u0021</code>) through the DEL character (<code>\u007F</code>), including
    /// most punctuation characters, digits, and upper and lowercased letters.</p>
    pub path: std::option::Option<std::string::String>,
    /// <p>A list of tags that you want to attach to the newly created IAM instance profile.
    /// Each tag consists of a key name and an associated value. For more information about tagging, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_tags.html">Tagging IAM resources</a> in the
    /// <i>IAM User Guide</i>.</p>
    /// <note>
    /// <p>If any one of the tags is invalid or if you exceed the allowed maximum number of tags, then the entire request
    /// fails and the resource is not created.</p>
    /// </note>
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
}
impl std::fmt::Debug for CreateInstanceProfileInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateInstanceProfileInput");
        formatter.field("instance_profile_name", &self.instance_profile_name);
        formatter.field("path", &self.path);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateGroupInput {
    /// <p> The path to the group. For more information about paths, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html">IAM
    /// identifiers</a> in the <i>IAM User Guide</i>.</p>
    /// <p>This parameter is optional. If it is not included, it defaults to a slash (/).</p>
    /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting
    /// of either a forward slash (/) by itself or a string that must begin and end with forward slashes.
    /// In addition, it can contain any ASCII character from the ! (<code>\u0021</code>) through the DEL character (<code>\u007F</code>), including
    /// most punctuation characters, digits, and upper and lowercased letters.</p>
    pub path: std::option::Option<std::string::String>,
    /// <p>The name of the group to create. Do not include the path in this value.</p>
    /// <p>IAM user, group, role, and policy names must be unique within the account. Names are
    /// not distinguished by case. For example, you cannot create resources named both
    /// "MyResource" and "myresource".</p>
    pub group_name: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for CreateGroupInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateGroupInput");
        formatter.field("path", &self.path);
        formatter.field("group_name", &self.group_name);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateAccountAliasInput {
    /// <p>The account alias to create.</p>
    /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of
    /// lowercase letters, digits, and dashes. You cannot start or finish with a dash, nor can you have
    /// two dashes in a row.</p>
    pub account_alias: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for CreateAccountAliasInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateAccountAliasInput");
        formatter.field("account_alias", &self.account_alias);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateAccessKeyInput {
    /// <p>The name of the IAM user that the new key will belong to.</p>
    /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
    /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
    pub user_name: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for CreateAccessKeyInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateAccessKeyInput");
        formatter.field("user_name", &self.user_name);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ChangePasswordInput {
    /// <p>The IAM user's current password.</p>
    pub old_password: std::option::Option<std::string::String>,
    /// <p>The new password. The new password must conform to the AWS account's password
    /// policy, if one exists.</p>
    /// <p>The <a href="http://wikipedia.org/wiki/regex">regex pattern</a>
    /// that is used to validate this parameter is a string of characters. That string can include almost any printable
    /// ASCII character from the space (<code>\u0020</code>) through the end of the ASCII character range (<code>\u00FF</code>).
    /// You can also include the tab (<code>\u0009</code>), line feed (<code>\u000A</code>), and carriage return (<code>\u000D</code>)
    /// characters. Any of these characters are valid in a password. However, many tools, such
    /// as the AWS Management Console, might restrict the ability to type certain characters because they have
    /// special meaning within that tool.</p>
    pub new_password: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ChangePasswordInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ChangePasswordInput");
        formatter.field("old_password", &"*** Sensitive Data Redacted ***");
        formatter.field("new_password", &"*** Sensitive Data Redacted ***");
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AttachUserPolicyInput {
    /// <p>The name (friendly name, not ARN) of the IAM user to attach the policy to.</p>
    /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
    /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
    pub user_name: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the IAM policy you want to attach.</p>
    /// <p>For more information about ARNs, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">Amazon Resource Names (ARNs)</a> in the <i>AWS General Reference</i>.</p>
    pub policy_arn: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for AttachUserPolicyInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AttachUserPolicyInput");
        formatter.field("user_name", &self.user_name);
        formatter.field("policy_arn", &self.policy_arn);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AttachRolePolicyInput {
    /// <p>The name (friendly name, not ARN) of the role to attach the policy to.</p>
    /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
    /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
    pub role_name: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the IAM policy you want to attach.</p>
    /// <p>For more information about ARNs, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">Amazon Resource Names (ARNs)</a> in the <i>AWS General Reference</i>.</p>
    pub policy_arn: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for AttachRolePolicyInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AttachRolePolicyInput");
        formatter.field("role_name", &self.role_name);
        formatter.field("policy_arn", &self.policy_arn);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AttachGroupPolicyInput {
    /// <p>The name (friendly name, not ARN) of the group to attach the policy to.</p>
    /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
    /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
    pub group_name: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the IAM policy you want to attach.</p>
    /// <p>For more information about ARNs, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">Amazon Resource Names (ARNs)</a> in the <i>AWS General Reference</i>.</p>
    pub policy_arn: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for AttachGroupPolicyInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AttachGroupPolicyInput");
        formatter.field("group_name", &self.group_name);
        formatter.field("policy_arn", &self.policy_arn);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AddUserToGroupInput {
    /// <p>The name of the group to update.</p>
    /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
    /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
    pub group_name: std::option::Option<std::string::String>,
    /// <p>The name of the user to add.</p>
    /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
    /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
    pub user_name: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for AddUserToGroupInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AddUserToGroupInput");
        formatter.field("group_name", &self.group_name);
        formatter.field("user_name", &self.user_name);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AddRoleToInstanceProfileInput {
    /// <p>The name of the instance profile to update.</p>
    /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
    /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
    pub instance_profile_name: std::option::Option<std::string::String>,
    /// <p>The name of the role to add.</p>
    /// <p>This parameter allows (through its <a href="http://wikipedia.org/wiki/regex">regex pattern</a>) a string of characters consisting of upper and lowercase alphanumeric
    /// characters with no spaces. You can also include any of the following characters: _+=,.@-</p>
    pub role_name: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for AddRoleToInstanceProfileInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AddRoleToInstanceProfileInput");
        formatter.field("instance_profile_name", &self.instance_profile_name);
        formatter.field("role_name", &self.role_name);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AddClientIDToOpenIDConnectProviderInput {
    /// <p>The Amazon Resource Name (ARN) of the IAM OpenID Connect (OIDC) provider resource to
    /// add the client ID to. You can get a list of OIDC provider ARNs by using the <a>ListOpenIDConnectProviders</a> operation.</p>
    pub open_id_connect_provider_arn: std::option::Option<std::string::String>,
    /// <p>The client ID (also known as audience) to add to the IAM OpenID Connect provider
    /// resource.</p>
    pub client_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for AddClientIDToOpenIDConnectProviderInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AddClientIDToOpenIDConnectProviderInput");
        formatter.field(
            "open_id_connect_provider_arn",
            &self.open_id_connect_provider_arn,
        );
        formatter.field("client_id", &self.client_id);
        formatter.finish()
    }
}
