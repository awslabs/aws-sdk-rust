// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct AddClientIDToOpenIDConnectProviderError {
    pub kind: AddClientIDToOpenIDConnectProviderErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum AddClientIDToOpenIDConnectProviderErrorKind {
    InvalidInputException(crate::error::InvalidInputException),
    LimitExceededException(crate::error::LimitExceededException),
    NoSuchEntityException(crate::error::NoSuchEntityException),
    ServiceFailureException(crate::error::ServiceFailureException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for AddClientIDToOpenIDConnectProviderError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            AddClientIDToOpenIDConnectProviderErrorKind::InvalidInputException(_inner) => {
                _inner.fmt(f)
            }
            AddClientIDToOpenIDConnectProviderErrorKind::LimitExceededException(_inner) => {
                _inner.fmt(f)
            }
            AddClientIDToOpenIDConnectProviderErrorKind::NoSuchEntityException(_inner) => {
                _inner.fmt(f)
            }
            AddClientIDToOpenIDConnectProviderErrorKind::ServiceFailureException(_inner) => {
                _inner.fmt(f)
            }
            AddClientIDToOpenIDConnectProviderErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for AddClientIDToOpenIDConnectProviderError {
    fn code(&self) -> Option<&str> {
        AddClientIDToOpenIDConnectProviderError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl AddClientIDToOpenIDConnectProviderError {
    pub fn new(
        kind: AddClientIDToOpenIDConnectProviderErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: AddClientIDToOpenIDConnectProviderErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: AddClientIDToOpenIDConnectProviderErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            AddClientIDToOpenIDConnectProviderErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            AddClientIDToOpenIDConnectProviderErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_no_such_entity_exception(&self) -> bool {
        matches!(
            &self.kind,
            AddClientIDToOpenIDConnectProviderErrorKind::NoSuchEntityException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            AddClientIDToOpenIDConnectProviderErrorKind::ServiceFailureException(_)
        )
    }
}
impl std::error::Error for AddClientIDToOpenIDConnectProviderError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            AddClientIDToOpenIDConnectProviderErrorKind::InvalidInputException(_inner) => {
                Some(_inner)
            }
            AddClientIDToOpenIDConnectProviderErrorKind::LimitExceededException(_inner) => {
                Some(_inner)
            }
            AddClientIDToOpenIDConnectProviderErrorKind::NoSuchEntityException(_inner) => {
                Some(_inner)
            }
            AddClientIDToOpenIDConnectProviderErrorKind::ServiceFailureException(_inner) => {
                Some(_inner)
            }
            AddClientIDToOpenIDConnectProviderErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct AddRoleToInstanceProfileError {
    pub kind: AddRoleToInstanceProfileErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum AddRoleToInstanceProfileErrorKind {
    EntityAlreadyExistsException(crate::error::EntityAlreadyExistsException),
    LimitExceededException(crate::error::LimitExceededException),
    NoSuchEntityException(crate::error::NoSuchEntityException),
    ServiceFailureException(crate::error::ServiceFailureException),
    UnmodifiableEntityException(crate::error::UnmodifiableEntityException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for AddRoleToInstanceProfileError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            AddRoleToInstanceProfileErrorKind::EntityAlreadyExistsException(_inner) => {
                _inner.fmt(f)
            }
            AddRoleToInstanceProfileErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            AddRoleToInstanceProfileErrorKind::NoSuchEntityException(_inner) => _inner.fmt(f),
            AddRoleToInstanceProfileErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            AddRoleToInstanceProfileErrorKind::UnmodifiableEntityException(_inner) => _inner.fmt(f),
            AddRoleToInstanceProfileErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for AddRoleToInstanceProfileError {
    fn code(&self) -> Option<&str> {
        AddRoleToInstanceProfileError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl AddRoleToInstanceProfileError {
    pub fn new(kind: AddRoleToInstanceProfileErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: AddRoleToInstanceProfileErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: AddRoleToInstanceProfileErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_entity_already_exists_exception(&self) -> bool {
        matches!(
            &self.kind,
            AddRoleToInstanceProfileErrorKind::EntityAlreadyExistsException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            AddRoleToInstanceProfileErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_no_such_entity_exception(&self) -> bool {
        matches!(
            &self.kind,
            AddRoleToInstanceProfileErrorKind::NoSuchEntityException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            AddRoleToInstanceProfileErrorKind::ServiceFailureException(_)
        )
    }
    pub fn is_unmodifiable_entity_exception(&self) -> bool {
        matches!(
            &self.kind,
            AddRoleToInstanceProfileErrorKind::UnmodifiableEntityException(_)
        )
    }
}
impl std::error::Error for AddRoleToInstanceProfileError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            AddRoleToInstanceProfileErrorKind::EntityAlreadyExistsException(_inner) => Some(_inner),
            AddRoleToInstanceProfileErrorKind::LimitExceededException(_inner) => Some(_inner),
            AddRoleToInstanceProfileErrorKind::NoSuchEntityException(_inner) => Some(_inner),
            AddRoleToInstanceProfileErrorKind::ServiceFailureException(_inner) => Some(_inner),
            AddRoleToInstanceProfileErrorKind::UnmodifiableEntityException(_inner) => Some(_inner),
            AddRoleToInstanceProfileErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct AddUserToGroupError {
    pub kind: AddUserToGroupErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum AddUserToGroupErrorKind {
    LimitExceededException(crate::error::LimitExceededException),
    NoSuchEntityException(crate::error::NoSuchEntityException),
    ServiceFailureException(crate::error::ServiceFailureException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for AddUserToGroupError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            AddUserToGroupErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            AddUserToGroupErrorKind::NoSuchEntityException(_inner) => _inner.fmt(f),
            AddUserToGroupErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            AddUserToGroupErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for AddUserToGroupError {
    fn code(&self) -> Option<&str> {
        AddUserToGroupError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl AddUserToGroupError {
    pub fn new(kind: AddUserToGroupErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: AddUserToGroupErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: AddUserToGroupErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            AddUserToGroupErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_no_such_entity_exception(&self) -> bool {
        matches!(
            &self.kind,
            AddUserToGroupErrorKind::NoSuchEntityException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            AddUserToGroupErrorKind::ServiceFailureException(_)
        )
    }
}
impl std::error::Error for AddUserToGroupError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            AddUserToGroupErrorKind::LimitExceededException(_inner) => Some(_inner),
            AddUserToGroupErrorKind::NoSuchEntityException(_inner) => Some(_inner),
            AddUserToGroupErrorKind::ServiceFailureException(_inner) => Some(_inner),
            AddUserToGroupErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct AttachGroupPolicyError {
    pub kind: AttachGroupPolicyErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum AttachGroupPolicyErrorKind {
    InvalidInputException(crate::error::InvalidInputException),
    LimitExceededException(crate::error::LimitExceededException),
    NoSuchEntityException(crate::error::NoSuchEntityException),
    PolicyNotAttachableException(crate::error::PolicyNotAttachableException),
    ServiceFailureException(crate::error::ServiceFailureException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for AttachGroupPolicyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            AttachGroupPolicyErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            AttachGroupPolicyErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            AttachGroupPolicyErrorKind::NoSuchEntityException(_inner) => _inner.fmt(f),
            AttachGroupPolicyErrorKind::PolicyNotAttachableException(_inner) => _inner.fmt(f),
            AttachGroupPolicyErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            AttachGroupPolicyErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for AttachGroupPolicyError {
    fn code(&self) -> Option<&str> {
        AttachGroupPolicyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl AttachGroupPolicyError {
    pub fn new(kind: AttachGroupPolicyErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: AttachGroupPolicyErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: AttachGroupPolicyErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            AttachGroupPolicyErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            AttachGroupPolicyErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_no_such_entity_exception(&self) -> bool {
        matches!(
            &self.kind,
            AttachGroupPolicyErrorKind::NoSuchEntityException(_)
        )
    }
    pub fn is_policy_not_attachable_exception(&self) -> bool {
        matches!(
            &self.kind,
            AttachGroupPolicyErrorKind::PolicyNotAttachableException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            AttachGroupPolicyErrorKind::ServiceFailureException(_)
        )
    }
}
impl std::error::Error for AttachGroupPolicyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            AttachGroupPolicyErrorKind::InvalidInputException(_inner) => Some(_inner),
            AttachGroupPolicyErrorKind::LimitExceededException(_inner) => Some(_inner),
            AttachGroupPolicyErrorKind::NoSuchEntityException(_inner) => Some(_inner),
            AttachGroupPolicyErrorKind::PolicyNotAttachableException(_inner) => Some(_inner),
            AttachGroupPolicyErrorKind::ServiceFailureException(_inner) => Some(_inner),
            AttachGroupPolicyErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct AttachRolePolicyError {
    pub kind: AttachRolePolicyErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum AttachRolePolicyErrorKind {
    InvalidInputException(crate::error::InvalidInputException),
    LimitExceededException(crate::error::LimitExceededException),
    NoSuchEntityException(crate::error::NoSuchEntityException),
    PolicyNotAttachableException(crate::error::PolicyNotAttachableException),
    ServiceFailureException(crate::error::ServiceFailureException),
    UnmodifiableEntityException(crate::error::UnmodifiableEntityException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for AttachRolePolicyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            AttachRolePolicyErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            AttachRolePolicyErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            AttachRolePolicyErrorKind::NoSuchEntityException(_inner) => _inner.fmt(f),
            AttachRolePolicyErrorKind::PolicyNotAttachableException(_inner) => _inner.fmt(f),
            AttachRolePolicyErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            AttachRolePolicyErrorKind::UnmodifiableEntityException(_inner) => _inner.fmt(f),
            AttachRolePolicyErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for AttachRolePolicyError {
    fn code(&self) -> Option<&str> {
        AttachRolePolicyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl AttachRolePolicyError {
    pub fn new(kind: AttachRolePolicyErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: AttachRolePolicyErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: AttachRolePolicyErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            AttachRolePolicyErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            AttachRolePolicyErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_no_such_entity_exception(&self) -> bool {
        matches!(
            &self.kind,
            AttachRolePolicyErrorKind::NoSuchEntityException(_)
        )
    }
    pub fn is_policy_not_attachable_exception(&self) -> bool {
        matches!(
            &self.kind,
            AttachRolePolicyErrorKind::PolicyNotAttachableException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            AttachRolePolicyErrorKind::ServiceFailureException(_)
        )
    }
    pub fn is_unmodifiable_entity_exception(&self) -> bool {
        matches!(
            &self.kind,
            AttachRolePolicyErrorKind::UnmodifiableEntityException(_)
        )
    }
}
impl std::error::Error for AttachRolePolicyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            AttachRolePolicyErrorKind::InvalidInputException(_inner) => Some(_inner),
            AttachRolePolicyErrorKind::LimitExceededException(_inner) => Some(_inner),
            AttachRolePolicyErrorKind::NoSuchEntityException(_inner) => Some(_inner),
            AttachRolePolicyErrorKind::PolicyNotAttachableException(_inner) => Some(_inner),
            AttachRolePolicyErrorKind::ServiceFailureException(_inner) => Some(_inner),
            AttachRolePolicyErrorKind::UnmodifiableEntityException(_inner) => Some(_inner),
            AttachRolePolicyErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct AttachUserPolicyError {
    pub kind: AttachUserPolicyErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum AttachUserPolicyErrorKind {
    InvalidInputException(crate::error::InvalidInputException),
    LimitExceededException(crate::error::LimitExceededException),
    NoSuchEntityException(crate::error::NoSuchEntityException),
    PolicyNotAttachableException(crate::error::PolicyNotAttachableException),
    ServiceFailureException(crate::error::ServiceFailureException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for AttachUserPolicyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            AttachUserPolicyErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            AttachUserPolicyErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            AttachUserPolicyErrorKind::NoSuchEntityException(_inner) => _inner.fmt(f),
            AttachUserPolicyErrorKind::PolicyNotAttachableException(_inner) => _inner.fmt(f),
            AttachUserPolicyErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            AttachUserPolicyErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for AttachUserPolicyError {
    fn code(&self) -> Option<&str> {
        AttachUserPolicyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl AttachUserPolicyError {
    pub fn new(kind: AttachUserPolicyErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: AttachUserPolicyErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: AttachUserPolicyErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            AttachUserPolicyErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            AttachUserPolicyErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_no_such_entity_exception(&self) -> bool {
        matches!(
            &self.kind,
            AttachUserPolicyErrorKind::NoSuchEntityException(_)
        )
    }
    pub fn is_policy_not_attachable_exception(&self) -> bool {
        matches!(
            &self.kind,
            AttachUserPolicyErrorKind::PolicyNotAttachableException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            AttachUserPolicyErrorKind::ServiceFailureException(_)
        )
    }
}
impl std::error::Error for AttachUserPolicyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            AttachUserPolicyErrorKind::InvalidInputException(_inner) => Some(_inner),
            AttachUserPolicyErrorKind::LimitExceededException(_inner) => Some(_inner),
            AttachUserPolicyErrorKind::NoSuchEntityException(_inner) => Some(_inner),
            AttachUserPolicyErrorKind::PolicyNotAttachableException(_inner) => Some(_inner),
            AttachUserPolicyErrorKind::ServiceFailureException(_inner) => Some(_inner),
            AttachUserPolicyErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ChangePasswordError {
    pub kind: ChangePasswordErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ChangePasswordErrorKind {
    EntityTemporarilyUnmodifiableException(crate::error::EntityTemporarilyUnmodifiableException),
    InvalidUserTypeException(crate::error::InvalidUserTypeException),
    LimitExceededException(crate::error::LimitExceededException),
    NoSuchEntityException(crate::error::NoSuchEntityException),
    PasswordPolicyViolationException(crate::error::PasswordPolicyViolationException),
    ServiceFailureException(crate::error::ServiceFailureException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ChangePasswordError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ChangePasswordErrorKind::EntityTemporarilyUnmodifiableException(_inner) => {
                _inner.fmt(f)
            }
            ChangePasswordErrorKind::InvalidUserTypeException(_inner) => _inner.fmt(f),
            ChangePasswordErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            ChangePasswordErrorKind::NoSuchEntityException(_inner) => _inner.fmt(f),
            ChangePasswordErrorKind::PasswordPolicyViolationException(_inner) => _inner.fmt(f),
            ChangePasswordErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            ChangePasswordErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ChangePasswordError {
    fn code(&self) -> Option<&str> {
        ChangePasswordError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ChangePasswordError {
    pub fn new(kind: ChangePasswordErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ChangePasswordErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ChangePasswordErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_entity_temporarily_unmodifiable_exception(&self) -> bool {
        matches!(
            &self.kind,
            ChangePasswordErrorKind::EntityTemporarilyUnmodifiableException(_)
        )
    }
    pub fn is_invalid_user_type_exception(&self) -> bool {
        matches!(
            &self.kind,
            ChangePasswordErrorKind::InvalidUserTypeException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            ChangePasswordErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_no_such_entity_exception(&self) -> bool {
        matches!(
            &self.kind,
            ChangePasswordErrorKind::NoSuchEntityException(_)
        )
    }
    pub fn is_password_policy_violation_exception(&self) -> bool {
        matches!(
            &self.kind,
            ChangePasswordErrorKind::PasswordPolicyViolationException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            ChangePasswordErrorKind::ServiceFailureException(_)
        )
    }
}
impl std::error::Error for ChangePasswordError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ChangePasswordErrorKind::EntityTemporarilyUnmodifiableException(_inner) => Some(_inner),
            ChangePasswordErrorKind::InvalidUserTypeException(_inner) => Some(_inner),
            ChangePasswordErrorKind::LimitExceededException(_inner) => Some(_inner),
            ChangePasswordErrorKind::NoSuchEntityException(_inner) => Some(_inner),
            ChangePasswordErrorKind::PasswordPolicyViolationException(_inner) => Some(_inner),
            ChangePasswordErrorKind::ServiceFailureException(_inner) => Some(_inner),
            ChangePasswordErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateAccessKeyError {
    pub kind: CreateAccessKeyErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateAccessKeyErrorKind {
    LimitExceededException(crate::error::LimitExceededException),
    NoSuchEntityException(crate::error::NoSuchEntityException),
    ServiceFailureException(crate::error::ServiceFailureException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateAccessKeyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateAccessKeyErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            CreateAccessKeyErrorKind::NoSuchEntityException(_inner) => _inner.fmt(f),
            CreateAccessKeyErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            CreateAccessKeyErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateAccessKeyError {
    fn code(&self) -> Option<&str> {
        CreateAccessKeyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateAccessKeyError {
    pub fn new(kind: CreateAccessKeyErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateAccessKeyErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateAccessKeyErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateAccessKeyErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_no_such_entity_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateAccessKeyErrorKind::NoSuchEntityException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateAccessKeyErrorKind::ServiceFailureException(_)
        )
    }
}
impl std::error::Error for CreateAccessKeyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateAccessKeyErrorKind::LimitExceededException(_inner) => Some(_inner),
            CreateAccessKeyErrorKind::NoSuchEntityException(_inner) => Some(_inner),
            CreateAccessKeyErrorKind::ServiceFailureException(_inner) => Some(_inner),
            CreateAccessKeyErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateAccountAliasError {
    pub kind: CreateAccountAliasErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateAccountAliasErrorKind {
    EntityAlreadyExistsException(crate::error::EntityAlreadyExistsException),
    LimitExceededException(crate::error::LimitExceededException),
    ServiceFailureException(crate::error::ServiceFailureException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateAccountAliasError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateAccountAliasErrorKind::EntityAlreadyExistsException(_inner) => _inner.fmt(f),
            CreateAccountAliasErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            CreateAccountAliasErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            CreateAccountAliasErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateAccountAliasError {
    fn code(&self) -> Option<&str> {
        CreateAccountAliasError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateAccountAliasError {
    pub fn new(kind: CreateAccountAliasErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateAccountAliasErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateAccountAliasErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_entity_already_exists_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateAccountAliasErrorKind::EntityAlreadyExistsException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateAccountAliasErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateAccountAliasErrorKind::ServiceFailureException(_)
        )
    }
}
impl std::error::Error for CreateAccountAliasError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateAccountAliasErrorKind::EntityAlreadyExistsException(_inner) => Some(_inner),
            CreateAccountAliasErrorKind::LimitExceededException(_inner) => Some(_inner),
            CreateAccountAliasErrorKind::ServiceFailureException(_inner) => Some(_inner),
            CreateAccountAliasErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateGroupError {
    pub kind: CreateGroupErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateGroupErrorKind {
    EntityAlreadyExistsException(crate::error::EntityAlreadyExistsException),
    LimitExceededException(crate::error::LimitExceededException),
    NoSuchEntityException(crate::error::NoSuchEntityException),
    ServiceFailureException(crate::error::ServiceFailureException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateGroupError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateGroupErrorKind::EntityAlreadyExistsException(_inner) => _inner.fmt(f),
            CreateGroupErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            CreateGroupErrorKind::NoSuchEntityException(_inner) => _inner.fmt(f),
            CreateGroupErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            CreateGroupErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateGroupError {
    fn code(&self) -> Option<&str> {
        CreateGroupError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateGroupError {
    pub fn new(kind: CreateGroupErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateGroupErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateGroupErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_entity_already_exists_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateGroupErrorKind::EntityAlreadyExistsException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(&self.kind, CreateGroupErrorKind::LimitExceededException(_))
    }
    pub fn is_no_such_entity_exception(&self) -> bool {
        matches!(&self.kind, CreateGroupErrorKind::NoSuchEntityException(_))
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(&self.kind, CreateGroupErrorKind::ServiceFailureException(_))
    }
}
impl std::error::Error for CreateGroupError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateGroupErrorKind::EntityAlreadyExistsException(_inner) => Some(_inner),
            CreateGroupErrorKind::LimitExceededException(_inner) => Some(_inner),
            CreateGroupErrorKind::NoSuchEntityException(_inner) => Some(_inner),
            CreateGroupErrorKind::ServiceFailureException(_inner) => Some(_inner),
            CreateGroupErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateInstanceProfileError {
    pub kind: CreateInstanceProfileErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateInstanceProfileErrorKind {
    ConcurrentModificationException(crate::error::ConcurrentModificationException),
    EntityAlreadyExistsException(crate::error::EntityAlreadyExistsException),
    InvalidInputException(crate::error::InvalidInputException),
    LimitExceededException(crate::error::LimitExceededException),
    ServiceFailureException(crate::error::ServiceFailureException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateInstanceProfileError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateInstanceProfileErrorKind::ConcurrentModificationException(_inner) => {
                _inner.fmt(f)
            }
            CreateInstanceProfileErrorKind::EntityAlreadyExistsException(_inner) => _inner.fmt(f),
            CreateInstanceProfileErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            CreateInstanceProfileErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            CreateInstanceProfileErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            CreateInstanceProfileErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateInstanceProfileError {
    fn code(&self) -> Option<&str> {
        CreateInstanceProfileError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateInstanceProfileError {
    pub fn new(kind: CreateInstanceProfileErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateInstanceProfileErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateInstanceProfileErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_concurrent_modification_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateInstanceProfileErrorKind::ConcurrentModificationException(_)
        )
    }
    pub fn is_entity_already_exists_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateInstanceProfileErrorKind::EntityAlreadyExistsException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateInstanceProfileErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateInstanceProfileErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateInstanceProfileErrorKind::ServiceFailureException(_)
        )
    }
}
impl std::error::Error for CreateInstanceProfileError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateInstanceProfileErrorKind::ConcurrentModificationException(_inner) => Some(_inner),
            CreateInstanceProfileErrorKind::EntityAlreadyExistsException(_inner) => Some(_inner),
            CreateInstanceProfileErrorKind::InvalidInputException(_inner) => Some(_inner),
            CreateInstanceProfileErrorKind::LimitExceededException(_inner) => Some(_inner),
            CreateInstanceProfileErrorKind::ServiceFailureException(_inner) => Some(_inner),
            CreateInstanceProfileErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateLoginProfileError {
    pub kind: CreateLoginProfileErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateLoginProfileErrorKind {
    EntityAlreadyExistsException(crate::error::EntityAlreadyExistsException),
    LimitExceededException(crate::error::LimitExceededException),
    NoSuchEntityException(crate::error::NoSuchEntityException),
    PasswordPolicyViolationException(crate::error::PasswordPolicyViolationException),
    ServiceFailureException(crate::error::ServiceFailureException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateLoginProfileError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateLoginProfileErrorKind::EntityAlreadyExistsException(_inner) => _inner.fmt(f),
            CreateLoginProfileErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            CreateLoginProfileErrorKind::NoSuchEntityException(_inner) => _inner.fmt(f),
            CreateLoginProfileErrorKind::PasswordPolicyViolationException(_inner) => _inner.fmt(f),
            CreateLoginProfileErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            CreateLoginProfileErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateLoginProfileError {
    fn code(&self) -> Option<&str> {
        CreateLoginProfileError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateLoginProfileError {
    pub fn new(kind: CreateLoginProfileErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateLoginProfileErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateLoginProfileErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_entity_already_exists_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateLoginProfileErrorKind::EntityAlreadyExistsException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateLoginProfileErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_no_such_entity_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateLoginProfileErrorKind::NoSuchEntityException(_)
        )
    }
    pub fn is_password_policy_violation_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateLoginProfileErrorKind::PasswordPolicyViolationException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateLoginProfileErrorKind::ServiceFailureException(_)
        )
    }
}
impl std::error::Error for CreateLoginProfileError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateLoginProfileErrorKind::EntityAlreadyExistsException(_inner) => Some(_inner),
            CreateLoginProfileErrorKind::LimitExceededException(_inner) => Some(_inner),
            CreateLoginProfileErrorKind::NoSuchEntityException(_inner) => Some(_inner),
            CreateLoginProfileErrorKind::PasswordPolicyViolationException(_inner) => Some(_inner),
            CreateLoginProfileErrorKind::ServiceFailureException(_inner) => Some(_inner),
            CreateLoginProfileErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateOpenIDConnectProviderError {
    pub kind: CreateOpenIDConnectProviderErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateOpenIDConnectProviderErrorKind {
    ConcurrentModificationException(crate::error::ConcurrentModificationException),
    EntityAlreadyExistsException(crate::error::EntityAlreadyExistsException),
    InvalidInputException(crate::error::InvalidInputException),
    LimitExceededException(crate::error::LimitExceededException),
    ServiceFailureException(crate::error::ServiceFailureException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateOpenIDConnectProviderError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateOpenIDConnectProviderErrorKind::ConcurrentModificationException(_inner) => {
                _inner.fmt(f)
            }
            CreateOpenIDConnectProviderErrorKind::EntityAlreadyExistsException(_inner) => {
                _inner.fmt(f)
            }
            CreateOpenIDConnectProviderErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            CreateOpenIDConnectProviderErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            CreateOpenIDConnectProviderErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            CreateOpenIDConnectProviderErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateOpenIDConnectProviderError {
    fn code(&self) -> Option<&str> {
        CreateOpenIDConnectProviderError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateOpenIDConnectProviderError {
    pub fn new(kind: CreateOpenIDConnectProviderErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateOpenIDConnectProviderErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateOpenIDConnectProviderErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_concurrent_modification_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateOpenIDConnectProviderErrorKind::ConcurrentModificationException(_)
        )
    }
    pub fn is_entity_already_exists_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateOpenIDConnectProviderErrorKind::EntityAlreadyExistsException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateOpenIDConnectProviderErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateOpenIDConnectProviderErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateOpenIDConnectProviderErrorKind::ServiceFailureException(_)
        )
    }
}
impl std::error::Error for CreateOpenIDConnectProviderError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateOpenIDConnectProviderErrorKind::ConcurrentModificationException(_inner) => {
                Some(_inner)
            }
            CreateOpenIDConnectProviderErrorKind::EntityAlreadyExistsException(_inner) => {
                Some(_inner)
            }
            CreateOpenIDConnectProviderErrorKind::InvalidInputException(_inner) => Some(_inner),
            CreateOpenIDConnectProviderErrorKind::LimitExceededException(_inner) => Some(_inner),
            CreateOpenIDConnectProviderErrorKind::ServiceFailureException(_inner) => Some(_inner),
            CreateOpenIDConnectProviderErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreatePolicyError {
    pub kind: CreatePolicyErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreatePolicyErrorKind {
    ConcurrentModificationException(crate::error::ConcurrentModificationException),
    EntityAlreadyExistsException(crate::error::EntityAlreadyExistsException),
    InvalidInputException(crate::error::InvalidInputException),
    LimitExceededException(crate::error::LimitExceededException),
    MalformedPolicyDocumentException(crate::error::MalformedPolicyDocumentException),
    ServiceFailureException(crate::error::ServiceFailureException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreatePolicyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreatePolicyErrorKind::ConcurrentModificationException(_inner) => _inner.fmt(f),
            CreatePolicyErrorKind::EntityAlreadyExistsException(_inner) => _inner.fmt(f),
            CreatePolicyErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            CreatePolicyErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            CreatePolicyErrorKind::MalformedPolicyDocumentException(_inner) => _inner.fmt(f),
            CreatePolicyErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            CreatePolicyErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreatePolicyError {
    fn code(&self) -> Option<&str> {
        CreatePolicyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreatePolicyError {
    pub fn new(kind: CreatePolicyErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreatePolicyErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreatePolicyErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_concurrent_modification_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreatePolicyErrorKind::ConcurrentModificationException(_)
        )
    }
    pub fn is_entity_already_exists_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreatePolicyErrorKind::EntityAlreadyExistsException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(&self.kind, CreatePolicyErrorKind::InvalidInputException(_))
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(&self.kind, CreatePolicyErrorKind::LimitExceededException(_))
    }
    pub fn is_malformed_policy_document_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreatePolicyErrorKind::MalformedPolicyDocumentException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreatePolicyErrorKind::ServiceFailureException(_)
        )
    }
}
impl std::error::Error for CreatePolicyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreatePolicyErrorKind::ConcurrentModificationException(_inner) => Some(_inner),
            CreatePolicyErrorKind::EntityAlreadyExistsException(_inner) => Some(_inner),
            CreatePolicyErrorKind::InvalidInputException(_inner) => Some(_inner),
            CreatePolicyErrorKind::LimitExceededException(_inner) => Some(_inner),
            CreatePolicyErrorKind::MalformedPolicyDocumentException(_inner) => Some(_inner),
            CreatePolicyErrorKind::ServiceFailureException(_inner) => Some(_inner),
            CreatePolicyErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreatePolicyVersionError {
    pub kind: CreatePolicyVersionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreatePolicyVersionErrorKind {
    InvalidInputException(crate::error::InvalidInputException),
    LimitExceededException(crate::error::LimitExceededException),
    MalformedPolicyDocumentException(crate::error::MalformedPolicyDocumentException),
    NoSuchEntityException(crate::error::NoSuchEntityException),
    ServiceFailureException(crate::error::ServiceFailureException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreatePolicyVersionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreatePolicyVersionErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            CreatePolicyVersionErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            CreatePolicyVersionErrorKind::MalformedPolicyDocumentException(_inner) => _inner.fmt(f),
            CreatePolicyVersionErrorKind::NoSuchEntityException(_inner) => _inner.fmt(f),
            CreatePolicyVersionErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            CreatePolicyVersionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreatePolicyVersionError {
    fn code(&self) -> Option<&str> {
        CreatePolicyVersionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreatePolicyVersionError {
    pub fn new(kind: CreatePolicyVersionErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreatePolicyVersionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreatePolicyVersionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreatePolicyVersionErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreatePolicyVersionErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_malformed_policy_document_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreatePolicyVersionErrorKind::MalformedPolicyDocumentException(_)
        )
    }
    pub fn is_no_such_entity_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreatePolicyVersionErrorKind::NoSuchEntityException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreatePolicyVersionErrorKind::ServiceFailureException(_)
        )
    }
}
impl std::error::Error for CreatePolicyVersionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreatePolicyVersionErrorKind::InvalidInputException(_inner) => Some(_inner),
            CreatePolicyVersionErrorKind::LimitExceededException(_inner) => Some(_inner),
            CreatePolicyVersionErrorKind::MalformedPolicyDocumentException(_inner) => Some(_inner),
            CreatePolicyVersionErrorKind::NoSuchEntityException(_inner) => Some(_inner),
            CreatePolicyVersionErrorKind::ServiceFailureException(_inner) => Some(_inner),
            CreatePolicyVersionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateRoleError {
    pub kind: CreateRoleErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateRoleErrorKind {
    ConcurrentModificationException(crate::error::ConcurrentModificationException),
    EntityAlreadyExistsException(crate::error::EntityAlreadyExistsException),
    InvalidInputException(crate::error::InvalidInputException),
    LimitExceededException(crate::error::LimitExceededException),
    MalformedPolicyDocumentException(crate::error::MalformedPolicyDocumentException),
    ServiceFailureException(crate::error::ServiceFailureException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateRoleError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateRoleErrorKind::ConcurrentModificationException(_inner) => _inner.fmt(f),
            CreateRoleErrorKind::EntityAlreadyExistsException(_inner) => _inner.fmt(f),
            CreateRoleErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            CreateRoleErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            CreateRoleErrorKind::MalformedPolicyDocumentException(_inner) => _inner.fmt(f),
            CreateRoleErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            CreateRoleErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateRoleError {
    fn code(&self) -> Option<&str> {
        CreateRoleError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateRoleError {
    pub fn new(kind: CreateRoleErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateRoleErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateRoleErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_concurrent_modification_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateRoleErrorKind::ConcurrentModificationException(_)
        )
    }
    pub fn is_entity_already_exists_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateRoleErrorKind::EntityAlreadyExistsException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(&self.kind, CreateRoleErrorKind::InvalidInputException(_))
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(&self.kind, CreateRoleErrorKind::LimitExceededException(_))
    }
    pub fn is_malformed_policy_document_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateRoleErrorKind::MalformedPolicyDocumentException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(&self.kind, CreateRoleErrorKind::ServiceFailureException(_))
    }
}
impl std::error::Error for CreateRoleError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateRoleErrorKind::ConcurrentModificationException(_inner) => Some(_inner),
            CreateRoleErrorKind::EntityAlreadyExistsException(_inner) => Some(_inner),
            CreateRoleErrorKind::InvalidInputException(_inner) => Some(_inner),
            CreateRoleErrorKind::LimitExceededException(_inner) => Some(_inner),
            CreateRoleErrorKind::MalformedPolicyDocumentException(_inner) => Some(_inner),
            CreateRoleErrorKind::ServiceFailureException(_inner) => Some(_inner),
            CreateRoleErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateSAMLProviderError {
    pub kind: CreateSAMLProviderErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateSAMLProviderErrorKind {
    ConcurrentModificationException(crate::error::ConcurrentModificationException),
    EntityAlreadyExistsException(crate::error::EntityAlreadyExistsException),
    InvalidInputException(crate::error::InvalidInputException),
    LimitExceededException(crate::error::LimitExceededException),
    ServiceFailureException(crate::error::ServiceFailureException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateSAMLProviderError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateSAMLProviderErrorKind::ConcurrentModificationException(_inner) => _inner.fmt(f),
            CreateSAMLProviderErrorKind::EntityAlreadyExistsException(_inner) => _inner.fmt(f),
            CreateSAMLProviderErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            CreateSAMLProviderErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            CreateSAMLProviderErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            CreateSAMLProviderErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateSAMLProviderError {
    fn code(&self) -> Option<&str> {
        CreateSAMLProviderError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateSAMLProviderError {
    pub fn new(kind: CreateSAMLProviderErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateSAMLProviderErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateSAMLProviderErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_concurrent_modification_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateSAMLProviderErrorKind::ConcurrentModificationException(_)
        )
    }
    pub fn is_entity_already_exists_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateSAMLProviderErrorKind::EntityAlreadyExistsException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateSAMLProviderErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateSAMLProviderErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateSAMLProviderErrorKind::ServiceFailureException(_)
        )
    }
}
impl std::error::Error for CreateSAMLProviderError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateSAMLProviderErrorKind::ConcurrentModificationException(_inner) => Some(_inner),
            CreateSAMLProviderErrorKind::EntityAlreadyExistsException(_inner) => Some(_inner),
            CreateSAMLProviderErrorKind::InvalidInputException(_inner) => Some(_inner),
            CreateSAMLProviderErrorKind::LimitExceededException(_inner) => Some(_inner),
            CreateSAMLProviderErrorKind::ServiceFailureException(_inner) => Some(_inner),
            CreateSAMLProviderErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateServiceLinkedRoleError {
    pub kind: CreateServiceLinkedRoleErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateServiceLinkedRoleErrorKind {
    InvalidInputException(crate::error::InvalidInputException),
    LimitExceededException(crate::error::LimitExceededException),
    NoSuchEntityException(crate::error::NoSuchEntityException),
    ServiceFailureException(crate::error::ServiceFailureException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateServiceLinkedRoleError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateServiceLinkedRoleErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            CreateServiceLinkedRoleErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            CreateServiceLinkedRoleErrorKind::NoSuchEntityException(_inner) => _inner.fmt(f),
            CreateServiceLinkedRoleErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            CreateServiceLinkedRoleErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateServiceLinkedRoleError {
    fn code(&self) -> Option<&str> {
        CreateServiceLinkedRoleError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateServiceLinkedRoleError {
    pub fn new(kind: CreateServiceLinkedRoleErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateServiceLinkedRoleErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateServiceLinkedRoleErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateServiceLinkedRoleErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateServiceLinkedRoleErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_no_such_entity_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateServiceLinkedRoleErrorKind::NoSuchEntityException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateServiceLinkedRoleErrorKind::ServiceFailureException(_)
        )
    }
}
impl std::error::Error for CreateServiceLinkedRoleError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateServiceLinkedRoleErrorKind::InvalidInputException(_inner) => Some(_inner),
            CreateServiceLinkedRoleErrorKind::LimitExceededException(_inner) => Some(_inner),
            CreateServiceLinkedRoleErrorKind::NoSuchEntityException(_inner) => Some(_inner),
            CreateServiceLinkedRoleErrorKind::ServiceFailureException(_inner) => Some(_inner),
            CreateServiceLinkedRoleErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateServiceSpecificCredentialError {
    pub kind: CreateServiceSpecificCredentialErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateServiceSpecificCredentialErrorKind {
    LimitExceededException(crate::error::LimitExceededException),
    NoSuchEntityException(crate::error::NoSuchEntityException),
    ServiceNotSupportedException(crate::error::ServiceNotSupportedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateServiceSpecificCredentialError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateServiceSpecificCredentialErrorKind::LimitExceededException(_inner) => {
                _inner.fmt(f)
            }
            CreateServiceSpecificCredentialErrorKind::NoSuchEntityException(_inner) => {
                _inner.fmt(f)
            }
            CreateServiceSpecificCredentialErrorKind::ServiceNotSupportedException(_inner) => {
                _inner.fmt(f)
            }
            CreateServiceSpecificCredentialErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateServiceSpecificCredentialError {
    fn code(&self) -> Option<&str> {
        CreateServiceSpecificCredentialError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateServiceSpecificCredentialError {
    pub fn new(kind: CreateServiceSpecificCredentialErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateServiceSpecificCredentialErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateServiceSpecificCredentialErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateServiceSpecificCredentialErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_no_such_entity_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateServiceSpecificCredentialErrorKind::NoSuchEntityException(_)
        )
    }
    pub fn is_service_not_supported_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateServiceSpecificCredentialErrorKind::ServiceNotSupportedException(_)
        )
    }
}
impl std::error::Error for CreateServiceSpecificCredentialError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateServiceSpecificCredentialErrorKind::LimitExceededException(_inner) => {
                Some(_inner)
            }
            CreateServiceSpecificCredentialErrorKind::NoSuchEntityException(_inner) => Some(_inner),
            CreateServiceSpecificCredentialErrorKind::ServiceNotSupportedException(_inner) => {
                Some(_inner)
            }
            CreateServiceSpecificCredentialErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateUserError {
    pub kind: CreateUserErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateUserErrorKind {
    ConcurrentModificationException(crate::error::ConcurrentModificationException),
    EntityAlreadyExistsException(crate::error::EntityAlreadyExistsException),
    InvalidInputException(crate::error::InvalidInputException),
    LimitExceededException(crate::error::LimitExceededException),
    NoSuchEntityException(crate::error::NoSuchEntityException),
    ServiceFailureException(crate::error::ServiceFailureException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateUserError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateUserErrorKind::ConcurrentModificationException(_inner) => _inner.fmt(f),
            CreateUserErrorKind::EntityAlreadyExistsException(_inner) => _inner.fmt(f),
            CreateUserErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            CreateUserErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            CreateUserErrorKind::NoSuchEntityException(_inner) => _inner.fmt(f),
            CreateUserErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            CreateUserErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateUserError {
    fn code(&self) -> Option<&str> {
        CreateUserError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateUserError {
    pub fn new(kind: CreateUserErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateUserErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateUserErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_concurrent_modification_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateUserErrorKind::ConcurrentModificationException(_)
        )
    }
    pub fn is_entity_already_exists_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateUserErrorKind::EntityAlreadyExistsException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(&self.kind, CreateUserErrorKind::InvalidInputException(_))
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(&self.kind, CreateUserErrorKind::LimitExceededException(_))
    }
    pub fn is_no_such_entity_exception(&self) -> bool {
        matches!(&self.kind, CreateUserErrorKind::NoSuchEntityException(_))
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(&self.kind, CreateUserErrorKind::ServiceFailureException(_))
    }
}
impl std::error::Error for CreateUserError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateUserErrorKind::ConcurrentModificationException(_inner) => Some(_inner),
            CreateUserErrorKind::EntityAlreadyExistsException(_inner) => Some(_inner),
            CreateUserErrorKind::InvalidInputException(_inner) => Some(_inner),
            CreateUserErrorKind::LimitExceededException(_inner) => Some(_inner),
            CreateUserErrorKind::NoSuchEntityException(_inner) => Some(_inner),
            CreateUserErrorKind::ServiceFailureException(_inner) => Some(_inner),
            CreateUserErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateVirtualMFADeviceError {
    pub kind: CreateVirtualMFADeviceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateVirtualMFADeviceErrorKind {
    ConcurrentModificationException(crate::error::ConcurrentModificationException),
    EntityAlreadyExistsException(crate::error::EntityAlreadyExistsException),
    InvalidInputException(crate::error::InvalidInputException),
    LimitExceededException(crate::error::LimitExceededException),
    ServiceFailureException(crate::error::ServiceFailureException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateVirtualMFADeviceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateVirtualMFADeviceErrorKind::ConcurrentModificationException(_inner) => {
                _inner.fmt(f)
            }
            CreateVirtualMFADeviceErrorKind::EntityAlreadyExistsException(_inner) => _inner.fmt(f),
            CreateVirtualMFADeviceErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            CreateVirtualMFADeviceErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            CreateVirtualMFADeviceErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            CreateVirtualMFADeviceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateVirtualMFADeviceError {
    fn code(&self) -> Option<&str> {
        CreateVirtualMFADeviceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateVirtualMFADeviceError {
    pub fn new(kind: CreateVirtualMFADeviceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateVirtualMFADeviceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateVirtualMFADeviceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_concurrent_modification_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateVirtualMFADeviceErrorKind::ConcurrentModificationException(_)
        )
    }
    pub fn is_entity_already_exists_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateVirtualMFADeviceErrorKind::EntityAlreadyExistsException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateVirtualMFADeviceErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateVirtualMFADeviceErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateVirtualMFADeviceErrorKind::ServiceFailureException(_)
        )
    }
}
impl std::error::Error for CreateVirtualMFADeviceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateVirtualMFADeviceErrorKind::ConcurrentModificationException(_inner) => {
                Some(_inner)
            }
            CreateVirtualMFADeviceErrorKind::EntityAlreadyExistsException(_inner) => Some(_inner),
            CreateVirtualMFADeviceErrorKind::InvalidInputException(_inner) => Some(_inner),
            CreateVirtualMFADeviceErrorKind::LimitExceededException(_inner) => Some(_inner),
            CreateVirtualMFADeviceErrorKind::ServiceFailureException(_inner) => Some(_inner),
            CreateVirtualMFADeviceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeactivateMFADeviceError {
    pub kind: DeactivateMFADeviceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeactivateMFADeviceErrorKind {
    EntityTemporarilyUnmodifiableException(crate::error::EntityTemporarilyUnmodifiableException),
    LimitExceededException(crate::error::LimitExceededException),
    NoSuchEntityException(crate::error::NoSuchEntityException),
    ServiceFailureException(crate::error::ServiceFailureException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeactivateMFADeviceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeactivateMFADeviceErrorKind::EntityTemporarilyUnmodifiableException(_inner) => {
                _inner.fmt(f)
            }
            DeactivateMFADeviceErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            DeactivateMFADeviceErrorKind::NoSuchEntityException(_inner) => _inner.fmt(f),
            DeactivateMFADeviceErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            DeactivateMFADeviceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeactivateMFADeviceError {
    fn code(&self) -> Option<&str> {
        DeactivateMFADeviceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeactivateMFADeviceError {
    pub fn new(kind: DeactivateMFADeviceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeactivateMFADeviceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeactivateMFADeviceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_entity_temporarily_unmodifiable_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeactivateMFADeviceErrorKind::EntityTemporarilyUnmodifiableException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeactivateMFADeviceErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_no_such_entity_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeactivateMFADeviceErrorKind::NoSuchEntityException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeactivateMFADeviceErrorKind::ServiceFailureException(_)
        )
    }
}
impl std::error::Error for DeactivateMFADeviceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeactivateMFADeviceErrorKind::EntityTemporarilyUnmodifiableException(_inner) => {
                Some(_inner)
            }
            DeactivateMFADeviceErrorKind::LimitExceededException(_inner) => Some(_inner),
            DeactivateMFADeviceErrorKind::NoSuchEntityException(_inner) => Some(_inner),
            DeactivateMFADeviceErrorKind::ServiceFailureException(_inner) => Some(_inner),
            DeactivateMFADeviceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteAccessKeyError {
    pub kind: DeleteAccessKeyErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteAccessKeyErrorKind {
    LimitExceededException(crate::error::LimitExceededException),
    NoSuchEntityException(crate::error::NoSuchEntityException),
    ServiceFailureException(crate::error::ServiceFailureException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteAccessKeyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteAccessKeyErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            DeleteAccessKeyErrorKind::NoSuchEntityException(_inner) => _inner.fmt(f),
            DeleteAccessKeyErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            DeleteAccessKeyErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteAccessKeyError {
    fn code(&self) -> Option<&str> {
        DeleteAccessKeyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteAccessKeyError {
    pub fn new(kind: DeleteAccessKeyErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteAccessKeyErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteAccessKeyErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteAccessKeyErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_no_such_entity_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteAccessKeyErrorKind::NoSuchEntityException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteAccessKeyErrorKind::ServiceFailureException(_)
        )
    }
}
impl std::error::Error for DeleteAccessKeyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteAccessKeyErrorKind::LimitExceededException(_inner) => Some(_inner),
            DeleteAccessKeyErrorKind::NoSuchEntityException(_inner) => Some(_inner),
            DeleteAccessKeyErrorKind::ServiceFailureException(_inner) => Some(_inner),
            DeleteAccessKeyErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteAccountAliasError {
    pub kind: DeleteAccountAliasErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteAccountAliasErrorKind {
    LimitExceededException(crate::error::LimitExceededException),
    NoSuchEntityException(crate::error::NoSuchEntityException),
    ServiceFailureException(crate::error::ServiceFailureException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteAccountAliasError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteAccountAliasErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            DeleteAccountAliasErrorKind::NoSuchEntityException(_inner) => _inner.fmt(f),
            DeleteAccountAliasErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            DeleteAccountAliasErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteAccountAliasError {
    fn code(&self) -> Option<&str> {
        DeleteAccountAliasError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteAccountAliasError {
    pub fn new(kind: DeleteAccountAliasErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteAccountAliasErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteAccountAliasErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteAccountAliasErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_no_such_entity_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteAccountAliasErrorKind::NoSuchEntityException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteAccountAliasErrorKind::ServiceFailureException(_)
        )
    }
}
impl std::error::Error for DeleteAccountAliasError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteAccountAliasErrorKind::LimitExceededException(_inner) => Some(_inner),
            DeleteAccountAliasErrorKind::NoSuchEntityException(_inner) => Some(_inner),
            DeleteAccountAliasErrorKind::ServiceFailureException(_inner) => Some(_inner),
            DeleteAccountAliasErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteAccountPasswordPolicyError {
    pub kind: DeleteAccountPasswordPolicyErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteAccountPasswordPolicyErrorKind {
    LimitExceededException(crate::error::LimitExceededException),
    NoSuchEntityException(crate::error::NoSuchEntityException),
    ServiceFailureException(crate::error::ServiceFailureException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteAccountPasswordPolicyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteAccountPasswordPolicyErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            DeleteAccountPasswordPolicyErrorKind::NoSuchEntityException(_inner) => _inner.fmt(f),
            DeleteAccountPasswordPolicyErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            DeleteAccountPasswordPolicyErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteAccountPasswordPolicyError {
    fn code(&self) -> Option<&str> {
        DeleteAccountPasswordPolicyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteAccountPasswordPolicyError {
    pub fn new(kind: DeleteAccountPasswordPolicyErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteAccountPasswordPolicyErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteAccountPasswordPolicyErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteAccountPasswordPolicyErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_no_such_entity_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteAccountPasswordPolicyErrorKind::NoSuchEntityException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteAccountPasswordPolicyErrorKind::ServiceFailureException(_)
        )
    }
}
impl std::error::Error for DeleteAccountPasswordPolicyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteAccountPasswordPolicyErrorKind::LimitExceededException(_inner) => Some(_inner),
            DeleteAccountPasswordPolicyErrorKind::NoSuchEntityException(_inner) => Some(_inner),
            DeleteAccountPasswordPolicyErrorKind::ServiceFailureException(_inner) => Some(_inner),
            DeleteAccountPasswordPolicyErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteGroupError {
    pub kind: DeleteGroupErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteGroupErrorKind {
    DeleteConflictException(crate::error::DeleteConflictException),
    LimitExceededException(crate::error::LimitExceededException),
    NoSuchEntityException(crate::error::NoSuchEntityException),
    ServiceFailureException(crate::error::ServiceFailureException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteGroupError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteGroupErrorKind::DeleteConflictException(_inner) => _inner.fmt(f),
            DeleteGroupErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            DeleteGroupErrorKind::NoSuchEntityException(_inner) => _inner.fmt(f),
            DeleteGroupErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            DeleteGroupErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteGroupError {
    fn code(&self) -> Option<&str> {
        DeleteGroupError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteGroupError {
    pub fn new(kind: DeleteGroupErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteGroupErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteGroupErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_delete_conflict_exception(&self) -> bool {
        matches!(&self.kind, DeleteGroupErrorKind::DeleteConflictException(_))
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(&self.kind, DeleteGroupErrorKind::LimitExceededException(_))
    }
    pub fn is_no_such_entity_exception(&self) -> bool {
        matches!(&self.kind, DeleteGroupErrorKind::NoSuchEntityException(_))
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(&self.kind, DeleteGroupErrorKind::ServiceFailureException(_))
    }
}
impl std::error::Error for DeleteGroupError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteGroupErrorKind::DeleteConflictException(_inner) => Some(_inner),
            DeleteGroupErrorKind::LimitExceededException(_inner) => Some(_inner),
            DeleteGroupErrorKind::NoSuchEntityException(_inner) => Some(_inner),
            DeleteGroupErrorKind::ServiceFailureException(_inner) => Some(_inner),
            DeleteGroupErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteGroupPolicyError {
    pub kind: DeleteGroupPolicyErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteGroupPolicyErrorKind {
    LimitExceededException(crate::error::LimitExceededException),
    NoSuchEntityException(crate::error::NoSuchEntityException),
    ServiceFailureException(crate::error::ServiceFailureException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteGroupPolicyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteGroupPolicyErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            DeleteGroupPolicyErrorKind::NoSuchEntityException(_inner) => _inner.fmt(f),
            DeleteGroupPolicyErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            DeleteGroupPolicyErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteGroupPolicyError {
    fn code(&self) -> Option<&str> {
        DeleteGroupPolicyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteGroupPolicyError {
    pub fn new(kind: DeleteGroupPolicyErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteGroupPolicyErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteGroupPolicyErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteGroupPolicyErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_no_such_entity_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteGroupPolicyErrorKind::NoSuchEntityException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteGroupPolicyErrorKind::ServiceFailureException(_)
        )
    }
}
impl std::error::Error for DeleteGroupPolicyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteGroupPolicyErrorKind::LimitExceededException(_inner) => Some(_inner),
            DeleteGroupPolicyErrorKind::NoSuchEntityException(_inner) => Some(_inner),
            DeleteGroupPolicyErrorKind::ServiceFailureException(_inner) => Some(_inner),
            DeleteGroupPolicyErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteInstanceProfileError {
    pub kind: DeleteInstanceProfileErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteInstanceProfileErrorKind {
    DeleteConflictException(crate::error::DeleteConflictException),
    LimitExceededException(crate::error::LimitExceededException),
    NoSuchEntityException(crate::error::NoSuchEntityException),
    ServiceFailureException(crate::error::ServiceFailureException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteInstanceProfileError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteInstanceProfileErrorKind::DeleteConflictException(_inner) => _inner.fmt(f),
            DeleteInstanceProfileErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            DeleteInstanceProfileErrorKind::NoSuchEntityException(_inner) => _inner.fmt(f),
            DeleteInstanceProfileErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            DeleteInstanceProfileErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteInstanceProfileError {
    fn code(&self) -> Option<&str> {
        DeleteInstanceProfileError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteInstanceProfileError {
    pub fn new(kind: DeleteInstanceProfileErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteInstanceProfileErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteInstanceProfileErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_delete_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteInstanceProfileErrorKind::DeleteConflictException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteInstanceProfileErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_no_such_entity_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteInstanceProfileErrorKind::NoSuchEntityException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteInstanceProfileErrorKind::ServiceFailureException(_)
        )
    }
}
impl std::error::Error for DeleteInstanceProfileError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteInstanceProfileErrorKind::DeleteConflictException(_inner) => Some(_inner),
            DeleteInstanceProfileErrorKind::LimitExceededException(_inner) => Some(_inner),
            DeleteInstanceProfileErrorKind::NoSuchEntityException(_inner) => Some(_inner),
            DeleteInstanceProfileErrorKind::ServiceFailureException(_inner) => Some(_inner),
            DeleteInstanceProfileErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteLoginProfileError {
    pub kind: DeleteLoginProfileErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteLoginProfileErrorKind {
    EntityTemporarilyUnmodifiableException(crate::error::EntityTemporarilyUnmodifiableException),
    LimitExceededException(crate::error::LimitExceededException),
    NoSuchEntityException(crate::error::NoSuchEntityException),
    ServiceFailureException(crate::error::ServiceFailureException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteLoginProfileError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteLoginProfileErrorKind::EntityTemporarilyUnmodifiableException(_inner) => {
                _inner.fmt(f)
            }
            DeleteLoginProfileErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            DeleteLoginProfileErrorKind::NoSuchEntityException(_inner) => _inner.fmt(f),
            DeleteLoginProfileErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            DeleteLoginProfileErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteLoginProfileError {
    fn code(&self) -> Option<&str> {
        DeleteLoginProfileError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteLoginProfileError {
    pub fn new(kind: DeleteLoginProfileErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteLoginProfileErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteLoginProfileErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_entity_temporarily_unmodifiable_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteLoginProfileErrorKind::EntityTemporarilyUnmodifiableException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteLoginProfileErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_no_such_entity_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteLoginProfileErrorKind::NoSuchEntityException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteLoginProfileErrorKind::ServiceFailureException(_)
        )
    }
}
impl std::error::Error for DeleteLoginProfileError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteLoginProfileErrorKind::EntityTemporarilyUnmodifiableException(_inner) => {
                Some(_inner)
            }
            DeleteLoginProfileErrorKind::LimitExceededException(_inner) => Some(_inner),
            DeleteLoginProfileErrorKind::NoSuchEntityException(_inner) => Some(_inner),
            DeleteLoginProfileErrorKind::ServiceFailureException(_inner) => Some(_inner),
            DeleteLoginProfileErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteOpenIDConnectProviderError {
    pub kind: DeleteOpenIDConnectProviderErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteOpenIDConnectProviderErrorKind {
    InvalidInputException(crate::error::InvalidInputException),
    NoSuchEntityException(crate::error::NoSuchEntityException),
    ServiceFailureException(crate::error::ServiceFailureException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteOpenIDConnectProviderError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteOpenIDConnectProviderErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            DeleteOpenIDConnectProviderErrorKind::NoSuchEntityException(_inner) => _inner.fmt(f),
            DeleteOpenIDConnectProviderErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            DeleteOpenIDConnectProviderErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteOpenIDConnectProviderError {
    fn code(&self) -> Option<&str> {
        DeleteOpenIDConnectProviderError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteOpenIDConnectProviderError {
    pub fn new(kind: DeleteOpenIDConnectProviderErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteOpenIDConnectProviderErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteOpenIDConnectProviderErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteOpenIDConnectProviderErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_no_such_entity_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteOpenIDConnectProviderErrorKind::NoSuchEntityException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteOpenIDConnectProviderErrorKind::ServiceFailureException(_)
        )
    }
}
impl std::error::Error for DeleteOpenIDConnectProviderError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteOpenIDConnectProviderErrorKind::InvalidInputException(_inner) => Some(_inner),
            DeleteOpenIDConnectProviderErrorKind::NoSuchEntityException(_inner) => Some(_inner),
            DeleteOpenIDConnectProviderErrorKind::ServiceFailureException(_inner) => Some(_inner),
            DeleteOpenIDConnectProviderErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeletePolicyError {
    pub kind: DeletePolicyErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeletePolicyErrorKind {
    DeleteConflictException(crate::error::DeleteConflictException),
    InvalidInputException(crate::error::InvalidInputException),
    LimitExceededException(crate::error::LimitExceededException),
    NoSuchEntityException(crate::error::NoSuchEntityException),
    ServiceFailureException(crate::error::ServiceFailureException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeletePolicyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeletePolicyErrorKind::DeleteConflictException(_inner) => _inner.fmt(f),
            DeletePolicyErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            DeletePolicyErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            DeletePolicyErrorKind::NoSuchEntityException(_inner) => _inner.fmt(f),
            DeletePolicyErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            DeletePolicyErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeletePolicyError {
    fn code(&self) -> Option<&str> {
        DeletePolicyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeletePolicyError {
    pub fn new(kind: DeletePolicyErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeletePolicyErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeletePolicyErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_delete_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeletePolicyErrorKind::DeleteConflictException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(&self.kind, DeletePolicyErrorKind::InvalidInputException(_))
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(&self.kind, DeletePolicyErrorKind::LimitExceededException(_))
    }
    pub fn is_no_such_entity_exception(&self) -> bool {
        matches!(&self.kind, DeletePolicyErrorKind::NoSuchEntityException(_))
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeletePolicyErrorKind::ServiceFailureException(_)
        )
    }
}
impl std::error::Error for DeletePolicyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeletePolicyErrorKind::DeleteConflictException(_inner) => Some(_inner),
            DeletePolicyErrorKind::InvalidInputException(_inner) => Some(_inner),
            DeletePolicyErrorKind::LimitExceededException(_inner) => Some(_inner),
            DeletePolicyErrorKind::NoSuchEntityException(_inner) => Some(_inner),
            DeletePolicyErrorKind::ServiceFailureException(_inner) => Some(_inner),
            DeletePolicyErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeletePolicyVersionError {
    pub kind: DeletePolicyVersionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeletePolicyVersionErrorKind {
    DeleteConflictException(crate::error::DeleteConflictException),
    InvalidInputException(crate::error::InvalidInputException),
    LimitExceededException(crate::error::LimitExceededException),
    NoSuchEntityException(crate::error::NoSuchEntityException),
    ServiceFailureException(crate::error::ServiceFailureException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeletePolicyVersionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeletePolicyVersionErrorKind::DeleteConflictException(_inner) => _inner.fmt(f),
            DeletePolicyVersionErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            DeletePolicyVersionErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            DeletePolicyVersionErrorKind::NoSuchEntityException(_inner) => _inner.fmt(f),
            DeletePolicyVersionErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            DeletePolicyVersionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeletePolicyVersionError {
    fn code(&self) -> Option<&str> {
        DeletePolicyVersionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeletePolicyVersionError {
    pub fn new(kind: DeletePolicyVersionErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeletePolicyVersionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeletePolicyVersionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_delete_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeletePolicyVersionErrorKind::DeleteConflictException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeletePolicyVersionErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeletePolicyVersionErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_no_such_entity_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeletePolicyVersionErrorKind::NoSuchEntityException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeletePolicyVersionErrorKind::ServiceFailureException(_)
        )
    }
}
impl std::error::Error for DeletePolicyVersionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeletePolicyVersionErrorKind::DeleteConflictException(_inner) => Some(_inner),
            DeletePolicyVersionErrorKind::InvalidInputException(_inner) => Some(_inner),
            DeletePolicyVersionErrorKind::LimitExceededException(_inner) => Some(_inner),
            DeletePolicyVersionErrorKind::NoSuchEntityException(_inner) => Some(_inner),
            DeletePolicyVersionErrorKind::ServiceFailureException(_inner) => Some(_inner),
            DeletePolicyVersionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteRoleError {
    pub kind: DeleteRoleErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteRoleErrorKind {
    ConcurrentModificationException(crate::error::ConcurrentModificationException),
    DeleteConflictException(crate::error::DeleteConflictException),
    LimitExceededException(crate::error::LimitExceededException),
    NoSuchEntityException(crate::error::NoSuchEntityException),
    ServiceFailureException(crate::error::ServiceFailureException),
    UnmodifiableEntityException(crate::error::UnmodifiableEntityException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteRoleError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteRoleErrorKind::ConcurrentModificationException(_inner) => _inner.fmt(f),
            DeleteRoleErrorKind::DeleteConflictException(_inner) => _inner.fmt(f),
            DeleteRoleErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            DeleteRoleErrorKind::NoSuchEntityException(_inner) => _inner.fmt(f),
            DeleteRoleErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            DeleteRoleErrorKind::UnmodifiableEntityException(_inner) => _inner.fmt(f),
            DeleteRoleErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteRoleError {
    fn code(&self) -> Option<&str> {
        DeleteRoleError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteRoleError {
    pub fn new(kind: DeleteRoleErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteRoleErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteRoleErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_concurrent_modification_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteRoleErrorKind::ConcurrentModificationException(_)
        )
    }
    pub fn is_delete_conflict_exception(&self) -> bool {
        matches!(&self.kind, DeleteRoleErrorKind::DeleteConflictException(_))
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(&self.kind, DeleteRoleErrorKind::LimitExceededException(_))
    }
    pub fn is_no_such_entity_exception(&self) -> bool {
        matches!(&self.kind, DeleteRoleErrorKind::NoSuchEntityException(_))
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(&self.kind, DeleteRoleErrorKind::ServiceFailureException(_))
    }
    pub fn is_unmodifiable_entity_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteRoleErrorKind::UnmodifiableEntityException(_)
        )
    }
}
impl std::error::Error for DeleteRoleError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteRoleErrorKind::ConcurrentModificationException(_inner) => Some(_inner),
            DeleteRoleErrorKind::DeleteConflictException(_inner) => Some(_inner),
            DeleteRoleErrorKind::LimitExceededException(_inner) => Some(_inner),
            DeleteRoleErrorKind::NoSuchEntityException(_inner) => Some(_inner),
            DeleteRoleErrorKind::ServiceFailureException(_inner) => Some(_inner),
            DeleteRoleErrorKind::UnmodifiableEntityException(_inner) => Some(_inner),
            DeleteRoleErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteRolePermissionsBoundaryError {
    pub kind: DeleteRolePermissionsBoundaryErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteRolePermissionsBoundaryErrorKind {
    NoSuchEntityException(crate::error::NoSuchEntityException),
    ServiceFailureException(crate::error::ServiceFailureException),
    UnmodifiableEntityException(crate::error::UnmodifiableEntityException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteRolePermissionsBoundaryError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteRolePermissionsBoundaryErrorKind::NoSuchEntityException(_inner) => _inner.fmt(f),
            DeleteRolePermissionsBoundaryErrorKind::ServiceFailureException(_inner) => {
                _inner.fmt(f)
            }
            DeleteRolePermissionsBoundaryErrorKind::UnmodifiableEntityException(_inner) => {
                _inner.fmt(f)
            }
            DeleteRolePermissionsBoundaryErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteRolePermissionsBoundaryError {
    fn code(&self) -> Option<&str> {
        DeleteRolePermissionsBoundaryError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteRolePermissionsBoundaryError {
    pub fn new(kind: DeleteRolePermissionsBoundaryErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteRolePermissionsBoundaryErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteRolePermissionsBoundaryErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_no_such_entity_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteRolePermissionsBoundaryErrorKind::NoSuchEntityException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteRolePermissionsBoundaryErrorKind::ServiceFailureException(_)
        )
    }
    pub fn is_unmodifiable_entity_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteRolePermissionsBoundaryErrorKind::UnmodifiableEntityException(_)
        )
    }
}
impl std::error::Error for DeleteRolePermissionsBoundaryError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteRolePermissionsBoundaryErrorKind::NoSuchEntityException(_inner) => Some(_inner),
            DeleteRolePermissionsBoundaryErrorKind::ServiceFailureException(_inner) => Some(_inner),
            DeleteRolePermissionsBoundaryErrorKind::UnmodifiableEntityException(_inner) => {
                Some(_inner)
            }
            DeleteRolePermissionsBoundaryErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteRolePolicyError {
    pub kind: DeleteRolePolicyErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteRolePolicyErrorKind {
    LimitExceededException(crate::error::LimitExceededException),
    NoSuchEntityException(crate::error::NoSuchEntityException),
    ServiceFailureException(crate::error::ServiceFailureException),
    UnmodifiableEntityException(crate::error::UnmodifiableEntityException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteRolePolicyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteRolePolicyErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            DeleteRolePolicyErrorKind::NoSuchEntityException(_inner) => _inner.fmt(f),
            DeleteRolePolicyErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            DeleteRolePolicyErrorKind::UnmodifiableEntityException(_inner) => _inner.fmt(f),
            DeleteRolePolicyErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteRolePolicyError {
    fn code(&self) -> Option<&str> {
        DeleteRolePolicyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteRolePolicyError {
    pub fn new(kind: DeleteRolePolicyErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteRolePolicyErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteRolePolicyErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteRolePolicyErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_no_such_entity_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteRolePolicyErrorKind::NoSuchEntityException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteRolePolicyErrorKind::ServiceFailureException(_)
        )
    }
    pub fn is_unmodifiable_entity_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteRolePolicyErrorKind::UnmodifiableEntityException(_)
        )
    }
}
impl std::error::Error for DeleteRolePolicyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteRolePolicyErrorKind::LimitExceededException(_inner) => Some(_inner),
            DeleteRolePolicyErrorKind::NoSuchEntityException(_inner) => Some(_inner),
            DeleteRolePolicyErrorKind::ServiceFailureException(_inner) => Some(_inner),
            DeleteRolePolicyErrorKind::UnmodifiableEntityException(_inner) => Some(_inner),
            DeleteRolePolicyErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteSAMLProviderError {
    pub kind: DeleteSAMLProviderErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteSAMLProviderErrorKind {
    InvalidInputException(crate::error::InvalidInputException),
    LimitExceededException(crate::error::LimitExceededException),
    NoSuchEntityException(crate::error::NoSuchEntityException),
    ServiceFailureException(crate::error::ServiceFailureException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteSAMLProviderError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteSAMLProviderErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            DeleteSAMLProviderErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            DeleteSAMLProviderErrorKind::NoSuchEntityException(_inner) => _inner.fmt(f),
            DeleteSAMLProviderErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            DeleteSAMLProviderErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteSAMLProviderError {
    fn code(&self) -> Option<&str> {
        DeleteSAMLProviderError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteSAMLProviderError {
    pub fn new(kind: DeleteSAMLProviderErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteSAMLProviderErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteSAMLProviderErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteSAMLProviderErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteSAMLProviderErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_no_such_entity_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteSAMLProviderErrorKind::NoSuchEntityException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteSAMLProviderErrorKind::ServiceFailureException(_)
        )
    }
}
impl std::error::Error for DeleteSAMLProviderError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteSAMLProviderErrorKind::InvalidInputException(_inner) => Some(_inner),
            DeleteSAMLProviderErrorKind::LimitExceededException(_inner) => Some(_inner),
            DeleteSAMLProviderErrorKind::NoSuchEntityException(_inner) => Some(_inner),
            DeleteSAMLProviderErrorKind::ServiceFailureException(_inner) => Some(_inner),
            DeleteSAMLProviderErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteServerCertificateError {
    pub kind: DeleteServerCertificateErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteServerCertificateErrorKind {
    DeleteConflictException(crate::error::DeleteConflictException),
    LimitExceededException(crate::error::LimitExceededException),
    NoSuchEntityException(crate::error::NoSuchEntityException),
    ServiceFailureException(crate::error::ServiceFailureException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteServerCertificateError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteServerCertificateErrorKind::DeleteConflictException(_inner) => _inner.fmt(f),
            DeleteServerCertificateErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            DeleteServerCertificateErrorKind::NoSuchEntityException(_inner) => _inner.fmt(f),
            DeleteServerCertificateErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            DeleteServerCertificateErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteServerCertificateError {
    fn code(&self) -> Option<&str> {
        DeleteServerCertificateError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteServerCertificateError {
    pub fn new(kind: DeleteServerCertificateErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteServerCertificateErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteServerCertificateErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_delete_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteServerCertificateErrorKind::DeleteConflictException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteServerCertificateErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_no_such_entity_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteServerCertificateErrorKind::NoSuchEntityException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteServerCertificateErrorKind::ServiceFailureException(_)
        )
    }
}
impl std::error::Error for DeleteServerCertificateError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteServerCertificateErrorKind::DeleteConflictException(_inner) => Some(_inner),
            DeleteServerCertificateErrorKind::LimitExceededException(_inner) => Some(_inner),
            DeleteServerCertificateErrorKind::NoSuchEntityException(_inner) => Some(_inner),
            DeleteServerCertificateErrorKind::ServiceFailureException(_inner) => Some(_inner),
            DeleteServerCertificateErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteServiceLinkedRoleError {
    pub kind: DeleteServiceLinkedRoleErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteServiceLinkedRoleErrorKind {
    LimitExceededException(crate::error::LimitExceededException),
    NoSuchEntityException(crate::error::NoSuchEntityException),
    ServiceFailureException(crate::error::ServiceFailureException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteServiceLinkedRoleError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteServiceLinkedRoleErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            DeleteServiceLinkedRoleErrorKind::NoSuchEntityException(_inner) => _inner.fmt(f),
            DeleteServiceLinkedRoleErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            DeleteServiceLinkedRoleErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteServiceLinkedRoleError {
    fn code(&self) -> Option<&str> {
        DeleteServiceLinkedRoleError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteServiceLinkedRoleError {
    pub fn new(kind: DeleteServiceLinkedRoleErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteServiceLinkedRoleErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteServiceLinkedRoleErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteServiceLinkedRoleErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_no_such_entity_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteServiceLinkedRoleErrorKind::NoSuchEntityException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteServiceLinkedRoleErrorKind::ServiceFailureException(_)
        )
    }
}
impl std::error::Error for DeleteServiceLinkedRoleError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteServiceLinkedRoleErrorKind::LimitExceededException(_inner) => Some(_inner),
            DeleteServiceLinkedRoleErrorKind::NoSuchEntityException(_inner) => Some(_inner),
            DeleteServiceLinkedRoleErrorKind::ServiceFailureException(_inner) => Some(_inner),
            DeleteServiceLinkedRoleErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteServiceSpecificCredentialError {
    pub kind: DeleteServiceSpecificCredentialErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteServiceSpecificCredentialErrorKind {
    NoSuchEntityException(crate::error::NoSuchEntityException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteServiceSpecificCredentialError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteServiceSpecificCredentialErrorKind::NoSuchEntityException(_inner) => {
                _inner.fmt(f)
            }
            DeleteServiceSpecificCredentialErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteServiceSpecificCredentialError {
    fn code(&self) -> Option<&str> {
        DeleteServiceSpecificCredentialError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteServiceSpecificCredentialError {
    pub fn new(kind: DeleteServiceSpecificCredentialErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteServiceSpecificCredentialErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteServiceSpecificCredentialErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_no_such_entity_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteServiceSpecificCredentialErrorKind::NoSuchEntityException(_)
        )
    }
}
impl std::error::Error for DeleteServiceSpecificCredentialError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteServiceSpecificCredentialErrorKind::NoSuchEntityException(_inner) => Some(_inner),
            DeleteServiceSpecificCredentialErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteSigningCertificateError {
    pub kind: DeleteSigningCertificateErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteSigningCertificateErrorKind {
    LimitExceededException(crate::error::LimitExceededException),
    NoSuchEntityException(crate::error::NoSuchEntityException),
    ServiceFailureException(crate::error::ServiceFailureException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteSigningCertificateError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteSigningCertificateErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            DeleteSigningCertificateErrorKind::NoSuchEntityException(_inner) => _inner.fmt(f),
            DeleteSigningCertificateErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            DeleteSigningCertificateErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteSigningCertificateError {
    fn code(&self) -> Option<&str> {
        DeleteSigningCertificateError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteSigningCertificateError {
    pub fn new(kind: DeleteSigningCertificateErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteSigningCertificateErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteSigningCertificateErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteSigningCertificateErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_no_such_entity_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteSigningCertificateErrorKind::NoSuchEntityException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteSigningCertificateErrorKind::ServiceFailureException(_)
        )
    }
}
impl std::error::Error for DeleteSigningCertificateError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteSigningCertificateErrorKind::LimitExceededException(_inner) => Some(_inner),
            DeleteSigningCertificateErrorKind::NoSuchEntityException(_inner) => Some(_inner),
            DeleteSigningCertificateErrorKind::ServiceFailureException(_inner) => Some(_inner),
            DeleteSigningCertificateErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteSSHPublicKeyError {
    pub kind: DeleteSSHPublicKeyErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteSSHPublicKeyErrorKind {
    NoSuchEntityException(crate::error::NoSuchEntityException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteSSHPublicKeyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteSSHPublicKeyErrorKind::NoSuchEntityException(_inner) => _inner.fmt(f),
            DeleteSSHPublicKeyErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteSSHPublicKeyError {
    fn code(&self) -> Option<&str> {
        DeleteSSHPublicKeyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteSSHPublicKeyError {
    pub fn new(kind: DeleteSSHPublicKeyErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteSSHPublicKeyErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteSSHPublicKeyErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_no_such_entity_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteSSHPublicKeyErrorKind::NoSuchEntityException(_)
        )
    }
}
impl std::error::Error for DeleteSSHPublicKeyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteSSHPublicKeyErrorKind::NoSuchEntityException(_inner) => Some(_inner),
            DeleteSSHPublicKeyErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteUserError {
    pub kind: DeleteUserErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteUserErrorKind {
    ConcurrentModificationException(crate::error::ConcurrentModificationException),
    DeleteConflictException(crate::error::DeleteConflictException),
    LimitExceededException(crate::error::LimitExceededException),
    NoSuchEntityException(crate::error::NoSuchEntityException),
    ServiceFailureException(crate::error::ServiceFailureException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteUserError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteUserErrorKind::ConcurrentModificationException(_inner) => _inner.fmt(f),
            DeleteUserErrorKind::DeleteConflictException(_inner) => _inner.fmt(f),
            DeleteUserErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            DeleteUserErrorKind::NoSuchEntityException(_inner) => _inner.fmt(f),
            DeleteUserErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            DeleteUserErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteUserError {
    fn code(&self) -> Option<&str> {
        DeleteUserError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteUserError {
    pub fn new(kind: DeleteUserErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteUserErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteUserErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_concurrent_modification_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteUserErrorKind::ConcurrentModificationException(_)
        )
    }
    pub fn is_delete_conflict_exception(&self) -> bool {
        matches!(&self.kind, DeleteUserErrorKind::DeleteConflictException(_))
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(&self.kind, DeleteUserErrorKind::LimitExceededException(_))
    }
    pub fn is_no_such_entity_exception(&self) -> bool {
        matches!(&self.kind, DeleteUserErrorKind::NoSuchEntityException(_))
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(&self.kind, DeleteUserErrorKind::ServiceFailureException(_))
    }
}
impl std::error::Error for DeleteUserError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteUserErrorKind::ConcurrentModificationException(_inner) => Some(_inner),
            DeleteUserErrorKind::DeleteConflictException(_inner) => Some(_inner),
            DeleteUserErrorKind::LimitExceededException(_inner) => Some(_inner),
            DeleteUserErrorKind::NoSuchEntityException(_inner) => Some(_inner),
            DeleteUserErrorKind::ServiceFailureException(_inner) => Some(_inner),
            DeleteUserErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteUserPermissionsBoundaryError {
    pub kind: DeleteUserPermissionsBoundaryErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteUserPermissionsBoundaryErrorKind {
    NoSuchEntityException(crate::error::NoSuchEntityException),
    ServiceFailureException(crate::error::ServiceFailureException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteUserPermissionsBoundaryError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteUserPermissionsBoundaryErrorKind::NoSuchEntityException(_inner) => _inner.fmt(f),
            DeleteUserPermissionsBoundaryErrorKind::ServiceFailureException(_inner) => {
                _inner.fmt(f)
            }
            DeleteUserPermissionsBoundaryErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteUserPermissionsBoundaryError {
    fn code(&self) -> Option<&str> {
        DeleteUserPermissionsBoundaryError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteUserPermissionsBoundaryError {
    pub fn new(kind: DeleteUserPermissionsBoundaryErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteUserPermissionsBoundaryErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteUserPermissionsBoundaryErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_no_such_entity_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteUserPermissionsBoundaryErrorKind::NoSuchEntityException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteUserPermissionsBoundaryErrorKind::ServiceFailureException(_)
        )
    }
}
impl std::error::Error for DeleteUserPermissionsBoundaryError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteUserPermissionsBoundaryErrorKind::NoSuchEntityException(_inner) => Some(_inner),
            DeleteUserPermissionsBoundaryErrorKind::ServiceFailureException(_inner) => Some(_inner),
            DeleteUserPermissionsBoundaryErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteUserPolicyError {
    pub kind: DeleteUserPolicyErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteUserPolicyErrorKind {
    LimitExceededException(crate::error::LimitExceededException),
    NoSuchEntityException(crate::error::NoSuchEntityException),
    ServiceFailureException(crate::error::ServiceFailureException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteUserPolicyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteUserPolicyErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            DeleteUserPolicyErrorKind::NoSuchEntityException(_inner) => _inner.fmt(f),
            DeleteUserPolicyErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            DeleteUserPolicyErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteUserPolicyError {
    fn code(&self) -> Option<&str> {
        DeleteUserPolicyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteUserPolicyError {
    pub fn new(kind: DeleteUserPolicyErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteUserPolicyErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteUserPolicyErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteUserPolicyErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_no_such_entity_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteUserPolicyErrorKind::NoSuchEntityException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteUserPolicyErrorKind::ServiceFailureException(_)
        )
    }
}
impl std::error::Error for DeleteUserPolicyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteUserPolicyErrorKind::LimitExceededException(_inner) => Some(_inner),
            DeleteUserPolicyErrorKind::NoSuchEntityException(_inner) => Some(_inner),
            DeleteUserPolicyErrorKind::ServiceFailureException(_inner) => Some(_inner),
            DeleteUserPolicyErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteVirtualMFADeviceError {
    pub kind: DeleteVirtualMFADeviceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteVirtualMFADeviceErrorKind {
    DeleteConflictException(crate::error::DeleteConflictException),
    LimitExceededException(crate::error::LimitExceededException),
    NoSuchEntityException(crate::error::NoSuchEntityException),
    ServiceFailureException(crate::error::ServiceFailureException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteVirtualMFADeviceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteVirtualMFADeviceErrorKind::DeleteConflictException(_inner) => _inner.fmt(f),
            DeleteVirtualMFADeviceErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            DeleteVirtualMFADeviceErrorKind::NoSuchEntityException(_inner) => _inner.fmt(f),
            DeleteVirtualMFADeviceErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            DeleteVirtualMFADeviceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteVirtualMFADeviceError {
    fn code(&self) -> Option<&str> {
        DeleteVirtualMFADeviceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteVirtualMFADeviceError {
    pub fn new(kind: DeleteVirtualMFADeviceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteVirtualMFADeviceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteVirtualMFADeviceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_delete_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteVirtualMFADeviceErrorKind::DeleteConflictException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteVirtualMFADeviceErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_no_such_entity_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteVirtualMFADeviceErrorKind::NoSuchEntityException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteVirtualMFADeviceErrorKind::ServiceFailureException(_)
        )
    }
}
impl std::error::Error for DeleteVirtualMFADeviceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteVirtualMFADeviceErrorKind::DeleteConflictException(_inner) => Some(_inner),
            DeleteVirtualMFADeviceErrorKind::LimitExceededException(_inner) => Some(_inner),
            DeleteVirtualMFADeviceErrorKind::NoSuchEntityException(_inner) => Some(_inner),
            DeleteVirtualMFADeviceErrorKind::ServiceFailureException(_inner) => Some(_inner),
            DeleteVirtualMFADeviceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DetachGroupPolicyError {
    pub kind: DetachGroupPolicyErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DetachGroupPolicyErrorKind {
    InvalidInputException(crate::error::InvalidInputException),
    LimitExceededException(crate::error::LimitExceededException),
    NoSuchEntityException(crate::error::NoSuchEntityException),
    ServiceFailureException(crate::error::ServiceFailureException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DetachGroupPolicyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DetachGroupPolicyErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            DetachGroupPolicyErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            DetachGroupPolicyErrorKind::NoSuchEntityException(_inner) => _inner.fmt(f),
            DetachGroupPolicyErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            DetachGroupPolicyErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DetachGroupPolicyError {
    fn code(&self) -> Option<&str> {
        DetachGroupPolicyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DetachGroupPolicyError {
    pub fn new(kind: DetachGroupPolicyErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DetachGroupPolicyErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DetachGroupPolicyErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            DetachGroupPolicyErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            DetachGroupPolicyErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_no_such_entity_exception(&self) -> bool {
        matches!(
            &self.kind,
            DetachGroupPolicyErrorKind::NoSuchEntityException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DetachGroupPolicyErrorKind::ServiceFailureException(_)
        )
    }
}
impl std::error::Error for DetachGroupPolicyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DetachGroupPolicyErrorKind::InvalidInputException(_inner) => Some(_inner),
            DetachGroupPolicyErrorKind::LimitExceededException(_inner) => Some(_inner),
            DetachGroupPolicyErrorKind::NoSuchEntityException(_inner) => Some(_inner),
            DetachGroupPolicyErrorKind::ServiceFailureException(_inner) => Some(_inner),
            DetachGroupPolicyErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DetachRolePolicyError {
    pub kind: DetachRolePolicyErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DetachRolePolicyErrorKind {
    InvalidInputException(crate::error::InvalidInputException),
    LimitExceededException(crate::error::LimitExceededException),
    NoSuchEntityException(crate::error::NoSuchEntityException),
    ServiceFailureException(crate::error::ServiceFailureException),
    UnmodifiableEntityException(crate::error::UnmodifiableEntityException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DetachRolePolicyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DetachRolePolicyErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            DetachRolePolicyErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            DetachRolePolicyErrorKind::NoSuchEntityException(_inner) => _inner.fmt(f),
            DetachRolePolicyErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            DetachRolePolicyErrorKind::UnmodifiableEntityException(_inner) => _inner.fmt(f),
            DetachRolePolicyErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DetachRolePolicyError {
    fn code(&self) -> Option<&str> {
        DetachRolePolicyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DetachRolePolicyError {
    pub fn new(kind: DetachRolePolicyErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DetachRolePolicyErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DetachRolePolicyErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            DetachRolePolicyErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            DetachRolePolicyErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_no_such_entity_exception(&self) -> bool {
        matches!(
            &self.kind,
            DetachRolePolicyErrorKind::NoSuchEntityException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DetachRolePolicyErrorKind::ServiceFailureException(_)
        )
    }
    pub fn is_unmodifiable_entity_exception(&self) -> bool {
        matches!(
            &self.kind,
            DetachRolePolicyErrorKind::UnmodifiableEntityException(_)
        )
    }
}
impl std::error::Error for DetachRolePolicyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DetachRolePolicyErrorKind::InvalidInputException(_inner) => Some(_inner),
            DetachRolePolicyErrorKind::LimitExceededException(_inner) => Some(_inner),
            DetachRolePolicyErrorKind::NoSuchEntityException(_inner) => Some(_inner),
            DetachRolePolicyErrorKind::ServiceFailureException(_inner) => Some(_inner),
            DetachRolePolicyErrorKind::UnmodifiableEntityException(_inner) => Some(_inner),
            DetachRolePolicyErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DetachUserPolicyError {
    pub kind: DetachUserPolicyErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DetachUserPolicyErrorKind {
    InvalidInputException(crate::error::InvalidInputException),
    LimitExceededException(crate::error::LimitExceededException),
    NoSuchEntityException(crate::error::NoSuchEntityException),
    ServiceFailureException(crate::error::ServiceFailureException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DetachUserPolicyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DetachUserPolicyErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            DetachUserPolicyErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            DetachUserPolicyErrorKind::NoSuchEntityException(_inner) => _inner.fmt(f),
            DetachUserPolicyErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            DetachUserPolicyErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DetachUserPolicyError {
    fn code(&self) -> Option<&str> {
        DetachUserPolicyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DetachUserPolicyError {
    pub fn new(kind: DetachUserPolicyErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DetachUserPolicyErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DetachUserPolicyErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            DetachUserPolicyErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            DetachUserPolicyErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_no_such_entity_exception(&self) -> bool {
        matches!(
            &self.kind,
            DetachUserPolicyErrorKind::NoSuchEntityException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DetachUserPolicyErrorKind::ServiceFailureException(_)
        )
    }
}
impl std::error::Error for DetachUserPolicyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DetachUserPolicyErrorKind::InvalidInputException(_inner) => Some(_inner),
            DetachUserPolicyErrorKind::LimitExceededException(_inner) => Some(_inner),
            DetachUserPolicyErrorKind::NoSuchEntityException(_inner) => Some(_inner),
            DetachUserPolicyErrorKind::ServiceFailureException(_inner) => Some(_inner),
            DetachUserPolicyErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct EnableMFADeviceError {
    pub kind: EnableMFADeviceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum EnableMFADeviceErrorKind {
    EntityAlreadyExistsException(crate::error::EntityAlreadyExistsException),
    EntityTemporarilyUnmodifiableException(crate::error::EntityTemporarilyUnmodifiableException),
    InvalidAuthenticationCodeException(crate::error::InvalidAuthenticationCodeException),
    LimitExceededException(crate::error::LimitExceededException),
    NoSuchEntityException(crate::error::NoSuchEntityException),
    ServiceFailureException(crate::error::ServiceFailureException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for EnableMFADeviceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            EnableMFADeviceErrorKind::EntityAlreadyExistsException(_inner) => _inner.fmt(f),
            EnableMFADeviceErrorKind::EntityTemporarilyUnmodifiableException(_inner) => {
                _inner.fmt(f)
            }
            EnableMFADeviceErrorKind::InvalidAuthenticationCodeException(_inner) => _inner.fmt(f),
            EnableMFADeviceErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            EnableMFADeviceErrorKind::NoSuchEntityException(_inner) => _inner.fmt(f),
            EnableMFADeviceErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            EnableMFADeviceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for EnableMFADeviceError {
    fn code(&self) -> Option<&str> {
        EnableMFADeviceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl EnableMFADeviceError {
    pub fn new(kind: EnableMFADeviceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: EnableMFADeviceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: EnableMFADeviceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_entity_already_exists_exception(&self) -> bool {
        matches!(
            &self.kind,
            EnableMFADeviceErrorKind::EntityAlreadyExistsException(_)
        )
    }
    pub fn is_entity_temporarily_unmodifiable_exception(&self) -> bool {
        matches!(
            &self.kind,
            EnableMFADeviceErrorKind::EntityTemporarilyUnmodifiableException(_)
        )
    }
    pub fn is_invalid_authentication_code_exception(&self) -> bool {
        matches!(
            &self.kind,
            EnableMFADeviceErrorKind::InvalidAuthenticationCodeException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            EnableMFADeviceErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_no_such_entity_exception(&self) -> bool {
        matches!(
            &self.kind,
            EnableMFADeviceErrorKind::NoSuchEntityException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            EnableMFADeviceErrorKind::ServiceFailureException(_)
        )
    }
}
impl std::error::Error for EnableMFADeviceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            EnableMFADeviceErrorKind::EntityAlreadyExistsException(_inner) => Some(_inner),
            EnableMFADeviceErrorKind::EntityTemporarilyUnmodifiableException(_inner) => {
                Some(_inner)
            }
            EnableMFADeviceErrorKind::InvalidAuthenticationCodeException(_inner) => Some(_inner),
            EnableMFADeviceErrorKind::LimitExceededException(_inner) => Some(_inner),
            EnableMFADeviceErrorKind::NoSuchEntityException(_inner) => Some(_inner),
            EnableMFADeviceErrorKind::ServiceFailureException(_inner) => Some(_inner),
            EnableMFADeviceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GenerateCredentialReportError {
    pub kind: GenerateCredentialReportErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GenerateCredentialReportErrorKind {
    LimitExceededException(crate::error::LimitExceededException),
    ServiceFailureException(crate::error::ServiceFailureException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GenerateCredentialReportError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GenerateCredentialReportErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            GenerateCredentialReportErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            GenerateCredentialReportErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GenerateCredentialReportError {
    fn code(&self) -> Option<&str> {
        GenerateCredentialReportError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GenerateCredentialReportError {
    pub fn new(kind: GenerateCredentialReportErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GenerateCredentialReportErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GenerateCredentialReportErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            GenerateCredentialReportErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            GenerateCredentialReportErrorKind::ServiceFailureException(_)
        )
    }
}
impl std::error::Error for GenerateCredentialReportError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GenerateCredentialReportErrorKind::LimitExceededException(_inner) => Some(_inner),
            GenerateCredentialReportErrorKind::ServiceFailureException(_inner) => Some(_inner),
            GenerateCredentialReportErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GenerateOrganizationsAccessReportError {
    pub kind: GenerateOrganizationsAccessReportErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GenerateOrganizationsAccessReportErrorKind {
    ReportGenerationLimitExceededException(crate::error::ReportGenerationLimitExceededException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GenerateOrganizationsAccessReportError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GenerateOrganizationsAccessReportErrorKind::ReportGenerationLimitExceededException(
                _inner,
            ) => _inner.fmt(f),
            GenerateOrganizationsAccessReportErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GenerateOrganizationsAccessReportError {
    fn code(&self) -> Option<&str> {
        GenerateOrganizationsAccessReportError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GenerateOrganizationsAccessReportError {
    pub fn new(
        kind: GenerateOrganizationsAccessReportErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GenerateOrganizationsAccessReportErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GenerateOrganizationsAccessReportErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_report_generation_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            GenerateOrganizationsAccessReportErrorKind::ReportGenerationLimitExceededException(_)
        )
    }
}
impl std::error::Error for GenerateOrganizationsAccessReportError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GenerateOrganizationsAccessReportErrorKind::ReportGenerationLimitExceededException(
                _inner,
            ) => Some(_inner),
            GenerateOrganizationsAccessReportErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GenerateServiceLastAccessedDetailsError {
    pub kind: GenerateServiceLastAccessedDetailsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GenerateServiceLastAccessedDetailsErrorKind {
    InvalidInputException(crate::error::InvalidInputException),
    NoSuchEntityException(crate::error::NoSuchEntityException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GenerateServiceLastAccessedDetailsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GenerateServiceLastAccessedDetailsErrorKind::InvalidInputException(_inner) => {
                _inner.fmt(f)
            }
            GenerateServiceLastAccessedDetailsErrorKind::NoSuchEntityException(_inner) => {
                _inner.fmt(f)
            }
            GenerateServiceLastAccessedDetailsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GenerateServiceLastAccessedDetailsError {
    fn code(&self) -> Option<&str> {
        GenerateServiceLastAccessedDetailsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GenerateServiceLastAccessedDetailsError {
    pub fn new(
        kind: GenerateServiceLastAccessedDetailsErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GenerateServiceLastAccessedDetailsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GenerateServiceLastAccessedDetailsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            GenerateServiceLastAccessedDetailsErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_no_such_entity_exception(&self) -> bool {
        matches!(
            &self.kind,
            GenerateServiceLastAccessedDetailsErrorKind::NoSuchEntityException(_)
        )
    }
}
impl std::error::Error for GenerateServiceLastAccessedDetailsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GenerateServiceLastAccessedDetailsErrorKind::InvalidInputException(_inner) => {
                Some(_inner)
            }
            GenerateServiceLastAccessedDetailsErrorKind::NoSuchEntityException(_inner) => {
                Some(_inner)
            }
            GenerateServiceLastAccessedDetailsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetAccessKeyLastUsedError {
    pub kind: GetAccessKeyLastUsedErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetAccessKeyLastUsedErrorKind {
    NoSuchEntityException(crate::error::NoSuchEntityException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetAccessKeyLastUsedError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetAccessKeyLastUsedErrorKind::NoSuchEntityException(_inner) => _inner.fmt(f),
            GetAccessKeyLastUsedErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetAccessKeyLastUsedError {
    fn code(&self) -> Option<&str> {
        GetAccessKeyLastUsedError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetAccessKeyLastUsedError {
    pub fn new(kind: GetAccessKeyLastUsedErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetAccessKeyLastUsedErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetAccessKeyLastUsedErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_no_such_entity_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetAccessKeyLastUsedErrorKind::NoSuchEntityException(_)
        )
    }
}
impl std::error::Error for GetAccessKeyLastUsedError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetAccessKeyLastUsedErrorKind::NoSuchEntityException(_inner) => Some(_inner),
            GetAccessKeyLastUsedErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetAccountAuthorizationDetailsError {
    pub kind: GetAccountAuthorizationDetailsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetAccountAuthorizationDetailsErrorKind {
    ServiceFailureException(crate::error::ServiceFailureException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetAccountAuthorizationDetailsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetAccountAuthorizationDetailsErrorKind::ServiceFailureException(_inner) => {
                _inner.fmt(f)
            }
            GetAccountAuthorizationDetailsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetAccountAuthorizationDetailsError {
    fn code(&self) -> Option<&str> {
        GetAccountAuthorizationDetailsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetAccountAuthorizationDetailsError {
    pub fn new(kind: GetAccountAuthorizationDetailsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetAccountAuthorizationDetailsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetAccountAuthorizationDetailsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetAccountAuthorizationDetailsErrorKind::ServiceFailureException(_)
        )
    }
}
impl std::error::Error for GetAccountAuthorizationDetailsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetAccountAuthorizationDetailsErrorKind::ServiceFailureException(_inner) => {
                Some(_inner)
            }
            GetAccountAuthorizationDetailsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetAccountPasswordPolicyError {
    pub kind: GetAccountPasswordPolicyErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetAccountPasswordPolicyErrorKind {
    NoSuchEntityException(crate::error::NoSuchEntityException),
    ServiceFailureException(crate::error::ServiceFailureException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetAccountPasswordPolicyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetAccountPasswordPolicyErrorKind::NoSuchEntityException(_inner) => _inner.fmt(f),
            GetAccountPasswordPolicyErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            GetAccountPasswordPolicyErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetAccountPasswordPolicyError {
    fn code(&self) -> Option<&str> {
        GetAccountPasswordPolicyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetAccountPasswordPolicyError {
    pub fn new(kind: GetAccountPasswordPolicyErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetAccountPasswordPolicyErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetAccountPasswordPolicyErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_no_such_entity_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetAccountPasswordPolicyErrorKind::NoSuchEntityException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetAccountPasswordPolicyErrorKind::ServiceFailureException(_)
        )
    }
}
impl std::error::Error for GetAccountPasswordPolicyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetAccountPasswordPolicyErrorKind::NoSuchEntityException(_inner) => Some(_inner),
            GetAccountPasswordPolicyErrorKind::ServiceFailureException(_inner) => Some(_inner),
            GetAccountPasswordPolicyErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetAccountSummaryError {
    pub kind: GetAccountSummaryErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetAccountSummaryErrorKind {
    ServiceFailureException(crate::error::ServiceFailureException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetAccountSummaryError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetAccountSummaryErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            GetAccountSummaryErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetAccountSummaryError {
    fn code(&self) -> Option<&str> {
        GetAccountSummaryError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetAccountSummaryError {
    pub fn new(kind: GetAccountSummaryErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetAccountSummaryErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetAccountSummaryErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetAccountSummaryErrorKind::ServiceFailureException(_)
        )
    }
}
impl std::error::Error for GetAccountSummaryError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetAccountSummaryErrorKind::ServiceFailureException(_inner) => Some(_inner),
            GetAccountSummaryErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetContextKeysForCustomPolicyError {
    pub kind: GetContextKeysForCustomPolicyErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetContextKeysForCustomPolicyErrorKind {
    InvalidInputException(crate::error::InvalidInputException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetContextKeysForCustomPolicyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetContextKeysForCustomPolicyErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            GetContextKeysForCustomPolicyErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetContextKeysForCustomPolicyError {
    fn code(&self) -> Option<&str> {
        GetContextKeysForCustomPolicyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetContextKeysForCustomPolicyError {
    pub fn new(kind: GetContextKeysForCustomPolicyErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetContextKeysForCustomPolicyErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetContextKeysForCustomPolicyErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetContextKeysForCustomPolicyErrorKind::InvalidInputException(_)
        )
    }
}
impl std::error::Error for GetContextKeysForCustomPolicyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetContextKeysForCustomPolicyErrorKind::InvalidInputException(_inner) => Some(_inner),
            GetContextKeysForCustomPolicyErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetContextKeysForPrincipalPolicyError {
    pub kind: GetContextKeysForPrincipalPolicyErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetContextKeysForPrincipalPolicyErrorKind {
    InvalidInputException(crate::error::InvalidInputException),
    NoSuchEntityException(crate::error::NoSuchEntityException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetContextKeysForPrincipalPolicyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetContextKeysForPrincipalPolicyErrorKind::InvalidInputException(_inner) => {
                _inner.fmt(f)
            }
            GetContextKeysForPrincipalPolicyErrorKind::NoSuchEntityException(_inner) => {
                _inner.fmt(f)
            }
            GetContextKeysForPrincipalPolicyErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetContextKeysForPrincipalPolicyError {
    fn code(&self) -> Option<&str> {
        GetContextKeysForPrincipalPolicyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetContextKeysForPrincipalPolicyError {
    pub fn new(kind: GetContextKeysForPrincipalPolicyErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetContextKeysForPrincipalPolicyErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetContextKeysForPrincipalPolicyErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetContextKeysForPrincipalPolicyErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_no_such_entity_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetContextKeysForPrincipalPolicyErrorKind::NoSuchEntityException(_)
        )
    }
}
impl std::error::Error for GetContextKeysForPrincipalPolicyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetContextKeysForPrincipalPolicyErrorKind::InvalidInputException(_inner) => {
                Some(_inner)
            }
            GetContextKeysForPrincipalPolicyErrorKind::NoSuchEntityException(_inner) => {
                Some(_inner)
            }
            GetContextKeysForPrincipalPolicyErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetCredentialReportError {
    pub kind: GetCredentialReportErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetCredentialReportErrorKind {
    CredentialReportExpiredException(crate::error::CredentialReportExpiredException),
    CredentialReportNotPresentException(crate::error::CredentialReportNotPresentException),
    CredentialReportNotReadyException(crate::error::CredentialReportNotReadyException),
    ServiceFailureException(crate::error::ServiceFailureException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetCredentialReportError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetCredentialReportErrorKind::CredentialReportExpiredException(_inner) => _inner.fmt(f),
            GetCredentialReportErrorKind::CredentialReportNotPresentException(_inner) => {
                _inner.fmt(f)
            }
            GetCredentialReportErrorKind::CredentialReportNotReadyException(_inner) => {
                _inner.fmt(f)
            }
            GetCredentialReportErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            GetCredentialReportErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetCredentialReportError {
    fn code(&self) -> Option<&str> {
        GetCredentialReportError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetCredentialReportError {
    pub fn new(kind: GetCredentialReportErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetCredentialReportErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetCredentialReportErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_credential_report_expired_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetCredentialReportErrorKind::CredentialReportExpiredException(_)
        )
    }
    pub fn is_credential_report_not_present_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetCredentialReportErrorKind::CredentialReportNotPresentException(_)
        )
    }
    pub fn is_credential_report_not_ready_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetCredentialReportErrorKind::CredentialReportNotReadyException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetCredentialReportErrorKind::ServiceFailureException(_)
        )
    }
}
impl std::error::Error for GetCredentialReportError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetCredentialReportErrorKind::CredentialReportExpiredException(_inner) => Some(_inner),
            GetCredentialReportErrorKind::CredentialReportNotPresentException(_inner) => {
                Some(_inner)
            }
            GetCredentialReportErrorKind::CredentialReportNotReadyException(_inner) => Some(_inner),
            GetCredentialReportErrorKind::ServiceFailureException(_inner) => Some(_inner),
            GetCredentialReportErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetGroupError {
    pub kind: GetGroupErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetGroupErrorKind {
    NoSuchEntityException(crate::error::NoSuchEntityException),
    ServiceFailureException(crate::error::ServiceFailureException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetGroupError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetGroupErrorKind::NoSuchEntityException(_inner) => _inner.fmt(f),
            GetGroupErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            GetGroupErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetGroupError {
    fn code(&self) -> Option<&str> {
        GetGroupError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetGroupError {
    pub fn new(kind: GetGroupErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetGroupErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetGroupErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_no_such_entity_exception(&self) -> bool {
        matches!(&self.kind, GetGroupErrorKind::NoSuchEntityException(_))
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(&self.kind, GetGroupErrorKind::ServiceFailureException(_))
    }
}
impl std::error::Error for GetGroupError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetGroupErrorKind::NoSuchEntityException(_inner) => Some(_inner),
            GetGroupErrorKind::ServiceFailureException(_inner) => Some(_inner),
            GetGroupErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetGroupPolicyError {
    pub kind: GetGroupPolicyErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetGroupPolicyErrorKind {
    NoSuchEntityException(crate::error::NoSuchEntityException),
    ServiceFailureException(crate::error::ServiceFailureException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetGroupPolicyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetGroupPolicyErrorKind::NoSuchEntityException(_inner) => _inner.fmt(f),
            GetGroupPolicyErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            GetGroupPolicyErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetGroupPolicyError {
    fn code(&self) -> Option<&str> {
        GetGroupPolicyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetGroupPolicyError {
    pub fn new(kind: GetGroupPolicyErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetGroupPolicyErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetGroupPolicyErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_no_such_entity_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetGroupPolicyErrorKind::NoSuchEntityException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetGroupPolicyErrorKind::ServiceFailureException(_)
        )
    }
}
impl std::error::Error for GetGroupPolicyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetGroupPolicyErrorKind::NoSuchEntityException(_inner) => Some(_inner),
            GetGroupPolicyErrorKind::ServiceFailureException(_inner) => Some(_inner),
            GetGroupPolicyErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetInstanceProfileError {
    pub kind: GetInstanceProfileErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetInstanceProfileErrorKind {
    NoSuchEntityException(crate::error::NoSuchEntityException),
    ServiceFailureException(crate::error::ServiceFailureException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetInstanceProfileError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetInstanceProfileErrorKind::NoSuchEntityException(_inner) => _inner.fmt(f),
            GetInstanceProfileErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            GetInstanceProfileErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetInstanceProfileError {
    fn code(&self) -> Option<&str> {
        GetInstanceProfileError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetInstanceProfileError {
    pub fn new(kind: GetInstanceProfileErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetInstanceProfileErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetInstanceProfileErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_no_such_entity_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetInstanceProfileErrorKind::NoSuchEntityException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetInstanceProfileErrorKind::ServiceFailureException(_)
        )
    }
}
impl std::error::Error for GetInstanceProfileError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetInstanceProfileErrorKind::NoSuchEntityException(_inner) => Some(_inner),
            GetInstanceProfileErrorKind::ServiceFailureException(_inner) => Some(_inner),
            GetInstanceProfileErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetLoginProfileError {
    pub kind: GetLoginProfileErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetLoginProfileErrorKind {
    NoSuchEntityException(crate::error::NoSuchEntityException),
    ServiceFailureException(crate::error::ServiceFailureException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetLoginProfileError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetLoginProfileErrorKind::NoSuchEntityException(_inner) => _inner.fmt(f),
            GetLoginProfileErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            GetLoginProfileErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetLoginProfileError {
    fn code(&self) -> Option<&str> {
        GetLoginProfileError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetLoginProfileError {
    pub fn new(kind: GetLoginProfileErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetLoginProfileErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetLoginProfileErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_no_such_entity_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetLoginProfileErrorKind::NoSuchEntityException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetLoginProfileErrorKind::ServiceFailureException(_)
        )
    }
}
impl std::error::Error for GetLoginProfileError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetLoginProfileErrorKind::NoSuchEntityException(_inner) => Some(_inner),
            GetLoginProfileErrorKind::ServiceFailureException(_inner) => Some(_inner),
            GetLoginProfileErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetOpenIDConnectProviderError {
    pub kind: GetOpenIDConnectProviderErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetOpenIDConnectProviderErrorKind {
    InvalidInputException(crate::error::InvalidInputException),
    NoSuchEntityException(crate::error::NoSuchEntityException),
    ServiceFailureException(crate::error::ServiceFailureException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetOpenIDConnectProviderError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetOpenIDConnectProviderErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            GetOpenIDConnectProviderErrorKind::NoSuchEntityException(_inner) => _inner.fmt(f),
            GetOpenIDConnectProviderErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            GetOpenIDConnectProviderErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetOpenIDConnectProviderError {
    fn code(&self) -> Option<&str> {
        GetOpenIDConnectProviderError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetOpenIDConnectProviderError {
    pub fn new(kind: GetOpenIDConnectProviderErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetOpenIDConnectProviderErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetOpenIDConnectProviderErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetOpenIDConnectProviderErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_no_such_entity_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetOpenIDConnectProviderErrorKind::NoSuchEntityException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetOpenIDConnectProviderErrorKind::ServiceFailureException(_)
        )
    }
}
impl std::error::Error for GetOpenIDConnectProviderError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetOpenIDConnectProviderErrorKind::InvalidInputException(_inner) => Some(_inner),
            GetOpenIDConnectProviderErrorKind::NoSuchEntityException(_inner) => Some(_inner),
            GetOpenIDConnectProviderErrorKind::ServiceFailureException(_inner) => Some(_inner),
            GetOpenIDConnectProviderErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetOrganizationsAccessReportError {
    pub kind: GetOrganizationsAccessReportErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetOrganizationsAccessReportErrorKind {
    NoSuchEntityException(crate::error::NoSuchEntityException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetOrganizationsAccessReportError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetOrganizationsAccessReportErrorKind::NoSuchEntityException(_inner) => _inner.fmt(f),
            GetOrganizationsAccessReportErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetOrganizationsAccessReportError {
    fn code(&self) -> Option<&str> {
        GetOrganizationsAccessReportError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetOrganizationsAccessReportError {
    pub fn new(kind: GetOrganizationsAccessReportErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetOrganizationsAccessReportErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetOrganizationsAccessReportErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_no_such_entity_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetOrganizationsAccessReportErrorKind::NoSuchEntityException(_)
        )
    }
}
impl std::error::Error for GetOrganizationsAccessReportError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetOrganizationsAccessReportErrorKind::NoSuchEntityException(_inner) => Some(_inner),
            GetOrganizationsAccessReportErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetPolicyError {
    pub kind: GetPolicyErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetPolicyErrorKind {
    InvalidInputException(crate::error::InvalidInputException),
    NoSuchEntityException(crate::error::NoSuchEntityException),
    ServiceFailureException(crate::error::ServiceFailureException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetPolicyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetPolicyErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            GetPolicyErrorKind::NoSuchEntityException(_inner) => _inner.fmt(f),
            GetPolicyErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            GetPolicyErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetPolicyError {
    fn code(&self) -> Option<&str> {
        GetPolicyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetPolicyError {
    pub fn new(kind: GetPolicyErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetPolicyErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetPolicyErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(&self.kind, GetPolicyErrorKind::InvalidInputException(_))
    }
    pub fn is_no_such_entity_exception(&self) -> bool {
        matches!(&self.kind, GetPolicyErrorKind::NoSuchEntityException(_))
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(&self.kind, GetPolicyErrorKind::ServiceFailureException(_))
    }
}
impl std::error::Error for GetPolicyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetPolicyErrorKind::InvalidInputException(_inner) => Some(_inner),
            GetPolicyErrorKind::NoSuchEntityException(_inner) => Some(_inner),
            GetPolicyErrorKind::ServiceFailureException(_inner) => Some(_inner),
            GetPolicyErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetPolicyVersionError {
    pub kind: GetPolicyVersionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetPolicyVersionErrorKind {
    InvalidInputException(crate::error::InvalidInputException),
    NoSuchEntityException(crate::error::NoSuchEntityException),
    ServiceFailureException(crate::error::ServiceFailureException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetPolicyVersionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetPolicyVersionErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            GetPolicyVersionErrorKind::NoSuchEntityException(_inner) => _inner.fmt(f),
            GetPolicyVersionErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            GetPolicyVersionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetPolicyVersionError {
    fn code(&self) -> Option<&str> {
        GetPolicyVersionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetPolicyVersionError {
    pub fn new(kind: GetPolicyVersionErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetPolicyVersionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetPolicyVersionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetPolicyVersionErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_no_such_entity_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetPolicyVersionErrorKind::NoSuchEntityException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetPolicyVersionErrorKind::ServiceFailureException(_)
        )
    }
}
impl std::error::Error for GetPolicyVersionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetPolicyVersionErrorKind::InvalidInputException(_inner) => Some(_inner),
            GetPolicyVersionErrorKind::NoSuchEntityException(_inner) => Some(_inner),
            GetPolicyVersionErrorKind::ServiceFailureException(_inner) => Some(_inner),
            GetPolicyVersionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetRoleError {
    pub kind: GetRoleErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetRoleErrorKind {
    NoSuchEntityException(crate::error::NoSuchEntityException),
    ServiceFailureException(crate::error::ServiceFailureException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetRoleError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetRoleErrorKind::NoSuchEntityException(_inner) => _inner.fmt(f),
            GetRoleErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            GetRoleErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetRoleError {
    fn code(&self) -> Option<&str> {
        GetRoleError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetRoleError {
    pub fn new(kind: GetRoleErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetRoleErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetRoleErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_no_such_entity_exception(&self) -> bool {
        matches!(&self.kind, GetRoleErrorKind::NoSuchEntityException(_))
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(&self.kind, GetRoleErrorKind::ServiceFailureException(_))
    }
}
impl std::error::Error for GetRoleError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetRoleErrorKind::NoSuchEntityException(_inner) => Some(_inner),
            GetRoleErrorKind::ServiceFailureException(_inner) => Some(_inner),
            GetRoleErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetRolePolicyError {
    pub kind: GetRolePolicyErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetRolePolicyErrorKind {
    NoSuchEntityException(crate::error::NoSuchEntityException),
    ServiceFailureException(crate::error::ServiceFailureException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetRolePolicyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetRolePolicyErrorKind::NoSuchEntityException(_inner) => _inner.fmt(f),
            GetRolePolicyErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            GetRolePolicyErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetRolePolicyError {
    fn code(&self) -> Option<&str> {
        GetRolePolicyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetRolePolicyError {
    pub fn new(kind: GetRolePolicyErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetRolePolicyErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetRolePolicyErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_no_such_entity_exception(&self) -> bool {
        matches!(&self.kind, GetRolePolicyErrorKind::NoSuchEntityException(_))
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetRolePolicyErrorKind::ServiceFailureException(_)
        )
    }
}
impl std::error::Error for GetRolePolicyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetRolePolicyErrorKind::NoSuchEntityException(_inner) => Some(_inner),
            GetRolePolicyErrorKind::ServiceFailureException(_inner) => Some(_inner),
            GetRolePolicyErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetSAMLProviderError {
    pub kind: GetSAMLProviderErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetSAMLProviderErrorKind {
    InvalidInputException(crate::error::InvalidInputException),
    NoSuchEntityException(crate::error::NoSuchEntityException),
    ServiceFailureException(crate::error::ServiceFailureException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetSAMLProviderError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetSAMLProviderErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            GetSAMLProviderErrorKind::NoSuchEntityException(_inner) => _inner.fmt(f),
            GetSAMLProviderErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            GetSAMLProviderErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetSAMLProviderError {
    fn code(&self) -> Option<&str> {
        GetSAMLProviderError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetSAMLProviderError {
    pub fn new(kind: GetSAMLProviderErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetSAMLProviderErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetSAMLProviderErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetSAMLProviderErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_no_such_entity_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetSAMLProviderErrorKind::NoSuchEntityException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetSAMLProviderErrorKind::ServiceFailureException(_)
        )
    }
}
impl std::error::Error for GetSAMLProviderError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetSAMLProviderErrorKind::InvalidInputException(_inner) => Some(_inner),
            GetSAMLProviderErrorKind::NoSuchEntityException(_inner) => Some(_inner),
            GetSAMLProviderErrorKind::ServiceFailureException(_inner) => Some(_inner),
            GetSAMLProviderErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetServerCertificateError {
    pub kind: GetServerCertificateErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetServerCertificateErrorKind {
    NoSuchEntityException(crate::error::NoSuchEntityException),
    ServiceFailureException(crate::error::ServiceFailureException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetServerCertificateError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetServerCertificateErrorKind::NoSuchEntityException(_inner) => _inner.fmt(f),
            GetServerCertificateErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            GetServerCertificateErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetServerCertificateError {
    fn code(&self) -> Option<&str> {
        GetServerCertificateError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetServerCertificateError {
    pub fn new(kind: GetServerCertificateErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetServerCertificateErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetServerCertificateErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_no_such_entity_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetServerCertificateErrorKind::NoSuchEntityException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetServerCertificateErrorKind::ServiceFailureException(_)
        )
    }
}
impl std::error::Error for GetServerCertificateError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetServerCertificateErrorKind::NoSuchEntityException(_inner) => Some(_inner),
            GetServerCertificateErrorKind::ServiceFailureException(_inner) => Some(_inner),
            GetServerCertificateErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetServiceLastAccessedDetailsError {
    pub kind: GetServiceLastAccessedDetailsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetServiceLastAccessedDetailsErrorKind {
    InvalidInputException(crate::error::InvalidInputException),
    NoSuchEntityException(crate::error::NoSuchEntityException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetServiceLastAccessedDetailsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetServiceLastAccessedDetailsErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            GetServiceLastAccessedDetailsErrorKind::NoSuchEntityException(_inner) => _inner.fmt(f),
            GetServiceLastAccessedDetailsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetServiceLastAccessedDetailsError {
    fn code(&self) -> Option<&str> {
        GetServiceLastAccessedDetailsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetServiceLastAccessedDetailsError {
    pub fn new(kind: GetServiceLastAccessedDetailsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetServiceLastAccessedDetailsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetServiceLastAccessedDetailsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetServiceLastAccessedDetailsErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_no_such_entity_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetServiceLastAccessedDetailsErrorKind::NoSuchEntityException(_)
        )
    }
}
impl std::error::Error for GetServiceLastAccessedDetailsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetServiceLastAccessedDetailsErrorKind::InvalidInputException(_inner) => Some(_inner),
            GetServiceLastAccessedDetailsErrorKind::NoSuchEntityException(_inner) => Some(_inner),
            GetServiceLastAccessedDetailsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetServiceLastAccessedDetailsWithEntitiesError {
    pub kind: GetServiceLastAccessedDetailsWithEntitiesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetServiceLastAccessedDetailsWithEntitiesErrorKind {
    InvalidInputException(crate::error::InvalidInputException),
    NoSuchEntityException(crate::error::NoSuchEntityException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetServiceLastAccessedDetailsWithEntitiesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetServiceLastAccessedDetailsWithEntitiesErrorKind::InvalidInputException(_inner) => {
                _inner.fmt(f)
            }
            GetServiceLastAccessedDetailsWithEntitiesErrorKind::NoSuchEntityException(_inner) => {
                _inner.fmt(f)
            }
            GetServiceLastAccessedDetailsWithEntitiesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetServiceLastAccessedDetailsWithEntitiesError {
    fn code(&self) -> Option<&str> {
        GetServiceLastAccessedDetailsWithEntitiesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetServiceLastAccessedDetailsWithEntitiesError {
    pub fn new(
        kind: GetServiceLastAccessedDetailsWithEntitiesErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetServiceLastAccessedDetailsWithEntitiesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetServiceLastAccessedDetailsWithEntitiesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetServiceLastAccessedDetailsWithEntitiesErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_no_such_entity_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetServiceLastAccessedDetailsWithEntitiesErrorKind::NoSuchEntityException(_)
        )
    }
}
impl std::error::Error for GetServiceLastAccessedDetailsWithEntitiesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetServiceLastAccessedDetailsWithEntitiesErrorKind::InvalidInputException(_inner) => {
                Some(_inner)
            }
            GetServiceLastAccessedDetailsWithEntitiesErrorKind::NoSuchEntityException(_inner) => {
                Some(_inner)
            }
            GetServiceLastAccessedDetailsWithEntitiesErrorKind::Unhandled(_inner) => {
                Some(_inner.as_ref())
            }
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetServiceLinkedRoleDeletionStatusError {
    pub kind: GetServiceLinkedRoleDeletionStatusErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetServiceLinkedRoleDeletionStatusErrorKind {
    InvalidInputException(crate::error::InvalidInputException),
    NoSuchEntityException(crate::error::NoSuchEntityException),
    ServiceFailureException(crate::error::ServiceFailureException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetServiceLinkedRoleDeletionStatusError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetServiceLinkedRoleDeletionStatusErrorKind::InvalidInputException(_inner) => {
                _inner.fmt(f)
            }
            GetServiceLinkedRoleDeletionStatusErrorKind::NoSuchEntityException(_inner) => {
                _inner.fmt(f)
            }
            GetServiceLinkedRoleDeletionStatusErrorKind::ServiceFailureException(_inner) => {
                _inner.fmt(f)
            }
            GetServiceLinkedRoleDeletionStatusErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetServiceLinkedRoleDeletionStatusError {
    fn code(&self) -> Option<&str> {
        GetServiceLinkedRoleDeletionStatusError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetServiceLinkedRoleDeletionStatusError {
    pub fn new(
        kind: GetServiceLinkedRoleDeletionStatusErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetServiceLinkedRoleDeletionStatusErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetServiceLinkedRoleDeletionStatusErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetServiceLinkedRoleDeletionStatusErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_no_such_entity_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetServiceLinkedRoleDeletionStatusErrorKind::NoSuchEntityException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetServiceLinkedRoleDeletionStatusErrorKind::ServiceFailureException(_)
        )
    }
}
impl std::error::Error for GetServiceLinkedRoleDeletionStatusError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetServiceLinkedRoleDeletionStatusErrorKind::InvalidInputException(_inner) => {
                Some(_inner)
            }
            GetServiceLinkedRoleDeletionStatusErrorKind::NoSuchEntityException(_inner) => {
                Some(_inner)
            }
            GetServiceLinkedRoleDeletionStatusErrorKind::ServiceFailureException(_inner) => {
                Some(_inner)
            }
            GetServiceLinkedRoleDeletionStatusErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetSSHPublicKeyError {
    pub kind: GetSSHPublicKeyErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetSSHPublicKeyErrorKind {
    NoSuchEntityException(crate::error::NoSuchEntityException),
    UnrecognizedPublicKeyEncodingException(crate::error::UnrecognizedPublicKeyEncodingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetSSHPublicKeyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetSSHPublicKeyErrorKind::NoSuchEntityException(_inner) => _inner.fmt(f),
            GetSSHPublicKeyErrorKind::UnrecognizedPublicKeyEncodingException(_inner) => {
                _inner.fmt(f)
            }
            GetSSHPublicKeyErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetSSHPublicKeyError {
    fn code(&self) -> Option<&str> {
        GetSSHPublicKeyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetSSHPublicKeyError {
    pub fn new(kind: GetSSHPublicKeyErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetSSHPublicKeyErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetSSHPublicKeyErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_no_such_entity_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetSSHPublicKeyErrorKind::NoSuchEntityException(_)
        )
    }
    pub fn is_unrecognized_public_key_encoding_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetSSHPublicKeyErrorKind::UnrecognizedPublicKeyEncodingException(_)
        )
    }
}
impl std::error::Error for GetSSHPublicKeyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetSSHPublicKeyErrorKind::NoSuchEntityException(_inner) => Some(_inner),
            GetSSHPublicKeyErrorKind::UnrecognizedPublicKeyEncodingException(_inner) => {
                Some(_inner)
            }
            GetSSHPublicKeyErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetUserError {
    pub kind: GetUserErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetUserErrorKind {
    NoSuchEntityException(crate::error::NoSuchEntityException),
    ServiceFailureException(crate::error::ServiceFailureException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetUserError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetUserErrorKind::NoSuchEntityException(_inner) => _inner.fmt(f),
            GetUserErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            GetUserErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetUserError {
    fn code(&self) -> Option<&str> {
        GetUserError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetUserError {
    pub fn new(kind: GetUserErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetUserErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetUserErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_no_such_entity_exception(&self) -> bool {
        matches!(&self.kind, GetUserErrorKind::NoSuchEntityException(_))
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(&self.kind, GetUserErrorKind::ServiceFailureException(_))
    }
}
impl std::error::Error for GetUserError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetUserErrorKind::NoSuchEntityException(_inner) => Some(_inner),
            GetUserErrorKind::ServiceFailureException(_inner) => Some(_inner),
            GetUserErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetUserPolicyError {
    pub kind: GetUserPolicyErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetUserPolicyErrorKind {
    NoSuchEntityException(crate::error::NoSuchEntityException),
    ServiceFailureException(crate::error::ServiceFailureException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetUserPolicyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetUserPolicyErrorKind::NoSuchEntityException(_inner) => _inner.fmt(f),
            GetUserPolicyErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            GetUserPolicyErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetUserPolicyError {
    fn code(&self) -> Option<&str> {
        GetUserPolicyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetUserPolicyError {
    pub fn new(kind: GetUserPolicyErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetUserPolicyErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetUserPolicyErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_no_such_entity_exception(&self) -> bool {
        matches!(&self.kind, GetUserPolicyErrorKind::NoSuchEntityException(_))
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetUserPolicyErrorKind::ServiceFailureException(_)
        )
    }
}
impl std::error::Error for GetUserPolicyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetUserPolicyErrorKind::NoSuchEntityException(_inner) => Some(_inner),
            GetUserPolicyErrorKind::ServiceFailureException(_inner) => Some(_inner),
            GetUserPolicyErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListAccessKeysError {
    pub kind: ListAccessKeysErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListAccessKeysErrorKind {
    NoSuchEntityException(crate::error::NoSuchEntityException),
    ServiceFailureException(crate::error::ServiceFailureException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListAccessKeysError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListAccessKeysErrorKind::NoSuchEntityException(_inner) => _inner.fmt(f),
            ListAccessKeysErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            ListAccessKeysErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListAccessKeysError {
    fn code(&self) -> Option<&str> {
        ListAccessKeysError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListAccessKeysError {
    pub fn new(kind: ListAccessKeysErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListAccessKeysErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListAccessKeysErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_no_such_entity_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListAccessKeysErrorKind::NoSuchEntityException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListAccessKeysErrorKind::ServiceFailureException(_)
        )
    }
}
impl std::error::Error for ListAccessKeysError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListAccessKeysErrorKind::NoSuchEntityException(_inner) => Some(_inner),
            ListAccessKeysErrorKind::ServiceFailureException(_inner) => Some(_inner),
            ListAccessKeysErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListAccountAliasesError {
    pub kind: ListAccountAliasesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListAccountAliasesErrorKind {
    ServiceFailureException(crate::error::ServiceFailureException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListAccountAliasesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListAccountAliasesErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            ListAccountAliasesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListAccountAliasesError {
    fn code(&self) -> Option<&str> {
        ListAccountAliasesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListAccountAliasesError {
    pub fn new(kind: ListAccountAliasesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListAccountAliasesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListAccountAliasesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListAccountAliasesErrorKind::ServiceFailureException(_)
        )
    }
}
impl std::error::Error for ListAccountAliasesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListAccountAliasesErrorKind::ServiceFailureException(_inner) => Some(_inner),
            ListAccountAliasesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListAttachedGroupPoliciesError {
    pub kind: ListAttachedGroupPoliciesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListAttachedGroupPoliciesErrorKind {
    InvalidInputException(crate::error::InvalidInputException),
    NoSuchEntityException(crate::error::NoSuchEntityException),
    ServiceFailureException(crate::error::ServiceFailureException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListAttachedGroupPoliciesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListAttachedGroupPoliciesErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            ListAttachedGroupPoliciesErrorKind::NoSuchEntityException(_inner) => _inner.fmt(f),
            ListAttachedGroupPoliciesErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            ListAttachedGroupPoliciesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListAttachedGroupPoliciesError {
    fn code(&self) -> Option<&str> {
        ListAttachedGroupPoliciesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListAttachedGroupPoliciesError {
    pub fn new(kind: ListAttachedGroupPoliciesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListAttachedGroupPoliciesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListAttachedGroupPoliciesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListAttachedGroupPoliciesErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_no_such_entity_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListAttachedGroupPoliciesErrorKind::NoSuchEntityException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListAttachedGroupPoliciesErrorKind::ServiceFailureException(_)
        )
    }
}
impl std::error::Error for ListAttachedGroupPoliciesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListAttachedGroupPoliciesErrorKind::InvalidInputException(_inner) => Some(_inner),
            ListAttachedGroupPoliciesErrorKind::NoSuchEntityException(_inner) => Some(_inner),
            ListAttachedGroupPoliciesErrorKind::ServiceFailureException(_inner) => Some(_inner),
            ListAttachedGroupPoliciesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListAttachedRolePoliciesError {
    pub kind: ListAttachedRolePoliciesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListAttachedRolePoliciesErrorKind {
    InvalidInputException(crate::error::InvalidInputException),
    NoSuchEntityException(crate::error::NoSuchEntityException),
    ServiceFailureException(crate::error::ServiceFailureException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListAttachedRolePoliciesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListAttachedRolePoliciesErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            ListAttachedRolePoliciesErrorKind::NoSuchEntityException(_inner) => _inner.fmt(f),
            ListAttachedRolePoliciesErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            ListAttachedRolePoliciesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListAttachedRolePoliciesError {
    fn code(&self) -> Option<&str> {
        ListAttachedRolePoliciesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListAttachedRolePoliciesError {
    pub fn new(kind: ListAttachedRolePoliciesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListAttachedRolePoliciesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListAttachedRolePoliciesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListAttachedRolePoliciesErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_no_such_entity_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListAttachedRolePoliciesErrorKind::NoSuchEntityException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListAttachedRolePoliciesErrorKind::ServiceFailureException(_)
        )
    }
}
impl std::error::Error for ListAttachedRolePoliciesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListAttachedRolePoliciesErrorKind::InvalidInputException(_inner) => Some(_inner),
            ListAttachedRolePoliciesErrorKind::NoSuchEntityException(_inner) => Some(_inner),
            ListAttachedRolePoliciesErrorKind::ServiceFailureException(_inner) => Some(_inner),
            ListAttachedRolePoliciesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListAttachedUserPoliciesError {
    pub kind: ListAttachedUserPoliciesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListAttachedUserPoliciesErrorKind {
    InvalidInputException(crate::error::InvalidInputException),
    NoSuchEntityException(crate::error::NoSuchEntityException),
    ServiceFailureException(crate::error::ServiceFailureException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListAttachedUserPoliciesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListAttachedUserPoliciesErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            ListAttachedUserPoliciesErrorKind::NoSuchEntityException(_inner) => _inner.fmt(f),
            ListAttachedUserPoliciesErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            ListAttachedUserPoliciesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListAttachedUserPoliciesError {
    fn code(&self) -> Option<&str> {
        ListAttachedUserPoliciesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListAttachedUserPoliciesError {
    pub fn new(kind: ListAttachedUserPoliciesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListAttachedUserPoliciesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListAttachedUserPoliciesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListAttachedUserPoliciesErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_no_such_entity_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListAttachedUserPoliciesErrorKind::NoSuchEntityException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListAttachedUserPoliciesErrorKind::ServiceFailureException(_)
        )
    }
}
impl std::error::Error for ListAttachedUserPoliciesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListAttachedUserPoliciesErrorKind::InvalidInputException(_inner) => Some(_inner),
            ListAttachedUserPoliciesErrorKind::NoSuchEntityException(_inner) => Some(_inner),
            ListAttachedUserPoliciesErrorKind::ServiceFailureException(_inner) => Some(_inner),
            ListAttachedUserPoliciesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListEntitiesForPolicyError {
    pub kind: ListEntitiesForPolicyErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListEntitiesForPolicyErrorKind {
    InvalidInputException(crate::error::InvalidInputException),
    NoSuchEntityException(crate::error::NoSuchEntityException),
    ServiceFailureException(crate::error::ServiceFailureException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListEntitiesForPolicyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListEntitiesForPolicyErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            ListEntitiesForPolicyErrorKind::NoSuchEntityException(_inner) => _inner.fmt(f),
            ListEntitiesForPolicyErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            ListEntitiesForPolicyErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListEntitiesForPolicyError {
    fn code(&self) -> Option<&str> {
        ListEntitiesForPolicyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListEntitiesForPolicyError {
    pub fn new(kind: ListEntitiesForPolicyErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListEntitiesForPolicyErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListEntitiesForPolicyErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListEntitiesForPolicyErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_no_such_entity_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListEntitiesForPolicyErrorKind::NoSuchEntityException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListEntitiesForPolicyErrorKind::ServiceFailureException(_)
        )
    }
}
impl std::error::Error for ListEntitiesForPolicyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListEntitiesForPolicyErrorKind::InvalidInputException(_inner) => Some(_inner),
            ListEntitiesForPolicyErrorKind::NoSuchEntityException(_inner) => Some(_inner),
            ListEntitiesForPolicyErrorKind::ServiceFailureException(_inner) => Some(_inner),
            ListEntitiesForPolicyErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListGroupPoliciesError {
    pub kind: ListGroupPoliciesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListGroupPoliciesErrorKind {
    NoSuchEntityException(crate::error::NoSuchEntityException),
    ServiceFailureException(crate::error::ServiceFailureException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListGroupPoliciesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListGroupPoliciesErrorKind::NoSuchEntityException(_inner) => _inner.fmt(f),
            ListGroupPoliciesErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            ListGroupPoliciesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListGroupPoliciesError {
    fn code(&self) -> Option<&str> {
        ListGroupPoliciesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListGroupPoliciesError {
    pub fn new(kind: ListGroupPoliciesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListGroupPoliciesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListGroupPoliciesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_no_such_entity_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListGroupPoliciesErrorKind::NoSuchEntityException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListGroupPoliciesErrorKind::ServiceFailureException(_)
        )
    }
}
impl std::error::Error for ListGroupPoliciesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListGroupPoliciesErrorKind::NoSuchEntityException(_inner) => Some(_inner),
            ListGroupPoliciesErrorKind::ServiceFailureException(_inner) => Some(_inner),
            ListGroupPoliciesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListGroupsError {
    pub kind: ListGroupsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListGroupsErrorKind {
    ServiceFailureException(crate::error::ServiceFailureException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListGroupsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListGroupsErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            ListGroupsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListGroupsError {
    fn code(&self) -> Option<&str> {
        ListGroupsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListGroupsError {
    pub fn new(kind: ListGroupsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListGroupsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListGroupsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(&self.kind, ListGroupsErrorKind::ServiceFailureException(_))
    }
}
impl std::error::Error for ListGroupsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListGroupsErrorKind::ServiceFailureException(_inner) => Some(_inner),
            ListGroupsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListGroupsForUserError {
    pub kind: ListGroupsForUserErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListGroupsForUserErrorKind {
    NoSuchEntityException(crate::error::NoSuchEntityException),
    ServiceFailureException(crate::error::ServiceFailureException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListGroupsForUserError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListGroupsForUserErrorKind::NoSuchEntityException(_inner) => _inner.fmt(f),
            ListGroupsForUserErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            ListGroupsForUserErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListGroupsForUserError {
    fn code(&self) -> Option<&str> {
        ListGroupsForUserError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListGroupsForUserError {
    pub fn new(kind: ListGroupsForUserErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListGroupsForUserErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListGroupsForUserErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_no_such_entity_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListGroupsForUserErrorKind::NoSuchEntityException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListGroupsForUserErrorKind::ServiceFailureException(_)
        )
    }
}
impl std::error::Error for ListGroupsForUserError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListGroupsForUserErrorKind::NoSuchEntityException(_inner) => Some(_inner),
            ListGroupsForUserErrorKind::ServiceFailureException(_inner) => Some(_inner),
            ListGroupsForUserErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListInstanceProfilesError {
    pub kind: ListInstanceProfilesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListInstanceProfilesErrorKind {
    ServiceFailureException(crate::error::ServiceFailureException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListInstanceProfilesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListInstanceProfilesErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            ListInstanceProfilesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListInstanceProfilesError {
    fn code(&self) -> Option<&str> {
        ListInstanceProfilesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListInstanceProfilesError {
    pub fn new(kind: ListInstanceProfilesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListInstanceProfilesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListInstanceProfilesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListInstanceProfilesErrorKind::ServiceFailureException(_)
        )
    }
}
impl std::error::Error for ListInstanceProfilesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListInstanceProfilesErrorKind::ServiceFailureException(_inner) => Some(_inner),
            ListInstanceProfilesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListInstanceProfilesForRoleError {
    pub kind: ListInstanceProfilesForRoleErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListInstanceProfilesForRoleErrorKind {
    NoSuchEntityException(crate::error::NoSuchEntityException),
    ServiceFailureException(crate::error::ServiceFailureException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListInstanceProfilesForRoleError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListInstanceProfilesForRoleErrorKind::NoSuchEntityException(_inner) => _inner.fmt(f),
            ListInstanceProfilesForRoleErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            ListInstanceProfilesForRoleErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListInstanceProfilesForRoleError {
    fn code(&self) -> Option<&str> {
        ListInstanceProfilesForRoleError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListInstanceProfilesForRoleError {
    pub fn new(kind: ListInstanceProfilesForRoleErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListInstanceProfilesForRoleErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListInstanceProfilesForRoleErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_no_such_entity_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListInstanceProfilesForRoleErrorKind::NoSuchEntityException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListInstanceProfilesForRoleErrorKind::ServiceFailureException(_)
        )
    }
}
impl std::error::Error for ListInstanceProfilesForRoleError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListInstanceProfilesForRoleErrorKind::NoSuchEntityException(_inner) => Some(_inner),
            ListInstanceProfilesForRoleErrorKind::ServiceFailureException(_inner) => Some(_inner),
            ListInstanceProfilesForRoleErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListInstanceProfileTagsError {
    pub kind: ListInstanceProfileTagsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListInstanceProfileTagsErrorKind {
    NoSuchEntityException(crate::error::NoSuchEntityException),
    ServiceFailureException(crate::error::ServiceFailureException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListInstanceProfileTagsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListInstanceProfileTagsErrorKind::NoSuchEntityException(_inner) => _inner.fmt(f),
            ListInstanceProfileTagsErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            ListInstanceProfileTagsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListInstanceProfileTagsError {
    fn code(&self) -> Option<&str> {
        ListInstanceProfileTagsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListInstanceProfileTagsError {
    pub fn new(kind: ListInstanceProfileTagsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListInstanceProfileTagsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListInstanceProfileTagsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_no_such_entity_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListInstanceProfileTagsErrorKind::NoSuchEntityException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListInstanceProfileTagsErrorKind::ServiceFailureException(_)
        )
    }
}
impl std::error::Error for ListInstanceProfileTagsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListInstanceProfileTagsErrorKind::NoSuchEntityException(_inner) => Some(_inner),
            ListInstanceProfileTagsErrorKind::ServiceFailureException(_inner) => Some(_inner),
            ListInstanceProfileTagsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListMFADevicesError {
    pub kind: ListMFADevicesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListMFADevicesErrorKind {
    NoSuchEntityException(crate::error::NoSuchEntityException),
    ServiceFailureException(crate::error::ServiceFailureException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListMFADevicesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListMFADevicesErrorKind::NoSuchEntityException(_inner) => _inner.fmt(f),
            ListMFADevicesErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            ListMFADevicesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListMFADevicesError {
    fn code(&self) -> Option<&str> {
        ListMFADevicesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListMFADevicesError {
    pub fn new(kind: ListMFADevicesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListMFADevicesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListMFADevicesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_no_such_entity_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListMFADevicesErrorKind::NoSuchEntityException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListMFADevicesErrorKind::ServiceFailureException(_)
        )
    }
}
impl std::error::Error for ListMFADevicesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListMFADevicesErrorKind::NoSuchEntityException(_inner) => Some(_inner),
            ListMFADevicesErrorKind::ServiceFailureException(_inner) => Some(_inner),
            ListMFADevicesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListMFADeviceTagsError {
    pub kind: ListMFADeviceTagsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListMFADeviceTagsErrorKind {
    InvalidInputException(crate::error::InvalidInputException),
    NoSuchEntityException(crate::error::NoSuchEntityException),
    ServiceFailureException(crate::error::ServiceFailureException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListMFADeviceTagsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListMFADeviceTagsErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            ListMFADeviceTagsErrorKind::NoSuchEntityException(_inner) => _inner.fmt(f),
            ListMFADeviceTagsErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            ListMFADeviceTagsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListMFADeviceTagsError {
    fn code(&self) -> Option<&str> {
        ListMFADeviceTagsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListMFADeviceTagsError {
    pub fn new(kind: ListMFADeviceTagsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListMFADeviceTagsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListMFADeviceTagsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListMFADeviceTagsErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_no_such_entity_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListMFADeviceTagsErrorKind::NoSuchEntityException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListMFADeviceTagsErrorKind::ServiceFailureException(_)
        )
    }
}
impl std::error::Error for ListMFADeviceTagsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListMFADeviceTagsErrorKind::InvalidInputException(_inner) => Some(_inner),
            ListMFADeviceTagsErrorKind::NoSuchEntityException(_inner) => Some(_inner),
            ListMFADeviceTagsErrorKind::ServiceFailureException(_inner) => Some(_inner),
            ListMFADeviceTagsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListOpenIDConnectProvidersError {
    pub kind: ListOpenIDConnectProvidersErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListOpenIDConnectProvidersErrorKind {
    ServiceFailureException(crate::error::ServiceFailureException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListOpenIDConnectProvidersError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListOpenIDConnectProvidersErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            ListOpenIDConnectProvidersErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListOpenIDConnectProvidersError {
    fn code(&self) -> Option<&str> {
        ListOpenIDConnectProvidersError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListOpenIDConnectProvidersError {
    pub fn new(kind: ListOpenIDConnectProvidersErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListOpenIDConnectProvidersErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListOpenIDConnectProvidersErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListOpenIDConnectProvidersErrorKind::ServiceFailureException(_)
        )
    }
}
impl std::error::Error for ListOpenIDConnectProvidersError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListOpenIDConnectProvidersErrorKind::ServiceFailureException(_inner) => Some(_inner),
            ListOpenIDConnectProvidersErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListOpenIDConnectProviderTagsError {
    pub kind: ListOpenIDConnectProviderTagsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListOpenIDConnectProviderTagsErrorKind {
    InvalidInputException(crate::error::InvalidInputException),
    NoSuchEntityException(crate::error::NoSuchEntityException),
    ServiceFailureException(crate::error::ServiceFailureException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListOpenIDConnectProviderTagsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListOpenIDConnectProviderTagsErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            ListOpenIDConnectProviderTagsErrorKind::NoSuchEntityException(_inner) => _inner.fmt(f),
            ListOpenIDConnectProviderTagsErrorKind::ServiceFailureException(_inner) => {
                _inner.fmt(f)
            }
            ListOpenIDConnectProviderTagsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListOpenIDConnectProviderTagsError {
    fn code(&self) -> Option<&str> {
        ListOpenIDConnectProviderTagsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListOpenIDConnectProviderTagsError {
    pub fn new(kind: ListOpenIDConnectProviderTagsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListOpenIDConnectProviderTagsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListOpenIDConnectProviderTagsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListOpenIDConnectProviderTagsErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_no_such_entity_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListOpenIDConnectProviderTagsErrorKind::NoSuchEntityException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListOpenIDConnectProviderTagsErrorKind::ServiceFailureException(_)
        )
    }
}
impl std::error::Error for ListOpenIDConnectProviderTagsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListOpenIDConnectProviderTagsErrorKind::InvalidInputException(_inner) => Some(_inner),
            ListOpenIDConnectProviderTagsErrorKind::NoSuchEntityException(_inner) => Some(_inner),
            ListOpenIDConnectProviderTagsErrorKind::ServiceFailureException(_inner) => Some(_inner),
            ListOpenIDConnectProviderTagsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListPoliciesError {
    pub kind: ListPoliciesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListPoliciesErrorKind {
    ServiceFailureException(crate::error::ServiceFailureException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListPoliciesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListPoliciesErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            ListPoliciesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListPoliciesError {
    fn code(&self) -> Option<&str> {
        ListPoliciesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListPoliciesError {
    pub fn new(kind: ListPoliciesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListPoliciesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListPoliciesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListPoliciesErrorKind::ServiceFailureException(_)
        )
    }
}
impl std::error::Error for ListPoliciesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListPoliciesErrorKind::ServiceFailureException(_inner) => Some(_inner),
            ListPoliciesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListPoliciesGrantingServiceAccessError {
    pub kind: ListPoliciesGrantingServiceAccessErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListPoliciesGrantingServiceAccessErrorKind {
    InvalidInputException(crate::error::InvalidInputException),
    NoSuchEntityException(crate::error::NoSuchEntityException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListPoliciesGrantingServiceAccessError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListPoliciesGrantingServiceAccessErrorKind::InvalidInputException(_inner) => {
                _inner.fmt(f)
            }
            ListPoliciesGrantingServiceAccessErrorKind::NoSuchEntityException(_inner) => {
                _inner.fmt(f)
            }
            ListPoliciesGrantingServiceAccessErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListPoliciesGrantingServiceAccessError {
    fn code(&self) -> Option<&str> {
        ListPoliciesGrantingServiceAccessError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListPoliciesGrantingServiceAccessError {
    pub fn new(
        kind: ListPoliciesGrantingServiceAccessErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListPoliciesGrantingServiceAccessErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListPoliciesGrantingServiceAccessErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListPoliciesGrantingServiceAccessErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_no_such_entity_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListPoliciesGrantingServiceAccessErrorKind::NoSuchEntityException(_)
        )
    }
}
impl std::error::Error for ListPoliciesGrantingServiceAccessError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListPoliciesGrantingServiceAccessErrorKind::InvalidInputException(_inner) => {
                Some(_inner)
            }
            ListPoliciesGrantingServiceAccessErrorKind::NoSuchEntityException(_inner) => {
                Some(_inner)
            }
            ListPoliciesGrantingServiceAccessErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListPolicyTagsError {
    pub kind: ListPolicyTagsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListPolicyTagsErrorKind {
    InvalidInputException(crate::error::InvalidInputException),
    NoSuchEntityException(crate::error::NoSuchEntityException),
    ServiceFailureException(crate::error::ServiceFailureException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListPolicyTagsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListPolicyTagsErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            ListPolicyTagsErrorKind::NoSuchEntityException(_inner) => _inner.fmt(f),
            ListPolicyTagsErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            ListPolicyTagsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListPolicyTagsError {
    fn code(&self) -> Option<&str> {
        ListPolicyTagsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListPolicyTagsError {
    pub fn new(kind: ListPolicyTagsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListPolicyTagsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListPolicyTagsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListPolicyTagsErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_no_such_entity_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListPolicyTagsErrorKind::NoSuchEntityException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListPolicyTagsErrorKind::ServiceFailureException(_)
        )
    }
}
impl std::error::Error for ListPolicyTagsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListPolicyTagsErrorKind::InvalidInputException(_inner) => Some(_inner),
            ListPolicyTagsErrorKind::NoSuchEntityException(_inner) => Some(_inner),
            ListPolicyTagsErrorKind::ServiceFailureException(_inner) => Some(_inner),
            ListPolicyTagsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListPolicyVersionsError {
    pub kind: ListPolicyVersionsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListPolicyVersionsErrorKind {
    InvalidInputException(crate::error::InvalidInputException),
    NoSuchEntityException(crate::error::NoSuchEntityException),
    ServiceFailureException(crate::error::ServiceFailureException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListPolicyVersionsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListPolicyVersionsErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            ListPolicyVersionsErrorKind::NoSuchEntityException(_inner) => _inner.fmt(f),
            ListPolicyVersionsErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            ListPolicyVersionsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListPolicyVersionsError {
    fn code(&self) -> Option<&str> {
        ListPolicyVersionsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListPolicyVersionsError {
    pub fn new(kind: ListPolicyVersionsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListPolicyVersionsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListPolicyVersionsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListPolicyVersionsErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_no_such_entity_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListPolicyVersionsErrorKind::NoSuchEntityException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListPolicyVersionsErrorKind::ServiceFailureException(_)
        )
    }
}
impl std::error::Error for ListPolicyVersionsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListPolicyVersionsErrorKind::InvalidInputException(_inner) => Some(_inner),
            ListPolicyVersionsErrorKind::NoSuchEntityException(_inner) => Some(_inner),
            ListPolicyVersionsErrorKind::ServiceFailureException(_inner) => Some(_inner),
            ListPolicyVersionsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListRolePoliciesError {
    pub kind: ListRolePoliciesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListRolePoliciesErrorKind {
    NoSuchEntityException(crate::error::NoSuchEntityException),
    ServiceFailureException(crate::error::ServiceFailureException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListRolePoliciesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListRolePoliciesErrorKind::NoSuchEntityException(_inner) => _inner.fmt(f),
            ListRolePoliciesErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            ListRolePoliciesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListRolePoliciesError {
    fn code(&self) -> Option<&str> {
        ListRolePoliciesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListRolePoliciesError {
    pub fn new(kind: ListRolePoliciesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListRolePoliciesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListRolePoliciesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_no_such_entity_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListRolePoliciesErrorKind::NoSuchEntityException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListRolePoliciesErrorKind::ServiceFailureException(_)
        )
    }
}
impl std::error::Error for ListRolePoliciesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListRolePoliciesErrorKind::NoSuchEntityException(_inner) => Some(_inner),
            ListRolePoliciesErrorKind::ServiceFailureException(_inner) => Some(_inner),
            ListRolePoliciesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListRolesError {
    pub kind: ListRolesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListRolesErrorKind {
    ServiceFailureException(crate::error::ServiceFailureException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListRolesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListRolesErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            ListRolesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListRolesError {
    fn code(&self) -> Option<&str> {
        ListRolesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListRolesError {
    pub fn new(kind: ListRolesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListRolesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListRolesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(&self.kind, ListRolesErrorKind::ServiceFailureException(_))
    }
}
impl std::error::Error for ListRolesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListRolesErrorKind::ServiceFailureException(_inner) => Some(_inner),
            ListRolesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListRoleTagsError {
    pub kind: ListRoleTagsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListRoleTagsErrorKind {
    NoSuchEntityException(crate::error::NoSuchEntityException),
    ServiceFailureException(crate::error::ServiceFailureException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListRoleTagsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListRoleTagsErrorKind::NoSuchEntityException(_inner) => _inner.fmt(f),
            ListRoleTagsErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            ListRoleTagsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListRoleTagsError {
    fn code(&self) -> Option<&str> {
        ListRoleTagsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListRoleTagsError {
    pub fn new(kind: ListRoleTagsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListRoleTagsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListRoleTagsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_no_such_entity_exception(&self) -> bool {
        matches!(&self.kind, ListRoleTagsErrorKind::NoSuchEntityException(_))
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListRoleTagsErrorKind::ServiceFailureException(_)
        )
    }
}
impl std::error::Error for ListRoleTagsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListRoleTagsErrorKind::NoSuchEntityException(_inner) => Some(_inner),
            ListRoleTagsErrorKind::ServiceFailureException(_inner) => Some(_inner),
            ListRoleTagsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListSAMLProvidersError {
    pub kind: ListSAMLProvidersErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListSAMLProvidersErrorKind {
    ServiceFailureException(crate::error::ServiceFailureException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListSAMLProvidersError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListSAMLProvidersErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            ListSAMLProvidersErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListSAMLProvidersError {
    fn code(&self) -> Option<&str> {
        ListSAMLProvidersError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListSAMLProvidersError {
    pub fn new(kind: ListSAMLProvidersErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListSAMLProvidersErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListSAMLProvidersErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListSAMLProvidersErrorKind::ServiceFailureException(_)
        )
    }
}
impl std::error::Error for ListSAMLProvidersError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListSAMLProvidersErrorKind::ServiceFailureException(_inner) => Some(_inner),
            ListSAMLProvidersErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListSAMLProviderTagsError {
    pub kind: ListSAMLProviderTagsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListSAMLProviderTagsErrorKind {
    InvalidInputException(crate::error::InvalidInputException),
    NoSuchEntityException(crate::error::NoSuchEntityException),
    ServiceFailureException(crate::error::ServiceFailureException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListSAMLProviderTagsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListSAMLProviderTagsErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            ListSAMLProviderTagsErrorKind::NoSuchEntityException(_inner) => _inner.fmt(f),
            ListSAMLProviderTagsErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            ListSAMLProviderTagsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListSAMLProviderTagsError {
    fn code(&self) -> Option<&str> {
        ListSAMLProviderTagsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListSAMLProviderTagsError {
    pub fn new(kind: ListSAMLProviderTagsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListSAMLProviderTagsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListSAMLProviderTagsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListSAMLProviderTagsErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_no_such_entity_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListSAMLProviderTagsErrorKind::NoSuchEntityException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListSAMLProviderTagsErrorKind::ServiceFailureException(_)
        )
    }
}
impl std::error::Error for ListSAMLProviderTagsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListSAMLProviderTagsErrorKind::InvalidInputException(_inner) => Some(_inner),
            ListSAMLProviderTagsErrorKind::NoSuchEntityException(_inner) => Some(_inner),
            ListSAMLProviderTagsErrorKind::ServiceFailureException(_inner) => Some(_inner),
            ListSAMLProviderTagsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListServerCertificatesError {
    pub kind: ListServerCertificatesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListServerCertificatesErrorKind {
    ServiceFailureException(crate::error::ServiceFailureException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListServerCertificatesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListServerCertificatesErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            ListServerCertificatesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListServerCertificatesError {
    fn code(&self) -> Option<&str> {
        ListServerCertificatesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListServerCertificatesError {
    pub fn new(kind: ListServerCertificatesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListServerCertificatesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListServerCertificatesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListServerCertificatesErrorKind::ServiceFailureException(_)
        )
    }
}
impl std::error::Error for ListServerCertificatesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListServerCertificatesErrorKind::ServiceFailureException(_inner) => Some(_inner),
            ListServerCertificatesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListServerCertificateTagsError {
    pub kind: ListServerCertificateTagsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListServerCertificateTagsErrorKind {
    NoSuchEntityException(crate::error::NoSuchEntityException),
    ServiceFailureException(crate::error::ServiceFailureException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListServerCertificateTagsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListServerCertificateTagsErrorKind::NoSuchEntityException(_inner) => _inner.fmt(f),
            ListServerCertificateTagsErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            ListServerCertificateTagsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListServerCertificateTagsError {
    fn code(&self) -> Option<&str> {
        ListServerCertificateTagsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListServerCertificateTagsError {
    pub fn new(kind: ListServerCertificateTagsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListServerCertificateTagsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListServerCertificateTagsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_no_such_entity_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListServerCertificateTagsErrorKind::NoSuchEntityException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListServerCertificateTagsErrorKind::ServiceFailureException(_)
        )
    }
}
impl std::error::Error for ListServerCertificateTagsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListServerCertificateTagsErrorKind::NoSuchEntityException(_inner) => Some(_inner),
            ListServerCertificateTagsErrorKind::ServiceFailureException(_inner) => Some(_inner),
            ListServerCertificateTagsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListServiceSpecificCredentialsError {
    pub kind: ListServiceSpecificCredentialsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListServiceSpecificCredentialsErrorKind {
    NoSuchEntityException(crate::error::NoSuchEntityException),
    ServiceNotSupportedException(crate::error::ServiceNotSupportedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListServiceSpecificCredentialsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListServiceSpecificCredentialsErrorKind::NoSuchEntityException(_inner) => _inner.fmt(f),
            ListServiceSpecificCredentialsErrorKind::ServiceNotSupportedException(_inner) => {
                _inner.fmt(f)
            }
            ListServiceSpecificCredentialsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListServiceSpecificCredentialsError {
    fn code(&self) -> Option<&str> {
        ListServiceSpecificCredentialsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListServiceSpecificCredentialsError {
    pub fn new(kind: ListServiceSpecificCredentialsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListServiceSpecificCredentialsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListServiceSpecificCredentialsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_no_such_entity_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListServiceSpecificCredentialsErrorKind::NoSuchEntityException(_)
        )
    }
    pub fn is_service_not_supported_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListServiceSpecificCredentialsErrorKind::ServiceNotSupportedException(_)
        )
    }
}
impl std::error::Error for ListServiceSpecificCredentialsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListServiceSpecificCredentialsErrorKind::NoSuchEntityException(_inner) => Some(_inner),
            ListServiceSpecificCredentialsErrorKind::ServiceNotSupportedException(_inner) => {
                Some(_inner)
            }
            ListServiceSpecificCredentialsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListSigningCertificatesError {
    pub kind: ListSigningCertificatesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListSigningCertificatesErrorKind {
    NoSuchEntityException(crate::error::NoSuchEntityException),
    ServiceFailureException(crate::error::ServiceFailureException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListSigningCertificatesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListSigningCertificatesErrorKind::NoSuchEntityException(_inner) => _inner.fmt(f),
            ListSigningCertificatesErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            ListSigningCertificatesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListSigningCertificatesError {
    fn code(&self) -> Option<&str> {
        ListSigningCertificatesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListSigningCertificatesError {
    pub fn new(kind: ListSigningCertificatesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListSigningCertificatesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListSigningCertificatesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_no_such_entity_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListSigningCertificatesErrorKind::NoSuchEntityException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListSigningCertificatesErrorKind::ServiceFailureException(_)
        )
    }
}
impl std::error::Error for ListSigningCertificatesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListSigningCertificatesErrorKind::NoSuchEntityException(_inner) => Some(_inner),
            ListSigningCertificatesErrorKind::ServiceFailureException(_inner) => Some(_inner),
            ListSigningCertificatesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListSSHPublicKeysError {
    pub kind: ListSSHPublicKeysErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListSSHPublicKeysErrorKind {
    NoSuchEntityException(crate::error::NoSuchEntityException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListSSHPublicKeysError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListSSHPublicKeysErrorKind::NoSuchEntityException(_inner) => _inner.fmt(f),
            ListSSHPublicKeysErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListSSHPublicKeysError {
    fn code(&self) -> Option<&str> {
        ListSSHPublicKeysError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListSSHPublicKeysError {
    pub fn new(kind: ListSSHPublicKeysErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListSSHPublicKeysErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListSSHPublicKeysErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_no_such_entity_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListSSHPublicKeysErrorKind::NoSuchEntityException(_)
        )
    }
}
impl std::error::Error for ListSSHPublicKeysError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListSSHPublicKeysErrorKind::NoSuchEntityException(_inner) => Some(_inner),
            ListSSHPublicKeysErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListUserPoliciesError {
    pub kind: ListUserPoliciesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListUserPoliciesErrorKind {
    NoSuchEntityException(crate::error::NoSuchEntityException),
    ServiceFailureException(crate::error::ServiceFailureException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListUserPoliciesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListUserPoliciesErrorKind::NoSuchEntityException(_inner) => _inner.fmt(f),
            ListUserPoliciesErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            ListUserPoliciesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListUserPoliciesError {
    fn code(&self) -> Option<&str> {
        ListUserPoliciesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListUserPoliciesError {
    pub fn new(kind: ListUserPoliciesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListUserPoliciesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListUserPoliciesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_no_such_entity_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListUserPoliciesErrorKind::NoSuchEntityException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListUserPoliciesErrorKind::ServiceFailureException(_)
        )
    }
}
impl std::error::Error for ListUserPoliciesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListUserPoliciesErrorKind::NoSuchEntityException(_inner) => Some(_inner),
            ListUserPoliciesErrorKind::ServiceFailureException(_inner) => Some(_inner),
            ListUserPoliciesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListUsersError {
    pub kind: ListUsersErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListUsersErrorKind {
    ServiceFailureException(crate::error::ServiceFailureException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListUsersError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListUsersErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            ListUsersErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListUsersError {
    fn code(&self) -> Option<&str> {
        ListUsersError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListUsersError {
    pub fn new(kind: ListUsersErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListUsersErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListUsersErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(&self.kind, ListUsersErrorKind::ServiceFailureException(_))
    }
}
impl std::error::Error for ListUsersError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListUsersErrorKind::ServiceFailureException(_inner) => Some(_inner),
            ListUsersErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListUserTagsError {
    pub kind: ListUserTagsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListUserTagsErrorKind {
    NoSuchEntityException(crate::error::NoSuchEntityException),
    ServiceFailureException(crate::error::ServiceFailureException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListUserTagsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListUserTagsErrorKind::NoSuchEntityException(_inner) => _inner.fmt(f),
            ListUserTagsErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            ListUserTagsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListUserTagsError {
    fn code(&self) -> Option<&str> {
        ListUserTagsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListUserTagsError {
    pub fn new(kind: ListUserTagsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListUserTagsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListUserTagsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_no_such_entity_exception(&self) -> bool {
        matches!(&self.kind, ListUserTagsErrorKind::NoSuchEntityException(_))
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListUserTagsErrorKind::ServiceFailureException(_)
        )
    }
}
impl std::error::Error for ListUserTagsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListUserTagsErrorKind::NoSuchEntityException(_inner) => Some(_inner),
            ListUserTagsErrorKind::ServiceFailureException(_inner) => Some(_inner),
            ListUserTagsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListVirtualMFADevicesError {
    pub kind: ListVirtualMFADevicesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListVirtualMFADevicesErrorKind {
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListVirtualMFADevicesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListVirtualMFADevicesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListVirtualMFADevicesError {
    fn code(&self) -> Option<&str> {
        ListVirtualMFADevicesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListVirtualMFADevicesError {
    pub fn new(kind: ListVirtualMFADevicesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListVirtualMFADevicesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListVirtualMFADevicesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
}
impl std::error::Error for ListVirtualMFADevicesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListVirtualMFADevicesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct PutGroupPolicyError {
    pub kind: PutGroupPolicyErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum PutGroupPolicyErrorKind {
    LimitExceededException(crate::error::LimitExceededException),
    MalformedPolicyDocumentException(crate::error::MalformedPolicyDocumentException),
    NoSuchEntityException(crate::error::NoSuchEntityException),
    ServiceFailureException(crate::error::ServiceFailureException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for PutGroupPolicyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            PutGroupPolicyErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            PutGroupPolicyErrorKind::MalformedPolicyDocumentException(_inner) => _inner.fmt(f),
            PutGroupPolicyErrorKind::NoSuchEntityException(_inner) => _inner.fmt(f),
            PutGroupPolicyErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            PutGroupPolicyErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for PutGroupPolicyError {
    fn code(&self) -> Option<&str> {
        PutGroupPolicyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl PutGroupPolicyError {
    pub fn new(kind: PutGroupPolicyErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: PutGroupPolicyErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: PutGroupPolicyErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutGroupPolicyErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_malformed_policy_document_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutGroupPolicyErrorKind::MalformedPolicyDocumentException(_)
        )
    }
    pub fn is_no_such_entity_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutGroupPolicyErrorKind::NoSuchEntityException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutGroupPolicyErrorKind::ServiceFailureException(_)
        )
    }
}
impl std::error::Error for PutGroupPolicyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            PutGroupPolicyErrorKind::LimitExceededException(_inner) => Some(_inner),
            PutGroupPolicyErrorKind::MalformedPolicyDocumentException(_inner) => Some(_inner),
            PutGroupPolicyErrorKind::NoSuchEntityException(_inner) => Some(_inner),
            PutGroupPolicyErrorKind::ServiceFailureException(_inner) => Some(_inner),
            PutGroupPolicyErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct PutRolePermissionsBoundaryError {
    pub kind: PutRolePermissionsBoundaryErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum PutRolePermissionsBoundaryErrorKind {
    InvalidInputException(crate::error::InvalidInputException),
    NoSuchEntityException(crate::error::NoSuchEntityException),
    PolicyNotAttachableException(crate::error::PolicyNotAttachableException),
    ServiceFailureException(crate::error::ServiceFailureException),
    UnmodifiableEntityException(crate::error::UnmodifiableEntityException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for PutRolePermissionsBoundaryError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            PutRolePermissionsBoundaryErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            PutRolePermissionsBoundaryErrorKind::NoSuchEntityException(_inner) => _inner.fmt(f),
            PutRolePermissionsBoundaryErrorKind::PolicyNotAttachableException(_inner) => {
                _inner.fmt(f)
            }
            PutRolePermissionsBoundaryErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            PutRolePermissionsBoundaryErrorKind::UnmodifiableEntityException(_inner) => {
                _inner.fmt(f)
            }
            PutRolePermissionsBoundaryErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for PutRolePermissionsBoundaryError {
    fn code(&self) -> Option<&str> {
        PutRolePermissionsBoundaryError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl PutRolePermissionsBoundaryError {
    pub fn new(kind: PutRolePermissionsBoundaryErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: PutRolePermissionsBoundaryErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: PutRolePermissionsBoundaryErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutRolePermissionsBoundaryErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_no_such_entity_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutRolePermissionsBoundaryErrorKind::NoSuchEntityException(_)
        )
    }
    pub fn is_policy_not_attachable_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutRolePermissionsBoundaryErrorKind::PolicyNotAttachableException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutRolePermissionsBoundaryErrorKind::ServiceFailureException(_)
        )
    }
    pub fn is_unmodifiable_entity_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutRolePermissionsBoundaryErrorKind::UnmodifiableEntityException(_)
        )
    }
}
impl std::error::Error for PutRolePermissionsBoundaryError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            PutRolePermissionsBoundaryErrorKind::InvalidInputException(_inner) => Some(_inner),
            PutRolePermissionsBoundaryErrorKind::NoSuchEntityException(_inner) => Some(_inner),
            PutRolePermissionsBoundaryErrorKind::PolicyNotAttachableException(_inner) => {
                Some(_inner)
            }
            PutRolePermissionsBoundaryErrorKind::ServiceFailureException(_inner) => Some(_inner),
            PutRolePermissionsBoundaryErrorKind::UnmodifiableEntityException(_inner) => {
                Some(_inner)
            }
            PutRolePermissionsBoundaryErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct PutRolePolicyError {
    pub kind: PutRolePolicyErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum PutRolePolicyErrorKind {
    LimitExceededException(crate::error::LimitExceededException),
    MalformedPolicyDocumentException(crate::error::MalformedPolicyDocumentException),
    NoSuchEntityException(crate::error::NoSuchEntityException),
    ServiceFailureException(crate::error::ServiceFailureException),
    UnmodifiableEntityException(crate::error::UnmodifiableEntityException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for PutRolePolicyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            PutRolePolicyErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            PutRolePolicyErrorKind::MalformedPolicyDocumentException(_inner) => _inner.fmt(f),
            PutRolePolicyErrorKind::NoSuchEntityException(_inner) => _inner.fmt(f),
            PutRolePolicyErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            PutRolePolicyErrorKind::UnmodifiableEntityException(_inner) => _inner.fmt(f),
            PutRolePolicyErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for PutRolePolicyError {
    fn code(&self) -> Option<&str> {
        PutRolePolicyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl PutRolePolicyError {
    pub fn new(kind: PutRolePolicyErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: PutRolePolicyErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: PutRolePolicyErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutRolePolicyErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_malformed_policy_document_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutRolePolicyErrorKind::MalformedPolicyDocumentException(_)
        )
    }
    pub fn is_no_such_entity_exception(&self) -> bool {
        matches!(&self.kind, PutRolePolicyErrorKind::NoSuchEntityException(_))
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutRolePolicyErrorKind::ServiceFailureException(_)
        )
    }
    pub fn is_unmodifiable_entity_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutRolePolicyErrorKind::UnmodifiableEntityException(_)
        )
    }
}
impl std::error::Error for PutRolePolicyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            PutRolePolicyErrorKind::LimitExceededException(_inner) => Some(_inner),
            PutRolePolicyErrorKind::MalformedPolicyDocumentException(_inner) => Some(_inner),
            PutRolePolicyErrorKind::NoSuchEntityException(_inner) => Some(_inner),
            PutRolePolicyErrorKind::ServiceFailureException(_inner) => Some(_inner),
            PutRolePolicyErrorKind::UnmodifiableEntityException(_inner) => Some(_inner),
            PutRolePolicyErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct PutUserPermissionsBoundaryError {
    pub kind: PutUserPermissionsBoundaryErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum PutUserPermissionsBoundaryErrorKind {
    InvalidInputException(crate::error::InvalidInputException),
    NoSuchEntityException(crate::error::NoSuchEntityException),
    PolicyNotAttachableException(crate::error::PolicyNotAttachableException),
    ServiceFailureException(crate::error::ServiceFailureException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for PutUserPermissionsBoundaryError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            PutUserPermissionsBoundaryErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            PutUserPermissionsBoundaryErrorKind::NoSuchEntityException(_inner) => _inner.fmt(f),
            PutUserPermissionsBoundaryErrorKind::PolicyNotAttachableException(_inner) => {
                _inner.fmt(f)
            }
            PutUserPermissionsBoundaryErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            PutUserPermissionsBoundaryErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for PutUserPermissionsBoundaryError {
    fn code(&self) -> Option<&str> {
        PutUserPermissionsBoundaryError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl PutUserPermissionsBoundaryError {
    pub fn new(kind: PutUserPermissionsBoundaryErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: PutUserPermissionsBoundaryErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: PutUserPermissionsBoundaryErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutUserPermissionsBoundaryErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_no_such_entity_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutUserPermissionsBoundaryErrorKind::NoSuchEntityException(_)
        )
    }
    pub fn is_policy_not_attachable_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutUserPermissionsBoundaryErrorKind::PolicyNotAttachableException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutUserPermissionsBoundaryErrorKind::ServiceFailureException(_)
        )
    }
}
impl std::error::Error for PutUserPermissionsBoundaryError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            PutUserPermissionsBoundaryErrorKind::InvalidInputException(_inner) => Some(_inner),
            PutUserPermissionsBoundaryErrorKind::NoSuchEntityException(_inner) => Some(_inner),
            PutUserPermissionsBoundaryErrorKind::PolicyNotAttachableException(_inner) => {
                Some(_inner)
            }
            PutUserPermissionsBoundaryErrorKind::ServiceFailureException(_inner) => Some(_inner),
            PutUserPermissionsBoundaryErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct PutUserPolicyError {
    pub kind: PutUserPolicyErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum PutUserPolicyErrorKind {
    LimitExceededException(crate::error::LimitExceededException),
    MalformedPolicyDocumentException(crate::error::MalformedPolicyDocumentException),
    NoSuchEntityException(crate::error::NoSuchEntityException),
    ServiceFailureException(crate::error::ServiceFailureException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for PutUserPolicyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            PutUserPolicyErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            PutUserPolicyErrorKind::MalformedPolicyDocumentException(_inner) => _inner.fmt(f),
            PutUserPolicyErrorKind::NoSuchEntityException(_inner) => _inner.fmt(f),
            PutUserPolicyErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            PutUserPolicyErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for PutUserPolicyError {
    fn code(&self) -> Option<&str> {
        PutUserPolicyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl PutUserPolicyError {
    pub fn new(kind: PutUserPolicyErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: PutUserPolicyErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: PutUserPolicyErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutUserPolicyErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_malformed_policy_document_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutUserPolicyErrorKind::MalformedPolicyDocumentException(_)
        )
    }
    pub fn is_no_such_entity_exception(&self) -> bool {
        matches!(&self.kind, PutUserPolicyErrorKind::NoSuchEntityException(_))
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutUserPolicyErrorKind::ServiceFailureException(_)
        )
    }
}
impl std::error::Error for PutUserPolicyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            PutUserPolicyErrorKind::LimitExceededException(_inner) => Some(_inner),
            PutUserPolicyErrorKind::MalformedPolicyDocumentException(_inner) => Some(_inner),
            PutUserPolicyErrorKind::NoSuchEntityException(_inner) => Some(_inner),
            PutUserPolicyErrorKind::ServiceFailureException(_inner) => Some(_inner),
            PutUserPolicyErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct RemoveClientIDFromOpenIDConnectProviderError {
    pub kind: RemoveClientIDFromOpenIDConnectProviderErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum RemoveClientIDFromOpenIDConnectProviderErrorKind {
    InvalidInputException(crate::error::InvalidInputException),
    NoSuchEntityException(crate::error::NoSuchEntityException),
    ServiceFailureException(crate::error::ServiceFailureException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for RemoveClientIDFromOpenIDConnectProviderError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            RemoveClientIDFromOpenIDConnectProviderErrorKind::InvalidInputException(_inner) => {
                _inner.fmt(f)
            }
            RemoveClientIDFromOpenIDConnectProviderErrorKind::NoSuchEntityException(_inner) => {
                _inner.fmt(f)
            }
            RemoveClientIDFromOpenIDConnectProviderErrorKind::ServiceFailureException(_inner) => {
                _inner.fmt(f)
            }
            RemoveClientIDFromOpenIDConnectProviderErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for RemoveClientIDFromOpenIDConnectProviderError {
    fn code(&self) -> Option<&str> {
        RemoveClientIDFromOpenIDConnectProviderError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl RemoveClientIDFromOpenIDConnectProviderError {
    pub fn new(
        kind: RemoveClientIDFromOpenIDConnectProviderErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: RemoveClientIDFromOpenIDConnectProviderErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: RemoveClientIDFromOpenIDConnectProviderErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            RemoveClientIDFromOpenIDConnectProviderErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_no_such_entity_exception(&self) -> bool {
        matches!(
            &self.kind,
            RemoveClientIDFromOpenIDConnectProviderErrorKind::NoSuchEntityException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            RemoveClientIDFromOpenIDConnectProviderErrorKind::ServiceFailureException(_)
        )
    }
}
impl std::error::Error for RemoveClientIDFromOpenIDConnectProviderError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            RemoveClientIDFromOpenIDConnectProviderErrorKind::InvalidInputException(_inner) => {
                Some(_inner)
            }
            RemoveClientIDFromOpenIDConnectProviderErrorKind::NoSuchEntityException(_inner) => {
                Some(_inner)
            }
            RemoveClientIDFromOpenIDConnectProviderErrorKind::ServiceFailureException(_inner) => {
                Some(_inner)
            }
            RemoveClientIDFromOpenIDConnectProviderErrorKind::Unhandled(_inner) => {
                Some(_inner.as_ref())
            }
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct RemoveRoleFromInstanceProfileError {
    pub kind: RemoveRoleFromInstanceProfileErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum RemoveRoleFromInstanceProfileErrorKind {
    LimitExceededException(crate::error::LimitExceededException),
    NoSuchEntityException(crate::error::NoSuchEntityException),
    ServiceFailureException(crate::error::ServiceFailureException),
    UnmodifiableEntityException(crate::error::UnmodifiableEntityException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for RemoveRoleFromInstanceProfileError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            RemoveRoleFromInstanceProfileErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            RemoveRoleFromInstanceProfileErrorKind::NoSuchEntityException(_inner) => _inner.fmt(f),
            RemoveRoleFromInstanceProfileErrorKind::ServiceFailureException(_inner) => {
                _inner.fmt(f)
            }
            RemoveRoleFromInstanceProfileErrorKind::UnmodifiableEntityException(_inner) => {
                _inner.fmt(f)
            }
            RemoveRoleFromInstanceProfileErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for RemoveRoleFromInstanceProfileError {
    fn code(&self) -> Option<&str> {
        RemoveRoleFromInstanceProfileError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl RemoveRoleFromInstanceProfileError {
    pub fn new(kind: RemoveRoleFromInstanceProfileErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: RemoveRoleFromInstanceProfileErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: RemoveRoleFromInstanceProfileErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            RemoveRoleFromInstanceProfileErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_no_such_entity_exception(&self) -> bool {
        matches!(
            &self.kind,
            RemoveRoleFromInstanceProfileErrorKind::NoSuchEntityException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            RemoveRoleFromInstanceProfileErrorKind::ServiceFailureException(_)
        )
    }
    pub fn is_unmodifiable_entity_exception(&self) -> bool {
        matches!(
            &self.kind,
            RemoveRoleFromInstanceProfileErrorKind::UnmodifiableEntityException(_)
        )
    }
}
impl std::error::Error for RemoveRoleFromInstanceProfileError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            RemoveRoleFromInstanceProfileErrorKind::LimitExceededException(_inner) => Some(_inner),
            RemoveRoleFromInstanceProfileErrorKind::NoSuchEntityException(_inner) => Some(_inner),
            RemoveRoleFromInstanceProfileErrorKind::ServiceFailureException(_inner) => Some(_inner),
            RemoveRoleFromInstanceProfileErrorKind::UnmodifiableEntityException(_inner) => {
                Some(_inner)
            }
            RemoveRoleFromInstanceProfileErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct RemoveUserFromGroupError {
    pub kind: RemoveUserFromGroupErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum RemoveUserFromGroupErrorKind {
    LimitExceededException(crate::error::LimitExceededException),
    NoSuchEntityException(crate::error::NoSuchEntityException),
    ServiceFailureException(crate::error::ServiceFailureException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for RemoveUserFromGroupError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            RemoveUserFromGroupErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            RemoveUserFromGroupErrorKind::NoSuchEntityException(_inner) => _inner.fmt(f),
            RemoveUserFromGroupErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            RemoveUserFromGroupErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for RemoveUserFromGroupError {
    fn code(&self) -> Option<&str> {
        RemoveUserFromGroupError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl RemoveUserFromGroupError {
    pub fn new(kind: RemoveUserFromGroupErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: RemoveUserFromGroupErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: RemoveUserFromGroupErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            RemoveUserFromGroupErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_no_such_entity_exception(&self) -> bool {
        matches!(
            &self.kind,
            RemoveUserFromGroupErrorKind::NoSuchEntityException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            RemoveUserFromGroupErrorKind::ServiceFailureException(_)
        )
    }
}
impl std::error::Error for RemoveUserFromGroupError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            RemoveUserFromGroupErrorKind::LimitExceededException(_inner) => Some(_inner),
            RemoveUserFromGroupErrorKind::NoSuchEntityException(_inner) => Some(_inner),
            RemoveUserFromGroupErrorKind::ServiceFailureException(_inner) => Some(_inner),
            RemoveUserFromGroupErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ResetServiceSpecificCredentialError {
    pub kind: ResetServiceSpecificCredentialErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ResetServiceSpecificCredentialErrorKind {
    NoSuchEntityException(crate::error::NoSuchEntityException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ResetServiceSpecificCredentialError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ResetServiceSpecificCredentialErrorKind::NoSuchEntityException(_inner) => _inner.fmt(f),
            ResetServiceSpecificCredentialErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ResetServiceSpecificCredentialError {
    fn code(&self) -> Option<&str> {
        ResetServiceSpecificCredentialError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ResetServiceSpecificCredentialError {
    pub fn new(kind: ResetServiceSpecificCredentialErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ResetServiceSpecificCredentialErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ResetServiceSpecificCredentialErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_no_such_entity_exception(&self) -> bool {
        matches!(
            &self.kind,
            ResetServiceSpecificCredentialErrorKind::NoSuchEntityException(_)
        )
    }
}
impl std::error::Error for ResetServiceSpecificCredentialError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ResetServiceSpecificCredentialErrorKind::NoSuchEntityException(_inner) => Some(_inner),
            ResetServiceSpecificCredentialErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ResyncMFADeviceError {
    pub kind: ResyncMFADeviceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ResyncMFADeviceErrorKind {
    InvalidAuthenticationCodeException(crate::error::InvalidAuthenticationCodeException),
    LimitExceededException(crate::error::LimitExceededException),
    NoSuchEntityException(crate::error::NoSuchEntityException),
    ServiceFailureException(crate::error::ServiceFailureException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ResyncMFADeviceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ResyncMFADeviceErrorKind::InvalidAuthenticationCodeException(_inner) => _inner.fmt(f),
            ResyncMFADeviceErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            ResyncMFADeviceErrorKind::NoSuchEntityException(_inner) => _inner.fmt(f),
            ResyncMFADeviceErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            ResyncMFADeviceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ResyncMFADeviceError {
    fn code(&self) -> Option<&str> {
        ResyncMFADeviceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ResyncMFADeviceError {
    pub fn new(kind: ResyncMFADeviceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ResyncMFADeviceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ResyncMFADeviceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_authentication_code_exception(&self) -> bool {
        matches!(
            &self.kind,
            ResyncMFADeviceErrorKind::InvalidAuthenticationCodeException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            ResyncMFADeviceErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_no_such_entity_exception(&self) -> bool {
        matches!(
            &self.kind,
            ResyncMFADeviceErrorKind::NoSuchEntityException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            ResyncMFADeviceErrorKind::ServiceFailureException(_)
        )
    }
}
impl std::error::Error for ResyncMFADeviceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ResyncMFADeviceErrorKind::InvalidAuthenticationCodeException(_inner) => Some(_inner),
            ResyncMFADeviceErrorKind::LimitExceededException(_inner) => Some(_inner),
            ResyncMFADeviceErrorKind::NoSuchEntityException(_inner) => Some(_inner),
            ResyncMFADeviceErrorKind::ServiceFailureException(_inner) => Some(_inner),
            ResyncMFADeviceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct SetDefaultPolicyVersionError {
    pub kind: SetDefaultPolicyVersionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum SetDefaultPolicyVersionErrorKind {
    InvalidInputException(crate::error::InvalidInputException),
    LimitExceededException(crate::error::LimitExceededException),
    NoSuchEntityException(crate::error::NoSuchEntityException),
    ServiceFailureException(crate::error::ServiceFailureException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for SetDefaultPolicyVersionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            SetDefaultPolicyVersionErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            SetDefaultPolicyVersionErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            SetDefaultPolicyVersionErrorKind::NoSuchEntityException(_inner) => _inner.fmt(f),
            SetDefaultPolicyVersionErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            SetDefaultPolicyVersionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for SetDefaultPolicyVersionError {
    fn code(&self) -> Option<&str> {
        SetDefaultPolicyVersionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl SetDefaultPolicyVersionError {
    pub fn new(kind: SetDefaultPolicyVersionErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: SetDefaultPolicyVersionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: SetDefaultPolicyVersionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            SetDefaultPolicyVersionErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            SetDefaultPolicyVersionErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_no_such_entity_exception(&self) -> bool {
        matches!(
            &self.kind,
            SetDefaultPolicyVersionErrorKind::NoSuchEntityException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            SetDefaultPolicyVersionErrorKind::ServiceFailureException(_)
        )
    }
}
impl std::error::Error for SetDefaultPolicyVersionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            SetDefaultPolicyVersionErrorKind::InvalidInputException(_inner) => Some(_inner),
            SetDefaultPolicyVersionErrorKind::LimitExceededException(_inner) => Some(_inner),
            SetDefaultPolicyVersionErrorKind::NoSuchEntityException(_inner) => Some(_inner),
            SetDefaultPolicyVersionErrorKind::ServiceFailureException(_inner) => Some(_inner),
            SetDefaultPolicyVersionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct SetSecurityTokenServicePreferencesError {
    pub kind: SetSecurityTokenServicePreferencesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum SetSecurityTokenServicePreferencesErrorKind {
    ServiceFailureException(crate::error::ServiceFailureException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for SetSecurityTokenServicePreferencesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            SetSecurityTokenServicePreferencesErrorKind::ServiceFailureException(_inner) => {
                _inner.fmt(f)
            }
            SetSecurityTokenServicePreferencesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for SetSecurityTokenServicePreferencesError {
    fn code(&self) -> Option<&str> {
        SetSecurityTokenServicePreferencesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl SetSecurityTokenServicePreferencesError {
    pub fn new(
        kind: SetSecurityTokenServicePreferencesErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: SetSecurityTokenServicePreferencesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: SetSecurityTokenServicePreferencesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            SetSecurityTokenServicePreferencesErrorKind::ServiceFailureException(_)
        )
    }
}
impl std::error::Error for SetSecurityTokenServicePreferencesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            SetSecurityTokenServicePreferencesErrorKind::ServiceFailureException(_inner) => {
                Some(_inner)
            }
            SetSecurityTokenServicePreferencesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct SimulateCustomPolicyError {
    pub kind: SimulateCustomPolicyErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum SimulateCustomPolicyErrorKind {
    InvalidInputException(crate::error::InvalidInputException),
    PolicyEvaluationException(crate::error::PolicyEvaluationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for SimulateCustomPolicyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            SimulateCustomPolicyErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            SimulateCustomPolicyErrorKind::PolicyEvaluationException(_inner) => _inner.fmt(f),
            SimulateCustomPolicyErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for SimulateCustomPolicyError {
    fn code(&self) -> Option<&str> {
        SimulateCustomPolicyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl SimulateCustomPolicyError {
    pub fn new(kind: SimulateCustomPolicyErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: SimulateCustomPolicyErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: SimulateCustomPolicyErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            SimulateCustomPolicyErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_policy_evaluation_exception(&self) -> bool {
        matches!(
            &self.kind,
            SimulateCustomPolicyErrorKind::PolicyEvaluationException(_)
        )
    }
}
impl std::error::Error for SimulateCustomPolicyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            SimulateCustomPolicyErrorKind::InvalidInputException(_inner) => Some(_inner),
            SimulateCustomPolicyErrorKind::PolicyEvaluationException(_inner) => Some(_inner),
            SimulateCustomPolicyErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct SimulatePrincipalPolicyError {
    pub kind: SimulatePrincipalPolicyErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum SimulatePrincipalPolicyErrorKind {
    InvalidInputException(crate::error::InvalidInputException),
    NoSuchEntityException(crate::error::NoSuchEntityException),
    PolicyEvaluationException(crate::error::PolicyEvaluationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for SimulatePrincipalPolicyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            SimulatePrincipalPolicyErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            SimulatePrincipalPolicyErrorKind::NoSuchEntityException(_inner) => _inner.fmt(f),
            SimulatePrincipalPolicyErrorKind::PolicyEvaluationException(_inner) => _inner.fmt(f),
            SimulatePrincipalPolicyErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for SimulatePrincipalPolicyError {
    fn code(&self) -> Option<&str> {
        SimulatePrincipalPolicyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl SimulatePrincipalPolicyError {
    pub fn new(kind: SimulatePrincipalPolicyErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: SimulatePrincipalPolicyErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: SimulatePrincipalPolicyErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            SimulatePrincipalPolicyErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_no_such_entity_exception(&self) -> bool {
        matches!(
            &self.kind,
            SimulatePrincipalPolicyErrorKind::NoSuchEntityException(_)
        )
    }
    pub fn is_policy_evaluation_exception(&self) -> bool {
        matches!(
            &self.kind,
            SimulatePrincipalPolicyErrorKind::PolicyEvaluationException(_)
        )
    }
}
impl std::error::Error for SimulatePrincipalPolicyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            SimulatePrincipalPolicyErrorKind::InvalidInputException(_inner) => Some(_inner),
            SimulatePrincipalPolicyErrorKind::NoSuchEntityException(_inner) => Some(_inner),
            SimulatePrincipalPolicyErrorKind::PolicyEvaluationException(_inner) => Some(_inner),
            SimulatePrincipalPolicyErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct TagInstanceProfileError {
    pub kind: TagInstanceProfileErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum TagInstanceProfileErrorKind {
    ConcurrentModificationException(crate::error::ConcurrentModificationException),
    InvalidInputException(crate::error::InvalidInputException),
    LimitExceededException(crate::error::LimitExceededException),
    NoSuchEntityException(crate::error::NoSuchEntityException),
    ServiceFailureException(crate::error::ServiceFailureException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for TagInstanceProfileError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            TagInstanceProfileErrorKind::ConcurrentModificationException(_inner) => _inner.fmt(f),
            TagInstanceProfileErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            TagInstanceProfileErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            TagInstanceProfileErrorKind::NoSuchEntityException(_inner) => _inner.fmt(f),
            TagInstanceProfileErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            TagInstanceProfileErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for TagInstanceProfileError {
    fn code(&self) -> Option<&str> {
        TagInstanceProfileError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl TagInstanceProfileError {
    pub fn new(kind: TagInstanceProfileErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: TagInstanceProfileErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: TagInstanceProfileErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_concurrent_modification_exception(&self) -> bool {
        matches!(
            &self.kind,
            TagInstanceProfileErrorKind::ConcurrentModificationException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            TagInstanceProfileErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            TagInstanceProfileErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_no_such_entity_exception(&self) -> bool {
        matches!(
            &self.kind,
            TagInstanceProfileErrorKind::NoSuchEntityException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            TagInstanceProfileErrorKind::ServiceFailureException(_)
        )
    }
}
impl std::error::Error for TagInstanceProfileError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            TagInstanceProfileErrorKind::ConcurrentModificationException(_inner) => Some(_inner),
            TagInstanceProfileErrorKind::InvalidInputException(_inner) => Some(_inner),
            TagInstanceProfileErrorKind::LimitExceededException(_inner) => Some(_inner),
            TagInstanceProfileErrorKind::NoSuchEntityException(_inner) => Some(_inner),
            TagInstanceProfileErrorKind::ServiceFailureException(_inner) => Some(_inner),
            TagInstanceProfileErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct TagMFADeviceError {
    pub kind: TagMFADeviceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum TagMFADeviceErrorKind {
    ConcurrentModificationException(crate::error::ConcurrentModificationException),
    InvalidInputException(crate::error::InvalidInputException),
    LimitExceededException(crate::error::LimitExceededException),
    NoSuchEntityException(crate::error::NoSuchEntityException),
    ServiceFailureException(crate::error::ServiceFailureException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for TagMFADeviceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            TagMFADeviceErrorKind::ConcurrentModificationException(_inner) => _inner.fmt(f),
            TagMFADeviceErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            TagMFADeviceErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            TagMFADeviceErrorKind::NoSuchEntityException(_inner) => _inner.fmt(f),
            TagMFADeviceErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            TagMFADeviceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for TagMFADeviceError {
    fn code(&self) -> Option<&str> {
        TagMFADeviceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl TagMFADeviceError {
    pub fn new(kind: TagMFADeviceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: TagMFADeviceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: TagMFADeviceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_concurrent_modification_exception(&self) -> bool {
        matches!(
            &self.kind,
            TagMFADeviceErrorKind::ConcurrentModificationException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(&self.kind, TagMFADeviceErrorKind::InvalidInputException(_))
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(&self.kind, TagMFADeviceErrorKind::LimitExceededException(_))
    }
    pub fn is_no_such_entity_exception(&self) -> bool {
        matches!(&self.kind, TagMFADeviceErrorKind::NoSuchEntityException(_))
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            TagMFADeviceErrorKind::ServiceFailureException(_)
        )
    }
}
impl std::error::Error for TagMFADeviceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            TagMFADeviceErrorKind::ConcurrentModificationException(_inner) => Some(_inner),
            TagMFADeviceErrorKind::InvalidInputException(_inner) => Some(_inner),
            TagMFADeviceErrorKind::LimitExceededException(_inner) => Some(_inner),
            TagMFADeviceErrorKind::NoSuchEntityException(_inner) => Some(_inner),
            TagMFADeviceErrorKind::ServiceFailureException(_inner) => Some(_inner),
            TagMFADeviceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct TagOpenIDConnectProviderError {
    pub kind: TagOpenIDConnectProviderErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum TagOpenIDConnectProviderErrorKind {
    ConcurrentModificationException(crate::error::ConcurrentModificationException),
    InvalidInputException(crate::error::InvalidInputException),
    LimitExceededException(crate::error::LimitExceededException),
    NoSuchEntityException(crate::error::NoSuchEntityException),
    ServiceFailureException(crate::error::ServiceFailureException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for TagOpenIDConnectProviderError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            TagOpenIDConnectProviderErrorKind::ConcurrentModificationException(_inner) => {
                _inner.fmt(f)
            }
            TagOpenIDConnectProviderErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            TagOpenIDConnectProviderErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            TagOpenIDConnectProviderErrorKind::NoSuchEntityException(_inner) => _inner.fmt(f),
            TagOpenIDConnectProviderErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            TagOpenIDConnectProviderErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for TagOpenIDConnectProviderError {
    fn code(&self) -> Option<&str> {
        TagOpenIDConnectProviderError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl TagOpenIDConnectProviderError {
    pub fn new(kind: TagOpenIDConnectProviderErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: TagOpenIDConnectProviderErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: TagOpenIDConnectProviderErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_concurrent_modification_exception(&self) -> bool {
        matches!(
            &self.kind,
            TagOpenIDConnectProviderErrorKind::ConcurrentModificationException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            TagOpenIDConnectProviderErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            TagOpenIDConnectProviderErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_no_such_entity_exception(&self) -> bool {
        matches!(
            &self.kind,
            TagOpenIDConnectProviderErrorKind::NoSuchEntityException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            TagOpenIDConnectProviderErrorKind::ServiceFailureException(_)
        )
    }
}
impl std::error::Error for TagOpenIDConnectProviderError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            TagOpenIDConnectProviderErrorKind::ConcurrentModificationException(_inner) => {
                Some(_inner)
            }
            TagOpenIDConnectProviderErrorKind::InvalidInputException(_inner) => Some(_inner),
            TagOpenIDConnectProviderErrorKind::LimitExceededException(_inner) => Some(_inner),
            TagOpenIDConnectProviderErrorKind::NoSuchEntityException(_inner) => Some(_inner),
            TagOpenIDConnectProviderErrorKind::ServiceFailureException(_inner) => Some(_inner),
            TagOpenIDConnectProviderErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct TagPolicyError {
    pub kind: TagPolicyErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum TagPolicyErrorKind {
    ConcurrentModificationException(crate::error::ConcurrentModificationException),
    InvalidInputException(crate::error::InvalidInputException),
    LimitExceededException(crate::error::LimitExceededException),
    NoSuchEntityException(crate::error::NoSuchEntityException),
    ServiceFailureException(crate::error::ServiceFailureException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for TagPolicyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            TagPolicyErrorKind::ConcurrentModificationException(_inner) => _inner.fmt(f),
            TagPolicyErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            TagPolicyErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            TagPolicyErrorKind::NoSuchEntityException(_inner) => _inner.fmt(f),
            TagPolicyErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            TagPolicyErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for TagPolicyError {
    fn code(&self) -> Option<&str> {
        TagPolicyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl TagPolicyError {
    pub fn new(kind: TagPolicyErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: TagPolicyErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: TagPolicyErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_concurrent_modification_exception(&self) -> bool {
        matches!(
            &self.kind,
            TagPolicyErrorKind::ConcurrentModificationException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(&self.kind, TagPolicyErrorKind::InvalidInputException(_))
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(&self.kind, TagPolicyErrorKind::LimitExceededException(_))
    }
    pub fn is_no_such_entity_exception(&self) -> bool {
        matches!(&self.kind, TagPolicyErrorKind::NoSuchEntityException(_))
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(&self.kind, TagPolicyErrorKind::ServiceFailureException(_))
    }
}
impl std::error::Error for TagPolicyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            TagPolicyErrorKind::ConcurrentModificationException(_inner) => Some(_inner),
            TagPolicyErrorKind::InvalidInputException(_inner) => Some(_inner),
            TagPolicyErrorKind::LimitExceededException(_inner) => Some(_inner),
            TagPolicyErrorKind::NoSuchEntityException(_inner) => Some(_inner),
            TagPolicyErrorKind::ServiceFailureException(_inner) => Some(_inner),
            TagPolicyErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct TagRoleError {
    pub kind: TagRoleErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum TagRoleErrorKind {
    ConcurrentModificationException(crate::error::ConcurrentModificationException),
    InvalidInputException(crate::error::InvalidInputException),
    LimitExceededException(crate::error::LimitExceededException),
    NoSuchEntityException(crate::error::NoSuchEntityException),
    ServiceFailureException(crate::error::ServiceFailureException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for TagRoleError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            TagRoleErrorKind::ConcurrentModificationException(_inner) => _inner.fmt(f),
            TagRoleErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            TagRoleErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            TagRoleErrorKind::NoSuchEntityException(_inner) => _inner.fmt(f),
            TagRoleErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            TagRoleErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for TagRoleError {
    fn code(&self) -> Option<&str> {
        TagRoleError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl TagRoleError {
    pub fn new(kind: TagRoleErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: TagRoleErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: TagRoleErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_concurrent_modification_exception(&self) -> bool {
        matches!(
            &self.kind,
            TagRoleErrorKind::ConcurrentModificationException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(&self.kind, TagRoleErrorKind::InvalidInputException(_))
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(&self.kind, TagRoleErrorKind::LimitExceededException(_))
    }
    pub fn is_no_such_entity_exception(&self) -> bool {
        matches!(&self.kind, TagRoleErrorKind::NoSuchEntityException(_))
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(&self.kind, TagRoleErrorKind::ServiceFailureException(_))
    }
}
impl std::error::Error for TagRoleError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            TagRoleErrorKind::ConcurrentModificationException(_inner) => Some(_inner),
            TagRoleErrorKind::InvalidInputException(_inner) => Some(_inner),
            TagRoleErrorKind::LimitExceededException(_inner) => Some(_inner),
            TagRoleErrorKind::NoSuchEntityException(_inner) => Some(_inner),
            TagRoleErrorKind::ServiceFailureException(_inner) => Some(_inner),
            TagRoleErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct TagSAMLProviderError {
    pub kind: TagSAMLProviderErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum TagSAMLProviderErrorKind {
    ConcurrentModificationException(crate::error::ConcurrentModificationException),
    InvalidInputException(crate::error::InvalidInputException),
    LimitExceededException(crate::error::LimitExceededException),
    NoSuchEntityException(crate::error::NoSuchEntityException),
    ServiceFailureException(crate::error::ServiceFailureException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for TagSAMLProviderError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            TagSAMLProviderErrorKind::ConcurrentModificationException(_inner) => _inner.fmt(f),
            TagSAMLProviderErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            TagSAMLProviderErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            TagSAMLProviderErrorKind::NoSuchEntityException(_inner) => _inner.fmt(f),
            TagSAMLProviderErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            TagSAMLProviderErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for TagSAMLProviderError {
    fn code(&self) -> Option<&str> {
        TagSAMLProviderError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl TagSAMLProviderError {
    pub fn new(kind: TagSAMLProviderErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: TagSAMLProviderErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: TagSAMLProviderErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_concurrent_modification_exception(&self) -> bool {
        matches!(
            &self.kind,
            TagSAMLProviderErrorKind::ConcurrentModificationException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            TagSAMLProviderErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            TagSAMLProviderErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_no_such_entity_exception(&self) -> bool {
        matches!(
            &self.kind,
            TagSAMLProviderErrorKind::NoSuchEntityException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            TagSAMLProviderErrorKind::ServiceFailureException(_)
        )
    }
}
impl std::error::Error for TagSAMLProviderError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            TagSAMLProviderErrorKind::ConcurrentModificationException(_inner) => Some(_inner),
            TagSAMLProviderErrorKind::InvalidInputException(_inner) => Some(_inner),
            TagSAMLProviderErrorKind::LimitExceededException(_inner) => Some(_inner),
            TagSAMLProviderErrorKind::NoSuchEntityException(_inner) => Some(_inner),
            TagSAMLProviderErrorKind::ServiceFailureException(_inner) => Some(_inner),
            TagSAMLProviderErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct TagServerCertificateError {
    pub kind: TagServerCertificateErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum TagServerCertificateErrorKind {
    ConcurrentModificationException(crate::error::ConcurrentModificationException),
    InvalidInputException(crate::error::InvalidInputException),
    LimitExceededException(crate::error::LimitExceededException),
    NoSuchEntityException(crate::error::NoSuchEntityException),
    ServiceFailureException(crate::error::ServiceFailureException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for TagServerCertificateError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            TagServerCertificateErrorKind::ConcurrentModificationException(_inner) => _inner.fmt(f),
            TagServerCertificateErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            TagServerCertificateErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            TagServerCertificateErrorKind::NoSuchEntityException(_inner) => _inner.fmt(f),
            TagServerCertificateErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            TagServerCertificateErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for TagServerCertificateError {
    fn code(&self) -> Option<&str> {
        TagServerCertificateError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl TagServerCertificateError {
    pub fn new(kind: TagServerCertificateErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: TagServerCertificateErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: TagServerCertificateErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_concurrent_modification_exception(&self) -> bool {
        matches!(
            &self.kind,
            TagServerCertificateErrorKind::ConcurrentModificationException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            TagServerCertificateErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            TagServerCertificateErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_no_such_entity_exception(&self) -> bool {
        matches!(
            &self.kind,
            TagServerCertificateErrorKind::NoSuchEntityException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            TagServerCertificateErrorKind::ServiceFailureException(_)
        )
    }
}
impl std::error::Error for TagServerCertificateError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            TagServerCertificateErrorKind::ConcurrentModificationException(_inner) => Some(_inner),
            TagServerCertificateErrorKind::InvalidInputException(_inner) => Some(_inner),
            TagServerCertificateErrorKind::LimitExceededException(_inner) => Some(_inner),
            TagServerCertificateErrorKind::NoSuchEntityException(_inner) => Some(_inner),
            TagServerCertificateErrorKind::ServiceFailureException(_inner) => Some(_inner),
            TagServerCertificateErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct TagUserError {
    pub kind: TagUserErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum TagUserErrorKind {
    ConcurrentModificationException(crate::error::ConcurrentModificationException),
    InvalidInputException(crate::error::InvalidInputException),
    LimitExceededException(crate::error::LimitExceededException),
    NoSuchEntityException(crate::error::NoSuchEntityException),
    ServiceFailureException(crate::error::ServiceFailureException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for TagUserError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            TagUserErrorKind::ConcurrentModificationException(_inner) => _inner.fmt(f),
            TagUserErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            TagUserErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            TagUserErrorKind::NoSuchEntityException(_inner) => _inner.fmt(f),
            TagUserErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            TagUserErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for TagUserError {
    fn code(&self) -> Option<&str> {
        TagUserError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl TagUserError {
    pub fn new(kind: TagUserErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: TagUserErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: TagUserErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_concurrent_modification_exception(&self) -> bool {
        matches!(
            &self.kind,
            TagUserErrorKind::ConcurrentModificationException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(&self.kind, TagUserErrorKind::InvalidInputException(_))
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(&self.kind, TagUserErrorKind::LimitExceededException(_))
    }
    pub fn is_no_such_entity_exception(&self) -> bool {
        matches!(&self.kind, TagUserErrorKind::NoSuchEntityException(_))
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(&self.kind, TagUserErrorKind::ServiceFailureException(_))
    }
}
impl std::error::Error for TagUserError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            TagUserErrorKind::ConcurrentModificationException(_inner) => Some(_inner),
            TagUserErrorKind::InvalidInputException(_inner) => Some(_inner),
            TagUserErrorKind::LimitExceededException(_inner) => Some(_inner),
            TagUserErrorKind::NoSuchEntityException(_inner) => Some(_inner),
            TagUserErrorKind::ServiceFailureException(_inner) => Some(_inner),
            TagUserErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UntagInstanceProfileError {
    pub kind: UntagInstanceProfileErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UntagInstanceProfileErrorKind {
    ConcurrentModificationException(crate::error::ConcurrentModificationException),
    InvalidInputException(crate::error::InvalidInputException),
    NoSuchEntityException(crate::error::NoSuchEntityException),
    ServiceFailureException(crate::error::ServiceFailureException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UntagInstanceProfileError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UntagInstanceProfileErrorKind::ConcurrentModificationException(_inner) => _inner.fmt(f),
            UntagInstanceProfileErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            UntagInstanceProfileErrorKind::NoSuchEntityException(_inner) => _inner.fmt(f),
            UntagInstanceProfileErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            UntagInstanceProfileErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UntagInstanceProfileError {
    fn code(&self) -> Option<&str> {
        UntagInstanceProfileError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UntagInstanceProfileError {
    pub fn new(kind: UntagInstanceProfileErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UntagInstanceProfileErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UntagInstanceProfileErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_concurrent_modification_exception(&self) -> bool {
        matches!(
            &self.kind,
            UntagInstanceProfileErrorKind::ConcurrentModificationException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            UntagInstanceProfileErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_no_such_entity_exception(&self) -> bool {
        matches!(
            &self.kind,
            UntagInstanceProfileErrorKind::NoSuchEntityException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            UntagInstanceProfileErrorKind::ServiceFailureException(_)
        )
    }
}
impl std::error::Error for UntagInstanceProfileError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UntagInstanceProfileErrorKind::ConcurrentModificationException(_inner) => Some(_inner),
            UntagInstanceProfileErrorKind::InvalidInputException(_inner) => Some(_inner),
            UntagInstanceProfileErrorKind::NoSuchEntityException(_inner) => Some(_inner),
            UntagInstanceProfileErrorKind::ServiceFailureException(_inner) => Some(_inner),
            UntagInstanceProfileErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UntagMFADeviceError {
    pub kind: UntagMFADeviceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UntagMFADeviceErrorKind {
    ConcurrentModificationException(crate::error::ConcurrentModificationException),
    InvalidInputException(crate::error::InvalidInputException),
    NoSuchEntityException(crate::error::NoSuchEntityException),
    ServiceFailureException(crate::error::ServiceFailureException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UntagMFADeviceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UntagMFADeviceErrorKind::ConcurrentModificationException(_inner) => _inner.fmt(f),
            UntagMFADeviceErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            UntagMFADeviceErrorKind::NoSuchEntityException(_inner) => _inner.fmt(f),
            UntagMFADeviceErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            UntagMFADeviceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UntagMFADeviceError {
    fn code(&self) -> Option<&str> {
        UntagMFADeviceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UntagMFADeviceError {
    pub fn new(kind: UntagMFADeviceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UntagMFADeviceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UntagMFADeviceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_concurrent_modification_exception(&self) -> bool {
        matches!(
            &self.kind,
            UntagMFADeviceErrorKind::ConcurrentModificationException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            UntagMFADeviceErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_no_such_entity_exception(&self) -> bool {
        matches!(
            &self.kind,
            UntagMFADeviceErrorKind::NoSuchEntityException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            UntagMFADeviceErrorKind::ServiceFailureException(_)
        )
    }
}
impl std::error::Error for UntagMFADeviceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UntagMFADeviceErrorKind::ConcurrentModificationException(_inner) => Some(_inner),
            UntagMFADeviceErrorKind::InvalidInputException(_inner) => Some(_inner),
            UntagMFADeviceErrorKind::NoSuchEntityException(_inner) => Some(_inner),
            UntagMFADeviceErrorKind::ServiceFailureException(_inner) => Some(_inner),
            UntagMFADeviceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UntagOpenIDConnectProviderError {
    pub kind: UntagOpenIDConnectProviderErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UntagOpenIDConnectProviderErrorKind {
    ConcurrentModificationException(crate::error::ConcurrentModificationException),
    InvalidInputException(crate::error::InvalidInputException),
    NoSuchEntityException(crate::error::NoSuchEntityException),
    ServiceFailureException(crate::error::ServiceFailureException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UntagOpenIDConnectProviderError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UntagOpenIDConnectProviderErrorKind::ConcurrentModificationException(_inner) => {
                _inner.fmt(f)
            }
            UntagOpenIDConnectProviderErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            UntagOpenIDConnectProviderErrorKind::NoSuchEntityException(_inner) => _inner.fmt(f),
            UntagOpenIDConnectProviderErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            UntagOpenIDConnectProviderErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UntagOpenIDConnectProviderError {
    fn code(&self) -> Option<&str> {
        UntagOpenIDConnectProviderError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UntagOpenIDConnectProviderError {
    pub fn new(kind: UntagOpenIDConnectProviderErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UntagOpenIDConnectProviderErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UntagOpenIDConnectProviderErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_concurrent_modification_exception(&self) -> bool {
        matches!(
            &self.kind,
            UntagOpenIDConnectProviderErrorKind::ConcurrentModificationException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            UntagOpenIDConnectProviderErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_no_such_entity_exception(&self) -> bool {
        matches!(
            &self.kind,
            UntagOpenIDConnectProviderErrorKind::NoSuchEntityException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            UntagOpenIDConnectProviderErrorKind::ServiceFailureException(_)
        )
    }
}
impl std::error::Error for UntagOpenIDConnectProviderError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UntagOpenIDConnectProviderErrorKind::ConcurrentModificationException(_inner) => {
                Some(_inner)
            }
            UntagOpenIDConnectProviderErrorKind::InvalidInputException(_inner) => Some(_inner),
            UntagOpenIDConnectProviderErrorKind::NoSuchEntityException(_inner) => Some(_inner),
            UntagOpenIDConnectProviderErrorKind::ServiceFailureException(_inner) => Some(_inner),
            UntagOpenIDConnectProviderErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UntagPolicyError {
    pub kind: UntagPolicyErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UntagPolicyErrorKind {
    ConcurrentModificationException(crate::error::ConcurrentModificationException),
    InvalidInputException(crate::error::InvalidInputException),
    NoSuchEntityException(crate::error::NoSuchEntityException),
    ServiceFailureException(crate::error::ServiceFailureException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UntagPolicyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UntagPolicyErrorKind::ConcurrentModificationException(_inner) => _inner.fmt(f),
            UntagPolicyErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            UntagPolicyErrorKind::NoSuchEntityException(_inner) => _inner.fmt(f),
            UntagPolicyErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            UntagPolicyErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UntagPolicyError {
    fn code(&self) -> Option<&str> {
        UntagPolicyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UntagPolicyError {
    pub fn new(kind: UntagPolicyErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UntagPolicyErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UntagPolicyErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_concurrent_modification_exception(&self) -> bool {
        matches!(
            &self.kind,
            UntagPolicyErrorKind::ConcurrentModificationException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(&self.kind, UntagPolicyErrorKind::InvalidInputException(_))
    }
    pub fn is_no_such_entity_exception(&self) -> bool {
        matches!(&self.kind, UntagPolicyErrorKind::NoSuchEntityException(_))
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(&self.kind, UntagPolicyErrorKind::ServiceFailureException(_))
    }
}
impl std::error::Error for UntagPolicyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UntagPolicyErrorKind::ConcurrentModificationException(_inner) => Some(_inner),
            UntagPolicyErrorKind::InvalidInputException(_inner) => Some(_inner),
            UntagPolicyErrorKind::NoSuchEntityException(_inner) => Some(_inner),
            UntagPolicyErrorKind::ServiceFailureException(_inner) => Some(_inner),
            UntagPolicyErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UntagRoleError {
    pub kind: UntagRoleErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UntagRoleErrorKind {
    ConcurrentModificationException(crate::error::ConcurrentModificationException),
    NoSuchEntityException(crate::error::NoSuchEntityException),
    ServiceFailureException(crate::error::ServiceFailureException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UntagRoleError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UntagRoleErrorKind::ConcurrentModificationException(_inner) => _inner.fmt(f),
            UntagRoleErrorKind::NoSuchEntityException(_inner) => _inner.fmt(f),
            UntagRoleErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            UntagRoleErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UntagRoleError {
    fn code(&self) -> Option<&str> {
        UntagRoleError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UntagRoleError {
    pub fn new(kind: UntagRoleErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UntagRoleErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UntagRoleErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_concurrent_modification_exception(&self) -> bool {
        matches!(
            &self.kind,
            UntagRoleErrorKind::ConcurrentModificationException(_)
        )
    }
    pub fn is_no_such_entity_exception(&self) -> bool {
        matches!(&self.kind, UntagRoleErrorKind::NoSuchEntityException(_))
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(&self.kind, UntagRoleErrorKind::ServiceFailureException(_))
    }
}
impl std::error::Error for UntagRoleError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UntagRoleErrorKind::ConcurrentModificationException(_inner) => Some(_inner),
            UntagRoleErrorKind::NoSuchEntityException(_inner) => Some(_inner),
            UntagRoleErrorKind::ServiceFailureException(_inner) => Some(_inner),
            UntagRoleErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UntagSAMLProviderError {
    pub kind: UntagSAMLProviderErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UntagSAMLProviderErrorKind {
    ConcurrentModificationException(crate::error::ConcurrentModificationException),
    InvalidInputException(crate::error::InvalidInputException),
    NoSuchEntityException(crate::error::NoSuchEntityException),
    ServiceFailureException(crate::error::ServiceFailureException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UntagSAMLProviderError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UntagSAMLProviderErrorKind::ConcurrentModificationException(_inner) => _inner.fmt(f),
            UntagSAMLProviderErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            UntagSAMLProviderErrorKind::NoSuchEntityException(_inner) => _inner.fmt(f),
            UntagSAMLProviderErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            UntagSAMLProviderErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UntagSAMLProviderError {
    fn code(&self) -> Option<&str> {
        UntagSAMLProviderError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UntagSAMLProviderError {
    pub fn new(kind: UntagSAMLProviderErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UntagSAMLProviderErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UntagSAMLProviderErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_concurrent_modification_exception(&self) -> bool {
        matches!(
            &self.kind,
            UntagSAMLProviderErrorKind::ConcurrentModificationException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            UntagSAMLProviderErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_no_such_entity_exception(&self) -> bool {
        matches!(
            &self.kind,
            UntagSAMLProviderErrorKind::NoSuchEntityException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            UntagSAMLProviderErrorKind::ServiceFailureException(_)
        )
    }
}
impl std::error::Error for UntagSAMLProviderError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UntagSAMLProviderErrorKind::ConcurrentModificationException(_inner) => Some(_inner),
            UntagSAMLProviderErrorKind::InvalidInputException(_inner) => Some(_inner),
            UntagSAMLProviderErrorKind::NoSuchEntityException(_inner) => Some(_inner),
            UntagSAMLProviderErrorKind::ServiceFailureException(_inner) => Some(_inner),
            UntagSAMLProviderErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UntagServerCertificateError {
    pub kind: UntagServerCertificateErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UntagServerCertificateErrorKind {
    ConcurrentModificationException(crate::error::ConcurrentModificationException),
    InvalidInputException(crate::error::InvalidInputException),
    NoSuchEntityException(crate::error::NoSuchEntityException),
    ServiceFailureException(crate::error::ServiceFailureException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UntagServerCertificateError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UntagServerCertificateErrorKind::ConcurrentModificationException(_inner) => {
                _inner.fmt(f)
            }
            UntagServerCertificateErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            UntagServerCertificateErrorKind::NoSuchEntityException(_inner) => _inner.fmt(f),
            UntagServerCertificateErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            UntagServerCertificateErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UntagServerCertificateError {
    fn code(&self) -> Option<&str> {
        UntagServerCertificateError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UntagServerCertificateError {
    pub fn new(kind: UntagServerCertificateErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UntagServerCertificateErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UntagServerCertificateErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_concurrent_modification_exception(&self) -> bool {
        matches!(
            &self.kind,
            UntagServerCertificateErrorKind::ConcurrentModificationException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            UntagServerCertificateErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_no_such_entity_exception(&self) -> bool {
        matches!(
            &self.kind,
            UntagServerCertificateErrorKind::NoSuchEntityException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            UntagServerCertificateErrorKind::ServiceFailureException(_)
        )
    }
}
impl std::error::Error for UntagServerCertificateError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UntagServerCertificateErrorKind::ConcurrentModificationException(_inner) => {
                Some(_inner)
            }
            UntagServerCertificateErrorKind::InvalidInputException(_inner) => Some(_inner),
            UntagServerCertificateErrorKind::NoSuchEntityException(_inner) => Some(_inner),
            UntagServerCertificateErrorKind::ServiceFailureException(_inner) => Some(_inner),
            UntagServerCertificateErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UntagUserError {
    pub kind: UntagUserErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UntagUserErrorKind {
    ConcurrentModificationException(crate::error::ConcurrentModificationException),
    NoSuchEntityException(crate::error::NoSuchEntityException),
    ServiceFailureException(crate::error::ServiceFailureException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UntagUserError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UntagUserErrorKind::ConcurrentModificationException(_inner) => _inner.fmt(f),
            UntagUserErrorKind::NoSuchEntityException(_inner) => _inner.fmt(f),
            UntagUserErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            UntagUserErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UntagUserError {
    fn code(&self) -> Option<&str> {
        UntagUserError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UntagUserError {
    pub fn new(kind: UntagUserErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UntagUserErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UntagUserErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_concurrent_modification_exception(&self) -> bool {
        matches!(
            &self.kind,
            UntagUserErrorKind::ConcurrentModificationException(_)
        )
    }
    pub fn is_no_such_entity_exception(&self) -> bool {
        matches!(&self.kind, UntagUserErrorKind::NoSuchEntityException(_))
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(&self.kind, UntagUserErrorKind::ServiceFailureException(_))
    }
}
impl std::error::Error for UntagUserError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UntagUserErrorKind::ConcurrentModificationException(_inner) => Some(_inner),
            UntagUserErrorKind::NoSuchEntityException(_inner) => Some(_inner),
            UntagUserErrorKind::ServiceFailureException(_inner) => Some(_inner),
            UntagUserErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateAccessKeyError {
    pub kind: UpdateAccessKeyErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateAccessKeyErrorKind {
    LimitExceededException(crate::error::LimitExceededException),
    NoSuchEntityException(crate::error::NoSuchEntityException),
    ServiceFailureException(crate::error::ServiceFailureException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateAccessKeyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateAccessKeyErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            UpdateAccessKeyErrorKind::NoSuchEntityException(_inner) => _inner.fmt(f),
            UpdateAccessKeyErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            UpdateAccessKeyErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateAccessKeyError {
    fn code(&self) -> Option<&str> {
        UpdateAccessKeyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateAccessKeyError {
    pub fn new(kind: UpdateAccessKeyErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateAccessKeyErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateAccessKeyErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateAccessKeyErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_no_such_entity_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateAccessKeyErrorKind::NoSuchEntityException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateAccessKeyErrorKind::ServiceFailureException(_)
        )
    }
}
impl std::error::Error for UpdateAccessKeyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateAccessKeyErrorKind::LimitExceededException(_inner) => Some(_inner),
            UpdateAccessKeyErrorKind::NoSuchEntityException(_inner) => Some(_inner),
            UpdateAccessKeyErrorKind::ServiceFailureException(_inner) => Some(_inner),
            UpdateAccessKeyErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateAccountPasswordPolicyError {
    pub kind: UpdateAccountPasswordPolicyErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateAccountPasswordPolicyErrorKind {
    LimitExceededException(crate::error::LimitExceededException),
    MalformedPolicyDocumentException(crate::error::MalformedPolicyDocumentException),
    NoSuchEntityException(crate::error::NoSuchEntityException),
    ServiceFailureException(crate::error::ServiceFailureException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateAccountPasswordPolicyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateAccountPasswordPolicyErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            UpdateAccountPasswordPolicyErrorKind::MalformedPolicyDocumentException(_inner) => {
                _inner.fmt(f)
            }
            UpdateAccountPasswordPolicyErrorKind::NoSuchEntityException(_inner) => _inner.fmt(f),
            UpdateAccountPasswordPolicyErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            UpdateAccountPasswordPolicyErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateAccountPasswordPolicyError {
    fn code(&self) -> Option<&str> {
        UpdateAccountPasswordPolicyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateAccountPasswordPolicyError {
    pub fn new(kind: UpdateAccountPasswordPolicyErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateAccountPasswordPolicyErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateAccountPasswordPolicyErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateAccountPasswordPolicyErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_malformed_policy_document_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateAccountPasswordPolicyErrorKind::MalformedPolicyDocumentException(_)
        )
    }
    pub fn is_no_such_entity_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateAccountPasswordPolicyErrorKind::NoSuchEntityException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateAccountPasswordPolicyErrorKind::ServiceFailureException(_)
        )
    }
}
impl std::error::Error for UpdateAccountPasswordPolicyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateAccountPasswordPolicyErrorKind::LimitExceededException(_inner) => Some(_inner),
            UpdateAccountPasswordPolicyErrorKind::MalformedPolicyDocumentException(_inner) => {
                Some(_inner)
            }
            UpdateAccountPasswordPolicyErrorKind::NoSuchEntityException(_inner) => Some(_inner),
            UpdateAccountPasswordPolicyErrorKind::ServiceFailureException(_inner) => Some(_inner),
            UpdateAccountPasswordPolicyErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateAssumeRolePolicyError {
    pub kind: UpdateAssumeRolePolicyErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateAssumeRolePolicyErrorKind {
    LimitExceededException(crate::error::LimitExceededException),
    MalformedPolicyDocumentException(crate::error::MalformedPolicyDocumentException),
    NoSuchEntityException(crate::error::NoSuchEntityException),
    ServiceFailureException(crate::error::ServiceFailureException),
    UnmodifiableEntityException(crate::error::UnmodifiableEntityException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateAssumeRolePolicyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateAssumeRolePolicyErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            UpdateAssumeRolePolicyErrorKind::MalformedPolicyDocumentException(_inner) => {
                _inner.fmt(f)
            }
            UpdateAssumeRolePolicyErrorKind::NoSuchEntityException(_inner) => _inner.fmt(f),
            UpdateAssumeRolePolicyErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            UpdateAssumeRolePolicyErrorKind::UnmodifiableEntityException(_inner) => _inner.fmt(f),
            UpdateAssumeRolePolicyErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateAssumeRolePolicyError {
    fn code(&self) -> Option<&str> {
        UpdateAssumeRolePolicyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateAssumeRolePolicyError {
    pub fn new(kind: UpdateAssumeRolePolicyErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateAssumeRolePolicyErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateAssumeRolePolicyErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateAssumeRolePolicyErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_malformed_policy_document_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateAssumeRolePolicyErrorKind::MalformedPolicyDocumentException(_)
        )
    }
    pub fn is_no_such_entity_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateAssumeRolePolicyErrorKind::NoSuchEntityException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateAssumeRolePolicyErrorKind::ServiceFailureException(_)
        )
    }
    pub fn is_unmodifiable_entity_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateAssumeRolePolicyErrorKind::UnmodifiableEntityException(_)
        )
    }
}
impl std::error::Error for UpdateAssumeRolePolicyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateAssumeRolePolicyErrorKind::LimitExceededException(_inner) => Some(_inner),
            UpdateAssumeRolePolicyErrorKind::MalformedPolicyDocumentException(_inner) => {
                Some(_inner)
            }
            UpdateAssumeRolePolicyErrorKind::NoSuchEntityException(_inner) => Some(_inner),
            UpdateAssumeRolePolicyErrorKind::ServiceFailureException(_inner) => Some(_inner),
            UpdateAssumeRolePolicyErrorKind::UnmodifiableEntityException(_inner) => Some(_inner),
            UpdateAssumeRolePolicyErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateGroupError {
    pub kind: UpdateGroupErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateGroupErrorKind {
    EntityAlreadyExistsException(crate::error::EntityAlreadyExistsException),
    LimitExceededException(crate::error::LimitExceededException),
    NoSuchEntityException(crate::error::NoSuchEntityException),
    ServiceFailureException(crate::error::ServiceFailureException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateGroupError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateGroupErrorKind::EntityAlreadyExistsException(_inner) => _inner.fmt(f),
            UpdateGroupErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            UpdateGroupErrorKind::NoSuchEntityException(_inner) => _inner.fmt(f),
            UpdateGroupErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            UpdateGroupErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateGroupError {
    fn code(&self) -> Option<&str> {
        UpdateGroupError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateGroupError {
    pub fn new(kind: UpdateGroupErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateGroupErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateGroupErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_entity_already_exists_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateGroupErrorKind::EntityAlreadyExistsException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(&self.kind, UpdateGroupErrorKind::LimitExceededException(_))
    }
    pub fn is_no_such_entity_exception(&self) -> bool {
        matches!(&self.kind, UpdateGroupErrorKind::NoSuchEntityException(_))
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(&self.kind, UpdateGroupErrorKind::ServiceFailureException(_))
    }
}
impl std::error::Error for UpdateGroupError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateGroupErrorKind::EntityAlreadyExistsException(_inner) => Some(_inner),
            UpdateGroupErrorKind::LimitExceededException(_inner) => Some(_inner),
            UpdateGroupErrorKind::NoSuchEntityException(_inner) => Some(_inner),
            UpdateGroupErrorKind::ServiceFailureException(_inner) => Some(_inner),
            UpdateGroupErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateLoginProfileError {
    pub kind: UpdateLoginProfileErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateLoginProfileErrorKind {
    EntityTemporarilyUnmodifiableException(crate::error::EntityTemporarilyUnmodifiableException),
    LimitExceededException(crate::error::LimitExceededException),
    NoSuchEntityException(crate::error::NoSuchEntityException),
    PasswordPolicyViolationException(crate::error::PasswordPolicyViolationException),
    ServiceFailureException(crate::error::ServiceFailureException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateLoginProfileError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateLoginProfileErrorKind::EntityTemporarilyUnmodifiableException(_inner) => {
                _inner.fmt(f)
            }
            UpdateLoginProfileErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            UpdateLoginProfileErrorKind::NoSuchEntityException(_inner) => _inner.fmt(f),
            UpdateLoginProfileErrorKind::PasswordPolicyViolationException(_inner) => _inner.fmt(f),
            UpdateLoginProfileErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            UpdateLoginProfileErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateLoginProfileError {
    fn code(&self) -> Option<&str> {
        UpdateLoginProfileError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateLoginProfileError {
    pub fn new(kind: UpdateLoginProfileErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateLoginProfileErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateLoginProfileErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_entity_temporarily_unmodifiable_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateLoginProfileErrorKind::EntityTemporarilyUnmodifiableException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateLoginProfileErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_no_such_entity_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateLoginProfileErrorKind::NoSuchEntityException(_)
        )
    }
    pub fn is_password_policy_violation_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateLoginProfileErrorKind::PasswordPolicyViolationException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateLoginProfileErrorKind::ServiceFailureException(_)
        )
    }
}
impl std::error::Error for UpdateLoginProfileError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateLoginProfileErrorKind::EntityTemporarilyUnmodifiableException(_inner) => {
                Some(_inner)
            }
            UpdateLoginProfileErrorKind::LimitExceededException(_inner) => Some(_inner),
            UpdateLoginProfileErrorKind::NoSuchEntityException(_inner) => Some(_inner),
            UpdateLoginProfileErrorKind::PasswordPolicyViolationException(_inner) => Some(_inner),
            UpdateLoginProfileErrorKind::ServiceFailureException(_inner) => Some(_inner),
            UpdateLoginProfileErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateOpenIDConnectProviderThumbprintError {
    pub kind: UpdateOpenIDConnectProviderThumbprintErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateOpenIDConnectProviderThumbprintErrorKind {
    InvalidInputException(crate::error::InvalidInputException),
    NoSuchEntityException(crate::error::NoSuchEntityException),
    ServiceFailureException(crate::error::ServiceFailureException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateOpenIDConnectProviderThumbprintError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateOpenIDConnectProviderThumbprintErrorKind::InvalidInputException(_inner) => {
                _inner.fmt(f)
            }
            UpdateOpenIDConnectProviderThumbprintErrorKind::NoSuchEntityException(_inner) => {
                _inner.fmt(f)
            }
            UpdateOpenIDConnectProviderThumbprintErrorKind::ServiceFailureException(_inner) => {
                _inner.fmt(f)
            }
            UpdateOpenIDConnectProviderThumbprintErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateOpenIDConnectProviderThumbprintError {
    fn code(&self) -> Option<&str> {
        UpdateOpenIDConnectProviderThumbprintError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateOpenIDConnectProviderThumbprintError {
    pub fn new(
        kind: UpdateOpenIDConnectProviderThumbprintErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateOpenIDConnectProviderThumbprintErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateOpenIDConnectProviderThumbprintErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateOpenIDConnectProviderThumbprintErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_no_such_entity_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateOpenIDConnectProviderThumbprintErrorKind::NoSuchEntityException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateOpenIDConnectProviderThumbprintErrorKind::ServiceFailureException(_)
        )
    }
}
impl std::error::Error for UpdateOpenIDConnectProviderThumbprintError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateOpenIDConnectProviderThumbprintErrorKind::InvalidInputException(_inner) => {
                Some(_inner)
            }
            UpdateOpenIDConnectProviderThumbprintErrorKind::NoSuchEntityException(_inner) => {
                Some(_inner)
            }
            UpdateOpenIDConnectProviderThumbprintErrorKind::ServiceFailureException(_inner) => {
                Some(_inner)
            }
            UpdateOpenIDConnectProviderThumbprintErrorKind::Unhandled(_inner) => {
                Some(_inner.as_ref())
            }
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateRoleError {
    pub kind: UpdateRoleErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateRoleErrorKind {
    NoSuchEntityException(crate::error::NoSuchEntityException),
    ServiceFailureException(crate::error::ServiceFailureException),
    UnmodifiableEntityException(crate::error::UnmodifiableEntityException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateRoleError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateRoleErrorKind::NoSuchEntityException(_inner) => _inner.fmt(f),
            UpdateRoleErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            UpdateRoleErrorKind::UnmodifiableEntityException(_inner) => _inner.fmt(f),
            UpdateRoleErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateRoleError {
    fn code(&self) -> Option<&str> {
        UpdateRoleError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateRoleError {
    pub fn new(kind: UpdateRoleErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateRoleErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateRoleErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_no_such_entity_exception(&self) -> bool {
        matches!(&self.kind, UpdateRoleErrorKind::NoSuchEntityException(_))
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(&self.kind, UpdateRoleErrorKind::ServiceFailureException(_))
    }
    pub fn is_unmodifiable_entity_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateRoleErrorKind::UnmodifiableEntityException(_)
        )
    }
}
impl std::error::Error for UpdateRoleError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateRoleErrorKind::NoSuchEntityException(_inner) => Some(_inner),
            UpdateRoleErrorKind::ServiceFailureException(_inner) => Some(_inner),
            UpdateRoleErrorKind::UnmodifiableEntityException(_inner) => Some(_inner),
            UpdateRoleErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateRoleDescriptionError {
    pub kind: UpdateRoleDescriptionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateRoleDescriptionErrorKind {
    NoSuchEntityException(crate::error::NoSuchEntityException),
    ServiceFailureException(crate::error::ServiceFailureException),
    UnmodifiableEntityException(crate::error::UnmodifiableEntityException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateRoleDescriptionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateRoleDescriptionErrorKind::NoSuchEntityException(_inner) => _inner.fmt(f),
            UpdateRoleDescriptionErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            UpdateRoleDescriptionErrorKind::UnmodifiableEntityException(_inner) => _inner.fmt(f),
            UpdateRoleDescriptionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateRoleDescriptionError {
    fn code(&self) -> Option<&str> {
        UpdateRoleDescriptionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateRoleDescriptionError {
    pub fn new(kind: UpdateRoleDescriptionErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateRoleDescriptionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateRoleDescriptionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_no_such_entity_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateRoleDescriptionErrorKind::NoSuchEntityException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateRoleDescriptionErrorKind::ServiceFailureException(_)
        )
    }
    pub fn is_unmodifiable_entity_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateRoleDescriptionErrorKind::UnmodifiableEntityException(_)
        )
    }
}
impl std::error::Error for UpdateRoleDescriptionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateRoleDescriptionErrorKind::NoSuchEntityException(_inner) => Some(_inner),
            UpdateRoleDescriptionErrorKind::ServiceFailureException(_inner) => Some(_inner),
            UpdateRoleDescriptionErrorKind::UnmodifiableEntityException(_inner) => Some(_inner),
            UpdateRoleDescriptionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateSAMLProviderError {
    pub kind: UpdateSAMLProviderErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateSAMLProviderErrorKind {
    InvalidInputException(crate::error::InvalidInputException),
    LimitExceededException(crate::error::LimitExceededException),
    NoSuchEntityException(crate::error::NoSuchEntityException),
    ServiceFailureException(crate::error::ServiceFailureException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateSAMLProviderError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateSAMLProviderErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            UpdateSAMLProviderErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            UpdateSAMLProviderErrorKind::NoSuchEntityException(_inner) => _inner.fmt(f),
            UpdateSAMLProviderErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            UpdateSAMLProviderErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateSAMLProviderError {
    fn code(&self) -> Option<&str> {
        UpdateSAMLProviderError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateSAMLProviderError {
    pub fn new(kind: UpdateSAMLProviderErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateSAMLProviderErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateSAMLProviderErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateSAMLProviderErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateSAMLProviderErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_no_such_entity_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateSAMLProviderErrorKind::NoSuchEntityException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateSAMLProviderErrorKind::ServiceFailureException(_)
        )
    }
}
impl std::error::Error for UpdateSAMLProviderError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateSAMLProviderErrorKind::InvalidInputException(_inner) => Some(_inner),
            UpdateSAMLProviderErrorKind::LimitExceededException(_inner) => Some(_inner),
            UpdateSAMLProviderErrorKind::NoSuchEntityException(_inner) => Some(_inner),
            UpdateSAMLProviderErrorKind::ServiceFailureException(_inner) => Some(_inner),
            UpdateSAMLProviderErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateServerCertificateError {
    pub kind: UpdateServerCertificateErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateServerCertificateErrorKind {
    EntityAlreadyExistsException(crate::error::EntityAlreadyExistsException),
    LimitExceededException(crate::error::LimitExceededException),
    NoSuchEntityException(crate::error::NoSuchEntityException),
    ServiceFailureException(crate::error::ServiceFailureException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateServerCertificateError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateServerCertificateErrorKind::EntityAlreadyExistsException(_inner) => _inner.fmt(f),
            UpdateServerCertificateErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            UpdateServerCertificateErrorKind::NoSuchEntityException(_inner) => _inner.fmt(f),
            UpdateServerCertificateErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            UpdateServerCertificateErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateServerCertificateError {
    fn code(&self) -> Option<&str> {
        UpdateServerCertificateError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateServerCertificateError {
    pub fn new(kind: UpdateServerCertificateErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateServerCertificateErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateServerCertificateErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_entity_already_exists_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateServerCertificateErrorKind::EntityAlreadyExistsException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateServerCertificateErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_no_such_entity_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateServerCertificateErrorKind::NoSuchEntityException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateServerCertificateErrorKind::ServiceFailureException(_)
        )
    }
}
impl std::error::Error for UpdateServerCertificateError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateServerCertificateErrorKind::EntityAlreadyExistsException(_inner) => Some(_inner),
            UpdateServerCertificateErrorKind::LimitExceededException(_inner) => Some(_inner),
            UpdateServerCertificateErrorKind::NoSuchEntityException(_inner) => Some(_inner),
            UpdateServerCertificateErrorKind::ServiceFailureException(_inner) => Some(_inner),
            UpdateServerCertificateErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateServiceSpecificCredentialError {
    pub kind: UpdateServiceSpecificCredentialErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateServiceSpecificCredentialErrorKind {
    NoSuchEntityException(crate::error::NoSuchEntityException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateServiceSpecificCredentialError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateServiceSpecificCredentialErrorKind::NoSuchEntityException(_inner) => {
                _inner.fmt(f)
            }
            UpdateServiceSpecificCredentialErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateServiceSpecificCredentialError {
    fn code(&self) -> Option<&str> {
        UpdateServiceSpecificCredentialError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateServiceSpecificCredentialError {
    pub fn new(kind: UpdateServiceSpecificCredentialErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateServiceSpecificCredentialErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateServiceSpecificCredentialErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_no_such_entity_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateServiceSpecificCredentialErrorKind::NoSuchEntityException(_)
        )
    }
}
impl std::error::Error for UpdateServiceSpecificCredentialError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateServiceSpecificCredentialErrorKind::NoSuchEntityException(_inner) => Some(_inner),
            UpdateServiceSpecificCredentialErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateSigningCertificateError {
    pub kind: UpdateSigningCertificateErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateSigningCertificateErrorKind {
    LimitExceededException(crate::error::LimitExceededException),
    NoSuchEntityException(crate::error::NoSuchEntityException),
    ServiceFailureException(crate::error::ServiceFailureException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateSigningCertificateError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateSigningCertificateErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            UpdateSigningCertificateErrorKind::NoSuchEntityException(_inner) => _inner.fmt(f),
            UpdateSigningCertificateErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            UpdateSigningCertificateErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateSigningCertificateError {
    fn code(&self) -> Option<&str> {
        UpdateSigningCertificateError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateSigningCertificateError {
    pub fn new(kind: UpdateSigningCertificateErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateSigningCertificateErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateSigningCertificateErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateSigningCertificateErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_no_such_entity_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateSigningCertificateErrorKind::NoSuchEntityException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateSigningCertificateErrorKind::ServiceFailureException(_)
        )
    }
}
impl std::error::Error for UpdateSigningCertificateError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateSigningCertificateErrorKind::LimitExceededException(_inner) => Some(_inner),
            UpdateSigningCertificateErrorKind::NoSuchEntityException(_inner) => Some(_inner),
            UpdateSigningCertificateErrorKind::ServiceFailureException(_inner) => Some(_inner),
            UpdateSigningCertificateErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateSSHPublicKeyError {
    pub kind: UpdateSSHPublicKeyErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateSSHPublicKeyErrorKind {
    NoSuchEntityException(crate::error::NoSuchEntityException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateSSHPublicKeyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateSSHPublicKeyErrorKind::NoSuchEntityException(_inner) => _inner.fmt(f),
            UpdateSSHPublicKeyErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateSSHPublicKeyError {
    fn code(&self) -> Option<&str> {
        UpdateSSHPublicKeyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateSSHPublicKeyError {
    pub fn new(kind: UpdateSSHPublicKeyErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateSSHPublicKeyErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateSSHPublicKeyErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_no_such_entity_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateSSHPublicKeyErrorKind::NoSuchEntityException(_)
        )
    }
}
impl std::error::Error for UpdateSSHPublicKeyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateSSHPublicKeyErrorKind::NoSuchEntityException(_inner) => Some(_inner),
            UpdateSSHPublicKeyErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateUserError {
    pub kind: UpdateUserErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateUserErrorKind {
    ConcurrentModificationException(crate::error::ConcurrentModificationException),
    EntityAlreadyExistsException(crate::error::EntityAlreadyExistsException),
    EntityTemporarilyUnmodifiableException(crate::error::EntityTemporarilyUnmodifiableException),
    LimitExceededException(crate::error::LimitExceededException),
    NoSuchEntityException(crate::error::NoSuchEntityException),
    ServiceFailureException(crate::error::ServiceFailureException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateUserError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateUserErrorKind::ConcurrentModificationException(_inner) => _inner.fmt(f),
            UpdateUserErrorKind::EntityAlreadyExistsException(_inner) => _inner.fmt(f),
            UpdateUserErrorKind::EntityTemporarilyUnmodifiableException(_inner) => _inner.fmt(f),
            UpdateUserErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            UpdateUserErrorKind::NoSuchEntityException(_inner) => _inner.fmt(f),
            UpdateUserErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            UpdateUserErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateUserError {
    fn code(&self) -> Option<&str> {
        UpdateUserError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateUserError {
    pub fn new(kind: UpdateUserErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateUserErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateUserErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_concurrent_modification_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateUserErrorKind::ConcurrentModificationException(_)
        )
    }
    pub fn is_entity_already_exists_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateUserErrorKind::EntityAlreadyExistsException(_)
        )
    }
    pub fn is_entity_temporarily_unmodifiable_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateUserErrorKind::EntityTemporarilyUnmodifiableException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(&self.kind, UpdateUserErrorKind::LimitExceededException(_))
    }
    pub fn is_no_such_entity_exception(&self) -> bool {
        matches!(&self.kind, UpdateUserErrorKind::NoSuchEntityException(_))
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(&self.kind, UpdateUserErrorKind::ServiceFailureException(_))
    }
}
impl std::error::Error for UpdateUserError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateUserErrorKind::ConcurrentModificationException(_inner) => Some(_inner),
            UpdateUserErrorKind::EntityAlreadyExistsException(_inner) => Some(_inner),
            UpdateUserErrorKind::EntityTemporarilyUnmodifiableException(_inner) => Some(_inner),
            UpdateUserErrorKind::LimitExceededException(_inner) => Some(_inner),
            UpdateUserErrorKind::NoSuchEntityException(_inner) => Some(_inner),
            UpdateUserErrorKind::ServiceFailureException(_inner) => Some(_inner),
            UpdateUserErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UploadServerCertificateError {
    pub kind: UploadServerCertificateErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UploadServerCertificateErrorKind {
    ConcurrentModificationException(crate::error::ConcurrentModificationException),
    EntityAlreadyExistsException(crate::error::EntityAlreadyExistsException),
    InvalidInputException(crate::error::InvalidInputException),
    KeyPairMismatchException(crate::error::KeyPairMismatchException),
    LimitExceededException(crate::error::LimitExceededException),
    MalformedCertificateException(crate::error::MalformedCertificateException),
    ServiceFailureException(crate::error::ServiceFailureException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UploadServerCertificateError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UploadServerCertificateErrorKind::ConcurrentModificationException(_inner) => {
                _inner.fmt(f)
            }
            UploadServerCertificateErrorKind::EntityAlreadyExistsException(_inner) => _inner.fmt(f),
            UploadServerCertificateErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            UploadServerCertificateErrorKind::KeyPairMismatchException(_inner) => _inner.fmt(f),
            UploadServerCertificateErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            UploadServerCertificateErrorKind::MalformedCertificateException(_inner) => {
                _inner.fmt(f)
            }
            UploadServerCertificateErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            UploadServerCertificateErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UploadServerCertificateError {
    fn code(&self) -> Option<&str> {
        UploadServerCertificateError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UploadServerCertificateError {
    pub fn new(kind: UploadServerCertificateErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UploadServerCertificateErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UploadServerCertificateErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_concurrent_modification_exception(&self) -> bool {
        matches!(
            &self.kind,
            UploadServerCertificateErrorKind::ConcurrentModificationException(_)
        )
    }
    pub fn is_entity_already_exists_exception(&self) -> bool {
        matches!(
            &self.kind,
            UploadServerCertificateErrorKind::EntityAlreadyExistsException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            UploadServerCertificateErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_key_pair_mismatch_exception(&self) -> bool {
        matches!(
            &self.kind,
            UploadServerCertificateErrorKind::KeyPairMismatchException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            UploadServerCertificateErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_malformed_certificate_exception(&self) -> bool {
        matches!(
            &self.kind,
            UploadServerCertificateErrorKind::MalformedCertificateException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            UploadServerCertificateErrorKind::ServiceFailureException(_)
        )
    }
}
impl std::error::Error for UploadServerCertificateError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UploadServerCertificateErrorKind::ConcurrentModificationException(_inner) => {
                Some(_inner)
            }
            UploadServerCertificateErrorKind::EntityAlreadyExistsException(_inner) => Some(_inner),
            UploadServerCertificateErrorKind::InvalidInputException(_inner) => Some(_inner),
            UploadServerCertificateErrorKind::KeyPairMismatchException(_inner) => Some(_inner),
            UploadServerCertificateErrorKind::LimitExceededException(_inner) => Some(_inner),
            UploadServerCertificateErrorKind::MalformedCertificateException(_inner) => Some(_inner),
            UploadServerCertificateErrorKind::ServiceFailureException(_inner) => Some(_inner),
            UploadServerCertificateErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UploadSigningCertificateError {
    pub kind: UploadSigningCertificateErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UploadSigningCertificateErrorKind {
    DuplicateCertificateException(crate::error::DuplicateCertificateException),
    EntityAlreadyExistsException(crate::error::EntityAlreadyExistsException),
    InvalidCertificateException(crate::error::InvalidCertificateException),
    LimitExceededException(crate::error::LimitExceededException),
    MalformedCertificateException(crate::error::MalformedCertificateException),
    NoSuchEntityException(crate::error::NoSuchEntityException),
    ServiceFailureException(crate::error::ServiceFailureException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UploadSigningCertificateError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UploadSigningCertificateErrorKind::DuplicateCertificateException(_inner) => {
                _inner.fmt(f)
            }
            UploadSigningCertificateErrorKind::EntityAlreadyExistsException(_inner) => {
                _inner.fmt(f)
            }
            UploadSigningCertificateErrorKind::InvalidCertificateException(_inner) => _inner.fmt(f),
            UploadSigningCertificateErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            UploadSigningCertificateErrorKind::MalformedCertificateException(_inner) => {
                _inner.fmt(f)
            }
            UploadSigningCertificateErrorKind::NoSuchEntityException(_inner) => _inner.fmt(f),
            UploadSigningCertificateErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            UploadSigningCertificateErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UploadSigningCertificateError {
    fn code(&self) -> Option<&str> {
        UploadSigningCertificateError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UploadSigningCertificateError {
    pub fn new(kind: UploadSigningCertificateErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UploadSigningCertificateErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UploadSigningCertificateErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_duplicate_certificate_exception(&self) -> bool {
        matches!(
            &self.kind,
            UploadSigningCertificateErrorKind::DuplicateCertificateException(_)
        )
    }
    pub fn is_entity_already_exists_exception(&self) -> bool {
        matches!(
            &self.kind,
            UploadSigningCertificateErrorKind::EntityAlreadyExistsException(_)
        )
    }
    pub fn is_invalid_certificate_exception(&self) -> bool {
        matches!(
            &self.kind,
            UploadSigningCertificateErrorKind::InvalidCertificateException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            UploadSigningCertificateErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_malformed_certificate_exception(&self) -> bool {
        matches!(
            &self.kind,
            UploadSigningCertificateErrorKind::MalformedCertificateException(_)
        )
    }
    pub fn is_no_such_entity_exception(&self) -> bool {
        matches!(
            &self.kind,
            UploadSigningCertificateErrorKind::NoSuchEntityException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            UploadSigningCertificateErrorKind::ServiceFailureException(_)
        )
    }
}
impl std::error::Error for UploadSigningCertificateError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UploadSigningCertificateErrorKind::DuplicateCertificateException(_inner) => {
                Some(_inner)
            }
            UploadSigningCertificateErrorKind::EntityAlreadyExistsException(_inner) => Some(_inner),
            UploadSigningCertificateErrorKind::InvalidCertificateException(_inner) => Some(_inner),
            UploadSigningCertificateErrorKind::LimitExceededException(_inner) => Some(_inner),
            UploadSigningCertificateErrorKind::MalformedCertificateException(_inner) => {
                Some(_inner)
            }
            UploadSigningCertificateErrorKind::NoSuchEntityException(_inner) => Some(_inner),
            UploadSigningCertificateErrorKind::ServiceFailureException(_inner) => Some(_inner),
            UploadSigningCertificateErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UploadSSHPublicKeyError {
    pub kind: UploadSSHPublicKeyErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UploadSSHPublicKeyErrorKind {
    DuplicateSshPublicKeyException(crate::error::DuplicateSshPublicKeyException),
    InvalidPublicKeyException(crate::error::InvalidPublicKeyException),
    LimitExceededException(crate::error::LimitExceededException),
    NoSuchEntityException(crate::error::NoSuchEntityException),
    UnrecognizedPublicKeyEncodingException(crate::error::UnrecognizedPublicKeyEncodingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UploadSSHPublicKeyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UploadSSHPublicKeyErrorKind::DuplicateSshPublicKeyException(_inner) => _inner.fmt(f),
            UploadSSHPublicKeyErrorKind::InvalidPublicKeyException(_inner) => _inner.fmt(f),
            UploadSSHPublicKeyErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            UploadSSHPublicKeyErrorKind::NoSuchEntityException(_inner) => _inner.fmt(f),
            UploadSSHPublicKeyErrorKind::UnrecognizedPublicKeyEncodingException(_inner) => {
                _inner.fmt(f)
            }
            UploadSSHPublicKeyErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UploadSSHPublicKeyError {
    fn code(&self) -> Option<&str> {
        UploadSSHPublicKeyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UploadSSHPublicKeyError {
    pub fn new(kind: UploadSSHPublicKeyErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UploadSSHPublicKeyErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UploadSSHPublicKeyErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_duplicate_ssh_public_key_exception(&self) -> bool {
        matches!(
            &self.kind,
            UploadSSHPublicKeyErrorKind::DuplicateSshPublicKeyException(_)
        )
    }
    pub fn is_invalid_public_key_exception(&self) -> bool {
        matches!(
            &self.kind,
            UploadSSHPublicKeyErrorKind::InvalidPublicKeyException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            UploadSSHPublicKeyErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_no_such_entity_exception(&self) -> bool {
        matches!(
            &self.kind,
            UploadSSHPublicKeyErrorKind::NoSuchEntityException(_)
        )
    }
    pub fn is_unrecognized_public_key_encoding_exception(&self) -> bool {
        matches!(
            &self.kind,
            UploadSSHPublicKeyErrorKind::UnrecognizedPublicKeyEncodingException(_)
        )
    }
}
impl std::error::Error for UploadSSHPublicKeyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UploadSSHPublicKeyErrorKind::DuplicateSshPublicKeyException(_inner) => Some(_inner),
            UploadSSHPublicKeyErrorKind::InvalidPublicKeyException(_inner) => Some(_inner),
            UploadSSHPublicKeyErrorKind::LimitExceededException(_inner) => Some(_inner),
            UploadSSHPublicKeyErrorKind::NoSuchEntityException(_inner) => Some(_inner),
            UploadSSHPublicKeyErrorKind::UnrecognizedPublicKeyEncodingException(_inner) => {
                Some(_inner)
            }
            UploadSSHPublicKeyErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// <p>The request was rejected because the public key encoding format is unsupported or
/// unrecognized.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UnrecognizedPublicKeyEncodingException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for UnrecognizedPublicKeyEncodingException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UnrecognizedPublicKeyEncodingException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl UnrecognizedPublicKeyEncodingException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for UnrecognizedPublicKeyEncodingException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "UnrecognizedPublicKeyEncodingException")?;
        if let Some(inner_1) = &self.message {
            write!(f, ": {}", inner_1)?;
        }
        Ok(())
    }
}
impl std::error::Error for UnrecognizedPublicKeyEncodingException {}
/// See [`UnrecognizedPublicKeyEncodingException`](crate::error::UnrecognizedPublicKeyEncodingException)
pub mod unrecognized_public_key_encoding_exception {
    /// A builder for [`UnrecognizedPublicKeyEncodingException`](crate::error::UnrecognizedPublicKeyEncodingException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`UnrecognizedPublicKeyEncodingException`](crate::error::UnrecognizedPublicKeyEncodingException)
        pub fn build(self) -> crate::error::UnrecognizedPublicKeyEncodingException {
            crate::error::UnrecognizedPublicKeyEncodingException {
                message: self.message,
            }
        }
    }
}
impl UnrecognizedPublicKeyEncodingException {
    /// Creates a new builder-style object to manufacture [`UnrecognizedPublicKeyEncodingException`](crate::error::UnrecognizedPublicKeyEncodingException)
    pub fn builder() -> crate::error::unrecognized_public_key_encoding_exception::Builder {
        crate::error::unrecognized_public_key_encoding_exception::Builder::default()
    }
}

/// <p>The request was rejected because it referenced a resource entity that does not exist. The
/// error message describes the resource.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct NoSuchEntityException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for NoSuchEntityException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("NoSuchEntityException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl NoSuchEntityException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for NoSuchEntityException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "NoSuchEntityException")?;
        if let Some(inner_2) = &self.message {
            write!(f, ": {}", inner_2)?;
        }
        Ok(())
    }
}
impl std::error::Error for NoSuchEntityException {}
/// See [`NoSuchEntityException`](crate::error::NoSuchEntityException)
pub mod no_such_entity_exception {
    /// A builder for [`NoSuchEntityException`](crate::error::NoSuchEntityException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`NoSuchEntityException`](crate::error::NoSuchEntityException)
        pub fn build(self) -> crate::error::NoSuchEntityException {
            crate::error::NoSuchEntityException {
                message: self.message,
            }
        }
    }
}
impl NoSuchEntityException {
    /// Creates a new builder-style object to manufacture [`NoSuchEntityException`](crate::error::NoSuchEntityException)
    pub fn builder() -> crate::error::no_such_entity_exception::Builder {
        crate::error::no_such_entity_exception::Builder::default()
    }
}

/// <p>The request was rejected because it attempted to create resources beyond the current Amazon Web Services
/// account limits. The error message describes the limit exceeded.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct LimitExceededException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for LimitExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("LimitExceededException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl LimitExceededException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for LimitExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "LimitExceededException")?;
        if let Some(inner_3) = &self.message {
            write!(f, ": {}", inner_3)?;
        }
        Ok(())
    }
}
impl std::error::Error for LimitExceededException {}
/// See [`LimitExceededException`](crate::error::LimitExceededException)
pub mod limit_exceeded_exception {
    /// A builder for [`LimitExceededException`](crate::error::LimitExceededException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`LimitExceededException`](crate::error::LimitExceededException)
        pub fn build(self) -> crate::error::LimitExceededException {
            crate::error::LimitExceededException {
                message: self.message,
            }
        }
    }
}
impl LimitExceededException {
    /// Creates a new builder-style object to manufacture [`LimitExceededException`](crate::error::LimitExceededException)
    pub fn builder() -> crate::error::limit_exceeded_exception::Builder {
        crate::error::limit_exceeded_exception::Builder::default()
    }
}

/// <p>The request was rejected because the public key is malformed or otherwise invalid.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidPublicKeyException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidPublicKeyException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidPublicKeyException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidPublicKeyException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidPublicKeyException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidPublicKeyException")?;
        if let Some(inner_4) = &self.message {
            write!(f, ": {}", inner_4)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidPublicKeyException {}
/// See [`InvalidPublicKeyException`](crate::error::InvalidPublicKeyException)
pub mod invalid_public_key_exception {
    /// A builder for [`InvalidPublicKeyException`](crate::error::InvalidPublicKeyException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidPublicKeyException`](crate::error::InvalidPublicKeyException)
        pub fn build(self) -> crate::error::InvalidPublicKeyException {
            crate::error::InvalidPublicKeyException {
                message: self.message,
            }
        }
    }
}
impl InvalidPublicKeyException {
    /// Creates a new builder-style object to manufacture [`InvalidPublicKeyException`](crate::error::InvalidPublicKeyException)
    pub fn builder() -> crate::error::invalid_public_key_exception::Builder {
        crate::error::invalid_public_key_exception::Builder::default()
    }
}

/// <p>The request was rejected because the SSH public key is already associated with the
/// specified IAM user.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DuplicateSshPublicKeyException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DuplicateSshPublicKeyException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DuplicateSshPublicKeyException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl DuplicateSshPublicKeyException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for DuplicateSshPublicKeyException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "DuplicateSshPublicKeyException [DuplicateSSHPublicKeyException]"
        )?;
        if let Some(inner_5) = &self.message {
            write!(f, ": {}", inner_5)?;
        }
        Ok(())
    }
}
impl std::error::Error for DuplicateSshPublicKeyException {}
/// See [`DuplicateSshPublicKeyException`](crate::error::DuplicateSshPublicKeyException)
pub mod duplicate_ssh_public_key_exception {
    /// A builder for [`DuplicateSshPublicKeyException`](crate::error::DuplicateSshPublicKeyException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`DuplicateSshPublicKeyException`](crate::error::DuplicateSshPublicKeyException)
        pub fn build(self) -> crate::error::DuplicateSshPublicKeyException {
            crate::error::DuplicateSshPublicKeyException {
                message: self.message,
            }
        }
    }
}
impl DuplicateSshPublicKeyException {
    /// Creates a new builder-style object to manufacture [`DuplicateSshPublicKeyException`](crate::error::DuplicateSshPublicKeyException)
    pub fn builder() -> crate::error::duplicate_ssh_public_key_exception::Builder {
        crate::error::duplicate_ssh_public_key_exception::Builder::default()
    }
}

/// <p>The request processing has failed because of an unknown error, exception or
/// failure.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ServiceFailureException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ServiceFailureException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ServiceFailureException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ServiceFailureException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ServiceFailureException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ServiceFailureException")?;
        if let Some(inner_6) = &self.message {
            write!(f, ": {}", inner_6)?;
        }
        Ok(())
    }
}
impl std::error::Error for ServiceFailureException {}
/// See [`ServiceFailureException`](crate::error::ServiceFailureException)
pub mod service_failure_exception {
    /// A builder for [`ServiceFailureException`](crate::error::ServiceFailureException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ServiceFailureException`](crate::error::ServiceFailureException)
        pub fn build(self) -> crate::error::ServiceFailureException {
            crate::error::ServiceFailureException {
                message: self.message,
            }
        }
    }
}
impl ServiceFailureException {
    /// Creates a new builder-style object to manufacture [`ServiceFailureException`](crate::error::ServiceFailureException)
    pub fn builder() -> crate::error::service_failure_exception::Builder {
        crate::error::service_failure_exception::Builder::default()
    }
}

/// <p>The request was rejected because the certificate was malformed or expired. The error
/// message describes the specific error.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct MalformedCertificateException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for MalformedCertificateException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("MalformedCertificateException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl MalformedCertificateException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for MalformedCertificateException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "MalformedCertificateException")?;
        if let Some(inner_7) = &self.message {
            write!(f, ": {}", inner_7)?;
        }
        Ok(())
    }
}
impl std::error::Error for MalformedCertificateException {}
/// See [`MalformedCertificateException`](crate::error::MalformedCertificateException)
pub mod malformed_certificate_exception {
    /// A builder for [`MalformedCertificateException`](crate::error::MalformedCertificateException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`MalformedCertificateException`](crate::error::MalformedCertificateException)
        pub fn build(self) -> crate::error::MalformedCertificateException {
            crate::error::MalformedCertificateException {
                message: self.message,
            }
        }
    }
}
impl MalformedCertificateException {
    /// Creates a new builder-style object to manufacture [`MalformedCertificateException`](crate::error::MalformedCertificateException)
    pub fn builder() -> crate::error::malformed_certificate_exception::Builder {
        crate::error::malformed_certificate_exception::Builder::default()
    }
}

/// <p>The request was rejected because the certificate is invalid.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidCertificateException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidCertificateException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidCertificateException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidCertificateException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidCertificateException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidCertificateException")?;
        if let Some(inner_8) = &self.message {
            write!(f, ": {}", inner_8)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidCertificateException {}
/// See [`InvalidCertificateException`](crate::error::InvalidCertificateException)
pub mod invalid_certificate_exception {
    /// A builder for [`InvalidCertificateException`](crate::error::InvalidCertificateException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidCertificateException`](crate::error::InvalidCertificateException)
        pub fn build(self) -> crate::error::InvalidCertificateException {
            crate::error::InvalidCertificateException {
                message: self.message,
            }
        }
    }
}
impl InvalidCertificateException {
    /// Creates a new builder-style object to manufacture [`InvalidCertificateException`](crate::error::InvalidCertificateException)
    pub fn builder() -> crate::error::invalid_certificate_exception::Builder {
        crate::error::invalid_certificate_exception::Builder::default()
    }
}

/// <p>The request was rejected because it attempted to create a resource that already
/// exists.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct EntityAlreadyExistsException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for EntityAlreadyExistsException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("EntityAlreadyExistsException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl EntityAlreadyExistsException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for EntityAlreadyExistsException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "EntityAlreadyExistsException")?;
        if let Some(inner_9) = &self.message {
            write!(f, ": {}", inner_9)?;
        }
        Ok(())
    }
}
impl std::error::Error for EntityAlreadyExistsException {}
/// See [`EntityAlreadyExistsException`](crate::error::EntityAlreadyExistsException)
pub mod entity_already_exists_exception {
    /// A builder for [`EntityAlreadyExistsException`](crate::error::EntityAlreadyExistsException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`EntityAlreadyExistsException`](crate::error::EntityAlreadyExistsException)
        pub fn build(self) -> crate::error::EntityAlreadyExistsException {
            crate::error::EntityAlreadyExistsException {
                message: self.message,
            }
        }
    }
}
impl EntityAlreadyExistsException {
    /// Creates a new builder-style object to manufacture [`EntityAlreadyExistsException`](crate::error::EntityAlreadyExistsException)
    pub fn builder() -> crate::error::entity_already_exists_exception::Builder {
        crate::error::entity_already_exists_exception::Builder::default()
    }
}

/// <p>The request was rejected because the same certificate is associated with an IAM user in
/// the account.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DuplicateCertificateException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DuplicateCertificateException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DuplicateCertificateException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl DuplicateCertificateException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for DuplicateCertificateException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "DuplicateCertificateException")?;
        if let Some(inner_10) = &self.message {
            write!(f, ": {}", inner_10)?;
        }
        Ok(())
    }
}
impl std::error::Error for DuplicateCertificateException {}
/// See [`DuplicateCertificateException`](crate::error::DuplicateCertificateException)
pub mod duplicate_certificate_exception {
    /// A builder for [`DuplicateCertificateException`](crate::error::DuplicateCertificateException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`DuplicateCertificateException`](crate::error::DuplicateCertificateException)
        pub fn build(self) -> crate::error::DuplicateCertificateException {
            crate::error::DuplicateCertificateException {
                message: self.message,
            }
        }
    }
}
impl DuplicateCertificateException {
    /// Creates a new builder-style object to manufacture [`DuplicateCertificateException`](crate::error::DuplicateCertificateException)
    pub fn builder() -> crate::error::duplicate_certificate_exception::Builder {
        crate::error::duplicate_certificate_exception::Builder::default()
    }
}

/// <p>The request was rejected because the public key certificate and the private key do not
/// match.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct KeyPairMismatchException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for KeyPairMismatchException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("KeyPairMismatchException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl KeyPairMismatchException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for KeyPairMismatchException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "KeyPairMismatchException")?;
        if let Some(inner_11) = &self.message {
            write!(f, ": {}", inner_11)?;
        }
        Ok(())
    }
}
impl std::error::Error for KeyPairMismatchException {}
/// See [`KeyPairMismatchException`](crate::error::KeyPairMismatchException)
pub mod key_pair_mismatch_exception {
    /// A builder for [`KeyPairMismatchException`](crate::error::KeyPairMismatchException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`KeyPairMismatchException`](crate::error::KeyPairMismatchException)
        pub fn build(self) -> crate::error::KeyPairMismatchException {
            crate::error::KeyPairMismatchException {
                message: self.message,
            }
        }
    }
}
impl KeyPairMismatchException {
    /// Creates a new builder-style object to manufacture [`KeyPairMismatchException`](crate::error::KeyPairMismatchException)
    pub fn builder() -> crate::error::key_pair_mismatch_exception::Builder {
        crate::error::key_pair_mismatch_exception::Builder::default()
    }
}

/// <p>The request was rejected because an invalid or out-of-range value was supplied for an
/// input parameter.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidInputException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidInputException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidInputException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidInputException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidInputException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidInputException")?;
        if let Some(inner_12) = &self.message {
            write!(f, ": {}", inner_12)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidInputException {}
/// See [`InvalidInputException`](crate::error::InvalidInputException)
pub mod invalid_input_exception {
    /// A builder for [`InvalidInputException`](crate::error::InvalidInputException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidInputException`](crate::error::InvalidInputException)
        pub fn build(self) -> crate::error::InvalidInputException {
            crate::error::InvalidInputException {
                message: self.message,
            }
        }
    }
}
impl InvalidInputException {
    /// Creates a new builder-style object to manufacture [`InvalidInputException`](crate::error::InvalidInputException)
    pub fn builder() -> crate::error::invalid_input_exception::Builder {
        crate::error::invalid_input_exception::Builder::default()
    }
}

/// <p>The request was rejected because multiple requests to change this object were submitted
/// simultaneously. Wait a few minutes and submit your request again.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ConcurrentModificationException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ConcurrentModificationException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ConcurrentModificationException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ConcurrentModificationException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ConcurrentModificationException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ConcurrentModificationException")?;
        if let Some(inner_13) = &self.message {
            write!(f, ": {}", inner_13)?;
        }
        Ok(())
    }
}
impl std::error::Error for ConcurrentModificationException {}
/// See [`ConcurrentModificationException`](crate::error::ConcurrentModificationException)
pub mod concurrent_modification_exception {
    /// A builder for [`ConcurrentModificationException`](crate::error::ConcurrentModificationException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ConcurrentModificationException`](crate::error::ConcurrentModificationException)
        pub fn build(self) -> crate::error::ConcurrentModificationException {
            crate::error::ConcurrentModificationException {
                message: self.message,
            }
        }
    }
}
impl ConcurrentModificationException {
    /// Creates a new builder-style object to manufacture [`ConcurrentModificationException`](crate::error::ConcurrentModificationException)
    pub fn builder() -> crate::error::concurrent_modification_exception::Builder {
        crate::error::concurrent_modification_exception::Builder::default()
    }
}

/// <p>The request was rejected because it referenced an entity that is temporarily unmodifiable,
/// such as a user name that was deleted and then recreated. The error indicates that the request
/// is likely to succeed if you try again after waiting several minutes. The error message
/// describes the entity.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct EntityTemporarilyUnmodifiableException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for EntityTemporarilyUnmodifiableException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("EntityTemporarilyUnmodifiableException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl EntityTemporarilyUnmodifiableException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for EntityTemporarilyUnmodifiableException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "EntityTemporarilyUnmodifiableException")?;
        if let Some(inner_14) = &self.message {
            write!(f, ": {}", inner_14)?;
        }
        Ok(())
    }
}
impl std::error::Error for EntityTemporarilyUnmodifiableException {}
/// See [`EntityTemporarilyUnmodifiableException`](crate::error::EntityTemporarilyUnmodifiableException)
pub mod entity_temporarily_unmodifiable_exception {
    /// A builder for [`EntityTemporarilyUnmodifiableException`](crate::error::EntityTemporarilyUnmodifiableException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`EntityTemporarilyUnmodifiableException`](crate::error::EntityTemporarilyUnmodifiableException)
        pub fn build(self) -> crate::error::EntityTemporarilyUnmodifiableException {
            crate::error::EntityTemporarilyUnmodifiableException {
                message: self.message,
            }
        }
    }
}
impl EntityTemporarilyUnmodifiableException {
    /// Creates a new builder-style object to manufacture [`EntityTemporarilyUnmodifiableException`](crate::error::EntityTemporarilyUnmodifiableException)
    pub fn builder() -> crate::error::entity_temporarily_unmodifiable_exception::Builder {
        crate::error::entity_temporarily_unmodifiable_exception::Builder::default()
    }
}

/// <p>The request was rejected because only the service that depends on the service-linked role
/// can modify or delete the role on your behalf. The error message includes the name of the
/// service that depends on this service-linked role. You must request the change through that
/// service.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UnmodifiableEntityException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for UnmodifiableEntityException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UnmodifiableEntityException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl UnmodifiableEntityException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for UnmodifiableEntityException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "UnmodifiableEntityException")?;
        if let Some(inner_15) = &self.message {
            write!(f, ": {}", inner_15)?;
        }
        Ok(())
    }
}
impl std::error::Error for UnmodifiableEntityException {}
/// See [`UnmodifiableEntityException`](crate::error::UnmodifiableEntityException)
pub mod unmodifiable_entity_exception {
    /// A builder for [`UnmodifiableEntityException`](crate::error::UnmodifiableEntityException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`UnmodifiableEntityException`](crate::error::UnmodifiableEntityException)
        pub fn build(self) -> crate::error::UnmodifiableEntityException {
            crate::error::UnmodifiableEntityException {
                message: self.message,
            }
        }
    }
}
impl UnmodifiableEntityException {
    /// Creates a new builder-style object to manufacture [`UnmodifiableEntityException`](crate::error::UnmodifiableEntityException)
    pub fn builder() -> crate::error::unmodifiable_entity_exception::Builder {
        crate::error::unmodifiable_entity_exception::Builder::default()
    }
}

/// <p>The request was rejected because the provided password did not meet the requirements
/// imposed by the account password policy.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PasswordPolicyViolationException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for PasswordPolicyViolationException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PasswordPolicyViolationException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl PasswordPolicyViolationException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for PasswordPolicyViolationException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "PasswordPolicyViolationException")?;
        if let Some(inner_16) = &self.message {
            write!(f, ": {}", inner_16)?;
        }
        Ok(())
    }
}
impl std::error::Error for PasswordPolicyViolationException {}
/// See [`PasswordPolicyViolationException`](crate::error::PasswordPolicyViolationException)
pub mod password_policy_violation_exception {
    /// A builder for [`PasswordPolicyViolationException`](crate::error::PasswordPolicyViolationException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`PasswordPolicyViolationException`](crate::error::PasswordPolicyViolationException)
        pub fn build(self) -> crate::error::PasswordPolicyViolationException {
            crate::error::PasswordPolicyViolationException {
                message: self.message,
            }
        }
    }
}
impl PasswordPolicyViolationException {
    /// Creates a new builder-style object to manufacture [`PasswordPolicyViolationException`](crate::error::PasswordPolicyViolationException)
    pub fn builder() -> crate::error::password_policy_violation_exception::Builder {
        crate::error::password_policy_violation_exception::Builder::default()
    }
}

/// <p>The request was rejected because the policy document was malformed. The error message
/// describes the specific error.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct MalformedPolicyDocumentException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for MalformedPolicyDocumentException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("MalformedPolicyDocumentException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl MalformedPolicyDocumentException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for MalformedPolicyDocumentException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "MalformedPolicyDocumentException")?;
        if let Some(inner_17) = &self.message {
            write!(f, ": {}", inner_17)?;
        }
        Ok(())
    }
}
impl std::error::Error for MalformedPolicyDocumentException {}
/// See [`MalformedPolicyDocumentException`](crate::error::MalformedPolicyDocumentException)
pub mod malformed_policy_document_exception {
    /// A builder for [`MalformedPolicyDocumentException`](crate::error::MalformedPolicyDocumentException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`MalformedPolicyDocumentException`](crate::error::MalformedPolicyDocumentException)
        pub fn build(self) -> crate::error::MalformedPolicyDocumentException {
            crate::error::MalformedPolicyDocumentException {
                message: self.message,
            }
        }
    }
}
impl MalformedPolicyDocumentException {
    /// Creates a new builder-style object to manufacture [`MalformedPolicyDocumentException`](crate::error::MalformedPolicyDocumentException)
    pub fn builder() -> crate::error::malformed_policy_document_exception::Builder {
        crate::error::malformed_policy_document_exception::Builder::default()
    }
}

/// <p>The request failed because a provided policy could not be successfully evaluated. An
/// additional detailed message indicates the source of the failure.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PolicyEvaluationException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for PolicyEvaluationException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PolicyEvaluationException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl PolicyEvaluationException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for PolicyEvaluationException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "PolicyEvaluationException")?;
        if let Some(inner_18) = &self.message {
            write!(f, ": {}", inner_18)?;
        }
        Ok(())
    }
}
impl std::error::Error for PolicyEvaluationException {}
/// See [`PolicyEvaluationException`](crate::error::PolicyEvaluationException)
pub mod policy_evaluation_exception {
    /// A builder for [`PolicyEvaluationException`](crate::error::PolicyEvaluationException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`PolicyEvaluationException`](crate::error::PolicyEvaluationException)
        pub fn build(self) -> crate::error::PolicyEvaluationException {
            crate::error::PolicyEvaluationException {
                message: self.message,
            }
        }
    }
}
impl PolicyEvaluationException {
    /// Creates a new builder-style object to manufacture [`PolicyEvaluationException`](crate::error::PolicyEvaluationException)
    pub fn builder() -> crate::error::policy_evaluation_exception::Builder {
        crate::error::policy_evaluation_exception::Builder::default()
    }
}

/// <p>The request was rejected because the authentication code was not recognized. The error
/// message describes the specific error.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidAuthenticationCodeException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidAuthenticationCodeException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidAuthenticationCodeException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidAuthenticationCodeException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidAuthenticationCodeException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidAuthenticationCodeException")?;
        if let Some(inner_19) = &self.message {
            write!(f, ": {}", inner_19)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidAuthenticationCodeException {}
/// See [`InvalidAuthenticationCodeException`](crate::error::InvalidAuthenticationCodeException)
pub mod invalid_authentication_code_exception {
    /// A builder for [`InvalidAuthenticationCodeException`](crate::error::InvalidAuthenticationCodeException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidAuthenticationCodeException`](crate::error::InvalidAuthenticationCodeException)
        pub fn build(self) -> crate::error::InvalidAuthenticationCodeException {
            crate::error::InvalidAuthenticationCodeException {
                message: self.message,
            }
        }
    }
}
impl InvalidAuthenticationCodeException {
    /// Creates a new builder-style object to manufacture [`InvalidAuthenticationCodeException`](crate::error::InvalidAuthenticationCodeException)
    pub fn builder() -> crate::error::invalid_authentication_code_exception::Builder {
        crate::error::invalid_authentication_code_exception::Builder::default()
    }
}

/// <p>The request failed because Amazon Web Services service role policies can only be attached to the
/// service-linked role for that service.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PolicyNotAttachableException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for PolicyNotAttachableException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PolicyNotAttachableException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl PolicyNotAttachableException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for PolicyNotAttachableException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "PolicyNotAttachableException")?;
        if let Some(inner_20) = &self.message {
            write!(f, ": {}", inner_20)?;
        }
        Ok(())
    }
}
impl std::error::Error for PolicyNotAttachableException {}
/// See [`PolicyNotAttachableException`](crate::error::PolicyNotAttachableException)
pub mod policy_not_attachable_exception {
    /// A builder for [`PolicyNotAttachableException`](crate::error::PolicyNotAttachableException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`PolicyNotAttachableException`](crate::error::PolicyNotAttachableException)
        pub fn build(self) -> crate::error::PolicyNotAttachableException {
            crate::error::PolicyNotAttachableException {
                message: self.message,
            }
        }
    }
}
impl PolicyNotAttachableException {
    /// Creates a new builder-style object to manufacture [`PolicyNotAttachableException`](crate::error::PolicyNotAttachableException)
    pub fn builder() -> crate::error::policy_not_attachable_exception::Builder {
        crate::error::policy_not_attachable_exception::Builder::default()
    }
}

/// <p>The specified service does not support service-specific credentials.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ServiceNotSupportedException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ServiceNotSupportedException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ServiceNotSupportedException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ServiceNotSupportedException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ServiceNotSupportedException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ServiceNotSupportedException")?;
        if let Some(inner_21) = &self.message {
            write!(f, ": {}", inner_21)?;
        }
        Ok(())
    }
}
impl std::error::Error for ServiceNotSupportedException {}
/// See [`ServiceNotSupportedException`](crate::error::ServiceNotSupportedException)
pub mod service_not_supported_exception {
    /// A builder for [`ServiceNotSupportedException`](crate::error::ServiceNotSupportedException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ServiceNotSupportedException`](crate::error::ServiceNotSupportedException)
        pub fn build(self) -> crate::error::ServiceNotSupportedException {
            crate::error::ServiceNotSupportedException {
                message: self.message,
            }
        }
    }
}
impl ServiceNotSupportedException {
    /// Creates a new builder-style object to manufacture [`ServiceNotSupportedException`](crate::error::ServiceNotSupportedException)
    pub fn builder() -> crate::error::service_not_supported_exception::Builder {
        crate::error::service_not_supported_exception::Builder::default()
    }
}

/// <p>The request was rejected because the credential report is still being generated.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CredentialReportNotReadyException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for CredentialReportNotReadyException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CredentialReportNotReadyException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl CredentialReportNotReadyException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for CredentialReportNotReadyException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "CredentialReportNotReadyException")?;
        if let Some(inner_22) = &self.message {
            write!(f, ": {}", inner_22)?;
        }
        Ok(())
    }
}
impl std::error::Error for CredentialReportNotReadyException {}
/// See [`CredentialReportNotReadyException`](crate::error::CredentialReportNotReadyException)
pub mod credential_report_not_ready_exception {
    /// A builder for [`CredentialReportNotReadyException`](crate::error::CredentialReportNotReadyException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`CredentialReportNotReadyException`](crate::error::CredentialReportNotReadyException)
        pub fn build(self) -> crate::error::CredentialReportNotReadyException {
            crate::error::CredentialReportNotReadyException {
                message: self.message,
            }
        }
    }
}
impl CredentialReportNotReadyException {
    /// Creates a new builder-style object to manufacture [`CredentialReportNotReadyException`](crate::error::CredentialReportNotReadyException)
    pub fn builder() -> crate::error::credential_report_not_ready_exception::Builder {
        crate::error::credential_report_not_ready_exception::Builder::default()
    }
}

/// <p>The request was rejected because the credential report does not exist. To generate a
/// credential report, use <a>GenerateCredentialReport</a>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CredentialReportNotPresentException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for CredentialReportNotPresentException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CredentialReportNotPresentException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl CredentialReportNotPresentException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for CredentialReportNotPresentException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "CredentialReportNotPresentException")?;
        if let Some(inner_23) = &self.message {
            write!(f, ": {}", inner_23)?;
        }
        Ok(())
    }
}
impl std::error::Error for CredentialReportNotPresentException {}
/// See [`CredentialReportNotPresentException`](crate::error::CredentialReportNotPresentException)
pub mod credential_report_not_present_exception {
    /// A builder for [`CredentialReportNotPresentException`](crate::error::CredentialReportNotPresentException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`CredentialReportNotPresentException`](crate::error::CredentialReportNotPresentException)
        pub fn build(self) -> crate::error::CredentialReportNotPresentException {
            crate::error::CredentialReportNotPresentException {
                message: self.message,
            }
        }
    }
}
impl CredentialReportNotPresentException {
    /// Creates a new builder-style object to manufacture [`CredentialReportNotPresentException`](crate::error::CredentialReportNotPresentException)
    pub fn builder() -> crate::error::credential_report_not_present_exception::Builder {
        crate::error::credential_report_not_present_exception::Builder::default()
    }
}

/// <p>The request was rejected because the most recent credential report has expired. To
/// generate a new credential report, use <a>GenerateCredentialReport</a>. For more
/// information about credential report expiration, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/credential-reports.html">Getting credential reports</a> in the
/// <i>IAM User Guide</i>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CredentialReportExpiredException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for CredentialReportExpiredException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CredentialReportExpiredException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl CredentialReportExpiredException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for CredentialReportExpiredException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "CredentialReportExpiredException")?;
        if let Some(inner_24) = &self.message {
            write!(f, ": {}", inner_24)?;
        }
        Ok(())
    }
}
impl std::error::Error for CredentialReportExpiredException {}
/// See [`CredentialReportExpiredException`](crate::error::CredentialReportExpiredException)
pub mod credential_report_expired_exception {
    /// A builder for [`CredentialReportExpiredException`](crate::error::CredentialReportExpiredException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`CredentialReportExpiredException`](crate::error::CredentialReportExpiredException)
        pub fn build(self) -> crate::error::CredentialReportExpiredException {
            crate::error::CredentialReportExpiredException {
                message: self.message,
            }
        }
    }
}
impl CredentialReportExpiredException {
    /// Creates a new builder-style object to manufacture [`CredentialReportExpiredException`](crate::error::CredentialReportExpiredException)
    pub fn builder() -> crate::error::credential_report_expired_exception::Builder {
        crate::error::credential_report_expired_exception::Builder::default()
    }
}

/// <p>The request failed because the maximum number of concurrent requests for this account are
/// already running.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ReportGenerationLimitExceededException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ReportGenerationLimitExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ReportGenerationLimitExceededException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ReportGenerationLimitExceededException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ReportGenerationLimitExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ReportGenerationLimitExceededException")?;
        if let Some(inner_25) = &self.message {
            write!(f, ": {}", inner_25)?;
        }
        Ok(())
    }
}
impl std::error::Error for ReportGenerationLimitExceededException {}
/// See [`ReportGenerationLimitExceededException`](crate::error::ReportGenerationLimitExceededException)
pub mod report_generation_limit_exceeded_exception {
    /// A builder for [`ReportGenerationLimitExceededException`](crate::error::ReportGenerationLimitExceededException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ReportGenerationLimitExceededException`](crate::error::ReportGenerationLimitExceededException)
        pub fn build(self) -> crate::error::ReportGenerationLimitExceededException {
            crate::error::ReportGenerationLimitExceededException {
                message: self.message,
            }
        }
    }
}
impl ReportGenerationLimitExceededException {
    /// Creates a new builder-style object to manufacture [`ReportGenerationLimitExceededException`](crate::error::ReportGenerationLimitExceededException)
    pub fn builder() -> crate::error::report_generation_limit_exceeded_exception::Builder {
        crate::error::report_generation_limit_exceeded_exception::Builder::default()
    }
}

/// <p>The request was rejected because it attempted to delete a resource that has attached
/// subordinate entities. The error message describes these entities.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteConflictException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DeleteConflictException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteConflictException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl DeleteConflictException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for DeleteConflictException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "DeleteConflictException")?;
        if let Some(inner_26) = &self.message {
            write!(f, ": {}", inner_26)?;
        }
        Ok(())
    }
}
impl std::error::Error for DeleteConflictException {}
/// See [`DeleteConflictException`](crate::error::DeleteConflictException)
pub mod delete_conflict_exception {
    /// A builder for [`DeleteConflictException`](crate::error::DeleteConflictException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteConflictException`](crate::error::DeleteConflictException)
        pub fn build(self) -> crate::error::DeleteConflictException {
            crate::error::DeleteConflictException {
                message: self.message,
            }
        }
    }
}
impl DeleteConflictException {
    /// Creates a new builder-style object to manufacture [`DeleteConflictException`](crate::error::DeleteConflictException)
    pub fn builder() -> crate::error::delete_conflict_exception::Builder {
        crate::error::delete_conflict_exception::Builder::default()
    }
}

/// <p>The request was rejected because the type of user for the transaction was
/// incorrect.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidUserTypeException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidUserTypeException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidUserTypeException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidUserTypeException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidUserTypeException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidUserTypeException")?;
        if let Some(inner_27) = &self.message {
            write!(f, ": {}", inner_27)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidUserTypeException {}
/// See [`InvalidUserTypeException`](crate::error::InvalidUserTypeException)
pub mod invalid_user_type_exception {
    /// A builder for [`InvalidUserTypeException`](crate::error::InvalidUserTypeException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidUserTypeException`](crate::error::InvalidUserTypeException)
        pub fn build(self) -> crate::error::InvalidUserTypeException {
            crate::error::InvalidUserTypeException {
                message: self.message,
            }
        }
    }
}
impl InvalidUserTypeException {
    /// Creates a new builder-style object to manufacture [`InvalidUserTypeException`](crate::error::InvalidUserTypeException)
    pub fn builder() -> crate::error::invalid_user_type_exception::Builder {
        crate::error::invalid_user_type_exception::Builder::default()
    }
}
