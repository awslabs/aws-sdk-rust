// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct AddClientIDToOpenIDConnectProviderError {
    pub kind: AddClientIDToOpenIDConnectProviderErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum AddClientIDToOpenIDConnectProviderErrorKind {
    InvalidInputError(crate::error::InvalidInputError),
    LimitExceededError(crate::error::LimitExceededError),
    NoSuchEntityError(crate::error::NoSuchEntityError),
    ServiceFailureError(crate::error::ServiceFailureError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for AddClientIDToOpenIDConnectProviderError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            AddClientIDToOpenIDConnectProviderErrorKind::InvalidInputError(_inner) => _inner.fmt(f),
            AddClientIDToOpenIDConnectProviderErrorKind::LimitExceededError(_inner) => {
                _inner.fmt(f)
            }
            AddClientIDToOpenIDConnectProviderErrorKind::NoSuchEntityError(_inner) => _inner.fmt(f),
            AddClientIDToOpenIDConnectProviderErrorKind::ServiceFailureError(_inner) => {
                _inner.fmt(f)
            }
            AddClientIDToOpenIDConnectProviderErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for AddClientIDToOpenIDConnectProviderError {
    fn code(&self) -> Option<&str> {
        AddClientIDToOpenIDConnectProviderError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl AddClientIDToOpenIDConnectProviderError {
    pub fn new(
        kind: AddClientIDToOpenIDConnectProviderErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: AddClientIDToOpenIDConnectProviderErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: AddClientIDToOpenIDConnectProviderErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_input_error(&self) -> bool {
        matches!(
            &self.kind,
            AddClientIDToOpenIDConnectProviderErrorKind::InvalidInputError(_)
        )
    }
    pub fn is_limit_exceeded_error(&self) -> bool {
        matches!(
            &self.kind,
            AddClientIDToOpenIDConnectProviderErrorKind::LimitExceededError(_)
        )
    }
    pub fn is_no_such_entity_error(&self) -> bool {
        matches!(
            &self.kind,
            AddClientIDToOpenIDConnectProviderErrorKind::NoSuchEntityError(_)
        )
    }
    pub fn is_service_failure_error(&self) -> bool {
        matches!(
            &self.kind,
            AddClientIDToOpenIDConnectProviderErrorKind::ServiceFailureError(_)
        )
    }
}
impl std::error::Error for AddClientIDToOpenIDConnectProviderError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            AddClientIDToOpenIDConnectProviderErrorKind::InvalidInputError(_inner) => Some(_inner),
            AddClientIDToOpenIDConnectProviderErrorKind::LimitExceededError(_inner) => Some(_inner),
            AddClientIDToOpenIDConnectProviderErrorKind::NoSuchEntityError(_inner) => Some(_inner),
            AddClientIDToOpenIDConnectProviderErrorKind::ServiceFailureError(_inner) => {
                Some(_inner)
            }
            AddClientIDToOpenIDConnectProviderErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct AddRoleToInstanceProfileError {
    pub kind: AddRoleToInstanceProfileErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum AddRoleToInstanceProfileErrorKind {
    EntityAlreadyExistsError(crate::error::EntityAlreadyExistsError),
    LimitExceededError(crate::error::LimitExceededError),
    NoSuchEntityError(crate::error::NoSuchEntityError),
    ServiceFailureError(crate::error::ServiceFailureError),
    UnmodifiableEntityError(crate::error::UnmodifiableEntityError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for AddRoleToInstanceProfileError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            AddRoleToInstanceProfileErrorKind::EntityAlreadyExistsError(_inner) => _inner.fmt(f),
            AddRoleToInstanceProfileErrorKind::LimitExceededError(_inner) => _inner.fmt(f),
            AddRoleToInstanceProfileErrorKind::NoSuchEntityError(_inner) => _inner.fmt(f),
            AddRoleToInstanceProfileErrorKind::ServiceFailureError(_inner) => _inner.fmt(f),
            AddRoleToInstanceProfileErrorKind::UnmodifiableEntityError(_inner) => _inner.fmt(f),
            AddRoleToInstanceProfileErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for AddRoleToInstanceProfileError {
    fn code(&self) -> Option<&str> {
        AddRoleToInstanceProfileError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl AddRoleToInstanceProfileError {
    pub fn new(kind: AddRoleToInstanceProfileErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: AddRoleToInstanceProfileErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: AddRoleToInstanceProfileErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_entity_already_exists_error(&self) -> bool {
        matches!(
            &self.kind,
            AddRoleToInstanceProfileErrorKind::EntityAlreadyExistsError(_)
        )
    }
    pub fn is_limit_exceeded_error(&self) -> bool {
        matches!(
            &self.kind,
            AddRoleToInstanceProfileErrorKind::LimitExceededError(_)
        )
    }
    pub fn is_no_such_entity_error(&self) -> bool {
        matches!(
            &self.kind,
            AddRoleToInstanceProfileErrorKind::NoSuchEntityError(_)
        )
    }
    pub fn is_service_failure_error(&self) -> bool {
        matches!(
            &self.kind,
            AddRoleToInstanceProfileErrorKind::ServiceFailureError(_)
        )
    }
    pub fn is_unmodifiable_entity_error(&self) -> bool {
        matches!(
            &self.kind,
            AddRoleToInstanceProfileErrorKind::UnmodifiableEntityError(_)
        )
    }
}
impl std::error::Error for AddRoleToInstanceProfileError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            AddRoleToInstanceProfileErrorKind::EntityAlreadyExistsError(_inner) => Some(_inner),
            AddRoleToInstanceProfileErrorKind::LimitExceededError(_inner) => Some(_inner),
            AddRoleToInstanceProfileErrorKind::NoSuchEntityError(_inner) => Some(_inner),
            AddRoleToInstanceProfileErrorKind::ServiceFailureError(_inner) => Some(_inner),
            AddRoleToInstanceProfileErrorKind::UnmodifiableEntityError(_inner) => Some(_inner),
            AddRoleToInstanceProfileErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct AddUserToGroupError {
    pub kind: AddUserToGroupErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum AddUserToGroupErrorKind {
    LimitExceededError(crate::error::LimitExceededError),
    NoSuchEntityError(crate::error::NoSuchEntityError),
    ServiceFailureError(crate::error::ServiceFailureError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for AddUserToGroupError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            AddUserToGroupErrorKind::LimitExceededError(_inner) => _inner.fmt(f),
            AddUserToGroupErrorKind::NoSuchEntityError(_inner) => _inner.fmt(f),
            AddUserToGroupErrorKind::ServiceFailureError(_inner) => _inner.fmt(f),
            AddUserToGroupErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for AddUserToGroupError {
    fn code(&self) -> Option<&str> {
        AddUserToGroupError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl AddUserToGroupError {
    pub fn new(kind: AddUserToGroupErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: AddUserToGroupErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: AddUserToGroupErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_limit_exceeded_error(&self) -> bool {
        matches!(&self.kind, AddUserToGroupErrorKind::LimitExceededError(_))
    }
    pub fn is_no_such_entity_error(&self) -> bool {
        matches!(&self.kind, AddUserToGroupErrorKind::NoSuchEntityError(_))
    }
    pub fn is_service_failure_error(&self) -> bool {
        matches!(&self.kind, AddUserToGroupErrorKind::ServiceFailureError(_))
    }
}
impl std::error::Error for AddUserToGroupError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            AddUserToGroupErrorKind::LimitExceededError(_inner) => Some(_inner),
            AddUserToGroupErrorKind::NoSuchEntityError(_inner) => Some(_inner),
            AddUserToGroupErrorKind::ServiceFailureError(_inner) => Some(_inner),
            AddUserToGroupErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct AttachGroupPolicyError {
    pub kind: AttachGroupPolicyErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum AttachGroupPolicyErrorKind {
    InvalidInputError(crate::error::InvalidInputError),
    LimitExceededError(crate::error::LimitExceededError),
    NoSuchEntityError(crate::error::NoSuchEntityError),
    PolicyNotAttachableError(crate::error::PolicyNotAttachableError),
    ServiceFailureError(crate::error::ServiceFailureError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for AttachGroupPolicyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            AttachGroupPolicyErrorKind::InvalidInputError(_inner) => _inner.fmt(f),
            AttachGroupPolicyErrorKind::LimitExceededError(_inner) => _inner.fmt(f),
            AttachGroupPolicyErrorKind::NoSuchEntityError(_inner) => _inner.fmt(f),
            AttachGroupPolicyErrorKind::PolicyNotAttachableError(_inner) => _inner.fmt(f),
            AttachGroupPolicyErrorKind::ServiceFailureError(_inner) => _inner.fmt(f),
            AttachGroupPolicyErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for AttachGroupPolicyError {
    fn code(&self) -> Option<&str> {
        AttachGroupPolicyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl AttachGroupPolicyError {
    pub fn new(kind: AttachGroupPolicyErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: AttachGroupPolicyErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: AttachGroupPolicyErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_input_error(&self) -> bool {
        matches!(&self.kind, AttachGroupPolicyErrorKind::InvalidInputError(_))
    }
    pub fn is_limit_exceeded_error(&self) -> bool {
        matches!(
            &self.kind,
            AttachGroupPolicyErrorKind::LimitExceededError(_)
        )
    }
    pub fn is_no_such_entity_error(&self) -> bool {
        matches!(&self.kind, AttachGroupPolicyErrorKind::NoSuchEntityError(_))
    }
    pub fn is_policy_not_attachable_error(&self) -> bool {
        matches!(
            &self.kind,
            AttachGroupPolicyErrorKind::PolicyNotAttachableError(_)
        )
    }
    pub fn is_service_failure_error(&self) -> bool {
        matches!(
            &self.kind,
            AttachGroupPolicyErrorKind::ServiceFailureError(_)
        )
    }
}
impl std::error::Error for AttachGroupPolicyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            AttachGroupPolicyErrorKind::InvalidInputError(_inner) => Some(_inner),
            AttachGroupPolicyErrorKind::LimitExceededError(_inner) => Some(_inner),
            AttachGroupPolicyErrorKind::NoSuchEntityError(_inner) => Some(_inner),
            AttachGroupPolicyErrorKind::PolicyNotAttachableError(_inner) => Some(_inner),
            AttachGroupPolicyErrorKind::ServiceFailureError(_inner) => Some(_inner),
            AttachGroupPolicyErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct AttachRolePolicyError {
    pub kind: AttachRolePolicyErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum AttachRolePolicyErrorKind {
    InvalidInputError(crate::error::InvalidInputError),
    LimitExceededError(crate::error::LimitExceededError),
    NoSuchEntityError(crate::error::NoSuchEntityError),
    PolicyNotAttachableError(crate::error::PolicyNotAttachableError),
    ServiceFailureError(crate::error::ServiceFailureError),
    UnmodifiableEntityError(crate::error::UnmodifiableEntityError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for AttachRolePolicyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            AttachRolePolicyErrorKind::InvalidInputError(_inner) => _inner.fmt(f),
            AttachRolePolicyErrorKind::LimitExceededError(_inner) => _inner.fmt(f),
            AttachRolePolicyErrorKind::NoSuchEntityError(_inner) => _inner.fmt(f),
            AttachRolePolicyErrorKind::PolicyNotAttachableError(_inner) => _inner.fmt(f),
            AttachRolePolicyErrorKind::ServiceFailureError(_inner) => _inner.fmt(f),
            AttachRolePolicyErrorKind::UnmodifiableEntityError(_inner) => _inner.fmt(f),
            AttachRolePolicyErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for AttachRolePolicyError {
    fn code(&self) -> Option<&str> {
        AttachRolePolicyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl AttachRolePolicyError {
    pub fn new(kind: AttachRolePolicyErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: AttachRolePolicyErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: AttachRolePolicyErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_input_error(&self) -> bool {
        matches!(&self.kind, AttachRolePolicyErrorKind::InvalidInputError(_))
    }
    pub fn is_limit_exceeded_error(&self) -> bool {
        matches!(&self.kind, AttachRolePolicyErrorKind::LimitExceededError(_))
    }
    pub fn is_no_such_entity_error(&self) -> bool {
        matches!(&self.kind, AttachRolePolicyErrorKind::NoSuchEntityError(_))
    }
    pub fn is_policy_not_attachable_error(&self) -> bool {
        matches!(
            &self.kind,
            AttachRolePolicyErrorKind::PolicyNotAttachableError(_)
        )
    }
    pub fn is_service_failure_error(&self) -> bool {
        matches!(
            &self.kind,
            AttachRolePolicyErrorKind::ServiceFailureError(_)
        )
    }
    pub fn is_unmodifiable_entity_error(&self) -> bool {
        matches!(
            &self.kind,
            AttachRolePolicyErrorKind::UnmodifiableEntityError(_)
        )
    }
}
impl std::error::Error for AttachRolePolicyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            AttachRolePolicyErrorKind::InvalidInputError(_inner) => Some(_inner),
            AttachRolePolicyErrorKind::LimitExceededError(_inner) => Some(_inner),
            AttachRolePolicyErrorKind::NoSuchEntityError(_inner) => Some(_inner),
            AttachRolePolicyErrorKind::PolicyNotAttachableError(_inner) => Some(_inner),
            AttachRolePolicyErrorKind::ServiceFailureError(_inner) => Some(_inner),
            AttachRolePolicyErrorKind::UnmodifiableEntityError(_inner) => Some(_inner),
            AttachRolePolicyErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct AttachUserPolicyError {
    pub kind: AttachUserPolicyErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum AttachUserPolicyErrorKind {
    InvalidInputError(crate::error::InvalidInputError),
    LimitExceededError(crate::error::LimitExceededError),
    NoSuchEntityError(crate::error::NoSuchEntityError),
    PolicyNotAttachableError(crate::error::PolicyNotAttachableError),
    ServiceFailureError(crate::error::ServiceFailureError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for AttachUserPolicyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            AttachUserPolicyErrorKind::InvalidInputError(_inner) => _inner.fmt(f),
            AttachUserPolicyErrorKind::LimitExceededError(_inner) => _inner.fmt(f),
            AttachUserPolicyErrorKind::NoSuchEntityError(_inner) => _inner.fmt(f),
            AttachUserPolicyErrorKind::PolicyNotAttachableError(_inner) => _inner.fmt(f),
            AttachUserPolicyErrorKind::ServiceFailureError(_inner) => _inner.fmt(f),
            AttachUserPolicyErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for AttachUserPolicyError {
    fn code(&self) -> Option<&str> {
        AttachUserPolicyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl AttachUserPolicyError {
    pub fn new(kind: AttachUserPolicyErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: AttachUserPolicyErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: AttachUserPolicyErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_input_error(&self) -> bool {
        matches!(&self.kind, AttachUserPolicyErrorKind::InvalidInputError(_))
    }
    pub fn is_limit_exceeded_error(&self) -> bool {
        matches!(&self.kind, AttachUserPolicyErrorKind::LimitExceededError(_))
    }
    pub fn is_no_such_entity_error(&self) -> bool {
        matches!(&self.kind, AttachUserPolicyErrorKind::NoSuchEntityError(_))
    }
    pub fn is_policy_not_attachable_error(&self) -> bool {
        matches!(
            &self.kind,
            AttachUserPolicyErrorKind::PolicyNotAttachableError(_)
        )
    }
    pub fn is_service_failure_error(&self) -> bool {
        matches!(
            &self.kind,
            AttachUserPolicyErrorKind::ServiceFailureError(_)
        )
    }
}
impl std::error::Error for AttachUserPolicyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            AttachUserPolicyErrorKind::InvalidInputError(_inner) => Some(_inner),
            AttachUserPolicyErrorKind::LimitExceededError(_inner) => Some(_inner),
            AttachUserPolicyErrorKind::NoSuchEntityError(_inner) => Some(_inner),
            AttachUserPolicyErrorKind::PolicyNotAttachableError(_inner) => Some(_inner),
            AttachUserPolicyErrorKind::ServiceFailureError(_inner) => Some(_inner),
            AttachUserPolicyErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ChangePasswordError {
    pub kind: ChangePasswordErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ChangePasswordErrorKind {
    EntityTemporarilyUnmodifiableError(crate::error::EntityTemporarilyUnmodifiableError),
    InvalidUserTypeError(crate::error::InvalidUserTypeError),
    LimitExceededError(crate::error::LimitExceededError),
    NoSuchEntityError(crate::error::NoSuchEntityError),
    PasswordPolicyViolationError(crate::error::PasswordPolicyViolationError),
    ServiceFailureError(crate::error::ServiceFailureError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ChangePasswordError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ChangePasswordErrorKind::EntityTemporarilyUnmodifiableError(_inner) => _inner.fmt(f),
            ChangePasswordErrorKind::InvalidUserTypeError(_inner) => _inner.fmt(f),
            ChangePasswordErrorKind::LimitExceededError(_inner) => _inner.fmt(f),
            ChangePasswordErrorKind::NoSuchEntityError(_inner) => _inner.fmt(f),
            ChangePasswordErrorKind::PasswordPolicyViolationError(_inner) => _inner.fmt(f),
            ChangePasswordErrorKind::ServiceFailureError(_inner) => _inner.fmt(f),
            ChangePasswordErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ChangePasswordError {
    fn code(&self) -> Option<&str> {
        ChangePasswordError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ChangePasswordError {
    pub fn new(kind: ChangePasswordErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ChangePasswordErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ChangePasswordErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_entity_temporarily_unmodifiable_error(&self) -> bool {
        matches!(
            &self.kind,
            ChangePasswordErrorKind::EntityTemporarilyUnmodifiableError(_)
        )
    }
    pub fn is_invalid_user_type_error(&self) -> bool {
        matches!(&self.kind, ChangePasswordErrorKind::InvalidUserTypeError(_))
    }
    pub fn is_limit_exceeded_error(&self) -> bool {
        matches!(&self.kind, ChangePasswordErrorKind::LimitExceededError(_))
    }
    pub fn is_no_such_entity_error(&self) -> bool {
        matches!(&self.kind, ChangePasswordErrorKind::NoSuchEntityError(_))
    }
    pub fn is_password_policy_violation_error(&self) -> bool {
        matches!(
            &self.kind,
            ChangePasswordErrorKind::PasswordPolicyViolationError(_)
        )
    }
    pub fn is_service_failure_error(&self) -> bool {
        matches!(&self.kind, ChangePasswordErrorKind::ServiceFailureError(_))
    }
}
impl std::error::Error for ChangePasswordError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ChangePasswordErrorKind::EntityTemporarilyUnmodifiableError(_inner) => Some(_inner),
            ChangePasswordErrorKind::InvalidUserTypeError(_inner) => Some(_inner),
            ChangePasswordErrorKind::LimitExceededError(_inner) => Some(_inner),
            ChangePasswordErrorKind::NoSuchEntityError(_inner) => Some(_inner),
            ChangePasswordErrorKind::PasswordPolicyViolationError(_inner) => Some(_inner),
            ChangePasswordErrorKind::ServiceFailureError(_inner) => Some(_inner),
            ChangePasswordErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateAccessKeyError {
    pub kind: CreateAccessKeyErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateAccessKeyErrorKind {
    LimitExceededError(crate::error::LimitExceededError),
    NoSuchEntityError(crate::error::NoSuchEntityError),
    ServiceFailureError(crate::error::ServiceFailureError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateAccessKeyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateAccessKeyErrorKind::LimitExceededError(_inner) => _inner.fmt(f),
            CreateAccessKeyErrorKind::NoSuchEntityError(_inner) => _inner.fmt(f),
            CreateAccessKeyErrorKind::ServiceFailureError(_inner) => _inner.fmt(f),
            CreateAccessKeyErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateAccessKeyError {
    fn code(&self) -> Option<&str> {
        CreateAccessKeyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateAccessKeyError {
    pub fn new(kind: CreateAccessKeyErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateAccessKeyErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateAccessKeyErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_limit_exceeded_error(&self) -> bool {
        matches!(&self.kind, CreateAccessKeyErrorKind::LimitExceededError(_))
    }
    pub fn is_no_such_entity_error(&self) -> bool {
        matches!(&self.kind, CreateAccessKeyErrorKind::NoSuchEntityError(_))
    }
    pub fn is_service_failure_error(&self) -> bool {
        matches!(&self.kind, CreateAccessKeyErrorKind::ServiceFailureError(_))
    }
}
impl std::error::Error for CreateAccessKeyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateAccessKeyErrorKind::LimitExceededError(_inner) => Some(_inner),
            CreateAccessKeyErrorKind::NoSuchEntityError(_inner) => Some(_inner),
            CreateAccessKeyErrorKind::ServiceFailureError(_inner) => Some(_inner),
            CreateAccessKeyErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateAccountAliasError {
    pub kind: CreateAccountAliasErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateAccountAliasErrorKind {
    EntityAlreadyExistsError(crate::error::EntityAlreadyExistsError),
    LimitExceededError(crate::error::LimitExceededError),
    ServiceFailureError(crate::error::ServiceFailureError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateAccountAliasError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateAccountAliasErrorKind::EntityAlreadyExistsError(_inner) => _inner.fmt(f),
            CreateAccountAliasErrorKind::LimitExceededError(_inner) => _inner.fmt(f),
            CreateAccountAliasErrorKind::ServiceFailureError(_inner) => _inner.fmt(f),
            CreateAccountAliasErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateAccountAliasError {
    fn code(&self) -> Option<&str> {
        CreateAccountAliasError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateAccountAliasError {
    pub fn new(kind: CreateAccountAliasErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateAccountAliasErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateAccountAliasErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_entity_already_exists_error(&self) -> bool {
        matches!(
            &self.kind,
            CreateAccountAliasErrorKind::EntityAlreadyExistsError(_)
        )
    }
    pub fn is_limit_exceeded_error(&self) -> bool {
        matches!(
            &self.kind,
            CreateAccountAliasErrorKind::LimitExceededError(_)
        )
    }
    pub fn is_service_failure_error(&self) -> bool {
        matches!(
            &self.kind,
            CreateAccountAliasErrorKind::ServiceFailureError(_)
        )
    }
}
impl std::error::Error for CreateAccountAliasError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateAccountAliasErrorKind::EntityAlreadyExistsError(_inner) => Some(_inner),
            CreateAccountAliasErrorKind::LimitExceededError(_inner) => Some(_inner),
            CreateAccountAliasErrorKind::ServiceFailureError(_inner) => Some(_inner),
            CreateAccountAliasErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateGroupError {
    pub kind: CreateGroupErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateGroupErrorKind {
    EntityAlreadyExistsError(crate::error::EntityAlreadyExistsError),
    LimitExceededError(crate::error::LimitExceededError),
    NoSuchEntityError(crate::error::NoSuchEntityError),
    ServiceFailureError(crate::error::ServiceFailureError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateGroupError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateGroupErrorKind::EntityAlreadyExistsError(_inner) => _inner.fmt(f),
            CreateGroupErrorKind::LimitExceededError(_inner) => _inner.fmt(f),
            CreateGroupErrorKind::NoSuchEntityError(_inner) => _inner.fmt(f),
            CreateGroupErrorKind::ServiceFailureError(_inner) => _inner.fmt(f),
            CreateGroupErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateGroupError {
    fn code(&self) -> Option<&str> {
        CreateGroupError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateGroupError {
    pub fn new(kind: CreateGroupErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateGroupErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateGroupErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_entity_already_exists_error(&self) -> bool {
        matches!(
            &self.kind,
            CreateGroupErrorKind::EntityAlreadyExistsError(_)
        )
    }
    pub fn is_limit_exceeded_error(&self) -> bool {
        matches!(&self.kind, CreateGroupErrorKind::LimitExceededError(_))
    }
    pub fn is_no_such_entity_error(&self) -> bool {
        matches!(&self.kind, CreateGroupErrorKind::NoSuchEntityError(_))
    }
    pub fn is_service_failure_error(&self) -> bool {
        matches!(&self.kind, CreateGroupErrorKind::ServiceFailureError(_))
    }
}
impl std::error::Error for CreateGroupError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateGroupErrorKind::EntityAlreadyExistsError(_inner) => Some(_inner),
            CreateGroupErrorKind::LimitExceededError(_inner) => Some(_inner),
            CreateGroupErrorKind::NoSuchEntityError(_inner) => Some(_inner),
            CreateGroupErrorKind::ServiceFailureError(_inner) => Some(_inner),
            CreateGroupErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateInstanceProfileError {
    pub kind: CreateInstanceProfileErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateInstanceProfileErrorKind {
    ConcurrentModificationError(crate::error::ConcurrentModificationError),
    EntityAlreadyExistsError(crate::error::EntityAlreadyExistsError),
    InvalidInputError(crate::error::InvalidInputError),
    LimitExceededError(crate::error::LimitExceededError),
    ServiceFailureError(crate::error::ServiceFailureError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateInstanceProfileError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateInstanceProfileErrorKind::ConcurrentModificationError(_inner) => _inner.fmt(f),
            CreateInstanceProfileErrorKind::EntityAlreadyExistsError(_inner) => _inner.fmt(f),
            CreateInstanceProfileErrorKind::InvalidInputError(_inner) => _inner.fmt(f),
            CreateInstanceProfileErrorKind::LimitExceededError(_inner) => _inner.fmt(f),
            CreateInstanceProfileErrorKind::ServiceFailureError(_inner) => _inner.fmt(f),
            CreateInstanceProfileErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateInstanceProfileError {
    fn code(&self) -> Option<&str> {
        CreateInstanceProfileError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateInstanceProfileError {
    pub fn new(kind: CreateInstanceProfileErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateInstanceProfileErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateInstanceProfileErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_concurrent_modification_error(&self) -> bool {
        matches!(
            &self.kind,
            CreateInstanceProfileErrorKind::ConcurrentModificationError(_)
        )
    }
    pub fn is_entity_already_exists_error(&self) -> bool {
        matches!(
            &self.kind,
            CreateInstanceProfileErrorKind::EntityAlreadyExistsError(_)
        )
    }
    pub fn is_invalid_input_error(&self) -> bool {
        matches!(
            &self.kind,
            CreateInstanceProfileErrorKind::InvalidInputError(_)
        )
    }
    pub fn is_limit_exceeded_error(&self) -> bool {
        matches!(
            &self.kind,
            CreateInstanceProfileErrorKind::LimitExceededError(_)
        )
    }
    pub fn is_service_failure_error(&self) -> bool {
        matches!(
            &self.kind,
            CreateInstanceProfileErrorKind::ServiceFailureError(_)
        )
    }
}
impl std::error::Error for CreateInstanceProfileError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateInstanceProfileErrorKind::ConcurrentModificationError(_inner) => Some(_inner),
            CreateInstanceProfileErrorKind::EntityAlreadyExistsError(_inner) => Some(_inner),
            CreateInstanceProfileErrorKind::InvalidInputError(_inner) => Some(_inner),
            CreateInstanceProfileErrorKind::LimitExceededError(_inner) => Some(_inner),
            CreateInstanceProfileErrorKind::ServiceFailureError(_inner) => Some(_inner),
            CreateInstanceProfileErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateLoginProfileError {
    pub kind: CreateLoginProfileErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateLoginProfileErrorKind {
    EntityAlreadyExistsError(crate::error::EntityAlreadyExistsError),
    LimitExceededError(crate::error::LimitExceededError),
    NoSuchEntityError(crate::error::NoSuchEntityError),
    PasswordPolicyViolationError(crate::error::PasswordPolicyViolationError),
    ServiceFailureError(crate::error::ServiceFailureError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateLoginProfileError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateLoginProfileErrorKind::EntityAlreadyExistsError(_inner) => _inner.fmt(f),
            CreateLoginProfileErrorKind::LimitExceededError(_inner) => _inner.fmt(f),
            CreateLoginProfileErrorKind::NoSuchEntityError(_inner) => _inner.fmt(f),
            CreateLoginProfileErrorKind::PasswordPolicyViolationError(_inner) => _inner.fmt(f),
            CreateLoginProfileErrorKind::ServiceFailureError(_inner) => _inner.fmt(f),
            CreateLoginProfileErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateLoginProfileError {
    fn code(&self) -> Option<&str> {
        CreateLoginProfileError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateLoginProfileError {
    pub fn new(kind: CreateLoginProfileErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateLoginProfileErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateLoginProfileErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_entity_already_exists_error(&self) -> bool {
        matches!(
            &self.kind,
            CreateLoginProfileErrorKind::EntityAlreadyExistsError(_)
        )
    }
    pub fn is_limit_exceeded_error(&self) -> bool {
        matches!(
            &self.kind,
            CreateLoginProfileErrorKind::LimitExceededError(_)
        )
    }
    pub fn is_no_such_entity_error(&self) -> bool {
        matches!(
            &self.kind,
            CreateLoginProfileErrorKind::NoSuchEntityError(_)
        )
    }
    pub fn is_password_policy_violation_error(&self) -> bool {
        matches!(
            &self.kind,
            CreateLoginProfileErrorKind::PasswordPolicyViolationError(_)
        )
    }
    pub fn is_service_failure_error(&self) -> bool {
        matches!(
            &self.kind,
            CreateLoginProfileErrorKind::ServiceFailureError(_)
        )
    }
}
impl std::error::Error for CreateLoginProfileError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateLoginProfileErrorKind::EntityAlreadyExistsError(_inner) => Some(_inner),
            CreateLoginProfileErrorKind::LimitExceededError(_inner) => Some(_inner),
            CreateLoginProfileErrorKind::NoSuchEntityError(_inner) => Some(_inner),
            CreateLoginProfileErrorKind::PasswordPolicyViolationError(_inner) => Some(_inner),
            CreateLoginProfileErrorKind::ServiceFailureError(_inner) => Some(_inner),
            CreateLoginProfileErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateOpenIDConnectProviderError {
    pub kind: CreateOpenIDConnectProviderErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateOpenIDConnectProviderErrorKind {
    ConcurrentModificationError(crate::error::ConcurrentModificationError),
    EntityAlreadyExistsError(crate::error::EntityAlreadyExistsError),
    InvalidInputError(crate::error::InvalidInputError),
    LimitExceededError(crate::error::LimitExceededError),
    ServiceFailureError(crate::error::ServiceFailureError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateOpenIDConnectProviderError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateOpenIDConnectProviderErrorKind::ConcurrentModificationError(_inner) => {
                _inner.fmt(f)
            }
            CreateOpenIDConnectProviderErrorKind::EntityAlreadyExistsError(_inner) => _inner.fmt(f),
            CreateOpenIDConnectProviderErrorKind::InvalidInputError(_inner) => _inner.fmt(f),
            CreateOpenIDConnectProviderErrorKind::LimitExceededError(_inner) => _inner.fmt(f),
            CreateOpenIDConnectProviderErrorKind::ServiceFailureError(_inner) => _inner.fmt(f),
            CreateOpenIDConnectProviderErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateOpenIDConnectProviderError {
    fn code(&self) -> Option<&str> {
        CreateOpenIDConnectProviderError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateOpenIDConnectProviderError {
    pub fn new(kind: CreateOpenIDConnectProviderErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateOpenIDConnectProviderErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateOpenIDConnectProviderErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_concurrent_modification_error(&self) -> bool {
        matches!(
            &self.kind,
            CreateOpenIDConnectProviderErrorKind::ConcurrentModificationError(_)
        )
    }
    pub fn is_entity_already_exists_error(&self) -> bool {
        matches!(
            &self.kind,
            CreateOpenIDConnectProviderErrorKind::EntityAlreadyExistsError(_)
        )
    }
    pub fn is_invalid_input_error(&self) -> bool {
        matches!(
            &self.kind,
            CreateOpenIDConnectProviderErrorKind::InvalidInputError(_)
        )
    }
    pub fn is_limit_exceeded_error(&self) -> bool {
        matches!(
            &self.kind,
            CreateOpenIDConnectProviderErrorKind::LimitExceededError(_)
        )
    }
    pub fn is_service_failure_error(&self) -> bool {
        matches!(
            &self.kind,
            CreateOpenIDConnectProviderErrorKind::ServiceFailureError(_)
        )
    }
}
impl std::error::Error for CreateOpenIDConnectProviderError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateOpenIDConnectProviderErrorKind::ConcurrentModificationError(_inner) => {
                Some(_inner)
            }
            CreateOpenIDConnectProviderErrorKind::EntityAlreadyExistsError(_inner) => Some(_inner),
            CreateOpenIDConnectProviderErrorKind::InvalidInputError(_inner) => Some(_inner),
            CreateOpenIDConnectProviderErrorKind::LimitExceededError(_inner) => Some(_inner),
            CreateOpenIDConnectProviderErrorKind::ServiceFailureError(_inner) => Some(_inner),
            CreateOpenIDConnectProviderErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreatePolicyError {
    pub kind: CreatePolicyErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreatePolicyErrorKind {
    ConcurrentModificationError(crate::error::ConcurrentModificationError),
    EntityAlreadyExistsError(crate::error::EntityAlreadyExistsError),
    InvalidInputError(crate::error::InvalidInputError),
    LimitExceededError(crate::error::LimitExceededError),
    MalformedPolicyDocumentError(crate::error::MalformedPolicyDocumentError),
    ServiceFailureError(crate::error::ServiceFailureError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreatePolicyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreatePolicyErrorKind::ConcurrentModificationError(_inner) => _inner.fmt(f),
            CreatePolicyErrorKind::EntityAlreadyExistsError(_inner) => _inner.fmt(f),
            CreatePolicyErrorKind::InvalidInputError(_inner) => _inner.fmt(f),
            CreatePolicyErrorKind::LimitExceededError(_inner) => _inner.fmt(f),
            CreatePolicyErrorKind::MalformedPolicyDocumentError(_inner) => _inner.fmt(f),
            CreatePolicyErrorKind::ServiceFailureError(_inner) => _inner.fmt(f),
            CreatePolicyErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreatePolicyError {
    fn code(&self) -> Option<&str> {
        CreatePolicyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreatePolicyError {
    pub fn new(kind: CreatePolicyErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreatePolicyErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreatePolicyErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_concurrent_modification_error(&self) -> bool {
        matches!(
            &self.kind,
            CreatePolicyErrorKind::ConcurrentModificationError(_)
        )
    }
    pub fn is_entity_already_exists_error(&self) -> bool {
        matches!(
            &self.kind,
            CreatePolicyErrorKind::EntityAlreadyExistsError(_)
        )
    }
    pub fn is_invalid_input_error(&self) -> bool {
        matches!(&self.kind, CreatePolicyErrorKind::InvalidInputError(_))
    }
    pub fn is_limit_exceeded_error(&self) -> bool {
        matches!(&self.kind, CreatePolicyErrorKind::LimitExceededError(_))
    }
    pub fn is_malformed_policy_document_error(&self) -> bool {
        matches!(
            &self.kind,
            CreatePolicyErrorKind::MalformedPolicyDocumentError(_)
        )
    }
    pub fn is_service_failure_error(&self) -> bool {
        matches!(&self.kind, CreatePolicyErrorKind::ServiceFailureError(_))
    }
}
impl std::error::Error for CreatePolicyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreatePolicyErrorKind::ConcurrentModificationError(_inner) => Some(_inner),
            CreatePolicyErrorKind::EntityAlreadyExistsError(_inner) => Some(_inner),
            CreatePolicyErrorKind::InvalidInputError(_inner) => Some(_inner),
            CreatePolicyErrorKind::LimitExceededError(_inner) => Some(_inner),
            CreatePolicyErrorKind::MalformedPolicyDocumentError(_inner) => Some(_inner),
            CreatePolicyErrorKind::ServiceFailureError(_inner) => Some(_inner),
            CreatePolicyErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreatePolicyVersionError {
    pub kind: CreatePolicyVersionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreatePolicyVersionErrorKind {
    InvalidInputError(crate::error::InvalidInputError),
    LimitExceededError(crate::error::LimitExceededError),
    MalformedPolicyDocumentError(crate::error::MalformedPolicyDocumentError),
    NoSuchEntityError(crate::error::NoSuchEntityError),
    ServiceFailureError(crate::error::ServiceFailureError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreatePolicyVersionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreatePolicyVersionErrorKind::InvalidInputError(_inner) => _inner.fmt(f),
            CreatePolicyVersionErrorKind::LimitExceededError(_inner) => _inner.fmt(f),
            CreatePolicyVersionErrorKind::MalformedPolicyDocumentError(_inner) => _inner.fmt(f),
            CreatePolicyVersionErrorKind::NoSuchEntityError(_inner) => _inner.fmt(f),
            CreatePolicyVersionErrorKind::ServiceFailureError(_inner) => _inner.fmt(f),
            CreatePolicyVersionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreatePolicyVersionError {
    fn code(&self) -> Option<&str> {
        CreatePolicyVersionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreatePolicyVersionError {
    pub fn new(kind: CreatePolicyVersionErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreatePolicyVersionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreatePolicyVersionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_input_error(&self) -> bool {
        matches!(
            &self.kind,
            CreatePolicyVersionErrorKind::InvalidInputError(_)
        )
    }
    pub fn is_limit_exceeded_error(&self) -> bool {
        matches!(
            &self.kind,
            CreatePolicyVersionErrorKind::LimitExceededError(_)
        )
    }
    pub fn is_malformed_policy_document_error(&self) -> bool {
        matches!(
            &self.kind,
            CreatePolicyVersionErrorKind::MalformedPolicyDocumentError(_)
        )
    }
    pub fn is_no_such_entity_error(&self) -> bool {
        matches!(
            &self.kind,
            CreatePolicyVersionErrorKind::NoSuchEntityError(_)
        )
    }
    pub fn is_service_failure_error(&self) -> bool {
        matches!(
            &self.kind,
            CreatePolicyVersionErrorKind::ServiceFailureError(_)
        )
    }
}
impl std::error::Error for CreatePolicyVersionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreatePolicyVersionErrorKind::InvalidInputError(_inner) => Some(_inner),
            CreatePolicyVersionErrorKind::LimitExceededError(_inner) => Some(_inner),
            CreatePolicyVersionErrorKind::MalformedPolicyDocumentError(_inner) => Some(_inner),
            CreatePolicyVersionErrorKind::NoSuchEntityError(_inner) => Some(_inner),
            CreatePolicyVersionErrorKind::ServiceFailureError(_inner) => Some(_inner),
            CreatePolicyVersionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateRoleError {
    pub kind: CreateRoleErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateRoleErrorKind {
    ConcurrentModificationError(crate::error::ConcurrentModificationError),
    EntityAlreadyExistsError(crate::error::EntityAlreadyExistsError),
    InvalidInputError(crate::error::InvalidInputError),
    LimitExceededError(crate::error::LimitExceededError),
    MalformedPolicyDocumentError(crate::error::MalformedPolicyDocumentError),
    ServiceFailureError(crate::error::ServiceFailureError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateRoleError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateRoleErrorKind::ConcurrentModificationError(_inner) => _inner.fmt(f),
            CreateRoleErrorKind::EntityAlreadyExistsError(_inner) => _inner.fmt(f),
            CreateRoleErrorKind::InvalidInputError(_inner) => _inner.fmt(f),
            CreateRoleErrorKind::LimitExceededError(_inner) => _inner.fmt(f),
            CreateRoleErrorKind::MalformedPolicyDocumentError(_inner) => _inner.fmt(f),
            CreateRoleErrorKind::ServiceFailureError(_inner) => _inner.fmt(f),
            CreateRoleErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateRoleError {
    fn code(&self) -> Option<&str> {
        CreateRoleError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateRoleError {
    pub fn new(kind: CreateRoleErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateRoleErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateRoleErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_concurrent_modification_error(&self) -> bool {
        matches!(
            &self.kind,
            CreateRoleErrorKind::ConcurrentModificationError(_)
        )
    }
    pub fn is_entity_already_exists_error(&self) -> bool {
        matches!(&self.kind, CreateRoleErrorKind::EntityAlreadyExistsError(_))
    }
    pub fn is_invalid_input_error(&self) -> bool {
        matches!(&self.kind, CreateRoleErrorKind::InvalidInputError(_))
    }
    pub fn is_limit_exceeded_error(&self) -> bool {
        matches!(&self.kind, CreateRoleErrorKind::LimitExceededError(_))
    }
    pub fn is_malformed_policy_document_error(&self) -> bool {
        matches!(
            &self.kind,
            CreateRoleErrorKind::MalformedPolicyDocumentError(_)
        )
    }
    pub fn is_service_failure_error(&self) -> bool {
        matches!(&self.kind, CreateRoleErrorKind::ServiceFailureError(_))
    }
}
impl std::error::Error for CreateRoleError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateRoleErrorKind::ConcurrentModificationError(_inner) => Some(_inner),
            CreateRoleErrorKind::EntityAlreadyExistsError(_inner) => Some(_inner),
            CreateRoleErrorKind::InvalidInputError(_inner) => Some(_inner),
            CreateRoleErrorKind::LimitExceededError(_inner) => Some(_inner),
            CreateRoleErrorKind::MalformedPolicyDocumentError(_inner) => Some(_inner),
            CreateRoleErrorKind::ServiceFailureError(_inner) => Some(_inner),
            CreateRoleErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateSAMLProviderError {
    pub kind: CreateSAMLProviderErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateSAMLProviderErrorKind {
    ConcurrentModificationError(crate::error::ConcurrentModificationError),
    EntityAlreadyExistsError(crate::error::EntityAlreadyExistsError),
    InvalidInputError(crate::error::InvalidInputError),
    LimitExceededError(crate::error::LimitExceededError),
    ServiceFailureError(crate::error::ServiceFailureError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateSAMLProviderError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateSAMLProviderErrorKind::ConcurrentModificationError(_inner) => _inner.fmt(f),
            CreateSAMLProviderErrorKind::EntityAlreadyExistsError(_inner) => _inner.fmt(f),
            CreateSAMLProviderErrorKind::InvalidInputError(_inner) => _inner.fmt(f),
            CreateSAMLProviderErrorKind::LimitExceededError(_inner) => _inner.fmt(f),
            CreateSAMLProviderErrorKind::ServiceFailureError(_inner) => _inner.fmt(f),
            CreateSAMLProviderErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateSAMLProviderError {
    fn code(&self) -> Option<&str> {
        CreateSAMLProviderError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateSAMLProviderError {
    pub fn new(kind: CreateSAMLProviderErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateSAMLProviderErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateSAMLProviderErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_concurrent_modification_error(&self) -> bool {
        matches!(
            &self.kind,
            CreateSAMLProviderErrorKind::ConcurrentModificationError(_)
        )
    }
    pub fn is_entity_already_exists_error(&self) -> bool {
        matches!(
            &self.kind,
            CreateSAMLProviderErrorKind::EntityAlreadyExistsError(_)
        )
    }
    pub fn is_invalid_input_error(&self) -> bool {
        matches!(
            &self.kind,
            CreateSAMLProviderErrorKind::InvalidInputError(_)
        )
    }
    pub fn is_limit_exceeded_error(&self) -> bool {
        matches!(
            &self.kind,
            CreateSAMLProviderErrorKind::LimitExceededError(_)
        )
    }
    pub fn is_service_failure_error(&self) -> bool {
        matches!(
            &self.kind,
            CreateSAMLProviderErrorKind::ServiceFailureError(_)
        )
    }
}
impl std::error::Error for CreateSAMLProviderError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateSAMLProviderErrorKind::ConcurrentModificationError(_inner) => Some(_inner),
            CreateSAMLProviderErrorKind::EntityAlreadyExistsError(_inner) => Some(_inner),
            CreateSAMLProviderErrorKind::InvalidInputError(_inner) => Some(_inner),
            CreateSAMLProviderErrorKind::LimitExceededError(_inner) => Some(_inner),
            CreateSAMLProviderErrorKind::ServiceFailureError(_inner) => Some(_inner),
            CreateSAMLProviderErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateServiceLinkedRoleError {
    pub kind: CreateServiceLinkedRoleErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateServiceLinkedRoleErrorKind {
    InvalidInputError(crate::error::InvalidInputError),
    LimitExceededError(crate::error::LimitExceededError),
    NoSuchEntityError(crate::error::NoSuchEntityError),
    ServiceFailureError(crate::error::ServiceFailureError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateServiceLinkedRoleError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateServiceLinkedRoleErrorKind::InvalidInputError(_inner) => _inner.fmt(f),
            CreateServiceLinkedRoleErrorKind::LimitExceededError(_inner) => _inner.fmt(f),
            CreateServiceLinkedRoleErrorKind::NoSuchEntityError(_inner) => _inner.fmt(f),
            CreateServiceLinkedRoleErrorKind::ServiceFailureError(_inner) => _inner.fmt(f),
            CreateServiceLinkedRoleErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateServiceLinkedRoleError {
    fn code(&self) -> Option<&str> {
        CreateServiceLinkedRoleError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateServiceLinkedRoleError {
    pub fn new(kind: CreateServiceLinkedRoleErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateServiceLinkedRoleErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateServiceLinkedRoleErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_input_error(&self) -> bool {
        matches!(
            &self.kind,
            CreateServiceLinkedRoleErrorKind::InvalidInputError(_)
        )
    }
    pub fn is_limit_exceeded_error(&self) -> bool {
        matches!(
            &self.kind,
            CreateServiceLinkedRoleErrorKind::LimitExceededError(_)
        )
    }
    pub fn is_no_such_entity_error(&self) -> bool {
        matches!(
            &self.kind,
            CreateServiceLinkedRoleErrorKind::NoSuchEntityError(_)
        )
    }
    pub fn is_service_failure_error(&self) -> bool {
        matches!(
            &self.kind,
            CreateServiceLinkedRoleErrorKind::ServiceFailureError(_)
        )
    }
}
impl std::error::Error for CreateServiceLinkedRoleError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateServiceLinkedRoleErrorKind::InvalidInputError(_inner) => Some(_inner),
            CreateServiceLinkedRoleErrorKind::LimitExceededError(_inner) => Some(_inner),
            CreateServiceLinkedRoleErrorKind::NoSuchEntityError(_inner) => Some(_inner),
            CreateServiceLinkedRoleErrorKind::ServiceFailureError(_inner) => Some(_inner),
            CreateServiceLinkedRoleErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateServiceSpecificCredentialError {
    pub kind: CreateServiceSpecificCredentialErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateServiceSpecificCredentialErrorKind {
    LimitExceededError(crate::error::LimitExceededError),
    NoSuchEntityError(crate::error::NoSuchEntityError),
    ServiceNotSupportedError(crate::error::ServiceNotSupportedError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateServiceSpecificCredentialError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateServiceSpecificCredentialErrorKind::LimitExceededError(_inner) => _inner.fmt(f),
            CreateServiceSpecificCredentialErrorKind::NoSuchEntityError(_inner) => _inner.fmt(f),
            CreateServiceSpecificCredentialErrorKind::ServiceNotSupportedError(_inner) => {
                _inner.fmt(f)
            }
            CreateServiceSpecificCredentialErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateServiceSpecificCredentialError {
    fn code(&self) -> Option<&str> {
        CreateServiceSpecificCredentialError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateServiceSpecificCredentialError {
    pub fn new(kind: CreateServiceSpecificCredentialErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateServiceSpecificCredentialErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateServiceSpecificCredentialErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_limit_exceeded_error(&self) -> bool {
        matches!(
            &self.kind,
            CreateServiceSpecificCredentialErrorKind::LimitExceededError(_)
        )
    }
    pub fn is_no_such_entity_error(&self) -> bool {
        matches!(
            &self.kind,
            CreateServiceSpecificCredentialErrorKind::NoSuchEntityError(_)
        )
    }
    pub fn is_service_not_supported_error(&self) -> bool {
        matches!(
            &self.kind,
            CreateServiceSpecificCredentialErrorKind::ServiceNotSupportedError(_)
        )
    }
}
impl std::error::Error for CreateServiceSpecificCredentialError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateServiceSpecificCredentialErrorKind::LimitExceededError(_inner) => Some(_inner),
            CreateServiceSpecificCredentialErrorKind::NoSuchEntityError(_inner) => Some(_inner),
            CreateServiceSpecificCredentialErrorKind::ServiceNotSupportedError(_inner) => {
                Some(_inner)
            }
            CreateServiceSpecificCredentialErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateUserError {
    pub kind: CreateUserErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateUserErrorKind {
    ConcurrentModificationError(crate::error::ConcurrentModificationError),
    EntityAlreadyExistsError(crate::error::EntityAlreadyExistsError),
    InvalidInputError(crate::error::InvalidInputError),
    LimitExceededError(crate::error::LimitExceededError),
    NoSuchEntityError(crate::error::NoSuchEntityError),
    ServiceFailureError(crate::error::ServiceFailureError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateUserError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateUserErrorKind::ConcurrentModificationError(_inner) => _inner.fmt(f),
            CreateUserErrorKind::EntityAlreadyExistsError(_inner) => _inner.fmt(f),
            CreateUserErrorKind::InvalidInputError(_inner) => _inner.fmt(f),
            CreateUserErrorKind::LimitExceededError(_inner) => _inner.fmt(f),
            CreateUserErrorKind::NoSuchEntityError(_inner) => _inner.fmt(f),
            CreateUserErrorKind::ServiceFailureError(_inner) => _inner.fmt(f),
            CreateUserErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateUserError {
    fn code(&self) -> Option<&str> {
        CreateUserError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateUserError {
    pub fn new(kind: CreateUserErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateUserErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateUserErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_concurrent_modification_error(&self) -> bool {
        matches!(
            &self.kind,
            CreateUserErrorKind::ConcurrentModificationError(_)
        )
    }
    pub fn is_entity_already_exists_error(&self) -> bool {
        matches!(&self.kind, CreateUserErrorKind::EntityAlreadyExistsError(_))
    }
    pub fn is_invalid_input_error(&self) -> bool {
        matches!(&self.kind, CreateUserErrorKind::InvalidInputError(_))
    }
    pub fn is_limit_exceeded_error(&self) -> bool {
        matches!(&self.kind, CreateUserErrorKind::LimitExceededError(_))
    }
    pub fn is_no_such_entity_error(&self) -> bool {
        matches!(&self.kind, CreateUserErrorKind::NoSuchEntityError(_))
    }
    pub fn is_service_failure_error(&self) -> bool {
        matches!(&self.kind, CreateUserErrorKind::ServiceFailureError(_))
    }
}
impl std::error::Error for CreateUserError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateUserErrorKind::ConcurrentModificationError(_inner) => Some(_inner),
            CreateUserErrorKind::EntityAlreadyExistsError(_inner) => Some(_inner),
            CreateUserErrorKind::InvalidInputError(_inner) => Some(_inner),
            CreateUserErrorKind::LimitExceededError(_inner) => Some(_inner),
            CreateUserErrorKind::NoSuchEntityError(_inner) => Some(_inner),
            CreateUserErrorKind::ServiceFailureError(_inner) => Some(_inner),
            CreateUserErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateVirtualMFADeviceError {
    pub kind: CreateVirtualMFADeviceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateVirtualMFADeviceErrorKind {
    ConcurrentModificationError(crate::error::ConcurrentModificationError),
    EntityAlreadyExistsError(crate::error::EntityAlreadyExistsError),
    InvalidInputError(crate::error::InvalidInputError),
    LimitExceededError(crate::error::LimitExceededError),
    ServiceFailureError(crate::error::ServiceFailureError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateVirtualMFADeviceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateVirtualMFADeviceErrorKind::ConcurrentModificationError(_inner) => _inner.fmt(f),
            CreateVirtualMFADeviceErrorKind::EntityAlreadyExistsError(_inner) => _inner.fmt(f),
            CreateVirtualMFADeviceErrorKind::InvalidInputError(_inner) => _inner.fmt(f),
            CreateVirtualMFADeviceErrorKind::LimitExceededError(_inner) => _inner.fmt(f),
            CreateVirtualMFADeviceErrorKind::ServiceFailureError(_inner) => _inner.fmt(f),
            CreateVirtualMFADeviceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateVirtualMFADeviceError {
    fn code(&self) -> Option<&str> {
        CreateVirtualMFADeviceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateVirtualMFADeviceError {
    pub fn new(kind: CreateVirtualMFADeviceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateVirtualMFADeviceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateVirtualMFADeviceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_concurrent_modification_error(&self) -> bool {
        matches!(
            &self.kind,
            CreateVirtualMFADeviceErrorKind::ConcurrentModificationError(_)
        )
    }
    pub fn is_entity_already_exists_error(&self) -> bool {
        matches!(
            &self.kind,
            CreateVirtualMFADeviceErrorKind::EntityAlreadyExistsError(_)
        )
    }
    pub fn is_invalid_input_error(&self) -> bool {
        matches!(
            &self.kind,
            CreateVirtualMFADeviceErrorKind::InvalidInputError(_)
        )
    }
    pub fn is_limit_exceeded_error(&self) -> bool {
        matches!(
            &self.kind,
            CreateVirtualMFADeviceErrorKind::LimitExceededError(_)
        )
    }
    pub fn is_service_failure_error(&self) -> bool {
        matches!(
            &self.kind,
            CreateVirtualMFADeviceErrorKind::ServiceFailureError(_)
        )
    }
}
impl std::error::Error for CreateVirtualMFADeviceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateVirtualMFADeviceErrorKind::ConcurrentModificationError(_inner) => Some(_inner),
            CreateVirtualMFADeviceErrorKind::EntityAlreadyExistsError(_inner) => Some(_inner),
            CreateVirtualMFADeviceErrorKind::InvalidInputError(_inner) => Some(_inner),
            CreateVirtualMFADeviceErrorKind::LimitExceededError(_inner) => Some(_inner),
            CreateVirtualMFADeviceErrorKind::ServiceFailureError(_inner) => Some(_inner),
            CreateVirtualMFADeviceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeactivateMFADeviceError {
    pub kind: DeactivateMFADeviceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeactivateMFADeviceErrorKind {
    EntityTemporarilyUnmodifiableError(crate::error::EntityTemporarilyUnmodifiableError),
    LimitExceededError(crate::error::LimitExceededError),
    NoSuchEntityError(crate::error::NoSuchEntityError),
    ServiceFailureError(crate::error::ServiceFailureError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeactivateMFADeviceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeactivateMFADeviceErrorKind::EntityTemporarilyUnmodifiableError(_inner) => {
                _inner.fmt(f)
            }
            DeactivateMFADeviceErrorKind::LimitExceededError(_inner) => _inner.fmt(f),
            DeactivateMFADeviceErrorKind::NoSuchEntityError(_inner) => _inner.fmt(f),
            DeactivateMFADeviceErrorKind::ServiceFailureError(_inner) => _inner.fmt(f),
            DeactivateMFADeviceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeactivateMFADeviceError {
    fn code(&self) -> Option<&str> {
        DeactivateMFADeviceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeactivateMFADeviceError {
    pub fn new(kind: DeactivateMFADeviceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeactivateMFADeviceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeactivateMFADeviceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_entity_temporarily_unmodifiable_error(&self) -> bool {
        matches!(
            &self.kind,
            DeactivateMFADeviceErrorKind::EntityTemporarilyUnmodifiableError(_)
        )
    }
    pub fn is_limit_exceeded_error(&self) -> bool {
        matches!(
            &self.kind,
            DeactivateMFADeviceErrorKind::LimitExceededError(_)
        )
    }
    pub fn is_no_such_entity_error(&self) -> bool {
        matches!(
            &self.kind,
            DeactivateMFADeviceErrorKind::NoSuchEntityError(_)
        )
    }
    pub fn is_service_failure_error(&self) -> bool {
        matches!(
            &self.kind,
            DeactivateMFADeviceErrorKind::ServiceFailureError(_)
        )
    }
}
impl std::error::Error for DeactivateMFADeviceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeactivateMFADeviceErrorKind::EntityTemporarilyUnmodifiableError(_inner) => {
                Some(_inner)
            }
            DeactivateMFADeviceErrorKind::LimitExceededError(_inner) => Some(_inner),
            DeactivateMFADeviceErrorKind::NoSuchEntityError(_inner) => Some(_inner),
            DeactivateMFADeviceErrorKind::ServiceFailureError(_inner) => Some(_inner),
            DeactivateMFADeviceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteAccessKeyError {
    pub kind: DeleteAccessKeyErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteAccessKeyErrorKind {
    LimitExceededError(crate::error::LimitExceededError),
    NoSuchEntityError(crate::error::NoSuchEntityError),
    ServiceFailureError(crate::error::ServiceFailureError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteAccessKeyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteAccessKeyErrorKind::LimitExceededError(_inner) => _inner.fmt(f),
            DeleteAccessKeyErrorKind::NoSuchEntityError(_inner) => _inner.fmt(f),
            DeleteAccessKeyErrorKind::ServiceFailureError(_inner) => _inner.fmt(f),
            DeleteAccessKeyErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteAccessKeyError {
    fn code(&self) -> Option<&str> {
        DeleteAccessKeyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteAccessKeyError {
    pub fn new(kind: DeleteAccessKeyErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteAccessKeyErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteAccessKeyErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_limit_exceeded_error(&self) -> bool {
        matches!(&self.kind, DeleteAccessKeyErrorKind::LimitExceededError(_))
    }
    pub fn is_no_such_entity_error(&self) -> bool {
        matches!(&self.kind, DeleteAccessKeyErrorKind::NoSuchEntityError(_))
    }
    pub fn is_service_failure_error(&self) -> bool {
        matches!(&self.kind, DeleteAccessKeyErrorKind::ServiceFailureError(_))
    }
}
impl std::error::Error for DeleteAccessKeyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteAccessKeyErrorKind::LimitExceededError(_inner) => Some(_inner),
            DeleteAccessKeyErrorKind::NoSuchEntityError(_inner) => Some(_inner),
            DeleteAccessKeyErrorKind::ServiceFailureError(_inner) => Some(_inner),
            DeleteAccessKeyErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteAccountAliasError {
    pub kind: DeleteAccountAliasErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteAccountAliasErrorKind {
    LimitExceededError(crate::error::LimitExceededError),
    NoSuchEntityError(crate::error::NoSuchEntityError),
    ServiceFailureError(crate::error::ServiceFailureError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteAccountAliasError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteAccountAliasErrorKind::LimitExceededError(_inner) => _inner.fmt(f),
            DeleteAccountAliasErrorKind::NoSuchEntityError(_inner) => _inner.fmt(f),
            DeleteAccountAliasErrorKind::ServiceFailureError(_inner) => _inner.fmt(f),
            DeleteAccountAliasErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteAccountAliasError {
    fn code(&self) -> Option<&str> {
        DeleteAccountAliasError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteAccountAliasError {
    pub fn new(kind: DeleteAccountAliasErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteAccountAliasErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteAccountAliasErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_limit_exceeded_error(&self) -> bool {
        matches!(
            &self.kind,
            DeleteAccountAliasErrorKind::LimitExceededError(_)
        )
    }
    pub fn is_no_such_entity_error(&self) -> bool {
        matches!(
            &self.kind,
            DeleteAccountAliasErrorKind::NoSuchEntityError(_)
        )
    }
    pub fn is_service_failure_error(&self) -> bool {
        matches!(
            &self.kind,
            DeleteAccountAliasErrorKind::ServiceFailureError(_)
        )
    }
}
impl std::error::Error for DeleteAccountAliasError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteAccountAliasErrorKind::LimitExceededError(_inner) => Some(_inner),
            DeleteAccountAliasErrorKind::NoSuchEntityError(_inner) => Some(_inner),
            DeleteAccountAliasErrorKind::ServiceFailureError(_inner) => Some(_inner),
            DeleteAccountAliasErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteAccountPasswordPolicyError {
    pub kind: DeleteAccountPasswordPolicyErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteAccountPasswordPolicyErrorKind {
    LimitExceededError(crate::error::LimitExceededError),
    NoSuchEntityError(crate::error::NoSuchEntityError),
    ServiceFailureError(crate::error::ServiceFailureError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteAccountPasswordPolicyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteAccountPasswordPolicyErrorKind::LimitExceededError(_inner) => _inner.fmt(f),
            DeleteAccountPasswordPolicyErrorKind::NoSuchEntityError(_inner) => _inner.fmt(f),
            DeleteAccountPasswordPolicyErrorKind::ServiceFailureError(_inner) => _inner.fmt(f),
            DeleteAccountPasswordPolicyErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteAccountPasswordPolicyError {
    fn code(&self) -> Option<&str> {
        DeleteAccountPasswordPolicyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteAccountPasswordPolicyError {
    pub fn new(kind: DeleteAccountPasswordPolicyErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteAccountPasswordPolicyErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteAccountPasswordPolicyErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_limit_exceeded_error(&self) -> bool {
        matches!(
            &self.kind,
            DeleteAccountPasswordPolicyErrorKind::LimitExceededError(_)
        )
    }
    pub fn is_no_such_entity_error(&self) -> bool {
        matches!(
            &self.kind,
            DeleteAccountPasswordPolicyErrorKind::NoSuchEntityError(_)
        )
    }
    pub fn is_service_failure_error(&self) -> bool {
        matches!(
            &self.kind,
            DeleteAccountPasswordPolicyErrorKind::ServiceFailureError(_)
        )
    }
}
impl std::error::Error for DeleteAccountPasswordPolicyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteAccountPasswordPolicyErrorKind::LimitExceededError(_inner) => Some(_inner),
            DeleteAccountPasswordPolicyErrorKind::NoSuchEntityError(_inner) => Some(_inner),
            DeleteAccountPasswordPolicyErrorKind::ServiceFailureError(_inner) => Some(_inner),
            DeleteAccountPasswordPolicyErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteGroupError {
    pub kind: DeleteGroupErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteGroupErrorKind {
    DeleteConflictError(crate::error::DeleteConflictError),
    LimitExceededError(crate::error::LimitExceededError),
    NoSuchEntityError(crate::error::NoSuchEntityError),
    ServiceFailureError(crate::error::ServiceFailureError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteGroupError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteGroupErrorKind::DeleteConflictError(_inner) => _inner.fmt(f),
            DeleteGroupErrorKind::LimitExceededError(_inner) => _inner.fmt(f),
            DeleteGroupErrorKind::NoSuchEntityError(_inner) => _inner.fmt(f),
            DeleteGroupErrorKind::ServiceFailureError(_inner) => _inner.fmt(f),
            DeleteGroupErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteGroupError {
    fn code(&self) -> Option<&str> {
        DeleteGroupError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteGroupError {
    pub fn new(kind: DeleteGroupErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteGroupErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteGroupErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_delete_conflict_error(&self) -> bool {
        matches!(&self.kind, DeleteGroupErrorKind::DeleteConflictError(_))
    }
    pub fn is_limit_exceeded_error(&self) -> bool {
        matches!(&self.kind, DeleteGroupErrorKind::LimitExceededError(_))
    }
    pub fn is_no_such_entity_error(&self) -> bool {
        matches!(&self.kind, DeleteGroupErrorKind::NoSuchEntityError(_))
    }
    pub fn is_service_failure_error(&self) -> bool {
        matches!(&self.kind, DeleteGroupErrorKind::ServiceFailureError(_))
    }
}
impl std::error::Error for DeleteGroupError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteGroupErrorKind::DeleteConflictError(_inner) => Some(_inner),
            DeleteGroupErrorKind::LimitExceededError(_inner) => Some(_inner),
            DeleteGroupErrorKind::NoSuchEntityError(_inner) => Some(_inner),
            DeleteGroupErrorKind::ServiceFailureError(_inner) => Some(_inner),
            DeleteGroupErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteGroupPolicyError {
    pub kind: DeleteGroupPolicyErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteGroupPolicyErrorKind {
    LimitExceededError(crate::error::LimitExceededError),
    NoSuchEntityError(crate::error::NoSuchEntityError),
    ServiceFailureError(crate::error::ServiceFailureError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteGroupPolicyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteGroupPolicyErrorKind::LimitExceededError(_inner) => _inner.fmt(f),
            DeleteGroupPolicyErrorKind::NoSuchEntityError(_inner) => _inner.fmt(f),
            DeleteGroupPolicyErrorKind::ServiceFailureError(_inner) => _inner.fmt(f),
            DeleteGroupPolicyErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteGroupPolicyError {
    fn code(&self) -> Option<&str> {
        DeleteGroupPolicyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteGroupPolicyError {
    pub fn new(kind: DeleteGroupPolicyErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteGroupPolicyErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteGroupPolicyErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_limit_exceeded_error(&self) -> bool {
        matches!(
            &self.kind,
            DeleteGroupPolicyErrorKind::LimitExceededError(_)
        )
    }
    pub fn is_no_such_entity_error(&self) -> bool {
        matches!(&self.kind, DeleteGroupPolicyErrorKind::NoSuchEntityError(_))
    }
    pub fn is_service_failure_error(&self) -> bool {
        matches!(
            &self.kind,
            DeleteGroupPolicyErrorKind::ServiceFailureError(_)
        )
    }
}
impl std::error::Error for DeleteGroupPolicyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteGroupPolicyErrorKind::LimitExceededError(_inner) => Some(_inner),
            DeleteGroupPolicyErrorKind::NoSuchEntityError(_inner) => Some(_inner),
            DeleteGroupPolicyErrorKind::ServiceFailureError(_inner) => Some(_inner),
            DeleteGroupPolicyErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteInstanceProfileError {
    pub kind: DeleteInstanceProfileErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteInstanceProfileErrorKind {
    DeleteConflictError(crate::error::DeleteConflictError),
    LimitExceededError(crate::error::LimitExceededError),
    NoSuchEntityError(crate::error::NoSuchEntityError),
    ServiceFailureError(crate::error::ServiceFailureError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteInstanceProfileError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteInstanceProfileErrorKind::DeleteConflictError(_inner) => _inner.fmt(f),
            DeleteInstanceProfileErrorKind::LimitExceededError(_inner) => _inner.fmt(f),
            DeleteInstanceProfileErrorKind::NoSuchEntityError(_inner) => _inner.fmt(f),
            DeleteInstanceProfileErrorKind::ServiceFailureError(_inner) => _inner.fmt(f),
            DeleteInstanceProfileErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteInstanceProfileError {
    fn code(&self) -> Option<&str> {
        DeleteInstanceProfileError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteInstanceProfileError {
    pub fn new(kind: DeleteInstanceProfileErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteInstanceProfileErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteInstanceProfileErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_delete_conflict_error(&self) -> bool {
        matches!(
            &self.kind,
            DeleteInstanceProfileErrorKind::DeleteConflictError(_)
        )
    }
    pub fn is_limit_exceeded_error(&self) -> bool {
        matches!(
            &self.kind,
            DeleteInstanceProfileErrorKind::LimitExceededError(_)
        )
    }
    pub fn is_no_such_entity_error(&self) -> bool {
        matches!(
            &self.kind,
            DeleteInstanceProfileErrorKind::NoSuchEntityError(_)
        )
    }
    pub fn is_service_failure_error(&self) -> bool {
        matches!(
            &self.kind,
            DeleteInstanceProfileErrorKind::ServiceFailureError(_)
        )
    }
}
impl std::error::Error for DeleteInstanceProfileError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteInstanceProfileErrorKind::DeleteConflictError(_inner) => Some(_inner),
            DeleteInstanceProfileErrorKind::LimitExceededError(_inner) => Some(_inner),
            DeleteInstanceProfileErrorKind::NoSuchEntityError(_inner) => Some(_inner),
            DeleteInstanceProfileErrorKind::ServiceFailureError(_inner) => Some(_inner),
            DeleteInstanceProfileErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteLoginProfileError {
    pub kind: DeleteLoginProfileErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteLoginProfileErrorKind {
    EntityTemporarilyUnmodifiableError(crate::error::EntityTemporarilyUnmodifiableError),
    LimitExceededError(crate::error::LimitExceededError),
    NoSuchEntityError(crate::error::NoSuchEntityError),
    ServiceFailureError(crate::error::ServiceFailureError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteLoginProfileError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteLoginProfileErrorKind::EntityTemporarilyUnmodifiableError(_inner) => {
                _inner.fmt(f)
            }
            DeleteLoginProfileErrorKind::LimitExceededError(_inner) => _inner.fmt(f),
            DeleteLoginProfileErrorKind::NoSuchEntityError(_inner) => _inner.fmt(f),
            DeleteLoginProfileErrorKind::ServiceFailureError(_inner) => _inner.fmt(f),
            DeleteLoginProfileErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteLoginProfileError {
    fn code(&self) -> Option<&str> {
        DeleteLoginProfileError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteLoginProfileError {
    pub fn new(kind: DeleteLoginProfileErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteLoginProfileErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteLoginProfileErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_entity_temporarily_unmodifiable_error(&self) -> bool {
        matches!(
            &self.kind,
            DeleteLoginProfileErrorKind::EntityTemporarilyUnmodifiableError(_)
        )
    }
    pub fn is_limit_exceeded_error(&self) -> bool {
        matches!(
            &self.kind,
            DeleteLoginProfileErrorKind::LimitExceededError(_)
        )
    }
    pub fn is_no_such_entity_error(&self) -> bool {
        matches!(
            &self.kind,
            DeleteLoginProfileErrorKind::NoSuchEntityError(_)
        )
    }
    pub fn is_service_failure_error(&self) -> bool {
        matches!(
            &self.kind,
            DeleteLoginProfileErrorKind::ServiceFailureError(_)
        )
    }
}
impl std::error::Error for DeleteLoginProfileError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteLoginProfileErrorKind::EntityTemporarilyUnmodifiableError(_inner) => Some(_inner),
            DeleteLoginProfileErrorKind::LimitExceededError(_inner) => Some(_inner),
            DeleteLoginProfileErrorKind::NoSuchEntityError(_inner) => Some(_inner),
            DeleteLoginProfileErrorKind::ServiceFailureError(_inner) => Some(_inner),
            DeleteLoginProfileErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteOpenIDConnectProviderError {
    pub kind: DeleteOpenIDConnectProviderErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteOpenIDConnectProviderErrorKind {
    InvalidInputError(crate::error::InvalidInputError),
    NoSuchEntityError(crate::error::NoSuchEntityError),
    ServiceFailureError(crate::error::ServiceFailureError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteOpenIDConnectProviderError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteOpenIDConnectProviderErrorKind::InvalidInputError(_inner) => _inner.fmt(f),
            DeleteOpenIDConnectProviderErrorKind::NoSuchEntityError(_inner) => _inner.fmt(f),
            DeleteOpenIDConnectProviderErrorKind::ServiceFailureError(_inner) => _inner.fmt(f),
            DeleteOpenIDConnectProviderErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteOpenIDConnectProviderError {
    fn code(&self) -> Option<&str> {
        DeleteOpenIDConnectProviderError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteOpenIDConnectProviderError {
    pub fn new(kind: DeleteOpenIDConnectProviderErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteOpenIDConnectProviderErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteOpenIDConnectProviderErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_input_error(&self) -> bool {
        matches!(
            &self.kind,
            DeleteOpenIDConnectProviderErrorKind::InvalidInputError(_)
        )
    }
    pub fn is_no_such_entity_error(&self) -> bool {
        matches!(
            &self.kind,
            DeleteOpenIDConnectProviderErrorKind::NoSuchEntityError(_)
        )
    }
    pub fn is_service_failure_error(&self) -> bool {
        matches!(
            &self.kind,
            DeleteOpenIDConnectProviderErrorKind::ServiceFailureError(_)
        )
    }
}
impl std::error::Error for DeleteOpenIDConnectProviderError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteOpenIDConnectProviderErrorKind::InvalidInputError(_inner) => Some(_inner),
            DeleteOpenIDConnectProviderErrorKind::NoSuchEntityError(_inner) => Some(_inner),
            DeleteOpenIDConnectProviderErrorKind::ServiceFailureError(_inner) => Some(_inner),
            DeleteOpenIDConnectProviderErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeletePolicyError {
    pub kind: DeletePolicyErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeletePolicyErrorKind {
    DeleteConflictError(crate::error::DeleteConflictError),
    InvalidInputError(crate::error::InvalidInputError),
    LimitExceededError(crate::error::LimitExceededError),
    NoSuchEntityError(crate::error::NoSuchEntityError),
    ServiceFailureError(crate::error::ServiceFailureError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeletePolicyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeletePolicyErrorKind::DeleteConflictError(_inner) => _inner.fmt(f),
            DeletePolicyErrorKind::InvalidInputError(_inner) => _inner.fmt(f),
            DeletePolicyErrorKind::LimitExceededError(_inner) => _inner.fmt(f),
            DeletePolicyErrorKind::NoSuchEntityError(_inner) => _inner.fmt(f),
            DeletePolicyErrorKind::ServiceFailureError(_inner) => _inner.fmt(f),
            DeletePolicyErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeletePolicyError {
    fn code(&self) -> Option<&str> {
        DeletePolicyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeletePolicyError {
    pub fn new(kind: DeletePolicyErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeletePolicyErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeletePolicyErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_delete_conflict_error(&self) -> bool {
        matches!(&self.kind, DeletePolicyErrorKind::DeleteConflictError(_))
    }
    pub fn is_invalid_input_error(&self) -> bool {
        matches!(&self.kind, DeletePolicyErrorKind::InvalidInputError(_))
    }
    pub fn is_limit_exceeded_error(&self) -> bool {
        matches!(&self.kind, DeletePolicyErrorKind::LimitExceededError(_))
    }
    pub fn is_no_such_entity_error(&self) -> bool {
        matches!(&self.kind, DeletePolicyErrorKind::NoSuchEntityError(_))
    }
    pub fn is_service_failure_error(&self) -> bool {
        matches!(&self.kind, DeletePolicyErrorKind::ServiceFailureError(_))
    }
}
impl std::error::Error for DeletePolicyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeletePolicyErrorKind::DeleteConflictError(_inner) => Some(_inner),
            DeletePolicyErrorKind::InvalidInputError(_inner) => Some(_inner),
            DeletePolicyErrorKind::LimitExceededError(_inner) => Some(_inner),
            DeletePolicyErrorKind::NoSuchEntityError(_inner) => Some(_inner),
            DeletePolicyErrorKind::ServiceFailureError(_inner) => Some(_inner),
            DeletePolicyErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeletePolicyVersionError {
    pub kind: DeletePolicyVersionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeletePolicyVersionErrorKind {
    DeleteConflictError(crate::error::DeleteConflictError),
    InvalidInputError(crate::error::InvalidInputError),
    LimitExceededError(crate::error::LimitExceededError),
    NoSuchEntityError(crate::error::NoSuchEntityError),
    ServiceFailureError(crate::error::ServiceFailureError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeletePolicyVersionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeletePolicyVersionErrorKind::DeleteConflictError(_inner) => _inner.fmt(f),
            DeletePolicyVersionErrorKind::InvalidInputError(_inner) => _inner.fmt(f),
            DeletePolicyVersionErrorKind::LimitExceededError(_inner) => _inner.fmt(f),
            DeletePolicyVersionErrorKind::NoSuchEntityError(_inner) => _inner.fmt(f),
            DeletePolicyVersionErrorKind::ServiceFailureError(_inner) => _inner.fmt(f),
            DeletePolicyVersionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeletePolicyVersionError {
    fn code(&self) -> Option<&str> {
        DeletePolicyVersionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeletePolicyVersionError {
    pub fn new(kind: DeletePolicyVersionErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeletePolicyVersionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeletePolicyVersionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_delete_conflict_error(&self) -> bool {
        matches!(
            &self.kind,
            DeletePolicyVersionErrorKind::DeleteConflictError(_)
        )
    }
    pub fn is_invalid_input_error(&self) -> bool {
        matches!(
            &self.kind,
            DeletePolicyVersionErrorKind::InvalidInputError(_)
        )
    }
    pub fn is_limit_exceeded_error(&self) -> bool {
        matches!(
            &self.kind,
            DeletePolicyVersionErrorKind::LimitExceededError(_)
        )
    }
    pub fn is_no_such_entity_error(&self) -> bool {
        matches!(
            &self.kind,
            DeletePolicyVersionErrorKind::NoSuchEntityError(_)
        )
    }
    pub fn is_service_failure_error(&self) -> bool {
        matches!(
            &self.kind,
            DeletePolicyVersionErrorKind::ServiceFailureError(_)
        )
    }
}
impl std::error::Error for DeletePolicyVersionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeletePolicyVersionErrorKind::DeleteConflictError(_inner) => Some(_inner),
            DeletePolicyVersionErrorKind::InvalidInputError(_inner) => Some(_inner),
            DeletePolicyVersionErrorKind::LimitExceededError(_inner) => Some(_inner),
            DeletePolicyVersionErrorKind::NoSuchEntityError(_inner) => Some(_inner),
            DeletePolicyVersionErrorKind::ServiceFailureError(_inner) => Some(_inner),
            DeletePolicyVersionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteRoleError {
    pub kind: DeleteRoleErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteRoleErrorKind {
    ConcurrentModificationError(crate::error::ConcurrentModificationError),
    DeleteConflictError(crate::error::DeleteConflictError),
    LimitExceededError(crate::error::LimitExceededError),
    NoSuchEntityError(crate::error::NoSuchEntityError),
    ServiceFailureError(crate::error::ServiceFailureError),
    UnmodifiableEntityError(crate::error::UnmodifiableEntityError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteRoleError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteRoleErrorKind::ConcurrentModificationError(_inner) => _inner.fmt(f),
            DeleteRoleErrorKind::DeleteConflictError(_inner) => _inner.fmt(f),
            DeleteRoleErrorKind::LimitExceededError(_inner) => _inner.fmt(f),
            DeleteRoleErrorKind::NoSuchEntityError(_inner) => _inner.fmt(f),
            DeleteRoleErrorKind::ServiceFailureError(_inner) => _inner.fmt(f),
            DeleteRoleErrorKind::UnmodifiableEntityError(_inner) => _inner.fmt(f),
            DeleteRoleErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteRoleError {
    fn code(&self) -> Option<&str> {
        DeleteRoleError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteRoleError {
    pub fn new(kind: DeleteRoleErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteRoleErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteRoleErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_concurrent_modification_error(&self) -> bool {
        matches!(
            &self.kind,
            DeleteRoleErrorKind::ConcurrentModificationError(_)
        )
    }
    pub fn is_delete_conflict_error(&self) -> bool {
        matches!(&self.kind, DeleteRoleErrorKind::DeleteConflictError(_))
    }
    pub fn is_limit_exceeded_error(&self) -> bool {
        matches!(&self.kind, DeleteRoleErrorKind::LimitExceededError(_))
    }
    pub fn is_no_such_entity_error(&self) -> bool {
        matches!(&self.kind, DeleteRoleErrorKind::NoSuchEntityError(_))
    }
    pub fn is_service_failure_error(&self) -> bool {
        matches!(&self.kind, DeleteRoleErrorKind::ServiceFailureError(_))
    }
    pub fn is_unmodifiable_entity_error(&self) -> bool {
        matches!(&self.kind, DeleteRoleErrorKind::UnmodifiableEntityError(_))
    }
}
impl std::error::Error for DeleteRoleError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteRoleErrorKind::ConcurrentModificationError(_inner) => Some(_inner),
            DeleteRoleErrorKind::DeleteConflictError(_inner) => Some(_inner),
            DeleteRoleErrorKind::LimitExceededError(_inner) => Some(_inner),
            DeleteRoleErrorKind::NoSuchEntityError(_inner) => Some(_inner),
            DeleteRoleErrorKind::ServiceFailureError(_inner) => Some(_inner),
            DeleteRoleErrorKind::UnmodifiableEntityError(_inner) => Some(_inner),
            DeleteRoleErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteRolePermissionsBoundaryError {
    pub kind: DeleteRolePermissionsBoundaryErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteRolePermissionsBoundaryErrorKind {
    NoSuchEntityError(crate::error::NoSuchEntityError),
    ServiceFailureError(crate::error::ServiceFailureError),
    UnmodifiableEntityError(crate::error::UnmodifiableEntityError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteRolePermissionsBoundaryError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteRolePermissionsBoundaryErrorKind::NoSuchEntityError(_inner) => _inner.fmt(f),
            DeleteRolePermissionsBoundaryErrorKind::ServiceFailureError(_inner) => _inner.fmt(f),
            DeleteRolePermissionsBoundaryErrorKind::UnmodifiableEntityError(_inner) => {
                _inner.fmt(f)
            }
            DeleteRolePermissionsBoundaryErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteRolePermissionsBoundaryError {
    fn code(&self) -> Option<&str> {
        DeleteRolePermissionsBoundaryError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteRolePermissionsBoundaryError {
    pub fn new(kind: DeleteRolePermissionsBoundaryErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteRolePermissionsBoundaryErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteRolePermissionsBoundaryErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_no_such_entity_error(&self) -> bool {
        matches!(
            &self.kind,
            DeleteRolePermissionsBoundaryErrorKind::NoSuchEntityError(_)
        )
    }
    pub fn is_service_failure_error(&self) -> bool {
        matches!(
            &self.kind,
            DeleteRolePermissionsBoundaryErrorKind::ServiceFailureError(_)
        )
    }
    pub fn is_unmodifiable_entity_error(&self) -> bool {
        matches!(
            &self.kind,
            DeleteRolePermissionsBoundaryErrorKind::UnmodifiableEntityError(_)
        )
    }
}
impl std::error::Error for DeleteRolePermissionsBoundaryError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteRolePermissionsBoundaryErrorKind::NoSuchEntityError(_inner) => Some(_inner),
            DeleteRolePermissionsBoundaryErrorKind::ServiceFailureError(_inner) => Some(_inner),
            DeleteRolePermissionsBoundaryErrorKind::UnmodifiableEntityError(_inner) => Some(_inner),
            DeleteRolePermissionsBoundaryErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteRolePolicyError {
    pub kind: DeleteRolePolicyErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteRolePolicyErrorKind {
    LimitExceededError(crate::error::LimitExceededError),
    NoSuchEntityError(crate::error::NoSuchEntityError),
    ServiceFailureError(crate::error::ServiceFailureError),
    UnmodifiableEntityError(crate::error::UnmodifiableEntityError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteRolePolicyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteRolePolicyErrorKind::LimitExceededError(_inner) => _inner.fmt(f),
            DeleteRolePolicyErrorKind::NoSuchEntityError(_inner) => _inner.fmt(f),
            DeleteRolePolicyErrorKind::ServiceFailureError(_inner) => _inner.fmt(f),
            DeleteRolePolicyErrorKind::UnmodifiableEntityError(_inner) => _inner.fmt(f),
            DeleteRolePolicyErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteRolePolicyError {
    fn code(&self) -> Option<&str> {
        DeleteRolePolicyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteRolePolicyError {
    pub fn new(kind: DeleteRolePolicyErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteRolePolicyErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteRolePolicyErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_limit_exceeded_error(&self) -> bool {
        matches!(&self.kind, DeleteRolePolicyErrorKind::LimitExceededError(_))
    }
    pub fn is_no_such_entity_error(&self) -> bool {
        matches!(&self.kind, DeleteRolePolicyErrorKind::NoSuchEntityError(_))
    }
    pub fn is_service_failure_error(&self) -> bool {
        matches!(
            &self.kind,
            DeleteRolePolicyErrorKind::ServiceFailureError(_)
        )
    }
    pub fn is_unmodifiable_entity_error(&self) -> bool {
        matches!(
            &self.kind,
            DeleteRolePolicyErrorKind::UnmodifiableEntityError(_)
        )
    }
}
impl std::error::Error for DeleteRolePolicyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteRolePolicyErrorKind::LimitExceededError(_inner) => Some(_inner),
            DeleteRolePolicyErrorKind::NoSuchEntityError(_inner) => Some(_inner),
            DeleteRolePolicyErrorKind::ServiceFailureError(_inner) => Some(_inner),
            DeleteRolePolicyErrorKind::UnmodifiableEntityError(_inner) => Some(_inner),
            DeleteRolePolicyErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteSAMLProviderError {
    pub kind: DeleteSAMLProviderErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteSAMLProviderErrorKind {
    InvalidInputError(crate::error::InvalidInputError),
    LimitExceededError(crate::error::LimitExceededError),
    NoSuchEntityError(crate::error::NoSuchEntityError),
    ServiceFailureError(crate::error::ServiceFailureError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteSAMLProviderError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteSAMLProviderErrorKind::InvalidInputError(_inner) => _inner.fmt(f),
            DeleteSAMLProviderErrorKind::LimitExceededError(_inner) => _inner.fmt(f),
            DeleteSAMLProviderErrorKind::NoSuchEntityError(_inner) => _inner.fmt(f),
            DeleteSAMLProviderErrorKind::ServiceFailureError(_inner) => _inner.fmt(f),
            DeleteSAMLProviderErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteSAMLProviderError {
    fn code(&self) -> Option<&str> {
        DeleteSAMLProviderError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteSAMLProviderError {
    pub fn new(kind: DeleteSAMLProviderErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteSAMLProviderErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteSAMLProviderErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_input_error(&self) -> bool {
        matches!(
            &self.kind,
            DeleteSAMLProviderErrorKind::InvalidInputError(_)
        )
    }
    pub fn is_limit_exceeded_error(&self) -> bool {
        matches!(
            &self.kind,
            DeleteSAMLProviderErrorKind::LimitExceededError(_)
        )
    }
    pub fn is_no_such_entity_error(&self) -> bool {
        matches!(
            &self.kind,
            DeleteSAMLProviderErrorKind::NoSuchEntityError(_)
        )
    }
    pub fn is_service_failure_error(&self) -> bool {
        matches!(
            &self.kind,
            DeleteSAMLProviderErrorKind::ServiceFailureError(_)
        )
    }
}
impl std::error::Error for DeleteSAMLProviderError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteSAMLProviderErrorKind::InvalidInputError(_inner) => Some(_inner),
            DeleteSAMLProviderErrorKind::LimitExceededError(_inner) => Some(_inner),
            DeleteSAMLProviderErrorKind::NoSuchEntityError(_inner) => Some(_inner),
            DeleteSAMLProviderErrorKind::ServiceFailureError(_inner) => Some(_inner),
            DeleteSAMLProviderErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteServerCertificateError {
    pub kind: DeleteServerCertificateErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteServerCertificateErrorKind {
    DeleteConflictError(crate::error::DeleteConflictError),
    LimitExceededError(crate::error::LimitExceededError),
    NoSuchEntityError(crate::error::NoSuchEntityError),
    ServiceFailureError(crate::error::ServiceFailureError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteServerCertificateError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteServerCertificateErrorKind::DeleteConflictError(_inner) => _inner.fmt(f),
            DeleteServerCertificateErrorKind::LimitExceededError(_inner) => _inner.fmt(f),
            DeleteServerCertificateErrorKind::NoSuchEntityError(_inner) => _inner.fmt(f),
            DeleteServerCertificateErrorKind::ServiceFailureError(_inner) => _inner.fmt(f),
            DeleteServerCertificateErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteServerCertificateError {
    fn code(&self) -> Option<&str> {
        DeleteServerCertificateError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteServerCertificateError {
    pub fn new(kind: DeleteServerCertificateErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteServerCertificateErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteServerCertificateErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_delete_conflict_error(&self) -> bool {
        matches!(
            &self.kind,
            DeleteServerCertificateErrorKind::DeleteConflictError(_)
        )
    }
    pub fn is_limit_exceeded_error(&self) -> bool {
        matches!(
            &self.kind,
            DeleteServerCertificateErrorKind::LimitExceededError(_)
        )
    }
    pub fn is_no_such_entity_error(&self) -> bool {
        matches!(
            &self.kind,
            DeleteServerCertificateErrorKind::NoSuchEntityError(_)
        )
    }
    pub fn is_service_failure_error(&self) -> bool {
        matches!(
            &self.kind,
            DeleteServerCertificateErrorKind::ServiceFailureError(_)
        )
    }
}
impl std::error::Error for DeleteServerCertificateError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteServerCertificateErrorKind::DeleteConflictError(_inner) => Some(_inner),
            DeleteServerCertificateErrorKind::LimitExceededError(_inner) => Some(_inner),
            DeleteServerCertificateErrorKind::NoSuchEntityError(_inner) => Some(_inner),
            DeleteServerCertificateErrorKind::ServiceFailureError(_inner) => Some(_inner),
            DeleteServerCertificateErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteServiceLinkedRoleError {
    pub kind: DeleteServiceLinkedRoleErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteServiceLinkedRoleErrorKind {
    LimitExceededError(crate::error::LimitExceededError),
    NoSuchEntityError(crate::error::NoSuchEntityError),
    ServiceFailureError(crate::error::ServiceFailureError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteServiceLinkedRoleError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteServiceLinkedRoleErrorKind::LimitExceededError(_inner) => _inner.fmt(f),
            DeleteServiceLinkedRoleErrorKind::NoSuchEntityError(_inner) => _inner.fmt(f),
            DeleteServiceLinkedRoleErrorKind::ServiceFailureError(_inner) => _inner.fmt(f),
            DeleteServiceLinkedRoleErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteServiceLinkedRoleError {
    fn code(&self) -> Option<&str> {
        DeleteServiceLinkedRoleError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteServiceLinkedRoleError {
    pub fn new(kind: DeleteServiceLinkedRoleErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteServiceLinkedRoleErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteServiceLinkedRoleErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_limit_exceeded_error(&self) -> bool {
        matches!(
            &self.kind,
            DeleteServiceLinkedRoleErrorKind::LimitExceededError(_)
        )
    }
    pub fn is_no_such_entity_error(&self) -> bool {
        matches!(
            &self.kind,
            DeleteServiceLinkedRoleErrorKind::NoSuchEntityError(_)
        )
    }
    pub fn is_service_failure_error(&self) -> bool {
        matches!(
            &self.kind,
            DeleteServiceLinkedRoleErrorKind::ServiceFailureError(_)
        )
    }
}
impl std::error::Error for DeleteServiceLinkedRoleError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteServiceLinkedRoleErrorKind::LimitExceededError(_inner) => Some(_inner),
            DeleteServiceLinkedRoleErrorKind::NoSuchEntityError(_inner) => Some(_inner),
            DeleteServiceLinkedRoleErrorKind::ServiceFailureError(_inner) => Some(_inner),
            DeleteServiceLinkedRoleErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteServiceSpecificCredentialError {
    pub kind: DeleteServiceSpecificCredentialErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteServiceSpecificCredentialErrorKind {
    NoSuchEntityError(crate::error::NoSuchEntityError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteServiceSpecificCredentialError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteServiceSpecificCredentialErrorKind::NoSuchEntityError(_inner) => _inner.fmt(f),
            DeleteServiceSpecificCredentialErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteServiceSpecificCredentialError {
    fn code(&self) -> Option<&str> {
        DeleteServiceSpecificCredentialError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteServiceSpecificCredentialError {
    pub fn new(kind: DeleteServiceSpecificCredentialErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteServiceSpecificCredentialErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteServiceSpecificCredentialErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_no_such_entity_error(&self) -> bool {
        matches!(
            &self.kind,
            DeleteServiceSpecificCredentialErrorKind::NoSuchEntityError(_)
        )
    }
}
impl std::error::Error for DeleteServiceSpecificCredentialError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteServiceSpecificCredentialErrorKind::NoSuchEntityError(_inner) => Some(_inner),
            DeleteServiceSpecificCredentialErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteSigningCertificateError {
    pub kind: DeleteSigningCertificateErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteSigningCertificateErrorKind {
    LimitExceededError(crate::error::LimitExceededError),
    NoSuchEntityError(crate::error::NoSuchEntityError),
    ServiceFailureError(crate::error::ServiceFailureError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteSigningCertificateError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteSigningCertificateErrorKind::LimitExceededError(_inner) => _inner.fmt(f),
            DeleteSigningCertificateErrorKind::NoSuchEntityError(_inner) => _inner.fmt(f),
            DeleteSigningCertificateErrorKind::ServiceFailureError(_inner) => _inner.fmt(f),
            DeleteSigningCertificateErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteSigningCertificateError {
    fn code(&self) -> Option<&str> {
        DeleteSigningCertificateError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteSigningCertificateError {
    pub fn new(kind: DeleteSigningCertificateErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteSigningCertificateErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteSigningCertificateErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_limit_exceeded_error(&self) -> bool {
        matches!(
            &self.kind,
            DeleteSigningCertificateErrorKind::LimitExceededError(_)
        )
    }
    pub fn is_no_such_entity_error(&self) -> bool {
        matches!(
            &self.kind,
            DeleteSigningCertificateErrorKind::NoSuchEntityError(_)
        )
    }
    pub fn is_service_failure_error(&self) -> bool {
        matches!(
            &self.kind,
            DeleteSigningCertificateErrorKind::ServiceFailureError(_)
        )
    }
}
impl std::error::Error for DeleteSigningCertificateError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteSigningCertificateErrorKind::LimitExceededError(_inner) => Some(_inner),
            DeleteSigningCertificateErrorKind::NoSuchEntityError(_inner) => Some(_inner),
            DeleteSigningCertificateErrorKind::ServiceFailureError(_inner) => Some(_inner),
            DeleteSigningCertificateErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteSSHPublicKeyError {
    pub kind: DeleteSSHPublicKeyErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteSSHPublicKeyErrorKind {
    NoSuchEntityError(crate::error::NoSuchEntityError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteSSHPublicKeyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteSSHPublicKeyErrorKind::NoSuchEntityError(_inner) => _inner.fmt(f),
            DeleteSSHPublicKeyErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteSSHPublicKeyError {
    fn code(&self) -> Option<&str> {
        DeleteSSHPublicKeyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteSSHPublicKeyError {
    pub fn new(kind: DeleteSSHPublicKeyErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteSSHPublicKeyErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteSSHPublicKeyErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_no_such_entity_error(&self) -> bool {
        matches!(
            &self.kind,
            DeleteSSHPublicKeyErrorKind::NoSuchEntityError(_)
        )
    }
}
impl std::error::Error for DeleteSSHPublicKeyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteSSHPublicKeyErrorKind::NoSuchEntityError(_inner) => Some(_inner),
            DeleteSSHPublicKeyErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteUserError {
    pub kind: DeleteUserErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteUserErrorKind {
    ConcurrentModificationError(crate::error::ConcurrentModificationError),
    DeleteConflictError(crate::error::DeleteConflictError),
    LimitExceededError(crate::error::LimitExceededError),
    NoSuchEntityError(crate::error::NoSuchEntityError),
    ServiceFailureError(crate::error::ServiceFailureError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteUserError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteUserErrorKind::ConcurrentModificationError(_inner) => _inner.fmt(f),
            DeleteUserErrorKind::DeleteConflictError(_inner) => _inner.fmt(f),
            DeleteUserErrorKind::LimitExceededError(_inner) => _inner.fmt(f),
            DeleteUserErrorKind::NoSuchEntityError(_inner) => _inner.fmt(f),
            DeleteUserErrorKind::ServiceFailureError(_inner) => _inner.fmt(f),
            DeleteUserErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteUserError {
    fn code(&self) -> Option<&str> {
        DeleteUserError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteUserError {
    pub fn new(kind: DeleteUserErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteUserErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteUserErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_concurrent_modification_error(&self) -> bool {
        matches!(
            &self.kind,
            DeleteUserErrorKind::ConcurrentModificationError(_)
        )
    }
    pub fn is_delete_conflict_error(&self) -> bool {
        matches!(&self.kind, DeleteUserErrorKind::DeleteConflictError(_))
    }
    pub fn is_limit_exceeded_error(&self) -> bool {
        matches!(&self.kind, DeleteUserErrorKind::LimitExceededError(_))
    }
    pub fn is_no_such_entity_error(&self) -> bool {
        matches!(&self.kind, DeleteUserErrorKind::NoSuchEntityError(_))
    }
    pub fn is_service_failure_error(&self) -> bool {
        matches!(&self.kind, DeleteUserErrorKind::ServiceFailureError(_))
    }
}
impl std::error::Error for DeleteUserError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteUserErrorKind::ConcurrentModificationError(_inner) => Some(_inner),
            DeleteUserErrorKind::DeleteConflictError(_inner) => Some(_inner),
            DeleteUserErrorKind::LimitExceededError(_inner) => Some(_inner),
            DeleteUserErrorKind::NoSuchEntityError(_inner) => Some(_inner),
            DeleteUserErrorKind::ServiceFailureError(_inner) => Some(_inner),
            DeleteUserErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteUserPermissionsBoundaryError {
    pub kind: DeleteUserPermissionsBoundaryErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteUserPermissionsBoundaryErrorKind {
    NoSuchEntityError(crate::error::NoSuchEntityError),
    ServiceFailureError(crate::error::ServiceFailureError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteUserPermissionsBoundaryError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteUserPermissionsBoundaryErrorKind::NoSuchEntityError(_inner) => _inner.fmt(f),
            DeleteUserPermissionsBoundaryErrorKind::ServiceFailureError(_inner) => _inner.fmt(f),
            DeleteUserPermissionsBoundaryErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteUserPermissionsBoundaryError {
    fn code(&self) -> Option<&str> {
        DeleteUserPermissionsBoundaryError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteUserPermissionsBoundaryError {
    pub fn new(kind: DeleteUserPermissionsBoundaryErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteUserPermissionsBoundaryErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteUserPermissionsBoundaryErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_no_such_entity_error(&self) -> bool {
        matches!(
            &self.kind,
            DeleteUserPermissionsBoundaryErrorKind::NoSuchEntityError(_)
        )
    }
    pub fn is_service_failure_error(&self) -> bool {
        matches!(
            &self.kind,
            DeleteUserPermissionsBoundaryErrorKind::ServiceFailureError(_)
        )
    }
}
impl std::error::Error for DeleteUserPermissionsBoundaryError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteUserPermissionsBoundaryErrorKind::NoSuchEntityError(_inner) => Some(_inner),
            DeleteUserPermissionsBoundaryErrorKind::ServiceFailureError(_inner) => Some(_inner),
            DeleteUserPermissionsBoundaryErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteUserPolicyError {
    pub kind: DeleteUserPolicyErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteUserPolicyErrorKind {
    LimitExceededError(crate::error::LimitExceededError),
    NoSuchEntityError(crate::error::NoSuchEntityError),
    ServiceFailureError(crate::error::ServiceFailureError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteUserPolicyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteUserPolicyErrorKind::LimitExceededError(_inner) => _inner.fmt(f),
            DeleteUserPolicyErrorKind::NoSuchEntityError(_inner) => _inner.fmt(f),
            DeleteUserPolicyErrorKind::ServiceFailureError(_inner) => _inner.fmt(f),
            DeleteUserPolicyErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteUserPolicyError {
    fn code(&self) -> Option<&str> {
        DeleteUserPolicyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteUserPolicyError {
    pub fn new(kind: DeleteUserPolicyErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteUserPolicyErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteUserPolicyErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_limit_exceeded_error(&self) -> bool {
        matches!(&self.kind, DeleteUserPolicyErrorKind::LimitExceededError(_))
    }
    pub fn is_no_such_entity_error(&self) -> bool {
        matches!(&self.kind, DeleteUserPolicyErrorKind::NoSuchEntityError(_))
    }
    pub fn is_service_failure_error(&self) -> bool {
        matches!(
            &self.kind,
            DeleteUserPolicyErrorKind::ServiceFailureError(_)
        )
    }
}
impl std::error::Error for DeleteUserPolicyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteUserPolicyErrorKind::LimitExceededError(_inner) => Some(_inner),
            DeleteUserPolicyErrorKind::NoSuchEntityError(_inner) => Some(_inner),
            DeleteUserPolicyErrorKind::ServiceFailureError(_inner) => Some(_inner),
            DeleteUserPolicyErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteVirtualMFADeviceError {
    pub kind: DeleteVirtualMFADeviceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteVirtualMFADeviceErrorKind {
    DeleteConflictError(crate::error::DeleteConflictError),
    LimitExceededError(crate::error::LimitExceededError),
    NoSuchEntityError(crate::error::NoSuchEntityError),
    ServiceFailureError(crate::error::ServiceFailureError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteVirtualMFADeviceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteVirtualMFADeviceErrorKind::DeleteConflictError(_inner) => _inner.fmt(f),
            DeleteVirtualMFADeviceErrorKind::LimitExceededError(_inner) => _inner.fmt(f),
            DeleteVirtualMFADeviceErrorKind::NoSuchEntityError(_inner) => _inner.fmt(f),
            DeleteVirtualMFADeviceErrorKind::ServiceFailureError(_inner) => _inner.fmt(f),
            DeleteVirtualMFADeviceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteVirtualMFADeviceError {
    fn code(&self) -> Option<&str> {
        DeleteVirtualMFADeviceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteVirtualMFADeviceError {
    pub fn new(kind: DeleteVirtualMFADeviceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteVirtualMFADeviceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteVirtualMFADeviceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_delete_conflict_error(&self) -> bool {
        matches!(
            &self.kind,
            DeleteVirtualMFADeviceErrorKind::DeleteConflictError(_)
        )
    }
    pub fn is_limit_exceeded_error(&self) -> bool {
        matches!(
            &self.kind,
            DeleteVirtualMFADeviceErrorKind::LimitExceededError(_)
        )
    }
    pub fn is_no_such_entity_error(&self) -> bool {
        matches!(
            &self.kind,
            DeleteVirtualMFADeviceErrorKind::NoSuchEntityError(_)
        )
    }
    pub fn is_service_failure_error(&self) -> bool {
        matches!(
            &self.kind,
            DeleteVirtualMFADeviceErrorKind::ServiceFailureError(_)
        )
    }
}
impl std::error::Error for DeleteVirtualMFADeviceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteVirtualMFADeviceErrorKind::DeleteConflictError(_inner) => Some(_inner),
            DeleteVirtualMFADeviceErrorKind::LimitExceededError(_inner) => Some(_inner),
            DeleteVirtualMFADeviceErrorKind::NoSuchEntityError(_inner) => Some(_inner),
            DeleteVirtualMFADeviceErrorKind::ServiceFailureError(_inner) => Some(_inner),
            DeleteVirtualMFADeviceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DetachGroupPolicyError {
    pub kind: DetachGroupPolicyErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DetachGroupPolicyErrorKind {
    InvalidInputError(crate::error::InvalidInputError),
    LimitExceededError(crate::error::LimitExceededError),
    NoSuchEntityError(crate::error::NoSuchEntityError),
    ServiceFailureError(crate::error::ServiceFailureError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DetachGroupPolicyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DetachGroupPolicyErrorKind::InvalidInputError(_inner) => _inner.fmt(f),
            DetachGroupPolicyErrorKind::LimitExceededError(_inner) => _inner.fmt(f),
            DetachGroupPolicyErrorKind::NoSuchEntityError(_inner) => _inner.fmt(f),
            DetachGroupPolicyErrorKind::ServiceFailureError(_inner) => _inner.fmt(f),
            DetachGroupPolicyErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DetachGroupPolicyError {
    fn code(&self) -> Option<&str> {
        DetachGroupPolicyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DetachGroupPolicyError {
    pub fn new(kind: DetachGroupPolicyErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DetachGroupPolicyErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DetachGroupPolicyErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_input_error(&self) -> bool {
        matches!(&self.kind, DetachGroupPolicyErrorKind::InvalidInputError(_))
    }
    pub fn is_limit_exceeded_error(&self) -> bool {
        matches!(
            &self.kind,
            DetachGroupPolicyErrorKind::LimitExceededError(_)
        )
    }
    pub fn is_no_such_entity_error(&self) -> bool {
        matches!(&self.kind, DetachGroupPolicyErrorKind::NoSuchEntityError(_))
    }
    pub fn is_service_failure_error(&self) -> bool {
        matches!(
            &self.kind,
            DetachGroupPolicyErrorKind::ServiceFailureError(_)
        )
    }
}
impl std::error::Error for DetachGroupPolicyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DetachGroupPolicyErrorKind::InvalidInputError(_inner) => Some(_inner),
            DetachGroupPolicyErrorKind::LimitExceededError(_inner) => Some(_inner),
            DetachGroupPolicyErrorKind::NoSuchEntityError(_inner) => Some(_inner),
            DetachGroupPolicyErrorKind::ServiceFailureError(_inner) => Some(_inner),
            DetachGroupPolicyErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DetachRolePolicyError {
    pub kind: DetachRolePolicyErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DetachRolePolicyErrorKind {
    InvalidInputError(crate::error::InvalidInputError),
    LimitExceededError(crate::error::LimitExceededError),
    NoSuchEntityError(crate::error::NoSuchEntityError),
    ServiceFailureError(crate::error::ServiceFailureError),
    UnmodifiableEntityError(crate::error::UnmodifiableEntityError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DetachRolePolicyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DetachRolePolicyErrorKind::InvalidInputError(_inner) => _inner.fmt(f),
            DetachRolePolicyErrorKind::LimitExceededError(_inner) => _inner.fmt(f),
            DetachRolePolicyErrorKind::NoSuchEntityError(_inner) => _inner.fmt(f),
            DetachRolePolicyErrorKind::ServiceFailureError(_inner) => _inner.fmt(f),
            DetachRolePolicyErrorKind::UnmodifiableEntityError(_inner) => _inner.fmt(f),
            DetachRolePolicyErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DetachRolePolicyError {
    fn code(&self) -> Option<&str> {
        DetachRolePolicyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DetachRolePolicyError {
    pub fn new(kind: DetachRolePolicyErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DetachRolePolicyErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DetachRolePolicyErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_input_error(&self) -> bool {
        matches!(&self.kind, DetachRolePolicyErrorKind::InvalidInputError(_))
    }
    pub fn is_limit_exceeded_error(&self) -> bool {
        matches!(&self.kind, DetachRolePolicyErrorKind::LimitExceededError(_))
    }
    pub fn is_no_such_entity_error(&self) -> bool {
        matches!(&self.kind, DetachRolePolicyErrorKind::NoSuchEntityError(_))
    }
    pub fn is_service_failure_error(&self) -> bool {
        matches!(
            &self.kind,
            DetachRolePolicyErrorKind::ServiceFailureError(_)
        )
    }
    pub fn is_unmodifiable_entity_error(&self) -> bool {
        matches!(
            &self.kind,
            DetachRolePolicyErrorKind::UnmodifiableEntityError(_)
        )
    }
}
impl std::error::Error for DetachRolePolicyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DetachRolePolicyErrorKind::InvalidInputError(_inner) => Some(_inner),
            DetachRolePolicyErrorKind::LimitExceededError(_inner) => Some(_inner),
            DetachRolePolicyErrorKind::NoSuchEntityError(_inner) => Some(_inner),
            DetachRolePolicyErrorKind::ServiceFailureError(_inner) => Some(_inner),
            DetachRolePolicyErrorKind::UnmodifiableEntityError(_inner) => Some(_inner),
            DetachRolePolicyErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DetachUserPolicyError {
    pub kind: DetachUserPolicyErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DetachUserPolicyErrorKind {
    InvalidInputError(crate::error::InvalidInputError),
    LimitExceededError(crate::error::LimitExceededError),
    NoSuchEntityError(crate::error::NoSuchEntityError),
    ServiceFailureError(crate::error::ServiceFailureError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DetachUserPolicyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DetachUserPolicyErrorKind::InvalidInputError(_inner) => _inner.fmt(f),
            DetachUserPolicyErrorKind::LimitExceededError(_inner) => _inner.fmt(f),
            DetachUserPolicyErrorKind::NoSuchEntityError(_inner) => _inner.fmt(f),
            DetachUserPolicyErrorKind::ServiceFailureError(_inner) => _inner.fmt(f),
            DetachUserPolicyErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DetachUserPolicyError {
    fn code(&self) -> Option<&str> {
        DetachUserPolicyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DetachUserPolicyError {
    pub fn new(kind: DetachUserPolicyErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DetachUserPolicyErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DetachUserPolicyErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_input_error(&self) -> bool {
        matches!(&self.kind, DetachUserPolicyErrorKind::InvalidInputError(_))
    }
    pub fn is_limit_exceeded_error(&self) -> bool {
        matches!(&self.kind, DetachUserPolicyErrorKind::LimitExceededError(_))
    }
    pub fn is_no_such_entity_error(&self) -> bool {
        matches!(&self.kind, DetachUserPolicyErrorKind::NoSuchEntityError(_))
    }
    pub fn is_service_failure_error(&self) -> bool {
        matches!(
            &self.kind,
            DetachUserPolicyErrorKind::ServiceFailureError(_)
        )
    }
}
impl std::error::Error for DetachUserPolicyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DetachUserPolicyErrorKind::InvalidInputError(_inner) => Some(_inner),
            DetachUserPolicyErrorKind::LimitExceededError(_inner) => Some(_inner),
            DetachUserPolicyErrorKind::NoSuchEntityError(_inner) => Some(_inner),
            DetachUserPolicyErrorKind::ServiceFailureError(_inner) => Some(_inner),
            DetachUserPolicyErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct EnableMFADeviceError {
    pub kind: EnableMFADeviceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum EnableMFADeviceErrorKind {
    EntityAlreadyExistsError(crate::error::EntityAlreadyExistsError),
    EntityTemporarilyUnmodifiableError(crate::error::EntityTemporarilyUnmodifiableError),
    InvalidAuthenticationCodeError(crate::error::InvalidAuthenticationCodeError),
    LimitExceededError(crate::error::LimitExceededError),
    NoSuchEntityError(crate::error::NoSuchEntityError),
    ServiceFailureError(crate::error::ServiceFailureError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for EnableMFADeviceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            EnableMFADeviceErrorKind::EntityAlreadyExistsError(_inner) => _inner.fmt(f),
            EnableMFADeviceErrorKind::EntityTemporarilyUnmodifiableError(_inner) => _inner.fmt(f),
            EnableMFADeviceErrorKind::InvalidAuthenticationCodeError(_inner) => _inner.fmt(f),
            EnableMFADeviceErrorKind::LimitExceededError(_inner) => _inner.fmt(f),
            EnableMFADeviceErrorKind::NoSuchEntityError(_inner) => _inner.fmt(f),
            EnableMFADeviceErrorKind::ServiceFailureError(_inner) => _inner.fmt(f),
            EnableMFADeviceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for EnableMFADeviceError {
    fn code(&self) -> Option<&str> {
        EnableMFADeviceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl EnableMFADeviceError {
    pub fn new(kind: EnableMFADeviceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: EnableMFADeviceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: EnableMFADeviceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_entity_already_exists_error(&self) -> bool {
        matches!(
            &self.kind,
            EnableMFADeviceErrorKind::EntityAlreadyExistsError(_)
        )
    }
    pub fn is_entity_temporarily_unmodifiable_error(&self) -> bool {
        matches!(
            &self.kind,
            EnableMFADeviceErrorKind::EntityTemporarilyUnmodifiableError(_)
        )
    }
    pub fn is_invalid_authentication_code_error(&self) -> bool {
        matches!(
            &self.kind,
            EnableMFADeviceErrorKind::InvalidAuthenticationCodeError(_)
        )
    }
    pub fn is_limit_exceeded_error(&self) -> bool {
        matches!(&self.kind, EnableMFADeviceErrorKind::LimitExceededError(_))
    }
    pub fn is_no_such_entity_error(&self) -> bool {
        matches!(&self.kind, EnableMFADeviceErrorKind::NoSuchEntityError(_))
    }
    pub fn is_service_failure_error(&self) -> bool {
        matches!(&self.kind, EnableMFADeviceErrorKind::ServiceFailureError(_))
    }
}
impl std::error::Error for EnableMFADeviceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            EnableMFADeviceErrorKind::EntityAlreadyExistsError(_inner) => Some(_inner),
            EnableMFADeviceErrorKind::EntityTemporarilyUnmodifiableError(_inner) => Some(_inner),
            EnableMFADeviceErrorKind::InvalidAuthenticationCodeError(_inner) => Some(_inner),
            EnableMFADeviceErrorKind::LimitExceededError(_inner) => Some(_inner),
            EnableMFADeviceErrorKind::NoSuchEntityError(_inner) => Some(_inner),
            EnableMFADeviceErrorKind::ServiceFailureError(_inner) => Some(_inner),
            EnableMFADeviceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GenerateCredentialReportError {
    pub kind: GenerateCredentialReportErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GenerateCredentialReportErrorKind {
    LimitExceededError(crate::error::LimitExceededError),
    ServiceFailureError(crate::error::ServiceFailureError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GenerateCredentialReportError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GenerateCredentialReportErrorKind::LimitExceededError(_inner) => _inner.fmt(f),
            GenerateCredentialReportErrorKind::ServiceFailureError(_inner) => _inner.fmt(f),
            GenerateCredentialReportErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GenerateCredentialReportError {
    fn code(&self) -> Option<&str> {
        GenerateCredentialReportError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GenerateCredentialReportError {
    pub fn new(kind: GenerateCredentialReportErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GenerateCredentialReportErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GenerateCredentialReportErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_limit_exceeded_error(&self) -> bool {
        matches!(
            &self.kind,
            GenerateCredentialReportErrorKind::LimitExceededError(_)
        )
    }
    pub fn is_service_failure_error(&self) -> bool {
        matches!(
            &self.kind,
            GenerateCredentialReportErrorKind::ServiceFailureError(_)
        )
    }
}
impl std::error::Error for GenerateCredentialReportError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GenerateCredentialReportErrorKind::LimitExceededError(_inner) => Some(_inner),
            GenerateCredentialReportErrorKind::ServiceFailureError(_inner) => Some(_inner),
            GenerateCredentialReportErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GenerateOrganizationsAccessReportError {
    pub kind: GenerateOrganizationsAccessReportErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GenerateOrganizationsAccessReportErrorKind {
    ReportGenerationLimitExceededError(crate::error::ReportGenerationLimitExceededError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GenerateOrganizationsAccessReportError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GenerateOrganizationsAccessReportErrorKind::ReportGenerationLimitExceededError(
                _inner,
            ) => _inner.fmt(f),
            GenerateOrganizationsAccessReportErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GenerateOrganizationsAccessReportError {
    fn code(&self) -> Option<&str> {
        GenerateOrganizationsAccessReportError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GenerateOrganizationsAccessReportError {
    pub fn new(
        kind: GenerateOrganizationsAccessReportErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GenerateOrganizationsAccessReportErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GenerateOrganizationsAccessReportErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_report_generation_limit_exceeded_error(&self) -> bool {
        matches!(
            &self.kind,
            GenerateOrganizationsAccessReportErrorKind::ReportGenerationLimitExceededError(_)
        )
    }
}
impl std::error::Error for GenerateOrganizationsAccessReportError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GenerateOrganizationsAccessReportErrorKind::ReportGenerationLimitExceededError(
                _inner,
            ) => Some(_inner),
            GenerateOrganizationsAccessReportErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GenerateServiceLastAccessedDetailsError {
    pub kind: GenerateServiceLastAccessedDetailsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GenerateServiceLastAccessedDetailsErrorKind {
    InvalidInputError(crate::error::InvalidInputError),
    NoSuchEntityError(crate::error::NoSuchEntityError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GenerateServiceLastAccessedDetailsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GenerateServiceLastAccessedDetailsErrorKind::InvalidInputError(_inner) => _inner.fmt(f),
            GenerateServiceLastAccessedDetailsErrorKind::NoSuchEntityError(_inner) => _inner.fmt(f),
            GenerateServiceLastAccessedDetailsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GenerateServiceLastAccessedDetailsError {
    fn code(&self) -> Option<&str> {
        GenerateServiceLastAccessedDetailsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GenerateServiceLastAccessedDetailsError {
    pub fn new(
        kind: GenerateServiceLastAccessedDetailsErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GenerateServiceLastAccessedDetailsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GenerateServiceLastAccessedDetailsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_input_error(&self) -> bool {
        matches!(
            &self.kind,
            GenerateServiceLastAccessedDetailsErrorKind::InvalidInputError(_)
        )
    }
    pub fn is_no_such_entity_error(&self) -> bool {
        matches!(
            &self.kind,
            GenerateServiceLastAccessedDetailsErrorKind::NoSuchEntityError(_)
        )
    }
}
impl std::error::Error for GenerateServiceLastAccessedDetailsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GenerateServiceLastAccessedDetailsErrorKind::InvalidInputError(_inner) => Some(_inner),
            GenerateServiceLastAccessedDetailsErrorKind::NoSuchEntityError(_inner) => Some(_inner),
            GenerateServiceLastAccessedDetailsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetAccessKeyLastUsedError {
    pub kind: GetAccessKeyLastUsedErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetAccessKeyLastUsedErrorKind {
    NoSuchEntityError(crate::error::NoSuchEntityError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetAccessKeyLastUsedError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetAccessKeyLastUsedErrorKind::NoSuchEntityError(_inner) => _inner.fmt(f),
            GetAccessKeyLastUsedErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetAccessKeyLastUsedError {
    fn code(&self) -> Option<&str> {
        GetAccessKeyLastUsedError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetAccessKeyLastUsedError {
    pub fn new(kind: GetAccessKeyLastUsedErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetAccessKeyLastUsedErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetAccessKeyLastUsedErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_no_such_entity_error(&self) -> bool {
        matches!(
            &self.kind,
            GetAccessKeyLastUsedErrorKind::NoSuchEntityError(_)
        )
    }
}
impl std::error::Error for GetAccessKeyLastUsedError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetAccessKeyLastUsedErrorKind::NoSuchEntityError(_inner) => Some(_inner),
            GetAccessKeyLastUsedErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetAccountAuthorizationDetailsError {
    pub kind: GetAccountAuthorizationDetailsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetAccountAuthorizationDetailsErrorKind {
    ServiceFailureError(crate::error::ServiceFailureError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetAccountAuthorizationDetailsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetAccountAuthorizationDetailsErrorKind::ServiceFailureError(_inner) => _inner.fmt(f),
            GetAccountAuthorizationDetailsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetAccountAuthorizationDetailsError {
    fn code(&self) -> Option<&str> {
        GetAccountAuthorizationDetailsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetAccountAuthorizationDetailsError {
    pub fn new(kind: GetAccountAuthorizationDetailsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetAccountAuthorizationDetailsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetAccountAuthorizationDetailsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_service_failure_error(&self) -> bool {
        matches!(
            &self.kind,
            GetAccountAuthorizationDetailsErrorKind::ServiceFailureError(_)
        )
    }
}
impl std::error::Error for GetAccountAuthorizationDetailsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetAccountAuthorizationDetailsErrorKind::ServiceFailureError(_inner) => Some(_inner),
            GetAccountAuthorizationDetailsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetAccountPasswordPolicyError {
    pub kind: GetAccountPasswordPolicyErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetAccountPasswordPolicyErrorKind {
    NoSuchEntityError(crate::error::NoSuchEntityError),
    ServiceFailureError(crate::error::ServiceFailureError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetAccountPasswordPolicyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetAccountPasswordPolicyErrorKind::NoSuchEntityError(_inner) => _inner.fmt(f),
            GetAccountPasswordPolicyErrorKind::ServiceFailureError(_inner) => _inner.fmt(f),
            GetAccountPasswordPolicyErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetAccountPasswordPolicyError {
    fn code(&self) -> Option<&str> {
        GetAccountPasswordPolicyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetAccountPasswordPolicyError {
    pub fn new(kind: GetAccountPasswordPolicyErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetAccountPasswordPolicyErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetAccountPasswordPolicyErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_no_such_entity_error(&self) -> bool {
        matches!(
            &self.kind,
            GetAccountPasswordPolicyErrorKind::NoSuchEntityError(_)
        )
    }
    pub fn is_service_failure_error(&self) -> bool {
        matches!(
            &self.kind,
            GetAccountPasswordPolicyErrorKind::ServiceFailureError(_)
        )
    }
}
impl std::error::Error for GetAccountPasswordPolicyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetAccountPasswordPolicyErrorKind::NoSuchEntityError(_inner) => Some(_inner),
            GetAccountPasswordPolicyErrorKind::ServiceFailureError(_inner) => Some(_inner),
            GetAccountPasswordPolicyErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetAccountSummaryError {
    pub kind: GetAccountSummaryErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetAccountSummaryErrorKind {
    ServiceFailureError(crate::error::ServiceFailureError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetAccountSummaryError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetAccountSummaryErrorKind::ServiceFailureError(_inner) => _inner.fmt(f),
            GetAccountSummaryErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetAccountSummaryError {
    fn code(&self) -> Option<&str> {
        GetAccountSummaryError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetAccountSummaryError {
    pub fn new(kind: GetAccountSummaryErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetAccountSummaryErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetAccountSummaryErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_service_failure_error(&self) -> bool {
        matches!(
            &self.kind,
            GetAccountSummaryErrorKind::ServiceFailureError(_)
        )
    }
}
impl std::error::Error for GetAccountSummaryError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetAccountSummaryErrorKind::ServiceFailureError(_inner) => Some(_inner),
            GetAccountSummaryErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetContextKeysForCustomPolicyError {
    pub kind: GetContextKeysForCustomPolicyErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetContextKeysForCustomPolicyErrorKind {
    InvalidInputError(crate::error::InvalidInputError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetContextKeysForCustomPolicyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetContextKeysForCustomPolicyErrorKind::InvalidInputError(_inner) => _inner.fmt(f),
            GetContextKeysForCustomPolicyErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetContextKeysForCustomPolicyError {
    fn code(&self) -> Option<&str> {
        GetContextKeysForCustomPolicyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetContextKeysForCustomPolicyError {
    pub fn new(kind: GetContextKeysForCustomPolicyErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetContextKeysForCustomPolicyErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetContextKeysForCustomPolicyErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_input_error(&self) -> bool {
        matches!(
            &self.kind,
            GetContextKeysForCustomPolicyErrorKind::InvalidInputError(_)
        )
    }
}
impl std::error::Error for GetContextKeysForCustomPolicyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetContextKeysForCustomPolicyErrorKind::InvalidInputError(_inner) => Some(_inner),
            GetContextKeysForCustomPolicyErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetContextKeysForPrincipalPolicyError {
    pub kind: GetContextKeysForPrincipalPolicyErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetContextKeysForPrincipalPolicyErrorKind {
    InvalidInputError(crate::error::InvalidInputError),
    NoSuchEntityError(crate::error::NoSuchEntityError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetContextKeysForPrincipalPolicyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetContextKeysForPrincipalPolicyErrorKind::InvalidInputError(_inner) => _inner.fmt(f),
            GetContextKeysForPrincipalPolicyErrorKind::NoSuchEntityError(_inner) => _inner.fmt(f),
            GetContextKeysForPrincipalPolicyErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetContextKeysForPrincipalPolicyError {
    fn code(&self) -> Option<&str> {
        GetContextKeysForPrincipalPolicyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetContextKeysForPrincipalPolicyError {
    pub fn new(kind: GetContextKeysForPrincipalPolicyErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetContextKeysForPrincipalPolicyErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetContextKeysForPrincipalPolicyErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_input_error(&self) -> bool {
        matches!(
            &self.kind,
            GetContextKeysForPrincipalPolicyErrorKind::InvalidInputError(_)
        )
    }
    pub fn is_no_such_entity_error(&self) -> bool {
        matches!(
            &self.kind,
            GetContextKeysForPrincipalPolicyErrorKind::NoSuchEntityError(_)
        )
    }
}
impl std::error::Error for GetContextKeysForPrincipalPolicyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetContextKeysForPrincipalPolicyErrorKind::InvalidInputError(_inner) => Some(_inner),
            GetContextKeysForPrincipalPolicyErrorKind::NoSuchEntityError(_inner) => Some(_inner),
            GetContextKeysForPrincipalPolicyErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetCredentialReportError {
    pub kind: GetCredentialReportErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetCredentialReportErrorKind {
    CredentialReportExpiredError(crate::error::CredentialReportExpiredError),
    CredentialReportNotPresentError(crate::error::CredentialReportNotPresentError),
    CredentialReportNotReadyError(crate::error::CredentialReportNotReadyError),
    ServiceFailureError(crate::error::ServiceFailureError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetCredentialReportError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetCredentialReportErrorKind::CredentialReportExpiredError(_inner) => _inner.fmt(f),
            GetCredentialReportErrorKind::CredentialReportNotPresentError(_inner) => _inner.fmt(f),
            GetCredentialReportErrorKind::CredentialReportNotReadyError(_inner) => _inner.fmt(f),
            GetCredentialReportErrorKind::ServiceFailureError(_inner) => _inner.fmt(f),
            GetCredentialReportErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetCredentialReportError {
    fn code(&self) -> Option<&str> {
        GetCredentialReportError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetCredentialReportError {
    pub fn new(kind: GetCredentialReportErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetCredentialReportErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetCredentialReportErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_credential_report_expired_error(&self) -> bool {
        matches!(
            &self.kind,
            GetCredentialReportErrorKind::CredentialReportExpiredError(_)
        )
    }
    pub fn is_credential_report_not_present_error(&self) -> bool {
        matches!(
            &self.kind,
            GetCredentialReportErrorKind::CredentialReportNotPresentError(_)
        )
    }
    pub fn is_credential_report_not_ready_error(&self) -> bool {
        matches!(
            &self.kind,
            GetCredentialReportErrorKind::CredentialReportNotReadyError(_)
        )
    }
    pub fn is_service_failure_error(&self) -> bool {
        matches!(
            &self.kind,
            GetCredentialReportErrorKind::ServiceFailureError(_)
        )
    }
}
impl std::error::Error for GetCredentialReportError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetCredentialReportErrorKind::CredentialReportExpiredError(_inner) => Some(_inner),
            GetCredentialReportErrorKind::CredentialReportNotPresentError(_inner) => Some(_inner),
            GetCredentialReportErrorKind::CredentialReportNotReadyError(_inner) => Some(_inner),
            GetCredentialReportErrorKind::ServiceFailureError(_inner) => Some(_inner),
            GetCredentialReportErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetGroupError {
    pub kind: GetGroupErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetGroupErrorKind {
    NoSuchEntityError(crate::error::NoSuchEntityError),
    ServiceFailureError(crate::error::ServiceFailureError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetGroupError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetGroupErrorKind::NoSuchEntityError(_inner) => _inner.fmt(f),
            GetGroupErrorKind::ServiceFailureError(_inner) => _inner.fmt(f),
            GetGroupErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetGroupError {
    fn code(&self) -> Option<&str> {
        GetGroupError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetGroupError {
    pub fn new(kind: GetGroupErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetGroupErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetGroupErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_no_such_entity_error(&self) -> bool {
        matches!(&self.kind, GetGroupErrorKind::NoSuchEntityError(_))
    }
    pub fn is_service_failure_error(&self) -> bool {
        matches!(&self.kind, GetGroupErrorKind::ServiceFailureError(_))
    }
}
impl std::error::Error for GetGroupError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetGroupErrorKind::NoSuchEntityError(_inner) => Some(_inner),
            GetGroupErrorKind::ServiceFailureError(_inner) => Some(_inner),
            GetGroupErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetGroupPolicyError {
    pub kind: GetGroupPolicyErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetGroupPolicyErrorKind {
    NoSuchEntityError(crate::error::NoSuchEntityError),
    ServiceFailureError(crate::error::ServiceFailureError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetGroupPolicyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetGroupPolicyErrorKind::NoSuchEntityError(_inner) => _inner.fmt(f),
            GetGroupPolicyErrorKind::ServiceFailureError(_inner) => _inner.fmt(f),
            GetGroupPolicyErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetGroupPolicyError {
    fn code(&self) -> Option<&str> {
        GetGroupPolicyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetGroupPolicyError {
    pub fn new(kind: GetGroupPolicyErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetGroupPolicyErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetGroupPolicyErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_no_such_entity_error(&self) -> bool {
        matches!(&self.kind, GetGroupPolicyErrorKind::NoSuchEntityError(_))
    }
    pub fn is_service_failure_error(&self) -> bool {
        matches!(&self.kind, GetGroupPolicyErrorKind::ServiceFailureError(_))
    }
}
impl std::error::Error for GetGroupPolicyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetGroupPolicyErrorKind::NoSuchEntityError(_inner) => Some(_inner),
            GetGroupPolicyErrorKind::ServiceFailureError(_inner) => Some(_inner),
            GetGroupPolicyErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetInstanceProfileError {
    pub kind: GetInstanceProfileErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetInstanceProfileErrorKind {
    NoSuchEntityError(crate::error::NoSuchEntityError),
    ServiceFailureError(crate::error::ServiceFailureError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetInstanceProfileError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetInstanceProfileErrorKind::NoSuchEntityError(_inner) => _inner.fmt(f),
            GetInstanceProfileErrorKind::ServiceFailureError(_inner) => _inner.fmt(f),
            GetInstanceProfileErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetInstanceProfileError {
    fn code(&self) -> Option<&str> {
        GetInstanceProfileError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetInstanceProfileError {
    pub fn new(kind: GetInstanceProfileErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetInstanceProfileErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetInstanceProfileErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_no_such_entity_error(&self) -> bool {
        matches!(
            &self.kind,
            GetInstanceProfileErrorKind::NoSuchEntityError(_)
        )
    }
    pub fn is_service_failure_error(&self) -> bool {
        matches!(
            &self.kind,
            GetInstanceProfileErrorKind::ServiceFailureError(_)
        )
    }
}
impl std::error::Error for GetInstanceProfileError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetInstanceProfileErrorKind::NoSuchEntityError(_inner) => Some(_inner),
            GetInstanceProfileErrorKind::ServiceFailureError(_inner) => Some(_inner),
            GetInstanceProfileErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetLoginProfileError {
    pub kind: GetLoginProfileErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetLoginProfileErrorKind {
    NoSuchEntityError(crate::error::NoSuchEntityError),
    ServiceFailureError(crate::error::ServiceFailureError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetLoginProfileError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetLoginProfileErrorKind::NoSuchEntityError(_inner) => _inner.fmt(f),
            GetLoginProfileErrorKind::ServiceFailureError(_inner) => _inner.fmt(f),
            GetLoginProfileErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetLoginProfileError {
    fn code(&self) -> Option<&str> {
        GetLoginProfileError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetLoginProfileError {
    pub fn new(kind: GetLoginProfileErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetLoginProfileErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetLoginProfileErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_no_such_entity_error(&self) -> bool {
        matches!(&self.kind, GetLoginProfileErrorKind::NoSuchEntityError(_))
    }
    pub fn is_service_failure_error(&self) -> bool {
        matches!(&self.kind, GetLoginProfileErrorKind::ServiceFailureError(_))
    }
}
impl std::error::Error for GetLoginProfileError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetLoginProfileErrorKind::NoSuchEntityError(_inner) => Some(_inner),
            GetLoginProfileErrorKind::ServiceFailureError(_inner) => Some(_inner),
            GetLoginProfileErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetOpenIDConnectProviderError {
    pub kind: GetOpenIDConnectProviderErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetOpenIDConnectProviderErrorKind {
    InvalidInputError(crate::error::InvalidInputError),
    NoSuchEntityError(crate::error::NoSuchEntityError),
    ServiceFailureError(crate::error::ServiceFailureError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetOpenIDConnectProviderError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetOpenIDConnectProviderErrorKind::InvalidInputError(_inner) => _inner.fmt(f),
            GetOpenIDConnectProviderErrorKind::NoSuchEntityError(_inner) => _inner.fmt(f),
            GetOpenIDConnectProviderErrorKind::ServiceFailureError(_inner) => _inner.fmt(f),
            GetOpenIDConnectProviderErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetOpenIDConnectProviderError {
    fn code(&self) -> Option<&str> {
        GetOpenIDConnectProviderError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetOpenIDConnectProviderError {
    pub fn new(kind: GetOpenIDConnectProviderErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetOpenIDConnectProviderErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetOpenIDConnectProviderErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_input_error(&self) -> bool {
        matches!(
            &self.kind,
            GetOpenIDConnectProviderErrorKind::InvalidInputError(_)
        )
    }
    pub fn is_no_such_entity_error(&self) -> bool {
        matches!(
            &self.kind,
            GetOpenIDConnectProviderErrorKind::NoSuchEntityError(_)
        )
    }
    pub fn is_service_failure_error(&self) -> bool {
        matches!(
            &self.kind,
            GetOpenIDConnectProviderErrorKind::ServiceFailureError(_)
        )
    }
}
impl std::error::Error for GetOpenIDConnectProviderError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetOpenIDConnectProviderErrorKind::InvalidInputError(_inner) => Some(_inner),
            GetOpenIDConnectProviderErrorKind::NoSuchEntityError(_inner) => Some(_inner),
            GetOpenIDConnectProviderErrorKind::ServiceFailureError(_inner) => Some(_inner),
            GetOpenIDConnectProviderErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetOrganizationsAccessReportError {
    pub kind: GetOrganizationsAccessReportErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetOrganizationsAccessReportErrorKind {
    NoSuchEntityError(crate::error::NoSuchEntityError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetOrganizationsAccessReportError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetOrganizationsAccessReportErrorKind::NoSuchEntityError(_inner) => _inner.fmt(f),
            GetOrganizationsAccessReportErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetOrganizationsAccessReportError {
    fn code(&self) -> Option<&str> {
        GetOrganizationsAccessReportError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetOrganizationsAccessReportError {
    pub fn new(kind: GetOrganizationsAccessReportErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetOrganizationsAccessReportErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetOrganizationsAccessReportErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_no_such_entity_error(&self) -> bool {
        matches!(
            &self.kind,
            GetOrganizationsAccessReportErrorKind::NoSuchEntityError(_)
        )
    }
}
impl std::error::Error for GetOrganizationsAccessReportError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetOrganizationsAccessReportErrorKind::NoSuchEntityError(_inner) => Some(_inner),
            GetOrganizationsAccessReportErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetPolicyError {
    pub kind: GetPolicyErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetPolicyErrorKind {
    InvalidInputError(crate::error::InvalidInputError),
    NoSuchEntityError(crate::error::NoSuchEntityError),
    ServiceFailureError(crate::error::ServiceFailureError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetPolicyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetPolicyErrorKind::InvalidInputError(_inner) => _inner.fmt(f),
            GetPolicyErrorKind::NoSuchEntityError(_inner) => _inner.fmt(f),
            GetPolicyErrorKind::ServiceFailureError(_inner) => _inner.fmt(f),
            GetPolicyErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetPolicyError {
    fn code(&self) -> Option<&str> {
        GetPolicyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetPolicyError {
    pub fn new(kind: GetPolicyErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetPolicyErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetPolicyErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_input_error(&self) -> bool {
        matches!(&self.kind, GetPolicyErrorKind::InvalidInputError(_))
    }
    pub fn is_no_such_entity_error(&self) -> bool {
        matches!(&self.kind, GetPolicyErrorKind::NoSuchEntityError(_))
    }
    pub fn is_service_failure_error(&self) -> bool {
        matches!(&self.kind, GetPolicyErrorKind::ServiceFailureError(_))
    }
}
impl std::error::Error for GetPolicyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetPolicyErrorKind::InvalidInputError(_inner) => Some(_inner),
            GetPolicyErrorKind::NoSuchEntityError(_inner) => Some(_inner),
            GetPolicyErrorKind::ServiceFailureError(_inner) => Some(_inner),
            GetPolicyErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetPolicyVersionError {
    pub kind: GetPolicyVersionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetPolicyVersionErrorKind {
    InvalidInputError(crate::error::InvalidInputError),
    NoSuchEntityError(crate::error::NoSuchEntityError),
    ServiceFailureError(crate::error::ServiceFailureError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetPolicyVersionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetPolicyVersionErrorKind::InvalidInputError(_inner) => _inner.fmt(f),
            GetPolicyVersionErrorKind::NoSuchEntityError(_inner) => _inner.fmt(f),
            GetPolicyVersionErrorKind::ServiceFailureError(_inner) => _inner.fmt(f),
            GetPolicyVersionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetPolicyVersionError {
    fn code(&self) -> Option<&str> {
        GetPolicyVersionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetPolicyVersionError {
    pub fn new(kind: GetPolicyVersionErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetPolicyVersionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetPolicyVersionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_input_error(&self) -> bool {
        matches!(&self.kind, GetPolicyVersionErrorKind::InvalidInputError(_))
    }
    pub fn is_no_such_entity_error(&self) -> bool {
        matches!(&self.kind, GetPolicyVersionErrorKind::NoSuchEntityError(_))
    }
    pub fn is_service_failure_error(&self) -> bool {
        matches!(
            &self.kind,
            GetPolicyVersionErrorKind::ServiceFailureError(_)
        )
    }
}
impl std::error::Error for GetPolicyVersionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetPolicyVersionErrorKind::InvalidInputError(_inner) => Some(_inner),
            GetPolicyVersionErrorKind::NoSuchEntityError(_inner) => Some(_inner),
            GetPolicyVersionErrorKind::ServiceFailureError(_inner) => Some(_inner),
            GetPolicyVersionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetRoleError {
    pub kind: GetRoleErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetRoleErrorKind {
    NoSuchEntityError(crate::error::NoSuchEntityError),
    ServiceFailureError(crate::error::ServiceFailureError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetRoleError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetRoleErrorKind::NoSuchEntityError(_inner) => _inner.fmt(f),
            GetRoleErrorKind::ServiceFailureError(_inner) => _inner.fmt(f),
            GetRoleErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetRoleError {
    fn code(&self) -> Option<&str> {
        GetRoleError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetRoleError {
    pub fn new(kind: GetRoleErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetRoleErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetRoleErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_no_such_entity_error(&self) -> bool {
        matches!(&self.kind, GetRoleErrorKind::NoSuchEntityError(_))
    }
    pub fn is_service_failure_error(&self) -> bool {
        matches!(&self.kind, GetRoleErrorKind::ServiceFailureError(_))
    }
}
impl std::error::Error for GetRoleError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetRoleErrorKind::NoSuchEntityError(_inner) => Some(_inner),
            GetRoleErrorKind::ServiceFailureError(_inner) => Some(_inner),
            GetRoleErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetRolePolicyError {
    pub kind: GetRolePolicyErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetRolePolicyErrorKind {
    NoSuchEntityError(crate::error::NoSuchEntityError),
    ServiceFailureError(crate::error::ServiceFailureError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetRolePolicyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetRolePolicyErrorKind::NoSuchEntityError(_inner) => _inner.fmt(f),
            GetRolePolicyErrorKind::ServiceFailureError(_inner) => _inner.fmt(f),
            GetRolePolicyErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetRolePolicyError {
    fn code(&self) -> Option<&str> {
        GetRolePolicyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetRolePolicyError {
    pub fn new(kind: GetRolePolicyErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetRolePolicyErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetRolePolicyErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_no_such_entity_error(&self) -> bool {
        matches!(&self.kind, GetRolePolicyErrorKind::NoSuchEntityError(_))
    }
    pub fn is_service_failure_error(&self) -> bool {
        matches!(&self.kind, GetRolePolicyErrorKind::ServiceFailureError(_))
    }
}
impl std::error::Error for GetRolePolicyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetRolePolicyErrorKind::NoSuchEntityError(_inner) => Some(_inner),
            GetRolePolicyErrorKind::ServiceFailureError(_inner) => Some(_inner),
            GetRolePolicyErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetSAMLProviderError {
    pub kind: GetSAMLProviderErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetSAMLProviderErrorKind {
    InvalidInputError(crate::error::InvalidInputError),
    NoSuchEntityError(crate::error::NoSuchEntityError),
    ServiceFailureError(crate::error::ServiceFailureError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetSAMLProviderError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetSAMLProviderErrorKind::InvalidInputError(_inner) => _inner.fmt(f),
            GetSAMLProviderErrorKind::NoSuchEntityError(_inner) => _inner.fmt(f),
            GetSAMLProviderErrorKind::ServiceFailureError(_inner) => _inner.fmt(f),
            GetSAMLProviderErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetSAMLProviderError {
    fn code(&self) -> Option<&str> {
        GetSAMLProviderError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetSAMLProviderError {
    pub fn new(kind: GetSAMLProviderErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetSAMLProviderErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetSAMLProviderErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_input_error(&self) -> bool {
        matches!(&self.kind, GetSAMLProviderErrorKind::InvalidInputError(_))
    }
    pub fn is_no_such_entity_error(&self) -> bool {
        matches!(&self.kind, GetSAMLProviderErrorKind::NoSuchEntityError(_))
    }
    pub fn is_service_failure_error(&self) -> bool {
        matches!(&self.kind, GetSAMLProviderErrorKind::ServiceFailureError(_))
    }
}
impl std::error::Error for GetSAMLProviderError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetSAMLProviderErrorKind::InvalidInputError(_inner) => Some(_inner),
            GetSAMLProviderErrorKind::NoSuchEntityError(_inner) => Some(_inner),
            GetSAMLProviderErrorKind::ServiceFailureError(_inner) => Some(_inner),
            GetSAMLProviderErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetServerCertificateError {
    pub kind: GetServerCertificateErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetServerCertificateErrorKind {
    NoSuchEntityError(crate::error::NoSuchEntityError),
    ServiceFailureError(crate::error::ServiceFailureError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetServerCertificateError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetServerCertificateErrorKind::NoSuchEntityError(_inner) => _inner.fmt(f),
            GetServerCertificateErrorKind::ServiceFailureError(_inner) => _inner.fmt(f),
            GetServerCertificateErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetServerCertificateError {
    fn code(&self) -> Option<&str> {
        GetServerCertificateError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetServerCertificateError {
    pub fn new(kind: GetServerCertificateErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetServerCertificateErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetServerCertificateErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_no_such_entity_error(&self) -> bool {
        matches!(
            &self.kind,
            GetServerCertificateErrorKind::NoSuchEntityError(_)
        )
    }
    pub fn is_service_failure_error(&self) -> bool {
        matches!(
            &self.kind,
            GetServerCertificateErrorKind::ServiceFailureError(_)
        )
    }
}
impl std::error::Error for GetServerCertificateError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetServerCertificateErrorKind::NoSuchEntityError(_inner) => Some(_inner),
            GetServerCertificateErrorKind::ServiceFailureError(_inner) => Some(_inner),
            GetServerCertificateErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetServiceLastAccessedDetailsError {
    pub kind: GetServiceLastAccessedDetailsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetServiceLastAccessedDetailsErrorKind {
    InvalidInputError(crate::error::InvalidInputError),
    NoSuchEntityError(crate::error::NoSuchEntityError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetServiceLastAccessedDetailsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetServiceLastAccessedDetailsErrorKind::InvalidInputError(_inner) => _inner.fmt(f),
            GetServiceLastAccessedDetailsErrorKind::NoSuchEntityError(_inner) => _inner.fmt(f),
            GetServiceLastAccessedDetailsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetServiceLastAccessedDetailsError {
    fn code(&self) -> Option<&str> {
        GetServiceLastAccessedDetailsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetServiceLastAccessedDetailsError {
    pub fn new(kind: GetServiceLastAccessedDetailsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetServiceLastAccessedDetailsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetServiceLastAccessedDetailsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_input_error(&self) -> bool {
        matches!(
            &self.kind,
            GetServiceLastAccessedDetailsErrorKind::InvalidInputError(_)
        )
    }
    pub fn is_no_such_entity_error(&self) -> bool {
        matches!(
            &self.kind,
            GetServiceLastAccessedDetailsErrorKind::NoSuchEntityError(_)
        )
    }
}
impl std::error::Error for GetServiceLastAccessedDetailsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetServiceLastAccessedDetailsErrorKind::InvalidInputError(_inner) => Some(_inner),
            GetServiceLastAccessedDetailsErrorKind::NoSuchEntityError(_inner) => Some(_inner),
            GetServiceLastAccessedDetailsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetServiceLastAccessedDetailsWithEntitiesError {
    pub kind: GetServiceLastAccessedDetailsWithEntitiesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetServiceLastAccessedDetailsWithEntitiesErrorKind {
    InvalidInputError(crate::error::InvalidInputError),
    NoSuchEntityError(crate::error::NoSuchEntityError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetServiceLastAccessedDetailsWithEntitiesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetServiceLastAccessedDetailsWithEntitiesErrorKind::InvalidInputError(_inner) => {
                _inner.fmt(f)
            }
            GetServiceLastAccessedDetailsWithEntitiesErrorKind::NoSuchEntityError(_inner) => {
                _inner.fmt(f)
            }
            GetServiceLastAccessedDetailsWithEntitiesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetServiceLastAccessedDetailsWithEntitiesError {
    fn code(&self) -> Option<&str> {
        GetServiceLastAccessedDetailsWithEntitiesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetServiceLastAccessedDetailsWithEntitiesError {
    pub fn new(
        kind: GetServiceLastAccessedDetailsWithEntitiesErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetServiceLastAccessedDetailsWithEntitiesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetServiceLastAccessedDetailsWithEntitiesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_input_error(&self) -> bool {
        matches!(
            &self.kind,
            GetServiceLastAccessedDetailsWithEntitiesErrorKind::InvalidInputError(_)
        )
    }
    pub fn is_no_such_entity_error(&self) -> bool {
        matches!(
            &self.kind,
            GetServiceLastAccessedDetailsWithEntitiesErrorKind::NoSuchEntityError(_)
        )
    }
}
impl std::error::Error for GetServiceLastAccessedDetailsWithEntitiesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetServiceLastAccessedDetailsWithEntitiesErrorKind::InvalidInputError(_inner) => {
                Some(_inner)
            }
            GetServiceLastAccessedDetailsWithEntitiesErrorKind::NoSuchEntityError(_inner) => {
                Some(_inner)
            }
            GetServiceLastAccessedDetailsWithEntitiesErrorKind::Unhandled(_inner) => {
                Some(_inner.as_ref())
            }
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetServiceLinkedRoleDeletionStatusError {
    pub kind: GetServiceLinkedRoleDeletionStatusErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetServiceLinkedRoleDeletionStatusErrorKind {
    InvalidInputError(crate::error::InvalidInputError),
    NoSuchEntityError(crate::error::NoSuchEntityError),
    ServiceFailureError(crate::error::ServiceFailureError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetServiceLinkedRoleDeletionStatusError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetServiceLinkedRoleDeletionStatusErrorKind::InvalidInputError(_inner) => _inner.fmt(f),
            GetServiceLinkedRoleDeletionStatusErrorKind::NoSuchEntityError(_inner) => _inner.fmt(f),
            GetServiceLinkedRoleDeletionStatusErrorKind::ServiceFailureError(_inner) => {
                _inner.fmt(f)
            }
            GetServiceLinkedRoleDeletionStatusErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetServiceLinkedRoleDeletionStatusError {
    fn code(&self) -> Option<&str> {
        GetServiceLinkedRoleDeletionStatusError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetServiceLinkedRoleDeletionStatusError {
    pub fn new(
        kind: GetServiceLinkedRoleDeletionStatusErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetServiceLinkedRoleDeletionStatusErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetServiceLinkedRoleDeletionStatusErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_input_error(&self) -> bool {
        matches!(
            &self.kind,
            GetServiceLinkedRoleDeletionStatusErrorKind::InvalidInputError(_)
        )
    }
    pub fn is_no_such_entity_error(&self) -> bool {
        matches!(
            &self.kind,
            GetServiceLinkedRoleDeletionStatusErrorKind::NoSuchEntityError(_)
        )
    }
    pub fn is_service_failure_error(&self) -> bool {
        matches!(
            &self.kind,
            GetServiceLinkedRoleDeletionStatusErrorKind::ServiceFailureError(_)
        )
    }
}
impl std::error::Error for GetServiceLinkedRoleDeletionStatusError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetServiceLinkedRoleDeletionStatusErrorKind::InvalidInputError(_inner) => Some(_inner),
            GetServiceLinkedRoleDeletionStatusErrorKind::NoSuchEntityError(_inner) => Some(_inner),
            GetServiceLinkedRoleDeletionStatusErrorKind::ServiceFailureError(_inner) => {
                Some(_inner)
            }
            GetServiceLinkedRoleDeletionStatusErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetSSHPublicKeyError {
    pub kind: GetSSHPublicKeyErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetSSHPublicKeyErrorKind {
    NoSuchEntityError(crate::error::NoSuchEntityError),
    UnrecognizedPublicKeyEncodingError(crate::error::UnrecognizedPublicKeyEncodingError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetSSHPublicKeyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetSSHPublicKeyErrorKind::NoSuchEntityError(_inner) => _inner.fmt(f),
            GetSSHPublicKeyErrorKind::UnrecognizedPublicKeyEncodingError(_inner) => _inner.fmt(f),
            GetSSHPublicKeyErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetSSHPublicKeyError {
    fn code(&self) -> Option<&str> {
        GetSSHPublicKeyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetSSHPublicKeyError {
    pub fn new(kind: GetSSHPublicKeyErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetSSHPublicKeyErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetSSHPublicKeyErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_no_such_entity_error(&self) -> bool {
        matches!(&self.kind, GetSSHPublicKeyErrorKind::NoSuchEntityError(_))
    }
    pub fn is_unrecognized_public_key_encoding_error(&self) -> bool {
        matches!(
            &self.kind,
            GetSSHPublicKeyErrorKind::UnrecognizedPublicKeyEncodingError(_)
        )
    }
}
impl std::error::Error for GetSSHPublicKeyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetSSHPublicKeyErrorKind::NoSuchEntityError(_inner) => Some(_inner),
            GetSSHPublicKeyErrorKind::UnrecognizedPublicKeyEncodingError(_inner) => Some(_inner),
            GetSSHPublicKeyErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetUserError {
    pub kind: GetUserErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetUserErrorKind {
    NoSuchEntityError(crate::error::NoSuchEntityError),
    ServiceFailureError(crate::error::ServiceFailureError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetUserError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetUserErrorKind::NoSuchEntityError(_inner) => _inner.fmt(f),
            GetUserErrorKind::ServiceFailureError(_inner) => _inner.fmt(f),
            GetUserErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetUserError {
    fn code(&self) -> Option<&str> {
        GetUserError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetUserError {
    pub fn new(kind: GetUserErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetUserErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetUserErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_no_such_entity_error(&self) -> bool {
        matches!(&self.kind, GetUserErrorKind::NoSuchEntityError(_))
    }
    pub fn is_service_failure_error(&self) -> bool {
        matches!(&self.kind, GetUserErrorKind::ServiceFailureError(_))
    }
}
impl std::error::Error for GetUserError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetUserErrorKind::NoSuchEntityError(_inner) => Some(_inner),
            GetUserErrorKind::ServiceFailureError(_inner) => Some(_inner),
            GetUserErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetUserPolicyError {
    pub kind: GetUserPolicyErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetUserPolicyErrorKind {
    NoSuchEntityError(crate::error::NoSuchEntityError),
    ServiceFailureError(crate::error::ServiceFailureError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetUserPolicyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetUserPolicyErrorKind::NoSuchEntityError(_inner) => _inner.fmt(f),
            GetUserPolicyErrorKind::ServiceFailureError(_inner) => _inner.fmt(f),
            GetUserPolicyErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetUserPolicyError {
    fn code(&self) -> Option<&str> {
        GetUserPolicyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetUserPolicyError {
    pub fn new(kind: GetUserPolicyErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetUserPolicyErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetUserPolicyErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_no_such_entity_error(&self) -> bool {
        matches!(&self.kind, GetUserPolicyErrorKind::NoSuchEntityError(_))
    }
    pub fn is_service_failure_error(&self) -> bool {
        matches!(&self.kind, GetUserPolicyErrorKind::ServiceFailureError(_))
    }
}
impl std::error::Error for GetUserPolicyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetUserPolicyErrorKind::NoSuchEntityError(_inner) => Some(_inner),
            GetUserPolicyErrorKind::ServiceFailureError(_inner) => Some(_inner),
            GetUserPolicyErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListAccessKeysError {
    pub kind: ListAccessKeysErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListAccessKeysErrorKind {
    NoSuchEntityError(crate::error::NoSuchEntityError),
    ServiceFailureError(crate::error::ServiceFailureError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListAccessKeysError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListAccessKeysErrorKind::NoSuchEntityError(_inner) => _inner.fmt(f),
            ListAccessKeysErrorKind::ServiceFailureError(_inner) => _inner.fmt(f),
            ListAccessKeysErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListAccessKeysError {
    fn code(&self) -> Option<&str> {
        ListAccessKeysError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListAccessKeysError {
    pub fn new(kind: ListAccessKeysErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListAccessKeysErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListAccessKeysErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_no_such_entity_error(&self) -> bool {
        matches!(&self.kind, ListAccessKeysErrorKind::NoSuchEntityError(_))
    }
    pub fn is_service_failure_error(&self) -> bool {
        matches!(&self.kind, ListAccessKeysErrorKind::ServiceFailureError(_))
    }
}
impl std::error::Error for ListAccessKeysError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListAccessKeysErrorKind::NoSuchEntityError(_inner) => Some(_inner),
            ListAccessKeysErrorKind::ServiceFailureError(_inner) => Some(_inner),
            ListAccessKeysErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListAccountAliasesError {
    pub kind: ListAccountAliasesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListAccountAliasesErrorKind {
    ServiceFailureError(crate::error::ServiceFailureError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListAccountAliasesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListAccountAliasesErrorKind::ServiceFailureError(_inner) => _inner.fmt(f),
            ListAccountAliasesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListAccountAliasesError {
    fn code(&self) -> Option<&str> {
        ListAccountAliasesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListAccountAliasesError {
    pub fn new(kind: ListAccountAliasesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListAccountAliasesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListAccountAliasesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_service_failure_error(&self) -> bool {
        matches!(
            &self.kind,
            ListAccountAliasesErrorKind::ServiceFailureError(_)
        )
    }
}
impl std::error::Error for ListAccountAliasesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListAccountAliasesErrorKind::ServiceFailureError(_inner) => Some(_inner),
            ListAccountAliasesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListAttachedGroupPoliciesError {
    pub kind: ListAttachedGroupPoliciesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListAttachedGroupPoliciesErrorKind {
    InvalidInputError(crate::error::InvalidInputError),
    NoSuchEntityError(crate::error::NoSuchEntityError),
    ServiceFailureError(crate::error::ServiceFailureError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListAttachedGroupPoliciesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListAttachedGroupPoliciesErrorKind::InvalidInputError(_inner) => _inner.fmt(f),
            ListAttachedGroupPoliciesErrorKind::NoSuchEntityError(_inner) => _inner.fmt(f),
            ListAttachedGroupPoliciesErrorKind::ServiceFailureError(_inner) => _inner.fmt(f),
            ListAttachedGroupPoliciesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListAttachedGroupPoliciesError {
    fn code(&self) -> Option<&str> {
        ListAttachedGroupPoliciesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListAttachedGroupPoliciesError {
    pub fn new(kind: ListAttachedGroupPoliciesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListAttachedGroupPoliciesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListAttachedGroupPoliciesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_input_error(&self) -> bool {
        matches!(
            &self.kind,
            ListAttachedGroupPoliciesErrorKind::InvalidInputError(_)
        )
    }
    pub fn is_no_such_entity_error(&self) -> bool {
        matches!(
            &self.kind,
            ListAttachedGroupPoliciesErrorKind::NoSuchEntityError(_)
        )
    }
    pub fn is_service_failure_error(&self) -> bool {
        matches!(
            &self.kind,
            ListAttachedGroupPoliciesErrorKind::ServiceFailureError(_)
        )
    }
}
impl std::error::Error for ListAttachedGroupPoliciesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListAttachedGroupPoliciesErrorKind::InvalidInputError(_inner) => Some(_inner),
            ListAttachedGroupPoliciesErrorKind::NoSuchEntityError(_inner) => Some(_inner),
            ListAttachedGroupPoliciesErrorKind::ServiceFailureError(_inner) => Some(_inner),
            ListAttachedGroupPoliciesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListAttachedRolePoliciesError {
    pub kind: ListAttachedRolePoliciesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListAttachedRolePoliciesErrorKind {
    InvalidInputError(crate::error::InvalidInputError),
    NoSuchEntityError(crate::error::NoSuchEntityError),
    ServiceFailureError(crate::error::ServiceFailureError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListAttachedRolePoliciesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListAttachedRolePoliciesErrorKind::InvalidInputError(_inner) => _inner.fmt(f),
            ListAttachedRolePoliciesErrorKind::NoSuchEntityError(_inner) => _inner.fmt(f),
            ListAttachedRolePoliciesErrorKind::ServiceFailureError(_inner) => _inner.fmt(f),
            ListAttachedRolePoliciesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListAttachedRolePoliciesError {
    fn code(&self) -> Option<&str> {
        ListAttachedRolePoliciesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListAttachedRolePoliciesError {
    pub fn new(kind: ListAttachedRolePoliciesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListAttachedRolePoliciesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListAttachedRolePoliciesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_input_error(&self) -> bool {
        matches!(
            &self.kind,
            ListAttachedRolePoliciesErrorKind::InvalidInputError(_)
        )
    }
    pub fn is_no_such_entity_error(&self) -> bool {
        matches!(
            &self.kind,
            ListAttachedRolePoliciesErrorKind::NoSuchEntityError(_)
        )
    }
    pub fn is_service_failure_error(&self) -> bool {
        matches!(
            &self.kind,
            ListAttachedRolePoliciesErrorKind::ServiceFailureError(_)
        )
    }
}
impl std::error::Error for ListAttachedRolePoliciesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListAttachedRolePoliciesErrorKind::InvalidInputError(_inner) => Some(_inner),
            ListAttachedRolePoliciesErrorKind::NoSuchEntityError(_inner) => Some(_inner),
            ListAttachedRolePoliciesErrorKind::ServiceFailureError(_inner) => Some(_inner),
            ListAttachedRolePoliciesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListAttachedUserPoliciesError {
    pub kind: ListAttachedUserPoliciesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListAttachedUserPoliciesErrorKind {
    InvalidInputError(crate::error::InvalidInputError),
    NoSuchEntityError(crate::error::NoSuchEntityError),
    ServiceFailureError(crate::error::ServiceFailureError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListAttachedUserPoliciesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListAttachedUserPoliciesErrorKind::InvalidInputError(_inner) => _inner.fmt(f),
            ListAttachedUserPoliciesErrorKind::NoSuchEntityError(_inner) => _inner.fmt(f),
            ListAttachedUserPoliciesErrorKind::ServiceFailureError(_inner) => _inner.fmt(f),
            ListAttachedUserPoliciesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListAttachedUserPoliciesError {
    fn code(&self) -> Option<&str> {
        ListAttachedUserPoliciesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListAttachedUserPoliciesError {
    pub fn new(kind: ListAttachedUserPoliciesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListAttachedUserPoliciesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListAttachedUserPoliciesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_input_error(&self) -> bool {
        matches!(
            &self.kind,
            ListAttachedUserPoliciesErrorKind::InvalidInputError(_)
        )
    }
    pub fn is_no_such_entity_error(&self) -> bool {
        matches!(
            &self.kind,
            ListAttachedUserPoliciesErrorKind::NoSuchEntityError(_)
        )
    }
    pub fn is_service_failure_error(&self) -> bool {
        matches!(
            &self.kind,
            ListAttachedUserPoliciesErrorKind::ServiceFailureError(_)
        )
    }
}
impl std::error::Error for ListAttachedUserPoliciesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListAttachedUserPoliciesErrorKind::InvalidInputError(_inner) => Some(_inner),
            ListAttachedUserPoliciesErrorKind::NoSuchEntityError(_inner) => Some(_inner),
            ListAttachedUserPoliciesErrorKind::ServiceFailureError(_inner) => Some(_inner),
            ListAttachedUserPoliciesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListEntitiesForPolicyError {
    pub kind: ListEntitiesForPolicyErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListEntitiesForPolicyErrorKind {
    InvalidInputError(crate::error::InvalidInputError),
    NoSuchEntityError(crate::error::NoSuchEntityError),
    ServiceFailureError(crate::error::ServiceFailureError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListEntitiesForPolicyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListEntitiesForPolicyErrorKind::InvalidInputError(_inner) => _inner.fmt(f),
            ListEntitiesForPolicyErrorKind::NoSuchEntityError(_inner) => _inner.fmt(f),
            ListEntitiesForPolicyErrorKind::ServiceFailureError(_inner) => _inner.fmt(f),
            ListEntitiesForPolicyErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListEntitiesForPolicyError {
    fn code(&self) -> Option<&str> {
        ListEntitiesForPolicyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListEntitiesForPolicyError {
    pub fn new(kind: ListEntitiesForPolicyErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListEntitiesForPolicyErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListEntitiesForPolicyErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_input_error(&self) -> bool {
        matches!(
            &self.kind,
            ListEntitiesForPolicyErrorKind::InvalidInputError(_)
        )
    }
    pub fn is_no_such_entity_error(&self) -> bool {
        matches!(
            &self.kind,
            ListEntitiesForPolicyErrorKind::NoSuchEntityError(_)
        )
    }
    pub fn is_service_failure_error(&self) -> bool {
        matches!(
            &self.kind,
            ListEntitiesForPolicyErrorKind::ServiceFailureError(_)
        )
    }
}
impl std::error::Error for ListEntitiesForPolicyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListEntitiesForPolicyErrorKind::InvalidInputError(_inner) => Some(_inner),
            ListEntitiesForPolicyErrorKind::NoSuchEntityError(_inner) => Some(_inner),
            ListEntitiesForPolicyErrorKind::ServiceFailureError(_inner) => Some(_inner),
            ListEntitiesForPolicyErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListGroupPoliciesError {
    pub kind: ListGroupPoliciesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListGroupPoliciesErrorKind {
    NoSuchEntityError(crate::error::NoSuchEntityError),
    ServiceFailureError(crate::error::ServiceFailureError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListGroupPoliciesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListGroupPoliciesErrorKind::NoSuchEntityError(_inner) => _inner.fmt(f),
            ListGroupPoliciesErrorKind::ServiceFailureError(_inner) => _inner.fmt(f),
            ListGroupPoliciesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListGroupPoliciesError {
    fn code(&self) -> Option<&str> {
        ListGroupPoliciesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListGroupPoliciesError {
    pub fn new(kind: ListGroupPoliciesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListGroupPoliciesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListGroupPoliciesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_no_such_entity_error(&self) -> bool {
        matches!(&self.kind, ListGroupPoliciesErrorKind::NoSuchEntityError(_))
    }
    pub fn is_service_failure_error(&self) -> bool {
        matches!(
            &self.kind,
            ListGroupPoliciesErrorKind::ServiceFailureError(_)
        )
    }
}
impl std::error::Error for ListGroupPoliciesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListGroupPoliciesErrorKind::NoSuchEntityError(_inner) => Some(_inner),
            ListGroupPoliciesErrorKind::ServiceFailureError(_inner) => Some(_inner),
            ListGroupPoliciesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListGroupsError {
    pub kind: ListGroupsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListGroupsErrorKind {
    ServiceFailureError(crate::error::ServiceFailureError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListGroupsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListGroupsErrorKind::ServiceFailureError(_inner) => _inner.fmt(f),
            ListGroupsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListGroupsError {
    fn code(&self) -> Option<&str> {
        ListGroupsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListGroupsError {
    pub fn new(kind: ListGroupsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListGroupsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListGroupsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_service_failure_error(&self) -> bool {
        matches!(&self.kind, ListGroupsErrorKind::ServiceFailureError(_))
    }
}
impl std::error::Error for ListGroupsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListGroupsErrorKind::ServiceFailureError(_inner) => Some(_inner),
            ListGroupsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListGroupsForUserError {
    pub kind: ListGroupsForUserErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListGroupsForUserErrorKind {
    NoSuchEntityError(crate::error::NoSuchEntityError),
    ServiceFailureError(crate::error::ServiceFailureError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListGroupsForUserError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListGroupsForUserErrorKind::NoSuchEntityError(_inner) => _inner.fmt(f),
            ListGroupsForUserErrorKind::ServiceFailureError(_inner) => _inner.fmt(f),
            ListGroupsForUserErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListGroupsForUserError {
    fn code(&self) -> Option<&str> {
        ListGroupsForUserError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListGroupsForUserError {
    pub fn new(kind: ListGroupsForUserErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListGroupsForUserErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListGroupsForUserErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_no_such_entity_error(&self) -> bool {
        matches!(&self.kind, ListGroupsForUserErrorKind::NoSuchEntityError(_))
    }
    pub fn is_service_failure_error(&self) -> bool {
        matches!(
            &self.kind,
            ListGroupsForUserErrorKind::ServiceFailureError(_)
        )
    }
}
impl std::error::Error for ListGroupsForUserError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListGroupsForUserErrorKind::NoSuchEntityError(_inner) => Some(_inner),
            ListGroupsForUserErrorKind::ServiceFailureError(_inner) => Some(_inner),
            ListGroupsForUserErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListInstanceProfilesError {
    pub kind: ListInstanceProfilesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListInstanceProfilesErrorKind {
    ServiceFailureError(crate::error::ServiceFailureError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListInstanceProfilesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListInstanceProfilesErrorKind::ServiceFailureError(_inner) => _inner.fmt(f),
            ListInstanceProfilesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListInstanceProfilesError {
    fn code(&self) -> Option<&str> {
        ListInstanceProfilesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListInstanceProfilesError {
    pub fn new(kind: ListInstanceProfilesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListInstanceProfilesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListInstanceProfilesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_service_failure_error(&self) -> bool {
        matches!(
            &self.kind,
            ListInstanceProfilesErrorKind::ServiceFailureError(_)
        )
    }
}
impl std::error::Error for ListInstanceProfilesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListInstanceProfilesErrorKind::ServiceFailureError(_inner) => Some(_inner),
            ListInstanceProfilesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListInstanceProfilesForRoleError {
    pub kind: ListInstanceProfilesForRoleErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListInstanceProfilesForRoleErrorKind {
    NoSuchEntityError(crate::error::NoSuchEntityError),
    ServiceFailureError(crate::error::ServiceFailureError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListInstanceProfilesForRoleError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListInstanceProfilesForRoleErrorKind::NoSuchEntityError(_inner) => _inner.fmt(f),
            ListInstanceProfilesForRoleErrorKind::ServiceFailureError(_inner) => _inner.fmt(f),
            ListInstanceProfilesForRoleErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListInstanceProfilesForRoleError {
    fn code(&self) -> Option<&str> {
        ListInstanceProfilesForRoleError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListInstanceProfilesForRoleError {
    pub fn new(kind: ListInstanceProfilesForRoleErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListInstanceProfilesForRoleErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListInstanceProfilesForRoleErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_no_such_entity_error(&self) -> bool {
        matches!(
            &self.kind,
            ListInstanceProfilesForRoleErrorKind::NoSuchEntityError(_)
        )
    }
    pub fn is_service_failure_error(&self) -> bool {
        matches!(
            &self.kind,
            ListInstanceProfilesForRoleErrorKind::ServiceFailureError(_)
        )
    }
}
impl std::error::Error for ListInstanceProfilesForRoleError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListInstanceProfilesForRoleErrorKind::NoSuchEntityError(_inner) => Some(_inner),
            ListInstanceProfilesForRoleErrorKind::ServiceFailureError(_inner) => Some(_inner),
            ListInstanceProfilesForRoleErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListInstanceProfileTagsError {
    pub kind: ListInstanceProfileTagsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListInstanceProfileTagsErrorKind {
    NoSuchEntityError(crate::error::NoSuchEntityError),
    ServiceFailureError(crate::error::ServiceFailureError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListInstanceProfileTagsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListInstanceProfileTagsErrorKind::NoSuchEntityError(_inner) => _inner.fmt(f),
            ListInstanceProfileTagsErrorKind::ServiceFailureError(_inner) => _inner.fmt(f),
            ListInstanceProfileTagsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListInstanceProfileTagsError {
    fn code(&self) -> Option<&str> {
        ListInstanceProfileTagsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListInstanceProfileTagsError {
    pub fn new(kind: ListInstanceProfileTagsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListInstanceProfileTagsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListInstanceProfileTagsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_no_such_entity_error(&self) -> bool {
        matches!(
            &self.kind,
            ListInstanceProfileTagsErrorKind::NoSuchEntityError(_)
        )
    }
    pub fn is_service_failure_error(&self) -> bool {
        matches!(
            &self.kind,
            ListInstanceProfileTagsErrorKind::ServiceFailureError(_)
        )
    }
}
impl std::error::Error for ListInstanceProfileTagsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListInstanceProfileTagsErrorKind::NoSuchEntityError(_inner) => Some(_inner),
            ListInstanceProfileTagsErrorKind::ServiceFailureError(_inner) => Some(_inner),
            ListInstanceProfileTagsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListMFADevicesError {
    pub kind: ListMFADevicesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListMFADevicesErrorKind {
    NoSuchEntityError(crate::error::NoSuchEntityError),
    ServiceFailureError(crate::error::ServiceFailureError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListMFADevicesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListMFADevicesErrorKind::NoSuchEntityError(_inner) => _inner.fmt(f),
            ListMFADevicesErrorKind::ServiceFailureError(_inner) => _inner.fmt(f),
            ListMFADevicesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListMFADevicesError {
    fn code(&self) -> Option<&str> {
        ListMFADevicesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListMFADevicesError {
    pub fn new(kind: ListMFADevicesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListMFADevicesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListMFADevicesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_no_such_entity_error(&self) -> bool {
        matches!(&self.kind, ListMFADevicesErrorKind::NoSuchEntityError(_))
    }
    pub fn is_service_failure_error(&self) -> bool {
        matches!(&self.kind, ListMFADevicesErrorKind::ServiceFailureError(_))
    }
}
impl std::error::Error for ListMFADevicesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListMFADevicesErrorKind::NoSuchEntityError(_inner) => Some(_inner),
            ListMFADevicesErrorKind::ServiceFailureError(_inner) => Some(_inner),
            ListMFADevicesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListMFADeviceTagsError {
    pub kind: ListMFADeviceTagsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListMFADeviceTagsErrorKind {
    InvalidInputError(crate::error::InvalidInputError),
    NoSuchEntityError(crate::error::NoSuchEntityError),
    ServiceFailureError(crate::error::ServiceFailureError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListMFADeviceTagsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListMFADeviceTagsErrorKind::InvalidInputError(_inner) => _inner.fmt(f),
            ListMFADeviceTagsErrorKind::NoSuchEntityError(_inner) => _inner.fmt(f),
            ListMFADeviceTagsErrorKind::ServiceFailureError(_inner) => _inner.fmt(f),
            ListMFADeviceTagsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListMFADeviceTagsError {
    fn code(&self) -> Option<&str> {
        ListMFADeviceTagsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListMFADeviceTagsError {
    pub fn new(kind: ListMFADeviceTagsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListMFADeviceTagsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListMFADeviceTagsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_input_error(&self) -> bool {
        matches!(&self.kind, ListMFADeviceTagsErrorKind::InvalidInputError(_))
    }
    pub fn is_no_such_entity_error(&self) -> bool {
        matches!(&self.kind, ListMFADeviceTagsErrorKind::NoSuchEntityError(_))
    }
    pub fn is_service_failure_error(&self) -> bool {
        matches!(
            &self.kind,
            ListMFADeviceTagsErrorKind::ServiceFailureError(_)
        )
    }
}
impl std::error::Error for ListMFADeviceTagsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListMFADeviceTagsErrorKind::InvalidInputError(_inner) => Some(_inner),
            ListMFADeviceTagsErrorKind::NoSuchEntityError(_inner) => Some(_inner),
            ListMFADeviceTagsErrorKind::ServiceFailureError(_inner) => Some(_inner),
            ListMFADeviceTagsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListOpenIDConnectProvidersError {
    pub kind: ListOpenIDConnectProvidersErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListOpenIDConnectProvidersErrorKind {
    ServiceFailureError(crate::error::ServiceFailureError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListOpenIDConnectProvidersError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListOpenIDConnectProvidersErrorKind::ServiceFailureError(_inner) => _inner.fmt(f),
            ListOpenIDConnectProvidersErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListOpenIDConnectProvidersError {
    fn code(&self) -> Option<&str> {
        ListOpenIDConnectProvidersError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListOpenIDConnectProvidersError {
    pub fn new(kind: ListOpenIDConnectProvidersErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListOpenIDConnectProvidersErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListOpenIDConnectProvidersErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_service_failure_error(&self) -> bool {
        matches!(
            &self.kind,
            ListOpenIDConnectProvidersErrorKind::ServiceFailureError(_)
        )
    }
}
impl std::error::Error for ListOpenIDConnectProvidersError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListOpenIDConnectProvidersErrorKind::ServiceFailureError(_inner) => Some(_inner),
            ListOpenIDConnectProvidersErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListOpenIDConnectProviderTagsError {
    pub kind: ListOpenIDConnectProviderTagsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListOpenIDConnectProviderTagsErrorKind {
    InvalidInputError(crate::error::InvalidInputError),
    NoSuchEntityError(crate::error::NoSuchEntityError),
    ServiceFailureError(crate::error::ServiceFailureError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListOpenIDConnectProviderTagsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListOpenIDConnectProviderTagsErrorKind::InvalidInputError(_inner) => _inner.fmt(f),
            ListOpenIDConnectProviderTagsErrorKind::NoSuchEntityError(_inner) => _inner.fmt(f),
            ListOpenIDConnectProviderTagsErrorKind::ServiceFailureError(_inner) => _inner.fmt(f),
            ListOpenIDConnectProviderTagsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListOpenIDConnectProviderTagsError {
    fn code(&self) -> Option<&str> {
        ListOpenIDConnectProviderTagsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListOpenIDConnectProviderTagsError {
    pub fn new(kind: ListOpenIDConnectProviderTagsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListOpenIDConnectProviderTagsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListOpenIDConnectProviderTagsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_input_error(&self) -> bool {
        matches!(
            &self.kind,
            ListOpenIDConnectProviderTagsErrorKind::InvalidInputError(_)
        )
    }
    pub fn is_no_such_entity_error(&self) -> bool {
        matches!(
            &self.kind,
            ListOpenIDConnectProviderTagsErrorKind::NoSuchEntityError(_)
        )
    }
    pub fn is_service_failure_error(&self) -> bool {
        matches!(
            &self.kind,
            ListOpenIDConnectProviderTagsErrorKind::ServiceFailureError(_)
        )
    }
}
impl std::error::Error for ListOpenIDConnectProviderTagsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListOpenIDConnectProviderTagsErrorKind::InvalidInputError(_inner) => Some(_inner),
            ListOpenIDConnectProviderTagsErrorKind::NoSuchEntityError(_inner) => Some(_inner),
            ListOpenIDConnectProviderTagsErrorKind::ServiceFailureError(_inner) => Some(_inner),
            ListOpenIDConnectProviderTagsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListPoliciesError {
    pub kind: ListPoliciesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListPoliciesErrorKind {
    ServiceFailureError(crate::error::ServiceFailureError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListPoliciesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListPoliciesErrorKind::ServiceFailureError(_inner) => _inner.fmt(f),
            ListPoliciesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListPoliciesError {
    fn code(&self) -> Option<&str> {
        ListPoliciesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListPoliciesError {
    pub fn new(kind: ListPoliciesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListPoliciesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListPoliciesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_service_failure_error(&self) -> bool {
        matches!(&self.kind, ListPoliciesErrorKind::ServiceFailureError(_))
    }
}
impl std::error::Error for ListPoliciesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListPoliciesErrorKind::ServiceFailureError(_inner) => Some(_inner),
            ListPoliciesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListPoliciesGrantingServiceAccessError {
    pub kind: ListPoliciesGrantingServiceAccessErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListPoliciesGrantingServiceAccessErrorKind {
    InvalidInputError(crate::error::InvalidInputError),
    NoSuchEntityError(crate::error::NoSuchEntityError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListPoliciesGrantingServiceAccessError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListPoliciesGrantingServiceAccessErrorKind::InvalidInputError(_inner) => _inner.fmt(f),
            ListPoliciesGrantingServiceAccessErrorKind::NoSuchEntityError(_inner) => _inner.fmt(f),
            ListPoliciesGrantingServiceAccessErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListPoliciesGrantingServiceAccessError {
    fn code(&self) -> Option<&str> {
        ListPoliciesGrantingServiceAccessError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListPoliciesGrantingServiceAccessError {
    pub fn new(
        kind: ListPoliciesGrantingServiceAccessErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListPoliciesGrantingServiceAccessErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListPoliciesGrantingServiceAccessErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_input_error(&self) -> bool {
        matches!(
            &self.kind,
            ListPoliciesGrantingServiceAccessErrorKind::InvalidInputError(_)
        )
    }
    pub fn is_no_such_entity_error(&self) -> bool {
        matches!(
            &self.kind,
            ListPoliciesGrantingServiceAccessErrorKind::NoSuchEntityError(_)
        )
    }
}
impl std::error::Error for ListPoliciesGrantingServiceAccessError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListPoliciesGrantingServiceAccessErrorKind::InvalidInputError(_inner) => Some(_inner),
            ListPoliciesGrantingServiceAccessErrorKind::NoSuchEntityError(_inner) => Some(_inner),
            ListPoliciesGrantingServiceAccessErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListPolicyTagsError {
    pub kind: ListPolicyTagsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListPolicyTagsErrorKind {
    InvalidInputError(crate::error::InvalidInputError),
    NoSuchEntityError(crate::error::NoSuchEntityError),
    ServiceFailureError(crate::error::ServiceFailureError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListPolicyTagsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListPolicyTagsErrorKind::InvalidInputError(_inner) => _inner.fmt(f),
            ListPolicyTagsErrorKind::NoSuchEntityError(_inner) => _inner.fmt(f),
            ListPolicyTagsErrorKind::ServiceFailureError(_inner) => _inner.fmt(f),
            ListPolicyTagsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListPolicyTagsError {
    fn code(&self) -> Option<&str> {
        ListPolicyTagsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListPolicyTagsError {
    pub fn new(kind: ListPolicyTagsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListPolicyTagsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListPolicyTagsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_input_error(&self) -> bool {
        matches!(&self.kind, ListPolicyTagsErrorKind::InvalidInputError(_))
    }
    pub fn is_no_such_entity_error(&self) -> bool {
        matches!(&self.kind, ListPolicyTagsErrorKind::NoSuchEntityError(_))
    }
    pub fn is_service_failure_error(&self) -> bool {
        matches!(&self.kind, ListPolicyTagsErrorKind::ServiceFailureError(_))
    }
}
impl std::error::Error for ListPolicyTagsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListPolicyTagsErrorKind::InvalidInputError(_inner) => Some(_inner),
            ListPolicyTagsErrorKind::NoSuchEntityError(_inner) => Some(_inner),
            ListPolicyTagsErrorKind::ServiceFailureError(_inner) => Some(_inner),
            ListPolicyTagsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListPolicyVersionsError {
    pub kind: ListPolicyVersionsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListPolicyVersionsErrorKind {
    InvalidInputError(crate::error::InvalidInputError),
    NoSuchEntityError(crate::error::NoSuchEntityError),
    ServiceFailureError(crate::error::ServiceFailureError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListPolicyVersionsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListPolicyVersionsErrorKind::InvalidInputError(_inner) => _inner.fmt(f),
            ListPolicyVersionsErrorKind::NoSuchEntityError(_inner) => _inner.fmt(f),
            ListPolicyVersionsErrorKind::ServiceFailureError(_inner) => _inner.fmt(f),
            ListPolicyVersionsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListPolicyVersionsError {
    fn code(&self) -> Option<&str> {
        ListPolicyVersionsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListPolicyVersionsError {
    pub fn new(kind: ListPolicyVersionsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListPolicyVersionsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListPolicyVersionsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_input_error(&self) -> bool {
        matches!(
            &self.kind,
            ListPolicyVersionsErrorKind::InvalidInputError(_)
        )
    }
    pub fn is_no_such_entity_error(&self) -> bool {
        matches!(
            &self.kind,
            ListPolicyVersionsErrorKind::NoSuchEntityError(_)
        )
    }
    pub fn is_service_failure_error(&self) -> bool {
        matches!(
            &self.kind,
            ListPolicyVersionsErrorKind::ServiceFailureError(_)
        )
    }
}
impl std::error::Error for ListPolicyVersionsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListPolicyVersionsErrorKind::InvalidInputError(_inner) => Some(_inner),
            ListPolicyVersionsErrorKind::NoSuchEntityError(_inner) => Some(_inner),
            ListPolicyVersionsErrorKind::ServiceFailureError(_inner) => Some(_inner),
            ListPolicyVersionsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListRolePoliciesError {
    pub kind: ListRolePoliciesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListRolePoliciesErrorKind {
    NoSuchEntityError(crate::error::NoSuchEntityError),
    ServiceFailureError(crate::error::ServiceFailureError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListRolePoliciesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListRolePoliciesErrorKind::NoSuchEntityError(_inner) => _inner.fmt(f),
            ListRolePoliciesErrorKind::ServiceFailureError(_inner) => _inner.fmt(f),
            ListRolePoliciesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListRolePoliciesError {
    fn code(&self) -> Option<&str> {
        ListRolePoliciesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListRolePoliciesError {
    pub fn new(kind: ListRolePoliciesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListRolePoliciesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListRolePoliciesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_no_such_entity_error(&self) -> bool {
        matches!(&self.kind, ListRolePoliciesErrorKind::NoSuchEntityError(_))
    }
    pub fn is_service_failure_error(&self) -> bool {
        matches!(
            &self.kind,
            ListRolePoliciesErrorKind::ServiceFailureError(_)
        )
    }
}
impl std::error::Error for ListRolePoliciesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListRolePoliciesErrorKind::NoSuchEntityError(_inner) => Some(_inner),
            ListRolePoliciesErrorKind::ServiceFailureError(_inner) => Some(_inner),
            ListRolePoliciesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListRolesError {
    pub kind: ListRolesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListRolesErrorKind {
    ServiceFailureError(crate::error::ServiceFailureError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListRolesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListRolesErrorKind::ServiceFailureError(_inner) => _inner.fmt(f),
            ListRolesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListRolesError {
    fn code(&self) -> Option<&str> {
        ListRolesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListRolesError {
    pub fn new(kind: ListRolesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListRolesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListRolesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_service_failure_error(&self) -> bool {
        matches!(&self.kind, ListRolesErrorKind::ServiceFailureError(_))
    }
}
impl std::error::Error for ListRolesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListRolesErrorKind::ServiceFailureError(_inner) => Some(_inner),
            ListRolesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListRoleTagsError {
    pub kind: ListRoleTagsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListRoleTagsErrorKind {
    NoSuchEntityError(crate::error::NoSuchEntityError),
    ServiceFailureError(crate::error::ServiceFailureError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListRoleTagsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListRoleTagsErrorKind::NoSuchEntityError(_inner) => _inner.fmt(f),
            ListRoleTagsErrorKind::ServiceFailureError(_inner) => _inner.fmt(f),
            ListRoleTagsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListRoleTagsError {
    fn code(&self) -> Option<&str> {
        ListRoleTagsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListRoleTagsError {
    pub fn new(kind: ListRoleTagsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListRoleTagsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListRoleTagsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_no_such_entity_error(&self) -> bool {
        matches!(&self.kind, ListRoleTagsErrorKind::NoSuchEntityError(_))
    }
    pub fn is_service_failure_error(&self) -> bool {
        matches!(&self.kind, ListRoleTagsErrorKind::ServiceFailureError(_))
    }
}
impl std::error::Error for ListRoleTagsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListRoleTagsErrorKind::NoSuchEntityError(_inner) => Some(_inner),
            ListRoleTagsErrorKind::ServiceFailureError(_inner) => Some(_inner),
            ListRoleTagsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListSAMLProvidersError {
    pub kind: ListSAMLProvidersErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListSAMLProvidersErrorKind {
    ServiceFailureError(crate::error::ServiceFailureError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListSAMLProvidersError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListSAMLProvidersErrorKind::ServiceFailureError(_inner) => _inner.fmt(f),
            ListSAMLProvidersErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListSAMLProvidersError {
    fn code(&self) -> Option<&str> {
        ListSAMLProvidersError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListSAMLProvidersError {
    pub fn new(kind: ListSAMLProvidersErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListSAMLProvidersErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListSAMLProvidersErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_service_failure_error(&self) -> bool {
        matches!(
            &self.kind,
            ListSAMLProvidersErrorKind::ServiceFailureError(_)
        )
    }
}
impl std::error::Error for ListSAMLProvidersError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListSAMLProvidersErrorKind::ServiceFailureError(_inner) => Some(_inner),
            ListSAMLProvidersErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListSAMLProviderTagsError {
    pub kind: ListSAMLProviderTagsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListSAMLProviderTagsErrorKind {
    InvalidInputError(crate::error::InvalidInputError),
    NoSuchEntityError(crate::error::NoSuchEntityError),
    ServiceFailureError(crate::error::ServiceFailureError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListSAMLProviderTagsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListSAMLProviderTagsErrorKind::InvalidInputError(_inner) => _inner.fmt(f),
            ListSAMLProviderTagsErrorKind::NoSuchEntityError(_inner) => _inner.fmt(f),
            ListSAMLProviderTagsErrorKind::ServiceFailureError(_inner) => _inner.fmt(f),
            ListSAMLProviderTagsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListSAMLProviderTagsError {
    fn code(&self) -> Option<&str> {
        ListSAMLProviderTagsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListSAMLProviderTagsError {
    pub fn new(kind: ListSAMLProviderTagsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListSAMLProviderTagsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListSAMLProviderTagsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_input_error(&self) -> bool {
        matches!(
            &self.kind,
            ListSAMLProviderTagsErrorKind::InvalidInputError(_)
        )
    }
    pub fn is_no_such_entity_error(&self) -> bool {
        matches!(
            &self.kind,
            ListSAMLProviderTagsErrorKind::NoSuchEntityError(_)
        )
    }
    pub fn is_service_failure_error(&self) -> bool {
        matches!(
            &self.kind,
            ListSAMLProviderTagsErrorKind::ServiceFailureError(_)
        )
    }
}
impl std::error::Error for ListSAMLProviderTagsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListSAMLProviderTagsErrorKind::InvalidInputError(_inner) => Some(_inner),
            ListSAMLProviderTagsErrorKind::NoSuchEntityError(_inner) => Some(_inner),
            ListSAMLProviderTagsErrorKind::ServiceFailureError(_inner) => Some(_inner),
            ListSAMLProviderTagsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListServerCertificatesError {
    pub kind: ListServerCertificatesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListServerCertificatesErrorKind {
    ServiceFailureError(crate::error::ServiceFailureError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListServerCertificatesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListServerCertificatesErrorKind::ServiceFailureError(_inner) => _inner.fmt(f),
            ListServerCertificatesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListServerCertificatesError {
    fn code(&self) -> Option<&str> {
        ListServerCertificatesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListServerCertificatesError {
    pub fn new(kind: ListServerCertificatesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListServerCertificatesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListServerCertificatesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_service_failure_error(&self) -> bool {
        matches!(
            &self.kind,
            ListServerCertificatesErrorKind::ServiceFailureError(_)
        )
    }
}
impl std::error::Error for ListServerCertificatesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListServerCertificatesErrorKind::ServiceFailureError(_inner) => Some(_inner),
            ListServerCertificatesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListServerCertificateTagsError {
    pub kind: ListServerCertificateTagsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListServerCertificateTagsErrorKind {
    NoSuchEntityError(crate::error::NoSuchEntityError),
    ServiceFailureError(crate::error::ServiceFailureError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListServerCertificateTagsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListServerCertificateTagsErrorKind::NoSuchEntityError(_inner) => _inner.fmt(f),
            ListServerCertificateTagsErrorKind::ServiceFailureError(_inner) => _inner.fmt(f),
            ListServerCertificateTagsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListServerCertificateTagsError {
    fn code(&self) -> Option<&str> {
        ListServerCertificateTagsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListServerCertificateTagsError {
    pub fn new(kind: ListServerCertificateTagsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListServerCertificateTagsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListServerCertificateTagsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_no_such_entity_error(&self) -> bool {
        matches!(
            &self.kind,
            ListServerCertificateTagsErrorKind::NoSuchEntityError(_)
        )
    }
    pub fn is_service_failure_error(&self) -> bool {
        matches!(
            &self.kind,
            ListServerCertificateTagsErrorKind::ServiceFailureError(_)
        )
    }
}
impl std::error::Error for ListServerCertificateTagsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListServerCertificateTagsErrorKind::NoSuchEntityError(_inner) => Some(_inner),
            ListServerCertificateTagsErrorKind::ServiceFailureError(_inner) => Some(_inner),
            ListServerCertificateTagsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListServiceSpecificCredentialsError {
    pub kind: ListServiceSpecificCredentialsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListServiceSpecificCredentialsErrorKind {
    NoSuchEntityError(crate::error::NoSuchEntityError),
    ServiceNotSupportedError(crate::error::ServiceNotSupportedError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListServiceSpecificCredentialsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListServiceSpecificCredentialsErrorKind::NoSuchEntityError(_inner) => _inner.fmt(f),
            ListServiceSpecificCredentialsErrorKind::ServiceNotSupportedError(_inner) => {
                _inner.fmt(f)
            }
            ListServiceSpecificCredentialsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListServiceSpecificCredentialsError {
    fn code(&self) -> Option<&str> {
        ListServiceSpecificCredentialsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListServiceSpecificCredentialsError {
    pub fn new(kind: ListServiceSpecificCredentialsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListServiceSpecificCredentialsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListServiceSpecificCredentialsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_no_such_entity_error(&self) -> bool {
        matches!(
            &self.kind,
            ListServiceSpecificCredentialsErrorKind::NoSuchEntityError(_)
        )
    }
    pub fn is_service_not_supported_error(&self) -> bool {
        matches!(
            &self.kind,
            ListServiceSpecificCredentialsErrorKind::ServiceNotSupportedError(_)
        )
    }
}
impl std::error::Error for ListServiceSpecificCredentialsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListServiceSpecificCredentialsErrorKind::NoSuchEntityError(_inner) => Some(_inner),
            ListServiceSpecificCredentialsErrorKind::ServiceNotSupportedError(_inner) => {
                Some(_inner)
            }
            ListServiceSpecificCredentialsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListSigningCertificatesError {
    pub kind: ListSigningCertificatesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListSigningCertificatesErrorKind {
    NoSuchEntityError(crate::error::NoSuchEntityError),
    ServiceFailureError(crate::error::ServiceFailureError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListSigningCertificatesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListSigningCertificatesErrorKind::NoSuchEntityError(_inner) => _inner.fmt(f),
            ListSigningCertificatesErrorKind::ServiceFailureError(_inner) => _inner.fmt(f),
            ListSigningCertificatesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListSigningCertificatesError {
    fn code(&self) -> Option<&str> {
        ListSigningCertificatesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListSigningCertificatesError {
    pub fn new(kind: ListSigningCertificatesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListSigningCertificatesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListSigningCertificatesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_no_such_entity_error(&self) -> bool {
        matches!(
            &self.kind,
            ListSigningCertificatesErrorKind::NoSuchEntityError(_)
        )
    }
    pub fn is_service_failure_error(&self) -> bool {
        matches!(
            &self.kind,
            ListSigningCertificatesErrorKind::ServiceFailureError(_)
        )
    }
}
impl std::error::Error for ListSigningCertificatesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListSigningCertificatesErrorKind::NoSuchEntityError(_inner) => Some(_inner),
            ListSigningCertificatesErrorKind::ServiceFailureError(_inner) => Some(_inner),
            ListSigningCertificatesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListSSHPublicKeysError {
    pub kind: ListSSHPublicKeysErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListSSHPublicKeysErrorKind {
    NoSuchEntityError(crate::error::NoSuchEntityError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListSSHPublicKeysError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListSSHPublicKeysErrorKind::NoSuchEntityError(_inner) => _inner.fmt(f),
            ListSSHPublicKeysErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListSSHPublicKeysError {
    fn code(&self) -> Option<&str> {
        ListSSHPublicKeysError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListSSHPublicKeysError {
    pub fn new(kind: ListSSHPublicKeysErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListSSHPublicKeysErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListSSHPublicKeysErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_no_such_entity_error(&self) -> bool {
        matches!(&self.kind, ListSSHPublicKeysErrorKind::NoSuchEntityError(_))
    }
}
impl std::error::Error for ListSSHPublicKeysError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListSSHPublicKeysErrorKind::NoSuchEntityError(_inner) => Some(_inner),
            ListSSHPublicKeysErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListUserPoliciesError {
    pub kind: ListUserPoliciesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListUserPoliciesErrorKind {
    NoSuchEntityError(crate::error::NoSuchEntityError),
    ServiceFailureError(crate::error::ServiceFailureError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListUserPoliciesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListUserPoliciesErrorKind::NoSuchEntityError(_inner) => _inner.fmt(f),
            ListUserPoliciesErrorKind::ServiceFailureError(_inner) => _inner.fmt(f),
            ListUserPoliciesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListUserPoliciesError {
    fn code(&self) -> Option<&str> {
        ListUserPoliciesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListUserPoliciesError {
    pub fn new(kind: ListUserPoliciesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListUserPoliciesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListUserPoliciesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_no_such_entity_error(&self) -> bool {
        matches!(&self.kind, ListUserPoliciesErrorKind::NoSuchEntityError(_))
    }
    pub fn is_service_failure_error(&self) -> bool {
        matches!(
            &self.kind,
            ListUserPoliciesErrorKind::ServiceFailureError(_)
        )
    }
}
impl std::error::Error for ListUserPoliciesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListUserPoliciesErrorKind::NoSuchEntityError(_inner) => Some(_inner),
            ListUserPoliciesErrorKind::ServiceFailureError(_inner) => Some(_inner),
            ListUserPoliciesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListUsersError {
    pub kind: ListUsersErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListUsersErrorKind {
    ServiceFailureError(crate::error::ServiceFailureError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListUsersError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListUsersErrorKind::ServiceFailureError(_inner) => _inner.fmt(f),
            ListUsersErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListUsersError {
    fn code(&self) -> Option<&str> {
        ListUsersError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListUsersError {
    pub fn new(kind: ListUsersErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListUsersErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListUsersErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_service_failure_error(&self) -> bool {
        matches!(&self.kind, ListUsersErrorKind::ServiceFailureError(_))
    }
}
impl std::error::Error for ListUsersError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListUsersErrorKind::ServiceFailureError(_inner) => Some(_inner),
            ListUsersErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListUserTagsError {
    pub kind: ListUserTagsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListUserTagsErrorKind {
    NoSuchEntityError(crate::error::NoSuchEntityError),
    ServiceFailureError(crate::error::ServiceFailureError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListUserTagsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListUserTagsErrorKind::NoSuchEntityError(_inner) => _inner.fmt(f),
            ListUserTagsErrorKind::ServiceFailureError(_inner) => _inner.fmt(f),
            ListUserTagsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListUserTagsError {
    fn code(&self) -> Option<&str> {
        ListUserTagsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListUserTagsError {
    pub fn new(kind: ListUserTagsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListUserTagsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListUserTagsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_no_such_entity_error(&self) -> bool {
        matches!(&self.kind, ListUserTagsErrorKind::NoSuchEntityError(_))
    }
    pub fn is_service_failure_error(&self) -> bool {
        matches!(&self.kind, ListUserTagsErrorKind::ServiceFailureError(_))
    }
}
impl std::error::Error for ListUserTagsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListUserTagsErrorKind::NoSuchEntityError(_inner) => Some(_inner),
            ListUserTagsErrorKind::ServiceFailureError(_inner) => Some(_inner),
            ListUserTagsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListVirtualMFADevicesError {
    pub kind: ListVirtualMFADevicesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListVirtualMFADevicesErrorKind {
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListVirtualMFADevicesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListVirtualMFADevicesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListVirtualMFADevicesError {
    fn code(&self) -> Option<&str> {
        ListVirtualMFADevicesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListVirtualMFADevicesError {
    pub fn new(kind: ListVirtualMFADevicesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListVirtualMFADevicesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListVirtualMFADevicesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
}
impl std::error::Error for ListVirtualMFADevicesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListVirtualMFADevicesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct PutGroupPolicyError {
    pub kind: PutGroupPolicyErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum PutGroupPolicyErrorKind {
    LimitExceededError(crate::error::LimitExceededError),
    MalformedPolicyDocumentError(crate::error::MalformedPolicyDocumentError),
    NoSuchEntityError(crate::error::NoSuchEntityError),
    ServiceFailureError(crate::error::ServiceFailureError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for PutGroupPolicyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            PutGroupPolicyErrorKind::LimitExceededError(_inner) => _inner.fmt(f),
            PutGroupPolicyErrorKind::MalformedPolicyDocumentError(_inner) => _inner.fmt(f),
            PutGroupPolicyErrorKind::NoSuchEntityError(_inner) => _inner.fmt(f),
            PutGroupPolicyErrorKind::ServiceFailureError(_inner) => _inner.fmt(f),
            PutGroupPolicyErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for PutGroupPolicyError {
    fn code(&self) -> Option<&str> {
        PutGroupPolicyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl PutGroupPolicyError {
    pub fn new(kind: PutGroupPolicyErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: PutGroupPolicyErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: PutGroupPolicyErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_limit_exceeded_error(&self) -> bool {
        matches!(&self.kind, PutGroupPolicyErrorKind::LimitExceededError(_))
    }
    pub fn is_malformed_policy_document_error(&self) -> bool {
        matches!(
            &self.kind,
            PutGroupPolicyErrorKind::MalformedPolicyDocumentError(_)
        )
    }
    pub fn is_no_such_entity_error(&self) -> bool {
        matches!(&self.kind, PutGroupPolicyErrorKind::NoSuchEntityError(_))
    }
    pub fn is_service_failure_error(&self) -> bool {
        matches!(&self.kind, PutGroupPolicyErrorKind::ServiceFailureError(_))
    }
}
impl std::error::Error for PutGroupPolicyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            PutGroupPolicyErrorKind::LimitExceededError(_inner) => Some(_inner),
            PutGroupPolicyErrorKind::MalformedPolicyDocumentError(_inner) => Some(_inner),
            PutGroupPolicyErrorKind::NoSuchEntityError(_inner) => Some(_inner),
            PutGroupPolicyErrorKind::ServiceFailureError(_inner) => Some(_inner),
            PutGroupPolicyErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct PutRolePermissionsBoundaryError {
    pub kind: PutRolePermissionsBoundaryErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum PutRolePermissionsBoundaryErrorKind {
    InvalidInputError(crate::error::InvalidInputError),
    NoSuchEntityError(crate::error::NoSuchEntityError),
    PolicyNotAttachableError(crate::error::PolicyNotAttachableError),
    ServiceFailureError(crate::error::ServiceFailureError),
    UnmodifiableEntityError(crate::error::UnmodifiableEntityError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for PutRolePermissionsBoundaryError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            PutRolePermissionsBoundaryErrorKind::InvalidInputError(_inner) => _inner.fmt(f),
            PutRolePermissionsBoundaryErrorKind::NoSuchEntityError(_inner) => _inner.fmt(f),
            PutRolePermissionsBoundaryErrorKind::PolicyNotAttachableError(_inner) => _inner.fmt(f),
            PutRolePermissionsBoundaryErrorKind::ServiceFailureError(_inner) => _inner.fmt(f),
            PutRolePermissionsBoundaryErrorKind::UnmodifiableEntityError(_inner) => _inner.fmt(f),
            PutRolePermissionsBoundaryErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for PutRolePermissionsBoundaryError {
    fn code(&self) -> Option<&str> {
        PutRolePermissionsBoundaryError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl PutRolePermissionsBoundaryError {
    pub fn new(kind: PutRolePermissionsBoundaryErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: PutRolePermissionsBoundaryErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: PutRolePermissionsBoundaryErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_input_error(&self) -> bool {
        matches!(
            &self.kind,
            PutRolePermissionsBoundaryErrorKind::InvalidInputError(_)
        )
    }
    pub fn is_no_such_entity_error(&self) -> bool {
        matches!(
            &self.kind,
            PutRolePermissionsBoundaryErrorKind::NoSuchEntityError(_)
        )
    }
    pub fn is_policy_not_attachable_error(&self) -> bool {
        matches!(
            &self.kind,
            PutRolePermissionsBoundaryErrorKind::PolicyNotAttachableError(_)
        )
    }
    pub fn is_service_failure_error(&self) -> bool {
        matches!(
            &self.kind,
            PutRolePermissionsBoundaryErrorKind::ServiceFailureError(_)
        )
    }
    pub fn is_unmodifiable_entity_error(&self) -> bool {
        matches!(
            &self.kind,
            PutRolePermissionsBoundaryErrorKind::UnmodifiableEntityError(_)
        )
    }
}
impl std::error::Error for PutRolePermissionsBoundaryError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            PutRolePermissionsBoundaryErrorKind::InvalidInputError(_inner) => Some(_inner),
            PutRolePermissionsBoundaryErrorKind::NoSuchEntityError(_inner) => Some(_inner),
            PutRolePermissionsBoundaryErrorKind::PolicyNotAttachableError(_inner) => Some(_inner),
            PutRolePermissionsBoundaryErrorKind::ServiceFailureError(_inner) => Some(_inner),
            PutRolePermissionsBoundaryErrorKind::UnmodifiableEntityError(_inner) => Some(_inner),
            PutRolePermissionsBoundaryErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct PutRolePolicyError {
    pub kind: PutRolePolicyErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum PutRolePolicyErrorKind {
    LimitExceededError(crate::error::LimitExceededError),
    MalformedPolicyDocumentError(crate::error::MalformedPolicyDocumentError),
    NoSuchEntityError(crate::error::NoSuchEntityError),
    ServiceFailureError(crate::error::ServiceFailureError),
    UnmodifiableEntityError(crate::error::UnmodifiableEntityError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for PutRolePolicyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            PutRolePolicyErrorKind::LimitExceededError(_inner) => _inner.fmt(f),
            PutRolePolicyErrorKind::MalformedPolicyDocumentError(_inner) => _inner.fmt(f),
            PutRolePolicyErrorKind::NoSuchEntityError(_inner) => _inner.fmt(f),
            PutRolePolicyErrorKind::ServiceFailureError(_inner) => _inner.fmt(f),
            PutRolePolicyErrorKind::UnmodifiableEntityError(_inner) => _inner.fmt(f),
            PutRolePolicyErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for PutRolePolicyError {
    fn code(&self) -> Option<&str> {
        PutRolePolicyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl PutRolePolicyError {
    pub fn new(kind: PutRolePolicyErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: PutRolePolicyErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: PutRolePolicyErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_limit_exceeded_error(&self) -> bool {
        matches!(&self.kind, PutRolePolicyErrorKind::LimitExceededError(_))
    }
    pub fn is_malformed_policy_document_error(&self) -> bool {
        matches!(
            &self.kind,
            PutRolePolicyErrorKind::MalformedPolicyDocumentError(_)
        )
    }
    pub fn is_no_such_entity_error(&self) -> bool {
        matches!(&self.kind, PutRolePolicyErrorKind::NoSuchEntityError(_))
    }
    pub fn is_service_failure_error(&self) -> bool {
        matches!(&self.kind, PutRolePolicyErrorKind::ServiceFailureError(_))
    }
    pub fn is_unmodifiable_entity_error(&self) -> bool {
        matches!(
            &self.kind,
            PutRolePolicyErrorKind::UnmodifiableEntityError(_)
        )
    }
}
impl std::error::Error for PutRolePolicyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            PutRolePolicyErrorKind::LimitExceededError(_inner) => Some(_inner),
            PutRolePolicyErrorKind::MalformedPolicyDocumentError(_inner) => Some(_inner),
            PutRolePolicyErrorKind::NoSuchEntityError(_inner) => Some(_inner),
            PutRolePolicyErrorKind::ServiceFailureError(_inner) => Some(_inner),
            PutRolePolicyErrorKind::UnmodifiableEntityError(_inner) => Some(_inner),
            PutRolePolicyErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct PutUserPermissionsBoundaryError {
    pub kind: PutUserPermissionsBoundaryErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum PutUserPermissionsBoundaryErrorKind {
    InvalidInputError(crate::error::InvalidInputError),
    NoSuchEntityError(crate::error::NoSuchEntityError),
    PolicyNotAttachableError(crate::error::PolicyNotAttachableError),
    ServiceFailureError(crate::error::ServiceFailureError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for PutUserPermissionsBoundaryError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            PutUserPermissionsBoundaryErrorKind::InvalidInputError(_inner) => _inner.fmt(f),
            PutUserPermissionsBoundaryErrorKind::NoSuchEntityError(_inner) => _inner.fmt(f),
            PutUserPermissionsBoundaryErrorKind::PolicyNotAttachableError(_inner) => _inner.fmt(f),
            PutUserPermissionsBoundaryErrorKind::ServiceFailureError(_inner) => _inner.fmt(f),
            PutUserPermissionsBoundaryErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for PutUserPermissionsBoundaryError {
    fn code(&self) -> Option<&str> {
        PutUserPermissionsBoundaryError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl PutUserPermissionsBoundaryError {
    pub fn new(kind: PutUserPermissionsBoundaryErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: PutUserPermissionsBoundaryErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: PutUserPermissionsBoundaryErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_input_error(&self) -> bool {
        matches!(
            &self.kind,
            PutUserPermissionsBoundaryErrorKind::InvalidInputError(_)
        )
    }
    pub fn is_no_such_entity_error(&self) -> bool {
        matches!(
            &self.kind,
            PutUserPermissionsBoundaryErrorKind::NoSuchEntityError(_)
        )
    }
    pub fn is_policy_not_attachable_error(&self) -> bool {
        matches!(
            &self.kind,
            PutUserPermissionsBoundaryErrorKind::PolicyNotAttachableError(_)
        )
    }
    pub fn is_service_failure_error(&self) -> bool {
        matches!(
            &self.kind,
            PutUserPermissionsBoundaryErrorKind::ServiceFailureError(_)
        )
    }
}
impl std::error::Error for PutUserPermissionsBoundaryError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            PutUserPermissionsBoundaryErrorKind::InvalidInputError(_inner) => Some(_inner),
            PutUserPermissionsBoundaryErrorKind::NoSuchEntityError(_inner) => Some(_inner),
            PutUserPermissionsBoundaryErrorKind::PolicyNotAttachableError(_inner) => Some(_inner),
            PutUserPermissionsBoundaryErrorKind::ServiceFailureError(_inner) => Some(_inner),
            PutUserPermissionsBoundaryErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct PutUserPolicyError {
    pub kind: PutUserPolicyErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum PutUserPolicyErrorKind {
    LimitExceededError(crate::error::LimitExceededError),
    MalformedPolicyDocumentError(crate::error::MalformedPolicyDocumentError),
    NoSuchEntityError(crate::error::NoSuchEntityError),
    ServiceFailureError(crate::error::ServiceFailureError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for PutUserPolicyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            PutUserPolicyErrorKind::LimitExceededError(_inner) => _inner.fmt(f),
            PutUserPolicyErrorKind::MalformedPolicyDocumentError(_inner) => _inner.fmt(f),
            PutUserPolicyErrorKind::NoSuchEntityError(_inner) => _inner.fmt(f),
            PutUserPolicyErrorKind::ServiceFailureError(_inner) => _inner.fmt(f),
            PutUserPolicyErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for PutUserPolicyError {
    fn code(&self) -> Option<&str> {
        PutUserPolicyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl PutUserPolicyError {
    pub fn new(kind: PutUserPolicyErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: PutUserPolicyErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: PutUserPolicyErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_limit_exceeded_error(&self) -> bool {
        matches!(&self.kind, PutUserPolicyErrorKind::LimitExceededError(_))
    }
    pub fn is_malformed_policy_document_error(&self) -> bool {
        matches!(
            &self.kind,
            PutUserPolicyErrorKind::MalformedPolicyDocumentError(_)
        )
    }
    pub fn is_no_such_entity_error(&self) -> bool {
        matches!(&self.kind, PutUserPolicyErrorKind::NoSuchEntityError(_))
    }
    pub fn is_service_failure_error(&self) -> bool {
        matches!(&self.kind, PutUserPolicyErrorKind::ServiceFailureError(_))
    }
}
impl std::error::Error for PutUserPolicyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            PutUserPolicyErrorKind::LimitExceededError(_inner) => Some(_inner),
            PutUserPolicyErrorKind::MalformedPolicyDocumentError(_inner) => Some(_inner),
            PutUserPolicyErrorKind::NoSuchEntityError(_inner) => Some(_inner),
            PutUserPolicyErrorKind::ServiceFailureError(_inner) => Some(_inner),
            PutUserPolicyErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct RemoveClientIDFromOpenIDConnectProviderError {
    pub kind: RemoveClientIDFromOpenIDConnectProviderErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum RemoveClientIDFromOpenIDConnectProviderErrorKind {
    InvalidInputError(crate::error::InvalidInputError),
    NoSuchEntityError(crate::error::NoSuchEntityError),
    ServiceFailureError(crate::error::ServiceFailureError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for RemoveClientIDFromOpenIDConnectProviderError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            RemoveClientIDFromOpenIDConnectProviderErrorKind::InvalidInputError(_inner) => {
                _inner.fmt(f)
            }
            RemoveClientIDFromOpenIDConnectProviderErrorKind::NoSuchEntityError(_inner) => {
                _inner.fmt(f)
            }
            RemoveClientIDFromOpenIDConnectProviderErrorKind::ServiceFailureError(_inner) => {
                _inner.fmt(f)
            }
            RemoveClientIDFromOpenIDConnectProviderErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for RemoveClientIDFromOpenIDConnectProviderError {
    fn code(&self) -> Option<&str> {
        RemoveClientIDFromOpenIDConnectProviderError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl RemoveClientIDFromOpenIDConnectProviderError {
    pub fn new(
        kind: RemoveClientIDFromOpenIDConnectProviderErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: RemoveClientIDFromOpenIDConnectProviderErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: RemoveClientIDFromOpenIDConnectProviderErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_input_error(&self) -> bool {
        matches!(
            &self.kind,
            RemoveClientIDFromOpenIDConnectProviderErrorKind::InvalidInputError(_)
        )
    }
    pub fn is_no_such_entity_error(&self) -> bool {
        matches!(
            &self.kind,
            RemoveClientIDFromOpenIDConnectProviderErrorKind::NoSuchEntityError(_)
        )
    }
    pub fn is_service_failure_error(&self) -> bool {
        matches!(
            &self.kind,
            RemoveClientIDFromOpenIDConnectProviderErrorKind::ServiceFailureError(_)
        )
    }
}
impl std::error::Error for RemoveClientIDFromOpenIDConnectProviderError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            RemoveClientIDFromOpenIDConnectProviderErrorKind::InvalidInputError(_inner) => {
                Some(_inner)
            }
            RemoveClientIDFromOpenIDConnectProviderErrorKind::NoSuchEntityError(_inner) => {
                Some(_inner)
            }
            RemoveClientIDFromOpenIDConnectProviderErrorKind::ServiceFailureError(_inner) => {
                Some(_inner)
            }
            RemoveClientIDFromOpenIDConnectProviderErrorKind::Unhandled(_inner) => {
                Some(_inner.as_ref())
            }
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct RemoveRoleFromInstanceProfileError {
    pub kind: RemoveRoleFromInstanceProfileErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum RemoveRoleFromInstanceProfileErrorKind {
    LimitExceededError(crate::error::LimitExceededError),
    NoSuchEntityError(crate::error::NoSuchEntityError),
    ServiceFailureError(crate::error::ServiceFailureError),
    UnmodifiableEntityError(crate::error::UnmodifiableEntityError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for RemoveRoleFromInstanceProfileError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            RemoveRoleFromInstanceProfileErrorKind::LimitExceededError(_inner) => _inner.fmt(f),
            RemoveRoleFromInstanceProfileErrorKind::NoSuchEntityError(_inner) => _inner.fmt(f),
            RemoveRoleFromInstanceProfileErrorKind::ServiceFailureError(_inner) => _inner.fmt(f),
            RemoveRoleFromInstanceProfileErrorKind::UnmodifiableEntityError(_inner) => {
                _inner.fmt(f)
            }
            RemoveRoleFromInstanceProfileErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for RemoveRoleFromInstanceProfileError {
    fn code(&self) -> Option<&str> {
        RemoveRoleFromInstanceProfileError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl RemoveRoleFromInstanceProfileError {
    pub fn new(kind: RemoveRoleFromInstanceProfileErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: RemoveRoleFromInstanceProfileErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: RemoveRoleFromInstanceProfileErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_limit_exceeded_error(&self) -> bool {
        matches!(
            &self.kind,
            RemoveRoleFromInstanceProfileErrorKind::LimitExceededError(_)
        )
    }
    pub fn is_no_such_entity_error(&self) -> bool {
        matches!(
            &self.kind,
            RemoveRoleFromInstanceProfileErrorKind::NoSuchEntityError(_)
        )
    }
    pub fn is_service_failure_error(&self) -> bool {
        matches!(
            &self.kind,
            RemoveRoleFromInstanceProfileErrorKind::ServiceFailureError(_)
        )
    }
    pub fn is_unmodifiable_entity_error(&self) -> bool {
        matches!(
            &self.kind,
            RemoveRoleFromInstanceProfileErrorKind::UnmodifiableEntityError(_)
        )
    }
}
impl std::error::Error for RemoveRoleFromInstanceProfileError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            RemoveRoleFromInstanceProfileErrorKind::LimitExceededError(_inner) => Some(_inner),
            RemoveRoleFromInstanceProfileErrorKind::NoSuchEntityError(_inner) => Some(_inner),
            RemoveRoleFromInstanceProfileErrorKind::ServiceFailureError(_inner) => Some(_inner),
            RemoveRoleFromInstanceProfileErrorKind::UnmodifiableEntityError(_inner) => Some(_inner),
            RemoveRoleFromInstanceProfileErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct RemoveUserFromGroupError {
    pub kind: RemoveUserFromGroupErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum RemoveUserFromGroupErrorKind {
    LimitExceededError(crate::error::LimitExceededError),
    NoSuchEntityError(crate::error::NoSuchEntityError),
    ServiceFailureError(crate::error::ServiceFailureError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for RemoveUserFromGroupError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            RemoveUserFromGroupErrorKind::LimitExceededError(_inner) => _inner.fmt(f),
            RemoveUserFromGroupErrorKind::NoSuchEntityError(_inner) => _inner.fmt(f),
            RemoveUserFromGroupErrorKind::ServiceFailureError(_inner) => _inner.fmt(f),
            RemoveUserFromGroupErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for RemoveUserFromGroupError {
    fn code(&self) -> Option<&str> {
        RemoveUserFromGroupError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl RemoveUserFromGroupError {
    pub fn new(kind: RemoveUserFromGroupErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: RemoveUserFromGroupErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: RemoveUserFromGroupErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_limit_exceeded_error(&self) -> bool {
        matches!(
            &self.kind,
            RemoveUserFromGroupErrorKind::LimitExceededError(_)
        )
    }
    pub fn is_no_such_entity_error(&self) -> bool {
        matches!(
            &self.kind,
            RemoveUserFromGroupErrorKind::NoSuchEntityError(_)
        )
    }
    pub fn is_service_failure_error(&self) -> bool {
        matches!(
            &self.kind,
            RemoveUserFromGroupErrorKind::ServiceFailureError(_)
        )
    }
}
impl std::error::Error for RemoveUserFromGroupError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            RemoveUserFromGroupErrorKind::LimitExceededError(_inner) => Some(_inner),
            RemoveUserFromGroupErrorKind::NoSuchEntityError(_inner) => Some(_inner),
            RemoveUserFromGroupErrorKind::ServiceFailureError(_inner) => Some(_inner),
            RemoveUserFromGroupErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ResetServiceSpecificCredentialError {
    pub kind: ResetServiceSpecificCredentialErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ResetServiceSpecificCredentialErrorKind {
    NoSuchEntityError(crate::error::NoSuchEntityError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ResetServiceSpecificCredentialError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ResetServiceSpecificCredentialErrorKind::NoSuchEntityError(_inner) => _inner.fmt(f),
            ResetServiceSpecificCredentialErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ResetServiceSpecificCredentialError {
    fn code(&self) -> Option<&str> {
        ResetServiceSpecificCredentialError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ResetServiceSpecificCredentialError {
    pub fn new(kind: ResetServiceSpecificCredentialErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ResetServiceSpecificCredentialErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ResetServiceSpecificCredentialErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_no_such_entity_error(&self) -> bool {
        matches!(
            &self.kind,
            ResetServiceSpecificCredentialErrorKind::NoSuchEntityError(_)
        )
    }
}
impl std::error::Error for ResetServiceSpecificCredentialError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ResetServiceSpecificCredentialErrorKind::NoSuchEntityError(_inner) => Some(_inner),
            ResetServiceSpecificCredentialErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ResyncMFADeviceError {
    pub kind: ResyncMFADeviceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ResyncMFADeviceErrorKind {
    InvalidAuthenticationCodeError(crate::error::InvalidAuthenticationCodeError),
    LimitExceededError(crate::error::LimitExceededError),
    NoSuchEntityError(crate::error::NoSuchEntityError),
    ServiceFailureError(crate::error::ServiceFailureError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ResyncMFADeviceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ResyncMFADeviceErrorKind::InvalidAuthenticationCodeError(_inner) => _inner.fmt(f),
            ResyncMFADeviceErrorKind::LimitExceededError(_inner) => _inner.fmt(f),
            ResyncMFADeviceErrorKind::NoSuchEntityError(_inner) => _inner.fmt(f),
            ResyncMFADeviceErrorKind::ServiceFailureError(_inner) => _inner.fmt(f),
            ResyncMFADeviceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ResyncMFADeviceError {
    fn code(&self) -> Option<&str> {
        ResyncMFADeviceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ResyncMFADeviceError {
    pub fn new(kind: ResyncMFADeviceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ResyncMFADeviceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ResyncMFADeviceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_authentication_code_error(&self) -> bool {
        matches!(
            &self.kind,
            ResyncMFADeviceErrorKind::InvalidAuthenticationCodeError(_)
        )
    }
    pub fn is_limit_exceeded_error(&self) -> bool {
        matches!(&self.kind, ResyncMFADeviceErrorKind::LimitExceededError(_))
    }
    pub fn is_no_such_entity_error(&self) -> bool {
        matches!(&self.kind, ResyncMFADeviceErrorKind::NoSuchEntityError(_))
    }
    pub fn is_service_failure_error(&self) -> bool {
        matches!(&self.kind, ResyncMFADeviceErrorKind::ServiceFailureError(_))
    }
}
impl std::error::Error for ResyncMFADeviceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ResyncMFADeviceErrorKind::InvalidAuthenticationCodeError(_inner) => Some(_inner),
            ResyncMFADeviceErrorKind::LimitExceededError(_inner) => Some(_inner),
            ResyncMFADeviceErrorKind::NoSuchEntityError(_inner) => Some(_inner),
            ResyncMFADeviceErrorKind::ServiceFailureError(_inner) => Some(_inner),
            ResyncMFADeviceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct SetDefaultPolicyVersionError {
    pub kind: SetDefaultPolicyVersionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum SetDefaultPolicyVersionErrorKind {
    InvalidInputError(crate::error::InvalidInputError),
    LimitExceededError(crate::error::LimitExceededError),
    NoSuchEntityError(crate::error::NoSuchEntityError),
    ServiceFailureError(crate::error::ServiceFailureError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for SetDefaultPolicyVersionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            SetDefaultPolicyVersionErrorKind::InvalidInputError(_inner) => _inner.fmt(f),
            SetDefaultPolicyVersionErrorKind::LimitExceededError(_inner) => _inner.fmt(f),
            SetDefaultPolicyVersionErrorKind::NoSuchEntityError(_inner) => _inner.fmt(f),
            SetDefaultPolicyVersionErrorKind::ServiceFailureError(_inner) => _inner.fmt(f),
            SetDefaultPolicyVersionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for SetDefaultPolicyVersionError {
    fn code(&self) -> Option<&str> {
        SetDefaultPolicyVersionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl SetDefaultPolicyVersionError {
    pub fn new(kind: SetDefaultPolicyVersionErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: SetDefaultPolicyVersionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: SetDefaultPolicyVersionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_input_error(&self) -> bool {
        matches!(
            &self.kind,
            SetDefaultPolicyVersionErrorKind::InvalidInputError(_)
        )
    }
    pub fn is_limit_exceeded_error(&self) -> bool {
        matches!(
            &self.kind,
            SetDefaultPolicyVersionErrorKind::LimitExceededError(_)
        )
    }
    pub fn is_no_such_entity_error(&self) -> bool {
        matches!(
            &self.kind,
            SetDefaultPolicyVersionErrorKind::NoSuchEntityError(_)
        )
    }
    pub fn is_service_failure_error(&self) -> bool {
        matches!(
            &self.kind,
            SetDefaultPolicyVersionErrorKind::ServiceFailureError(_)
        )
    }
}
impl std::error::Error for SetDefaultPolicyVersionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            SetDefaultPolicyVersionErrorKind::InvalidInputError(_inner) => Some(_inner),
            SetDefaultPolicyVersionErrorKind::LimitExceededError(_inner) => Some(_inner),
            SetDefaultPolicyVersionErrorKind::NoSuchEntityError(_inner) => Some(_inner),
            SetDefaultPolicyVersionErrorKind::ServiceFailureError(_inner) => Some(_inner),
            SetDefaultPolicyVersionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct SetSecurityTokenServicePreferencesError {
    pub kind: SetSecurityTokenServicePreferencesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum SetSecurityTokenServicePreferencesErrorKind {
    ServiceFailureError(crate::error::ServiceFailureError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for SetSecurityTokenServicePreferencesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            SetSecurityTokenServicePreferencesErrorKind::ServiceFailureError(_inner) => {
                _inner.fmt(f)
            }
            SetSecurityTokenServicePreferencesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for SetSecurityTokenServicePreferencesError {
    fn code(&self) -> Option<&str> {
        SetSecurityTokenServicePreferencesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl SetSecurityTokenServicePreferencesError {
    pub fn new(
        kind: SetSecurityTokenServicePreferencesErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: SetSecurityTokenServicePreferencesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: SetSecurityTokenServicePreferencesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_service_failure_error(&self) -> bool {
        matches!(
            &self.kind,
            SetSecurityTokenServicePreferencesErrorKind::ServiceFailureError(_)
        )
    }
}
impl std::error::Error for SetSecurityTokenServicePreferencesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            SetSecurityTokenServicePreferencesErrorKind::ServiceFailureError(_inner) => {
                Some(_inner)
            }
            SetSecurityTokenServicePreferencesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct SimulateCustomPolicyError {
    pub kind: SimulateCustomPolicyErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum SimulateCustomPolicyErrorKind {
    InvalidInputError(crate::error::InvalidInputError),
    PolicyEvaluationError(crate::error::PolicyEvaluationError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for SimulateCustomPolicyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            SimulateCustomPolicyErrorKind::InvalidInputError(_inner) => _inner.fmt(f),
            SimulateCustomPolicyErrorKind::PolicyEvaluationError(_inner) => _inner.fmt(f),
            SimulateCustomPolicyErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for SimulateCustomPolicyError {
    fn code(&self) -> Option<&str> {
        SimulateCustomPolicyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl SimulateCustomPolicyError {
    pub fn new(kind: SimulateCustomPolicyErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: SimulateCustomPolicyErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: SimulateCustomPolicyErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_input_error(&self) -> bool {
        matches!(
            &self.kind,
            SimulateCustomPolicyErrorKind::InvalidInputError(_)
        )
    }
    pub fn is_policy_evaluation_error(&self) -> bool {
        matches!(
            &self.kind,
            SimulateCustomPolicyErrorKind::PolicyEvaluationError(_)
        )
    }
}
impl std::error::Error for SimulateCustomPolicyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            SimulateCustomPolicyErrorKind::InvalidInputError(_inner) => Some(_inner),
            SimulateCustomPolicyErrorKind::PolicyEvaluationError(_inner) => Some(_inner),
            SimulateCustomPolicyErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct SimulatePrincipalPolicyError {
    pub kind: SimulatePrincipalPolicyErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum SimulatePrincipalPolicyErrorKind {
    InvalidInputError(crate::error::InvalidInputError),
    NoSuchEntityError(crate::error::NoSuchEntityError),
    PolicyEvaluationError(crate::error::PolicyEvaluationError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for SimulatePrincipalPolicyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            SimulatePrincipalPolicyErrorKind::InvalidInputError(_inner) => _inner.fmt(f),
            SimulatePrincipalPolicyErrorKind::NoSuchEntityError(_inner) => _inner.fmt(f),
            SimulatePrincipalPolicyErrorKind::PolicyEvaluationError(_inner) => _inner.fmt(f),
            SimulatePrincipalPolicyErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for SimulatePrincipalPolicyError {
    fn code(&self) -> Option<&str> {
        SimulatePrincipalPolicyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl SimulatePrincipalPolicyError {
    pub fn new(kind: SimulatePrincipalPolicyErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: SimulatePrincipalPolicyErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: SimulatePrincipalPolicyErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_input_error(&self) -> bool {
        matches!(
            &self.kind,
            SimulatePrincipalPolicyErrorKind::InvalidInputError(_)
        )
    }
    pub fn is_no_such_entity_error(&self) -> bool {
        matches!(
            &self.kind,
            SimulatePrincipalPolicyErrorKind::NoSuchEntityError(_)
        )
    }
    pub fn is_policy_evaluation_error(&self) -> bool {
        matches!(
            &self.kind,
            SimulatePrincipalPolicyErrorKind::PolicyEvaluationError(_)
        )
    }
}
impl std::error::Error for SimulatePrincipalPolicyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            SimulatePrincipalPolicyErrorKind::InvalidInputError(_inner) => Some(_inner),
            SimulatePrincipalPolicyErrorKind::NoSuchEntityError(_inner) => Some(_inner),
            SimulatePrincipalPolicyErrorKind::PolicyEvaluationError(_inner) => Some(_inner),
            SimulatePrincipalPolicyErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct TagInstanceProfileError {
    pub kind: TagInstanceProfileErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum TagInstanceProfileErrorKind {
    ConcurrentModificationError(crate::error::ConcurrentModificationError),
    InvalidInputError(crate::error::InvalidInputError),
    LimitExceededError(crate::error::LimitExceededError),
    NoSuchEntityError(crate::error::NoSuchEntityError),
    ServiceFailureError(crate::error::ServiceFailureError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for TagInstanceProfileError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            TagInstanceProfileErrorKind::ConcurrentModificationError(_inner) => _inner.fmt(f),
            TagInstanceProfileErrorKind::InvalidInputError(_inner) => _inner.fmt(f),
            TagInstanceProfileErrorKind::LimitExceededError(_inner) => _inner.fmt(f),
            TagInstanceProfileErrorKind::NoSuchEntityError(_inner) => _inner.fmt(f),
            TagInstanceProfileErrorKind::ServiceFailureError(_inner) => _inner.fmt(f),
            TagInstanceProfileErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for TagInstanceProfileError {
    fn code(&self) -> Option<&str> {
        TagInstanceProfileError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl TagInstanceProfileError {
    pub fn new(kind: TagInstanceProfileErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: TagInstanceProfileErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: TagInstanceProfileErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_concurrent_modification_error(&self) -> bool {
        matches!(
            &self.kind,
            TagInstanceProfileErrorKind::ConcurrentModificationError(_)
        )
    }
    pub fn is_invalid_input_error(&self) -> bool {
        matches!(
            &self.kind,
            TagInstanceProfileErrorKind::InvalidInputError(_)
        )
    }
    pub fn is_limit_exceeded_error(&self) -> bool {
        matches!(
            &self.kind,
            TagInstanceProfileErrorKind::LimitExceededError(_)
        )
    }
    pub fn is_no_such_entity_error(&self) -> bool {
        matches!(
            &self.kind,
            TagInstanceProfileErrorKind::NoSuchEntityError(_)
        )
    }
    pub fn is_service_failure_error(&self) -> bool {
        matches!(
            &self.kind,
            TagInstanceProfileErrorKind::ServiceFailureError(_)
        )
    }
}
impl std::error::Error for TagInstanceProfileError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            TagInstanceProfileErrorKind::ConcurrentModificationError(_inner) => Some(_inner),
            TagInstanceProfileErrorKind::InvalidInputError(_inner) => Some(_inner),
            TagInstanceProfileErrorKind::LimitExceededError(_inner) => Some(_inner),
            TagInstanceProfileErrorKind::NoSuchEntityError(_inner) => Some(_inner),
            TagInstanceProfileErrorKind::ServiceFailureError(_inner) => Some(_inner),
            TagInstanceProfileErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct TagMFADeviceError {
    pub kind: TagMFADeviceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum TagMFADeviceErrorKind {
    ConcurrentModificationError(crate::error::ConcurrentModificationError),
    InvalidInputError(crate::error::InvalidInputError),
    LimitExceededError(crate::error::LimitExceededError),
    NoSuchEntityError(crate::error::NoSuchEntityError),
    ServiceFailureError(crate::error::ServiceFailureError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for TagMFADeviceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            TagMFADeviceErrorKind::ConcurrentModificationError(_inner) => _inner.fmt(f),
            TagMFADeviceErrorKind::InvalidInputError(_inner) => _inner.fmt(f),
            TagMFADeviceErrorKind::LimitExceededError(_inner) => _inner.fmt(f),
            TagMFADeviceErrorKind::NoSuchEntityError(_inner) => _inner.fmt(f),
            TagMFADeviceErrorKind::ServiceFailureError(_inner) => _inner.fmt(f),
            TagMFADeviceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for TagMFADeviceError {
    fn code(&self) -> Option<&str> {
        TagMFADeviceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl TagMFADeviceError {
    pub fn new(kind: TagMFADeviceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: TagMFADeviceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: TagMFADeviceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_concurrent_modification_error(&self) -> bool {
        matches!(
            &self.kind,
            TagMFADeviceErrorKind::ConcurrentModificationError(_)
        )
    }
    pub fn is_invalid_input_error(&self) -> bool {
        matches!(&self.kind, TagMFADeviceErrorKind::InvalidInputError(_))
    }
    pub fn is_limit_exceeded_error(&self) -> bool {
        matches!(&self.kind, TagMFADeviceErrorKind::LimitExceededError(_))
    }
    pub fn is_no_such_entity_error(&self) -> bool {
        matches!(&self.kind, TagMFADeviceErrorKind::NoSuchEntityError(_))
    }
    pub fn is_service_failure_error(&self) -> bool {
        matches!(&self.kind, TagMFADeviceErrorKind::ServiceFailureError(_))
    }
}
impl std::error::Error for TagMFADeviceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            TagMFADeviceErrorKind::ConcurrentModificationError(_inner) => Some(_inner),
            TagMFADeviceErrorKind::InvalidInputError(_inner) => Some(_inner),
            TagMFADeviceErrorKind::LimitExceededError(_inner) => Some(_inner),
            TagMFADeviceErrorKind::NoSuchEntityError(_inner) => Some(_inner),
            TagMFADeviceErrorKind::ServiceFailureError(_inner) => Some(_inner),
            TagMFADeviceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct TagOpenIDConnectProviderError {
    pub kind: TagOpenIDConnectProviderErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum TagOpenIDConnectProviderErrorKind {
    ConcurrentModificationError(crate::error::ConcurrentModificationError),
    InvalidInputError(crate::error::InvalidInputError),
    LimitExceededError(crate::error::LimitExceededError),
    NoSuchEntityError(crate::error::NoSuchEntityError),
    ServiceFailureError(crate::error::ServiceFailureError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for TagOpenIDConnectProviderError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            TagOpenIDConnectProviderErrorKind::ConcurrentModificationError(_inner) => _inner.fmt(f),
            TagOpenIDConnectProviderErrorKind::InvalidInputError(_inner) => _inner.fmt(f),
            TagOpenIDConnectProviderErrorKind::LimitExceededError(_inner) => _inner.fmt(f),
            TagOpenIDConnectProviderErrorKind::NoSuchEntityError(_inner) => _inner.fmt(f),
            TagOpenIDConnectProviderErrorKind::ServiceFailureError(_inner) => _inner.fmt(f),
            TagOpenIDConnectProviderErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for TagOpenIDConnectProviderError {
    fn code(&self) -> Option<&str> {
        TagOpenIDConnectProviderError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl TagOpenIDConnectProviderError {
    pub fn new(kind: TagOpenIDConnectProviderErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: TagOpenIDConnectProviderErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: TagOpenIDConnectProviderErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_concurrent_modification_error(&self) -> bool {
        matches!(
            &self.kind,
            TagOpenIDConnectProviderErrorKind::ConcurrentModificationError(_)
        )
    }
    pub fn is_invalid_input_error(&self) -> bool {
        matches!(
            &self.kind,
            TagOpenIDConnectProviderErrorKind::InvalidInputError(_)
        )
    }
    pub fn is_limit_exceeded_error(&self) -> bool {
        matches!(
            &self.kind,
            TagOpenIDConnectProviderErrorKind::LimitExceededError(_)
        )
    }
    pub fn is_no_such_entity_error(&self) -> bool {
        matches!(
            &self.kind,
            TagOpenIDConnectProviderErrorKind::NoSuchEntityError(_)
        )
    }
    pub fn is_service_failure_error(&self) -> bool {
        matches!(
            &self.kind,
            TagOpenIDConnectProviderErrorKind::ServiceFailureError(_)
        )
    }
}
impl std::error::Error for TagOpenIDConnectProviderError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            TagOpenIDConnectProviderErrorKind::ConcurrentModificationError(_inner) => Some(_inner),
            TagOpenIDConnectProviderErrorKind::InvalidInputError(_inner) => Some(_inner),
            TagOpenIDConnectProviderErrorKind::LimitExceededError(_inner) => Some(_inner),
            TagOpenIDConnectProviderErrorKind::NoSuchEntityError(_inner) => Some(_inner),
            TagOpenIDConnectProviderErrorKind::ServiceFailureError(_inner) => Some(_inner),
            TagOpenIDConnectProviderErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct TagPolicyError {
    pub kind: TagPolicyErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum TagPolicyErrorKind {
    ConcurrentModificationError(crate::error::ConcurrentModificationError),
    InvalidInputError(crate::error::InvalidInputError),
    LimitExceededError(crate::error::LimitExceededError),
    NoSuchEntityError(crate::error::NoSuchEntityError),
    ServiceFailureError(crate::error::ServiceFailureError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for TagPolicyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            TagPolicyErrorKind::ConcurrentModificationError(_inner) => _inner.fmt(f),
            TagPolicyErrorKind::InvalidInputError(_inner) => _inner.fmt(f),
            TagPolicyErrorKind::LimitExceededError(_inner) => _inner.fmt(f),
            TagPolicyErrorKind::NoSuchEntityError(_inner) => _inner.fmt(f),
            TagPolicyErrorKind::ServiceFailureError(_inner) => _inner.fmt(f),
            TagPolicyErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for TagPolicyError {
    fn code(&self) -> Option<&str> {
        TagPolicyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl TagPolicyError {
    pub fn new(kind: TagPolicyErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: TagPolicyErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: TagPolicyErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_concurrent_modification_error(&self) -> bool {
        matches!(
            &self.kind,
            TagPolicyErrorKind::ConcurrentModificationError(_)
        )
    }
    pub fn is_invalid_input_error(&self) -> bool {
        matches!(&self.kind, TagPolicyErrorKind::InvalidInputError(_))
    }
    pub fn is_limit_exceeded_error(&self) -> bool {
        matches!(&self.kind, TagPolicyErrorKind::LimitExceededError(_))
    }
    pub fn is_no_such_entity_error(&self) -> bool {
        matches!(&self.kind, TagPolicyErrorKind::NoSuchEntityError(_))
    }
    pub fn is_service_failure_error(&self) -> bool {
        matches!(&self.kind, TagPolicyErrorKind::ServiceFailureError(_))
    }
}
impl std::error::Error for TagPolicyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            TagPolicyErrorKind::ConcurrentModificationError(_inner) => Some(_inner),
            TagPolicyErrorKind::InvalidInputError(_inner) => Some(_inner),
            TagPolicyErrorKind::LimitExceededError(_inner) => Some(_inner),
            TagPolicyErrorKind::NoSuchEntityError(_inner) => Some(_inner),
            TagPolicyErrorKind::ServiceFailureError(_inner) => Some(_inner),
            TagPolicyErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct TagRoleError {
    pub kind: TagRoleErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum TagRoleErrorKind {
    ConcurrentModificationError(crate::error::ConcurrentModificationError),
    InvalidInputError(crate::error::InvalidInputError),
    LimitExceededError(crate::error::LimitExceededError),
    NoSuchEntityError(crate::error::NoSuchEntityError),
    ServiceFailureError(crate::error::ServiceFailureError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for TagRoleError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            TagRoleErrorKind::ConcurrentModificationError(_inner) => _inner.fmt(f),
            TagRoleErrorKind::InvalidInputError(_inner) => _inner.fmt(f),
            TagRoleErrorKind::LimitExceededError(_inner) => _inner.fmt(f),
            TagRoleErrorKind::NoSuchEntityError(_inner) => _inner.fmt(f),
            TagRoleErrorKind::ServiceFailureError(_inner) => _inner.fmt(f),
            TagRoleErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for TagRoleError {
    fn code(&self) -> Option<&str> {
        TagRoleError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl TagRoleError {
    pub fn new(kind: TagRoleErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: TagRoleErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: TagRoleErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_concurrent_modification_error(&self) -> bool {
        matches!(&self.kind, TagRoleErrorKind::ConcurrentModificationError(_))
    }
    pub fn is_invalid_input_error(&self) -> bool {
        matches!(&self.kind, TagRoleErrorKind::InvalidInputError(_))
    }
    pub fn is_limit_exceeded_error(&self) -> bool {
        matches!(&self.kind, TagRoleErrorKind::LimitExceededError(_))
    }
    pub fn is_no_such_entity_error(&self) -> bool {
        matches!(&self.kind, TagRoleErrorKind::NoSuchEntityError(_))
    }
    pub fn is_service_failure_error(&self) -> bool {
        matches!(&self.kind, TagRoleErrorKind::ServiceFailureError(_))
    }
}
impl std::error::Error for TagRoleError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            TagRoleErrorKind::ConcurrentModificationError(_inner) => Some(_inner),
            TagRoleErrorKind::InvalidInputError(_inner) => Some(_inner),
            TagRoleErrorKind::LimitExceededError(_inner) => Some(_inner),
            TagRoleErrorKind::NoSuchEntityError(_inner) => Some(_inner),
            TagRoleErrorKind::ServiceFailureError(_inner) => Some(_inner),
            TagRoleErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct TagSAMLProviderError {
    pub kind: TagSAMLProviderErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum TagSAMLProviderErrorKind {
    ConcurrentModificationError(crate::error::ConcurrentModificationError),
    InvalidInputError(crate::error::InvalidInputError),
    LimitExceededError(crate::error::LimitExceededError),
    NoSuchEntityError(crate::error::NoSuchEntityError),
    ServiceFailureError(crate::error::ServiceFailureError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for TagSAMLProviderError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            TagSAMLProviderErrorKind::ConcurrentModificationError(_inner) => _inner.fmt(f),
            TagSAMLProviderErrorKind::InvalidInputError(_inner) => _inner.fmt(f),
            TagSAMLProviderErrorKind::LimitExceededError(_inner) => _inner.fmt(f),
            TagSAMLProviderErrorKind::NoSuchEntityError(_inner) => _inner.fmt(f),
            TagSAMLProviderErrorKind::ServiceFailureError(_inner) => _inner.fmt(f),
            TagSAMLProviderErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for TagSAMLProviderError {
    fn code(&self) -> Option<&str> {
        TagSAMLProviderError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl TagSAMLProviderError {
    pub fn new(kind: TagSAMLProviderErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: TagSAMLProviderErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: TagSAMLProviderErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_concurrent_modification_error(&self) -> bool {
        matches!(
            &self.kind,
            TagSAMLProviderErrorKind::ConcurrentModificationError(_)
        )
    }
    pub fn is_invalid_input_error(&self) -> bool {
        matches!(&self.kind, TagSAMLProviderErrorKind::InvalidInputError(_))
    }
    pub fn is_limit_exceeded_error(&self) -> bool {
        matches!(&self.kind, TagSAMLProviderErrorKind::LimitExceededError(_))
    }
    pub fn is_no_such_entity_error(&self) -> bool {
        matches!(&self.kind, TagSAMLProviderErrorKind::NoSuchEntityError(_))
    }
    pub fn is_service_failure_error(&self) -> bool {
        matches!(&self.kind, TagSAMLProviderErrorKind::ServiceFailureError(_))
    }
}
impl std::error::Error for TagSAMLProviderError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            TagSAMLProviderErrorKind::ConcurrentModificationError(_inner) => Some(_inner),
            TagSAMLProviderErrorKind::InvalidInputError(_inner) => Some(_inner),
            TagSAMLProviderErrorKind::LimitExceededError(_inner) => Some(_inner),
            TagSAMLProviderErrorKind::NoSuchEntityError(_inner) => Some(_inner),
            TagSAMLProviderErrorKind::ServiceFailureError(_inner) => Some(_inner),
            TagSAMLProviderErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct TagServerCertificateError {
    pub kind: TagServerCertificateErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum TagServerCertificateErrorKind {
    ConcurrentModificationError(crate::error::ConcurrentModificationError),
    InvalidInputError(crate::error::InvalidInputError),
    LimitExceededError(crate::error::LimitExceededError),
    NoSuchEntityError(crate::error::NoSuchEntityError),
    ServiceFailureError(crate::error::ServiceFailureError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for TagServerCertificateError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            TagServerCertificateErrorKind::ConcurrentModificationError(_inner) => _inner.fmt(f),
            TagServerCertificateErrorKind::InvalidInputError(_inner) => _inner.fmt(f),
            TagServerCertificateErrorKind::LimitExceededError(_inner) => _inner.fmt(f),
            TagServerCertificateErrorKind::NoSuchEntityError(_inner) => _inner.fmt(f),
            TagServerCertificateErrorKind::ServiceFailureError(_inner) => _inner.fmt(f),
            TagServerCertificateErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for TagServerCertificateError {
    fn code(&self) -> Option<&str> {
        TagServerCertificateError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl TagServerCertificateError {
    pub fn new(kind: TagServerCertificateErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: TagServerCertificateErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: TagServerCertificateErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_concurrent_modification_error(&self) -> bool {
        matches!(
            &self.kind,
            TagServerCertificateErrorKind::ConcurrentModificationError(_)
        )
    }
    pub fn is_invalid_input_error(&self) -> bool {
        matches!(
            &self.kind,
            TagServerCertificateErrorKind::InvalidInputError(_)
        )
    }
    pub fn is_limit_exceeded_error(&self) -> bool {
        matches!(
            &self.kind,
            TagServerCertificateErrorKind::LimitExceededError(_)
        )
    }
    pub fn is_no_such_entity_error(&self) -> bool {
        matches!(
            &self.kind,
            TagServerCertificateErrorKind::NoSuchEntityError(_)
        )
    }
    pub fn is_service_failure_error(&self) -> bool {
        matches!(
            &self.kind,
            TagServerCertificateErrorKind::ServiceFailureError(_)
        )
    }
}
impl std::error::Error for TagServerCertificateError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            TagServerCertificateErrorKind::ConcurrentModificationError(_inner) => Some(_inner),
            TagServerCertificateErrorKind::InvalidInputError(_inner) => Some(_inner),
            TagServerCertificateErrorKind::LimitExceededError(_inner) => Some(_inner),
            TagServerCertificateErrorKind::NoSuchEntityError(_inner) => Some(_inner),
            TagServerCertificateErrorKind::ServiceFailureError(_inner) => Some(_inner),
            TagServerCertificateErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct TagUserError {
    pub kind: TagUserErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum TagUserErrorKind {
    ConcurrentModificationError(crate::error::ConcurrentModificationError),
    InvalidInputError(crate::error::InvalidInputError),
    LimitExceededError(crate::error::LimitExceededError),
    NoSuchEntityError(crate::error::NoSuchEntityError),
    ServiceFailureError(crate::error::ServiceFailureError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for TagUserError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            TagUserErrorKind::ConcurrentModificationError(_inner) => _inner.fmt(f),
            TagUserErrorKind::InvalidInputError(_inner) => _inner.fmt(f),
            TagUserErrorKind::LimitExceededError(_inner) => _inner.fmt(f),
            TagUserErrorKind::NoSuchEntityError(_inner) => _inner.fmt(f),
            TagUserErrorKind::ServiceFailureError(_inner) => _inner.fmt(f),
            TagUserErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for TagUserError {
    fn code(&self) -> Option<&str> {
        TagUserError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl TagUserError {
    pub fn new(kind: TagUserErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: TagUserErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: TagUserErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_concurrent_modification_error(&self) -> bool {
        matches!(&self.kind, TagUserErrorKind::ConcurrentModificationError(_))
    }
    pub fn is_invalid_input_error(&self) -> bool {
        matches!(&self.kind, TagUserErrorKind::InvalidInputError(_))
    }
    pub fn is_limit_exceeded_error(&self) -> bool {
        matches!(&self.kind, TagUserErrorKind::LimitExceededError(_))
    }
    pub fn is_no_such_entity_error(&self) -> bool {
        matches!(&self.kind, TagUserErrorKind::NoSuchEntityError(_))
    }
    pub fn is_service_failure_error(&self) -> bool {
        matches!(&self.kind, TagUserErrorKind::ServiceFailureError(_))
    }
}
impl std::error::Error for TagUserError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            TagUserErrorKind::ConcurrentModificationError(_inner) => Some(_inner),
            TagUserErrorKind::InvalidInputError(_inner) => Some(_inner),
            TagUserErrorKind::LimitExceededError(_inner) => Some(_inner),
            TagUserErrorKind::NoSuchEntityError(_inner) => Some(_inner),
            TagUserErrorKind::ServiceFailureError(_inner) => Some(_inner),
            TagUserErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UntagInstanceProfileError {
    pub kind: UntagInstanceProfileErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UntagInstanceProfileErrorKind {
    ConcurrentModificationError(crate::error::ConcurrentModificationError),
    InvalidInputError(crate::error::InvalidInputError),
    NoSuchEntityError(crate::error::NoSuchEntityError),
    ServiceFailureError(crate::error::ServiceFailureError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UntagInstanceProfileError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UntagInstanceProfileErrorKind::ConcurrentModificationError(_inner) => _inner.fmt(f),
            UntagInstanceProfileErrorKind::InvalidInputError(_inner) => _inner.fmt(f),
            UntagInstanceProfileErrorKind::NoSuchEntityError(_inner) => _inner.fmt(f),
            UntagInstanceProfileErrorKind::ServiceFailureError(_inner) => _inner.fmt(f),
            UntagInstanceProfileErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UntagInstanceProfileError {
    fn code(&self) -> Option<&str> {
        UntagInstanceProfileError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UntagInstanceProfileError {
    pub fn new(kind: UntagInstanceProfileErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UntagInstanceProfileErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UntagInstanceProfileErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_concurrent_modification_error(&self) -> bool {
        matches!(
            &self.kind,
            UntagInstanceProfileErrorKind::ConcurrentModificationError(_)
        )
    }
    pub fn is_invalid_input_error(&self) -> bool {
        matches!(
            &self.kind,
            UntagInstanceProfileErrorKind::InvalidInputError(_)
        )
    }
    pub fn is_no_such_entity_error(&self) -> bool {
        matches!(
            &self.kind,
            UntagInstanceProfileErrorKind::NoSuchEntityError(_)
        )
    }
    pub fn is_service_failure_error(&self) -> bool {
        matches!(
            &self.kind,
            UntagInstanceProfileErrorKind::ServiceFailureError(_)
        )
    }
}
impl std::error::Error for UntagInstanceProfileError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UntagInstanceProfileErrorKind::ConcurrentModificationError(_inner) => Some(_inner),
            UntagInstanceProfileErrorKind::InvalidInputError(_inner) => Some(_inner),
            UntagInstanceProfileErrorKind::NoSuchEntityError(_inner) => Some(_inner),
            UntagInstanceProfileErrorKind::ServiceFailureError(_inner) => Some(_inner),
            UntagInstanceProfileErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UntagMFADeviceError {
    pub kind: UntagMFADeviceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UntagMFADeviceErrorKind {
    ConcurrentModificationError(crate::error::ConcurrentModificationError),
    InvalidInputError(crate::error::InvalidInputError),
    NoSuchEntityError(crate::error::NoSuchEntityError),
    ServiceFailureError(crate::error::ServiceFailureError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UntagMFADeviceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UntagMFADeviceErrorKind::ConcurrentModificationError(_inner) => _inner.fmt(f),
            UntagMFADeviceErrorKind::InvalidInputError(_inner) => _inner.fmt(f),
            UntagMFADeviceErrorKind::NoSuchEntityError(_inner) => _inner.fmt(f),
            UntagMFADeviceErrorKind::ServiceFailureError(_inner) => _inner.fmt(f),
            UntagMFADeviceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UntagMFADeviceError {
    fn code(&self) -> Option<&str> {
        UntagMFADeviceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UntagMFADeviceError {
    pub fn new(kind: UntagMFADeviceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UntagMFADeviceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UntagMFADeviceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_concurrent_modification_error(&self) -> bool {
        matches!(
            &self.kind,
            UntagMFADeviceErrorKind::ConcurrentModificationError(_)
        )
    }
    pub fn is_invalid_input_error(&self) -> bool {
        matches!(&self.kind, UntagMFADeviceErrorKind::InvalidInputError(_))
    }
    pub fn is_no_such_entity_error(&self) -> bool {
        matches!(&self.kind, UntagMFADeviceErrorKind::NoSuchEntityError(_))
    }
    pub fn is_service_failure_error(&self) -> bool {
        matches!(&self.kind, UntagMFADeviceErrorKind::ServiceFailureError(_))
    }
}
impl std::error::Error for UntagMFADeviceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UntagMFADeviceErrorKind::ConcurrentModificationError(_inner) => Some(_inner),
            UntagMFADeviceErrorKind::InvalidInputError(_inner) => Some(_inner),
            UntagMFADeviceErrorKind::NoSuchEntityError(_inner) => Some(_inner),
            UntagMFADeviceErrorKind::ServiceFailureError(_inner) => Some(_inner),
            UntagMFADeviceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UntagOpenIDConnectProviderError {
    pub kind: UntagOpenIDConnectProviderErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UntagOpenIDConnectProviderErrorKind {
    ConcurrentModificationError(crate::error::ConcurrentModificationError),
    InvalidInputError(crate::error::InvalidInputError),
    NoSuchEntityError(crate::error::NoSuchEntityError),
    ServiceFailureError(crate::error::ServiceFailureError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UntagOpenIDConnectProviderError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UntagOpenIDConnectProviderErrorKind::ConcurrentModificationError(_inner) => {
                _inner.fmt(f)
            }
            UntagOpenIDConnectProviderErrorKind::InvalidInputError(_inner) => _inner.fmt(f),
            UntagOpenIDConnectProviderErrorKind::NoSuchEntityError(_inner) => _inner.fmt(f),
            UntagOpenIDConnectProviderErrorKind::ServiceFailureError(_inner) => _inner.fmt(f),
            UntagOpenIDConnectProviderErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UntagOpenIDConnectProviderError {
    fn code(&self) -> Option<&str> {
        UntagOpenIDConnectProviderError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UntagOpenIDConnectProviderError {
    pub fn new(kind: UntagOpenIDConnectProviderErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UntagOpenIDConnectProviderErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UntagOpenIDConnectProviderErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_concurrent_modification_error(&self) -> bool {
        matches!(
            &self.kind,
            UntagOpenIDConnectProviderErrorKind::ConcurrentModificationError(_)
        )
    }
    pub fn is_invalid_input_error(&self) -> bool {
        matches!(
            &self.kind,
            UntagOpenIDConnectProviderErrorKind::InvalidInputError(_)
        )
    }
    pub fn is_no_such_entity_error(&self) -> bool {
        matches!(
            &self.kind,
            UntagOpenIDConnectProviderErrorKind::NoSuchEntityError(_)
        )
    }
    pub fn is_service_failure_error(&self) -> bool {
        matches!(
            &self.kind,
            UntagOpenIDConnectProviderErrorKind::ServiceFailureError(_)
        )
    }
}
impl std::error::Error for UntagOpenIDConnectProviderError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UntagOpenIDConnectProviderErrorKind::ConcurrentModificationError(_inner) => {
                Some(_inner)
            }
            UntagOpenIDConnectProviderErrorKind::InvalidInputError(_inner) => Some(_inner),
            UntagOpenIDConnectProviderErrorKind::NoSuchEntityError(_inner) => Some(_inner),
            UntagOpenIDConnectProviderErrorKind::ServiceFailureError(_inner) => Some(_inner),
            UntagOpenIDConnectProviderErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UntagPolicyError {
    pub kind: UntagPolicyErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UntagPolicyErrorKind {
    ConcurrentModificationError(crate::error::ConcurrentModificationError),
    InvalidInputError(crate::error::InvalidInputError),
    NoSuchEntityError(crate::error::NoSuchEntityError),
    ServiceFailureError(crate::error::ServiceFailureError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UntagPolicyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UntagPolicyErrorKind::ConcurrentModificationError(_inner) => _inner.fmt(f),
            UntagPolicyErrorKind::InvalidInputError(_inner) => _inner.fmt(f),
            UntagPolicyErrorKind::NoSuchEntityError(_inner) => _inner.fmt(f),
            UntagPolicyErrorKind::ServiceFailureError(_inner) => _inner.fmt(f),
            UntagPolicyErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UntagPolicyError {
    fn code(&self) -> Option<&str> {
        UntagPolicyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UntagPolicyError {
    pub fn new(kind: UntagPolicyErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UntagPolicyErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UntagPolicyErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_concurrent_modification_error(&self) -> bool {
        matches!(
            &self.kind,
            UntagPolicyErrorKind::ConcurrentModificationError(_)
        )
    }
    pub fn is_invalid_input_error(&self) -> bool {
        matches!(&self.kind, UntagPolicyErrorKind::InvalidInputError(_))
    }
    pub fn is_no_such_entity_error(&self) -> bool {
        matches!(&self.kind, UntagPolicyErrorKind::NoSuchEntityError(_))
    }
    pub fn is_service_failure_error(&self) -> bool {
        matches!(&self.kind, UntagPolicyErrorKind::ServiceFailureError(_))
    }
}
impl std::error::Error for UntagPolicyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UntagPolicyErrorKind::ConcurrentModificationError(_inner) => Some(_inner),
            UntagPolicyErrorKind::InvalidInputError(_inner) => Some(_inner),
            UntagPolicyErrorKind::NoSuchEntityError(_inner) => Some(_inner),
            UntagPolicyErrorKind::ServiceFailureError(_inner) => Some(_inner),
            UntagPolicyErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UntagRoleError {
    pub kind: UntagRoleErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UntagRoleErrorKind {
    ConcurrentModificationError(crate::error::ConcurrentModificationError),
    NoSuchEntityError(crate::error::NoSuchEntityError),
    ServiceFailureError(crate::error::ServiceFailureError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UntagRoleError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UntagRoleErrorKind::ConcurrentModificationError(_inner) => _inner.fmt(f),
            UntagRoleErrorKind::NoSuchEntityError(_inner) => _inner.fmt(f),
            UntagRoleErrorKind::ServiceFailureError(_inner) => _inner.fmt(f),
            UntagRoleErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UntagRoleError {
    fn code(&self) -> Option<&str> {
        UntagRoleError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UntagRoleError {
    pub fn new(kind: UntagRoleErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UntagRoleErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UntagRoleErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_concurrent_modification_error(&self) -> bool {
        matches!(
            &self.kind,
            UntagRoleErrorKind::ConcurrentModificationError(_)
        )
    }
    pub fn is_no_such_entity_error(&self) -> bool {
        matches!(&self.kind, UntagRoleErrorKind::NoSuchEntityError(_))
    }
    pub fn is_service_failure_error(&self) -> bool {
        matches!(&self.kind, UntagRoleErrorKind::ServiceFailureError(_))
    }
}
impl std::error::Error for UntagRoleError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UntagRoleErrorKind::ConcurrentModificationError(_inner) => Some(_inner),
            UntagRoleErrorKind::NoSuchEntityError(_inner) => Some(_inner),
            UntagRoleErrorKind::ServiceFailureError(_inner) => Some(_inner),
            UntagRoleErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UntagSAMLProviderError {
    pub kind: UntagSAMLProviderErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UntagSAMLProviderErrorKind {
    ConcurrentModificationError(crate::error::ConcurrentModificationError),
    InvalidInputError(crate::error::InvalidInputError),
    NoSuchEntityError(crate::error::NoSuchEntityError),
    ServiceFailureError(crate::error::ServiceFailureError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UntagSAMLProviderError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UntagSAMLProviderErrorKind::ConcurrentModificationError(_inner) => _inner.fmt(f),
            UntagSAMLProviderErrorKind::InvalidInputError(_inner) => _inner.fmt(f),
            UntagSAMLProviderErrorKind::NoSuchEntityError(_inner) => _inner.fmt(f),
            UntagSAMLProviderErrorKind::ServiceFailureError(_inner) => _inner.fmt(f),
            UntagSAMLProviderErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UntagSAMLProviderError {
    fn code(&self) -> Option<&str> {
        UntagSAMLProviderError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UntagSAMLProviderError {
    pub fn new(kind: UntagSAMLProviderErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UntagSAMLProviderErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UntagSAMLProviderErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_concurrent_modification_error(&self) -> bool {
        matches!(
            &self.kind,
            UntagSAMLProviderErrorKind::ConcurrentModificationError(_)
        )
    }
    pub fn is_invalid_input_error(&self) -> bool {
        matches!(&self.kind, UntagSAMLProviderErrorKind::InvalidInputError(_))
    }
    pub fn is_no_such_entity_error(&self) -> bool {
        matches!(&self.kind, UntagSAMLProviderErrorKind::NoSuchEntityError(_))
    }
    pub fn is_service_failure_error(&self) -> bool {
        matches!(
            &self.kind,
            UntagSAMLProviderErrorKind::ServiceFailureError(_)
        )
    }
}
impl std::error::Error for UntagSAMLProviderError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UntagSAMLProviderErrorKind::ConcurrentModificationError(_inner) => Some(_inner),
            UntagSAMLProviderErrorKind::InvalidInputError(_inner) => Some(_inner),
            UntagSAMLProviderErrorKind::NoSuchEntityError(_inner) => Some(_inner),
            UntagSAMLProviderErrorKind::ServiceFailureError(_inner) => Some(_inner),
            UntagSAMLProviderErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UntagServerCertificateError {
    pub kind: UntagServerCertificateErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UntagServerCertificateErrorKind {
    ConcurrentModificationError(crate::error::ConcurrentModificationError),
    InvalidInputError(crate::error::InvalidInputError),
    NoSuchEntityError(crate::error::NoSuchEntityError),
    ServiceFailureError(crate::error::ServiceFailureError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UntagServerCertificateError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UntagServerCertificateErrorKind::ConcurrentModificationError(_inner) => _inner.fmt(f),
            UntagServerCertificateErrorKind::InvalidInputError(_inner) => _inner.fmt(f),
            UntagServerCertificateErrorKind::NoSuchEntityError(_inner) => _inner.fmt(f),
            UntagServerCertificateErrorKind::ServiceFailureError(_inner) => _inner.fmt(f),
            UntagServerCertificateErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UntagServerCertificateError {
    fn code(&self) -> Option<&str> {
        UntagServerCertificateError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UntagServerCertificateError {
    pub fn new(kind: UntagServerCertificateErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UntagServerCertificateErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UntagServerCertificateErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_concurrent_modification_error(&self) -> bool {
        matches!(
            &self.kind,
            UntagServerCertificateErrorKind::ConcurrentModificationError(_)
        )
    }
    pub fn is_invalid_input_error(&self) -> bool {
        matches!(
            &self.kind,
            UntagServerCertificateErrorKind::InvalidInputError(_)
        )
    }
    pub fn is_no_such_entity_error(&self) -> bool {
        matches!(
            &self.kind,
            UntagServerCertificateErrorKind::NoSuchEntityError(_)
        )
    }
    pub fn is_service_failure_error(&self) -> bool {
        matches!(
            &self.kind,
            UntagServerCertificateErrorKind::ServiceFailureError(_)
        )
    }
}
impl std::error::Error for UntagServerCertificateError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UntagServerCertificateErrorKind::ConcurrentModificationError(_inner) => Some(_inner),
            UntagServerCertificateErrorKind::InvalidInputError(_inner) => Some(_inner),
            UntagServerCertificateErrorKind::NoSuchEntityError(_inner) => Some(_inner),
            UntagServerCertificateErrorKind::ServiceFailureError(_inner) => Some(_inner),
            UntagServerCertificateErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UntagUserError {
    pub kind: UntagUserErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UntagUserErrorKind {
    ConcurrentModificationError(crate::error::ConcurrentModificationError),
    NoSuchEntityError(crate::error::NoSuchEntityError),
    ServiceFailureError(crate::error::ServiceFailureError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UntagUserError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UntagUserErrorKind::ConcurrentModificationError(_inner) => _inner.fmt(f),
            UntagUserErrorKind::NoSuchEntityError(_inner) => _inner.fmt(f),
            UntagUserErrorKind::ServiceFailureError(_inner) => _inner.fmt(f),
            UntagUserErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UntagUserError {
    fn code(&self) -> Option<&str> {
        UntagUserError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UntagUserError {
    pub fn new(kind: UntagUserErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UntagUserErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UntagUserErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_concurrent_modification_error(&self) -> bool {
        matches!(
            &self.kind,
            UntagUserErrorKind::ConcurrentModificationError(_)
        )
    }
    pub fn is_no_such_entity_error(&self) -> bool {
        matches!(&self.kind, UntagUserErrorKind::NoSuchEntityError(_))
    }
    pub fn is_service_failure_error(&self) -> bool {
        matches!(&self.kind, UntagUserErrorKind::ServiceFailureError(_))
    }
}
impl std::error::Error for UntagUserError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UntagUserErrorKind::ConcurrentModificationError(_inner) => Some(_inner),
            UntagUserErrorKind::NoSuchEntityError(_inner) => Some(_inner),
            UntagUserErrorKind::ServiceFailureError(_inner) => Some(_inner),
            UntagUserErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateAccessKeyError {
    pub kind: UpdateAccessKeyErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateAccessKeyErrorKind {
    LimitExceededError(crate::error::LimitExceededError),
    NoSuchEntityError(crate::error::NoSuchEntityError),
    ServiceFailureError(crate::error::ServiceFailureError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateAccessKeyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateAccessKeyErrorKind::LimitExceededError(_inner) => _inner.fmt(f),
            UpdateAccessKeyErrorKind::NoSuchEntityError(_inner) => _inner.fmt(f),
            UpdateAccessKeyErrorKind::ServiceFailureError(_inner) => _inner.fmt(f),
            UpdateAccessKeyErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateAccessKeyError {
    fn code(&self) -> Option<&str> {
        UpdateAccessKeyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateAccessKeyError {
    pub fn new(kind: UpdateAccessKeyErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateAccessKeyErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateAccessKeyErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_limit_exceeded_error(&self) -> bool {
        matches!(&self.kind, UpdateAccessKeyErrorKind::LimitExceededError(_))
    }
    pub fn is_no_such_entity_error(&self) -> bool {
        matches!(&self.kind, UpdateAccessKeyErrorKind::NoSuchEntityError(_))
    }
    pub fn is_service_failure_error(&self) -> bool {
        matches!(&self.kind, UpdateAccessKeyErrorKind::ServiceFailureError(_))
    }
}
impl std::error::Error for UpdateAccessKeyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateAccessKeyErrorKind::LimitExceededError(_inner) => Some(_inner),
            UpdateAccessKeyErrorKind::NoSuchEntityError(_inner) => Some(_inner),
            UpdateAccessKeyErrorKind::ServiceFailureError(_inner) => Some(_inner),
            UpdateAccessKeyErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateAccountPasswordPolicyError {
    pub kind: UpdateAccountPasswordPolicyErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateAccountPasswordPolicyErrorKind {
    LimitExceededError(crate::error::LimitExceededError),
    MalformedPolicyDocumentError(crate::error::MalformedPolicyDocumentError),
    NoSuchEntityError(crate::error::NoSuchEntityError),
    ServiceFailureError(crate::error::ServiceFailureError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateAccountPasswordPolicyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateAccountPasswordPolicyErrorKind::LimitExceededError(_inner) => _inner.fmt(f),
            UpdateAccountPasswordPolicyErrorKind::MalformedPolicyDocumentError(_inner) => {
                _inner.fmt(f)
            }
            UpdateAccountPasswordPolicyErrorKind::NoSuchEntityError(_inner) => _inner.fmt(f),
            UpdateAccountPasswordPolicyErrorKind::ServiceFailureError(_inner) => _inner.fmt(f),
            UpdateAccountPasswordPolicyErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateAccountPasswordPolicyError {
    fn code(&self) -> Option<&str> {
        UpdateAccountPasswordPolicyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateAccountPasswordPolicyError {
    pub fn new(kind: UpdateAccountPasswordPolicyErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateAccountPasswordPolicyErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateAccountPasswordPolicyErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_limit_exceeded_error(&self) -> bool {
        matches!(
            &self.kind,
            UpdateAccountPasswordPolicyErrorKind::LimitExceededError(_)
        )
    }
    pub fn is_malformed_policy_document_error(&self) -> bool {
        matches!(
            &self.kind,
            UpdateAccountPasswordPolicyErrorKind::MalformedPolicyDocumentError(_)
        )
    }
    pub fn is_no_such_entity_error(&self) -> bool {
        matches!(
            &self.kind,
            UpdateAccountPasswordPolicyErrorKind::NoSuchEntityError(_)
        )
    }
    pub fn is_service_failure_error(&self) -> bool {
        matches!(
            &self.kind,
            UpdateAccountPasswordPolicyErrorKind::ServiceFailureError(_)
        )
    }
}
impl std::error::Error for UpdateAccountPasswordPolicyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateAccountPasswordPolicyErrorKind::LimitExceededError(_inner) => Some(_inner),
            UpdateAccountPasswordPolicyErrorKind::MalformedPolicyDocumentError(_inner) => {
                Some(_inner)
            }
            UpdateAccountPasswordPolicyErrorKind::NoSuchEntityError(_inner) => Some(_inner),
            UpdateAccountPasswordPolicyErrorKind::ServiceFailureError(_inner) => Some(_inner),
            UpdateAccountPasswordPolicyErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateAssumeRolePolicyError {
    pub kind: UpdateAssumeRolePolicyErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateAssumeRolePolicyErrorKind {
    LimitExceededError(crate::error::LimitExceededError),
    MalformedPolicyDocumentError(crate::error::MalformedPolicyDocumentError),
    NoSuchEntityError(crate::error::NoSuchEntityError),
    ServiceFailureError(crate::error::ServiceFailureError),
    UnmodifiableEntityError(crate::error::UnmodifiableEntityError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateAssumeRolePolicyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateAssumeRolePolicyErrorKind::LimitExceededError(_inner) => _inner.fmt(f),
            UpdateAssumeRolePolicyErrorKind::MalformedPolicyDocumentError(_inner) => _inner.fmt(f),
            UpdateAssumeRolePolicyErrorKind::NoSuchEntityError(_inner) => _inner.fmt(f),
            UpdateAssumeRolePolicyErrorKind::ServiceFailureError(_inner) => _inner.fmt(f),
            UpdateAssumeRolePolicyErrorKind::UnmodifiableEntityError(_inner) => _inner.fmt(f),
            UpdateAssumeRolePolicyErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateAssumeRolePolicyError {
    fn code(&self) -> Option<&str> {
        UpdateAssumeRolePolicyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateAssumeRolePolicyError {
    pub fn new(kind: UpdateAssumeRolePolicyErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateAssumeRolePolicyErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateAssumeRolePolicyErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_limit_exceeded_error(&self) -> bool {
        matches!(
            &self.kind,
            UpdateAssumeRolePolicyErrorKind::LimitExceededError(_)
        )
    }
    pub fn is_malformed_policy_document_error(&self) -> bool {
        matches!(
            &self.kind,
            UpdateAssumeRolePolicyErrorKind::MalformedPolicyDocumentError(_)
        )
    }
    pub fn is_no_such_entity_error(&self) -> bool {
        matches!(
            &self.kind,
            UpdateAssumeRolePolicyErrorKind::NoSuchEntityError(_)
        )
    }
    pub fn is_service_failure_error(&self) -> bool {
        matches!(
            &self.kind,
            UpdateAssumeRolePolicyErrorKind::ServiceFailureError(_)
        )
    }
    pub fn is_unmodifiable_entity_error(&self) -> bool {
        matches!(
            &self.kind,
            UpdateAssumeRolePolicyErrorKind::UnmodifiableEntityError(_)
        )
    }
}
impl std::error::Error for UpdateAssumeRolePolicyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateAssumeRolePolicyErrorKind::LimitExceededError(_inner) => Some(_inner),
            UpdateAssumeRolePolicyErrorKind::MalformedPolicyDocumentError(_inner) => Some(_inner),
            UpdateAssumeRolePolicyErrorKind::NoSuchEntityError(_inner) => Some(_inner),
            UpdateAssumeRolePolicyErrorKind::ServiceFailureError(_inner) => Some(_inner),
            UpdateAssumeRolePolicyErrorKind::UnmodifiableEntityError(_inner) => Some(_inner),
            UpdateAssumeRolePolicyErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateGroupError {
    pub kind: UpdateGroupErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateGroupErrorKind {
    EntityAlreadyExistsError(crate::error::EntityAlreadyExistsError),
    LimitExceededError(crate::error::LimitExceededError),
    NoSuchEntityError(crate::error::NoSuchEntityError),
    ServiceFailureError(crate::error::ServiceFailureError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateGroupError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateGroupErrorKind::EntityAlreadyExistsError(_inner) => _inner.fmt(f),
            UpdateGroupErrorKind::LimitExceededError(_inner) => _inner.fmt(f),
            UpdateGroupErrorKind::NoSuchEntityError(_inner) => _inner.fmt(f),
            UpdateGroupErrorKind::ServiceFailureError(_inner) => _inner.fmt(f),
            UpdateGroupErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateGroupError {
    fn code(&self) -> Option<&str> {
        UpdateGroupError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateGroupError {
    pub fn new(kind: UpdateGroupErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateGroupErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateGroupErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_entity_already_exists_error(&self) -> bool {
        matches!(
            &self.kind,
            UpdateGroupErrorKind::EntityAlreadyExistsError(_)
        )
    }
    pub fn is_limit_exceeded_error(&self) -> bool {
        matches!(&self.kind, UpdateGroupErrorKind::LimitExceededError(_))
    }
    pub fn is_no_such_entity_error(&self) -> bool {
        matches!(&self.kind, UpdateGroupErrorKind::NoSuchEntityError(_))
    }
    pub fn is_service_failure_error(&self) -> bool {
        matches!(&self.kind, UpdateGroupErrorKind::ServiceFailureError(_))
    }
}
impl std::error::Error for UpdateGroupError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateGroupErrorKind::EntityAlreadyExistsError(_inner) => Some(_inner),
            UpdateGroupErrorKind::LimitExceededError(_inner) => Some(_inner),
            UpdateGroupErrorKind::NoSuchEntityError(_inner) => Some(_inner),
            UpdateGroupErrorKind::ServiceFailureError(_inner) => Some(_inner),
            UpdateGroupErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateLoginProfileError {
    pub kind: UpdateLoginProfileErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateLoginProfileErrorKind {
    EntityTemporarilyUnmodifiableError(crate::error::EntityTemporarilyUnmodifiableError),
    LimitExceededError(crate::error::LimitExceededError),
    NoSuchEntityError(crate::error::NoSuchEntityError),
    PasswordPolicyViolationError(crate::error::PasswordPolicyViolationError),
    ServiceFailureError(crate::error::ServiceFailureError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateLoginProfileError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateLoginProfileErrorKind::EntityTemporarilyUnmodifiableError(_inner) => {
                _inner.fmt(f)
            }
            UpdateLoginProfileErrorKind::LimitExceededError(_inner) => _inner.fmt(f),
            UpdateLoginProfileErrorKind::NoSuchEntityError(_inner) => _inner.fmt(f),
            UpdateLoginProfileErrorKind::PasswordPolicyViolationError(_inner) => _inner.fmt(f),
            UpdateLoginProfileErrorKind::ServiceFailureError(_inner) => _inner.fmt(f),
            UpdateLoginProfileErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateLoginProfileError {
    fn code(&self) -> Option<&str> {
        UpdateLoginProfileError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateLoginProfileError {
    pub fn new(kind: UpdateLoginProfileErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateLoginProfileErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateLoginProfileErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_entity_temporarily_unmodifiable_error(&self) -> bool {
        matches!(
            &self.kind,
            UpdateLoginProfileErrorKind::EntityTemporarilyUnmodifiableError(_)
        )
    }
    pub fn is_limit_exceeded_error(&self) -> bool {
        matches!(
            &self.kind,
            UpdateLoginProfileErrorKind::LimitExceededError(_)
        )
    }
    pub fn is_no_such_entity_error(&self) -> bool {
        matches!(
            &self.kind,
            UpdateLoginProfileErrorKind::NoSuchEntityError(_)
        )
    }
    pub fn is_password_policy_violation_error(&self) -> bool {
        matches!(
            &self.kind,
            UpdateLoginProfileErrorKind::PasswordPolicyViolationError(_)
        )
    }
    pub fn is_service_failure_error(&self) -> bool {
        matches!(
            &self.kind,
            UpdateLoginProfileErrorKind::ServiceFailureError(_)
        )
    }
}
impl std::error::Error for UpdateLoginProfileError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateLoginProfileErrorKind::EntityTemporarilyUnmodifiableError(_inner) => Some(_inner),
            UpdateLoginProfileErrorKind::LimitExceededError(_inner) => Some(_inner),
            UpdateLoginProfileErrorKind::NoSuchEntityError(_inner) => Some(_inner),
            UpdateLoginProfileErrorKind::PasswordPolicyViolationError(_inner) => Some(_inner),
            UpdateLoginProfileErrorKind::ServiceFailureError(_inner) => Some(_inner),
            UpdateLoginProfileErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateOpenIDConnectProviderThumbprintError {
    pub kind: UpdateOpenIDConnectProviderThumbprintErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateOpenIDConnectProviderThumbprintErrorKind {
    InvalidInputError(crate::error::InvalidInputError),
    NoSuchEntityError(crate::error::NoSuchEntityError),
    ServiceFailureError(crate::error::ServiceFailureError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateOpenIDConnectProviderThumbprintError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateOpenIDConnectProviderThumbprintErrorKind::InvalidInputError(_inner) => {
                _inner.fmt(f)
            }
            UpdateOpenIDConnectProviderThumbprintErrorKind::NoSuchEntityError(_inner) => {
                _inner.fmt(f)
            }
            UpdateOpenIDConnectProviderThumbprintErrorKind::ServiceFailureError(_inner) => {
                _inner.fmt(f)
            }
            UpdateOpenIDConnectProviderThumbprintErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateOpenIDConnectProviderThumbprintError {
    fn code(&self) -> Option<&str> {
        UpdateOpenIDConnectProviderThumbprintError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateOpenIDConnectProviderThumbprintError {
    pub fn new(
        kind: UpdateOpenIDConnectProviderThumbprintErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateOpenIDConnectProviderThumbprintErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateOpenIDConnectProviderThumbprintErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_input_error(&self) -> bool {
        matches!(
            &self.kind,
            UpdateOpenIDConnectProviderThumbprintErrorKind::InvalidInputError(_)
        )
    }
    pub fn is_no_such_entity_error(&self) -> bool {
        matches!(
            &self.kind,
            UpdateOpenIDConnectProviderThumbprintErrorKind::NoSuchEntityError(_)
        )
    }
    pub fn is_service_failure_error(&self) -> bool {
        matches!(
            &self.kind,
            UpdateOpenIDConnectProviderThumbprintErrorKind::ServiceFailureError(_)
        )
    }
}
impl std::error::Error for UpdateOpenIDConnectProviderThumbprintError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateOpenIDConnectProviderThumbprintErrorKind::InvalidInputError(_inner) => {
                Some(_inner)
            }
            UpdateOpenIDConnectProviderThumbprintErrorKind::NoSuchEntityError(_inner) => {
                Some(_inner)
            }
            UpdateOpenIDConnectProviderThumbprintErrorKind::ServiceFailureError(_inner) => {
                Some(_inner)
            }
            UpdateOpenIDConnectProviderThumbprintErrorKind::Unhandled(_inner) => {
                Some(_inner.as_ref())
            }
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateRoleError {
    pub kind: UpdateRoleErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateRoleErrorKind {
    NoSuchEntityError(crate::error::NoSuchEntityError),
    ServiceFailureError(crate::error::ServiceFailureError),
    UnmodifiableEntityError(crate::error::UnmodifiableEntityError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateRoleError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateRoleErrorKind::NoSuchEntityError(_inner) => _inner.fmt(f),
            UpdateRoleErrorKind::ServiceFailureError(_inner) => _inner.fmt(f),
            UpdateRoleErrorKind::UnmodifiableEntityError(_inner) => _inner.fmt(f),
            UpdateRoleErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateRoleError {
    fn code(&self) -> Option<&str> {
        UpdateRoleError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateRoleError {
    pub fn new(kind: UpdateRoleErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateRoleErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateRoleErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_no_such_entity_error(&self) -> bool {
        matches!(&self.kind, UpdateRoleErrorKind::NoSuchEntityError(_))
    }
    pub fn is_service_failure_error(&self) -> bool {
        matches!(&self.kind, UpdateRoleErrorKind::ServiceFailureError(_))
    }
    pub fn is_unmodifiable_entity_error(&self) -> bool {
        matches!(&self.kind, UpdateRoleErrorKind::UnmodifiableEntityError(_))
    }
}
impl std::error::Error for UpdateRoleError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateRoleErrorKind::NoSuchEntityError(_inner) => Some(_inner),
            UpdateRoleErrorKind::ServiceFailureError(_inner) => Some(_inner),
            UpdateRoleErrorKind::UnmodifiableEntityError(_inner) => Some(_inner),
            UpdateRoleErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateRoleDescriptionError {
    pub kind: UpdateRoleDescriptionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateRoleDescriptionErrorKind {
    NoSuchEntityError(crate::error::NoSuchEntityError),
    ServiceFailureError(crate::error::ServiceFailureError),
    UnmodifiableEntityError(crate::error::UnmodifiableEntityError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateRoleDescriptionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateRoleDescriptionErrorKind::NoSuchEntityError(_inner) => _inner.fmt(f),
            UpdateRoleDescriptionErrorKind::ServiceFailureError(_inner) => _inner.fmt(f),
            UpdateRoleDescriptionErrorKind::UnmodifiableEntityError(_inner) => _inner.fmt(f),
            UpdateRoleDescriptionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateRoleDescriptionError {
    fn code(&self) -> Option<&str> {
        UpdateRoleDescriptionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateRoleDescriptionError {
    pub fn new(kind: UpdateRoleDescriptionErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateRoleDescriptionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateRoleDescriptionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_no_such_entity_error(&self) -> bool {
        matches!(
            &self.kind,
            UpdateRoleDescriptionErrorKind::NoSuchEntityError(_)
        )
    }
    pub fn is_service_failure_error(&self) -> bool {
        matches!(
            &self.kind,
            UpdateRoleDescriptionErrorKind::ServiceFailureError(_)
        )
    }
    pub fn is_unmodifiable_entity_error(&self) -> bool {
        matches!(
            &self.kind,
            UpdateRoleDescriptionErrorKind::UnmodifiableEntityError(_)
        )
    }
}
impl std::error::Error for UpdateRoleDescriptionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateRoleDescriptionErrorKind::NoSuchEntityError(_inner) => Some(_inner),
            UpdateRoleDescriptionErrorKind::ServiceFailureError(_inner) => Some(_inner),
            UpdateRoleDescriptionErrorKind::UnmodifiableEntityError(_inner) => Some(_inner),
            UpdateRoleDescriptionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateSAMLProviderError {
    pub kind: UpdateSAMLProviderErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateSAMLProviderErrorKind {
    InvalidInputError(crate::error::InvalidInputError),
    LimitExceededError(crate::error::LimitExceededError),
    NoSuchEntityError(crate::error::NoSuchEntityError),
    ServiceFailureError(crate::error::ServiceFailureError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateSAMLProviderError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateSAMLProviderErrorKind::InvalidInputError(_inner) => _inner.fmt(f),
            UpdateSAMLProviderErrorKind::LimitExceededError(_inner) => _inner.fmt(f),
            UpdateSAMLProviderErrorKind::NoSuchEntityError(_inner) => _inner.fmt(f),
            UpdateSAMLProviderErrorKind::ServiceFailureError(_inner) => _inner.fmt(f),
            UpdateSAMLProviderErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateSAMLProviderError {
    fn code(&self) -> Option<&str> {
        UpdateSAMLProviderError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateSAMLProviderError {
    pub fn new(kind: UpdateSAMLProviderErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateSAMLProviderErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateSAMLProviderErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_input_error(&self) -> bool {
        matches!(
            &self.kind,
            UpdateSAMLProviderErrorKind::InvalidInputError(_)
        )
    }
    pub fn is_limit_exceeded_error(&self) -> bool {
        matches!(
            &self.kind,
            UpdateSAMLProviderErrorKind::LimitExceededError(_)
        )
    }
    pub fn is_no_such_entity_error(&self) -> bool {
        matches!(
            &self.kind,
            UpdateSAMLProviderErrorKind::NoSuchEntityError(_)
        )
    }
    pub fn is_service_failure_error(&self) -> bool {
        matches!(
            &self.kind,
            UpdateSAMLProviderErrorKind::ServiceFailureError(_)
        )
    }
}
impl std::error::Error for UpdateSAMLProviderError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateSAMLProviderErrorKind::InvalidInputError(_inner) => Some(_inner),
            UpdateSAMLProviderErrorKind::LimitExceededError(_inner) => Some(_inner),
            UpdateSAMLProviderErrorKind::NoSuchEntityError(_inner) => Some(_inner),
            UpdateSAMLProviderErrorKind::ServiceFailureError(_inner) => Some(_inner),
            UpdateSAMLProviderErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateServerCertificateError {
    pub kind: UpdateServerCertificateErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateServerCertificateErrorKind {
    EntityAlreadyExistsError(crate::error::EntityAlreadyExistsError),
    LimitExceededError(crate::error::LimitExceededError),
    NoSuchEntityError(crate::error::NoSuchEntityError),
    ServiceFailureError(crate::error::ServiceFailureError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateServerCertificateError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateServerCertificateErrorKind::EntityAlreadyExistsError(_inner) => _inner.fmt(f),
            UpdateServerCertificateErrorKind::LimitExceededError(_inner) => _inner.fmt(f),
            UpdateServerCertificateErrorKind::NoSuchEntityError(_inner) => _inner.fmt(f),
            UpdateServerCertificateErrorKind::ServiceFailureError(_inner) => _inner.fmt(f),
            UpdateServerCertificateErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateServerCertificateError {
    fn code(&self) -> Option<&str> {
        UpdateServerCertificateError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateServerCertificateError {
    pub fn new(kind: UpdateServerCertificateErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateServerCertificateErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateServerCertificateErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_entity_already_exists_error(&self) -> bool {
        matches!(
            &self.kind,
            UpdateServerCertificateErrorKind::EntityAlreadyExistsError(_)
        )
    }
    pub fn is_limit_exceeded_error(&self) -> bool {
        matches!(
            &self.kind,
            UpdateServerCertificateErrorKind::LimitExceededError(_)
        )
    }
    pub fn is_no_such_entity_error(&self) -> bool {
        matches!(
            &self.kind,
            UpdateServerCertificateErrorKind::NoSuchEntityError(_)
        )
    }
    pub fn is_service_failure_error(&self) -> bool {
        matches!(
            &self.kind,
            UpdateServerCertificateErrorKind::ServiceFailureError(_)
        )
    }
}
impl std::error::Error for UpdateServerCertificateError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateServerCertificateErrorKind::EntityAlreadyExistsError(_inner) => Some(_inner),
            UpdateServerCertificateErrorKind::LimitExceededError(_inner) => Some(_inner),
            UpdateServerCertificateErrorKind::NoSuchEntityError(_inner) => Some(_inner),
            UpdateServerCertificateErrorKind::ServiceFailureError(_inner) => Some(_inner),
            UpdateServerCertificateErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateServiceSpecificCredentialError {
    pub kind: UpdateServiceSpecificCredentialErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateServiceSpecificCredentialErrorKind {
    NoSuchEntityError(crate::error::NoSuchEntityError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateServiceSpecificCredentialError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateServiceSpecificCredentialErrorKind::NoSuchEntityError(_inner) => _inner.fmt(f),
            UpdateServiceSpecificCredentialErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateServiceSpecificCredentialError {
    fn code(&self) -> Option<&str> {
        UpdateServiceSpecificCredentialError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateServiceSpecificCredentialError {
    pub fn new(kind: UpdateServiceSpecificCredentialErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateServiceSpecificCredentialErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateServiceSpecificCredentialErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_no_such_entity_error(&self) -> bool {
        matches!(
            &self.kind,
            UpdateServiceSpecificCredentialErrorKind::NoSuchEntityError(_)
        )
    }
}
impl std::error::Error for UpdateServiceSpecificCredentialError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateServiceSpecificCredentialErrorKind::NoSuchEntityError(_inner) => Some(_inner),
            UpdateServiceSpecificCredentialErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateSigningCertificateError {
    pub kind: UpdateSigningCertificateErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateSigningCertificateErrorKind {
    LimitExceededError(crate::error::LimitExceededError),
    NoSuchEntityError(crate::error::NoSuchEntityError),
    ServiceFailureError(crate::error::ServiceFailureError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateSigningCertificateError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateSigningCertificateErrorKind::LimitExceededError(_inner) => _inner.fmt(f),
            UpdateSigningCertificateErrorKind::NoSuchEntityError(_inner) => _inner.fmt(f),
            UpdateSigningCertificateErrorKind::ServiceFailureError(_inner) => _inner.fmt(f),
            UpdateSigningCertificateErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateSigningCertificateError {
    fn code(&self) -> Option<&str> {
        UpdateSigningCertificateError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateSigningCertificateError {
    pub fn new(kind: UpdateSigningCertificateErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateSigningCertificateErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateSigningCertificateErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_limit_exceeded_error(&self) -> bool {
        matches!(
            &self.kind,
            UpdateSigningCertificateErrorKind::LimitExceededError(_)
        )
    }
    pub fn is_no_such_entity_error(&self) -> bool {
        matches!(
            &self.kind,
            UpdateSigningCertificateErrorKind::NoSuchEntityError(_)
        )
    }
    pub fn is_service_failure_error(&self) -> bool {
        matches!(
            &self.kind,
            UpdateSigningCertificateErrorKind::ServiceFailureError(_)
        )
    }
}
impl std::error::Error for UpdateSigningCertificateError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateSigningCertificateErrorKind::LimitExceededError(_inner) => Some(_inner),
            UpdateSigningCertificateErrorKind::NoSuchEntityError(_inner) => Some(_inner),
            UpdateSigningCertificateErrorKind::ServiceFailureError(_inner) => Some(_inner),
            UpdateSigningCertificateErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateSSHPublicKeyError {
    pub kind: UpdateSSHPublicKeyErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateSSHPublicKeyErrorKind {
    NoSuchEntityError(crate::error::NoSuchEntityError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateSSHPublicKeyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateSSHPublicKeyErrorKind::NoSuchEntityError(_inner) => _inner.fmt(f),
            UpdateSSHPublicKeyErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateSSHPublicKeyError {
    fn code(&self) -> Option<&str> {
        UpdateSSHPublicKeyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateSSHPublicKeyError {
    pub fn new(kind: UpdateSSHPublicKeyErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateSSHPublicKeyErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateSSHPublicKeyErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_no_such_entity_error(&self) -> bool {
        matches!(
            &self.kind,
            UpdateSSHPublicKeyErrorKind::NoSuchEntityError(_)
        )
    }
}
impl std::error::Error for UpdateSSHPublicKeyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateSSHPublicKeyErrorKind::NoSuchEntityError(_inner) => Some(_inner),
            UpdateSSHPublicKeyErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateUserError {
    pub kind: UpdateUserErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateUserErrorKind {
    ConcurrentModificationError(crate::error::ConcurrentModificationError),
    EntityAlreadyExistsError(crate::error::EntityAlreadyExistsError),
    EntityTemporarilyUnmodifiableError(crate::error::EntityTemporarilyUnmodifiableError),
    LimitExceededError(crate::error::LimitExceededError),
    NoSuchEntityError(crate::error::NoSuchEntityError),
    ServiceFailureError(crate::error::ServiceFailureError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateUserError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateUserErrorKind::ConcurrentModificationError(_inner) => _inner.fmt(f),
            UpdateUserErrorKind::EntityAlreadyExistsError(_inner) => _inner.fmt(f),
            UpdateUserErrorKind::EntityTemporarilyUnmodifiableError(_inner) => _inner.fmt(f),
            UpdateUserErrorKind::LimitExceededError(_inner) => _inner.fmt(f),
            UpdateUserErrorKind::NoSuchEntityError(_inner) => _inner.fmt(f),
            UpdateUserErrorKind::ServiceFailureError(_inner) => _inner.fmt(f),
            UpdateUserErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateUserError {
    fn code(&self) -> Option<&str> {
        UpdateUserError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateUserError {
    pub fn new(kind: UpdateUserErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateUserErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateUserErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_concurrent_modification_error(&self) -> bool {
        matches!(
            &self.kind,
            UpdateUserErrorKind::ConcurrentModificationError(_)
        )
    }
    pub fn is_entity_already_exists_error(&self) -> bool {
        matches!(&self.kind, UpdateUserErrorKind::EntityAlreadyExistsError(_))
    }
    pub fn is_entity_temporarily_unmodifiable_error(&self) -> bool {
        matches!(
            &self.kind,
            UpdateUserErrorKind::EntityTemporarilyUnmodifiableError(_)
        )
    }
    pub fn is_limit_exceeded_error(&self) -> bool {
        matches!(&self.kind, UpdateUserErrorKind::LimitExceededError(_))
    }
    pub fn is_no_such_entity_error(&self) -> bool {
        matches!(&self.kind, UpdateUserErrorKind::NoSuchEntityError(_))
    }
    pub fn is_service_failure_error(&self) -> bool {
        matches!(&self.kind, UpdateUserErrorKind::ServiceFailureError(_))
    }
}
impl std::error::Error for UpdateUserError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateUserErrorKind::ConcurrentModificationError(_inner) => Some(_inner),
            UpdateUserErrorKind::EntityAlreadyExistsError(_inner) => Some(_inner),
            UpdateUserErrorKind::EntityTemporarilyUnmodifiableError(_inner) => Some(_inner),
            UpdateUserErrorKind::LimitExceededError(_inner) => Some(_inner),
            UpdateUserErrorKind::NoSuchEntityError(_inner) => Some(_inner),
            UpdateUserErrorKind::ServiceFailureError(_inner) => Some(_inner),
            UpdateUserErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UploadServerCertificateError {
    pub kind: UploadServerCertificateErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UploadServerCertificateErrorKind {
    ConcurrentModificationError(crate::error::ConcurrentModificationError),
    EntityAlreadyExistsError(crate::error::EntityAlreadyExistsError),
    InvalidInputError(crate::error::InvalidInputError),
    KeyPairMismatchError(crate::error::KeyPairMismatchError),
    LimitExceededError(crate::error::LimitExceededError),
    MalformedCertificateError(crate::error::MalformedCertificateError),
    ServiceFailureError(crate::error::ServiceFailureError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UploadServerCertificateError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UploadServerCertificateErrorKind::ConcurrentModificationError(_inner) => _inner.fmt(f),
            UploadServerCertificateErrorKind::EntityAlreadyExistsError(_inner) => _inner.fmt(f),
            UploadServerCertificateErrorKind::InvalidInputError(_inner) => _inner.fmt(f),
            UploadServerCertificateErrorKind::KeyPairMismatchError(_inner) => _inner.fmt(f),
            UploadServerCertificateErrorKind::LimitExceededError(_inner) => _inner.fmt(f),
            UploadServerCertificateErrorKind::MalformedCertificateError(_inner) => _inner.fmt(f),
            UploadServerCertificateErrorKind::ServiceFailureError(_inner) => _inner.fmt(f),
            UploadServerCertificateErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UploadServerCertificateError {
    fn code(&self) -> Option<&str> {
        UploadServerCertificateError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UploadServerCertificateError {
    pub fn new(kind: UploadServerCertificateErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UploadServerCertificateErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UploadServerCertificateErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_concurrent_modification_error(&self) -> bool {
        matches!(
            &self.kind,
            UploadServerCertificateErrorKind::ConcurrentModificationError(_)
        )
    }
    pub fn is_entity_already_exists_error(&self) -> bool {
        matches!(
            &self.kind,
            UploadServerCertificateErrorKind::EntityAlreadyExistsError(_)
        )
    }
    pub fn is_invalid_input_error(&self) -> bool {
        matches!(
            &self.kind,
            UploadServerCertificateErrorKind::InvalidInputError(_)
        )
    }
    pub fn is_key_pair_mismatch_error(&self) -> bool {
        matches!(
            &self.kind,
            UploadServerCertificateErrorKind::KeyPairMismatchError(_)
        )
    }
    pub fn is_limit_exceeded_error(&self) -> bool {
        matches!(
            &self.kind,
            UploadServerCertificateErrorKind::LimitExceededError(_)
        )
    }
    pub fn is_malformed_certificate_error(&self) -> bool {
        matches!(
            &self.kind,
            UploadServerCertificateErrorKind::MalformedCertificateError(_)
        )
    }
    pub fn is_service_failure_error(&self) -> bool {
        matches!(
            &self.kind,
            UploadServerCertificateErrorKind::ServiceFailureError(_)
        )
    }
}
impl std::error::Error for UploadServerCertificateError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UploadServerCertificateErrorKind::ConcurrentModificationError(_inner) => Some(_inner),
            UploadServerCertificateErrorKind::EntityAlreadyExistsError(_inner) => Some(_inner),
            UploadServerCertificateErrorKind::InvalidInputError(_inner) => Some(_inner),
            UploadServerCertificateErrorKind::KeyPairMismatchError(_inner) => Some(_inner),
            UploadServerCertificateErrorKind::LimitExceededError(_inner) => Some(_inner),
            UploadServerCertificateErrorKind::MalformedCertificateError(_inner) => Some(_inner),
            UploadServerCertificateErrorKind::ServiceFailureError(_inner) => Some(_inner),
            UploadServerCertificateErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UploadSigningCertificateError {
    pub kind: UploadSigningCertificateErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UploadSigningCertificateErrorKind {
    DuplicateCertificateError(crate::error::DuplicateCertificateError),
    EntityAlreadyExistsError(crate::error::EntityAlreadyExistsError),
    InvalidCertificateError(crate::error::InvalidCertificateError),
    LimitExceededError(crate::error::LimitExceededError),
    MalformedCertificateError(crate::error::MalformedCertificateError),
    NoSuchEntityError(crate::error::NoSuchEntityError),
    ServiceFailureError(crate::error::ServiceFailureError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UploadSigningCertificateError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UploadSigningCertificateErrorKind::DuplicateCertificateError(_inner) => _inner.fmt(f),
            UploadSigningCertificateErrorKind::EntityAlreadyExistsError(_inner) => _inner.fmt(f),
            UploadSigningCertificateErrorKind::InvalidCertificateError(_inner) => _inner.fmt(f),
            UploadSigningCertificateErrorKind::LimitExceededError(_inner) => _inner.fmt(f),
            UploadSigningCertificateErrorKind::MalformedCertificateError(_inner) => _inner.fmt(f),
            UploadSigningCertificateErrorKind::NoSuchEntityError(_inner) => _inner.fmt(f),
            UploadSigningCertificateErrorKind::ServiceFailureError(_inner) => _inner.fmt(f),
            UploadSigningCertificateErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UploadSigningCertificateError {
    fn code(&self) -> Option<&str> {
        UploadSigningCertificateError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UploadSigningCertificateError {
    pub fn new(kind: UploadSigningCertificateErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UploadSigningCertificateErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UploadSigningCertificateErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_duplicate_certificate_error(&self) -> bool {
        matches!(
            &self.kind,
            UploadSigningCertificateErrorKind::DuplicateCertificateError(_)
        )
    }
    pub fn is_entity_already_exists_error(&self) -> bool {
        matches!(
            &self.kind,
            UploadSigningCertificateErrorKind::EntityAlreadyExistsError(_)
        )
    }
    pub fn is_invalid_certificate_error(&self) -> bool {
        matches!(
            &self.kind,
            UploadSigningCertificateErrorKind::InvalidCertificateError(_)
        )
    }
    pub fn is_limit_exceeded_error(&self) -> bool {
        matches!(
            &self.kind,
            UploadSigningCertificateErrorKind::LimitExceededError(_)
        )
    }
    pub fn is_malformed_certificate_error(&self) -> bool {
        matches!(
            &self.kind,
            UploadSigningCertificateErrorKind::MalformedCertificateError(_)
        )
    }
    pub fn is_no_such_entity_error(&self) -> bool {
        matches!(
            &self.kind,
            UploadSigningCertificateErrorKind::NoSuchEntityError(_)
        )
    }
    pub fn is_service_failure_error(&self) -> bool {
        matches!(
            &self.kind,
            UploadSigningCertificateErrorKind::ServiceFailureError(_)
        )
    }
}
impl std::error::Error for UploadSigningCertificateError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UploadSigningCertificateErrorKind::DuplicateCertificateError(_inner) => Some(_inner),
            UploadSigningCertificateErrorKind::EntityAlreadyExistsError(_inner) => Some(_inner),
            UploadSigningCertificateErrorKind::InvalidCertificateError(_inner) => Some(_inner),
            UploadSigningCertificateErrorKind::LimitExceededError(_inner) => Some(_inner),
            UploadSigningCertificateErrorKind::MalformedCertificateError(_inner) => Some(_inner),
            UploadSigningCertificateErrorKind::NoSuchEntityError(_inner) => Some(_inner),
            UploadSigningCertificateErrorKind::ServiceFailureError(_inner) => Some(_inner),
            UploadSigningCertificateErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UploadSSHPublicKeyError {
    pub kind: UploadSSHPublicKeyErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UploadSSHPublicKeyErrorKind {
    DuplicateSSHPublicKeyError(crate::error::DuplicateSSHPublicKeyError),
    InvalidPublicKeyError(crate::error::InvalidPublicKeyError),
    LimitExceededError(crate::error::LimitExceededError),
    NoSuchEntityError(crate::error::NoSuchEntityError),
    UnrecognizedPublicKeyEncodingError(crate::error::UnrecognizedPublicKeyEncodingError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UploadSSHPublicKeyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UploadSSHPublicKeyErrorKind::DuplicateSSHPublicKeyError(_inner) => _inner.fmt(f),
            UploadSSHPublicKeyErrorKind::InvalidPublicKeyError(_inner) => _inner.fmt(f),
            UploadSSHPublicKeyErrorKind::LimitExceededError(_inner) => _inner.fmt(f),
            UploadSSHPublicKeyErrorKind::NoSuchEntityError(_inner) => _inner.fmt(f),
            UploadSSHPublicKeyErrorKind::UnrecognizedPublicKeyEncodingError(_inner) => {
                _inner.fmt(f)
            }
            UploadSSHPublicKeyErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UploadSSHPublicKeyError {
    fn code(&self) -> Option<&str> {
        UploadSSHPublicKeyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UploadSSHPublicKeyError {
    pub fn new(kind: UploadSSHPublicKeyErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UploadSSHPublicKeyErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UploadSSHPublicKeyErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_duplicate_ssh_public_key_error(&self) -> bool {
        matches!(
            &self.kind,
            UploadSSHPublicKeyErrorKind::DuplicateSSHPublicKeyError(_)
        )
    }
    pub fn is_invalid_public_key_error(&self) -> bool {
        matches!(
            &self.kind,
            UploadSSHPublicKeyErrorKind::InvalidPublicKeyError(_)
        )
    }
    pub fn is_limit_exceeded_error(&self) -> bool {
        matches!(
            &self.kind,
            UploadSSHPublicKeyErrorKind::LimitExceededError(_)
        )
    }
    pub fn is_no_such_entity_error(&self) -> bool {
        matches!(
            &self.kind,
            UploadSSHPublicKeyErrorKind::NoSuchEntityError(_)
        )
    }
    pub fn is_unrecognized_public_key_encoding_error(&self) -> bool {
        matches!(
            &self.kind,
            UploadSSHPublicKeyErrorKind::UnrecognizedPublicKeyEncodingError(_)
        )
    }
}
impl std::error::Error for UploadSSHPublicKeyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UploadSSHPublicKeyErrorKind::DuplicateSSHPublicKeyError(_inner) => Some(_inner),
            UploadSSHPublicKeyErrorKind::InvalidPublicKeyError(_inner) => Some(_inner),
            UploadSSHPublicKeyErrorKind::LimitExceededError(_inner) => Some(_inner),
            UploadSSHPublicKeyErrorKind::NoSuchEntityError(_inner) => Some(_inner),
            UploadSSHPublicKeyErrorKind::UnrecognizedPublicKeyEncodingError(_inner) => Some(_inner),
            UploadSSHPublicKeyErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// <p>The request was rejected because the public key encoding format is unsupported or
/// unrecognized.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UnrecognizedPublicKeyEncodingError {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for UnrecognizedPublicKeyEncodingError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UnrecognizedPublicKeyEncodingError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl UnrecognizedPublicKeyEncodingError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for UnrecognizedPublicKeyEncodingError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "UnrecognizedPublicKeyEncodingError [UnrecognizedPublicKeyEncodingException]"
        )?;
        if let Some(inner_1) = &self.message {
            write!(f, ": {}", inner_1)?;
        }
        Ok(())
    }
}
impl std::error::Error for UnrecognizedPublicKeyEncodingError {}
/// See [`UnrecognizedPublicKeyEncodingError`](crate::error::UnrecognizedPublicKeyEncodingError)
pub mod unrecognized_public_key_encoding_error {
    /// A builder for [`UnrecognizedPublicKeyEncodingError`](crate::error::UnrecognizedPublicKeyEncodingError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`UnrecognizedPublicKeyEncodingError`](crate::error::UnrecognizedPublicKeyEncodingError)
        pub fn build(self) -> crate::error::UnrecognizedPublicKeyEncodingError {
            crate::error::UnrecognizedPublicKeyEncodingError {
                message: self.message,
            }
        }
    }
}
impl UnrecognizedPublicKeyEncodingError {
    /// Creates a new builder-style object to manufacture [`UnrecognizedPublicKeyEncodingError`](crate::error::UnrecognizedPublicKeyEncodingError)
    pub fn builder() -> crate::error::unrecognized_public_key_encoding_error::Builder {
        crate::error::unrecognized_public_key_encoding_error::Builder::default()
    }
}

/// <p>The request was rejected because it referenced a resource entity that does not exist. The
/// error message describes the resource.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct NoSuchEntityError {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for NoSuchEntityError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("NoSuchEntityError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl NoSuchEntityError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for NoSuchEntityError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "NoSuchEntityError [NoSuchEntityException]")?;
        if let Some(inner_2) = &self.message {
            write!(f, ": {}", inner_2)?;
        }
        Ok(())
    }
}
impl std::error::Error for NoSuchEntityError {}
/// See [`NoSuchEntityError`](crate::error::NoSuchEntityError)
pub mod no_such_entity_error {
    /// A builder for [`NoSuchEntityError`](crate::error::NoSuchEntityError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`NoSuchEntityError`](crate::error::NoSuchEntityError)
        pub fn build(self) -> crate::error::NoSuchEntityError {
            crate::error::NoSuchEntityError {
                message: self.message,
            }
        }
    }
}
impl NoSuchEntityError {
    /// Creates a new builder-style object to manufacture [`NoSuchEntityError`](crate::error::NoSuchEntityError)
    pub fn builder() -> crate::error::no_such_entity_error::Builder {
        crate::error::no_such_entity_error::Builder::default()
    }
}

/// <p>The request was rejected because it attempted to create resources beyond the current AWS
/// account limits. The error message describes the limit exceeded.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct LimitExceededError {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for LimitExceededError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("LimitExceededError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl LimitExceededError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for LimitExceededError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "LimitExceededError [LimitExceededException]")?;
        if let Some(inner_3) = &self.message {
            write!(f, ": {}", inner_3)?;
        }
        Ok(())
    }
}
impl std::error::Error for LimitExceededError {}
/// See [`LimitExceededError`](crate::error::LimitExceededError)
pub mod limit_exceeded_error {
    /// A builder for [`LimitExceededError`](crate::error::LimitExceededError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`LimitExceededError`](crate::error::LimitExceededError)
        pub fn build(self) -> crate::error::LimitExceededError {
            crate::error::LimitExceededError {
                message: self.message,
            }
        }
    }
}
impl LimitExceededError {
    /// Creates a new builder-style object to manufacture [`LimitExceededError`](crate::error::LimitExceededError)
    pub fn builder() -> crate::error::limit_exceeded_error::Builder {
        crate::error::limit_exceeded_error::Builder::default()
    }
}

/// <p>The request was rejected because the public key is malformed or otherwise invalid.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidPublicKeyError {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidPublicKeyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidPublicKeyError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidPublicKeyError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidPublicKeyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidPublicKeyError [InvalidPublicKeyException]")?;
        if let Some(inner_4) = &self.message {
            write!(f, ": {}", inner_4)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidPublicKeyError {}
/// See [`InvalidPublicKeyError`](crate::error::InvalidPublicKeyError)
pub mod invalid_public_key_error {
    /// A builder for [`InvalidPublicKeyError`](crate::error::InvalidPublicKeyError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidPublicKeyError`](crate::error::InvalidPublicKeyError)
        pub fn build(self) -> crate::error::InvalidPublicKeyError {
            crate::error::InvalidPublicKeyError {
                message: self.message,
            }
        }
    }
}
impl InvalidPublicKeyError {
    /// Creates a new builder-style object to manufacture [`InvalidPublicKeyError`](crate::error::InvalidPublicKeyError)
    pub fn builder() -> crate::error::invalid_public_key_error::Builder {
        crate::error::invalid_public_key_error::Builder::default()
    }
}

/// <p>The request was rejected because the SSH public key is already associated with the
/// specified IAM user.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DuplicateSSHPublicKeyError {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DuplicateSSHPublicKeyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DuplicateSSHPublicKeyError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl DuplicateSSHPublicKeyError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for DuplicateSSHPublicKeyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "DuplicateSSHPublicKeyError [DuplicateSSHPublicKeyException]"
        )?;
        if let Some(inner_5) = &self.message {
            write!(f, ": {}", inner_5)?;
        }
        Ok(())
    }
}
impl std::error::Error for DuplicateSSHPublicKeyError {}
/// See [`DuplicateSSHPublicKeyError`](crate::error::DuplicateSSHPublicKeyError)
pub mod duplicate_ssh_public_key_error {
    /// A builder for [`DuplicateSSHPublicKeyError`](crate::error::DuplicateSSHPublicKeyError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`DuplicateSSHPublicKeyError`](crate::error::DuplicateSSHPublicKeyError)
        pub fn build(self) -> crate::error::DuplicateSSHPublicKeyError {
            crate::error::DuplicateSSHPublicKeyError {
                message: self.message,
            }
        }
    }
}
impl DuplicateSSHPublicKeyError {
    /// Creates a new builder-style object to manufacture [`DuplicateSSHPublicKeyError`](crate::error::DuplicateSSHPublicKeyError)
    pub fn builder() -> crate::error::duplicate_ssh_public_key_error::Builder {
        crate::error::duplicate_ssh_public_key_error::Builder::default()
    }
}

/// <p>The request processing has failed because of an unknown error, exception or
/// failure.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ServiceFailureError {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ServiceFailureError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ServiceFailureError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ServiceFailureError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ServiceFailureError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ServiceFailureError [ServiceFailureException]")?;
        if let Some(inner_6) = &self.message {
            write!(f, ": {}", inner_6)?;
        }
        Ok(())
    }
}
impl std::error::Error for ServiceFailureError {}
/// See [`ServiceFailureError`](crate::error::ServiceFailureError)
pub mod service_failure_error {
    /// A builder for [`ServiceFailureError`](crate::error::ServiceFailureError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ServiceFailureError`](crate::error::ServiceFailureError)
        pub fn build(self) -> crate::error::ServiceFailureError {
            crate::error::ServiceFailureError {
                message: self.message,
            }
        }
    }
}
impl ServiceFailureError {
    /// Creates a new builder-style object to manufacture [`ServiceFailureError`](crate::error::ServiceFailureError)
    pub fn builder() -> crate::error::service_failure_error::Builder {
        crate::error::service_failure_error::Builder::default()
    }
}

/// <p>The request was rejected because the certificate was malformed or expired. The error
/// message describes the specific error.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct MalformedCertificateError {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for MalformedCertificateError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("MalformedCertificateError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl MalformedCertificateError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for MalformedCertificateError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "MalformedCertificateError [MalformedCertificateException]"
        )?;
        if let Some(inner_7) = &self.message {
            write!(f, ": {}", inner_7)?;
        }
        Ok(())
    }
}
impl std::error::Error for MalformedCertificateError {}
/// See [`MalformedCertificateError`](crate::error::MalformedCertificateError)
pub mod malformed_certificate_error {
    /// A builder for [`MalformedCertificateError`](crate::error::MalformedCertificateError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`MalformedCertificateError`](crate::error::MalformedCertificateError)
        pub fn build(self) -> crate::error::MalformedCertificateError {
            crate::error::MalformedCertificateError {
                message: self.message,
            }
        }
    }
}
impl MalformedCertificateError {
    /// Creates a new builder-style object to manufacture [`MalformedCertificateError`](crate::error::MalformedCertificateError)
    pub fn builder() -> crate::error::malformed_certificate_error::Builder {
        crate::error::malformed_certificate_error::Builder::default()
    }
}

/// <p>The request was rejected because the certificate is invalid.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidCertificateError {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidCertificateError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidCertificateError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidCertificateError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidCertificateError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidCertificateError [InvalidCertificateException]")?;
        if let Some(inner_8) = &self.message {
            write!(f, ": {}", inner_8)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidCertificateError {}
/// See [`InvalidCertificateError`](crate::error::InvalidCertificateError)
pub mod invalid_certificate_error {
    /// A builder for [`InvalidCertificateError`](crate::error::InvalidCertificateError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidCertificateError`](crate::error::InvalidCertificateError)
        pub fn build(self) -> crate::error::InvalidCertificateError {
            crate::error::InvalidCertificateError {
                message: self.message,
            }
        }
    }
}
impl InvalidCertificateError {
    /// Creates a new builder-style object to manufacture [`InvalidCertificateError`](crate::error::InvalidCertificateError)
    pub fn builder() -> crate::error::invalid_certificate_error::Builder {
        crate::error::invalid_certificate_error::Builder::default()
    }
}

/// <p>The request was rejected because it attempted to create a resource that already
/// exists.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct EntityAlreadyExistsError {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for EntityAlreadyExistsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("EntityAlreadyExistsError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl EntityAlreadyExistsError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for EntityAlreadyExistsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "EntityAlreadyExistsError [EntityAlreadyExistsException]")?;
        if let Some(inner_9) = &self.message {
            write!(f, ": {}", inner_9)?;
        }
        Ok(())
    }
}
impl std::error::Error for EntityAlreadyExistsError {}
/// See [`EntityAlreadyExistsError`](crate::error::EntityAlreadyExistsError)
pub mod entity_already_exists_error {
    /// A builder for [`EntityAlreadyExistsError`](crate::error::EntityAlreadyExistsError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`EntityAlreadyExistsError`](crate::error::EntityAlreadyExistsError)
        pub fn build(self) -> crate::error::EntityAlreadyExistsError {
            crate::error::EntityAlreadyExistsError {
                message: self.message,
            }
        }
    }
}
impl EntityAlreadyExistsError {
    /// Creates a new builder-style object to manufacture [`EntityAlreadyExistsError`](crate::error::EntityAlreadyExistsError)
    pub fn builder() -> crate::error::entity_already_exists_error::Builder {
        crate::error::entity_already_exists_error::Builder::default()
    }
}

/// <p>The request was rejected because the same certificate is associated with an IAM user in
/// the account.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DuplicateCertificateError {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DuplicateCertificateError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DuplicateCertificateError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl DuplicateCertificateError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for DuplicateCertificateError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "DuplicateCertificateError [DuplicateCertificateException]"
        )?;
        if let Some(inner_10) = &self.message {
            write!(f, ": {}", inner_10)?;
        }
        Ok(())
    }
}
impl std::error::Error for DuplicateCertificateError {}
/// See [`DuplicateCertificateError`](crate::error::DuplicateCertificateError)
pub mod duplicate_certificate_error {
    /// A builder for [`DuplicateCertificateError`](crate::error::DuplicateCertificateError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`DuplicateCertificateError`](crate::error::DuplicateCertificateError)
        pub fn build(self) -> crate::error::DuplicateCertificateError {
            crate::error::DuplicateCertificateError {
                message: self.message,
            }
        }
    }
}
impl DuplicateCertificateError {
    /// Creates a new builder-style object to manufacture [`DuplicateCertificateError`](crate::error::DuplicateCertificateError)
    pub fn builder() -> crate::error::duplicate_certificate_error::Builder {
        crate::error::duplicate_certificate_error::Builder::default()
    }
}

/// <p>The request was rejected because the public key certificate and the private key do not
/// match.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct KeyPairMismatchError {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for KeyPairMismatchError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("KeyPairMismatchError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl KeyPairMismatchError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for KeyPairMismatchError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "KeyPairMismatchError [KeyPairMismatchException]")?;
        if let Some(inner_11) = &self.message {
            write!(f, ": {}", inner_11)?;
        }
        Ok(())
    }
}
impl std::error::Error for KeyPairMismatchError {}
/// See [`KeyPairMismatchError`](crate::error::KeyPairMismatchError)
pub mod key_pair_mismatch_error {
    /// A builder for [`KeyPairMismatchError`](crate::error::KeyPairMismatchError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`KeyPairMismatchError`](crate::error::KeyPairMismatchError)
        pub fn build(self) -> crate::error::KeyPairMismatchError {
            crate::error::KeyPairMismatchError {
                message: self.message,
            }
        }
    }
}
impl KeyPairMismatchError {
    /// Creates a new builder-style object to manufacture [`KeyPairMismatchError`](crate::error::KeyPairMismatchError)
    pub fn builder() -> crate::error::key_pair_mismatch_error::Builder {
        crate::error::key_pair_mismatch_error::Builder::default()
    }
}

/// <p>The request was rejected because an invalid or out-of-range value was supplied for an
/// input parameter.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidInputError {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidInputError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidInputError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidInputError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidInputError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidInputError [InvalidInputException]")?;
        if let Some(inner_12) = &self.message {
            write!(f, ": {}", inner_12)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidInputError {}
/// See [`InvalidInputError`](crate::error::InvalidInputError)
pub mod invalid_input_error {
    /// A builder for [`InvalidInputError`](crate::error::InvalidInputError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidInputError`](crate::error::InvalidInputError)
        pub fn build(self) -> crate::error::InvalidInputError {
            crate::error::InvalidInputError {
                message: self.message,
            }
        }
    }
}
impl InvalidInputError {
    /// Creates a new builder-style object to manufacture [`InvalidInputError`](crate::error::InvalidInputError)
    pub fn builder() -> crate::error::invalid_input_error::Builder {
        crate::error::invalid_input_error::Builder::default()
    }
}

/// <p>The request was rejected because multiple requests to change this object were submitted
/// simultaneously. Wait a few minutes and submit your request again.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ConcurrentModificationError {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ConcurrentModificationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ConcurrentModificationError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ConcurrentModificationError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ConcurrentModificationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "ConcurrentModificationError [ConcurrentModificationException]"
        )?;
        if let Some(inner_13) = &self.message {
            write!(f, ": {}", inner_13)?;
        }
        Ok(())
    }
}
impl std::error::Error for ConcurrentModificationError {}
/// See [`ConcurrentModificationError`](crate::error::ConcurrentModificationError)
pub mod concurrent_modification_error {
    /// A builder for [`ConcurrentModificationError`](crate::error::ConcurrentModificationError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ConcurrentModificationError`](crate::error::ConcurrentModificationError)
        pub fn build(self) -> crate::error::ConcurrentModificationError {
            crate::error::ConcurrentModificationError {
                message: self.message,
            }
        }
    }
}
impl ConcurrentModificationError {
    /// Creates a new builder-style object to manufacture [`ConcurrentModificationError`](crate::error::ConcurrentModificationError)
    pub fn builder() -> crate::error::concurrent_modification_error::Builder {
        crate::error::concurrent_modification_error::Builder::default()
    }
}

/// <p>The request was rejected because it referenced an entity that is temporarily unmodifiable,
/// such as a user name that was deleted and then recreated. The error indicates that the request
/// is likely to succeed if you try again after waiting several minutes. The error message
/// describes the entity.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct EntityTemporarilyUnmodifiableError {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for EntityTemporarilyUnmodifiableError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("EntityTemporarilyUnmodifiableError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl EntityTemporarilyUnmodifiableError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for EntityTemporarilyUnmodifiableError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "EntityTemporarilyUnmodifiableError [EntityTemporarilyUnmodifiableException]"
        )?;
        if let Some(inner_14) = &self.message {
            write!(f, ": {}", inner_14)?;
        }
        Ok(())
    }
}
impl std::error::Error for EntityTemporarilyUnmodifiableError {}
/// See [`EntityTemporarilyUnmodifiableError`](crate::error::EntityTemporarilyUnmodifiableError)
pub mod entity_temporarily_unmodifiable_error {
    /// A builder for [`EntityTemporarilyUnmodifiableError`](crate::error::EntityTemporarilyUnmodifiableError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`EntityTemporarilyUnmodifiableError`](crate::error::EntityTemporarilyUnmodifiableError)
        pub fn build(self) -> crate::error::EntityTemporarilyUnmodifiableError {
            crate::error::EntityTemporarilyUnmodifiableError {
                message: self.message,
            }
        }
    }
}
impl EntityTemporarilyUnmodifiableError {
    /// Creates a new builder-style object to manufacture [`EntityTemporarilyUnmodifiableError`](crate::error::EntityTemporarilyUnmodifiableError)
    pub fn builder() -> crate::error::entity_temporarily_unmodifiable_error::Builder {
        crate::error::entity_temporarily_unmodifiable_error::Builder::default()
    }
}

/// <p>The request was rejected because only the service that depends on the service-linked role
/// can modify or delete the role on your behalf. The error message includes the name of the
/// service that depends on this service-linked role. You must request the change through that
/// service.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UnmodifiableEntityError {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for UnmodifiableEntityError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UnmodifiableEntityError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl UnmodifiableEntityError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for UnmodifiableEntityError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "UnmodifiableEntityError [UnmodifiableEntityException]")?;
        if let Some(inner_15) = &self.message {
            write!(f, ": {}", inner_15)?;
        }
        Ok(())
    }
}
impl std::error::Error for UnmodifiableEntityError {}
/// See [`UnmodifiableEntityError`](crate::error::UnmodifiableEntityError)
pub mod unmodifiable_entity_error {
    /// A builder for [`UnmodifiableEntityError`](crate::error::UnmodifiableEntityError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`UnmodifiableEntityError`](crate::error::UnmodifiableEntityError)
        pub fn build(self) -> crate::error::UnmodifiableEntityError {
            crate::error::UnmodifiableEntityError {
                message: self.message,
            }
        }
    }
}
impl UnmodifiableEntityError {
    /// Creates a new builder-style object to manufacture [`UnmodifiableEntityError`](crate::error::UnmodifiableEntityError)
    pub fn builder() -> crate::error::unmodifiable_entity_error::Builder {
        crate::error::unmodifiable_entity_error::Builder::default()
    }
}

/// <p>The request was rejected because the provided password did not meet the requirements
/// imposed by the account password policy.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PasswordPolicyViolationError {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for PasswordPolicyViolationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PasswordPolicyViolationError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl PasswordPolicyViolationError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for PasswordPolicyViolationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "PasswordPolicyViolationError [PasswordPolicyViolationException]"
        )?;
        if let Some(inner_16) = &self.message {
            write!(f, ": {}", inner_16)?;
        }
        Ok(())
    }
}
impl std::error::Error for PasswordPolicyViolationError {}
/// See [`PasswordPolicyViolationError`](crate::error::PasswordPolicyViolationError)
pub mod password_policy_violation_error {
    /// A builder for [`PasswordPolicyViolationError`](crate::error::PasswordPolicyViolationError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`PasswordPolicyViolationError`](crate::error::PasswordPolicyViolationError)
        pub fn build(self) -> crate::error::PasswordPolicyViolationError {
            crate::error::PasswordPolicyViolationError {
                message: self.message,
            }
        }
    }
}
impl PasswordPolicyViolationError {
    /// Creates a new builder-style object to manufacture [`PasswordPolicyViolationError`](crate::error::PasswordPolicyViolationError)
    pub fn builder() -> crate::error::password_policy_violation_error::Builder {
        crate::error::password_policy_violation_error::Builder::default()
    }
}

/// <p>The request was rejected because the policy document was malformed. The error message
/// describes the specific error.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct MalformedPolicyDocumentError {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for MalformedPolicyDocumentError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("MalformedPolicyDocumentError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl MalformedPolicyDocumentError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for MalformedPolicyDocumentError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "MalformedPolicyDocumentError [MalformedPolicyDocumentException]"
        )?;
        if let Some(inner_17) = &self.message {
            write!(f, ": {}", inner_17)?;
        }
        Ok(())
    }
}
impl std::error::Error for MalformedPolicyDocumentError {}
/// See [`MalformedPolicyDocumentError`](crate::error::MalformedPolicyDocumentError)
pub mod malformed_policy_document_error {
    /// A builder for [`MalformedPolicyDocumentError`](crate::error::MalformedPolicyDocumentError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`MalformedPolicyDocumentError`](crate::error::MalformedPolicyDocumentError)
        pub fn build(self) -> crate::error::MalformedPolicyDocumentError {
            crate::error::MalformedPolicyDocumentError {
                message: self.message,
            }
        }
    }
}
impl MalformedPolicyDocumentError {
    /// Creates a new builder-style object to manufacture [`MalformedPolicyDocumentError`](crate::error::MalformedPolicyDocumentError)
    pub fn builder() -> crate::error::malformed_policy_document_error::Builder {
        crate::error::malformed_policy_document_error::Builder::default()
    }
}

/// <p>The request failed because a provided policy could not be successfully evaluated. An
/// additional detailed message indicates the source of the failure.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PolicyEvaluationError {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for PolicyEvaluationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PolicyEvaluationError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl PolicyEvaluationError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for PolicyEvaluationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "PolicyEvaluationError [PolicyEvaluationException]")?;
        if let Some(inner_18) = &self.message {
            write!(f, ": {}", inner_18)?;
        }
        Ok(())
    }
}
impl std::error::Error for PolicyEvaluationError {}
/// See [`PolicyEvaluationError`](crate::error::PolicyEvaluationError)
pub mod policy_evaluation_error {
    /// A builder for [`PolicyEvaluationError`](crate::error::PolicyEvaluationError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`PolicyEvaluationError`](crate::error::PolicyEvaluationError)
        pub fn build(self) -> crate::error::PolicyEvaluationError {
            crate::error::PolicyEvaluationError {
                message: self.message,
            }
        }
    }
}
impl PolicyEvaluationError {
    /// Creates a new builder-style object to manufacture [`PolicyEvaluationError`](crate::error::PolicyEvaluationError)
    pub fn builder() -> crate::error::policy_evaluation_error::Builder {
        crate::error::policy_evaluation_error::Builder::default()
    }
}

/// <p>The request was rejected because the authentication code was not recognized. The error
/// message describes the specific error.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidAuthenticationCodeError {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidAuthenticationCodeError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidAuthenticationCodeError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidAuthenticationCodeError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidAuthenticationCodeError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "InvalidAuthenticationCodeError [InvalidAuthenticationCodeException]"
        )?;
        if let Some(inner_19) = &self.message {
            write!(f, ": {}", inner_19)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidAuthenticationCodeError {}
/// See [`InvalidAuthenticationCodeError`](crate::error::InvalidAuthenticationCodeError)
pub mod invalid_authentication_code_error {
    /// A builder for [`InvalidAuthenticationCodeError`](crate::error::InvalidAuthenticationCodeError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidAuthenticationCodeError`](crate::error::InvalidAuthenticationCodeError)
        pub fn build(self) -> crate::error::InvalidAuthenticationCodeError {
            crate::error::InvalidAuthenticationCodeError {
                message: self.message,
            }
        }
    }
}
impl InvalidAuthenticationCodeError {
    /// Creates a new builder-style object to manufacture [`InvalidAuthenticationCodeError`](crate::error::InvalidAuthenticationCodeError)
    pub fn builder() -> crate::error::invalid_authentication_code_error::Builder {
        crate::error::invalid_authentication_code_error::Builder::default()
    }
}

/// <p>The request failed because AWS service role policies can only be attached to the
/// service-linked role for that service.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PolicyNotAttachableError {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for PolicyNotAttachableError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PolicyNotAttachableError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl PolicyNotAttachableError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for PolicyNotAttachableError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "PolicyNotAttachableError [PolicyNotAttachableException]")?;
        if let Some(inner_20) = &self.message {
            write!(f, ": {}", inner_20)?;
        }
        Ok(())
    }
}
impl std::error::Error for PolicyNotAttachableError {}
/// See [`PolicyNotAttachableError`](crate::error::PolicyNotAttachableError)
pub mod policy_not_attachable_error {
    /// A builder for [`PolicyNotAttachableError`](crate::error::PolicyNotAttachableError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`PolicyNotAttachableError`](crate::error::PolicyNotAttachableError)
        pub fn build(self) -> crate::error::PolicyNotAttachableError {
            crate::error::PolicyNotAttachableError {
                message: self.message,
            }
        }
    }
}
impl PolicyNotAttachableError {
    /// Creates a new builder-style object to manufacture [`PolicyNotAttachableError`](crate::error::PolicyNotAttachableError)
    pub fn builder() -> crate::error::policy_not_attachable_error::Builder {
        crate::error::policy_not_attachable_error::Builder::default()
    }
}

/// <p>The specified service does not support service-specific credentials.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ServiceNotSupportedError {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ServiceNotSupportedError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ServiceNotSupportedError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ServiceNotSupportedError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ServiceNotSupportedError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ServiceNotSupportedError [ServiceNotSupportedException]")?;
        if let Some(inner_21) = &self.message {
            write!(f, ": {}", inner_21)?;
        }
        Ok(())
    }
}
impl std::error::Error for ServiceNotSupportedError {}
/// See [`ServiceNotSupportedError`](crate::error::ServiceNotSupportedError)
pub mod service_not_supported_error {
    /// A builder for [`ServiceNotSupportedError`](crate::error::ServiceNotSupportedError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ServiceNotSupportedError`](crate::error::ServiceNotSupportedError)
        pub fn build(self) -> crate::error::ServiceNotSupportedError {
            crate::error::ServiceNotSupportedError {
                message: self.message,
            }
        }
    }
}
impl ServiceNotSupportedError {
    /// Creates a new builder-style object to manufacture [`ServiceNotSupportedError`](crate::error::ServiceNotSupportedError)
    pub fn builder() -> crate::error::service_not_supported_error::Builder {
        crate::error::service_not_supported_error::Builder::default()
    }
}

/// <p>The request was rejected because the credential report is still being generated.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CredentialReportNotReadyError {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for CredentialReportNotReadyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CredentialReportNotReadyError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl CredentialReportNotReadyError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for CredentialReportNotReadyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "CredentialReportNotReadyError [CredentialReportNotReadyException]"
        )?;
        if let Some(inner_22) = &self.message {
            write!(f, ": {}", inner_22)?;
        }
        Ok(())
    }
}
impl std::error::Error for CredentialReportNotReadyError {}
/// See [`CredentialReportNotReadyError`](crate::error::CredentialReportNotReadyError)
pub mod credential_report_not_ready_error {
    /// A builder for [`CredentialReportNotReadyError`](crate::error::CredentialReportNotReadyError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`CredentialReportNotReadyError`](crate::error::CredentialReportNotReadyError)
        pub fn build(self) -> crate::error::CredentialReportNotReadyError {
            crate::error::CredentialReportNotReadyError {
                message: self.message,
            }
        }
    }
}
impl CredentialReportNotReadyError {
    /// Creates a new builder-style object to manufacture [`CredentialReportNotReadyError`](crate::error::CredentialReportNotReadyError)
    pub fn builder() -> crate::error::credential_report_not_ready_error::Builder {
        crate::error::credential_report_not_ready_error::Builder::default()
    }
}

/// <p>The request was rejected because the credential report does not exist. To generate a
/// credential report, use <a>GenerateCredentialReport</a>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CredentialReportNotPresentError {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for CredentialReportNotPresentError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CredentialReportNotPresentError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl CredentialReportNotPresentError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for CredentialReportNotPresentError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "CredentialReportNotPresentError [CredentialReportNotPresentException]"
        )?;
        if let Some(inner_23) = &self.message {
            write!(f, ": {}", inner_23)?;
        }
        Ok(())
    }
}
impl std::error::Error for CredentialReportNotPresentError {}
/// See [`CredentialReportNotPresentError`](crate::error::CredentialReportNotPresentError)
pub mod credential_report_not_present_error {
    /// A builder for [`CredentialReportNotPresentError`](crate::error::CredentialReportNotPresentError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`CredentialReportNotPresentError`](crate::error::CredentialReportNotPresentError)
        pub fn build(self) -> crate::error::CredentialReportNotPresentError {
            crate::error::CredentialReportNotPresentError {
                message: self.message,
            }
        }
    }
}
impl CredentialReportNotPresentError {
    /// Creates a new builder-style object to manufacture [`CredentialReportNotPresentError`](crate::error::CredentialReportNotPresentError)
    pub fn builder() -> crate::error::credential_report_not_present_error::Builder {
        crate::error::credential_report_not_present_error::Builder::default()
    }
}

/// <p>The request was rejected because the most recent credential report has expired. To
/// generate a new credential report, use <a>GenerateCredentialReport</a>. For more
/// information about credential report expiration, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/credential-reports.html">Getting credential reports</a> in the
/// <i>IAM User Guide</i>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CredentialReportExpiredError {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for CredentialReportExpiredError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CredentialReportExpiredError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl CredentialReportExpiredError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for CredentialReportExpiredError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "CredentialReportExpiredError [CredentialReportExpiredException]"
        )?;
        if let Some(inner_24) = &self.message {
            write!(f, ": {}", inner_24)?;
        }
        Ok(())
    }
}
impl std::error::Error for CredentialReportExpiredError {}
/// See [`CredentialReportExpiredError`](crate::error::CredentialReportExpiredError)
pub mod credential_report_expired_error {
    /// A builder for [`CredentialReportExpiredError`](crate::error::CredentialReportExpiredError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`CredentialReportExpiredError`](crate::error::CredentialReportExpiredError)
        pub fn build(self) -> crate::error::CredentialReportExpiredError {
            crate::error::CredentialReportExpiredError {
                message: self.message,
            }
        }
    }
}
impl CredentialReportExpiredError {
    /// Creates a new builder-style object to manufacture [`CredentialReportExpiredError`](crate::error::CredentialReportExpiredError)
    pub fn builder() -> crate::error::credential_report_expired_error::Builder {
        crate::error::credential_report_expired_error::Builder::default()
    }
}

/// <p>The request failed because the maximum number of concurrent requests for this account are
/// already running.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ReportGenerationLimitExceededError {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ReportGenerationLimitExceededError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ReportGenerationLimitExceededError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ReportGenerationLimitExceededError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ReportGenerationLimitExceededError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "ReportGenerationLimitExceededError [ReportGenerationLimitExceededException]"
        )?;
        if let Some(inner_25) = &self.message {
            write!(f, ": {}", inner_25)?;
        }
        Ok(())
    }
}
impl std::error::Error for ReportGenerationLimitExceededError {}
/// See [`ReportGenerationLimitExceededError`](crate::error::ReportGenerationLimitExceededError)
pub mod report_generation_limit_exceeded_error {
    /// A builder for [`ReportGenerationLimitExceededError`](crate::error::ReportGenerationLimitExceededError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ReportGenerationLimitExceededError`](crate::error::ReportGenerationLimitExceededError)
        pub fn build(self) -> crate::error::ReportGenerationLimitExceededError {
            crate::error::ReportGenerationLimitExceededError {
                message: self.message,
            }
        }
    }
}
impl ReportGenerationLimitExceededError {
    /// Creates a new builder-style object to manufacture [`ReportGenerationLimitExceededError`](crate::error::ReportGenerationLimitExceededError)
    pub fn builder() -> crate::error::report_generation_limit_exceeded_error::Builder {
        crate::error::report_generation_limit_exceeded_error::Builder::default()
    }
}

/// <p>The request was rejected because it attempted to delete a resource that has attached
/// subordinate entities. The error message describes these entities.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteConflictError {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DeleteConflictError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteConflictError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl DeleteConflictError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for DeleteConflictError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "DeleteConflictError [DeleteConflictException]")?;
        if let Some(inner_26) = &self.message {
            write!(f, ": {}", inner_26)?;
        }
        Ok(())
    }
}
impl std::error::Error for DeleteConflictError {}
/// See [`DeleteConflictError`](crate::error::DeleteConflictError)
pub mod delete_conflict_error {
    /// A builder for [`DeleteConflictError`](crate::error::DeleteConflictError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteConflictError`](crate::error::DeleteConflictError)
        pub fn build(self) -> crate::error::DeleteConflictError {
            crate::error::DeleteConflictError {
                message: self.message,
            }
        }
    }
}
impl DeleteConflictError {
    /// Creates a new builder-style object to manufacture [`DeleteConflictError`](crate::error::DeleteConflictError)
    pub fn builder() -> crate::error::delete_conflict_error::Builder {
        crate::error::delete_conflict_error::Builder::default()
    }
}

/// <p>The request was rejected because the type of user for the transaction was
/// incorrect.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidUserTypeError {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidUserTypeError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidUserTypeError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidUserTypeError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidUserTypeError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidUserTypeError [InvalidUserTypeException]")?;
        if let Some(inner_27) = &self.message {
            write!(f, ": {}", inner_27)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidUserTypeError {}
/// See [`InvalidUserTypeError`](crate::error::InvalidUserTypeError)
pub mod invalid_user_type_error {
    /// A builder for [`InvalidUserTypeError`](crate::error::InvalidUserTypeError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidUserTypeError`](crate::error::InvalidUserTypeError)
        pub fn build(self) -> crate::error::InvalidUserTypeError {
            crate::error::InvalidUserTypeError {
                message: self.message,
            }
        }
    }
}
impl InvalidUserTypeError {
    /// Creates a new builder-style object to manufacture [`InvalidUserTypeError`](crate::error::InvalidUserTypeError)
    pub fn builder() -> crate::error::invalid_user_type_error::Builder {
        crate::error::invalid_user_type_error::Builder::default()
    }
}
