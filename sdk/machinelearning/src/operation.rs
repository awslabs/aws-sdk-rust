// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
/// <p>Adds one or more tags to an object, up to a limit of 10. Each tag consists of a key
/// and an optional value. If you add a tag using a key that is already associated with the ML object,
/// <code>AddTags</code> updates the tag's value.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct AddTags {
    _private: (),
}
impl AddTags {
    /// Creates a new builder-style object to manufacture [`AddTagsInput`](crate::input::AddTagsInput)
    pub fn builder() -> crate::input::add_tags_input::Builder {
        crate::input::add_tags_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for AddTags {
    type Output = std::result::Result<crate::output::AddTagsOutput, crate::error::AddTagsError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_add_tags_error(response)
        } else {
            crate::operation_ser::parse_add_tags_response(response)
        }
    }
}

/// <p>Generates predictions for a group of observations. The observations to process exist in one or more data files referenced
/// by a <code>DataSource</code>. This operation creates a new <code>BatchPrediction</code>, and uses an <code>MLModel</code> and the data
/// files referenced by the <code>DataSource</code> as information sources.
/// </p>
/// <p>
/// <code>CreateBatchPrediction</code> is an asynchronous operation. In response to <code>CreateBatchPrediction</code>,
/// Amazon Machine Learning (Amazon ML) immediately returns and sets the <code>BatchPrediction</code> status to <code>PENDING</code>.
/// After the <code>BatchPrediction</code> completes, Amazon ML sets the status to <code>COMPLETED</code>.
/// </p>
/// <p>You can poll for status updates by using the <a>GetBatchPrediction</a> operation and checking the <code>Status</code> parameter of the result. After the <code>COMPLETED</code> status appears,
/// the results are available in the location specified by the <code>OutputUri</code> parameter.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateBatchPrediction {
    _private: (),
}
impl CreateBatchPrediction {
    /// Creates a new builder-style object to manufacture [`CreateBatchPredictionInput`](crate::input::CreateBatchPredictionInput)
    pub fn builder() -> crate::input::create_batch_prediction_input::Builder {
        crate::input::create_batch_prediction_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateBatchPrediction {
    type Output = std::result::Result<
        crate::output::CreateBatchPredictionOutput,
        crate::error::CreateBatchPredictionError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_create_batch_prediction_error(response)
        } else {
            crate::operation_ser::parse_create_batch_prediction_response(response)
        }
    }
}

/// <p>Creates a <code>DataSource</code> object from an <a href="http://aws.amazon.com/rds/"> Amazon Relational Database Service</a> (Amazon RDS). A <code>DataSource</code> references data that can be used to perform <code>CreateMLModel</code>, <code>CreateEvaluation</code>, or <code>CreateBatchPrediction</code> operations.</p>
/// <p>
/// <code>CreateDataSourceFromRDS</code> is an asynchronous operation. In response to <code>CreateDataSourceFromRDS</code>,
/// Amazon Machine Learning (Amazon ML) immediately returns and sets the <code>DataSource</code> status to <code>PENDING</code>.
/// After the <code>DataSource</code> is created and ready for use, Amazon ML sets the <code>Status</code> parameter to <code>COMPLETED</code>.
/// <code>DataSource</code> in the <code>COMPLETED</code> or <code>PENDING</code> state can
/// be used only to perform <code>>CreateMLModel</code>>, <code>CreateEvaluation</code>, or <code>CreateBatchPrediction</code> operations.
/// </p>
/// <p>
/// If Amazon ML cannot accept the input source, it sets the <code>Status</code> parameter to <code>FAILED</code> and includes an error message in the <code>Message</code> attribute of the <code>GetDataSource</code> operation response.
/// </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateDataSourceFromRDS {
    _private: (),
}
impl CreateDataSourceFromRDS {
    /// Creates a new builder-style object to manufacture [`CreateDataSourceFromRdsInput`](crate::input::CreateDataSourceFromRdsInput)
    pub fn builder() -> crate::input::create_data_source_from_rds_input::Builder {
        crate::input::create_data_source_from_rds_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateDataSourceFromRDS {
    type Output = std::result::Result<
        crate::output::CreateDataSourceFromRdsOutput,
        crate::error::CreateDataSourceFromRDSError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_create_data_source_from_rds_error(response)
        } else {
            crate::operation_ser::parse_create_data_source_from_rds_response(response)
        }
    }
}

/// <p>Creates a <code>DataSource</code> from a database hosted on an Amazon Redshift cluster. A
/// <code>DataSource</code> references data that can be used to perform either <code>CreateMLModel</code>, <code>CreateEvaluation</code>, or <code>CreateBatchPrediction</code>
/// operations.</p>
/// <p>
/// <code>CreateDataSourceFromRedshift</code> is an asynchronous operation. In response to <code>CreateDataSourceFromRedshift</code>, Amazon Machine Learning (Amazon ML) immediately returns and sets the <code>DataSource</code> status to <code>PENDING</code>.
/// After the <code>DataSource</code> is created and ready for use, Amazon ML sets the <code>Status</code> parameter to <code>COMPLETED</code>.
/// <code>DataSource</code> in <code>COMPLETED</code> or <code>PENDING</code> states can be
/// used to perform only <code>CreateMLModel</code>, <code>CreateEvaluation</code>, or <code>CreateBatchPrediction</code> operations.
/// </p>
/// <p>
/// If Amazon ML can't accept the input source, it sets the <code>Status</code> parameter to <code>FAILED</code> and includes an error message in the <code>Message</code>
/// attribute of the <code>GetDataSource</code> operation response.
/// </p>
/// <p>The observations should be contained in the database hosted on an Amazon Redshift cluster
/// and should be specified by a <code>SelectSqlQuery</code> query. Amazon ML executes an
/// <code>Unload</code> command in Amazon Redshift to transfer the result set of
/// the <code>SelectSqlQuery</code> query to <code>S3StagingLocation</code>.</p>
/// <p>After the <code>DataSource</code> has been created, it's ready for use in evaluations and
/// batch predictions. If you plan to use the <code>DataSource</code> to train an
/// <code>MLModel</code>, the <code>DataSource</code> also requires a recipe. A recipe
/// describes how each input variable will be used in training an <code>MLModel</code>. Will
/// the variable be included or excluded from training? Will the variable be manipulated;
/// for example, will it be combined with another variable or will it be split apart into
/// word combinations? The recipe provides answers to these questions.</p>
/// <p>You can't change an existing datasource, but you can copy and modify the settings from an
/// existing Amazon Redshift datasource to create a new datasource. To do so, call
/// <code>GetDataSource</code> for an existing datasource and copy the values to a
/// <code>CreateDataSource</code> call. Change the settings that you want to change and
/// make sure that all required fields have the appropriate values.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateDataSourceFromRedshift {
    _private: (),
}
impl CreateDataSourceFromRedshift {
    /// Creates a new builder-style object to manufacture [`CreateDataSourceFromRedshiftInput`](crate::input::CreateDataSourceFromRedshiftInput)
    pub fn builder() -> crate::input::create_data_source_from_redshift_input::Builder {
        crate::input::create_data_source_from_redshift_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateDataSourceFromRedshift {
    type Output = std::result::Result<
        crate::output::CreateDataSourceFromRedshiftOutput,
        crate::error::CreateDataSourceFromRedshiftError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_create_data_source_from_redshift_error(response)
        } else {
            crate::operation_ser::parse_create_data_source_from_redshift_response(response)
        }
    }
}

/// <p>Creates a <code>DataSource</code> object. A <code>DataSource</code> references data that
/// can be used to perform  <code>CreateMLModel</code>, <code>CreateEvaluation</code>, or
/// <code>CreateBatchPrediction</code> operations.</p>
/// <p>
/// <code>CreateDataSourceFromS3</code> is an asynchronous operation. In response to
/// <code>CreateDataSourceFromS3</code>, Amazon Machine Learning (Amazon ML) immediately
/// returns and sets the <code>DataSource</code> status to <code>PENDING</code>. After the
/// <code>DataSource</code> has been created and is ready for use, Amazon ML sets the
/// <code>Status</code> parameter to <code>COMPLETED</code>. <code>DataSource</code> in
/// the <code>COMPLETED</code> or <code>PENDING</code> state can be used to perform only
/// <code>CreateMLModel</code>, <code>CreateEvaluation</code> or
/// <code>CreateBatchPrediction</code> operations. </p>
/// <p> If Amazon ML can't accept the input source, it sets the <code>Status</code> parameter to
/// <code>FAILED</code> and includes an error message in the <code>Message</code>
/// attribute of the <code>GetDataSource</code> operation response. </p>
/// <p>The observation data used in a <code>DataSource</code> should be ready to use; that is,
/// it should have a consistent structure, and missing data values should be kept to a
/// minimum. The observation data must reside in one or more .csv files in an Amazon Simple
/// Storage Service (Amazon S3) location, along with a schema that describes the data items
/// by name and type. The same schema must be used for all of the data files referenced by
/// the <code>DataSource</code>. </p>
/// <p>After the <code>DataSource</code> has been created, it's ready to use in evaluations and
/// batch predictions. If you plan to use the <code>DataSource</code> to train an
/// <code>MLModel</code>, the <code>DataSource</code> also needs a recipe. A recipe
/// describes how each input variable will be used in training an <code>MLModel</code>. Will
/// the variable be included or excluded from training? Will the variable be manipulated;
/// for example, will it be combined with another variable or will it be split apart into
/// word combinations? The recipe provides answers to these questions.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateDataSourceFromS3 {
    _private: (),
}
impl CreateDataSourceFromS3 {
    /// Creates a new builder-style object to manufacture [`CreateDataSourceFromS3Input`](crate::input::CreateDataSourceFromS3Input)
    pub fn builder() -> crate::input::create_data_source_from_s3_input::Builder {
        crate::input::create_data_source_from_s3_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateDataSourceFromS3 {
    type Output = std::result::Result<
        crate::output::CreateDataSourceFromS3Output,
        crate::error::CreateDataSourceFromS3Error,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_create_data_source_from_s3_error(response)
        } else {
            crate::operation_ser::parse_create_data_source_from_s3_response(response)
        }
    }
}

/// <p>Creates a new <code>Evaluation</code> of an <code>MLModel</code>. An <code>MLModel</code> is evaluated on a set of observations associated to a <code>DataSource</code>. Like a <code>DataSource</code>
/// for an <code>MLModel</code>, the <code>DataSource</code> for an <code>Evaluation</code> contains values for the <code>Target Variable</code>. The <code>Evaluation</code> compares the predicted result for each observation to the actual outcome and provides a
/// summary so that you know how effective the <code>MLModel</code> functions on the test
/// data. Evaluation generates a relevant performance metric, such as BinaryAUC, RegressionRMSE or MulticlassAvgFScore based on the corresponding <code>MLModelType</code>: <code>BINARY</code>, <code>REGRESSION</code> or <code>MULTICLASS</code>.
/// </p>
/// <p>
/// <code>CreateEvaluation</code> is an asynchronous operation. In response to <code>CreateEvaluation</code>, Amazon Machine Learning (Amazon ML) immediately
/// returns and sets the evaluation status to <code>PENDING</code>. After the <code>Evaluation</code> is created and ready for use,
/// Amazon ML sets the status to <code>COMPLETED</code>.
/// </p>
/// <p>You can use the <code>GetEvaluation</code> operation to check progress of the evaluation during the creation operation.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateEvaluation {
    _private: (),
}
impl CreateEvaluation {
    /// Creates a new builder-style object to manufacture [`CreateEvaluationInput`](crate::input::CreateEvaluationInput)
    pub fn builder() -> crate::input::create_evaluation_input::Builder {
        crate::input::create_evaluation_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateEvaluation {
    type Output = std::result::Result<
        crate::output::CreateEvaluationOutput,
        crate::error::CreateEvaluationError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_create_evaluation_error(response)
        } else {
            crate::operation_ser::parse_create_evaluation_response(response)
        }
    }
}

/// <p>Creates a new <code>MLModel</code> using the <code>DataSource</code> and the recipe as
/// information sources. </p>
/// <p>An <code>MLModel</code> is nearly immutable. Users can update only the
/// <code>MLModelName</code> and the <code>ScoreThreshold</code> in an
/// <code>MLModel</code> without creating a new <code>MLModel</code>. </p>
/// <p>
/// <code>CreateMLModel</code> is an asynchronous operation. In response to
/// <code>CreateMLModel</code>, Amazon Machine Learning (Amazon ML) immediately returns
/// and sets the <code>MLModel</code> status to <code>PENDING</code>. After the
/// <code>MLModel</code> has been created and ready is for use, Amazon ML sets the
/// status to <code>COMPLETED</code>. </p>
/// <p>You can use the <code>GetMLModel</code> operation to check the progress of the
/// <code>MLModel</code> during the creation operation.</p>
/// <p>
/// <code>CreateMLModel</code> requires a <code>DataSource</code> with computed statistics,
/// which can be created by setting <code>ComputeStatistics</code> to <code>true</code> in
/// <code>CreateDataSourceFromRDS</code>, <code>CreateDataSourceFromS3</code>, or
/// <code>CreateDataSourceFromRedshift</code> operations.
/// </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateMLModel {
    _private: (),
}
impl CreateMLModel {
    /// Creates a new builder-style object to manufacture [`CreateMlModelInput`](crate::input::CreateMlModelInput)
    pub fn builder() -> crate::input::create_ml_model_input::Builder {
        crate::input::create_ml_model_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateMLModel {
    type Output =
        std::result::Result<crate::output::CreateMlModelOutput, crate::error::CreateMLModelError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_create_ml_model_error(response)
        } else {
            crate::operation_ser::parse_create_ml_model_response(response)
        }
    }
}

/// <p>Creates a real-time endpoint for the <code>MLModel</code>. The endpoint contains the URI of the <code>MLModel</code>; that is, the location to send real-time prediction requests for the specified <code>MLModel</code>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateRealtimeEndpoint {
    _private: (),
}
impl CreateRealtimeEndpoint {
    /// Creates a new builder-style object to manufacture [`CreateRealtimeEndpointInput`](crate::input::CreateRealtimeEndpointInput)
    pub fn builder() -> crate::input::create_realtime_endpoint_input::Builder {
        crate::input::create_realtime_endpoint_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateRealtimeEndpoint {
    type Output = std::result::Result<
        crate::output::CreateRealtimeEndpointOutput,
        crate::error::CreateRealtimeEndpointError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_create_realtime_endpoint_error(response)
        } else {
            crate::operation_ser::parse_create_realtime_endpoint_response(response)
        }
    }
}

/// <p>Assigns the DELETED status to a <code>BatchPrediction</code>, rendering it unusable.</p>
/// <p>After using the <code>DeleteBatchPrediction</code> operation, you can use the <a>GetBatchPrediction</a>
/// operation to verify that the status of the <code>BatchPrediction</code> changed to DELETED.</p>
/// <p>
/// <b>Caution:</b> The result of the <code>DeleteBatchPrediction</code> operation is irreversible.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteBatchPrediction {
    _private: (),
}
impl DeleteBatchPrediction {
    /// Creates a new builder-style object to manufacture [`DeleteBatchPredictionInput`](crate::input::DeleteBatchPredictionInput)
    pub fn builder() -> crate::input::delete_batch_prediction_input::Builder {
        crate::input::delete_batch_prediction_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteBatchPrediction {
    type Output = std::result::Result<
        crate::output::DeleteBatchPredictionOutput,
        crate::error::DeleteBatchPredictionError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_delete_batch_prediction_error(response)
        } else {
            crate::operation_ser::parse_delete_batch_prediction_response(response)
        }
    }
}

/// <p>Assigns the DELETED status to a <code>DataSource</code>, rendering it unusable.</p>
/// <p>After using the <code>DeleteDataSource</code> operation, you can use the <a>GetDataSource</a> operation to verify that the status of the <code>DataSource</code> changed to DELETED.</p>
/// <p>
/// <b>Caution:</b> The results of the <code>DeleteDataSource</code> operation are irreversible.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteDataSource {
    _private: (),
}
impl DeleteDataSource {
    /// Creates a new builder-style object to manufacture [`DeleteDataSourceInput`](crate::input::DeleteDataSourceInput)
    pub fn builder() -> crate::input::delete_data_source_input::Builder {
        crate::input::delete_data_source_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteDataSource {
    type Output = std::result::Result<
        crate::output::DeleteDataSourceOutput,
        crate::error::DeleteDataSourceError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_delete_data_source_error(response)
        } else {
            crate::operation_ser::parse_delete_data_source_response(response)
        }
    }
}

/// <p>Assigns the <code>DELETED</code> status to an <code>Evaluation</code>, rendering it unusable.</p>
/// <p>After invoking the <code>DeleteEvaluation</code> operation, you can use the
/// <code>GetEvaluation</code> operation to verify that the status of the <code>Evaluation</code> changed to <code>DELETED</code>.</p>
/// <p>
/// <b>Caution:</b> The results of the <code>DeleteEvaluation</code> operation are irreversible.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteEvaluation {
    _private: (),
}
impl DeleteEvaluation {
    /// Creates a new builder-style object to manufacture [`DeleteEvaluationInput`](crate::input::DeleteEvaluationInput)
    pub fn builder() -> crate::input::delete_evaluation_input::Builder {
        crate::input::delete_evaluation_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteEvaluation {
    type Output = std::result::Result<
        crate::output::DeleteEvaluationOutput,
        crate::error::DeleteEvaluationError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_delete_evaluation_error(response)
        } else {
            crate::operation_ser::parse_delete_evaluation_response(response)
        }
    }
}

/// <p>Assigns the <code>DELETED</code> status to an <code>MLModel</code>, rendering it unusable.</p>
/// <p>After using the <code>DeleteMLModel</code> operation, you can use the
/// <code>GetMLModel</code> operation to verify that the status of the <code>MLModel</code> changed to DELETED.</p>
/// <p>
/// <b>Caution:</b> The result of the <code>DeleteMLModel</code> operation is irreversible.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteMLModel {
    _private: (),
}
impl DeleteMLModel {
    /// Creates a new builder-style object to manufacture [`DeleteMlModelInput`](crate::input::DeleteMlModelInput)
    pub fn builder() -> crate::input::delete_ml_model_input::Builder {
        crate::input::delete_ml_model_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteMLModel {
    type Output =
        std::result::Result<crate::output::DeleteMlModelOutput, crate::error::DeleteMLModelError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_delete_ml_model_error(response)
        } else {
            crate::operation_ser::parse_delete_ml_model_response(response)
        }
    }
}

/// <p>Deletes a real time endpoint of an <code>MLModel</code>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteRealtimeEndpoint {
    _private: (),
}
impl DeleteRealtimeEndpoint {
    /// Creates a new builder-style object to manufacture [`DeleteRealtimeEndpointInput`](crate::input::DeleteRealtimeEndpointInput)
    pub fn builder() -> crate::input::delete_realtime_endpoint_input::Builder {
        crate::input::delete_realtime_endpoint_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteRealtimeEndpoint {
    type Output = std::result::Result<
        crate::output::DeleteRealtimeEndpointOutput,
        crate::error::DeleteRealtimeEndpointError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_delete_realtime_endpoint_error(response)
        } else {
            crate::operation_ser::parse_delete_realtime_endpoint_response(response)
        }
    }
}

/// <p>Deletes the specified tags associated with an ML object. After this operation is complete, you can't recover deleted tags.</p>
/// <p>If you specify a tag that doesn't exist, Amazon ML ignores it.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteTags {
    _private: (),
}
impl DeleteTags {
    /// Creates a new builder-style object to manufacture [`DeleteTagsInput`](crate::input::DeleteTagsInput)
    pub fn builder() -> crate::input::delete_tags_input::Builder {
        crate::input::delete_tags_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteTags {
    type Output =
        std::result::Result<crate::output::DeleteTagsOutput, crate::error::DeleteTagsError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_delete_tags_error(response)
        } else {
            crate::operation_ser::parse_delete_tags_response(response)
        }
    }
}

/// <p>Returns a list of <code>BatchPrediction</code> operations that match the search criteria in the request.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeBatchPredictions {
    _private: (),
}
impl DescribeBatchPredictions {
    /// Creates a new builder-style object to manufacture [`DescribeBatchPredictionsInput`](crate::input::DescribeBatchPredictionsInput)
    pub fn builder() -> crate::input::describe_batch_predictions_input::Builder {
        crate::input::describe_batch_predictions_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeBatchPredictions {
    type Output = std::result::Result<
        crate::output::DescribeBatchPredictionsOutput,
        crate::error::DescribeBatchPredictionsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_describe_batch_predictions_error(response)
        } else {
            crate::operation_ser::parse_describe_batch_predictions_response(response)
        }
    }
}

/// <p>Returns a list of <code>DataSource</code> that match the search criteria in the request.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeDataSources {
    _private: (),
}
impl DescribeDataSources {
    /// Creates a new builder-style object to manufacture [`DescribeDataSourcesInput`](crate::input::DescribeDataSourcesInput)
    pub fn builder() -> crate::input::describe_data_sources_input::Builder {
        crate::input::describe_data_sources_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeDataSources {
    type Output = std::result::Result<
        crate::output::DescribeDataSourcesOutput,
        crate::error::DescribeDataSourcesError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_describe_data_sources_error(response)
        } else {
            crate::operation_ser::parse_describe_data_sources_response(response)
        }
    }
}

/// <p>Returns a list of <code>DescribeEvaluations</code> that match the search criteria in the request.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeEvaluations {
    _private: (),
}
impl DescribeEvaluations {
    /// Creates a new builder-style object to manufacture [`DescribeEvaluationsInput`](crate::input::DescribeEvaluationsInput)
    pub fn builder() -> crate::input::describe_evaluations_input::Builder {
        crate::input::describe_evaluations_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeEvaluations {
    type Output = std::result::Result<
        crate::output::DescribeEvaluationsOutput,
        crate::error::DescribeEvaluationsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_describe_evaluations_error(response)
        } else {
            crate::operation_ser::parse_describe_evaluations_response(response)
        }
    }
}

/// <p>Returns a list of <code>MLModel</code> that match the search criteria in the request.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeMLModels {
    _private: (),
}
impl DescribeMLModels {
    /// Creates a new builder-style object to manufacture [`DescribeMlModelsInput`](crate::input::DescribeMlModelsInput)
    pub fn builder() -> crate::input::describe_ml_models_input::Builder {
        crate::input::describe_ml_models_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeMLModels {
    type Output = std::result::Result<
        crate::output::DescribeMlModelsOutput,
        crate::error::DescribeMLModelsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_describe_ml_models_error(response)
        } else {
            crate::operation_ser::parse_describe_ml_models_response(response)
        }
    }
}

/// <p>Describes one or more of the tags for your Amazon ML object.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeTags {
    _private: (),
}
impl DescribeTags {
    /// Creates a new builder-style object to manufacture [`DescribeTagsInput`](crate::input::DescribeTagsInput)
    pub fn builder() -> crate::input::describe_tags_input::Builder {
        crate::input::describe_tags_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeTags {
    type Output =
        std::result::Result<crate::output::DescribeTagsOutput, crate::error::DescribeTagsError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_describe_tags_error(response)
        } else {
            crate::operation_ser::parse_describe_tags_response(response)
        }
    }
}

/// <p>Returns a <code>BatchPrediction</code> that includes detailed metadata, status, and data file information for a
/// <code>Batch Prediction</code> request.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetBatchPrediction {
    _private: (),
}
impl GetBatchPrediction {
    /// Creates a new builder-style object to manufacture [`GetBatchPredictionInput`](crate::input::GetBatchPredictionInput)
    pub fn builder() -> crate::input::get_batch_prediction_input::Builder {
        crate::input::get_batch_prediction_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetBatchPrediction {
    type Output = std::result::Result<
        crate::output::GetBatchPredictionOutput,
        crate::error::GetBatchPredictionError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_get_batch_prediction_error(response)
        } else {
            crate::operation_ser::parse_get_batch_prediction_response(response)
        }
    }
}

/// <p>Returns a <code>DataSource</code> that includes metadata and data file information, as well as the current status of the <code>DataSource</code>.</p>
/// <p>
/// <code>GetDataSource</code> provides results in normal or verbose format. The verbose format
/// adds the schema description and the list of files pointed to by the DataSource to the normal format.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetDataSource {
    _private: (),
}
impl GetDataSource {
    /// Creates a new builder-style object to manufacture [`GetDataSourceInput`](crate::input::GetDataSourceInput)
    pub fn builder() -> crate::input::get_data_source_input::Builder {
        crate::input::get_data_source_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetDataSource {
    type Output =
        std::result::Result<crate::output::GetDataSourceOutput, crate::error::GetDataSourceError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_get_data_source_error(response)
        } else {
            crate::operation_ser::parse_get_data_source_response(response)
        }
    }
}

/// <p>Returns an <code>Evaluation</code> that includes metadata as well as the current status of the <code>Evaluation</code>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetEvaluation {
    _private: (),
}
impl GetEvaluation {
    /// Creates a new builder-style object to manufacture [`GetEvaluationInput`](crate::input::GetEvaluationInput)
    pub fn builder() -> crate::input::get_evaluation_input::Builder {
        crate::input::get_evaluation_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetEvaluation {
    type Output =
        std::result::Result<crate::output::GetEvaluationOutput, crate::error::GetEvaluationError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_get_evaluation_error(response)
        } else {
            crate::operation_ser::parse_get_evaluation_response(response)
        }
    }
}

/// <p>Returns an <code>MLModel</code> that includes detailed metadata, data source information, and the current status of the <code>MLModel</code>.</p>
/// <p>
/// <code>GetMLModel</code> provides results in normal or verbose format. </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetMLModel {
    _private: (),
}
impl GetMLModel {
    /// Creates a new builder-style object to manufacture [`GetMlModelInput`](crate::input::GetMlModelInput)
    pub fn builder() -> crate::input::get_ml_model_input::Builder {
        crate::input::get_ml_model_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetMLModel {
    type Output =
        std::result::Result<crate::output::GetMlModelOutput, crate::error::GetMLModelError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_get_ml_model_error(response)
        } else {
            crate::operation_ser::parse_get_ml_model_response(response)
        }
    }
}

/// <p>Generates a prediction for the observation using the specified <code>ML Model</code>.</p>
/// <p>
/// <b>Note:</b> Not all response parameters will be populated. Whether a
/// response parameter is populated depends on the type of model requested.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct Predict {
    _private: (),
}
impl Predict {
    /// Creates a new builder-style object to manufacture [`PredictInput`](crate::input::PredictInput)
    pub fn builder() -> crate::input::predict_input::Builder {
        crate::input::predict_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for Predict {
    type Output = std::result::Result<crate::output::PredictOutput, crate::error::PredictError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_predict_error(response)
        } else {
            crate::operation_ser::parse_predict_response(response)
        }
    }
}

/// <p>Updates the <code>BatchPredictionName</code> of a <code>BatchPrediction</code>.</p>
/// <p>You can use the <code>GetBatchPrediction</code> operation to view the contents of the updated data element.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdateBatchPrediction {
    _private: (),
}
impl UpdateBatchPrediction {
    /// Creates a new builder-style object to manufacture [`UpdateBatchPredictionInput`](crate::input::UpdateBatchPredictionInput)
    pub fn builder() -> crate::input::update_batch_prediction_input::Builder {
        crate::input::update_batch_prediction_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdateBatchPrediction {
    type Output = std::result::Result<
        crate::output::UpdateBatchPredictionOutput,
        crate::error::UpdateBatchPredictionError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_update_batch_prediction_error(response)
        } else {
            crate::operation_ser::parse_update_batch_prediction_response(response)
        }
    }
}

/// <p>Updates the <code>DataSourceName</code> of a <code>DataSource</code>.</p>
/// <p>You can use the <code>GetDataSource</code> operation to view the contents of the updated data element.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdateDataSource {
    _private: (),
}
impl UpdateDataSource {
    /// Creates a new builder-style object to manufacture [`UpdateDataSourceInput`](crate::input::UpdateDataSourceInput)
    pub fn builder() -> crate::input::update_data_source_input::Builder {
        crate::input::update_data_source_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdateDataSource {
    type Output = std::result::Result<
        crate::output::UpdateDataSourceOutput,
        crate::error::UpdateDataSourceError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_update_data_source_error(response)
        } else {
            crate::operation_ser::parse_update_data_source_response(response)
        }
    }
}

/// <p>Updates the <code>EvaluationName</code> of an <code>Evaluation</code>.</p>
/// <p>You can use the <code>GetEvaluation</code> operation to view the contents of the updated data element.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdateEvaluation {
    _private: (),
}
impl UpdateEvaluation {
    /// Creates a new builder-style object to manufacture [`UpdateEvaluationInput`](crate::input::UpdateEvaluationInput)
    pub fn builder() -> crate::input::update_evaluation_input::Builder {
        crate::input::update_evaluation_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdateEvaluation {
    type Output = std::result::Result<
        crate::output::UpdateEvaluationOutput,
        crate::error::UpdateEvaluationError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_update_evaluation_error(response)
        } else {
            crate::operation_ser::parse_update_evaluation_response(response)
        }
    }
}

/// <p>Updates the <code>MLModelName</code> and the <code>ScoreThreshold</code> of an <code>MLModel</code>.</p>
/// <p>You can use the <code>GetMLModel</code> operation to view the contents of the updated data element.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdateMLModel {
    _private: (),
}
impl UpdateMLModel {
    /// Creates a new builder-style object to manufacture [`UpdateMlModelInput`](crate::input::UpdateMlModelInput)
    pub fn builder() -> crate::input::update_ml_model_input::Builder {
        crate::input::update_ml_model_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdateMLModel {
    type Output =
        std::result::Result<crate::output::UpdateMlModelOutput, crate::error::UpdateMLModelError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_update_ml_model_error(response)
        } else {
            crate::operation_ser::parse_update_ml_model_response(response)
        }
    }
}
