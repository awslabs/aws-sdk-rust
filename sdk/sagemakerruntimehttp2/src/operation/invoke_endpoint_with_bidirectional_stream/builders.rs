// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
pub use crate::operation::invoke_endpoint_with_bidirectional_stream::_invoke_endpoint_with_bidirectional_stream_output::InvokeEndpointWithBidirectionalStreamOutputBuilder;

pub use crate::operation::invoke_endpoint_with_bidirectional_stream::_invoke_endpoint_with_bidirectional_stream_input::InvokeEndpointWithBidirectionalStreamInputBuilder;

impl crate::operation::invoke_endpoint_with_bidirectional_stream::builders::InvokeEndpointWithBidirectionalStreamInputBuilder {
    /// Sends a request with this input using the given client.
    pub async fn send_with(
        self,
        client: &crate::Client,
    ) -> ::std::result::Result<
        crate::operation::invoke_endpoint_with_bidirectional_stream::InvokeEndpointWithBidirectionalStreamOutput,
        ::aws_smithy_runtime_api::client::result::SdkError<
            crate::operation::invoke_endpoint_with_bidirectional_stream::InvokeEndpointWithBidirectionalStreamError,
            ::aws_smithy_runtime_api::client::orchestrator::HttpResponse,
        >,
    > {
        let mut fluent_builder = client.invoke_endpoint_with_bidirectional_stream();
        fluent_builder.inner = self;
        fluent_builder.send().await
    }
}
/// Fluent builder constructing a request to `InvokeEndpointWithBidirectionalStream`.
///
/// <p>Invokes a model endpoint with bidirectional streaming capabilities. This operation establishes a persistent connection that allows you to send multiple requests and receive streaming responses from the model in real-time.</p>
/// <p>Bidirectional streaming is useful for interactive applications such as chatbots, real-time translation, or any scenario where you need to maintain a conversation-like interaction with the model. The connection remains open, allowing you to send additional input and receive responses without establishing a new connection for each request.</p>
/// <p>For an overview of Amazon SageMaker AI, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/how-it-works.html">How It Works</a>.</p>
/// <p>Amazon SageMaker AI strips all POST headers except those supported by the API. Amazon SageMaker AI might add additional headers. You should not rely on the behavior of headers outside those enumerated in the request syntax.</p>
/// <p>Calls to <code>InvokeEndpointWithBidirectionalStream</code> are authenticated by using Amazon Web Services Signature Version 4. For information, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/API/sig-v4-authenticating-requests.html">Authenticating Requests (Amazon Web Services Signature Version 4)</a> in the <i>Amazon S3 API Reference</i>.</p>
/// <p>The bidirectional stream maintains the connection until either the client closes it or the model indicates completion. Each request and response in the stream is sent as an event with optional headers for data type and completion state.</p><note>
/// <p>Endpoints are scoped to an individual account, and are not public. The URL does not contain the account ID, but Amazon SageMaker AI determines the account ID from the authentication token that is supplied by the caller.</p>
/// </note>
#[derive(::std::fmt::Debug)]
pub struct InvokeEndpointWithBidirectionalStreamFluentBuilder {
    handle: ::std::sync::Arc<crate::client::Handle>,
    inner: crate::operation::invoke_endpoint_with_bidirectional_stream::builders::InvokeEndpointWithBidirectionalStreamInputBuilder,
    config_override: ::std::option::Option<crate::config::Builder>,
}
impl
    crate::client::customize::internal::CustomizableSend<
        crate::operation::invoke_endpoint_with_bidirectional_stream::InvokeEndpointWithBidirectionalStreamOutput,
        crate::operation::invoke_endpoint_with_bidirectional_stream::InvokeEndpointWithBidirectionalStreamError,
    > for InvokeEndpointWithBidirectionalStreamFluentBuilder
{
    fn send(
        self,
        config_override: crate::config::Builder,
    ) -> crate::client::customize::internal::BoxFuture<
        crate::client::customize::internal::SendResult<
            crate::operation::invoke_endpoint_with_bidirectional_stream::InvokeEndpointWithBidirectionalStreamOutput,
            crate::operation::invoke_endpoint_with_bidirectional_stream::InvokeEndpointWithBidirectionalStreamError,
        >,
    > {
        ::std::boxed::Box::pin(async move { self.config_override(config_override).send().await })
    }
}
impl InvokeEndpointWithBidirectionalStreamFluentBuilder {
    /// Creates a new `InvokeEndpointWithBidirectionalStreamFluentBuilder`.
    pub(crate) fn new(handle: ::std::sync::Arc<crate::client::Handle>) -> Self {
        Self {
            handle,
            inner: ::std::default::Default::default(),
            config_override: ::std::option::Option::None,
        }
    }
    /// Access the InvokeEndpointWithBidirectionalStream as a reference.
    pub fn as_input(
        &self,
    ) -> &crate::operation::invoke_endpoint_with_bidirectional_stream::builders::InvokeEndpointWithBidirectionalStreamInputBuilder {
        &self.inner
    }
    /// Sends the request and returns the response.
    ///
    /// If an error occurs, an `SdkError` will be returned with additional details that
    /// can be matched against.
    ///
    /// By default, any retryable failures will be retried twice. Retry behavior
    /// is configurable with the [RetryConfig](aws_smithy_types::retry::RetryConfig), which can be
    /// set when configuring the client.
    pub async fn send(
        self,
    ) -> ::std::result::Result<
        crate::operation::invoke_endpoint_with_bidirectional_stream::InvokeEndpointWithBidirectionalStreamOutput,
        ::aws_smithy_runtime_api::client::result::SdkError<
            crate::operation::invoke_endpoint_with_bidirectional_stream::InvokeEndpointWithBidirectionalStreamError,
            ::aws_smithy_runtime_api::client::orchestrator::HttpResponse,
        >,
    > {
        let input = self
            .inner
            .build()
            .map_err(::aws_smithy_runtime_api::client::result::SdkError::construction_failure)?;
        let runtime_plugins =
            crate::operation::invoke_endpoint_with_bidirectional_stream::InvokeEndpointWithBidirectionalStream::operation_runtime_plugins(
                self.handle.runtime_plugins.clone(),
                &self.handle.conf,
                self.config_override,
            );
        let mut output =
            crate::operation::invoke_endpoint_with_bidirectional_stream::InvokeEndpointWithBidirectionalStream::orchestrate(&runtime_plugins, input)
                .await?;

        // Converts any error encountered beyond this point into an `SdkError` response error
        // with an `HttpResponse`. However, since we have already exited the `orchestrate`
        // function, the original `HttpResponse` is no longer available and cannot be restored.
        // This means that header information from the original response has been lost.
        //
        // Note that the response body would have been consumed by the deserializer
        // regardless, even if the initial message was hypothetically processed during
        // the orchestrator's deserialization phase but later resulted in an error.
        fn response_error(
            err: impl ::std::convert::Into<::aws_smithy_runtime_api::box_error::BoxError>,
        ) -> ::aws_smithy_runtime_api::client::result::SdkError<
            crate::operation::invoke_endpoint_with_bidirectional_stream::InvokeEndpointWithBidirectionalStreamError,
            ::aws_smithy_runtime_api::client::orchestrator::HttpResponse,
        > {
            ::aws_smithy_runtime_api::client::result::SdkError::response_error(
                err,
                ::aws_smithy_runtime_api::client::orchestrator::HttpResponse::new(
                    ::aws_smithy_runtime_api::http::StatusCode::try_from(200).expect("valid successful code"),
                    ::aws_smithy_types::body::SdkBody::empty(),
                ),
            )
        }

        let message = output.body.try_recv_initial_response().await.map_err(response_error)?;

        match message {
            ::std::option::Option::Some(_message) => ::std::result::Result::Ok(output),
            ::std::option::Option::None => ::std::result::Result::Ok(output),
        }
    }

    /// Consumes this builder, creating a customizable operation that can be modified before being sent.
    pub fn customize(
        self,
    ) -> crate::client::customize::CustomizableOperation<
        crate::operation::invoke_endpoint_with_bidirectional_stream::InvokeEndpointWithBidirectionalStreamOutput,
        crate::operation::invoke_endpoint_with_bidirectional_stream::InvokeEndpointWithBidirectionalStreamError,
        Self,
    > {
        crate::client::customize::CustomizableOperation::new(self)
    }
    pub(crate) fn config_override(mut self, config_override: impl ::std::convert::Into<crate::config::Builder>) -> Self {
        self.set_config_override(::std::option::Option::Some(config_override.into()));
        self
    }

    pub(crate) fn set_config_override(&mut self, config_override: ::std::option::Option<crate::config::Builder>) -> &mut Self {
        self.config_override = config_override;
        self
    }
    /// <p>The name of the endpoint to invoke.</p>
    pub fn endpoint_name(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.inner = self.inner.endpoint_name(input.into());
        self
    }
    /// <p>The name of the endpoint to invoke.</p>
    pub fn set_endpoint_name(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.inner = self.inner.set_endpoint_name(input);
        self
    }
    /// <p>The name of the endpoint to invoke.</p>
    pub fn get_endpoint_name(&self) -> &::std::option::Option<::std::string::String> {
        self.inner.get_endpoint_name()
    }
    /// <p>The request payload stream.</p>
    pub fn body(
        mut self,
        input: ::aws_smithy_http::event_stream::EventStreamSender<crate::types::RequestStreamEvent, crate::types::error::RequestStreamEventError>,
    ) -> Self {
        self.inner = self.inner.body(input);
        self
    }
    /// <p>The request payload stream.</p>
    pub fn set_body(
        mut self,
        input: ::std::option::Option<
            ::aws_smithy_http::event_stream::EventStreamSender<crate::types::RequestStreamEvent, crate::types::error::RequestStreamEventError>,
        >,
    ) -> Self {
        self.inner = self.inner.set_body(input);
        self
    }
    /// <p>The request payload stream.</p>
    pub fn get_body(
        &self,
    ) -> &::std::option::Option<
        ::aws_smithy_http::event_stream::EventStreamSender<crate::types::RequestStreamEvent, crate::types::error::RequestStreamEventError>,
    > {
        self.inner.get_body()
    }
    /// <p>Target variant for the request.</p>
    pub fn target_variant(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.inner = self.inner.target_variant(input.into());
        self
    }
    /// <p>Target variant for the request.</p>
    pub fn set_target_variant(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.inner = self.inner.set_target_variant(input);
        self
    }
    /// <p>Target variant for the request.</p>
    pub fn get_target_variant(&self) -> &::std::option::Option<::std::string::String> {
        self.inner.get_target_variant()
    }
    /// <p>Model invocation path.</p>
    pub fn model_invocation_path(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.inner = self.inner.model_invocation_path(input.into());
        self
    }
    /// <p>Model invocation path.</p>
    pub fn set_model_invocation_path(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.inner = self.inner.set_model_invocation_path(input);
        self
    }
    /// <p>Model invocation path.</p>
    pub fn get_model_invocation_path(&self) -> &::std::option::Option<::std::string::String> {
        self.inner.get_model_invocation_path()
    }
    /// <p>Model query string.</p>
    pub fn model_query_string(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.inner = self.inner.model_query_string(input.into());
        self
    }
    /// <p>Model query string.</p>
    pub fn set_model_query_string(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.inner = self.inner.set_model_query_string(input);
        self
    }
    /// <p>Model query string.</p>
    pub fn get_model_query_string(&self) -> &::std::option::Option<::std::string::String> {
        self.inner.get_model_query_string()
    }
}
