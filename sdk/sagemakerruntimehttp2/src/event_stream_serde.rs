// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[non_exhaustive]
#[derive(Debug)]
pub struct RequestStreamEventErrorMarshaller;

impl RequestStreamEventErrorMarshaller {
    pub fn new() -> Self {
        RequestStreamEventErrorMarshaller
    }
}
impl ::aws_smithy_eventstream::frame::MarshallMessage for RequestStreamEventErrorMarshaller {
    type Input = crate::types::error::RequestStreamEventError;
    fn marshall(
        &self,
        _input: Self::Input,
    ) -> std::result::Result<::aws_smithy_types::event_stream::Message, ::aws_smithy_eventstream::error::Error> {
        let mut headers = Vec::new();
        headers.push(::aws_smithy_types::event_stream::Header::new(
            ":message-type",
            ::aws_smithy_types::event_stream::HeaderValue::String("exception".into()),
        ));
        let payload = Vec::new();
        Ok(::aws_smithy_types::event_stream::Message::new_from_parts(headers, payload))
    }
}

#[non_exhaustive]
#[derive(Debug)]
pub struct RequestStreamEventMarshaller;

impl RequestStreamEventMarshaller {
    pub fn new() -> Self {
        RequestStreamEventMarshaller
    }
}
impl ::aws_smithy_eventstream::frame::MarshallMessage for RequestStreamEventMarshaller {
    type Input = crate::types::RequestStreamEvent;
    fn marshall(&self, input: Self::Input) -> std::result::Result<::aws_smithy_types::event_stream::Message, ::aws_smithy_eventstream::error::Error> {
        let mut headers = Vec::new();
        headers.push(::aws_smithy_types::event_stream::Header::new(
            ":message-type",
            ::aws_smithy_types::event_stream::HeaderValue::String("event".into()),
        ));
        let payload = match input {
            Self::Input::PayloadPart(inner) =>  {
                headers.push(::aws_smithy_types::event_stream::Header::new(":event-type", ::aws_smithy_types::event_stream::HeaderValue::String("PayloadPart".into())));
                if let Some(value) = inner.data_type {
                    headers.push(
                        ::aws_smithy_types::event_stream::Header::new("DataType", ::aws_smithy_types::event_stream::HeaderValue::String(value.into()))
                    );
                }
                if let Some(value) = inner.completion_state {
                    headers.push(
                        ::aws_smithy_types::event_stream::Header::new("CompletionState", ::aws_smithy_types::event_stream::HeaderValue::String(value.into()))
                    );
                }
                if let Some(value) = inner.p {
                    headers.push(
                        ::aws_smithy_types::event_stream::Header::new("P", ::aws_smithy_types::event_stream::HeaderValue::String(value.into()))
                    );
                }
                headers.push(::aws_smithy_types::event_stream::Header::new(":content-type", ::aws_smithy_types::event_stream::HeaderValue::String("application/octet-stream".into())));
                if let Some(inner_payload) = inner.bytes {
                    inner_payload.into_inner()
                }
                 else  {
                    Vec::new()
                }
            }
            Self::Input::Unknown => return Err(
                                            ::aws_smithy_eventstream::error::Error::marshalling("Cannot serialize `RequestStreamEvent::Unknown` for the request. The `Unknown` variant is intended for responses only. It occurs when an outdated client is used after a new enum variant was added on the server side.".to_owned())
                                        )
        }
        ;
        Ok(::aws_smithy_types::event_stream::Message::new_from_parts(headers, payload))
    }
}

#[non_exhaustive]
#[derive(Debug)]
pub struct ResponseStreamEventUnmarshaller;

impl ResponseStreamEventUnmarshaller {
    pub fn new() -> Self {
        ResponseStreamEventUnmarshaller
    }
}
impl ::aws_smithy_eventstream::frame::UnmarshallMessage for ResponseStreamEventUnmarshaller {
    type Output = crate::types::ResponseStreamEvent;
    type Error = crate::types::error::ResponseStreamEventError;
    fn unmarshall(
        &self,
        message: &::aws_smithy_types::event_stream::Message,
    ) -> std::result::Result<::aws_smithy_eventstream::frame::UnmarshalledMessage<Self::Output, Self::Error>, ::aws_smithy_eventstream::error::Error>
    {
        let response_headers = ::aws_smithy_eventstream::smithy::parse_response_headers(message)?;
        match response_headers.message_type.as_str() {
            "event" => {
                match response_headers.smithy_type.as_str() {
                    "PayloadPart" => {
                        let mut builder = crate::types::builders::ResponsePayloadPartBuilder::default();
                        let content_type = response_headers.content_type().unwrap_or_default();
                        if content_type != "application/octet-stream" {
                            return Err(::aws_smithy_eventstream::error::Error::unmarshalling(format!(
                                "expected :content-type to be 'application/octet-stream', but was '{content_type}'"
                            )));
                        }
                        builder = builder.set_bytes(Some(::aws_smithy_types::Blob::new(message.payload().as_ref())));
                        for header in message.headers() {
                            match header.name().as_str() {
                                "DataType" => {
                                    builder = builder.set_data_type(Some(::aws_smithy_eventstream::smithy::expect_string(header)?));
                                }
                                "CompletionState" => {
                                    builder = builder.set_completion_state(Some(::aws_smithy_eventstream::smithy::expect_string(header)?));
                                }
                                "P" => {
                                    builder = builder.set_p(Some(::aws_smithy_eventstream::smithy::expect_string(header)?));
                                }
                                // Event stream protocol headers start with ':'
                                name => {
                                    if !name.starts_with(':') {
                                        ::tracing::trace!("Unrecognized event stream message header: {}", name);
                                    }
                                }
                            }
                        }
                        Ok(::aws_smithy_eventstream::frame::UnmarshalledMessage::Event(
                            crate::types::ResponseStreamEvent::PayloadPart(builder.build()),
                        ))
                    }
                    _unknown_variant => Ok(::aws_smithy_eventstream::frame::UnmarshalledMessage::Event(
                        crate::types::ResponseStreamEvent::Unknown,
                    )),
                }
            }
            "exception" => {
                let generic = match crate::protocol_serde::parse_event_stream_error_metadata(message.payload()) {
                    Ok(builder) => builder.build(),
                    Err(err) => {
                        return Ok(::aws_smithy_eventstream::frame::UnmarshalledMessage::Error(
                            crate::types::error::ResponseStreamEventError::unhandled(err),
                        ))
                    }
                };
                match response_headers.smithy_type.as_str() {
                    "ModelStreamError" => {
                        let mut builder = crate::types::error::builders::ModelStreamErrorBuilder::default();
                        builder = crate::protocol_serde::shape_model_stream_error::de_model_stream_error_json_err(&message.payload()[..], builder)
                            .map_err(|err| {
                                ::aws_smithy_eventstream::error::Error::unmarshalling(format!("failed to unmarshall ModelStreamError: {err}"))
                            })?;
                        builder.set_meta(Some(generic));
                        return Ok(::aws_smithy_eventstream::frame::UnmarshalledMessage::Error(
                            crate::types::error::ResponseStreamEventError::ModelStreamError(builder.build()),
                        ));
                    }
                    "InternalStreamFailure" => {
                        let mut builder = crate::types::error::builders::InternalStreamFailureBuilder::default();
                        builder = crate::protocol_serde::shape_internal_stream_failure::de_internal_stream_failure_json_err(
                            &message.payload()[..],
                            builder,
                        )
                        .map_err(|err| {
                            ::aws_smithy_eventstream::error::Error::unmarshalling(format!("failed to unmarshall InternalStreamFailure: {err}"))
                        })?;
                        builder.set_meta(Some(generic));
                        return Ok(::aws_smithy_eventstream::frame::UnmarshalledMessage::Error(
                            crate::types::error::ResponseStreamEventError::InternalStreamFailure(builder.build()),
                        ));
                    }
                    _ => {}
                }
                Ok(::aws_smithy_eventstream::frame::UnmarshalledMessage::Error(
                    crate::types::error::ResponseStreamEventError::generic(generic),
                ))
            }
            value => {
                return Err(::aws_smithy_eventstream::error::Error::unmarshalling(format!(
                    "unrecognized :message-type: {value}"
                )));
            }
        }
    }
}
