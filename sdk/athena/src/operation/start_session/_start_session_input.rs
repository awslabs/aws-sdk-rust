// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct StartSessionInput {
    /// <p>The session description.</p>
    pub description: ::std::option::Option<::std::string::String>,
    /// <p>The workgroup to which the session belongs.</p>
    pub work_group: ::std::option::Option<::std::string::String>,
    /// <p>Contains engine data processing unit (DPU) configuration settings and parameter mappings.</p>
    pub engine_configuration: ::std::option::Option<crate::types::EngineConfiguration>,
    /// <p>The ARN of the execution role used to access user resources for Spark sessions and Identity Center enabled workgroups. This property applies only to Spark enabled workgroups and Identity Center enabled workgroups.</p>
    pub execution_role: ::std::option::Option<::std::string::String>,
    /// <p>Contains the configuration settings for managed log persistence, delivering logs to Amazon S3 buckets, Amazon CloudWatch log groups etc.</p>
    pub monitoring_configuration: ::std::option::Option<crate::types::MonitoringConfiguration>,
    /// <p>The notebook version. This value is supplied automatically for notebook sessions in the Athena console and is not required for programmatic session access. The only valid notebook version is <code>Athena notebook version 1</code>. If you specify a value for <code>NotebookVersion</code>, you must also specify a value for <code>NotebookId</code>. See <code>EngineConfiguration$AdditionalConfigs</code>.</p>
    pub notebook_version: ::std::option::Option<::std::string::String>,
    /// <p>The idle timeout in minutes for the session.</p>
    pub session_idle_timeout_in_minutes: ::std::option::Option<i32>,
    /// <p>A unique case-sensitive string used to ensure the request to create the session is idempotent (executes only once). If another <code>StartSessionRequest</code> is received, the same response is returned and another session is not created. If a parameter has changed, an error is returned.</p><important>
    /// <p>This token is listed as not required because Amazon Web Services SDKs (for example the Amazon Web Services SDK for Java) auto-generate the token for users. If you are not using the Amazon Web Services SDK or the Amazon Web Services CLI, you must provide this token or the action will fail.</p>
    /// </important>
    pub client_request_token: ::std::option::Option<::std::string::String>,
    /// <p>A list of comma separated tags to add to the session that is created.</p>
    pub tags: ::std::option::Option<::std::vec::Vec<crate::types::Tag>>,
    /// <p>Copies the tags from the Workgroup to the Session when.</p>
    pub copy_work_group_tags: ::std::option::Option<bool>,
}
impl StartSessionInput {
    /// <p>The session description.</p>
    pub fn description(&self) -> ::std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>The workgroup to which the session belongs.</p>
    pub fn work_group(&self) -> ::std::option::Option<&str> {
        self.work_group.as_deref()
    }
    /// <p>Contains engine data processing unit (DPU) configuration settings and parameter mappings.</p>
    pub fn engine_configuration(&self) -> ::std::option::Option<&crate::types::EngineConfiguration> {
        self.engine_configuration.as_ref()
    }
    /// <p>The ARN of the execution role used to access user resources for Spark sessions and Identity Center enabled workgroups. This property applies only to Spark enabled workgroups and Identity Center enabled workgroups.</p>
    pub fn execution_role(&self) -> ::std::option::Option<&str> {
        self.execution_role.as_deref()
    }
    /// <p>Contains the configuration settings for managed log persistence, delivering logs to Amazon S3 buckets, Amazon CloudWatch log groups etc.</p>
    pub fn monitoring_configuration(&self) -> ::std::option::Option<&crate::types::MonitoringConfiguration> {
        self.monitoring_configuration.as_ref()
    }
    /// <p>The notebook version. This value is supplied automatically for notebook sessions in the Athena console and is not required for programmatic session access. The only valid notebook version is <code>Athena notebook version 1</code>. If you specify a value for <code>NotebookVersion</code>, you must also specify a value for <code>NotebookId</code>. See <code>EngineConfiguration$AdditionalConfigs</code>.</p>
    pub fn notebook_version(&self) -> ::std::option::Option<&str> {
        self.notebook_version.as_deref()
    }
    /// <p>The idle timeout in minutes for the session.</p>
    pub fn session_idle_timeout_in_minutes(&self) -> ::std::option::Option<i32> {
        self.session_idle_timeout_in_minutes
    }
    /// <p>A unique case-sensitive string used to ensure the request to create the session is idempotent (executes only once). If another <code>StartSessionRequest</code> is received, the same response is returned and another session is not created. If a parameter has changed, an error is returned.</p><important>
    /// <p>This token is listed as not required because Amazon Web Services SDKs (for example the Amazon Web Services SDK for Java) auto-generate the token for users. If you are not using the Amazon Web Services SDK or the Amazon Web Services CLI, you must provide this token or the action will fail.</p>
    /// </important>
    pub fn client_request_token(&self) -> ::std::option::Option<&str> {
        self.client_request_token.as_deref()
    }
    /// <p>A list of comma separated tags to add to the session that is created.</p>
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.tags.is_none()`.
    pub fn tags(&self) -> &[crate::types::Tag] {
        self.tags.as_deref().unwrap_or_default()
    }
    /// <p>Copies the tags from the Workgroup to the Session when.</p>
    pub fn copy_work_group_tags(&self) -> ::std::option::Option<bool> {
        self.copy_work_group_tags
    }
}
impl StartSessionInput {
    /// Creates a new builder-style object to manufacture [`StartSessionInput`](crate::operation::start_session::StartSessionInput).
    pub fn builder() -> crate::operation::start_session::builders::StartSessionInputBuilder {
        crate::operation::start_session::builders::StartSessionInputBuilder::default()
    }
}

/// A builder for [`StartSessionInput`](crate::operation::start_session::StartSessionInput).
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::default::Default, ::std::fmt::Debug)]
#[non_exhaustive]
pub struct StartSessionInputBuilder {
    pub(crate) description: ::std::option::Option<::std::string::String>,
    pub(crate) work_group: ::std::option::Option<::std::string::String>,
    pub(crate) engine_configuration: ::std::option::Option<crate::types::EngineConfiguration>,
    pub(crate) execution_role: ::std::option::Option<::std::string::String>,
    pub(crate) monitoring_configuration: ::std::option::Option<crate::types::MonitoringConfiguration>,
    pub(crate) notebook_version: ::std::option::Option<::std::string::String>,
    pub(crate) session_idle_timeout_in_minutes: ::std::option::Option<i32>,
    pub(crate) client_request_token: ::std::option::Option<::std::string::String>,
    pub(crate) tags: ::std::option::Option<::std::vec::Vec<crate::types::Tag>>,
    pub(crate) copy_work_group_tags: ::std::option::Option<bool>,
}
impl StartSessionInputBuilder {
    /// <p>The session description.</p>
    pub fn description(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.description = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The session description.</p>
    pub fn set_description(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.description = input;
        self
    }
    /// <p>The session description.</p>
    pub fn get_description(&self) -> &::std::option::Option<::std::string::String> {
        &self.description
    }
    /// <p>The workgroup to which the session belongs.</p>
    /// This field is required.
    pub fn work_group(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.work_group = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The workgroup to which the session belongs.</p>
    pub fn set_work_group(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.work_group = input;
        self
    }
    /// <p>The workgroup to which the session belongs.</p>
    pub fn get_work_group(&self) -> &::std::option::Option<::std::string::String> {
        &self.work_group
    }
    /// <p>Contains engine data processing unit (DPU) configuration settings and parameter mappings.</p>
    /// This field is required.
    pub fn engine_configuration(mut self, input: crate::types::EngineConfiguration) -> Self {
        self.engine_configuration = ::std::option::Option::Some(input);
        self
    }
    /// <p>Contains engine data processing unit (DPU) configuration settings and parameter mappings.</p>
    pub fn set_engine_configuration(mut self, input: ::std::option::Option<crate::types::EngineConfiguration>) -> Self {
        self.engine_configuration = input;
        self
    }
    /// <p>Contains engine data processing unit (DPU) configuration settings and parameter mappings.</p>
    pub fn get_engine_configuration(&self) -> &::std::option::Option<crate::types::EngineConfiguration> {
        &self.engine_configuration
    }
    /// <p>The ARN of the execution role used to access user resources for Spark sessions and Identity Center enabled workgroups. This property applies only to Spark enabled workgroups and Identity Center enabled workgroups.</p>
    pub fn execution_role(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.execution_role = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The ARN of the execution role used to access user resources for Spark sessions and Identity Center enabled workgroups. This property applies only to Spark enabled workgroups and Identity Center enabled workgroups.</p>
    pub fn set_execution_role(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.execution_role = input;
        self
    }
    /// <p>The ARN of the execution role used to access user resources for Spark sessions and Identity Center enabled workgroups. This property applies only to Spark enabled workgroups and Identity Center enabled workgroups.</p>
    pub fn get_execution_role(&self) -> &::std::option::Option<::std::string::String> {
        &self.execution_role
    }
    /// <p>Contains the configuration settings for managed log persistence, delivering logs to Amazon S3 buckets, Amazon CloudWatch log groups etc.</p>
    pub fn monitoring_configuration(mut self, input: crate::types::MonitoringConfiguration) -> Self {
        self.monitoring_configuration = ::std::option::Option::Some(input);
        self
    }
    /// <p>Contains the configuration settings for managed log persistence, delivering logs to Amazon S3 buckets, Amazon CloudWatch log groups etc.</p>
    pub fn set_monitoring_configuration(mut self, input: ::std::option::Option<crate::types::MonitoringConfiguration>) -> Self {
        self.monitoring_configuration = input;
        self
    }
    /// <p>Contains the configuration settings for managed log persistence, delivering logs to Amazon S3 buckets, Amazon CloudWatch log groups etc.</p>
    pub fn get_monitoring_configuration(&self) -> &::std::option::Option<crate::types::MonitoringConfiguration> {
        &self.monitoring_configuration
    }
    /// <p>The notebook version. This value is supplied automatically for notebook sessions in the Athena console and is not required for programmatic session access. The only valid notebook version is <code>Athena notebook version 1</code>. If you specify a value for <code>NotebookVersion</code>, you must also specify a value for <code>NotebookId</code>. See <code>EngineConfiguration$AdditionalConfigs</code>.</p>
    pub fn notebook_version(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.notebook_version = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The notebook version. This value is supplied automatically for notebook sessions in the Athena console and is not required for programmatic session access. The only valid notebook version is <code>Athena notebook version 1</code>. If you specify a value for <code>NotebookVersion</code>, you must also specify a value for <code>NotebookId</code>. See <code>EngineConfiguration$AdditionalConfigs</code>.</p>
    pub fn set_notebook_version(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.notebook_version = input;
        self
    }
    /// <p>The notebook version. This value is supplied automatically for notebook sessions in the Athena console and is not required for programmatic session access. The only valid notebook version is <code>Athena notebook version 1</code>. If you specify a value for <code>NotebookVersion</code>, you must also specify a value for <code>NotebookId</code>. See <code>EngineConfiguration$AdditionalConfigs</code>.</p>
    pub fn get_notebook_version(&self) -> &::std::option::Option<::std::string::String> {
        &self.notebook_version
    }
    /// <p>The idle timeout in minutes for the session.</p>
    pub fn session_idle_timeout_in_minutes(mut self, input: i32) -> Self {
        self.session_idle_timeout_in_minutes = ::std::option::Option::Some(input);
        self
    }
    /// <p>The idle timeout in minutes for the session.</p>
    pub fn set_session_idle_timeout_in_minutes(mut self, input: ::std::option::Option<i32>) -> Self {
        self.session_idle_timeout_in_minutes = input;
        self
    }
    /// <p>The idle timeout in minutes for the session.</p>
    pub fn get_session_idle_timeout_in_minutes(&self) -> &::std::option::Option<i32> {
        &self.session_idle_timeout_in_minutes
    }
    /// <p>A unique case-sensitive string used to ensure the request to create the session is idempotent (executes only once). If another <code>StartSessionRequest</code> is received, the same response is returned and another session is not created. If a parameter has changed, an error is returned.</p><important>
    /// <p>This token is listed as not required because Amazon Web Services SDKs (for example the Amazon Web Services SDK for Java) auto-generate the token for users. If you are not using the Amazon Web Services SDK or the Amazon Web Services CLI, you must provide this token or the action will fail.</p>
    /// </important>
    pub fn client_request_token(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.client_request_token = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>A unique case-sensitive string used to ensure the request to create the session is idempotent (executes only once). If another <code>StartSessionRequest</code> is received, the same response is returned and another session is not created. If a parameter has changed, an error is returned.</p><important>
    /// <p>This token is listed as not required because Amazon Web Services SDKs (for example the Amazon Web Services SDK for Java) auto-generate the token for users. If you are not using the Amazon Web Services SDK or the Amazon Web Services CLI, you must provide this token or the action will fail.</p>
    /// </important>
    pub fn set_client_request_token(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.client_request_token = input;
        self
    }
    /// <p>A unique case-sensitive string used to ensure the request to create the session is idempotent (executes only once). If another <code>StartSessionRequest</code> is received, the same response is returned and another session is not created. If a parameter has changed, an error is returned.</p><important>
    /// <p>This token is listed as not required because Amazon Web Services SDKs (for example the Amazon Web Services SDK for Java) auto-generate the token for users. If you are not using the Amazon Web Services SDK or the Amazon Web Services CLI, you must provide this token or the action will fail.</p>
    /// </important>
    pub fn get_client_request_token(&self) -> &::std::option::Option<::std::string::String> {
        &self.client_request_token
    }
    /// Appends an item to `tags`.
    ///
    /// To override the contents of this collection use [`set_tags`](Self::set_tags).
    ///
    /// <p>A list of comma separated tags to add to the session that is created.</p>
    pub fn tags(mut self, input: crate::types::Tag) -> Self {
        let mut v = self.tags.unwrap_or_default();
        v.push(input);
        self.tags = ::std::option::Option::Some(v);
        self
    }
    /// <p>A list of comma separated tags to add to the session that is created.</p>
    pub fn set_tags(mut self, input: ::std::option::Option<::std::vec::Vec<crate::types::Tag>>) -> Self {
        self.tags = input;
        self
    }
    /// <p>A list of comma separated tags to add to the session that is created.</p>
    pub fn get_tags(&self) -> &::std::option::Option<::std::vec::Vec<crate::types::Tag>> {
        &self.tags
    }
    /// <p>Copies the tags from the Workgroup to the Session when.</p>
    pub fn copy_work_group_tags(mut self, input: bool) -> Self {
        self.copy_work_group_tags = ::std::option::Option::Some(input);
        self
    }
    /// <p>Copies the tags from the Workgroup to the Session when.</p>
    pub fn set_copy_work_group_tags(mut self, input: ::std::option::Option<bool>) -> Self {
        self.copy_work_group_tags = input;
        self
    }
    /// <p>Copies the tags from the Workgroup to the Session when.</p>
    pub fn get_copy_work_group_tags(&self) -> &::std::option::Option<bool> {
        &self.copy_work_group_tags
    }
    /// Consumes the builder and constructs a [`StartSessionInput`](crate::operation::start_session::StartSessionInput).
    pub fn build(
        self,
    ) -> ::std::result::Result<crate::operation::start_session::StartSessionInput, ::aws_smithy_types::error::operation::BuildError> {
        ::std::result::Result::Ok(crate::operation::start_session::StartSessionInput {
            description: self.description,
            work_group: self.work_group,
            engine_configuration: self.engine_configuration,
            execution_role: self.execution_role,
            monitoring_configuration: self.monitoring_configuration,
            notebook_version: self.notebook_version,
            session_idle_timeout_in_minutes: self.session_idle_timeout_in_minutes,
            client_request_token: self.client_request_token,
            tags: self.tags,
            copy_work_group_tags: self.copy_work_group_tags,
        })
    }
}
