// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[derive(std::fmt::Debug)]
pub(crate) struct Handle<C = aws_hyper::DynConnector> {
    client: aws_hyper::Client<C>,
    conf: crate::Config,
}

#[derive(Clone, std::fmt::Debug)]
pub struct Client<C = aws_hyper::DynConnector> {
    handle: std::sync::Arc<Handle<C>>,
}
impl<C> Client<C> {
    pub fn from_conf_conn(conf: crate::Config, conn: C) -> Self {
        let client = aws_hyper::Client::new(conn);
        Self {
            handle: std::sync::Arc::new(Handle { client, conf }),
        }
    }

    pub fn conf(&self) -> &crate::Config {
        &self.handle.conf
    }
}
impl Client {
    #[cfg(any(feature = "rustls", feature = "native-tls"))]
    pub fn from_env() -> Self {
        Self::from_conf(crate::Config::builder().build())
    }

    #[cfg(any(feature = "rustls", feature = "native-tls"))]
    pub fn from_conf(conf: crate::Config) -> Self {
        let client = aws_hyper::Client::https();
        Self {
            handle: std::sync::Arc::new(Handle { client, conf }),
        }
    }
}
impl<C> Client<C>
where
    C: aws_hyper::SmithyConnector,
{
    pub fn batch_get_named_query(&self) -> fluent_builders::BatchGetNamedQuery<C> {
        fluent_builders::BatchGetNamedQuery::new(self.handle.clone())
    }
    pub fn batch_get_query_execution(&self) -> fluent_builders::BatchGetQueryExecution<C> {
        fluent_builders::BatchGetQueryExecution::new(self.handle.clone())
    }
    pub fn create_data_catalog(&self) -> fluent_builders::CreateDataCatalog<C> {
        fluent_builders::CreateDataCatalog::new(self.handle.clone())
    }
    pub fn create_named_query(&self) -> fluent_builders::CreateNamedQuery<C> {
        fluent_builders::CreateNamedQuery::new(self.handle.clone())
    }
    pub fn create_prepared_statement(&self) -> fluent_builders::CreatePreparedStatement<C> {
        fluent_builders::CreatePreparedStatement::new(self.handle.clone())
    }
    pub fn create_work_group(&self) -> fluent_builders::CreateWorkGroup<C> {
        fluent_builders::CreateWorkGroup::new(self.handle.clone())
    }
    pub fn delete_data_catalog(&self) -> fluent_builders::DeleteDataCatalog<C> {
        fluent_builders::DeleteDataCatalog::new(self.handle.clone())
    }
    pub fn delete_named_query(&self) -> fluent_builders::DeleteNamedQuery<C> {
        fluent_builders::DeleteNamedQuery::new(self.handle.clone())
    }
    pub fn delete_prepared_statement(&self) -> fluent_builders::DeletePreparedStatement<C> {
        fluent_builders::DeletePreparedStatement::new(self.handle.clone())
    }
    pub fn delete_work_group(&self) -> fluent_builders::DeleteWorkGroup<C> {
        fluent_builders::DeleteWorkGroup::new(self.handle.clone())
    }
    pub fn get_database(&self) -> fluent_builders::GetDatabase<C> {
        fluent_builders::GetDatabase::new(self.handle.clone())
    }
    pub fn get_data_catalog(&self) -> fluent_builders::GetDataCatalog<C> {
        fluent_builders::GetDataCatalog::new(self.handle.clone())
    }
    pub fn get_named_query(&self) -> fluent_builders::GetNamedQuery<C> {
        fluent_builders::GetNamedQuery::new(self.handle.clone())
    }
    pub fn get_prepared_statement(&self) -> fluent_builders::GetPreparedStatement<C> {
        fluent_builders::GetPreparedStatement::new(self.handle.clone())
    }
    pub fn get_query_execution(&self) -> fluent_builders::GetQueryExecution<C> {
        fluent_builders::GetQueryExecution::new(self.handle.clone())
    }
    pub fn get_query_results(&self) -> fluent_builders::GetQueryResults<C> {
        fluent_builders::GetQueryResults::new(self.handle.clone())
    }
    pub fn get_table_metadata(&self) -> fluent_builders::GetTableMetadata<C> {
        fluent_builders::GetTableMetadata::new(self.handle.clone())
    }
    pub fn get_work_group(&self) -> fluent_builders::GetWorkGroup<C> {
        fluent_builders::GetWorkGroup::new(self.handle.clone())
    }
    pub fn list_databases(&self) -> fluent_builders::ListDatabases<C> {
        fluent_builders::ListDatabases::new(self.handle.clone())
    }
    pub fn list_data_catalogs(&self) -> fluent_builders::ListDataCatalogs<C> {
        fluent_builders::ListDataCatalogs::new(self.handle.clone())
    }
    pub fn list_engine_versions(&self) -> fluent_builders::ListEngineVersions<C> {
        fluent_builders::ListEngineVersions::new(self.handle.clone())
    }
    pub fn list_named_queries(&self) -> fluent_builders::ListNamedQueries<C> {
        fluent_builders::ListNamedQueries::new(self.handle.clone())
    }
    pub fn list_prepared_statements(&self) -> fluent_builders::ListPreparedStatements<C> {
        fluent_builders::ListPreparedStatements::new(self.handle.clone())
    }
    pub fn list_query_executions(&self) -> fluent_builders::ListQueryExecutions<C> {
        fluent_builders::ListQueryExecutions::new(self.handle.clone())
    }
    pub fn list_table_metadata(&self) -> fluent_builders::ListTableMetadata<C> {
        fluent_builders::ListTableMetadata::new(self.handle.clone())
    }
    pub fn list_tags_for_resource(&self) -> fluent_builders::ListTagsForResource<C> {
        fluent_builders::ListTagsForResource::new(self.handle.clone())
    }
    pub fn list_work_groups(&self) -> fluent_builders::ListWorkGroups<C> {
        fluent_builders::ListWorkGroups::new(self.handle.clone())
    }
    pub fn start_query_execution(&self) -> fluent_builders::StartQueryExecution<C> {
        fluent_builders::StartQueryExecution::new(self.handle.clone())
    }
    pub fn stop_query_execution(&self) -> fluent_builders::StopQueryExecution<C> {
        fluent_builders::StopQueryExecution::new(self.handle.clone())
    }
    pub fn tag_resource(&self) -> fluent_builders::TagResource<C> {
        fluent_builders::TagResource::new(self.handle.clone())
    }
    pub fn untag_resource(&self) -> fluent_builders::UntagResource<C> {
        fluent_builders::UntagResource::new(self.handle.clone())
    }
    pub fn update_data_catalog(&self) -> fluent_builders::UpdateDataCatalog<C> {
        fluent_builders::UpdateDataCatalog::new(self.handle.clone())
    }
    pub fn update_prepared_statement(&self) -> fluent_builders::UpdatePreparedStatement<C> {
        fluent_builders::UpdatePreparedStatement::new(self.handle.clone())
    }
    pub fn update_work_group(&self) -> fluent_builders::UpdateWorkGroup<C> {
        fluent_builders::UpdateWorkGroup::new(self.handle.clone())
    }
}
pub mod fluent_builders {
    #[derive(std::fmt::Debug)]
    pub struct BatchGetNamedQuery<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::batch_get_named_query_input::Builder,
    }
    impl<C> BatchGetNamedQuery<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::BatchGetNamedQueryOutput,
            smithy_http::result::SdkError<crate::error::BatchGetNamedQueryError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>An array of query IDs.</p>
        pub fn named_query_ids(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.named_query_ids(inp);
            self
        }
        pub fn set_named_query_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_named_query_ids(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct BatchGetQueryExecution<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::batch_get_query_execution_input::Builder,
    }
    impl<C> BatchGetQueryExecution<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::BatchGetQueryExecutionOutput,
            smithy_http::result::SdkError<crate::error::BatchGetQueryExecutionError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>An array of query execution IDs.</p>
        pub fn query_execution_ids(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.query_execution_ids(inp);
            self
        }
        pub fn set_query_execution_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_query_execution_ids(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateDataCatalog<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_data_catalog_input::Builder,
    }
    impl<C> CreateDataCatalog<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateDataCatalogOutput,
            smithy_http::result::SdkError<crate::error::CreateDataCatalogError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the data catalog to create. The catalog name must be unique for the
        /// Amazon Web Services account and can use a maximum of 128 alphanumeric, underscore, at
        /// sign, or hyphen characters.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(input);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
        /// <p>The type of data catalog to create: <code>LAMBDA</code> for a federated catalog,
        /// <code>HIVE</code> for an external hive metastore, or <code>GLUE</code> for an
        /// Glue Data Catalog.</p>
        pub fn r#type(mut self, input: crate::model::DataCatalogType) -> Self {
            self.inner = self.inner.r#type(input);
            self
        }
        pub fn set_type(
            mut self,
            input: std::option::Option<crate::model::DataCatalogType>,
        ) -> Self {
            self.inner = self.inner.set_type(input);
            self
        }
        /// <p>A description of the data catalog to be created.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.description(input);
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_description(input);
            self
        }
        /// <p>Specifies the Lambda function or functions to use for creating the data
        /// catalog. This is a mapping whose values depend on the catalog type. </p>
        /// <ul>
        /// <li>
        /// <p>For the <code>HIVE</code> data catalog type, use the following syntax. The
        /// <code>metadata-function</code> parameter is required. <code>The
        /// sdk-version</code> parameter is optional and defaults to the currently
        /// supported version.</p>
        /// <p>
        /// <code>metadata-function=<i>lambda_arn</i>,
        /// sdk-version=<i>version_number</i>
        /// </code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>For the <code>LAMBDA</code> data catalog type, use one of the following sets
        /// of required parameters, but not both.</p>
        /// <ul>
        /// <li>
        /// <p>If you have one Lambda function that processes metadata
        /// and another for reading the actual data, use the following syntax. Both
        /// parameters are required.</p>
        /// <p>
        /// <code>metadata-function=<i>lambda_arn</i>,
        /// record-function=<i>lambda_arn</i>
        /// </code>
        /// </p>
        /// </li>
        /// <li>
        /// <p> If you have a composite Lambda function that processes
        /// both metadata and data, use the following syntax to specify your Lambda function.</p>
        /// <p>
        /// <code>function=<i>lambda_arn</i>
        /// </code>
        /// </p>
        /// </li>
        /// </ul>
        /// </li>
        /// <li>
        /// <p>The <code>GLUE</code> type takes a catalog ID parameter and is required. The
        /// <code>
        /// <i>catalog_id</i>
        /// </code> is the account ID of the
        /// Amazon Web Services account to which the Glue Data Catalog
        /// belongs.</p>
        /// <p>
        /// <code>catalog-id=<i>catalog_id</i>
        /// </code>
        /// </p>
        /// <ul>
        /// <li>
        /// <p>The <code>GLUE</code> data catalog type also applies to the default
        /// <code>AwsDataCatalog</code> that already exists in your account, of
        /// which you can have only one and cannot modify.</p>
        /// </li>
        /// <li>
        /// <p>Queries that specify a Glue Data Catalog other than the default
        /// <code>AwsDataCatalog</code> must be run on Athena engine
        /// version 2.</p>
        /// </li>
        /// <li>
        /// <p>In Regions where Athena engine version 2 is not available,
        /// creating new Glue data catalogs results in an
        /// <code>INVALID_INPUT</code> error.</p>
        /// </li>
        /// </ul>
        /// </li>
        /// </ul>
        pub fn parameters(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.parameters(k, v);
            self
        }
        pub fn set_parameters(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.inner = self.inner.set_parameters(input);
            self
        }
        /// <p>A list of comma separated tags to add to the data catalog that is created.</p>
        pub fn tags(mut self, inp: impl Into<crate::model::Tag>) -> Self {
            self.inner = self.inner.tags(inp);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateNamedQuery<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_named_query_input::Builder,
    }
    impl<C> CreateNamedQuery<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateNamedQueryOutput,
            smithy_http::result::SdkError<crate::error::CreateNamedQueryError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The query name.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(input);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
        /// <p>The query description.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.description(input);
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_description(input);
            self
        }
        /// <p>The database to which the query belongs.</p>
        pub fn database(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.database(input);
            self
        }
        pub fn set_database(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_database(input);
            self
        }
        /// <p>The contents of the query with all query statements.</p>
        pub fn query_string(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.query_string(input);
            self
        }
        pub fn set_query_string(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_query_string(input);
            self
        }
        /// <p>A unique case-sensitive string used to ensure the request to create the query is
        /// idempotent (executes only once). If another <code>CreateNamedQuery</code> request is
        /// received, the same response is returned and another query is not created. If a parameter
        /// has changed, for example, the <code>QueryString</code>, an error is returned.</p>
        /// <important>
        /// <p>This token is listed as not required because Amazon Web Services SDKs (for example
        /// the Amazon Web Services SDK for Java) auto-generate the token for users. If you are
        /// not using the Amazon Web Services SDK or the Amazon Web Services CLI, you must provide
        /// this token or the action will fail.</p>
        /// </important>
        pub fn client_request_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.client_request_token(input);
            self
        }
        pub fn set_client_request_token(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_client_request_token(input);
            self
        }
        /// <p>The name of the workgroup in which the named query is being created.</p>
        pub fn work_group(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.work_group(input);
            self
        }
        pub fn set_work_group(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_work_group(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreatePreparedStatement<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_prepared_statement_input::Builder,
    }
    impl<C> CreatePreparedStatement<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreatePreparedStatementOutput,
            smithy_http::result::SdkError<crate::error::CreatePreparedStatementError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the prepared statement.</p>
        pub fn statement_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.statement_name(input);
            self
        }
        pub fn set_statement_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_statement_name(input);
            self
        }
        /// <p>The name of the workgroup to which the prepared statement belongs.</p>
        pub fn work_group(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.work_group(input);
            self
        }
        pub fn set_work_group(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_work_group(input);
            self
        }
        /// <p>The query string for the prepared statement.</p>
        pub fn query_statement(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.query_statement(input);
            self
        }
        pub fn set_query_statement(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_query_statement(input);
            self
        }
        /// <p>The description of the prepared statement.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.description(input);
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_description(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateWorkGroup<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_work_group_input::Builder,
    }
    impl<C> CreateWorkGroup<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateWorkGroupOutput,
            smithy_http::result::SdkError<crate::error::CreateWorkGroupError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The workgroup name.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(input);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
        /// <p>The configuration for the workgroup, which includes the location in Amazon S3
        /// where query results are stored, the encryption configuration, if any, used for
        /// encrypting query results, whether the Amazon CloudWatch Metrics are enabled for the
        /// workgroup, the limit for the amount of bytes scanned (cutoff) per query, if it is
        /// specified, and whether workgroup's settings (specified with
        /// <code>EnforceWorkGroupConfiguration</code>) in the
        /// <code>WorkGroupConfiguration</code> override client-side settings. See <a>WorkGroupConfiguration$EnforceWorkGroupConfiguration</a>.</p>
        pub fn configuration(mut self, input: crate::model::WorkGroupConfiguration) -> Self {
            self.inner = self.inner.configuration(input);
            self
        }
        pub fn set_configuration(
            mut self,
            input: std::option::Option<crate::model::WorkGroupConfiguration>,
        ) -> Self {
            self.inner = self.inner.set_configuration(input);
            self
        }
        /// <p>The workgroup description.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.description(input);
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_description(input);
            self
        }
        /// <p>A list of comma separated tags to add to the workgroup that is created.</p>
        pub fn tags(mut self, inp: impl Into<crate::model::Tag>) -> Self {
            self.inner = self.inner.tags(inp);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteDataCatalog<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_data_catalog_input::Builder,
    }
    impl<C> DeleteDataCatalog<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteDataCatalogOutput,
            smithy_http::result::SdkError<crate::error::DeleteDataCatalogError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the data catalog to delete.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(input);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteNamedQuery<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_named_query_input::Builder,
    }
    impl<C> DeleteNamedQuery<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteNamedQueryOutput,
            smithy_http::result::SdkError<crate::error::DeleteNamedQueryError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The unique ID of the query to delete.</p>
        pub fn named_query_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.named_query_id(input);
            self
        }
        pub fn set_named_query_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_named_query_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeletePreparedStatement<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_prepared_statement_input::Builder,
    }
    impl<C> DeletePreparedStatement<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeletePreparedStatementOutput,
            smithy_http::result::SdkError<crate::error::DeletePreparedStatementError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the prepared statement to delete.</p>
        pub fn statement_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.statement_name(input);
            self
        }
        pub fn set_statement_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_statement_name(input);
            self
        }
        /// <p>The workgroup to which the statement to be deleted belongs.</p>
        pub fn work_group(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.work_group(input);
            self
        }
        pub fn set_work_group(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_work_group(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteWorkGroup<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_work_group_input::Builder,
    }
    impl<C> DeleteWorkGroup<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteWorkGroupOutput,
            smithy_http::result::SdkError<crate::error::DeleteWorkGroupError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The unique name of the workgroup to delete.</p>
        pub fn work_group(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.work_group(input);
            self
        }
        pub fn set_work_group(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_work_group(input);
            self
        }
        /// <p>The option to delete the workgroup and its contents even if the workgroup contains any
        /// named queries or query executions.</p>
        pub fn recursive_delete_option(mut self, input: bool) -> Self {
            self.inner = self.inner.recursive_delete_option(input);
            self
        }
        pub fn set_recursive_delete_option(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_recursive_delete_option(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetDatabase<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_database_input::Builder,
    }
    impl<C> GetDatabase<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetDatabaseOutput,
            smithy_http::result::SdkError<crate::error::GetDatabaseError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the data catalog that contains the database to return.</p>
        pub fn catalog_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.catalog_name(input);
            self
        }
        pub fn set_catalog_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_catalog_name(input);
            self
        }
        /// <p>The name of the database to return.</p>
        pub fn database_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.database_name(input);
            self
        }
        pub fn set_database_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_database_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetDataCatalog<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_data_catalog_input::Builder,
    }
    impl<C> GetDataCatalog<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetDataCatalogOutput,
            smithy_http::result::SdkError<crate::error::GetDataCatalogError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the data catalog to return.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(input);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetNamedQuery<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_named_query_input::Builder,
    }
    impl<C> GetNamedQuery<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetNamedQueryOutput,
            smithy_http::result::SdkError<crate::error::GetNamedQueryError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The unique ID of the query. Use <a>ListNamedQueries</a> to get query
        /// IDs.</p>
        pub fn named_query_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.named_query_id(input);
            self
        }
        pub fn set_named_query_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_named_query_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetPreparedStatement<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_prepared_statement_input::Builder,
    }
    impl<C> GetPreparedStatement<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetPreparedStatementOutput,
            smithy_http::result::SdkError<crate::error::GetPreparedStatementError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the prepared statement to retrieve.</p>
        pub fn statement_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.statement_name(input);
            self
        }
        pub fn set_statement_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_statement_name(input);
            self
        }
        /// <p>The workgroup to which the statement to be retrieved belongs.</p>
        pub fn work_group(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.work_group(input);
            self
        }
        pub fn set_work_group(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_work_group(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetQueryExecution<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_query_execution_input::Builder,
    }
    impl<C> GetQueryExecution<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetQueryExecutionOutput,
            smithy_http::result::SdkError<crate::error::GetQueryExecutionError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The unique ID of the query execution.</p>
        pub fn query_execution_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.query_execution_id(input);
            self
        }
        pub fn set_query_execution_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_query_execution_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetQueryResults<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_query_results_input::Builder,
    }
    impl<C> GetQueryResults<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetQueryResultsOutput,
            smithy_http::result::SdkError<crate::error::GetQueryResultsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The unique ID of the query execution.</p>
        pub fn query_execution_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.query_execution_id(input);
            self
        }
        pub fn set_query_execution_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_query_execution_id(input);
            self
        }
        /// <p>A token generated by the Athena service that specifies where to continue
        /// pagination if a previous request was truncated. To obtain the next set of pages, pass in
        /// the <code>NextToken</code> from the response object of the previous page call.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>The maximum number of results (rows) to return in this request.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetTableMetadata<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_table_metadata_input::Builder,
    }
    impl<C> GetTableMetadata<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetTableMetadataOutput,
            smithy_http::result::SdkError<crate::error::GetTableMetadataError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the data catalog that contains the database and table metadata to
        /// return.</p>
        pub fn catalog_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.catalog_name(input);
            self
        }
        pub fn set_catalog_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_catalog_name(input);
            self
        }
        /// <p>The name of the database that contains the table metadata to return.</p>
        pub fn database_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.database_name(input);
            self
        }
        pub fn set_database_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_database_name(input);
            self
        }
        /// <p>The name of the table for which metadata is returned.</p>
        pub fn table_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.table_name(input);
            self
        }
        pub fn set_table_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_table_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetWorkGroup<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_work_group_input::Builder,
    }
    impl<C> GetWorkGroup<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetWorkGroupOutput,
            smithy_http::result::SdkError<crate::error::GetWorkGroupError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the workgroup.</p>
        pub fn work_group(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.work_group(input);
            self
        }
        pub fn set_work_group(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_work_group(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListDatabases<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_databases_input::Builder,
    }
    impl<C> ListDatabases<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListDatabasesOutput,
            smithy_http::result::SdkError<crate::error::ListDatabasesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the data catalog that contains the databases to return.</p>
        pub fn catalog_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.catalog_name(input);
            self
        }
        pub fn set_catalog_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_catalog_name(input);
            self
        }
        /// <p>A token generated by the Athena service that specifies where to continue
        /// pagination if a previous request was truncated. To obtain the next set of pages, pass in
        /// the <code>NextToken</code> from the response object of the previous page call.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>Specifies the maximum number of results to return.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListDataCatalogs<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_data_catalogs_input::Builder,
    }
    impl<C> ListDataCatalogs<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListDataCatalogsOutput,
            smithy_http::result::SdkError<crate::error::ListDataCatalogsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>A token generated by the Athena service that specifies where to continue
        /// pagination if a previous request was truncated. To obtain the next set of pages, pass in
        /// the NextToken from the response object of the previous page call.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>Specifies the maximum number of data catalogs to return.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListEngineVersions<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_engine_versions_input::Builder,
    }
    impl<C> ListEngineVersions<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListEngineVersionsOutput,
            smithy_http::result::SdkError<crate::error::ListEngineVersionsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>A token generated by the Athena service that specifies where to continue
        /// pagination if a previous request was truncated. To obtain the next set of pages, pass in
        /// the <code>NextToken</code> from the response object of the previous page call.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>The maximum number of engine versions to return in this request.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListNamedQueries<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_named_queries_input::Builder,
    }
    impl<C> ListNamedQueries<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListNamedQueriesOutput,
            smithy_http::result::SdkError<crate::error::ListNamedQueriesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>A token generated by the Athena service that specifies where to continue
        /// pagination if a previous request was truncated. To obtain the next set of pages, pass in
        /// the <code>NextToken</code> from the response object of the previous page call.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>The maximum number of queries to return in this request.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>The name of the workgroup from which the named queries are being returned. If a
        /// workgroup is not specified, the saved queries for the primary workgroup are
        /// returned.</p>
        pub fn work_group(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.work_group(input);
            self
        }
        pub fn set_work_group(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_work_group(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListPreparedStatements<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_prepared_statements_input::Builder,
    }
    impl<C> ListPreparedStatements<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListPreparedStatementsOutput,
            smithy_http::result::SdkError<crate::error::ListPreparedStatementsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The workgroup to list the prepared statements for.</p>
        pub fn work_group(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.work_group(input);
            self
        }
        pub fn set_work_group(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_work_group(input);
            self
        }
        /// <p>A token generated by the Athena service that specifies where to continue
        /// pagination if a previous request was truncated. To obtain the next set of pages, pass in
        /// the <code>NextToken</code> from the response object of the previous page call.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>The maximum number of results to return in this request.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListQueryExecutions<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_query_executions_input::Builder,
    }
    impl<C> ListQueryExecutions<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListQueryExecutionsOutput,
            smithy_http::result::SdkError<crate::error::ListQueryExecutionsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>A token generated by the Athena service that specifies where to continue
        /// pagination if a previous request was truncated. To obtain the next set of pages, pass in
        /// the <code>NextToken</code> from the response object of the previous page call.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>The maximum number of query executions to return in this request.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>The name of the workgroup from which queries are being returned. If a workgroup is not
        /// specified, a list of available query execution IDs for the queries in the primary
        /// workgroup is returned.</p>
        pub fn work_group(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.work_group(input);
            self
        }
        pub fn set_work_group(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_work_group(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListTableMetadata<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_table_metadata_input::Builder,
    }
    impl<C> ListTableMetadata<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListTableMetadataOutput,
            smithy_http::result::SdkError<crate::error::ListTableMetadataError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the data catalog for which table metadata should be returned.</p>
        pub fn catalog_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.catalog_name(input);
            self
        }
        pub fn set_catalog_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_catalog_name(input);
            self
        }
        /// <p>The name of the database for which table metadata should be returned.</p>
        pub fn database_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.database_name(input);
            self
        }
        pub fn set_database_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_database_name(input);
            self
        }
        /// <p>A regex filter that pattern-matches table names. If no expression is supplied,
        /// metadata for all tables are listed.</p>
        pub fn expression(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.expression(input);
            self
        }
        pub fn set_expression(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_expression(input);
            self
        }
        /// <p>A token generated by the Athena service that specifies where to continue
        /// pagination if a previous request was truncated. To obtain the next set of pages, pass in
        /// the NextToken from the response object of the previous page call.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>Specifies the maximum number of results to return.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListTagsForResource<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_tags_for_resource_input::Builder,
    }
    impl<C> ListTagsForResource<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListTagsForResourceOutput,
            smithy_http::result::SdkError<crate::error::ListTagsForResourceError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Lists the tags for the resource with the specified ARN.</p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resource_arn(input);
            self
        }
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_resource_arn(input);
            self
        }
        /// <p>The token for the next set of results, or null if there are no additional results for
        /// this request, where the request lists the tags for the resource with the specified
        /// ARN.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>The maximum number of results to be returned per request that lists the tags for the
        /// resource.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListWorkGroups<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_work_groups_input::Builder,
    }
    impl<C> ListWorkGroups<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListWorkGroupsOutput,
            smithy_http::result::SdkError<crate::error::ListWorkGroupsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>A token generated by the Athena service that specifies where to continue
        /// pagination if a previous request was truncated. To obtain the next set of pages, pass in
        /// the <code>NextToken</code> from the response object of the previous page call.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>The maximum number of workgroups to return in this request.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct StartQueryExecution<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::start_query_execution_input::Builder,
    }
    impl<C> StartQueryExecution<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::StartQueryExecutionOutput,
            smithy_http::result::SdkError<crate::error::StartQueryExecutionError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The SQL query statements to be executed.</p>
        pub fn query_string(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.query_string(input);
            self
        }
        pub fn set_query_string(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_query_string(input);
            self
        }
        /// <p>A unique case-sensitive string used to ensure the request to create the query is
        /// idempotent (executes only once). If another <code>StartQueryExecution</code> request is
        /// received, the same response is returned and another query is not created. If a parameter
        /// has changed, for example, the <code>QueryString</code>, an error is returned.</p>
        /// <important>
        /// <p>This token is listed as not required because Amazon Web Services SDKs (for example
        /// the Amazon Web Services SDK for Java) auto-generate the token for users. If you are
        /// not using the Amazon Web Services SDK or the Amazon Web Services CLI, you must provide
        /// this token or the action will fail.</p>
        /// </important>
        pub fn client_request_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.client_request_token(input);
            self
        }
        pub fn set_client_request_token(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_client_request_token(input);
            self
        }
        /// <p>The database within which the query executes.</p>
        pub fn query_execution_context(
            mut self,
            input: crate::model::QueryExecutionContext,
        ) -> Self {
            self.inner = self.inner.query_execution_context(input);
            self
        }
        pub fn set_query_execution_context(
            mut self,
            input: std::option::Option<crate::model::QueryExecutionContext>,
        ) -> Self {
            self.inner = self.inner.set_query_execution_context(input);
            self
        }
        /// <p>Specifies information about where and how to save the results of the query execution.
        /// If the query runs in a workgroup, then workgroup's settings may override query settings.
        /// This affects the query results location. The workgroup settings override is specified in
        /// EnforceWorkGroupConfiguration (true/false) in the WorkGroupConfiguration. See <a>WorkGroupConfiguration$EnforceWorkGroupConfiguration</a>.</p>
        pub fn result_configuration(mut self, input: crate::model::ResultConfiguration) -> Self {
            self.inner = self.inner.result_configuration(input);
            self
        }
        pub fn set_result_configuration(
            mut self,
            input: std::option::Option<crate::model::ResultConfiguration>,
        ) -> Self {
            self.inner = self.inner.set_result_configuration(input);
            self
        }
        /// <p>The name of the workgroup in which the query is being started.</p>
        pub fn work_group(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.work_group(input);
            self
        }
        pub fn set_work_group(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_work_group(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct StopQueryExecution<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::stop_query_execution_input::Builder,
    }
    impl<C> StopQueryExecution<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::StopQueryExecutionOutput,
            smithy_http::result::SdkError<crate::error::StopQueryExecutionError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The unique ID of the query execution to stop.</p>
        pub fn query_execution_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.query_execution_id(input);
            self
        }
        pub fn set_query_execution_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_query_execution_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct TagResource<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::tag_resource_input::Builder,
    }
    impl<C> TagResource<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::TagResourceOutput,
            smithy_http::result::SdkError<crate::error::TagResourceError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Specifies the ARN of the Athena resource (workgroup or data catalog) to
        /// which tags are to be added.</p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resource_arn(input);
            self
        }
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_resource_arn(input);
            self
        }
        /// <p>A collection of one or more tags, separated by commas, to be added to an Athena workgroup or data catalog resource.</p>
        pub fn tags(mut self, inp: impl Into<crate::model::Tag>) -> Self {
            self.inner = self.inner.tags(inp);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UntagResource<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::untag_resource_input::Builder,
    }
    impl<C> UntagResource<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UntagResourceOutput,
            smithy_http::result::SdkError<crate::error::UntagResourceError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Specifies the ARN of the resource from which tags are to be removed.</p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resource_arn(input);
            self
        }
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_resource_arn(input);
            self
        }
        /// <p>A comma-separated list of one or more tag keys whose tags are to be removed from the
        /// specified resource.</p>
        pub fn tag_keys(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.tag_keys(inp);
            self
        }
        pub fn set_tag_keys(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_tag_keys(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateDataCatalog<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::update_data_catalog_input::Builder,
    }
    impl<C> UpdateDataCatalog<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateDataCatalogOutput,
            smithy_http::result::SdkError<crate::error::UpdateDataCatalogError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the data catalog to update. The catalog name must be unique for the
        /// Amazon Web Services account and can use a maximum of 128 alphanumeric, underscore, at
        /// sign, or hyphen characters.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(input);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
        /// <p>Specifies the type of data catalog to update. Specify <code>LAMBDA</code> for a
        /// federated catalog, <code>HIVE</code> for an external hive metastore, or
        /// <code>GLUE</code> for an Glue Data Catalog.</p>
        pub fn r#type(mut self, input: crate::model::DataCatalogType) -> Self {
            self.inner = self.inner.r#type(input);
            self
        }
        pub fn set_type(
            mut self,
            input: std::option::Option<crate::model::DataCatalogType>,
        ) -> Self {
            self.inner = self.inner.set_type(input);
            self
        }
        /// <p>New or modified text that describes the data catalog.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.description(input);
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_description(input);
            self
        }
        /// <p>Specifies the Lambda function or functions to use for updating the data
        /// catalog. This is a mapping whose values depend on the catalog type. </p>
        /// <ul>
        /// <li>
        /// <p>For the <code>HIVE</code> data catalog type, use the following syntax. The
        /// <code>metadata-function</code> parameter is required. <code>The
        /// sdk-version</code> parameter is optional and defaults to the currently
        /// supported version.</p>
        /// <p>
        /// <code>metadata-function=<i>lambda_arn</i>,
        /// sdk-version=<i>version_number</i>
        /// </code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>For the <code>LAMBDA</code> data catalog type, use one of the following sets
        /// of required parameters, but not both.</p>
        /// <ul>
        /// <li>
        /// <p>If you have one Lambda function that processes metadata
        /// and another for reading the actual data, use the following syntax. Both
        /// parameters are required.</p>
        /// <p>
        /// <code>metadata-function=<i>lambda_arn</i>,
        /// record-function=<i>lambda_arn</i>
        /// </code>
        /// </p>
        /// </li>
        /// <li>
        /// <p> If you have a composite Lambda function that processes
        /// both metadata and data, use the following syntax to specify your Lambda function.</p>
        /// <p>
        /// <code>function=<i>lambda_arn</i>
        /// </code>
        /// </p>
        /// </li>
        /// </ul>
        /// </li>
        /// </ul>
        pub fn parameters(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.parameters(k, v);
            self
        }
        pub fn set_parameters(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.inner = self.inner.set_parameters(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdatePreparedStatement<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::update_prepared_statement_input::Builder,
    }
    impl<C> UpdatePreparedStatement<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdatePreparedStatementOutput,
            smithy_http::result::SdkError<crate::error::UpdatePreparedStatementError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the prepared statement.</p>
        pub fn statement_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.statement_name(input);
            self
        }
        pub fn set_statement_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_statement_name(input);
            self
        }
        /// <p>The workgroup for the prepared statement.</p>
        pub fn work_group(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.work_group(input);
            self
        }
        pub fn set_work_group(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_work_group(input);
            self
        }
        /// <p>The query string for the prepared statement.</p>
        pub fn query_statement(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.query_statement(input);
            self
        }
        pub fn set_query_statement(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_query_statement(input);
            self
        }
        /// <p>The description of the prepared statement.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.description(input);
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_description(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateWorkGroup<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::update_work_group_input::Builder,
    }
    impl<C> UpdateWorkGroup<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateWorkGroupOutput,
            smithy_http::result::SdkError<crate::error::UpdateWorkGroupError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The specified workgroup that will be updated.</p>
        pub fn work_group(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.work_group(input);
            self
        }
        pub fn set_work_group(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_work_group(input);
            self
        }
        /// <p>The workgroup description.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.description(input);
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_description(input);
            self
        }
        /// <p>The workgroup configuration that will be updated for the given workgroup.</p>
        pub fn configuration_updates(
            mut self,
            input: crate::model::WorkGroupConfigurationUpdates,
        ) -> Self {
            self.inner = self.inner.configuration_updates(input);
            self
        }
        pub fn set_configuration_updates(
            mut self,
            input: std::option::Option<crate::model::WorkGroupConfigurationUpdates>,
        ) -> Self {
            self.inner = self.inner.set_configuration_updates(input);
            self
        }
        /// <p>The workgroup state that will be updated for the given workgroup.</p>
        pub fn state(mut self, input: crate::model::WorkGroupState) -> Self {
            self.inner = self.inner.state(input);
            self
        }
        pub fn set_state(
            mut self,
            input: std::option::Option<crate::model::WorkGroupState>,
        ) -> Self {
            self.inner = self.inner.set_state(input);
            self
        }
    }
}
