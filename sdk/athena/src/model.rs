// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum WorkGroupState {
    #[allow(missing_docs)] // documentation missing in model
    Disabled,
    #[allow(missing_docs)] // documentation missing in model
    Enabled,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for WorkGroupState {
    fn from(s: &str) -> Self {
        match s {
            "DISABLED" => WorkGroupState::Disabled,
            "ENABLED" => WorkGroupState::Enabled,
            other => WorkGroupState::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for WorkGroupState {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(WorkGroupState::from(s))
    }
}
impl WorkGroupState {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            WorkGroupState::Disabled => "DISABLED",
            WorkGroupState::Enabled => "ENABLED",
            WorkGroupState::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["DISABLED", "ENABLED"]
    }
}
impl AsRef<str> for WorkGroupState {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The configuration information that will be updated for this workgroup, which includes the location in Amazon S3 where query results are stored, the encryption option, if any, used for query results, whether the Amazon CloudWatch Metrics are enabled for the workgroup, whether the workgroup settings override the client-side settings, and the data usage limit for the amount of bytes scanned per query, if it is specified.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct WorkGroupConfigurationUpdates {
    /// <p>If set to "true", the settings for the workgroup override client-side settings. If set to "false" client-side settings are used. For more information, see <a href="https://docs.aws.amazon.com/athena/latest/ug/workgroups-settings-override.html">Workgroup Settings Override Client-Side Settings</a>.</p>
    pub enforce_work_group_configuration: std::option::Option<bool>,
    /// <p>The result configuration information about the queries in this workgroup that will be updated. Includes the updated results location and an updated option for encrypting query results.</p>
    pub result_configuration_updates: std::option::Option<crate::model::ResultConfigurationUpdates>,
    /// <p>Indicates whether this workgroup enables publishing metrics to Amazon CloudWatch.</p>
    pub publish_cloud_watch_metrics_enabled: std::option::Option<bool>,
    /// <p>The upper limit (cutoff) for the amount of bytes a single query in a workgroup is allowed to scan.</p>
    pub bytes_scanned_cutoff_per_query: std::option::Option<i64>,
    /// <p>Indicates that the data usage control limit per query is removed. <code>WorkGroupConfiguration$BytesScannedCutoffPerQuery</code> </p>
    pub remove_bytes_scanned_cutoff_per_query: std::option::Option<bool>,
    /// <p>If set to <code>true</code>, allows members assigned to a workgroup to specify Amazon S3 Requester Pays buckets in queries. If set to <code>false</code>, workgroup members cannot query data from Requester Pays buckets, and queries that retrieve data from Requester Pays buckets cause an error. The default is <code>false</code>. For more information about Requester Pays buckets, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/RequesterPaysBuckets.html">Requester Pays Buckets</a> in the <i>Amazon Simple Storage Service Developer Guide</i>.</p>
    pub requester_pays_enabled: std::option::Option<bool>,
    /// <p>The engine version requested when a workgroup is updated. After the update, all queries on the workgroup run on the requested engine version. If no value was previously set, the default is Auto. Queries on the <code>AmazonAthenaPreviewFunctionality</code> workgroup run on the preview engine regardless of this setting.</p>
    pub engine_version: std::option::Option<crate::model::EngineVersion>,
}
impl WorkGroupConfigurationUpdates {
    /// <p>If set to "true", the settings for the workgroup override client-side settings. If set to "false" client-side settings are used. For more information, see <a href="https://docs.aws.amazon.com/athena/latest/ug/workgroups-settings-override.html">Workgroup Settings Override Client-Side Settings</a>.</p>
    pub fn enforce_work_group_configuration(&self) -> std::option::Option<bool> {
        self.enforce_work_group_configuration
    }
    /// <p>The result configuration information about the queries in this workgroup that will be updated. Includes the updated results location and an updated option for encrypting query results.</p>
    pub fn result_configuration_updates(
        &self,
    ) -> std::option::Option<&crate::model::ResultConfigurationUpdates> {
        self.result_configuration_updates.as_ref()
    }
    /// <p>Indicates whether this workgroup enables publishing metrics to Amazon CloudWatch.</p>
    pub fn publish_cloud_watch_metrics_enabled(&self) -> std::option::Option<bool> {
        self.publish_cloud_watch_metrics_enabled
    }
    /// <p>The upper limit (cutoff) for the amount of bytes a single query in a workgroup is allowed to scan.</p>
    pub fn bytes_scanned_cutoff_per_query(&self) -> std::option::Option<i64> {
        self.bytes_scanned_cutoff_per_query
    }
    /// <p>Indicates that the data usage control limit per query is removed. <code>WorkGroupConfiguration$BytesScannedCutoffPerQuery</code> </p>
    pub fn remove_bytes_scanned_cutoff_per_query(&self) -> std::option::Option<bool> {
        self.remove_bytes_scanned_cutoff_per_query
    }
    /// <p>If set to <code>true</code>, allows members assigned to a workgroup to specify Amazon S3 Requester Pays buckets in queries. If set to <code>false</code>, workgroup members cannot query data from Requester Pays buckets, and queries that retrieve data from Requester Pays buckets cause an error. The default is <code>false</code>. For more information about Requester Pays buckets, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/RequesterPaysBuckets.html">Requester Pays Buckets</a> in the <i>Amazon Simple Storage Service Developer Guide</i>.</p>
    pub fn requester_pays_enabled(&self) -> std::option::Option<bool> {
        self.requester_pays_enabled
    }
    /// <p>The engine version requested when a workgroup is updated. After the update, all queries on the workgroup run on the requested engine version. If no value was previously set, the default is Auto. Queries on the <code>AmazonAthenaPreviewFunctionality</code> workgroup run on the preview engine regardless of this setting.</p>
    pub fn engine_version(&self) -> std::option::Option<&crate::model::EngineVersion> {
        self.engine_version.as_ref()
    }
}
impl std::fmt::Debug for WorkGroupConfigurationUpdates {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("WorkGroupConfigurationUpdates");
        formatter.field(
            "enforce_work_group_configuration",
            &self.enforce_work_group_configuration,
        );
        formatter.field(
            "result_configuration_updates",
            &self.result_configuration_updates,
        );
        formatter.field(
            "publish_cloud_watch_metrics_enabled",
            &self.publish_cloud_watch_metrics_enabled,
        );
        formatter.field(
            "bytes_scanned_cutoff_per_query",
            &self.bytes_scanned_cutoff_per_query,
        );
        formatter.field(
            "remove_bytes_scanned_cutoff_per_query",
            &self.remove_bytes_scanned_cutoff_per_query,
        );
        formatter.field("requester_pays_enabled", &self.requester_pays_enabled);
        formatter.field("engine_version", &self.engine_version);
        formatter.finish()
    }
}
/// See [`WorkGroupConfigurationUpdates`](crate::model::WorkGroupConfigurationUpdates)
pub mod work_group_configuration_updates {

    /// A builder for [`WorkGroupConfigurationUpdates`](crate::model::WorkGroupConfigurationUpdates)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) enforce_work_group_configuration: std::option::Option<bool>,
        pub(crate) result_configuration_updates:
            std::option::Option<crate::model::ResultConfigurationUpdates>,
        pub(crate) publish_cloud_watch_metrics_enabled: std::option::Option<bool>,
        pub(crate) bytes_scanned_cutoff_per_query: std::option::Option<i64>,
        pub(crate) remove_bytes_scanned_cutoff_per_query: std::option::Option<bool>,
        pub(crate) requester_pays_enabled: std::option::Option<bool>,
        pub(crate) engine_version: std::option::Option<crate::model::EngineVersion>,
    }
    impl Builder {
        /// <p>If set to "true", the settings for the workgroup override client-side settings. If set to "false" client-side settings are used. For more information, see <a href="https://docs.aws.amazon.com/athena/latest/ug/workgroups-settings-override.html">Workgroup Settings Override Client-Side Settings</a>.</p>
        pub fn enforce_work_group_configuration(mut self, input: bool) -> Self {
            self.enforce_work_group_configuration = Some(input);
            self
        }
        /// <p>If set to "true", the settings for the workgroup override client-side settings. If set to "false" client-side settings are used. For more information, see <a href="https://docs.aws.amazon.com/athena/latest/ug/workgroups-settings-override.html">Workgroup Settings Override Client-Side Settings</a>.</p>
        pub fn set_enforce_work_group_configuration(
            mut self,
            input: std::option::Option<bool>,
        ) -> Self {
            self.enforce_work_group_configuration = input;
            self
        }
        /// <p>The result configuration information about the queries in this workgroup that will be updated. Includes the updated results location and an updated option for encrypting query results.</p>
        pub fn result_configuration_updates(
            mut self,
            input: crate::model::ResultConfigurationUpdates,
        ) -> Self {
            self.result_configuration_updates = Some(input);
            self
        }
        /// <p>The result configuration information about the queries in this workgroup that will be updated. Includes the updated results location and an updated option for encrypting query results.</p>
        pub fn set_result_configuration_updates(
            mut self,
            input: std::option::Option<crate::model::ResultConfigurationUpdates>,
        ) -> Self {
            self.result_configuration_updates = input;
            self
        }
        /// <p>Indicates whether this workgroup enables publishing metrics to Amazon CloudWatch.</p>
        pub fn publish_cloud_watch_metrics_enabled(mut self, input: bool) -> Self {
            self.publish_cloud_watch_metrics_enabled = Some(input);
            self
        }
        /// <p>Indicates whether this workgroup enables publishing metrics to Amazon CloudWatch.</p>
        pub fn set_publish_cloud_watch_metrics_enabled(
            mut self,
            input: std::option::Option<bool>,
        ) -> Self {
            self.publish_cloud_watch_metrics_enabled = input;
            self
        }
        /// <p>The upper limit (cutoff) for the amount of bytes a single query in a workgroup is allowed to scan.</p>
        pub fn bytes_scanned_cutoff_per_query(mut self, input: i64) -> Self {
            self.bytes_scanned_cutoff_per_query = Some(input);
            self
        }
        /// <p>The upper limit (cutoff) for the amount of bytes a single query in a workgroup is allowed to scan.</p>
        pub fn set_bytes_scanned_cutoff_per_query(
            mut self,
            input: std::option::Option<i64>,
        ) -> Self {
            self.bytes_scanned_cutoff_per_query = input;
            self
        }
        /// <p>Indicates that the data usage control limit per query is removed. <code>WorkGroupConfiguration$BytesScannedCutoffPerQuery</code> </p>
        pub fn remove_bytes_scanned_cutoff_per_query(mut self, input: bool) -> Self {
            self.remove_bytes_scanned_cutoff_per_query = Some(input);
            self
        }
        /// <p>Indicates that the data usage control limit per query is removed. <code>WorkGroupConfiguration$BytesScannedCutoffPerQuery</code> </p>
        pub fn set_remove_bytes_scanned_cutoff_per_query(
            mut self,
            input: std::option::Option<bool>,
        ) -> Self {
            self.remove_bytes_scanned_cutoff_per_query = input;
            self
        }
        /// <p>If set to <code>true</code>, allows members assigned to a workgroup to specify Amazon S3 Requester Pays buckets in queries. If set to <code>false</code>, workgroup members cannot query data from Requester Pays buckets, and queries that retrieve data from Requester Pays buckets cause an error. The default is <code>false</code>. For more information about Requester Pays buckets, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/RequesterPaysBuckets.html">Requester Pays Buckets</a> in the <i>Amazon Simple Storage Service Developer Guide</i>.</p>
        pub fn requester_pays_enabled(mut self, input: bool) -> Self {
            self.requester_pays_enabled = Some(input);
            self
        }
        /// <p>If set to <code>true</code>, allows members assigned to a workgroup to specify Amazon S3 Requester Pays buckets in queries. If set to <code>false</code>, workgroup members cannot query data from Requester Pays buckets, and queries that retrieve data from Requester Pays buckets cause an error. The default is <code>false</code>. For more information about Requester Pays buckets, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/RequesterPaysBuckets.html">Requester Pays Buckets</a> in the <i>Amazon Simple Storage Service Developer Guide</i>.</p>
        pub fn set_requester_pays_enabled(mut self, input: std::option::Option<bool>) -> Self {
            self.requester_pays_enabled = input;
            self
        }
        /// <p>The engine version requested when a workgroup is updated. After the update, all queries on the workgroup run on the requested engine version. If no value was previously set, the default is Auto. Queries on the <code>AmazonAthenaPreviewFunctionality</code> workgroup run on the preview engine regardless of this setting.</p>
        pub fn engine_version(mut self, input: crate::model::EngineVersion) -> Self {
            self.engine_version = Some(input);
            self
        }
        /// <p>The engine version requested when a workgroup is updated. After the update, all queries on the workgroup run on the requested engine version. If no value was previously set, the default is Auto. Queries on the <code>AmazonAthenaPreviewFunctionality</code> workgroup run on the preview engine regardless of this setting.</p>
        pub fn set_engine_version(
            mut self,
            input: std::option::Option<crate::model::EngineVersion>,
        ) -> Self {
            self.engine_version = input;
            self
        }
        /// Consumes the builder and constructs a [`WorkGroupConfigurationUpdates`](crate::model::WorkGroupConfigurationUpdates)
        pub fn build(self) -> crate::model::WorkGroupConfigurationUpdates {
            crate::model::WorkGroupConfigurationUpdates {
                enforce_work_group_configuration: self.enforce_work_group_configuration,
                result_configuration_updates: self.result_configuration_updates,
                publish_cloud_watch_metrics_enabled: self.publish_cloud_watch_metrics_enabled,
                bytes_scanned_cutoff_per_query: self.bytes_scanned_cutoff_per_query,
                remove_bytes_scanned_cutoff_per_query: self.remove_bytes_scanned_cutoff_per_query,
                requester_pays_enabled: self.requester_pays_enabled,
                engine_version: self.engine_version,
            }
        }
    }
}
impl WorkGroupConfigurationUpdates {
    /// Creates a new builder-style object to manufacture [`WorkGroupConfigurationUpdates`](crate::model::WorkGroupConfigurationUpdates)
    pub fn builder() -> crate::model::work_group_configuration_updates::Builder {
        crate::model::work_group_configuration_updates::Builder::default()
    }
}

/// <p>The Athena engine version for running queries.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct EngineVersion {
    /// <p>The engine version requested by the user. Possible values are determined by the output of <code>ListEngineVersions</code>, including Auto. The default is Auto.</p>
    pub selected_engine_version: std::option::Option<std::string::String>,
    /// <p>Read only. The engine version on which the query runs. If the user requests a valid engine version other than Auto, the effective engine version is the same as the engine version that the user requested. If the user requests Auto, the effective engine version is chosen by Athena. When a request to update the engine version is made by a <code>CreateWorkGroup</code> or <code>UpdateWorkGroup</code> operation, the <code>EffectiveEngineVersion</code> field is ignored.</p>
    pub effective_engine_version: std::option::Option<std::string::String>,
}
impl EngineVersion {
    /// <p>The engine version requested by the user. Possible values are determined by the output of <code>ListEngineVersions</code>, including Auto. The default is Auto.</p>
    pub fn selected_engine_version(&self) -> std::option::Option<&str> {
        self.selected_engine_version.as_deref()
    }
    /// <p>Read only. The engine version on which the query runs. If the user requests a valid engine version other than Auto, the effective engine version is the same as the engine version that the user requested. If the user requests Auto, the effective engine version is chosen by Athena. When a request to update the engine version is made by a <code>CreateWorkGroup</code> or <code>UpdateWorkGroup</code> operation, the <code>EffectiveEngineVersion</code> field is ignored.</p>
    pub fn effective_engine_version(&self) -> std::option::Option<&str> {
        self.effective_engine_version.as_deref()
    }
}
impl std::fmt::Debug for EngineVersion {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("EngineVersion");
        formatter.field("selected_engine_version", &self.selected_engine_version);
        formatter.field("effective_engine_version", &self.effective_engine_version);
        formatter.finish()
    }
}
/// See [`EngineVersion`](crate::model::EngineVersion)
pub mod engine_version {

    /// A builder for [`EngineVersion`](crate::model::EngineVersion)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) selected_engine_version: std::option::Option<std::string::String>,
        pub(crate) effective_engine_version: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The engine version requested by the user. Possible values are determined by the output of <code>ListEngineVersions</code>, including Auto. The default is Auto.</p>
        pub fn selected_engine_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.selected_engine_version = Some(input.into());
            self
        }
        /// <p>The engine version requested by the user. Possible values are determined by the output of <code>ListEngineVersions</code>, including Auto. The default is Auto.</p>
        pub fn set_selected_engine_version(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.selected_engine_version = input;
            self
        }
        /// <p>Read only. The engine version on which the query runs. If the user requests a valid engine version other than Auto, the effective engine version is the same as the engine version that the user requested. If the user requests Auto, the effective engine version is chosen by Athena. When a request to update the engine version is made by a <code>CreateWorkGroup</code> or <code>UpdateWorkGroup</code> operation, the <code>EffectiveEngineVersion</code> field is ignored.</p>
        pub fn effective_engine_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.effective_engine_version = Some(input.into());
            self
        }
        /// <p>Read only. The engine version on which the query runs. If the user requests a valid engine version other than Auto, the effective engine version is the same as the engine version that the user requested. If the user requests Auto, the effective engine version is chosen by Athena. When a request to update the engine version is made by a <code>CreateWorkGroup</code> or <code>UpdateWorkGroup</code> operation, the <code>EffectiveEngineVersion</code> field is ignored.</p>
        pub fn set_effective_engine_version(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.effective_engine_version = input;
            self
        }
        /// Consumes the builder and constructs a [`EngineVersion`](crate::model::EngineVersion)
        pub fn build(self) -> crate::model::EngineVersion {
            crate::model::EngineVersion {
                selected_engine_version: self.selected_engine_version,
                effective_engine_version: self.effective_engine_version,
            }
        }
    }
}
impl EngineVersion {
    /// Creates a new builder-style object to manufacture [`EngineVersion`](crate::model::EngineVersion)
    pub fn builder() -> crate::model::engine_version::Builder {
        crate::model::engine_version::Builder::default()
    }
}

/// <p>The information about the updates in the query results, such as output location and encryption configuration for the query results.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ResultConfigurationUpdates {
    /// <p>The location in Amazon S3 where your query results are stored, such as <code>s3://path/to/query/bucket/</code>. For more information, see <a href="https://docs.aws.amazon.com/athena/latest/ug/querying.html">Query Results</a> If workgroup settings override client-side settings, then the query uses the location for the query results and the encryption configuration that are specified for the workgroup. The "workgroup settings override" is specified in <code>EnforceWorkGroupConfiguration</code> (true/false) in the <code>WorkGroupConfiguration</code>. See <code>WorkGroupConfiguration$EnforceWorkGroupConfiguration</code>.</p>
    pub output_location: std::option::Option<std::string::String>,
    /// <p>If set to "true", indicates that the previously-specified query results location (also known as a client-side setting) for queries in this workgroup should be ignored and set to null. If set to "false" or not set, and a value is present in the <code>OutputLocation</code> in <code>ResultConfigurationUpdates</code> (the client-side setting), the <code>OutputLocation</code> in the workgroup's <code>ResultConfiguration</code> will be updated with the new value. For more information, see <a href="https://docs.aws.amazon.com/athena/latest/ug/workgroups-settings-override.html">Workgroup Settings Override Client-Side Settings</a>.</p>
    pub remove_output_location: std::option::Option<bool>,
    /// <p>The encryption configuration for the query results.</p>
    pub encryption_configuration: std::option::Option<crate::model::EncryptionConfiguration>,
    /// <p>If set to "true", indicates that the previously-specified encryption configuration (also known as the client-side setting) for queries in this workgroup should be ignored and set to null. If set to "false" or not set, and a value is present in the <code>EncryptionConfiguration</code> in <code>ResultConfigurationUpdates</code> (the client-side setting), the <code>EncryptionConfiguration</code> in the workgroup's <code>ResultConfiguration</code> will be updated with the new value. For more information, see <a href="https://docs.aws.amazon.com/athena/latest/ug/workgroups-settings-override.html">Workgroup Settings Override Client-Side Settings</a>.</p>
    pub remove_encryption_configuration: std::option::Option<bool>,
    /// <p>The Amazon Web Services account ID that you expect to be the owner of the Amazon S3 bucket specified by <code>ResultConfiguration$OutputLocation</code>. If set, Athena uses the value for <code>ExpectedBucketOwner</code> when it makes Amazon S3 calls to your specified output location. If the <code>ExpectedBucketOwner</code> Amazon Web Services account ID does not match the actual owner of the Amazon S3 bucket, the call fails with a permissions error.</p>
    /// <p>If workgroup settings override client-side settings, then the query uses the <code>ExpectedBucketOwner</code> setting that is specified for the workgroup, and also uses the location for storing query results specified in the workgroup. See <code>WorkGroupConfiguration$EnforceWorkGroupConfiguration</code> and <a href="https://docs.aws.amazon.com/athena/latest/ug/workgroups-settings-override.html">Workgroup Settings Override Client-Side Settings</a>.</p>
    pub expected_bucket_owner: std::option::Option<std::string::String>,
    /// <p>If set to "true", removes the Amazon Web Services account ID previously specified for <code>ResultConfiguration$ExpectedBucketOwner</code>. If set to "false" or not set, and a value is present in the <code>ExpectedBucketOwner</code> in <code>ResultConfigurationUpdates</code> (the client-side setting), the <code>ExpectedBucketOwner</code> in the workgroup's <code>ResultConfiguration</code> is updated with the new value. For more information, see <a href="https://docs.aws.amazon.com/athena/latest/ug/workgroups-settings-override.html">Workgroup Settings Override Client-Side Settings</a>.</p>
    pub remove_expected_bucket_owner: std::option::Option<bool>,
    /// <p>The ACL configuration for the query results.</p>
    pub acl_configuration: std::option::Option<crate::model::AclConfiguration>,
    /// <p>If set to <code>true</code>, indicates that the previously-specified ACL configuration for queries in this workgroup should be ignored and set to null. If set to <code>false</code> or not set, and a value is present in the <code>AclConfiguration</code> of <code>ResultConfigurationUpdates</code>, the <code>AclConfiguration</code> in the workgroup's <code>ResultConfiguration</code> is updated with the new value. For more information, see <a href="https://docs.aws.amazon.com/athena/latest/ug/workgroups-settings-override.html">Workgroup Settings Override Client-Side Settings</a>.</p>
    pub remove_acl_configuration: std::option::Option<bool>,
}
impl ResultConfigurationUpdates {
    /// <p>The location in Amazon S3 where your query results are stored, such as <code>s3://path/to/query/bucket/</code>. For more information, see <a href="https://docs.aws.amazon.com/athena/latest/ug/querying.html">Query Results</a> If workgroup settings override client-side settings, then the query uses the location for the query results and the encryption configuration that are specified for the workgroup. The "workgroup settings override" is specified in <code>EnforceWorkGroupConfiguration</code> (true/false) in the <code>WorkGroupConfiguration</code>. See <code>WorkGroupConfiguration$EnforceWorkGroupConfiguration</code>.</p>
    pub fn output_location(&self) -> std::option::Option<&str> {
        self.output_location.as_deref()
    }
    /// <p>If set to "true", indicates that the previously-specified query results location (also known as a client-side setting) for queries in this workgroup should be ignored and set to null. If set to "false" or not set, and a value is present in the <code>OutputLocation</code> in <code>ResultConfigurationUpdates</code> (the client-side setting), the <code>OutputLocation</code> in the workgroup's <code>ResultConfiguration</code> will be updated with the new value. For more information, see <a href="https://docs.aws.amazon.com/athena/latest/ug/workgroups-settings-override.html">Workgroup Settings Override Client-Side Settings</a>.</p>
    pub fn remove_output_location(&self) -> std::option::Option<bool> {
        self.remove_output_location
    }
    /// <p>The encryption configuration for the query results.</p>
    pub fn encryption_configuration(
        &self,
    ) -> std::option::Option<&crate::model::EncryptionConfiguration> {
        self.encryption_configuration.as_ref()
    }
    /// <p>If set to "true", indicates that the previously-specified encryption configuration (also known as the client-side setting) for queries in this workgroup should be ignored and set to null. If set to "false" or not set, and a value is present in the <code>EncryptionConfiguration</code> in <code>ResultConfigurationUpdates</code> (the client-side setting), the <code>EncryptionConfiguration</code> in the workgroup's <code>ResultConfiguration</code> will be updated with the new value. For more information, see <a href="https://docs.aws.amazon.com/athena/latest/ug/workgroups-settings-override.html">Workgroup Settings Override Client-Side Settings</a>.</p>
    pub fn remove_encryption_configuration(&self) -> std::option::Option<bool> {
        self.remove_encryption_configuration
    }
    /// <p>The Amazon Web Services account ID that you expect to be the owner of the Amazon S3 bucket specified by <code>ResultConfiguration$OutputLocation</code>. If set, Athena uses the value for <code>ExpectedBucketOwner</code> when it makes Amazon S3 calls to your specified output location. If the <code>ExpectedBucketOwner</code> Amazon Web Services account ID does not match the actual owner of the Amazon S3 bucket, the call fails with a permissions error.</p>
    /// <p>If workgroup settings override client-side settings, then the query uses the <code>ExpectedBucketOwner</code> setting that is specified for the workgroup, and also uses the location for storing query results specified in the workgroup. See <code>WorkGroupConfiguration$EnforceWorkGroupConfiguration</code> and <a href="https://docs.aws.amazon.com/athena/latest/ug/workgroups-settings-override.html">Workgroup Settings Override Client-Side Settings</a>.</p>
    pub fn expected_bucket_owner(&self) -> std::option::Option<&str> {
        self.expected_bucket_owner.as_deref()
    }
    /// <p>If set to "true", removes the Amazon Web Services account ID previously specified for <code>ResultConfiguration$ExpectedBucketOwner</code>. If set to "false" or not set, and a value is present in the <code>ExpectedBucketOwner</code> in <code>ResultConfigurationUpdates</code> (the client-side setting), the <code>ExpectedBucketOwner</code> in the workgroup's <code>ResultConfiguration</code> is updated with the new value. For more information, see <a href="https://docs.aws.amazon.com/athena/latest/ug/workgroups-settings-override.html">Workgroup Settings Override Client-Side Settings</a>.</p>
    pub fn remove_expected_bucket_owner(&self) -> std::option::Option<bool> {
        self.remove_expected_bucket_owner
    }
    /// <p>The ACL configuration for the query results.</p>
    pub fn acl_configuration(&self) -> std::option::Option<&crate::model::AclConfiguration> {
        self.acl_configuration.as_ref()
    }
    /// <p>If set to <code>true</code>, indicates that the previously-specified ACL configuration for queries in this workgroup should be ignored and set to null. If set to <code>false</code> or not set, and a value is present in the <code>AclConfiguration</code> of <code>ResultConfigurationUpdates</code>, the <code>AclConfiguration</code> in the workgroup's <code>ResultConfiguration</code> is updated with the new value. For more information, see <a href="https://docs.aws.amazon.com/athena/latest/ug/workgroups-settings-override.html">Workgroup Settings Override Client-Side Settings</a>.</p>
    pub fn remove_acl_configuration(&self) -> std::option::Option<bool> {
        self.remove_acl_configuration
    }
}
impl std::fmt::Debug for ResultConfigurationUpdates {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ResultConfigurationUpdates");
        formatter.field("output_location", &self.output_location);
        formatter.field("remove_output_location", &self.remove_output_location);
        formatter.field("encryption_configuration", &self.encryption_configuration);
        formatter.field(
            "remove_encryption_configuration",
            &self.remove_encryption_configuration,
        );
        formatter.field("expected_bucket_owner", &self.expected_bucket_owner);
        formatter.field(
            "remove_expected_bucket_owner",
            &self.remove_expected_bucket_owner,
        );
        formatter.field("acl_configuration", &self.acl_configuration);
        formatter.field("remove_acl_configuration", &self.remove_acl_configuration);
        formatter.finish()
    }
}
/// See [`ResultConfigurationUpdates`](crate::model::ResultConfigurationUpdates)
pub mod result_configuration_updates {

    /// A builder for [`ResultConfigurationUpdates`](crate::model::ResultConfigurationUpdates)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) output_location: std::option::Option<std::string::String>,
        pub(crate) remove_output_location: std::option::Option<bool>,
        pub(crate) encryption_configuration:
            std::option::Option<crate::model::EncryptionConfiguration>,
        pub(crate) remove_encryption_configuration: std::option::Option<bool>,
        pub(crate) expected_bucket_owner: std::option::Option<std::string::String>,
        pub(crate) remove_expected_bucket_owner: std::option::Option<bool>,
        pub(crate) acl_configuration: std::option::Option<crate::model::AclConfiguration>,
        pub(crate) remove_acl_configuration: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>The location in Amazon S3 where your query results are stored, such as <code>s3://path/to/query/bucket/</code>. For more information, see <a href="https://docs.aws.amazon.com/athena/latest/ug/querying.html">Query Results</a> If workgroup settings override client-side settings, then the query uses the location for the query results and the encryption configuration that are specified for the workgroup. The "workgroup settings override" is specified in <code>EnforceWorkGroupConfiguration</code> (true/false) in the <code>WorkGroupConfiguration</code>. See <code>WorkGroupConfiguration$EnforceWorkGroupConfiguration</code>.</p>
        pub fn output_location(mut self, input: impl Into<std::string::String>) -> Self {
            self.output_location = Some(input.into());
            self
        }
        /// <p>The location in Amazon S3 where your query results are stored, such as <code>s3://path/to/query/bucket/</code>. For more information, see <a href="https://docs.aws.amazon.com/athena/latest/ug/querying.html">Query Results</a> If workgroup settings override client-side settings, then the query uses the location for the query results and the encryption configuration that are specified for the workgroup. The "workgroup settings override" is specified in <code>EnforceWorkGroupConfiguration</code> (true/false) in the <code>WorkGroupConfiguration</code>. See <code>WorkGroupConfiguration$EnforceWorkGroupConfiguration</code>.</p>
        pub fn set_output_location(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.output_location = input;
            self
        }
        /// <p>If set to "true", indicates that the previously-specified query results location (also known as a client-side setting) for queries in this workgroup should be ignored and set to null. If set to "false" or not set, and a value is present in the <code>OutputLocation</code> in <code>ResultConfigurationUpdates</code> (the client-side setting), the <code>OutputLocation</code> in the workgroup's <code>ResultConfiguration</code> will be updated with the new value. For more information, see <a href="https://docs.aws.amazon.com/athena/latest/ug/workgroups-settings-override.html">Workgroup Settings Override Client-Side Settings</a>.</p>
        pub fn remove_output_location(mut self, input: bool) -> Self {
            self.remove_output_location = Some(input);
            self
        }
        /// <p>If set to "true", indicates that the previously-specified query results location (also known as a client-side setting) for queries in this workgroup should be ignored and set to null. If set to "false" or not set, and a value is present in the <code>OutputLocation</code> in <code>ResultConfigurationUpdates</code> (the client-side setting), the <code>OutputLocation</code> in the workgroup's <code>ResultConfiguration</code> will be updated with the new value. For more information, see <a href="https://docs.aws.amazon.com/athena/latest/ug/workgroups-settings-override.html">Workgroup Settings Override Client-Side Settings</a>.</p>
        pub fn set_remove_output_location(mut self, input: std::option::Option<bool>) -> Self {
            self.remove_output_location = input;
            self
        }
        /// <p>The encryption configuration for the query results.</p>
        pub fn encryption_configuration(
            mut self,
            input: crate::model::EncryptionConfiguration,
        ) -> Self {
            self.encryption_configuration = Some(input);
            self
        }
        /// <p>The encryption configuration for the query results.</p>
        pub fn set_encryption_configuration(
            mut self,
            input: std::option::Option<crate::model::EncryptionConfiguration>,
        ) -> Self {
            self.encryption_configuration = input;
            self
        }
        /// <p>If set to "true", indicates that the previously-specified encryption configuration (also known as the client-side setting) for queries in this workgroup should be ignored and set to null. If set to "false" or not set, and a value is present in the <code>EncryptionConfiguration</code> in <code>ResultConfigurationUpdates</code> (the client-side setting), the <code>EncryptionConfiguration</code> in the workgroup's <code>ResultConfiguration</code> will be updated with the new value. For more information, see <a href="https://docs.aws.amazon.com/athena/latest/ug/workgroups-settings-override.html">Workgroup Settings Override Client-Side Settings</a>.</p>
        pub fn remove_encryption_configuration(mut self, input: bool) -> Self {
            self.remove_encryption_configuration = Some(input);
            self
        }
        /// <p>If set to "true", indicates that the previously-specified encryption configuration (also known as the client-side setting) for queries in this workgroup should be ignored and set to null. If set to "false" or not set, and a value is present in the <code>EncryptionConfiguration</code> in <code>ResultConfigurationUpdates</code> (the client-side setting), the <code>EncryptionConfiguration</code> in the workgroup's <code>ResultConfiguration</code> will be updated with the new value. For more information, see <a href="https://docs.aws.amazon.com/athena/latest/ug/workgroups-settings-override.html">Workgroup Settings Override Client-Side Settings</a>.</p>
        pub fn set_remove_encryption_configuration(
            mut self,
            input: std::option::Option<bool>,
        ) -> Self {
            self.remove_encryption_configuration = input;
            self
        }
        /// <p>The Amazon Web Services account ID that you expect to be the owner of the Amazon S3 bucket specified by <code>ResultConfiguration$OutputLocation</code>. If set, Athena uses the value for <code>ExpectedBucketOwner</code> when it makes Amazon S3 calls to your specified output location. If the <code>ExpectedBucketOwner</code> Amazon Web Services account ID does not match the actual owner of the Amazon S3 bucket, the call fails with a permissions error.</p>
        /// <p>If workgroup settings override client-side settings, then the query uses the <code>ExpectedBucketOwner</code> setting that is specified for the workgroup, and also uses the location for storing query results specified in the workgroup. See <code>WorkGroupConfiguration$EnforceWorkGroupConfiguration</code> and <a href="https://docs.aws.amazon.com/athena/latest/ug/workgroups-settings-override.html">Workgroup Settings Override Client-Side Settings</a>.</p>
        pub fn expected_bucket_owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.expected_bucket_owner = Some(input.into());
            self
        }
        /// <p>The Amazon Web Services account ID that you expect to be the owner of the Amazon S3 bucket specified by <code>ResultConfiguration$OutputLocation</code>. If set, Athena uses the value for <code>ExpectedBucketOwner</code> when it makes Amazon S3 calls to your specified output location. If the <code>ExpectedBucketOwner</code> Amazon Web Services account ID does not match the actual owner of the Amazon S3 bucket, the call fails with a permissions error.</p>
        /// <p>If workgroup settings override client-side settings, then the query uses the <code>ExpectedBucketOwner</code> setting that is specified for the workgroup, and also uses the location for storing query results specified in the workgroup. See <code>WorkGroupConfiguration$EnforceWorkGroupConfiguration</code> and <a href="https://docs.aws.amazon.com/athena/latest/ug/workgroups-settings-override.html">Workgroup Settings Override Client-Side Settings</a>.</p>
        pub fn set_expected_bucket_owner(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.expected_bucket_owner = input;
            self
        }
        /// <p>If set to "true", removes the Amazon Web Services account ID previously specified for <code>ResultConfiguration$ExpectedBucketOwner</code>. If set to "false" or not set, and a value is present in the <code>ExpectedBucketOwner</code> in <code>ResultConfigurationUpdates</code> (the client-side setting), the <code>ExpectedBucketOwner</code> in the workgroup's <code>ResultConfiguration</code> is updated with the new value. For more information, see <a href="https://docs.aws.amazon.com/athena/latest/ug/workgroups-settings-override.html">Workgroup Settings Override Client-Side Settings</a>.</p>
        pub fn remove_expected_bucket_owner(mut self, input: bool) -> Self {
            self.remove_expected_bucket_owner = Some(input);
            self
        }
        /// <p>If set to "true", removes the Amazon Web Services account ID previously specified for <code>ResultConfiguration$ExpectedBucketOwner</code>. If set to "false" or not set, and a value is present in the <code>ExpectedBucketOwner</code> in <code>ResultConfigurationUpdates</code> (the client-side setting), the <code>ExpectedBucketOwner</code> in the workgroup's <code>ResultConfiguration</code> is updated with the new value. For more information, see <a href="https://docs.aws.amazon.com/athena/latest/ug/workgroups-settings-override.html">Workgroup Settings Override Client-Side Settings</a>.</p>
        pub fn set_remove_expected_bucket_owner(
            mut self,
            input: std::option::Option<bool>,
        ) -> Self {
            self.remove_expected_bucket_owner = input;
            self
        }
        /// <p>The ACL configuration for the query results.</p>
        pub fn acl_configuration(mut self, input: crate::model::AclConfiguration) -> Self {
            self.acl_configuration = Some(input);
            self
        }
        /// <p>The ACL configuration for the query results.</p>
        pub fn set_acl_configuration(
            mut self,
            input: std::option::Option<crate::model::AclConfiguration>,
        ) -> Self {
            self.acl_configuration = input;
            self
        }
        /// <p>If set to <code>true</code>, indicates that the previously-specified ACL configuration for queries in this workgroup should be ignored and set to null. If set to <code>false</code> or not set, and a value is present in the <code>AclConfiguration</code> of <code>ResultConfigurationUpdates</code>, the <code>AclConfiguration</code> in the workgroup's <code>ResultConfiguration</code> is updated with the new value. For more information, see <a href="https://docs.aws.amazon.com/athena/latest/ug/workgroups-settings-override.html">Workgroup Settings Override Client-Side Settings</a>.</p>
        pub fn remove_acl_configuration(mut self, input: bool) -> Self {
            self.remove_acl_configuration = Some(input);
            self
        }
        /// <p>If set to <code>true</code>, indicates that the previously-specified ACL configuration for queries in this workgroup should be ignored and set to null. If set to <code>false</code> or not set, and a value is present in the <code>AclConfiguration</code> of <code>ResultConfigurationUpdates</code>, the <code>AclConfiguration</code> in the workgroup's <code>ResultConfiguration</code> is updated with the new value. For more information, see <a href="https://docs.aws.amazon.com/athena/latest/ug/workgroups-settings-override.html">Workgroup Settings Override Client-Side Settings</a>.</p>
        pub fn set_remove_acl_configuration(mut self, input: std::option::Option<bool>) -> Self {
            self.remove_acl_configuration = input;
            self
        }
        /// Consumes the builder and constructs a [`ResultConfigurationUpdates`](crate::model::ResultConfigurationUpdates)
        pub fn build(self) -> crate::model::ResultConfigurationUpdates {
            crate::model::ResultConfigurationUpdates {
                output_location: self.output_location,
                remove_output_location: self.remove_output_location,
                encryption_configuration: self.encryption_configuration,
                remove_encryption_configuration: self.remove_encryption_configuration,
                expected_bucket_owner: self.expected_bucket_owner,
                remove_expected_bucket_owner: self.remove_expected_bucket_owner,
                acl_configuration: self.acl_configuration,
                remove_acl_configuration: self.remove_acl_configuration,
            }
        }
    }
}
impl ResultConfigurationUpdates {
    /// Creates a new builder-style object to manufacture [`ResultConfigurationUpdates`](crate::model::ResultConfigurationUpdates)
    pub fn builder() -> crate::model::result_configuration_updates::Builder {
        crate::model::result_configuration_updates::Builder::default()
    }
}

/// <p>Indicates that an Amazon S3 canned ACL should be set to control ownership of stored query results. When Athena stores query results in Amazon S3, the canned ACL is set with the <code>x-amz-acl</code> request header. For more information about S3 Object Ownership, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/about-object-ownership.html#object-ownership-overview">Object Ownership settings</a> in the <i>Amazon S3 User Guide</i>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AclConfiguration {
    /// <p>The Amazon S3 canned ACL that Athena should specify when storing query results. Currently the only supported canned ACL is <code>BUCKET_OWNER_FULL_CONTROL</code>. If a query runs in a workgroup and the workgroup overrides client-side settings, then the Amazon S3 canned ACL specified in the workgroup's settings is used for all queries that run in the workgroup. For more information about Amazon S3 canned ACLs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/acl-overview.html#canned-acl">Canned ACL</a> in the <i>Amazon S3 User Guide</i>.</p>
    pub s3_acl_option: std::option::Option<crate::model::S3AclOption>,
}
impl AclConfiguration {
    /// <p>The Amazon S3 canned ACL that Athena should specify when storing query results. Currently the only supported canned ACL is <code>BUCKET_OWNER_FULL_CONTROL</code>. If a query runs in a workgroup and the workgroup overrides client-side settings, then the Amazon S3 canned ACL specified in the workgroup's settings is used for all queries that run in the workgroup. For more information about Amazon S3 canned ACLs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/acl-overview.html#canned-acl">Canned ACL</a> in the <i>Amazon S3 User Guide</i>.</p>
    pub fn s3_acl_option(&self) -> std::option::Option<&crate::model::S3AclOption> {
        self.s3_acl_option.as_ref()
    }
}
impl std::fmt::Debug for AclConfiguration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AclConfiguration");
        formatter.field("s3_acl_option", &self.s3_acl_option);
        formatter.finish()
    }
}
/// See [`AclConfiguration`](crate::model::AclConfiguration)
pub mod acl_configuration {

    /// A builder for [`AclConfiguration`](crate::model::AclConfiguration)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) s3_acl_option: std::option::Option<crate::model::S3AclOption>,
    }
    impl Builder {
        /// <p>The Amazon S3 canned ACL that Athena should specify when storing query results. Currently the only supported canned ACL is <code>BUCKET_OWNER_FULL_CONTROL</code>. If a query runs in a workgroup and the workgroup overrides client-side settings, then the Amazon S3 canned ACL specified in the workgroup's settings is used for all queries that run in the workgroup. For more information about Amazon S3 canned ACLs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/acl-overview.html#canned-acl">Canned ACL</a> in the <i>Amazon S3 User Guide</i>.</p>
        pub fn s3_acl_option(mut self, input: crate::model::S3AclOption) -> Self {
            self.s3_acl_option = Some(input);
            self
        }
        /// <p>The Amazon S3 canned ACL that Athena should specify when storing query results. Currently the only supported canned ACL is <code>BUCKET_OWNER_FULL_CONTROL</code>. If a query runs in a workgroup and the workgroup overrides client-side settings, then the Amazon S3 canned ACL specified in the workgroup's settings is used for all queries that run in the workgroup. For more information about Amazon S3 canned ACLs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/acl-overview.html#canned-acl">Canned ACL</a> in the <i>Amazon S3 User Guide</i>.</p>
        pub fn set_s3_acl_option(
            mut self,
            input: std::option::Option<crate::model::S3AclOption>,
        ) -> Self {
            self.s3_acl_option = input;
            self
        }
        /// Consumes the builder and constructs a [`AclConfiguration`](crate::model::AclConfiguration)
        pub fn build(self) -> crate::model::AclConfiguration {
            crate::model::AclConfiguration {
                s3_acl_option: self.s3_acl_option,
            }
        }
    }
}
impl AclConfiguration {
    /// Creates a new builder-style object to manufacture [`AclConfiguration`](crate::model::AclConfiguration)
    pub fn builder() -> crate::model::acl_configuration::Builder {
        crate::model::acl_configuration::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum S3AclOption {
    #[allow(missing_docs)] // documentation missing in model
    BucketOwnerFullControl,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for S3AclOption {
    fn from(s: &str) -> Self {
        match s {
            "BUCKET_OWNER_FULL_CONTROL" => S3AclOption::BucketOwnerFullControl,
            other => S3AclOption::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for S3AclOption {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(S3AclOption::from(s))
    }
}
impl S3AclOption {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            S3AclOption::BucketOwnerFullControl => "BUCKET_OWNER_FULL_CONTROL",
            S3AclOption::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["BUCKET_OWNER_FULL_CONTROL"]
    }
}
impl AsRef<str> for S3AclOption {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>If query results are encrypted in Amazon S3, indicates the encryption option used (for example, <code>SSE_KMS</code> or <code>CSE_KMS</code>) and key information.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct EncryptionConfiguration {
    /// <p>Indicates whether Amazon S3 server-side encryption with Amazon S3-managed keys (<code>SSE_S3</code>), server-side encryption with KMS-managed keys (<code>SSE_KMS</code>), or client-side encryption with KMS-managed keys (<code>CSE_KMS</code>) is used.</p>
    /// <p>If a query runs in a workgroup and the workgroup overrides client-side settings, then the workgroup's setting for encryption is used. It specifies whether query results must be encrypted, for all queries that run in this workgroup. </p>
    pub encryption_option: std::option::Option<crate::model::EncryptionOption>,
    /// <p>For <code>SSE_KMS</code> and <code>CSE_KMS</code>, this is the KMS key ARN or ID.</p>
    pub kms_key: std::option::Option<std::string::String>,
}
impl EncryptionConfiguration {
    /// <p>Indicates whether Amazon S3 server-side encryption with Amazon S3-managed keys (<code>SSE_S3</code>), server-side encryption with KMS-managed keys (<code>SSE_KMS</code>), or client-side encryption with KMS-managed keys (<code>CSE_KMS</code>) is used.</p>
    /// <p>If a query runs in a workgroup and the workgroup overrides client-side settings, then the workgroup's setting for encryption is used. It specifies whether query results must be encrypted, for all queries that run in this workgroup. </p>
    pub fn encryption_option(&self) -> std::option::Option<&crate::model::EncryptionOption> {
        self.encryption_option.as_ref()
    }
    /// <p>For <code>SSE_KMS</code> and <code>CSE_KMS</code>, this is the KMS key ARN or ID.</p>
    pub fn kms_key(&self) -> std::option::Option<&str> {
        self.kms_key.as_deref()
    }
}
impl std::fmt::Debug for EncryptionConfiguration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("EncryptionConfiguration");
        formatter.field("encryption_option", &self.encryption_option);
        formatter.field("kms_key", &self.kms_key);
        formatter.finish()
    }
}
/// See [`EncryptionConfiguration`](crate::model::EncryptionConfiguration)
pub mod encryption_configuration {

    /// A builder for [`EncryptionConfiguration`](crate::model::EncryptionConfiguration)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) encryption_option: std::option::Option<crate::model::EncryptionOption>,
        pub(crate) kms_key: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Indicates whether Amazon S3 server-side encryption with Amazon S3-managed keys (<code>SSE_S3</code>), server-side encryption with KMS-managed keys (<code>SSE_KMS</code>), or client-side encryption with KMS-managed keys (<code>CSE_KMS</code>) is used.</p>
        /// <p>If a query runs in a workgroup and the workgroup overrides client-side settings, then the workgroup's setting for encryption is used. It specifies whether query results must be encrypted, for all queries that run in this workgroup. </p>
        pub fn encryption_option(mut self, input: crate::model::EncryptionOption) -> Self {
            self.encryption_option = Some(input);
            self
        }
        /// <p>Indicates whether Amazon S3 server-side encryption with Amazon S3-managed keys (<code>SSE_S3</code>), server-side encryption with KMS-managed keys (<code>SSE_KMS</code>), or client-side encryption with KMS-managed keys (<code>CSE_KMS</code>) is used.</p>
        /// <p>If a query runs in a workgroup and the workgroup overrides client-side settings, then the workgroup's setting for encryption is used. It specifies whether query results must be encrypted, for all queries that run in this workgroup. </p>
        pub fn set_encryption_option(
            mut self,
            input: std::option::Option<crate::model::EncryptionOption>,
        ) -> Self {
            self.encryption_option = input;
            self
        }
        /// <p>For <code>SSE_KMS</code> and <code>CSE_KMS</code>, this is the KMS key ARN or ID.</p>
        pub fn kms_key(mut self, input: impl Into<std::string::String>) -> Self {
            self.kms_key = Some(input.into());
            self
        }
        /// <p>For <code>SSE_KMS</code> and <code>CSE_KMS</code>, this is the KMS key ARN or ID.</p>
        pub fn set_kms_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.kms_key = input;
            self
        }
        /// Consumes the builder and constructs a [`EncryptionConfiguration`](crate::model::EncryptionConfiguration)
        pub fn build(self) -> crate::model::EncryptionConfiguration {
            crate::model::EncryptionConfiguration {
                encryption_option: self.encryption_option,
                kms_key: self.kms_key,
            }
        }
    }
}
impl EncryptionConfiguration {
    /// Creates a new builder-style object to manufacture [`EncryptionConfiguration`](crate::model::EncryptionConfiguration)
    pub fn builder() -> crate::model::encryption_configuration::Builder {
        crate::model::encryption_configuration::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum EncryptionOption {
    #[allow(missing_docs)] // documentation missing in model
    CseKms,
    #[allow(missing_docs)] // documentation missing in model
    SseKms,
    #[allow(missing_docs)] // documentation missing in model
    SseS3,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for EncryptionOption {
    fn from(s: &str) -> Self {
        match s {
            "CSE_KMS" => EncryptionOption::CseKms,
            "SSE_KMS" => EncryptionOption::SseKms,
            "SSE_S3" => EncryptionOption::SseS3,
            other => EncryptionOption::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for EncryptionOption {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(EncryptionOption::from(s))
    }
}
impl EncryptionOption {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            EncryptionOption::CseKms => "CSE_KMS",
            EncryptionOption::SseKms => "SSE_KMS",
            EncryptionOption::SseS3 => "SSE_S3",
            EncryptionOption::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["CSE_KMS", "SSE_KMS", "SSE_S3"]
    }
}
impl AsRef<str> for EncryptionOption {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum DataCatalogType {
    #[allow(missing_docs)] // documentation missing in model
    Glue,
    #[allow(missing_docs)] // documentation missing in model
    Hive,
    #[allow(missing_docs)] // documentation missing in model
    Lambda,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for DataCatalogType {
    fn from(s: &str) -> Self {
        match s {
            "GLUE" => DataCatalogType::Glue,
            "HIVE" => DataCatalogType::Hive,
            "LAMBDA" => DataCatalogType::Lambda,
            other => DataCatalogType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for DataCatalogType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(DataCatalogType::from(s))
    }
}
impl DataCatalogType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            DataCatalogType::Glue => "GLUE",
            DataCatalogType::Hive => "HIVE",
            DataCatalogType::Lambda => "LAMBDA",
            DataCatalogType::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["GLUE", "HIVE", "LAMBDA"]
    }
}
impl AsRef<str> for DataCatalogType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>A label that you assign to a resource. In Athena, a resource can be a workgroup or data catalog. Each tag consists of a key and an optional value, both of which you define. For example, you can use tags to categorize Athena workgroups or data catalogs by purpose, owner, or environment. Use a consistent set of tag keys to make it easier to search and filter workgroups or data catalogs in your account. For best practices, see <a href="https://aws.amazon.com/answers/account-management/aws-tagging-strategies/">Tagging Best Practices</a>. Tag keys can be from 1 to 128 UTF-8 Unicode characters, and tag values can be from 0 to 256 UTF-8 Unicode characters. Tags can use letters and numbers representable in UTF-8, and the following characters: + - = . _ : / @. Tag keys and values are case-sensitive. Tag keys must be unique per resource. If you specify more than one tag, separate them by commas. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Tag {
    /// <p>A tag key. The tag key length is from 1 to 128 Unicode characters in UTF-8. You can use letters and numbers representable in UTF-8, and the following characters: + - = . _ : / @. Tag keys are case-sensitive and must be unique per resource. </p>
    pub key: std::option::Option<std::string::String>,
    /// <p>A tag value. The tag value length is from 0 to 256 Unicode characters in UTF-8. You can use letters and numbers representable in UTF-8, and the following characters: + - = . _ : / @. Tag values are case-sensitive. </p>
    pub value: std::option::Option<std::string::String>,
}
impl Tag {
    /// <p>A tag key. The tag key length is from 1 to 128 Unicode characters in UTF-8. You can use letters and numbers representable in UTF-8, and the following characters: + - = . _ : / @. Tag keys are case-sensitive and must be unique per resource. </p>
    pub fn key(&self) -> std::option::Option<&str> {
        self.key.as_deref()
    }
    /// <p>A tag value. The tag value length is from 0 to 256 Unicode characters in UTF-8. You can use letters and numbers representable in UTF-8, and the following characters: + - = . _ : / @. Tag values are case-sensitive. </p>
    pub fn value(&self) -> std::option::Option<&str> {
        self.value.as_deref()
    }
}
impl std::fmt::Debug for Tag {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Tag");
        formatter.field("key", &self.key);
        formatter.field("value", &self.value);
        formatter.finish()
    }
}
/// See [`Tag`](crate::model::Tag)
pub mod tag {

    /// A builder for [`Tag`](crate::model::Tag)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) key: std::option::Option<std::string::String>,
        pub(crate) value: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>A tag key. The tag key length is from 1 to 128 Unicode characters in UTF-8. You can use letters and numbers representable in UTF-8, and the following characters: + - = . _ : / @. Tag keys are case-sensitive and must be unique per resource. </p>
        pub fn key(mut self, input: impl Into<std::string::String>) -> Self {
            self.key = Some(input.into());
            self
        }
        /// <p>A tag key. The tag key length is from 1 to 128 Unicode characters in UTF-8. You can use letters and numbers representable in UTF-8, and the following characters: + - = . _ : / @. Tag keys are case-sensitive and must be unique per resource. </p>
        pub fn set_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.key = input;
            self
        }
        /// <p>A tag value. The tag value length is from 0 to 256 Unicode characters in UTF-8. You can use letters and numbers representable in UTF-8, and the following characters: + - = . _ : / @. Tag values are case-sensitive. </p>
        pub fn value(mut self, input: impl Into<std::string::String>) -> Self {
            self.value = Some(input.into());
            self
        }
        /// <p>A tag value. The tag value length is from 0 to 256 Unicode characters in UTF-8. You can use letters and numbers representable in UTF-8, and the following characters: + - = . _ : / @. Tag values are case-sensitive. </p>
        pub fn set_value(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.value = input;
            self
        }
        /// Consumes the builder and constructs a [`Tag`](crate::model::Tag)
        pub fn build(self) -> crate::model::Tag {
            crate::model::Tag {
                key: self.key,
                value: self.value,
            }
        }
    }
}
impl Tag {
    /// Creates a new builder-style object to manufacture [`Tag`](crate::model::Tag)
    pub fn builder() -> crate::model::tag::Builder {
        crate::model::tag::Builder::default()
    }
}

/// <p>The reason for the query throttling, for example, when it exceeds the concurrent query
/// limit.</p>
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ThrottleReason {
    #[allow(missing_docs)] // documentation missing in model
    ConcurrentQueryLimitExceeded,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for ThrottleReason {
    fn from(s: &str) -> Self {
        match s {
            "CONCURRENT_QUERY_LIMIT_EXCEEDED" => ThrottleReason::ConcurrentQueryLimitExceeded,
            other => ThrottleReason::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for ThrottleReason {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ThrottleReason::from(s))
    }
}
impl ThrottleReason {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ThrottleReason::ConcurrentQueryLimitExceeded => "CONCURRENT_QUERY_LIMIT_EXCEEDED",
            ThrottleReason::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["CONCURRENT_QUERY_LIMIT_EXCEEDED"]
    }
}
impl AsRef<str> for ThrottleReason {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The location in Amazon S3 where query results are stored and the encryption option, if any, used for query results. These are known as "client-side settings". If workgroup settings override client-side settings, then the query uses the workgroup settings.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ResultConfiguration {
    /// <p>The location in Amazon S3 where your query results are stored, such as <code>s3://path/to/query/bucket/</code>. To run the query, you must specify the query results location using one of the ways: either for individual queries using either this setting (client-side), or in the workgroup, using <code>WorkGroupConfiguration</code>. If none of them is set, Athena issues an error that no output location is provided. For more information, see <a href="https://docs.aws.amazon.com/athena/latest/ug/querying.html">Query Results</a>. If workgroup settings override client-side settings, then the query uses the settings specified for the workgroup. See <code>WorkGroupConfiguration$EnforceWorkGroupConfiguration</code>.</p>
    pub output_location: std::option::Option<std::string::String>,
    /// <p>If query results are encrypted in Amazon S3, indicates the encryption option used (for example, <code>SSE_KMS</code> or <code>CSE_KMS</code>) and key information. This is a client-side setting. If workgroup settings override client-side settings, then the query uses the encryption configuration that is specified for the workgroup, and also uses the location for storing query results specified in the workgroup. See <code>WorkGroupConfiguration$EnforceWorkGroupConfiguration</code> and <a href="https://docs.aws.amazon.com/athena/latest/ug/workgroups-settings-override.html">Workgroup Settings Override Client-Side Settings</a>.</p>
    pub encryption_configuration: std::option::Option<crate::model::EncryptionConfiguration>,
    /// <p>The Amazon Web Services account ID that you expect to be the owner of the Amazon S3 bucket specified by <code>ResultConfiguration$OutputLocation</code>. If set, Athena uses the value for <code>ExpectedBucketOwner</code> when it makes Amazon S3 calls to your specified output location. If the <code>ExpectedBucketOwner</code> Amazon Web Services account ID does not match the actual owner of the Amazon S3 bucket, the call fails with a permissions error.</p>
    /// <p>This is a client-side setting. If workgroup settings override client-side settings, then the query uses the <code>ExpectedBucketOwner</code> setting that is specified for the workgroup, and also uses the location for storing query results specified in the workgroup. See <code>WorkGroupConfiguration$EnforceWorkGroupConfiguration</code> and <a href="https://docs.aws.amazon.com/athena/latest/ug/workgroups-settings-override.html">Workgroup Settings Override Client-Side Settings</a>.</p>
    pub expected_bucket_owner: std::option::Option<std::string::String>,
    /// <p>Indicates that an Amazon S3 canned ACL should be set to control ownership of stored query results. Currently the only supported canned ACL is <code>BUCKET_OWNER_FULL_CONTROL</code>. This is a client-side setting. If workgroup settings override client-side settings, then the query uses the ACL configuration that is specified for the workgroup, and also uses the location for storing query results specified in the workgroup. For more information, see <code>WorkGroupConfiguration$EnforceWorkGroupConfiguration</code> and <a href="https://docs.aws.amazon.com/athena/latest/ug/workgroups-settings-override.html">Workgroup Settings Override Client-Side Settings</a>.</p>
    pub acl_configuration: std::option::Option<crate::model::AclConfiguration>,
}
impl ResultConfiguration {
    /// <p>The location in Amazon S3 where your query results are stored, such as <code>s3://path/to/query/bucket/</code>. To run the query, you must specify the query results location using one of the ways: either for individual queries using either this setting (client-side), or in the workgroup, using <code>WorkGroupConfiguration</code>. If none of them is set, Athena issues an error that no output location is provided. For more information, see <a href="https://docs.aws.amazon.com/athena/latest/ug/querying.html">Query Results</a>. If workgroup settings override client-side settings, then the query uses the settings specified for the workgroup. See <code>WorkGroupConfiguration$EnforceWorkGroupConfiguration</code>.</p>
    pub fn output_location(&self) -> std::option::Option<&str> {
        self.output_location.as_deref()
    }
    /// <p>If query results are encrypted in Amazon S3, indicates the encryption option used (for example, <code>SSE_KMS</code> or <code>CSE_KMS</code>) and key information. This is a client-side setting. If workgroup settings override client-side settings, then the query uses the encryption configuration that is specified for the workgroup, and also uses the location for storing query results specified in the workgroup. See <code>WorkGroupConfiguration$EnforceWorkGroupConfiguration</code> and <a href="https://docs.aws.amazon.com/athena/latest/ug/workgroups-settings-override.html">Workgroup Settings Override Client-Side Settings</a>.</p>
    pub fn encryption_configuration(
        &self,
    ) -> std::option::Option<&crate::model::EncryptionConfiguration> {
        self.encryption_configuration.as_ref()
    }
    /// <p>The Amazon Web Services account ID that you expect to be the owner of the Amazon S3 bucket specified by <code>ResultConfiguration$OutputLocation</code>. If set, Athena uses the value for <code>ExpectedBucketOwner</code> when it makes Amazon S3 calls to your specified output location. If the <code>ExpectedBucketOwner</code> Amazon Web Services account ID does not match the actual owner of the Amazon S3 bucket, the call fails with a permissions error.</p>
    /// <p>This is a client-side setting. If workgroup settings override client-side settings, then the query uses the <code>ExpectedBucketOwner</code> setting that is specified for the workgroup, and also uses the location for storing query results specified in the workgroup. See <code>WorkGroupConfiguration$EnforceWorkGroupConfiguration</code> and <a href="https://docs.aws.amazon.com/athena/latest/ug/workgroups-settings-override.html">Workgroup Settings Override Client-Side Settings</a>.</p>
    pub fn expected_bucket_owner(&self) -> std::option::Option<&str> {
        self.expected_bucket_owner.as_deref()
    }
    /// <p>Indicates that an Amazon S3 canned ACL should be set to control ownership of stored query results. Currently the only supported canned ACL is <code>BUCKET_OWNER_FULL_CONTROL</code>. This is a client-side setting. If workgroup settings override client-side settings, then the query uses the ACL configuration that is specified for the workgroup, and also uses the location for storing query results specified in the workgroup. For more information, see <code>WorkGroupConfiguration$EnforceWorkGroupConfiguration</code> and <a href="https://docs.aws.amazon.com/athena/latest/ug/workgroups-settings-override.html">Workgroup Settings Override Client-Side Settings</a>.</p>
    pub fn acl_configuration(&self) -> std::option::Option<&crate::model::AclConfiguration> {
        self.acl_configuration.as_ref()
    }
}
impl std::fmt::Debug for ResultConfiguration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ResultConfiguration");
        formatter.field("output_location", &self.output_location);
        formatter.field("encryption_configuration", &self.encryption_configuration);
        formatter.field("expected_bucket_owner", &self.expected_bucket_owner);
        formatter.field("acl_configuration", &self.acl_configuration);
        formatter.finish()
    }
}
/// See [`ResultConfiguration`](crate::model::ResultConfiguration)
pub mod result_configuration {

    /// A builder for [`ResultConfiguration`](crate::model::ResultConfiguration)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) output_location: std::option::Option<std::string::String>,
        pub(crate) encryption_configuration:
            std::option::Option<crate::model::EncryptionConfiguration>,
        pub(crate) expected_bucket_owner: std::option::Option<std::string::String>,
        pub(crate) acl_configuration: std::option::Option<crate::model::AclConfiguration>,
    }
    impl Builder {
        /// <p>The location in Amazon S3 where your query results are stored, such as <code>s3://path/to/query/bucket/</code>. To run the query, you must specify the query results location using one of the ways: either for individual queries using either this setting (client-side), or in the workgroup, using <code>WorkGroupConfiguration</code>. If none of them is set, Athena issues an error that no output location is provided. For more information, see <a href="https://docs.aws.amazon.com/athena/latest/ug/querying.html">Query Results</a>. If workgroup settings override client-side settings, then the query uses the settings specified for the workgroup. See <code>WorkGroupConfiguration$EnforceWorkGroupConfiguration</code>.</p>
        pub fn output_location(mut self, input: impl Into<std::string::String>) -> Self {
            self.output_location = Some(input.into());
            self
        }
        /// <p>The location in Amazon S3 where your query results are stored, such as <code>s3://path/to/query/bucket/</code>. To run the query, you must specify the query results location using one of the ways: either for individual queries using either this setting (client-side), or in the workgroup, using <code>WorkGroupConfiguration</code>. If none of them is set, Athena issues an error that no output location is provided. For more information, see <a href="https://docs.aws.amazon.com/athena/latest/ug/querying.html">Query Results</a>. If workgroup settings override client-side settings, then the query uses the settings specified for the workgroup. See <code>WorkGroupConfiguration$EnforceWorkGroupConfiguration</code>.</p>
        pub fn set_output_location(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.output_location = input;
            self
        }
        /// <p>If query results are encrypted in Amazon S3, indicates the encryption option used (for example, <code>SSE_KMS</code> or <code>CSE_KMS</code>) and key information. This is a client-side setting. If workgroup settings override client-side settings, then the query uses the encryption configuration that is specified for the workgroup, and also uses the location for storing query results specified in the workgroup. See <code>WorkGroupConfiguration$EnforceWorkGroupConfiguration</code> and <a href="https://docs.aws.amazon.com/athena/latest/ug/workgroups-settings-override.html">Workgroup Settings Override Client-Side Settings</a>.</p>
        pub fn encryption_configuration(
            mut self,
            input: crate::model::EncryptionConfiguration,
        ) -> Self {
            self.encryption_configuration = Some(input);
            self
        }
        /// <p>If query results are encrypted in Amazon S3, indicates the encryption option used (for example, <code>SSE_KMS</code> or <code>CSE_KMS</code>) and key information. This is a client-side setting. If workgroup settings override client-side settings, then the query uses the encryption configuration that is specified for the workgroup, and also uses the location for storing query results specified in the workgroup. See <code>WorkGroupConfiguration$EnforceWorkGroupConfiguration</code> and <a href="https://docs.aws.amazon.com/athena/latest/ug/workgroups-settings-override.html">Workgroup Settings Override Client-Side Settings</a>.</p>
        pub fn set_encryption_configuration(
            mut self,
            input: std::option::Option<crate::model::EncryptionConfiguration>,
        ) -> Self {
            self.encryption_configuration = input;
            self
        }
        /// <p>The Amazon Web Services account ID that you expect to be the owner of the Amazon S3 bucket specified by <code>ResultConfiguration$OutputLocation</code>. If set, Athena uses the value for <code>ExpectedBucketOwner</code> when it makes Amazon S3 calls to your specified output location. If the <code>ExpectedBucketOwner</code> Amazon Web Services account ID does not match the actual owner of the Amazon S3 bucket, the call fails with a permissions error.</p>
        /// <p>This is a client-side setting. If workgroup settings override client-side settings, then the query uses the <code>ExpectedBucketOwner</code> setting that is specified for the workgroup, and also uses the location for storing query results specified in the workgroup. See <code>WorkGroupConfiguration$EnforceWorkGroupConfiguration</code> and <a href="https://docs.aws.amazon.com/athena/latest/ug/workgroups-settings-override.html">Workgroup Settings Override Client-Side Settings</a>.</p>
        pub fn expected_bucket_owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.expected_bucket_owner = Some(input.into());
            self
        }
        /// <p>The Amazon Web Services account ID that you expect to be the owner of the Amazon S3 bucket specified by <code>ResultConfiguration$OutputLocation</code>. If set, Athena uses the value for <code>ExpectedBucketOwner</code> when it makes Amazon S3 calls to your specified output location. If the <code>ExpectedBucketOwner</code> Amazon Web Services account ID does not match the actual owner of the Amazon S3 bucket, the call fails with a permissions error.</p>
        /// <p>This is a client-side setting. If workgroup settings override client-side settings, then the query uses the <code>ExpectedBucketOwner</code> setting that is specified for the workgroup, and also uses the location for storing query results specified in the workgroup. See <code>WorkGroupConfiguration$EnforceWorkGroupConfiguration</code> and <a href="https://docs.aws.amazon.com/athena/latest/ug/workgroups-settings-override.html">Workgroup Settings Override Client-Side Settings</a>.</p>
        pub fn set_expected_bucket_owner(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.expected_bucket_owner = input;
            self
        }
        /// <p>Indicates that an Amazon S3 canned ACL should be set to control ownership of stored query results. Currently the only supported canned ACL is <code>BUCKET_OWNER_FULL_CONTROL</code>. This is a client-side setting. If workgroup settings override client-side settings, then the query uses the ACL configuration that is specified for the workgroup, and also uses the location for storing query results specified in the workgroup. For more information, see <code>WorkGroupConfiguration$EnforceWorkGroupConfiguration</code> and <a href="https://docs.aws.amazon.com/athena/latest/ug/workgroups-settings-override.html">Workgroup Settings Override Client-Side Settings</a>.</p>
        pub fn acl_configuration(mut self, input: crate::model::AclConfiguration) -> Self {
            self.acl_configuration = Some(input);
            self
        }
        /// <p>Indicates that an Amazon S3 canned ACL should be set to control ownership of stored query results. Currently the only supported canned ACL is <code>BUCKET_OWNER_FULL_CONTROL</code>. This is a client-side setting. If workgroup settings override client-side settings, then the query uses the ACL configuration that is specified for the workgroup, and also uses the location for storing query results specified in the workgroup. For more information, see <code>WorkGroupConfiguration$EnforceWorkGroupConfiguration</code> and <a href="https://docs.aws.amazon.com/athena/latest/ug/workgroups-settings-override.html">Workgroup Settings Override Client-Side Settings</a>.</p>
        pub fn set_acl_configuration(
            mut self,
            input: std::option::Option<crate::model::AclConfiguration>,
        ) -> Self {
            self.acl_configuration = input;
            self
        }
        /// Consumes the builder and constructs a [`ResultConfiguration`](crate::model::ResultConfiguration)
        pub fn build(self) -> crate::model::ResultConfiguration {
            crate::model::ResultConfiguration {
                output_location: self.output_location,
                encryption_configuration: self.encryption_configuration,
                expected_bucket_owner: self.expected_bucket_owner,
                acl_configuration: self.acl_configuration,
            }
        }
    }
}
impl ResultConfiguration {
    /// Creates a new builder-style object to manufacture [`ResultConfiguration`](crate::model::ResultConfiguration)
    pub fn builder() -> crate::model::result_configuration::Builder {
        crate::model::result_configuration::Builder::default()
    }
}

/// <p>The database and data catalog context in which the query execution occurs.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct QueryExecutionContext {
    /// <p>The name of the database used in the query execution. The database must exist in the catalog.</p>
    pub database: std::option::Option<std::string::String>,
    /// <p>The name of the data catalog used in the query execution.</p>
    pub catalog: std::option::Option<std::string::String>,
}
impl QueryExecutionContext {
    /// <p>The name of the database used in the query execution. The database must exist in the catalog.</p>
    pub fn database(&self) -> std::option::Option<&str> {
        self.database.as_deref()
    }
    /// <p>The name of the data catalog used in the query execution.</p>
    pub fn catalog(&self) -> std::option::Option<&str> {
        self.catalog.as_deref()
    }
}
impl std::fmt::Debug for QueryExecutionContext {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("QueryExecutionContext");
        formatter.field("database", &self.database);
        formatter.field("catalog", &self.catalog);
        formatter.finish()
    }
}
/// See [`QueryExecutionContext`](crate::model::QueryExecutionContext)
pub mod query_execution_context {

    /// A builder for [`QueryExecutionContext`](crate::model::QueryExecutionContext)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) database: std::option::Option<std::string::String>,
        pub(crate) catalog: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the database used in the query execution. The database must exist in the catalog.</p>
        pub fn database(mut self, input: impl Into<std::string::String>) -> Self {
            self.database = Some(input.into());
            self
        }
        /// <p>The name of the database used in the query execution. The database must exist in the catalog.</p>
        pub fn set_database(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.database = input;
            self
        }
        /// <p>The name of the data catalog used in the query execution.</p>
        pub fn catalog(mut self, input: impl Into<std::string::String>) -> Self {
            self.catalog = Some(input.into());
            self
        }
        /// <p>The name of the data catalog used in the query execution.</p>
        pub fn set_catalog(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.catalog = input;
            self
        }
        /// Consumes the builder and constructs a [`QueryExecutionContext`](crate::model::QueryExecutionContext)
        pub fn build(self) -> crate::model::QueryExecutionContext {
            crate::model::QueryExecutionContext {
                database: self.database,
                catalog: self.catalog,
            }
        }
    }
}
impl QueryExecutionContext {
    /// Creates a new builder-style object to manufacture [`QueryExecutionContext`](crate::model::QueryExecutionContext)
    pub fn builder() -> crate::model::query_execution_context::Builder {
        crate::model::query_execution_context::Builder::default()
    }
}

/// <p>The summary information for the workgroup, which includes its name, state, description, and the date and time it was created.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct WorkGroupSummary {
    /// <p>The name of the workgroup.</p>
    pub name: std::option::Option<std::string::String>,
    /// <p>The state of the workgroup.</p>
    pub state: std::option::Option<crate::model::WorkGroupState>,
    /// <p>The workgroup description.</p>
    pub description: std::option::Option<std::string::String>,
    /// <p>The workgroup creation date and time.</p>
    pub creation_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The engine version setting for all queries on the workgroup. Queries on the <code>AmazonAthenaPreviewFunctionality</code> workgroup run on the preview engine regardless of this setting.</p>
    pub engine_version: std::option::Option<crate::model::EngineVersion>,
}
impl WorkGroupSummary {
    /// <p>The name of the workgroup.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The state of the workgroup.</p>
    pub fn state(&self) -> std::option::Option<&crate::model::WorkGroupState> {
        self.state.as_ref()
    }
    /// <p>The workgroup description.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>The workgroup creation date and time.</p>
    pub fn creation_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.creation_time.as_ref()
    }
    /// <p>The engine version setting for all queries on the workgroup. Queries on the <code>AmazonAthenaPreviewFunctionality</code> workgroup run on the preview engine regardless of this setting.</p>
    pub fn engine_version(&self) -> std::option::Option<&crate::model::EngineVersion> {
        self.engine_version.as_ref()
    }
}
impl std::fmt::Debug for WorkGroupSummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("WorkGroupSummary");
        formatter.field("name", &self.name);
        formatter.field("state", &self.state);
        formatter.field("description", &self.description);
        formatter.field("creation_time", &self.creation_time);
        formatter.field("engine_version", &self.engine_version);
        formatter.finish()
    }
}
/// See [`WorkGroupSummary`](crate::model::WorkGroupSummary)
pub mod work_group_summary {

    /// A builder for [`WorkGroupSummary`](crate::model::WorkGroupSummary)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) state: std::option::Option<crate::model::WorkGroupState>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) creation_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) engine_version: std::option::Option<crate::model::EngineVersion>,
    }
    impl Builder {
        /// <p>The name of the workgroup.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the workgroup.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The state of the workgroup.</p>
        pub fn state(mut self, input: crate::model::WorkGroupState) -> Self {
            self.state = Some(input);
            self
        }
        /// <p>The state of the workgroup.</p>
        pub fn set_state(
            mut self,
            input: std::option::Option<crate::model::WorkGroupState>,
        ) -> Self {
            self.state = input;
            self
        }
        /// <p>The workgroup description.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>The workgroup description.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>The workgroup creation date and time.</p>
        pub fn creation_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.creation_time = Some(input);
            self
        }
        /// <p>The workgroup creation date and time.</p>
        pub fn set_creation_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.creation_time = input;
            self
        }
        /// <p>The engine version setting for all queries on the workgroup. Queries on the <code>AmazonAthenaPreviewFunctionality</code> workgroup run on the preview engine regardless of this setting.</p>
        pub fn engine_version(mut self, input: crate::model::EngineVersion) -> Self {
            self.engine_version = Some(input);
            self
        }
        /// <p>The engine version setting for all queries on the workgroup. Queries on the <code>AmazonAthenaPreviewFunctionality</code> workgroup run on the preview engine regardless of this setting.</p>
        pub fn set_engine_version(
            mut self,
            input: std::option::Option<crate::model::EngineVersion>,
        ) -> Self {
            self.engine_version = input;
            self
        }
        /// Consumes the builder and constructs a [`WorkGroupSummary`](crate::model::WorkGroupSummary)
        pub fn build(self) -> crate::model::WorkGroupSummary {
            crate::model::WorkGroupSummary {
                name: self.name,
                state: self.state,
                description: self.description,
                creation_time: self.creation_time,
                engine_version: self.engine_version,
            }
        }
    }
}
impl WorkGroupSummary {
    /// Creates a new builder-style object to manufacture [`WorkGroupSummary`](crate::model::WorkGroupSummary)
    pub fn builder() -> crate::model::work_group_summary::Builder {
        crate::model::work_group_summary::Builder::default()
    }
}

/// <p>Contains metadata for a table.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TableMetadata {
    /// <p>The name of the table.</p>
    pub name: std::option::Option<std::string::String>,
    /// <p>The time that the table was created.</p>
    pub create_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The last time the table was accessed.</p>
    pub last_access_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The type of table. In Athena, only <code>EXTERNAL_TABLE</code> is supported.</p>
    pub table_type: std::option::Option<std::string::String>,
    /// <p>A list of the columns in the table.</p>
    pub columns: std::option::Option<std::vec::Vec<crate::model::Column>>,
    /// <p>A list of the partition keys in the table.</p>
    pub partition_keys: std::option::Option<std::vec::Vec<crate::model::Column>>,
    /// <p>A set of custom key/value pairs for table properties.</p>
    pub parameters:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
}
impl TableMetadata {
    /// <p>The name of the table.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The time that the table was created.</p>
    pub fn create_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.create_time.as_ref()
    }
    /// <p>The last time the table was accessed.</p>
    pub fn last_access_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.last_access_time.as_ref()
    }
    /// <p>The type of table. In Athena, only <code>EXTERNAL_TABLE</code> is supported.</p>
    pub fn table_type(&self) -> std::option::Option<&str> {
        self.table_type.as_deref()
    }
    /// <p>A list of the columns in the table.</p>
    pub fn columns(&self) -> std::option::Option<&[crate::model::Column]> {
        self.columns.as_deref()
    }
    /// <p>A list of the partition keys in the table.</p>
    pub fn partition_keys(&self) -> std::option::Option<&[crate::model::Column]> {
        self.partition_keys.as_deref()
    }
    /// <p>A set of custom key/value pairs for table properties.</p>
    pub fn parameters(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.parameters.as_ref()
    }
}
impl std::fmt::Debug for TableMetadata {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TableMetadata");
        formatter.field("name", &self.name);
        formatter.field("create_time", &self.create_time);
        formatter.field("last_access_time", &self.last_access_time);
        formatter.field("table_type", &self.table_type);
        formatter.field("columns", &self.columns);
        formatter.field("partition_keys", &self.partition_keys);
        formatter.field("parameters", &self.parameters);
        formatter.finish()
    }
}
/// See [`TableMetadata`](crate::model::TableMetadata)
pub mod table_metadata {

    /// A builder for [`TableMetadata`](crate::model::TableMetadata)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) create_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) last_access_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) table_type: std::option::Option<std::string::String>,
        pub(crate) columns: std::option::Option<std::vec::Vec<crate::model::Column>>,
        pub(crate) partition_keys: std::option::Option<std::vec::Vec<crate::model::Column>>,
        pub(crate) parameters: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
    }
    impl Builder {
        /// <p>The name of the table.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the table.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The time that the table was created.</p>
        pub fn create_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.create_time = Some(input);
            self
        }
        /// <p>The time that the table was created.</p>
        pub fn set_create_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.create_time = input;
            self
        }
        /// <p>The last time the table was accessed.</p>
        pub fn last_access_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.last_access_time = Some(input);
            self
        }
        /// <p>The last time the table was accessed.</p>
        pub fn set_last_access_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.last_access_time = input;
            self
        }
        /// <p>The type of table. In Athena, only <code>EXTERNAL_TABLE</code> is supported.</p>
        pub fn table_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.table_type = Some(input.into());
            self
        }
        /// <p>The type of table. In Athena, only <code>EXTERNAL_TABLE</code> is supported.</p>
        pub fn set_table_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.table_type = input;
            self
        }
        /// Appends an item to `columns`.
        ///
        /// To override the contents of this collection use [`set_columns`](Self::set_columns).
        ///
        /// <p>A list of the columns in the table.</p>
        pub fn columns(mut self, input: crate::model::Column) -> Self {
            let mut v = self.columns.unwrap_or_default();
            v.push(input);
            self.columns = Some(v);
            self
        }
        /// <p>A list of the columns in the table.</p>
        pub fn set_columns(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Column>>,
        ) -> Self {
            self.columns = input;
            self
        }
        /// Appends an item to `partition_keys`.
        ///
        /// To override the contents of this collection use [`set_partition_keys`](Self::set_partition_keys).
        ///
        /// <p>A list of the partition keys in the table.</p>
        pub fn partition_keys(mut self, input: crate::model::Column) -> Self {
            let mut v = self.partition_keys.unwrap_or_default();
            v.push(input);
            self.partition_keys = Some(v);
            self
        }
        /// <p>A list of the partition keys in the table.</p>
        pub fn set_partition_keys(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Column>>,
        ) -> Self {
            self.partition_keys = input;
            self
        }
        /// Adds a key-value pair to `parameters`.
        ///
        /// To override the contents of this collection use [`set_parameters`](Self::set_parameters).
        ///
        /// <p>A set of custom key/value pairs for table properties.</p>
        pub fn parameters(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.parameters.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.parameters = Some(hash_map);
            self
        }
        /// <p>A set of custom key/value pairs for table properties.</p>
        pub fn set_parameters(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.parameters = input;
            self
        }
        /// Consumes the builder and constructs a [`TableMetadata`](crate::model::TableMetadata)
        pub fn build(self) -> crate::model::TableMetadata {
            crate::model::TableMetadata {
                name: self.name,
                create_time: self.create_time,
                last_access_time: self.last_access_time,
                table_type: self.table_type,
                columns: self.columns,
                partition_keys: self.partition_keys,
                parameters: self.parameters,
            }
        }
    }
}
impl TableMetadata {
    /// Creates a new builder-style object to manufacture [`TableMetadata`](crate::model::TableMetadata)
    pub fn builder() -> crate::model::table_metadata::Builder {
        crate::model::table_metadata::Builder::default()
    }
}

/// <p>Contains metadata for a column in a table.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Column {
    /// <p>The name of the column.</p>
    pub name: std::option::Option<std::string::String>,
    /// <p>The data type of the column.</p>
    pub r#type: std::option::Option<std::string::String>,
    /// <p>Optional information about the column.</p>
    pub comment: std::option::Option<std::string::String>,
}
impl Column {
    /// <p>The name of the column.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The data type of the column.</p>
    pub fn r#type(&self) -> std::option::Option<&str> {
        self.r#type.as_deref()
    }
    /// <p>Optional information about the column.</p>
    pub fn comment(&self) -> std::option::Option<&str> {
        self.comment.as_deref()
    }
}
impl std::fmt::Debug for Column {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Column");
        formatter.field("name", &self.name);
        formatter.field("r#type", &self.r#type);
        formatter.field("comment", &self.comment);
        formatter.finish()
    }
}
/// See [`Column`](crate::model::Column)
pub mod column {

    /// A builder for [`Column`](crate::model::Column)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) r#type: std::option::Option<std::string::String>,
        pub(crate) comment: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the column.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the column.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The data type of the column.</p>
        pub fn r#type(mut self, input: impl Into<std::string::String>) -> Self {
            self.r#type = Some(input.into());
            self
        }
        /// <p>The data type of the column.</p>
        pub fn set_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.r#type = input;
            self
        }
        /// <p>Optional information about the column.</p>
        pub fn comment(mut self, input: impl Into<std::string::String>) -> Self {
            self.comment = Some(input.into());
            self
        }
        /// <p>Optional information about the column.</p>
        pub fn set_comment(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.comment = input;
            self
        }
        /// Consumes the builder and constructs a [`Column`](crate::model::Column)
        pub fn build(self) -> crate::model::Column {
            crate::model::Column {
                name: self.name,
                r#type: self.r#type,
                comment: self.comment,
            }
        }
    }
}
impl Column {
    /// Creates a new builder-style object to manufacture [`Column`](crate::model::Column)
    pub fn builder() -> crate::model::column::Builder {
        crate::model::column::Builder::default()
    }
}

/// <p>The name and last modified time of the prepared statement.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PreparedStatementSummary {
    /// <p>The name of the prepared statement.</p>
    pub statement_name: std::option::Option<std::string::String>,
    /// <p>The last modified time of the prepared statement.</p>
    pub last_modified_time: std::option::Option<aws_smithy_types::DateTime>,
}
impl PreparedStatementSummary {
    /// <p>The name of the prepared statement.</p>
    pub fn statement_name(&self) -> std::option::Option<&str> {
        self.statement_name.as_deref()
    }
    /// <p>The last modified time of the prepared statement.</p>
    pub fn last_modified_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.last_modified_time.as_ref()
    }
}
impl std::fmt::Debug for PreparedStatementSummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PreparedStatementSummary");
        formatter.field("statement_name", &self.statement_name);
        formatter.field("last_modified_time", &self.last_modified_time);
        formatter.finish()
    }
}
/// See [`PreparedStatementSummary`](crate::model::PreparedStatementSummary)
pub mod prepared_statement_summary {

    /// A builder for [`PreparedStatementSummary`](crate::model::PreparedStatementSummary)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) statement_name: std::option::Option<std::string::String>,
        pub(crate) last_modified_time: std::option::Option<aws_smithy_types::DateTime>,
    }
    impl Builder {
        /// <p>The name of the prepared statement.</p>
        pub fn statement_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.statement_name = Some(input.into());
            self
        }
        /// <p>The name of the prepared statement.</p>
        pub fn set_statement_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.statement_name = input;
            self
        }
        /// <p>The last modified time of the prepared statement.</p>
        pub fn last_modified_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.last_modified_time = Some(input);
            self
        }
        /// <p>The last modified time of the prepared statement.</p>
        pub fn set_last_modified_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.last_modified_time = input;
            self
        }
        /// Consumes the builder and constructs a [`PreparedStatementSummary`](crate::model::PreparedStatementSummary)
        pub fn build(self) -> crate::model::PreparedStatementSummary {
            crate::model::PreparedStatementSummary {
                statement_name: self.statement_name,
                last_modified_time: self.last_modified_time,
            }
        }
    }
}
impl PreparedStatementSummary {
    /// Creates a new builder-style object to manufacture [`PreparedStatementSummary`](crate::model::PreparedStatementSummary)
    pub fn builder() -> crate::model::prepared_statement_summary::Builder {
        crate::model::prepared_statement_summary::Builder::default()
    }
}

/// <p>The summary information for the data catalog, which includes its name and type.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DataCatalogSummary {
    /// <p>The name of the data catalog. The catalog name is unique for the Amazon Web Services account and can use a maximum of 127 alphanumeric, underscore, at sign, or hyphen characters. The remainder of the length constraint of 256 is reserved for use by Athena.</p>
    pub catalog_name: std::option::Option<std::string::String>,
    /// <p>The data catalog type.</p>
    pub r#type: std::option::Option<crate::model::DataCatalogType>,
}
impl DataCatalogSummary {
    /// <p>The name of the data catalog. The catalog name is unique for the Amazon Web Services account and can use a maximum of 127 alphanumeric, underscore, at sign, or hyphen characters. The remainder of the length constraint of 256 is reserved for use by Athena.</p>
    pub fn catalog_name(&self) -> std::option::Option<&str> {
        self.catalog_name.as_deref()
    }
    /// <p>The data catalog type.</p>
    pub fn r#type(&self) -> std::option::Option<&crate::model::DataCatalogType> {
        self.r#type.as_ref()
    }
}
impl std::fmt::Debug for DataCatalogSummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DataCatalogSummary");
        formatter.field("catalog_name", &self.catalog_name);
        formatter.field("r#type", &self.r#type);
        formatter.finish()
    }
}
/// See [`DataCatalogSummary`](crate::model::DataCatalogSummary)
pub mod data_catalog_summary {

    /// A builder for [`DataCatalogSummary`](crate::model::DataCatalogSummary)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) catalog_name: std::option::Option<std::string::String>,
        pub(crate) r#type: std::option::Option<crate::model::DataCatalogType>,
    }
    impl Builder {
        /// <p>The name of the data catalog. The catalog name is unique for the Amazon Web Services account and can use a maximum of 127 alphanumeric, underscore, at sign, or hyphen characters. The remainder of the length constraint of 256 is reserved for use by Athena.</p>
        pub fn catalog_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.catalog_name = Some(input.into());
            self
        }
        /// <p>The name of the data catalog. The catalog name is unique for the Amazon Web Services account and can use a maximum of 127 alphanumeric, underscore, at sign, or hyphen characters. The remainder of the length constraint of 256 is reserved for use by Athena.</p>
        pub fn set_catalog_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.catalog_name = input;
            self
        }
        /// <p>The data catalog type.</p>
        pub fn r#type(mut self, input: crate::model::DataCatalogType) -> Self {
            self.r#type = Some(input);
            self
        }
        /// <p>The data catalog type.</p>
        pub fn set_type(
            mut self,
            input: std::option::Option<crate::model::DataCatalogType>,
        ) -> Self {
            self.r#type = input;
            self
        }
        /// Consumes the builder and constructs a [`DataCatalogSummary`](crate::model::DataCatalogSummary)
        pub fn build(self) -> crate::model::DataCatalogSummary {
            crate::model::DataCatalogSummary {
                catalog_name: self.catalog_name,
                r#type: self.r#type,
            }
        }
    }
}
impl DataCatalogSummary {
    /// Creates a new builder-style object to manufacture [`DataCatalogSummary`](crate::model::DataCatalogSummary)
    pub fn builder() -> crate::model::data_catalog_summary::Builder {
        crate::model::data_catalog_summary::Builder::default()
    }
}

/// <p>Contains metadata information for a database in a data catalog.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Database {
    /// <p>The name of the database.</p>
    pub name: std::option::Option<std::string::String>,
    /// <p>An optional description of the database.</p>
    pub description: std::option::Option<std::string::String>,
    /// <p>A set of custom key/value pairs.</p>
    pub parameters:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
}
impl Database {
    /// <p>The name of the database.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>An optional description of the database.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>A set of custom key/value pairs.</p>
    pub fn parameters(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.parameters.as_ref()
    }
}
impl std::fmt::Debug for Database {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Database");
        formatter.field("name", &self.name);
        formatter.field("description", &self.description);
        formatter.field("parameters", &self.parameters);
        formatter.finish()
    }
}
/// See [`Database`](crate::model::Database)
pub mod database {

    /// A builder for [`Database`](crate::model::Database)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) parameters: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
    }
    impl Builder {
        /// <p>The name of the database.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the database.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>An optional description of the database.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>An optional description of the database.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// Adds a key-value pair to `parameters`.
        ///
        /// To override the contents of this collection use [`set_parameters`](Self::set_parameters).
        ///
        /// <p>A set of custom key/value pairs.</p>
        pub fn parameters(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.parameters.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.parameters = Some(hash_map);
            self
        }
        /// <p>A set of custom key/value pairs.</p>
        pub fn set_parameters(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.parameters = input;
            self
        }
        /// Consumes the builder and constructs a [`Database`](crate::model::Database)
        pub fn build(self) -> crate::model::Database {
            crate::model::Database {
                name: self.name,
                description: self.description,
                parameters: self.parameters,
            }
        }
    }
}
impl Database {
    /// Creates a new builder-style object to manufacture [`Database`](crate::model::Database)
    pub fn builder() -> crate::model::database::Builder {
        crate::model::database::Builder::default()
    }
}

/// <p>A workgroup, which contains a name, description, creation time, state, and other configuration, listed under <code>WorkGroup$Configuration</code>. Each workgroup enables you to isolate queries for you or your group of users from other queries in the same account, to configure the query results location and the encryption configuration (known as workgroup settings), to enable sending query metrics to Amazon CloudWatch, and to establish per-query data usage control limits for all queries in a workgroup. The workgroup settings override is specified in <code>EnforceWorkGroupConfiguration</code> (true/false) in the <code>WorkGroupConfiguration</code>. See <code>WorkGroupConfiguration$EnforceWorkGroupConfiguration</code>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct WorkGroup {
    /// <p>The workgroup name.</p>
    pub name: std::option::Option<std::string::String>,
    /// <p>The state of the workgroup: ENABLED or DISABLED.</p>
    pub state: std::option::Option<crate::model::WorkGroupState>,
    /// <p>The configuration of the workgroup, which includes the location in Amazon S3 where query results are stored, the encryption configuration, if any, used for query results; whether the Amazon CloudWatch Metrics are enabled for the workgroup; whether workgroup settings override client-side settings; and the data usage limits for the amount of data scanned per query or per workgroup. The workgroup settings override is specified in <code>EnforceWorkGroupConfiguration</code> (true/false) in the <code>WorkGroupConfiguration</code>. See <code>WorkGroupConfiguration$EnforceWorkGroupConfiguration</code>.</p>
    pub configuration: std::option::Option<crate::model::WorkGroupConfiguration>,
    /// <p>The workgroup description.</p>
    pub description: std::option::Option<std::string::String>,
    /// <p>The date and time the workgroup was created.</p>
    pub creation_time: std::option::Option<aws_smithy_types::DateTime>,
}
impl WorkGroup {
    /// <p>The workgroup name.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The state of the workgroup: ENABLED or DISABLED.</p>
    pub fn state(&self) -> std::option::Option<&crate::model::WorkGroupState> {
        self.state.as_ref()
    }
    /// <p>The configuration of the workgroup, which includes the location in Amazon S3 where query results are stored, the encryption configuration, if any, used for query results; whether the Amazon CloudWatch Metrics are enabled for the workgroup; whether workgroup settings override client-side settings; and the data usage limits for the amount of data scanned per query or per workgroup. The workgroup settings override is specified in <code>EnforceWorkGroupConfiguration</code> (true/false) in the <code>WorkGroupConfiguration</code>. See <code>WorkGroupConfiguration$EnforceWorkGroupConfiguration</code>.</p>
    pub fn configuration(&self) -> std::option::Option<&crate::model::WorkGroupConfiguration> {
        self.configuration.as_ref()
    }
    /// <p>The workgroup description.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>The date and time the workgroup was created.</p>
    pub fn creation_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.creation_time.as_ref()
    }
}
impl std::fmt::Debug for WorkGroup {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("WorkGroup");
        formatter.field("name", &self.name);
        formatter.field("state", &self.state);
        formatter.field("configuration", &self.configuration);
        formatter.field("description", &self.description);
        formatter.field("creation_time", &self.creation_time);
        formatter.finish()
    }
}
/// See [`WorkGroup`](crate::model::WorkGroup)
pub mod work_group {

    /// A builder for [`WorkGroup`](crate::model::WorkGroup)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) state: std::option::Option<crate::model::WorkGroupState>,
        pub(crate) configuration: std::option::Option<crate::model::WorkGroupConfiguration>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) creation_time: std::option::Option<aws_smithy_types::DateTime>,
    }
    impl Builder {
        /// <p>The workgroup name.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The workgroup name.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The state of the workgroup: ENABLED or DISABLED.</p>
        pub fn state(mut self, input: crate::model::WorkGroupState) -> Self {
            self.state = Some(input);
            self
        }
        /// <p>The state of the workgroup: ENABLED or DISABLED.</p>
        pub fn set_state(
            mut self,
            input: std::option::Option<crate::model::WorkGroupState>,
        ) -> Self {
            self.state = input;
            self
        }
        /// <p>The configuration of the workgroup, which includes the location in Amazon S3 where query results are stored, the encryption configuration, if any, used for query results; whether the Amazon CloudWatch Metrics are enabled for the workgroup; whether workgroup settings override client-side settings; and the data usage limits for the amount of data scanned per query or per workgroup. The workgroup settings override is specified in <code>EnforceWorkGroupConfiguration</code> (true/false) in the <code>WorkGroupConfiguration</code>. See <code>WorkGroupConfiguration$EnforceWorkGroupConfiguration</code>.</p>
        pub fn configuration(mut self, input: crate::model::WorkGroupConfiguration) -> Self {
            self.configuration = Some(input);
            self
        }
        /// <p>The configuration of the workgroup, which includes the location in Amazon S3 where query results are stored, the encryption configuration, if any, used for query results; whether the Amazon CloudWatch Metrics are enabled for the workgroup; whether workgroup settings override client-side settings; and the data usage limits for the amount of data scanned per query or per workgroup. The workgroup settings override is specified in <code>EnforceWorkGroupConfiguration</code> (true/false) in the <code>WorkGroupConfiguration</code>. See <code>WorkGroupConfiguration$EnforceWorkGroupConfiguration</code>.</p>
        pub fn set_configuration(
            mut self,
            input: std::option::Option<crate::model::WorkGroupConfiguration>,
        ) -> Self {
            self.configuration = input;
            self
        }
        /// <p>The workgroup description.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>The workgroup description.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>The date and time the workgroup was created.</p>
        pub fn creation_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.creation_time = Some(input);
            self
        }
        /// <p>The date and time the workgroup was created.</p>
        pub fn set_creation_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.creation_time = input;
            self
        }
        /// Consumes the builder and constructs a [`WorkGroup`](crate::model::WorkGroup)
        pub fn build(self) -> crate::model::WorkGroup {
            crate::model::WorkGroup {
                name: self.name,
                state: self.state,
                configuration: self.configuration,
                description: self.description,
                creation_time: self.creation_time,
            }
        }
    }
}
impl WorkGroup {
    /// Creates a new builder-style object to manufacture [`WorkGroup`](crate::model::WorkGroup)
    pub fn builder() -> crate::model::work_group::Builder {
        crate::model::work_group::Builder::default()
    }
}

/// <p>The configuration of the workgroup, which includes the location in Amazon S3 where query results are stored, the encryption option, if any, used for query results, whether the Amazon CloudWatch Metrics are enabled for the workgroup and whether workgroup settings override query settings, and the data usage limits for the amount of data scanned per query or per workgroup. The workgroup settings override is specified in <code>EnforceWorkGroupConfiguration</code> (true/false) in the <code>WorkGroupConfiguration</code>. See <code>WorkGroupConfiguration$EnforceWorkGroupConfiguration</code>. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct WorkGroupConfiguration {
    /// <p>The configuration for the workgroup, which includes the location in Amazon S3 where query results are stored and the encryption option, if any, used for query results. To run the query, you must specify the query results location using one of the ways: either in the workgroup using this setting, or for individual queries (client-side), using <code>ResultConfiguration$OutputLocation</code>. If none of them is set, Athena issues an error that no output location is provided. For more information, see <a href="https://docs.aws.amazon.com/athena/latest/ug/querying.html">Query Results</a>.</p>
    pub result_configuration: std::option::Option<crate::model::ResultConfiguration>,
    /// <p>If set to "true", the settings for the workgroup override client-side settings. If set to "false", client-side settings are used. For more information, see <a href="https://docs.aws.amazon.com/athena/latest/ug/workgroups-settings-override.html">Workgroup Settings Override Client-Side Settings</a>.</p>
    pub enforce_work_group_configuration: std::option::Option<bool>,
    /// <p>Indicates that the Amazon CloudWatch metrics are enabled for the workgroup.</p>
    pub publish_cloud_watch_metrics_enabled: std::option::Option<bool>,
    /// <p>The upper data usage limit (cutoff) for the amount of bytes a single query in a workgroup is allowed to scan.</p>
    pub bytes_scanned_cutoff_per_query: std::option::Option<i64>,
    /// <p>If set to <code>true</code>, allows members assigned to a workgroup to reference Amazon S3 Requester Pays buckets in queries. If set to <code>false</code>, workgroup members cannot query data from Requester Pays buckets, and queries that retrieve data from Requester Pays buckets cause an error. The default is <code>false</code>. For more information about Requester Pays buckets, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/RequesterPaysBuckets.html">Requester Pays Buckets</a> in the <i>Amazon Simple Storage Service Developer Guide</i>.</p>
    pub requester_pays_enabled: std::option::Option<bool>,
    /// <p>The engine version that all queries running on the workgroup use. Queries on the <code>AmazonAthenaPreviewFunctionality</code> workgroup run on the preview engine regardless of this setting.</p>
    pub engine_version: std::option::Option<crate::model::EngineVersion>,
}
impl WorkGroupConfiguration {
    /// <p>The configuration for the workgroup, which includes the location in Amazon S3 where query results are stored and the encryption option, if any, used for query results. To run the query, you must specify the query results location using one of the ways: either in the workgroup using this setting, or for individual queries (client-side), using <code>ResultConfiguration$OutputLocation</code>. If none of them is set, Athena issues an error that no output location is provided. For more information, see <a href="https://docs.aws.amazon.com/athena/latest/ug/querying.html">Query Results</a>.</p>
    pub fn result_configuration(&self) -> std::option::Option<&crate::model::ResultConfiguration> {
        self.result_configuration.as_ref()
    }
    /// <p>If set to "true", the settings for the workgroup override client-side settings. If set to "false", client-side settings are used. For more information, see <a href="https://docs.aws.amazon.com/athena/latest/ug/workgroups-settings-override.html">Workgroup Settings Override Client-Side Settings</a>.</p>
    pub fn enforce_work_group_configuration(&self) -> std::option::Option<bool> {
        self.enforce_work_group_configuration
    }
    /// <p>Indicates that the Amazon CloudWatch metrics are enabled for the workgroup.</p>
    pub fn publish_cloud_watch_metrics_enabled(&self) -> std::option::Option<bool> {
        self.publish_cloud_watch_metrics_enabled
    }
    /// <p>The upper data usage limit (cutoff) for the amount of bytes a single query in a workgroup is allowed to scan.</p>
    pub fn bytes_scanned_cutoff_per_query(&self) -> std::option::Option<i64> {
        self.bytes_scanned_cutoff_per_query
    }
    /// <p>If set to <code>true</code>, allows members assigned to a workgroup to reference Amazon S3 Requester Pays buckets in queries. If set to <code>false</code>, workgroup members cannot query data from Requester Pays buckets, and queries that retrieve data from Requester Pays buckets cause an error. The default is <code>false</code>. For more information about Requester Pays buckets, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/RequesterPaysBuckets.html">Requester Pays Buckets</a> in the <i>Amazon Simple Storage Service Developer Guide</i>.</p>
    pub fn requester_pays_enabled(&self) -> std::option::Option<bool> {
        self.requester_pays_enabled
    }
    /// <p>The engine version that all queries running on the workgroup use. Queries on the <code>AmazonAthenaPreviewFunctionality</code> workgroup run on the preview engine regardless of this setting.</p>
    pub fn engine_version(&self) -> std::option::Option<&crate::model::EngineVersion> {
        self.engine_version.as_ref()
    }
}
impl std::fmt::Debug for WorkGroupConfiguration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("WorkGroupConfiguration");
        formatter.field("result_configuration", &self.result_configuration);
        formatter.field(
            "enforce_work_group_configuration",
            &self.enforce_work_group_configuration,
        );
        formatter.field(
            "publish_cloud_watch_metrics_enabled",
            &self.publish_cloud_watch_metrics_enabled,
        );
        formatter.field(
            "bytes_scanned_cutoff_per_query",
            &self.bytes_scanned_cutoff_per_query,
        );
        formatter.field("requester_pays_enabled", &self.requester_pays_enabled);
        formatter.field("engine_version", &self.engine_version);
        formatter.finish()
    }
}
/// See [`WorkGroupConfiguration`](crate::model::WorkGroupConfiguration)
pub mod work_group_configuration {

    /// A builder for [`WorkGroupConfiguration`](crate::model::WorkGroupConfiguration)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) result_configuration: std::option::Option<crate::model::ResultConfiguration>,
        pub(crate) enforce_work_group_configuration: std::option::Option<bool>,
        pub(crate) publish_cloud_watch_metrics_enabled: std::option::Option<bool>,
        pub(crate) bytes_scanned_cutoff_per_query: std::option::Option<i64>,
        pub(crate) requester_pays_enabled: std::option::Option<bool>,
        pub(crate) engine_version: std::option::Option<crate::model::EngineVersion>,
    }
    impl Builder {
        /// <p>The configuration for the workgroup, which includes the location in Amazon S3 where query results are stored and the encryption option, if any, used for query results. To run the query, you must specify the query results location using one of the ways: either in the workgroup using this setting, or for individual queries (client-side), using <code>ResultConfiguration$OutputLocation</code>. If none of them is set, Athena issues an error that no output location is provided. For more information, see <a href="https://docs.aws.amazon.com/athena/latest/ug/querying.html">Query Results</a>.</p>
        pub fn result_configuration(mut self, input: crate::model::ResultConfiguration) -> Self {
            self.result_configuration = Some(input);
            self
        }
        /// <p>The configuration for the workgroup, which includes the location in Amazon S3 where query results are stored and the encryption option, if any, used for query results. To run the query, you must specify the query results location using one of the ways: either in the workgroup using this setting, or for individual queries (client-side), using <code>ResultConfiguration$OutputLocation</code>. If none of them is set, Athena issues an error that no output location is provided. For more information, see <a href="https://docs.aws.amazon.com/athena/latest/ug/querying.html">Query Results</a>.</p>
        pub fn set_result_configuration(
            mut self,
            input: std::option::Option<crate::model::ResultConfiguration>,
        ) -> Self {
            self.result_configuration = input;
            self
        }
        /// <p>If set to "true", the settings for the workgroup override client-side settings. If set to "false", client-side settings are used. For more information, see <a href="https://docs.aws.amazon.com/athena/latest/ug/workgroups-settings-override.html">Workgroup Settings Override Client-Side Settings</a>.</p>
        pub fn enforce_work_group_configuration(mut self, input: bool) -> Self {
            self.enforce_work_group_configuration = Some(input);
            self
        }
        /// <p>If set to "true", the settings for the workgroup override client-side settings. If set to "false", client-side settings are used. For more information, see <a href="https://docs.aws.amazon.com/athena/latest/ug/workgroups-settings-override.html">Workgroup Settings Override Client-Side Settings</a>.</p>
        pub fn set_enforce_work_group_configuration(
            mut self,
            input: std::option::Option<bool>,
        ) -> Self {
            self.enforce_work_group_configuration = input;
            self
        }
        /// <p>Indicates that the Amazon CloudWatch metrics are enabled for the workgroup.</p>
        pub fn publish_cloud_watch_metrics_enabled(mut self, input: bool) -> Self {
            self.publish_cloud_watch_metrics_enabled = Some(input);
            self
        }
        /// <p>Indicates that the Amazon CloudWatch metrics are enabled for the workgroup.</p>
        pub fn set_publish_cloud_watch_metrics_enabled(
            mut self,
            input: std::option::Option<bool>,
        ) -> Self {
            self.publish_cloud_watch_metrics_enabled = input;
            self
        }
        /// <p>The upper data usage limit (cutoff) for the amount of bytes a single query in a workgroup is allowed to scan.</p>
        pub fn bytes_scanned_cutoff_per_query(mut self, input: i64) -> Self {
            self.bytes_scanned_cutoff_per_query = Some(input);
            self
        }
        /// <p>The upper data usage limit (cutoff) for the amount of bytes a single query in a workgroup is allowed to scan.</p>
        pub fn set_bytes_scanned_cutoff_per_query(
            mut self,
            input: std::option::Option<i64>,
        ) -> Self {
            self.bytes_scanned_cutoff_per_query = input;
            self
        }
        /// <p>If set to <code>true</code>, allows members assigned to a workgroup to reference Amazon S3 Requester Pays buckets in queries. If set to <code>false</code>, workgroup members cannot query data from Requester Pays buckets, and queries that retrieve data from Requester Pays buckets cause an error. The default is <code>false</code>. For more information about Requester Pays buckets, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/RequesterPaysBuckets.html">Requester Pays Buckets</a> in the <i>Amazon Simple Storage Service Developer Guide</i>.</p>
        pub fn requester_pays_enabled(mut self, input: bool) -> Self {
            self.requester_pays_enabled = Some(input);
            self
        }
        /// <p>If set to <code>true</code>, allows members assigned to a workgroup to reference Amazon S3 Requester Pays buckets in queries. If set to <code>false</code>, workgroup members cannot query data from Requester Pays buckets, and queries that retrieve data from Requester Pays buckets cause an error. The default is <code>false</code>. For more information about Requester Pays buckets, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/RequesterPaysBuckets.html">Requester Pays Buckets</a> in the <i>Amazon Simple Storage Service Developer Guide</i>.</p>
        pub fn set_requester_pays_enabled(mut self, input: std::option::Option<bool>) -> Self {
            self.requester_pays_enabled = input;
            self
        }
        /// <p>The engine version that all queries running on the workgroup use. Queries on the <code>AmazonAthenaPreviewFunctionality</code> workgroup run on the preview engine regardless of this setting.</p>
        pub fn engine_version(mut self, input: crate::model::EngineVersion) -> Self {
            self.engine_version = Some(input);
            self
        }
        /// <p>The engine version that all queries running on the workgroup use. Queries on the <code>AmazonAthenaPreviewFunctionality</code> workgroup run on the preview engine regardless of this setting.</p>
        pub fn set_engine_version(
            mut self,
            input: std::option::Option<crate::model::EngineVersion>,
        ) -> Self {
            self.engine_version = input;
            self
        }
        /// Consumes the builder and constructs a [`WorkGroupConfiguration`](crate::model::WorkGroupConfiguration)
        pub fn build(self) -> crate::model::WorkGroupConfiguration {
            crate::model::WorkGroupConfiguration {
                result_configuration: self.result_configuration,
                enforce_work_group_configuration: self.enforce_work_group_configuration,
                publish_cloud_watch_metrics_enabled: self.publish_cloud_watch_metrics_enabled,
                bytes_scanned_cutoff_per_query: self.bytes_scanned_cutoff_per_query,
                requester_pays_enabled: self.requester_pays_enabled,
                engine_version: self.engine_version,
            }
        }
    }
}
impl WorkGroupConfiguration {
    /// Creates a new builder-style object to manufacture [`WorkGroupConfiguration`](crate::model::WorkGroupConfiguration)
    pub fn builder() -> crate::model::work_group_configuration::Builder {
        crate::model::work_group_configuration::Builder::default()
    }
}

/// <p>The metadata and rows that make up a query result set. The metadata describes the column structure and data types. To return a <code>ResultSet</code> object, use <code>GetQueryResults</code>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ResultSet {
    /// <p>The rows in the table.</p>
    pub rows: std::option::Option<std::vec::Vec<crate::model::Row>>,
    /// <p>The metadata that describes the column structure and data types of a table of query results.</p>
    pub result_set_metadata: std::option::Option<crate::model::ResultSetMetadata>,
}
impl ResultSet {
    /// <p>The rows in the table.</p>
    pub fn rows(&self) -> std::option::Option<&[crate::model::Row]> {
        self.rows.as_deref()
    }
    /// <p>The metadata that describes the column structure and data types of a table of query results.</p>
    pub fn result_set_metadata(&self) -> std::option::Option<&crate::model::ResultSetMetadata> {
        self.result_set_metadata.as_ref()
    }
}
impl std::fmt::Debug for ResultSet {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ResultSet");
        formatter.field("rows", &self.rows);
        formatter.field("result_set_metadata", &self.result_set_metadata);
        formatter.finish()
    }
}
/// See [`ResultSet`](crate::model::ResultSet)
pub mod result_set {

    /// A builder for [`ResultSet`](crate::model::ResultSet)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) rows: std::option::Option<std::vec::Vec<crate::model::Row>>,
        pub(crate) result_set_metadata: std::option::Option<crate::model::ResultSetMetadata>,
    }
    impl Builder {
        /// Appends an item to `rows`.
        ///
        /// To override the contents of this collection use [`set_rows`](Self::set_rows).
        ///
        /// <p>The rows in the table.</p>
        pub fn rows(mut self, input: crate::model::Row) -> Self {
            let mut v = self.rows.unwrap_or_default();
            v.push(input);
            self.rows = Some(v);
            self
        }
        /// <p>The rows in the table.</p>
        pub fn set_rows(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Row>>,
        ) -> Self {
            self.rows = input;
            self
        }
        /// <p>The metadata that describes the column structure and data types of a table of query results.</p>
        pub fn result_set_metadata(mut self, input: crate::model::ResultSetMetadata) -> Self {
            self.result_set_metadata = Some(input);
            self
        }
        /// <p>The metadata that describes the column structure and data types of a table of query results.</p>
        pub fn set_result_set_metadata(
            mut self,
            input: std::option::Option<crate::model::ResultSetMetadata>,
        ) -> Self {
            self.result_set_metadata = input;
            self
        }
        /// Consumes the builder and constructs a [`ResultSet`](crate::model::ResultSet)
        pub fn build(self) -> crate::model::ResultSet {
            crate::model::ResultSet {
                rows: self.rows,
                result_set_metadata: self.result_set_metadata,
            }
        }
    }
}
impl ResultSet {
    /// Creates a new builder-style object to manufacture [`ResultSet`](crate::model::ResultSet)
    pub fn builder() -> crate::model::result_set::Builder {
        crate::model::result_set::Builder::default()
    }
}

/// <p>The metadata that describes the column structure and data types of a table of query results. To return a <code>ResultSetMetadata</code> object, use <code>GetQueryResults</code>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ResultSetMetadata {
    /// <p>Information about the columns returned in a query result metadata.</p>
    pub column_info: std::option::Option<std::vec::Vec<crate::model::ColumnInfo>>,
}
impl ResultSetMetadata {
    /// <p>Information about the columns returned in a query result metadata.</p>
    pub fn column_info(&self) -> std::option::Option<&[crate::model::ColumnInfo]> {
        self.column_info.as_deref()
    }
}
impl std::fmt::Debug for ResultSetMetadata {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ResultSetMetadata");
        formatter.field("column_info", &self.column_info);
        formatter.finish()
    }
}
/// See [`ResultSetMetadata`](crate::model::ResultSetMetadata)
pub mod result_set_metadata {

    /// A builder for [`ResultSetMetadata`](crate::model::ResultSetMetadata)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) column_info: std::option::Option<std::vec::Vec<crate::model::ColumnInfo>>,
    }
    impl Builder {
        /// Appends an item to `column_info`.
        ///
        /// To override the contents of this collection use [`set_column_info`](Self::set_column_info).
        ///
        /// <p>Information about the columns returned in a query result metadata.</p>
        pub fn column_info(mut self, input: crate::model::ColumnInfo) -> Self {
            let mut v = self.column_info.unwrap_or_default();
            v.push(input);
            self.column_info = Some(v);
            self
        }
        /// <p>Information about the columns returned in a query result metadata.</p>
        pub fn set_column_info(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ColumnInfo>>,
        ) -> Self {
            self.column_info = input;
            self
        }
        /// Consumes the builder and constructs a [`ResultSetMetadata`](crate::model::ResultSetMetadata)
        pub fn build(self) -> crate::model::ResultSetMetadata {
            crate::model::ResultSetMetadata {
                column_info: self.column_info,
            }
        }
    }
}
impl ResultSetMetadata {
    /// Creates a new builder-style object to manufacture [`ResultSetMetadata`](crate::model::ResultSetMetadata)
    pub fn builder() -> crate::model::result_set_metadata::Builder {
        crate::model::result_set_metadata::Builder::default()
    }
}

/// <p>Information about the columns in a query execution result.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ColumnInfo {
    /// <p>The catalog to which the query results belong.</p>
    pub catalog_name: std::option::Option<std::string::String>,
    /// <p>The schema name (database name) to which the query results belong.</p>
    pub schema_name: std::option::Option<std::string::String>,
    /// <p>The table name for the query results.</p>
    pub table_name: std::option::Option<std::string::String>,
    /// <p>The name of the column.</p>
    pub name: std::option::Option<std::string::String>,
    /// <p>A column label.</p>
    pub label: std::option::Option<std::string::String>,
    /// <p>The data type of the column.</p>
    pub r#type: std::option::Option<std::string::String>,
    /// <p>For <code>DECIMAL</code> data types, specifies the total number of digits, up to 38. For performance reasons, we recommend up to 18 digits.</p>
    pub precision: i32,
    /// <p>For <code>DECIMAL</code> data types, specifies the total number of digits in the fractional part of the value. Defaults to 0.</p>
    pub scale: i32,
    /// <p>Indicates the column's nullable status.</p>
    pub nullable: std::option::Option<crate::model::ColumnNullable>,
    /// <p>Indicates whether values in the column are case-sensitive.</p>
    pub case_sensitive: bool,
}
impl ColumnInfo {
    /// <p>The catalog to which the query results belong.</p>
    pub fn catalog_name(&self) -> std::option::Option<&str> {
        self.catalog_name.as_deref()
    }
    /// <p>The schema name (database name) to which the query results belong.</p>
    pub fn schema_name(&self) -> std::option::Option<&str> {
        self.schema_name.as_deref()
    }
    /// <p>The table name for the query results.</p>
    pub fn table_name(&self) -> std::option::Option<&str> {
        self.table_name.as_deref()
    }
    /// <p>The name of the column.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>A column label.</p>
    pub fn label(&self) -> std::option::Option<&str> {
        self.label.as_deref()
    }
    /// <p>The data type of the column.</p>
    pub fn r#type(&self) -> std::option::Option<&str> {
        self.r#type.as_deref()
    }
    /// <p>For <code>DECIMAL</code> data types, specifies the total number of digits, up to 38. For performance reasons, we recommend up to 18 digits.</p>
    pub fn precision(&self) -> i32 {
        self.precision
    }
    /// <p>For <code>DECIMAL</code> data types, specifies the total number of digits in the fractional part of the value. Defaults to 0.</p>
    pub fn scale(&self) -> i32 {
        self.scale
    }
    /// <p>Indicates the column's nullable status.</p>
    pub fn nullable(&self) -> std::option::Option<&crate::model::ColumnNullable> {
        self.nullable.as_ref()
    }
    /// <p>Indicates whether values in the column are case-sensitive.</p>
    pub fn case_sensitive(&self) -> bool {
        self.case_sensitive
    }
}
impl std::fmt::Debug for ColumnInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ColumnInfo");
        formatter.field("catalog_name", &self.catalog_name);
        formatter.field("schema_name", &self.schema_name);
        formatter.field("table_name", &self.table_name);
        formatter.field("name", &self.name);
        formatter.field("label", &self.label);
        formatter.field("r#type", &self.r#type);
        formatter.field("precision", &self.precision);
        formatter.field("scale", &self.scale);
        formatter.field("nullable", &self.nullable);
        formatter.field("case_sensitive", &self.case_sensitive);
        formatter.finish()
    }
}
/// See [`ColumnInfo`](crate::model::ColumnInfo)
pub mod column_info {

    /// A builder for [`ColumnInfo`](crate::model::ColumnInfo)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) catalog_name: std::option::Option<std::string::String>,
        pub(crate) schema_name: std::option::Option<std::string::String>,
        pub(crate) table_name: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) label: std::option::Option<std::string::String>,
        pub(crate) r#type: std::option::Option<std::string::String>,
        pub(crate) precision: std::option::Option<i32>,
        pub(crate) scale: std::option::Option<i32>,
        pub(crate) nullable: std::option::Option<crate::model::ColumnNullable>,
        pub(crate) case_sensitive: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>The catalog to which the query results belong.</p>
        pub fn catalog_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.catalog_name = Some(input.into());
            self
        }
        /// <p>The catalog to which the query results belong.</p>
        pub fn set_catalog_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.catalog_name = input;
            self
        }
        /// <p>The schema name (database name) to which the query results belong.</p>
        pub fn schema_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.schema_name = Some(input.into());
            self
        }
        /// <p>The schema name (database name) to which the query results belong.</p>
        pub fn set_schema_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.schema_name = input;
            self
        }
        /// <p>The table name for the query results.</p>
        pub fn table_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.table_name = Some(input.into());
            self
        }
        /// <p>The table name for the query results.</p>
        pub fn set_table_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.table_name = input;
            self
        }
        /// <p>The name of the column.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the column.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>A column label.</p>
        pub fn label(mut self, input: impl Into<std::string::String>) -> Self {
            self.label = Some(input.into());
            self
        }
        /// <p>A column label.</p>
        pub fn set_label(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.label = input;
            self
        }
        /// <p>The data type of the column.</p>
        pub fn r#type(mut self, input: impl Into<std::string::String>) -> Self {
            self.r#type = Some(input.into());
            self
        }
        /// <p>The data type of the column.</p>
        pub fn set_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.r#type = input;
            self
        }
        /// <p>For <code>DECIMAL</code> data types, specifies the total number of digits, up to 38. For performance reasons, we recommend up to 18 digits.</p>
        pub fn precision(mut self, input: i32) -> Self {
            self.precision = Some(input);
            self
        }
        /// <p>For <code>DECIMAL</code> data types, specifies the total number of digits, up to 38. For performance reasons, we recommend up to 18 digits.</p>
        pub fn set_precision(mut self, input: std::option::Option<i32>) -> Self {
            self.precision = input;
            self
        }
        /// <p>For <code>DECIMAL</code> data types, specifies the total number of digits in the fractional part of the value. Defaults to 0.</p>
        pub fn scale(mut self, input: i32) -> Self {
            self.scale = Some(input);
            self
        }
        /// <p>For <code>DECIMAL</code> data types, specifies the total number of digits in the fractional part of the value. Defaults to 0.</p>
        pub fn set_scale(mut self, input: std::option::Option<i32>) -> Self {
            self.scale = input;
            self
        }
        /// <p>Indicates the column's nullable status.</p>
        pub fn nullable(mut self, input: crate::model::ColumnNullable) -> Self {
            self.nullable = Some(input);
            self
        }
        /// <p>Indicates the column's nullable status.</p>
        pub fn set_nullable(
            mut self,
            input: std::option::Option<crate::model::ColumnNullable>,
        ) -> Self {
            self.nullable = input;
            self
        }
        /// <p>Indicates whether values in the column are case-sensitive.</p>
        pub fn case_sensitive(mut self, input: bool) -> Self {
            self.case_sensitive = Some(input);
            self
        }
        /// <p>Indicates whether values in the column are case-sensitive.</p>
        pub fn set_case_sensitive(mut self, input: std::option::Option<bool>) -> Self {
            self.case_sensitive = input;
            self
        }
        /// Consumes the builder and constructs a [`ColumnInfo`](crate::model::ColumnInfo)
        pub fn build(self) -> crate::model::ColumnInfo {
            crate::model::ColumnInfo {
                catalog_name: self.catalog_name,
                schema_name: self.schema_name,
                table_name: self.table_name,
                name: self.name,
                label: self.label,
                r#type: self.r#type,
                precision: self.precision.unwrap_or_default(),
                scale: self.scale.unwrap_or_default(),
                nullable: self.nullable,
                case_sensitive: self.case_sensitive.unwrap_or_default(),
            }
        }
    }
}
impl ColumnInfo {
    /// Creates a new builder-style object to manufacture [`ColumnInfo`](crate::model::ColumnInfo)
    pub fn builder() -> crate::model::column_info::Builder {
        crate::model::column_info::Builder::default()
    }
}

/// _Note: `ColumnNullable::Unknown` has been renamed to `::UnknownValue`._
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ColumnNullable {
    #[allow(missing_docs)] // documentation missing in model
    NotNull,
    #[allow(missing_docs)] // documentation missing in model
    Nullable,
    /// _Note: `::Unknown` has been renamed to `::UnknownValue`._
    UnknownValue,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for ColumnNullable {
    fn from(s: &str) -> Self {
        match s {
            "NOT_NULL" => ColumnNullable::NotNull,
            "NULLABLE" => ColumnNullable::Nullable,
            "UNKNOWN" => ColumnNullable::UnknownValue,
            other => ColumnNullable::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for ColumnNullable {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ColumnNullable::from(s))
    }
}
impl ColumnNullable {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ColumnNullable::NotNull => "NOT_NULL",
            ColumnNullable::Nullable => "NULLABLE",
            ColumnNullable::UnknownValue => "UNKNOWN",
            ColumnNullable::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["NOT_NULL", "NULLABLE", "UNKNOWN"]
    }
}
impl AsRef<str> for ColumnNullable {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The rows that make up a query result table.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Row {
    /// <p>The data that populates a row in a query result table.</p>
    pub data: std::option::Option<std::vec::Vec<crate::model::Datum>>,
}
impl Row {
    /// <p>The data that populates a row in a query result table.</p>
    pub fn data(&self) -> std::option::Option<&[crate::model::Datum]> {
        self.data.as_deref()
    }
}
impl std::fmt::Debug for Row {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Row");
        formatter.field("data", &self.data);
        formatter.finish()
    }
}
/// See [`Row`](crate::model::Row)
pub mod row {

    /// A builder for [`Row`](crate::model::Row)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) data: std::option::Option<std::vec::Vec<crate::model::Datum>>,
    }
    impl Builder {
        /// Appends an item to `data`.
        ///
        /// To override the contents of this collection use [`set_data`](Self::set_data).
        ///
        /// <p>The data that populates a row in a query result table.</p>
        pub fn data(mut self, input: crate::model::Datum) -> Self {
            let mut v = self.data.unwrap_or_default();
            v.push(input);
            self.data = Some(v);
            self
        }
        /// <p>The data that populates a row in a query result table.</p>
        pub fn set_data(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Datum>>,
        ) -> Self {
            self.data = input;
            self
        }
        /// Consumes the builder and constructs a [`Row`](crate::model::Row)
        pub fn build(self) -> crate::model::Row {
            crate::model::Row { data: self.data }
        }
    }
}
impl Row {
    /// Creates a new builder-style object to manufacture [`Row`](crate::model::Row)
    pub fn builder() -> crate::model::row::Builder {
        crate::model::row::Builder::default()
    }
}

/// <p>A piece of data (a field in the table).</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Datum {
    /// <p>The value of the datum.</p>
    pub var_char_value: std::option::Option<std::string::String>,
}
impl Datum {
    /// <p>The value of the datum.</p>
    pub fn var_char_value(&self) -> std::option::Option<&str> {
        self.var_char_value.as_deref()
    }
}
impl std::fmt::Debug for Datum {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Datum");
        formatter.field("var_char_value", &self.var_char_value);
        formatter.finish()
    }
}
/// See [`Datum`](crate::model::Datum)
pub mod datum {

    /// A builder for [`Datum`](crate::model::Datum)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) var_char_value: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The value of the datum.</p>
        pub fn var_char_value(mut self, input: impl Into<std::string::String>) -> Self {
            self.var_char_value = Some(input.into());
            self
        }
        /// <p>The value of the datum.</p>
        pub fn set_var_char_value(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.var_char_value = input;
            self
        }
        /// Consumes the builder and constructs a [`Datum`](crate::model::Datum)
        pub fn build(self) -> crate::model::Datum {
            crate::model::Datum {
                var_char_value: self.var_char_value,
            }
        }
    }
}
impl Datum {
    /// Creates a new builder-style object to manufacture [`Datum`](crate::model::Datum)
    pub fn builder() -> crate::model::datum::Builder {
        crate::model::datum::Builder::default()
    }
}

/// <p>Information about a single instance of a query execution.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct QueryExecution {
    /// <p>The unique identifier for each query execution.</p>
    pub query_execution_id: std::option::Option<std::string::String>,
    /// <p>The SQL query statements which the query execution ran.</p>
    pub query: std::option::Option<std::string::String>,
    /// <p>The type of query statement that was run. <code>DDL</code> indicates DDL query statements. <code>DML</code> indicates DML (Data Manipulation Language) query statements, such as <code>CREATE TABLE AS SELECT</code>. <code>UTILITY</code> indicates query statements other than DDL and DML, such as <code>SHOW CREATE TABLE</code>, or <code>DESCRIBE TABLE</code>.</p>
    pub statement_type: std::option::Option<crate::model::StatementType>,
    /// <p>The location in Amazon S3 where query results were stored and the encryption option, if any, used for query results. These are known as "client-side settings". If workgroup settings override client-side settings, then the query uses the location for the query results and the encryption configuration that are specified for the workgroup.</p>
    pub result_configuration: std::option::Option<crate::model::ResultConfiguration>,
    /// <p>The database in which the query execution occurred.</p>
    pub query_execution_context: std::option::Option<crate::model::QueryExecutionContext>,
    /// <p>The completion date, current state, submission time, and state change reason (if applicable) for the query execution.</p>
    pub status: std::option::Option<crate::model::QueryExecutionStatus>,
    /// <p>Query execution statistics, such as the amount of data scanned, the amount of time that the query took to process, and the type of statement that was run.</p>
    pub statistics: std::option::Option<crate::model::QueryExecutionStatistics>,
    /// <p>The name of the workgroup in which the query ran.</p>
    pub work_group: std::option::Option<std::string::String>,
    /// <p>The engine version that executed the query.</p>
    pub engine_version: std::option::Option<crate::model::EngineVersion>,
}
impl QueryExecution {
    /// <p>The unique identifier for each query execution.</p>
    pub fn query_execution_id(&self) -> std::option::Option<&str> {
        self.query_execution_id.as_deref()
    }
    /// <p>The SQL query statements which the query execution ran.</p>
    pub fn query(&self) -> std::option::Option<&str> {
        self.query.as_deref()
    }
    /// <p>The type of query statement that was run. <code>DDL</code> indicates DDL query statements. <code>DML</code> indicates DML (Data Manipulation Language) query statements, such as <code>CREATE TABLE AS SELECT</code>. <code>UTILITY</code> indicates query statements other than DDL and DML, such as <code>SHOW CREATE TABLE</code>, or <code>DESCRIBE TABLE</code>.</p>
    pub fn statement_type(&self) -> std::option::Option<&crate::model::StatementType> {
        self.statement_type.as_ref()
    }
    /// <p>The location in Amazon S3 where query results were stored and the encryption option, if any, used for query results. These are known as "client-side settings". If workgroup settings override client-side settings, then the query uses the location for the query results and the encryption configuration that are specified for the workgroup.</p>
    pub fn result_configuration(&self) -> std::option::Option<&crate::model::ResultConfiguration> {
        self.result_configuration.as_ref()
    }
    /// <p>The database in which the query execution occurred.</p>
    pub fn query_execution_context(
        &self,
    ) -> std::option::Option<&crate::model::QueryExecutionContext> {
        self.query_execution_context.as_ref()
    }
    /// <p>The completion date, current state, submission time, and state change reason (if applicable) for the query execution.</p>
    pub fn status(&self) -> std::option::Option<&crate::model::QueryExecutionStatus> {
        self.status.as_ref()
    }
    /// <p>Query execution statistics, such as the amount of data scanned, the amount of time that the query took to process, and the type of statement that was run.</p>
    pub fn statistics(&self) -> std::option::Option<&crate::model::QueryExecutionStatistics> {
        self.statistics.as_ref()
    }
    /// <p>The name of the workgroup in which the query ran.</p>
    pub fn work_group(&self) -> std::option::Option<&str> {
        self.work_group.as_deref()
    }
    /// <p>The engine version that executed the query.</p>
    pub fn engine_version(&self) -> std::option::Option<&crate::model::EngineVersion> {
        self.engine_version.as_ref()
    }
}
impl std::fmt::Debug for QueryExecution {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("QueryExecution");
        formatter.field("query_execution_id", &self.query_execution_id);
        formatter.field("query", &self.query);
        formatter.field("statement_type", &self.statement_type);
        formatter.field("result_configuration", &self.result_configuration);
        formatter.field("query_execution_context", &self.query_execution_context);
        formatter.field("status", &self.status);
        formatter.field("statistics", &self.statistics);
        formatter.field("work_group", &self.work_group);
        formatter.field("engine_version", &self.engine_version);
        formatter.finish()
    }
}
/// See [`QueryExecution`](crate::model::QueryExecution)
pub mod query_execution {

    /// A builder for [`QueryExecution`](crate::model::QueryExecution)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) query_execution_id: std::option::Option<std::string::String>,
        pub(crate) query: std::option::Option<std::string::String>,
        pub(crate) statement_type: std::option::Option<crate::model::StatementType>,
        pub(crate) result_configuration: std::option::Option<crate::model::ResultConfiguration>,
        pub(crate) query_execution_context:
            std::option::Option<crate::model::QueryExecutionContext>,
        pub(crate) status: std::option::Option<crate::model::QueryExecutionStatus>,
        pub(crate) statistics: std::option::Option<crate::model::QueryExecutionStatistics>,
        pub(crate) work_group: std::option::Option<std::string::String>,
        pub(crate) engine_version: std::option::Option<crate::model::EngineVersion>,
    }
    impl Builder {
        /// <p>The unique identifier for each query execution.</p>
        pub fn query_execution_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.query_execution_id = Some(input.into());
            self
        }
        /// <p>The unique identifier for each query execution.</p>
        pub fn set_query_execution_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.query_execution_id = input;
            self
        }
        /// <p>The SQL query statements which the query execution ran.</p>
        pub fn query(mut self, input: impl Into<std::string::String>) -> Self {
            self.query = Some(input.into());
            self
        }
        /// <p>The SQL query statements which the query execution ran.</p>
        pub fn set_query(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.query = input;
            self
        }
        /// <p>The type of query statement that was run. <code>DDL</code> indicates DDL query statements. <code>DML</code> indicates DML (Data Manipulation Language) query statements, such as <code>CREATE TABLE AS SELECT</code>. <code>UTILITY</code> indicates query statements other than DDL and DML, such as <code>SHOW CREATE TABLE</code>, or <code>DESCRIBE TABLE</code>.</p>
        pub fn statement_type(mut self, input: crate::model::StatementType) -> Self {
            self.statement_type = Some(input);
            self
        }
        /// <p>The type of query statement that was run. <code>DDL</code> indicates DDL query statements. <code>DML</code> indicates DML (Data Manipulation Language) query statements, such as <code>CREATE TABLE AS SELECT</code>. <code>UTILITY</code> indicates query statements other than DDL and DML, such as <code>SHOW CREATE TABLE</code>, or <code>DESCRIBE TABLE</code>.</p>
        pub fn set_statement_type(
            mut self,
            input: std::option::Option<crate::model::StatementType>,
        ) -> Self {
            self.statement_type = input;
            self
        }
        /// <p>The location in Amazon S3 where query results were stored and the encryption option, if any, used for query results. These are known as "client-side settings". If workgroup settings override client-side settings, then the query uses the location for the query results and the encryption configuration that are specified for the workgroup.</p>
        pub fn result_configuration(mut self, input: crate::model::ResultConfiguration) -> Self {
            self.result_configuration = Some(input);
            self
        }
        /// <p>The location in Amazon S3 where query results were stored and the encryption option, if any, used for query results. These are known as "client-side settings". If workgroup settings override client-side settings, then the query uses the location for the query results and the encryption configuration that are specified for the workgroup.</p>
        pub fn set_result_configuration(
            mut self,
            input: std::option::Option<crate::model::ResultConfiguration>,
        ) -> Self {
            self.result_configuration = input;
            self
        }
        /// <p>The database in which the query execution occurred.</p>
        pub fn query_execution_context(
            mut self,
            input: crate::model::QueryExecutionContext,
        ) -> Self {
            self.query_execution_context = Some(input);
            self
        }
        /// <p>The database in which the query execution occurred.</p>
        pub fn set_query_execution_context(
            mut self,
            input: std::option::Option<crate::model::QueryExecutionContext>,
        ) -> Self {
            self.query_execution_context = input;
            self
        }
        /// <p>The completion date, current state, submission time, and state change reason (if applicable) for the query execution.</p>
        pub fn status(mut self, input: crate::model::QueryExecutionStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The completion date, current state, submission time, and state change reason (if applicable) for the query execution.</p>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::QueryExecutionStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// <p>Query execution statistics, such as the amount of data scanned, the amount of time that the query took to process, and the type of statement that was run.</p>
        pub fn statistics(mut self, input: crate::model::QueryExecutionStatistics) -> Self {
            self.statistics = Some(input);
            self
        }
        /// <p>Query execution statistics, such as the amount of data scanned, the amount of time that the query took to process, and the type of statement that was run.</p>
        pub fn set_statistics(
            mut self,
            input: std::option::Option<crate::model::QueryExecutionStatistics>,
        ) -> Self {
            self.statistics = input;
            self
        }
        /// <p>The name of the workgroup in which the query ran.</p>
        pub fn work_group(mut self, input: impl Into<std::string::String>) -> Self {
            self.work_group = Some(input.into());
            self
        }
        /// <p>The name of the workgroup in which the query ran.</p>
        pub fn set_work_group(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.work_group = input;
            self
        }
        /// <p>The engine version that executed the query.</p>
        pub fn engine_version(mut self, input: crate::model::EngineVersion) -> Self {
            self.engine_version = Some(input);
            self
        }
        /// <p>The engine version that executed the query.</p>
        pub fn set_engine_version(
            mut self,
            input: std::option::Option<crate::model::EngineVersion>,
        ) -> Self {
            self.engine_version = input;
            self
        }
        /// Consumes the builder and constructs a [`QueryExecution`](crate::model::QueryExecution)
        pub fn build(self) -> crate::model::QueryExecution {
            crate::model::QueryExecution {
                query_execution_id: self.query_execution_id,
                query: self.query,
                statement_type: self.statement_type,
                result_configuration: self.result_configuration,
                query_execution_context: self.query_execution_context,
                status: self.status,
                statistics: self.statistics,
                work_group: self.work_group,
                engine_version: self.engine_version,
            }
        }
    }
}
impl QueryExecution {
    /// Creates a new builder-style object to manufacture [`QueryExecution`](crate::model::QueryExecution)
    pub fn builder() -> crate::model::query_execution::Builder {
        crate::model::query_execution::Builder::default()
    }
}

/// <p>The amount of data scanned during the query execution and the amount of time that it took to execute, and the type of statement that was run.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct QueryExecutionStatistics {
    /// <p>The number of milliseconds that the query took to execute.</p>
    pub engine_execution_time_in_millis: std::option::Option<i64>,
    /// <p>The number of bytes in the data that was queried.</p>
    pub data_scanned_in_bytes: std::option::Option<i64>,
    /// <p>The location and file name of a data manifest file. The manifest file is saved to the Athena query results location in Amazon S3. The manifest file tracks files that the query wrote to Amazon S3. If the query fails, the manifest file also tracks files that the query intended to write. The manifest is useful for identifying orphaned files resulting from a failed query. For more information, see <a href="https://docs.aws.amazon.com/athena/latest/ug/querying.html">Working with Query Results, Output Files, and Query History</a> in the <i>Amazon Athena User Guide</i>.</p>
    pub data_manifest_location: std::option::Option<std::string::String>,
    /// <p>The number of milliseconds that Athena took to run the query.</p>
    pub total_execution_time_in_millis: std::option::Option<i64>,
    /// <p>The number of milliseconds that the query was in your query queue waiting for resources. Note that if transient errors occur, Athena might automatically add the query back to the queue.</p>
    pub query_queue_time_in_millis: std::option::Option<i64>,
    /// <p>The number of milliseconds that Athena took to plan the query processing flow. This includes the time spent retrieving table partitions from the data source. Note that because the query engine performs the query planning, query planning time is a subset of engine processing time.</p>
    pub query_planning_time_in_millis: std::option::Option<i64>,
    /// <p>The number of milliseconds that Athena took to finalize and publish the query results after the query engine finished running the query.</p>
    pub service_processing_time_in_millis: std::option::Option<i64>,
}
impl QueryExecutionStatistics {
    /// <p>The number of milliseconds that the query took to execute.</p>
    pub fn engine_execution_time_in_millis(&self) -> std::option::Option<i64> {
        self.engine_execution_time_in_millis
    }
    /// <p>The number of bytes in the data that was queried.</p>
    pub fn data_scanned_in_bytes(&self) -> std::option::Option<i64> {
        self.data_scanned_in_bytes
    }
    /// <p>The location and file name of a data manifest file. The manifest file is saved to the Athena query results location in Amazon S3. The manifest file tracks files that the query wrote to Amazon S3. If the query fails, the manifest file also tracks files that the query intended to write. The manifest is useful for identifying orphaned files resulting from a failed query. For more information, see <a href="https://docs.aws.amazon.com/athena/latest/ug/querying.html">Working with Query Results, Output Files, and Query History</a> in the <i>Amazon Athena User Guide</i>.</p>
    pub fn data_manifest_location(&self) -> std::option::Option<&str> {
        self.data_manifest_location.as_deref()
    }
    /// <p>The number of milliseconds that Athena took to run the query.</p>
    pub fn total_execution_time_in_millis(&self) -> std::option::Option<i64> {
        self.total_execution_time_in_millis
    }
    /// <p>The number of milliseconds that the query was in your query queue waiting for resources. Note that if transient errors occur, Athena might automatically add the query back to the queue.</p>
    pub fn query_queue_time_in_millis(&self) -> std::option::Option<i64> {
        self.query_queue_time_in_millis
    }
    /// <p>The number of milliseconds that Athena took to plan the query processing flow. This includes the time spent retrieving table partitions from the data source. Note that because the query engine performs the query planning, query planning time is a subset of engine processing time.</p>
    pub fn query_planning_time_in_millis(&self) -> std::option::Option<i64> {
        self.query_planning_time_in_millis
    }
    /// <p>The number of milliseconds that Athena took to finalize and publish the query results after the query engine finished running the query.</p>
    pub fn service_processing_time_in_millis(&self) -> std::option::Option<i64> {
        self.service_processing_time_in_millis
    }
}
impl std::fmt::Debug for QueryExecutionStatistics {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("QueryExecutionStatistics");
        formatter.field(
            "engine_execution_time_in_millis",
            &self.engine_execution_time_in_millis,
        );
        formatter.field("data_scanned_in_bytes", &self.data_scanned_in_bytes);
        formatter.field("data_manifest_location", &self.data_manifest_location);
        formatter.field(
            "total_execution_time_in_millis",
            &self.total_execution_time_in_millis,
        );
        formatter.field(
            "query_queue_time_in_millis",
            &self.query_queue_time_in_millis,
        );
        formatter.field(
            "query_planning_time_in_millis",
            &self.query_planning_time_in_millis,
        );
        formatter.field(
            "service_processing_time_in_millis",
            &self.service_processing_time_in_millis,
        );
        formatter.finish()
    }
}
/// See [`QueryExecutionStatistics`](crate::model::QueryExecutionStatistics)
pub mod query_execution_statistics {

    /// A builder for [`QueryExecutionStatistics`](crate::model::QueryExecutionStatistics)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) engine_execution_time_in_millis: std::option::Option<i64>,
        pub(crate) data_scanned_in_bytes: std::option::Option<i64>,
        pub(crate) data_manifest_location: std::option::Option<std::string::String>,
        pub(crate) total_execution_time_in_millis: std::option::Option<i64>,
        pub(crate) query_queue_time_in_millis: std::option::Option<i64>,
        pub(crate) query_planning_time_in_millis: std::option::Option<i64>,
        pub(crate) service_processing_time_in_millis: std::option::Option<i64>,
    }
    impl Builder {
        /// <p>The number of milliseconds that the query took to execute.</p>
        pub fn engine_execution_time_in_millis(mut self, input: i64) -> Self {
            self.engine_execution_time_in_millis = Some(input);
            self
        }
        /// <p>The number of milliseconds that the query took to execute.</p>
        pub fn set_engine_execution_time_in_millis(
            mut self,
            input: std::option::Option<i64>,
        ) -> Self {
            self.engine_execution_time_in_millis = input;
            self
        }
        /// <p>The number of bytes in the data that was queried.</p>
        pub fn data_scanned_in_bytes(mut self, input: i64) -> Self {
            self.data_scanned_in_bytes = Some(input);
            self
        }
        /// <p>The number of bytes in the data that was queried.</p>
        pub fn set_data_scanned_in_bytes(mut self, input: std::option::Option<i64>) -> Self {
            self.data_scanned_in_bytes = input;
            self
        }
        /// <p>The location and file name of a data manifest file. The manifest file is saved to the Athena query results location in Amazon S3. The manifest file tracks files that the query wrote to Amazon S3. If the query fails, the manifest file also tracks files that the query intended to write. The manifest is useful for identifying orphaned files resulting from a failed query. For more information, see <a href="https://docs.aws.amazon.com/athena/latest/ug/querying.html">Working with Query Results, Output Files, and Query History</a> in the <i>Amazon Athena User Guide</i>.</p>
        pub fn data_manifest_location(mut self, input: impl Into<std::string::String>) -> Self {
            self.data_manifest_location = Some(input.into());
            self
        }
        /// <p>The location and file name of a data manifest file. The manifest file is saved to the Athena query results location in Amazon S3. The manifest file tracks files that the query wrote to Amazon S3. If the query fails, the manifest file also tracks files that the query intended to write. The manifest is useful for identifying orphaned files resulting from a failed query. For more information, see <a href="https://docs.aws.amazon.com/athena/latest/ug/querying.html">Working with Query Results, Output Files, and Query History</a> in the <i>Amazon Athena User Guide</i>.</p>
        pub fn set_data_manifest_location(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.data_manifest_location = input;
            self
        }
        /// <p>The number of milliseconds that Athena took to run the query.</p>
        pub fn total_execution_time_in_millis(mut self, input: i64) -> Self {
            self.total_execution_time_in_millis = Some(input);
            self
        }
        /// <p>The number of milliseconds that Athena took to run the query.</p>
        pub fn set_total_execution_time_in_millis(
            mut self,
            input: std::option::Option<i64>,
        ) -> Self {
            self.total_execution_time_in_millis = input;
            self
        }
        /// <p>The number of milliseconds that the query was in your query queue waiting for resources. Note that if transient errors occur, Athena might automatically add the query back to the queue.</p>
        pub fn query_queue_time_in_millis(mut self, input: i64) -> Self {
            self.query_queue_time_in_millis = Some(input);
            self
        }
        /// <p>The number of milliseconds that the query was in your query queue waiting for resources. Note that if transient errors occur, Athena might automatically add the query back to the queue.</p>
        pub fn set_query_queue_time_in_millis(mut self, input: std::option::Option<i64>) -> Self {
            self.query_queue_time_in_millis = input;
            self
        }
        /// <p>The number of milliseconds that Athena took to plan the query processing flow. This includes the time spent retrieving table partitions from the data source. Note that because the query engine performs the query planning, query planning time is a subset of engine processing time.</p>
        pub fn query_planning_time_in_millis(mut self, input: i64) -> Self {
            self.query_planning_time_in_millis = Some(input);
            self
        }
        /// <p>The number of milliseconds that Athena took to plan the query processing flow. This includes the time spent retrieving table partitions from the data source. Note that because the query engine performs the query planning, query planning time is a subset of engine processing time.</p>
        pub fn set_query_planning_time_in_millis(
            mut self,
            input: std::option::Option<i64>,
        ) -> Self {
            self.query_planning_time_in_millis = input;
            self
        }
        /// <p>The number of milliseconds that Athena took to finalize and publish the query results after the query engine finished running the query.</p>
        pub fn service_processing_time_in_millis(mut self, input: i64) -> Self {
            self.service_processing_time_in_millis = Some(input);
            self
        }
        /// <p>The number of milliseconds that Athena took to finalize and publish the query results after the query engine finished running the query.</p>
        pub fn set_service_processing_time_in_millis(
            mut self,
            input: std::option::Option<i64>,
        ) -> Self {
            self.service_processing_time_in_millis = input;
            self
        }
        /// Consumes the builder and constructs a [`QueryExecutionStatistics`](crate::model::QueryExecutionStatistics)
        pub fn build(self) -> crate::model::QueryExecutionStatistics {
            crate::model::QueryExecutionStatistics {
                engine_execution_time_in_millis: self.engine_execution_time_in_millis,
                data_scanned_in_bytes: self.data_scanned_in_bytes,
                data_manifest_location: self.data_manifest_location,
                total_execution_time_in_millis: self.total_execution_time_in_millis,
                query_queue_time_in_millis: self.query_queue_time_in_millis,
                query_planning_time_in_millis: self.query_planning_time_in_millis,
                service_processing_time_in_millis: self.service_processing_time_in_millis,
            }
        }
    }
}
impl QueryExecutionStatistics {
    /// Creates a new builder-style object to manufacture [`QueryExecutionStatistics`](crate::model::QueryExecutionStatistics)
    pub fn builder() -> crate::model::query_execution_statistics::Builder {
        crate::model::query_execution_statistics::Builder::default()
    }
}

/// <p>The completion date, current state, submission time, and state change reason (if applicable) for the query execution.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct QueryExecutionStatus {
    /// <p>The state of query execution. <code>QUEUED</code> indicates that the query has been submitted to the service, and Athena will execute the query as soon as resources are available. <code>RUNNING</code> indicates that the query is in execution phase. <code>SUCCEEDED</code> indicates that the query completed without errors. <code>FAILED</code> indicates that the query experienced an error and did not complete processing. <code>CANCELLED</code> indicates that a user input interrupted query execution.</p> <note>
    /// <p>Athena automatically retries your queries in cases of certain transient errors. As a result, you may see the query state transition from <code>RUNNING</code> or <code>FAILED</code> to <code>QUEUED</code>. </p>
    /// </note>
    pub state: std::option::Option<crate::model::QueryExecutionState>,
    /// <p>Further detail about the status of the query.</p>
    pub state_change_reason: std::option::Option<std::string::String>,
    /// <p>The date and time that the query was submitted.</p>
    pub submission_date_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The date and time that the query completed.</p>
    pub completion_date_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>Provides information about an Athena query error.</p>
    pub athena_error: std::option::Option<crate::model::AthenaError>,
}
impl QueryExecutionStatus {
    /// <p>The state of query execution. <code>QUEUED</code> indicates that the query has been submitted to the service, and Athena will execute the query as soon as resources are available. <code>RUNNING</code> indicates that the query is in execution phase. <code>SUCCEEDED</code> indicates that the query completed without errors. <code>FAILED</code> indicates that the query experienced an error and did not complete processing. <code>CANCELLED</code> indicates that a user input interrupted query execution.</p> <note>
    /// <p>Athena automatically retries your queries in cases of certain transient errors. As a result, you may see the query state transition from <code>RUNNING</code> or <code>FAILED</code> to <code>QUEUED</code>. </p>
    /// </note>
    pub fn state(&self) -> std::option::Option<&crate::model::QueryExecutionState> {
        self.state.as_ref()
    }
    /// <p>Further detail about the status of the query.</p>
    pub fn state_change_reason(&self) -> std::option::Option<&str> {
        self.state_change_reason.as_deref()
    }
    /// <p>The date and time that the query was submitted.</p>
    pub fn submission_date_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.submission_date_time.as_ref()
    }
    /// <p>The date and time that the query completed.</p>
    pub fn completion_date_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.completion_date_time.as_ref()
    }
    /// <p>Provides information about an Athena query error.</p>
    pub fn athena_error(&self) -> std::option::Option<&crate::model::AthenaError> {
        self.athena_error.as_ref()
    }
}
impl std::fmt::Debug for QueryExecutionStatus {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("QueryExecutionStatus");
        formatter.field("state", &self.state);
        formatter.field("state_change_reason", &self.state_change_reason);
        formatter.field("submission_date_time", &self.submission_date_time);
        formatter.field("completion_date_time", &self.completion_date_time);
        formatter.field("athena_error", &self.athena_error);
        formatter.finish()
    }
}
/// See [`QueryExecutionStatus`](crate::model::QueryExecutionStatus)
pub mod query_execution_status {

    /// A builder for [`QueryExecutionStatus`](crate::model::QueryExecutionStatus)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) state: std::option::Option<crate::model::QueryExecutionState>,
        pub(crate) state_change_reason: std::option::Option<std::string::String>,
        pub(crate) submission_date_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) completion_date_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) athena_error: std::option::Option<crate::model::AthenaError>,
    }
    impl Builder {
        /// <p>The state of query execution. <code>QUEUED</code> indicates that the query has been submitted to the service, and Athena will execute the query as soon as resources are available. <code>RUNNING</code> indicates that the query is in execution phase. <code>SUCCEEDED</code> indicates that the query completed without errors. <code>FAILED</code> indicates that the query experienced an error and did not complete processing. <code>CANCELLED</code> indicates that a user input interrupted query execution.</p> <note>
        /// <p>Athena automatically retries your queries in cases of certain transient errors. As a result, you may see the query state transition from <code>RUNNING</code> or <code>FAILED</code> to <code>QUEUED</code>. </p>
        /// </note>
        pub fn state(mut self, input: crate::model::QueryExecutionState) -> Self {
            self.state = Some(input);
            self
        }
        /// <p>The state of query execution. <code>QUEUED</code> indicates that the query has been submitted to the service, and Athena will execute the query as soon as resources are available. <code>RUNNING</code> indicates that the query is in execution phase. <code>SUCCEEDED</code> indicates that the query completed without errors. <code>FAILED</code> indicates that the query experienced an error and did not complete processing. <code>CANCELLED</code> indicates that a user input interrupted query execution.</p> <note>
        /// <p>Athena automatically retries your queries in cases of certain transient errors. As a result, you may see the query state transition from <code>RUNNING</code> or <code>FAILED</code> to <code>QUEUED</code>. </p>
        /// </note>
        pub fn set_state(
            mut self,
            input: std::option::Option<crate::model::QueryExecutionState>,
        ) -> Self {
            self.state = input;
            self
        }
        /// <p>Further detail about the status of the query.</p>
        pub fn state_change_reason(mut self, input: impl Into<std::string::String>) -> Self {
            self.state_change_reason = Some(input.into());
            self
        }
        /// <p>Further detail about the status of the query.</p>
        pub fn set_state_change_reason(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.state_change_reason = input;
            self
        }
        /// <p>The date and time that the query was submitted.</p>
        pub fn submission_date_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.submission_date_time = Some(input);
            self
        }
        /// <p>The date and time that the query was submitted.</p>
        pub fn set_submission_date_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.submission_date_time = input;
            self
        }
        /// <p>The date and time that the query completed.</p>
        pub fn completion_date_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.completion_date_time = Some(input);
            self
        }
        /// <p>The date and time that the query completed.</p>
        pub fn set_completion_date_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.completion_date_time = input;
            self
        }
        /// <p>Provides information about an Athena query error.</p>
        pub fn athena_error(mut self, input: crate::model::AthenaError) -> Self {
            self.athena_error = Some(input);
            self
        }
        /// <p>Provides information about an Athena query error.</p>
        pub fn set_athena_error(
            mut self,
            input: std::option::Option<crate::model::AthenaError>,
        ) -> Self {
            self.athena_error = input;
            self
        }
        /// Consumes the builder and constructs a [`QueryExecutionStatus`](crate::model::QueryExecutionStatus)
        pub fn build(self) -> crate::model::QueryExecutionStatus {
            crate::model::QueryExecutionStatus {
                state: self.state,
                state_change_reason: self.state_change_reason,
                submission_date_time: self.submission_date_time,
                completion_date_time: self.completion_date_time,
                athena_error: self.athena_error,
            }
        }
    }
}
impl QueryExecutionStatus {
    /// Creates a new builder-style object to manufacture [`QueryExecutionStatus`](crate::model::QueryExecutionStatus)
    pub fn builder() -> crate::model::query_execution_status::Builder {
        crate::model::query_execution_status::Builder::default()
    }
}

/// <p>Provides information about an Athena query error. The <code>AthenaError</code> feature provides standardized error information to help you understand failed queries and take steps after a query failure occurs. <code>AthenaError</code> includes an <code>ErrorCategory</code> field that specifies whether the cause of the failed query is due to system error, user error, or other error.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AthenaError {
    /// <p>An integer value that specifies the category of a query failure error. The following list shows the category for each integer value.</p>
    /// <p> <b>1</b> - System</p>
    /// <p> <b>2</b> - User</p>
    /// <p> <b>3</b> - Other</p>
    pub error_category: std::option::Option<i32>,
    /// <p>An integer value that provides specific information about an Athena query error. For the meaning of specific values, see the <a href="https://docs.aws.amazon.com/athena/latest/ug/error-reference.html#error-reference-error-type-reference">Error Type Reference</a> in the <i>Amazon Athena User Guide</i>.</p>
    pub error_type: std::option::Option<i32>,
    /// <p>True if the query might succeed if resubmitted.</p>
    pub retryable: bool,
    /// <p>Contains a short description of the error that occurred.</p>
    pub error_message: std::option::Option<std::string::String>,
}
impl AthenaError {
    /// <p>An integer value that specifies the category of a query failure error. The following list shows the category for each integer value.</p>
    /// <p> <b>1</b> - System</p>
    /// <p> <b>2</b> - User</p>
    /// <p> <b>3</b> - Other</p>
    pub fn error_category(&self) -> std::option::Option<i32> {
        self.error_category
    }
    /// <p>An integer value that provides specific information about an Athena query error. For the meaning of specific values, see the <a href="https://docs.aws.amazon.com/athena/latest/ug/error-reference.html#error-reference-error-type-reference">Error Type Reference</a> in the <i>Amazon Athena User Guide</i>.</p>
    pub fn error_type(&self) -> std::option::Option<i32> {
        self.error_type
    }
    /// <p>True if the query might succeed if resubmitted.</p>
    pub fn retryable(&self) -> bool {
        self.retryable
    }
    /// <p>Contains a short description of the error that occurred.</p>
    pub fn error_message(&self) -> std::option::Option<&str> {
        self.error_message.as_deref()
    }
}
impl std::fmt::Debug for AthenaError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AthenaError");
        formatter.field("error_category", &self.error_category);
        formatter.field("error_type", &self.error_type);
        formatter.field("retryable", &self.retryable);
        formatter.field("error_message", &self.error_message);
        formatter.finish()
    }
}
/// See [`AthenaError`](crate::model::AthenaError)
pub mod athena_error {

    /// A builder for [`AthenaError`](crate::model::AthenaError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) error_category: std::option::Option<i32>,
        pub(crate) error_type: std::option::Option<i32>,
        pub(crate) retryable: std::option::Option<bool>,
        pub(crate) error_message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>An integer value that specifies the category of a query failure error. The following list shows the category for each integer value.</p>
        /// <p> <b>1</b> - System</p>
        /// <p> <b>2</b> - User</p>
        /// <p> <b>3</b> - Other</p>
        pub fn error_category(mut self, input: i32) -> Self {
            self.error_category = Some(input);
            self
        }
        /// <p>An integer value that specifies the category of a query failure error. The following list shows the category for each integer value.</p>
        /// <p> <b>1</b> - System</p>
        /// <p> <b>2</b> - User</p>
        /// <p> <b>3</b> - Other</p>
        pub fn set_error_category(mut self, input: std::option::Option<i32>) -> Self {
            self.error_category = input;
            self
        }
        /// <p>An integer value that provides specific information about an Athena query error. For the meaning of specific values, see the <a href="https://docs.aws.amazon.com/athena/latest/ug/error-reference.html#error-reference-error-type-reference">Error Type Reference</a> in the <i>Amazon Athena User Guide</i>.</p>
        pub fn error_type(mut self, input: i32) -> Self {
            self.error_type = Some(input);
            self
        }
        /// <p>An integer value that provides specific information about an Athena query error. For the meaning of specific values, see the <a href="https://docs.aws.amazon.com/athena/latest/ug/error-reference.html#error-reference-error-type-reference">Error Type Reference</a> in the <i>Amazon Athena User Guide</i>.</p>
        pub fn set_error_type(mut self, input: std::option::Option<i32>) -> Self {
            self.error_type = input;
            self
        }
        /// <p>True if the query might succeed if resubmitted.</p>
        pub fn retryable(mut self, input: bool) -> Self {
            self.retryable = Some(input);
            self
        }
        /// <p>True if the query might succeed if resubmitted.</p>
        pub fn set_retryable(mut self, input: std::option::Option<bool>) -> Self {
            self.retryable = input;
            self
        }
        /// <p>Contains a short description of the error that occurred.</p>
        pub fn error_message(mut self, input: impl Into<std::string::String>) -> Self {
            self.error_message = Some(input.into());
            self
        }
        /// <p>Contains a short description of the error that occurred.</p>
        pub fn set_error_message(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.error_message = input;
            self
        }
        /// Consumes the builder and constructs a [`AthenaError`](crate::model::AthenaError)
        pub fn build(self) -> crate::model::AthenaError {
            crate::model::AthenaError {
                error_category: self.error_category,
                error_type: self.error_type,
                retryable: self.retryable.unwrap_or_default(),
                error_message: self.error_message,
            }
        }
    }
}
impl AthenaError {
    /// Creates a new builder-style object to manufacture [`AthenaError`](crate::model::AthenaError)
    pub fn builder() -> crate::model::athena_error::Builder {
        crate::model::athena_error::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum QueryExecutionState {
    #[allow(missing_docs)] // documentation missing in model
    Cancelled,
    #[allow(missing_docs)] // documentation missing in model
    Failed,
    #[allow(missing_docs)] // documentation missing in model
    Queued,
    #[allow(missing_docs)] // documentation missing in model
    Running,
    #[allow(missing_docs)] // documentation missing in model
    Succeeded,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for QueryExecutionState {
    fn from(s: &str) -> Self {
        match s {
            "CANCELLED" => QueryExecutionState::Cancelled,
            "FAILED" => QueryExecutionState::Failed,
            "QUEUED" => QueryExecutionState::Queued,
            "RUNNING" => QueryExecutionState::Running,
            "SUCCEEDED" => QueryExecutionState::Succeeded,
            other => QueryExecutionState::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for QueryExecutionState {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(QueryExecutionState::from(s))
    }
}
impl QueryExecutionState {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            QueryExecutionState::Cancelled => "CANCELLED",
            QueryExecutionState::Failed => "FAILED",
            QueryExecutionState::Queued => "QUEUED",
            QueryExecutionState::Running => "RUNNING",
            QueryExecutionState::Succeeded => "SUCCEEDED",
            QueryExecutionState::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["CANCELLED", "FAILED", "QUEUED", "RUNNING", "SUCCEEDED"]
    }
}
impl AsRef<str> for QueryExecutionState {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum StatementType {
    #[allow(missing_docs)] // documentation missing in model
    Ddl,
    #[allow(missing_docs)] // documentation missing in model
    Dml,
    #[allow(missing_docs)] // documentation missing in model
    Utility,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for StatementType {
    fn from(s: &str) -> Self {
        match s {
            "DDL" => StatementType::Ddl,
            "DML" => StatementType::Dml,
            "UTILITY" => StatementType::Utility,
            other => StatementType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for StatementType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(StatementType::from(s))
    }
}
impl StatementType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            StatementType::Ddl => "DDL",
            StatementType::Dml => "DML",
            StatementType::Utility => "UTILITY",
            StatementType::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["DDL", "DML", "UTILITY"]
    }
}
impl AsRef<str> for StatementType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>A prepared SQL statement for use with Athena.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PreparedStatement {
    /// <p>The name of the prepared statement.</p>
    pub statement_name: std::option::Option<std::string::String>,
    /// <p>The query string for the prepared statement.</p>
    pub query_statement: std::option::Option<std::string::String>,
    /// <p>The name of the workgroup to which the prepared statement belongs.</p>
    pub work_group_name: std::option::Option<std::string::String>,
    /// <p>The description of the prepared statement.</p>
    pub description: std::option::Option<std::string::String>,
    /// <p>The last modified time of the prepared statement.</p>
    pub last_modified_time: std::option::Option<aws_smithy_types::DateTime>,
}
impl PreparedStatement {
    /// <p>The name of the prepared statement.</p>
    pub fn statement_name(&self) -> std::option::Option<&str> {
        self.statement_name.as_deref()
    }
    /// <p>The query string for the prepared statement.</p>
    pub fn query_statement(&self) -> std::option::Option<&str> {
        self.query_statement.as_deref()
    }
    /// <p>The name of the workgroup to which the prepared statement belongs.</p>
    pub fn work_group_name(&self) -> std::option::Option<&str> {
        self.work_group_name.as_deref()
    }
    /// <p>The description of the prepared statement.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>The last modified time of the prepared statement.</p>
    pub fn last_modified_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.last_modified_time.as_ref()
    }
}
impl std::fmt::Debug for PreparedStatement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PreparedStatement");
        formatter.field("statement_name", &self.statement_name);
        formatter.field("query_statement", &self.query_statement);
        formatter.field("work_group_name", &self.work_group_name);
        formatter.field("description", &self.description);
        formatter.field("last_modified_time", &self.last_modified_time);
        formatter.finish()
    }
}
/// See [`PreparedStatement`](crate::model::PreparedStatement)
pub mod prepared_statement {

    /// A builder for [`PreparedStatement`](crate::model::PreparedStatement)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) statement_name: std::option::Option<std::string::String>,
        pub(crate) query_statement: std::option::Option<std::string::String>,
        pub(crate) work_group_name: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) last_modified_time: std::option::Option<aws_smithy_types::DateTime>,
    }
    impl Builder {
        /// <p>The name of the prepared statement.</p>
        pub fn statement_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.statement_name = Some(input.into());
            self
        }
        /// <p>The name of the prepared statement.</p>
        pub fn set_statement_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.statement_name = input;
            self
        }
        /// <p>The query string for the prepared statement.</p>
        pub fn query_statement(mut self, input: impl Into<std::string::String>) -> Self {
            self.query_statement = Some(input.into());
            self
        }
        /// <p>The query string for the prepared statement.</p>
        pub fn set_query_statement(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.query_statement = input;
            self
        }
        /// <p>The name of the workgroup to which the prepared statement belongs.</p>
        pub fn work_group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.work_group_name = Some(input.into());
            self
        }
        /// <p>The name of the workgroup to which the prepared statement belongs.</p>
        pub fn set_work_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.work_group_name = input;
            self
        }
        /// <p>The description of the prepared statement.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>The description of the prepared statement.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>The last modified time of the prepared statement.</p>
        pub fn last_modified_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.last_modified_time = Some(input);
            self
        }
        /// <p>The last modified time of the prepared statement.</p>
        pub fn set_last_modified_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.last_modified_time = input;
            self
        }
        /// Consumes the builder and constructs a [`PreparedStatement`](crate::model::PreparedStatement)
        pub fn build(self) -> crate::model::PreparedStatement {
            crate::model::PreparedStatement {
                statement_name: self.statement_name,
                query_statement: self.query_statement,
                work_group_name: self.work_group_name,
                description: self.description,
                last_modified_time: self.last_modified_time,
            }
        }
    }
}
impl PreparedStatement {
    /// Creates a new builder-style object to manufacture [`PreparedStatement`](crate::model::PreparedStatement)
    pub fn builder() -> crate::model::prepared_statement::Builder {
        crate::model::prepared_statement::Builder::default()
    }
}

/// <p>A query, where <code>QueryString</code> contains the SQL statements that make up the query.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct NamedQuery {
    /// <p>The query name.</p>
    pub name: std::option::Option<std::string::String>,
    /// <p>The query description.</p>
    pub description: std::option::Option<std::string::String>,
    /// <p>The database to which the query belongs.</p>
    pub database: std::option::Option<std::string::String>,
    /// <p>The SQL statements that make up the query.</p>
    pub query_string: std::option::Option<std::string::String>,
    /// <p>The unique identifier of the query.</p>
    pub named_query_id: std::option::Option<std::string::String>,
    /// <p>The name of the workgroup that contains the named query.</p>
    pub work_group: std::option::Option<std::string::String>,
}
impl NamedQuery {
    /// <p>The query name.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The query description.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>The database to which the query belongs.</p>
    pub fn database(&self) -> std::option::Option<&str> {
        self.database.as_deref()
    }
    /// <p>The SQL statements that make up the query.</p>
    pub fn query_string(&self) -> std::option::Option<&str> {
        self.query_string.as_deref()
    }
    /// <p>The unique identifier of the query.</p>
    pub fn named_query_id(&self) -> std::option::Option<&str> {
        self.named_query_id.as_deref()
    }
    /// <p>The name of the workgroup that contains the named query.</p>
    pub fn work_group(&self) -> std::option::Option<&str> {
        self.work_group.as_deref()
    }
}
impl std::fmt::Debug for NamedQuery {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("NamedQuery");
        formatter.field("name", &self.name);
        formatter.field("description", &self.description);
        formatter.field("database", &self.database);
        formatter.field("query_string", &self.query_string);
        formatter.field("named_query_id", &self.named_query_id);
        formatter.field("work_group", &self.work_group);
        formatter.finish()
    }
}
/// See [`NamedQuery`](crate::model::NamedQuery)
pub mod named_query {

    /// A builder for [`NamedQuery`](crate::model::NamedQuery)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) database: std::option::Option<std::string::String>,
        pub(crate) query_string: std::option::Option<std::string::String>,
        pub(crate) named_query_id: std::option::Option<std::string::String>,
        pub(crate) work_group: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The query name.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The query name.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The query description.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>The query description.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>The database to which the query belongs.</p>
        pub fn database(mut self, input: impl Into<std::string::String>) -> Self {
            self.database = Some(input.into());
            self
        }
        /// <p>The database to which the query belongs.</p>
        pub fn set_database(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.database = input;
            self
        }
        /// <p>The SQL statements that make up the query.</p>
        pub fn query_string(mut self, input: impl Into<std::string::String>) -> Self {
            self.query_string = Some(input.into());
            self
        }
        /// <p>The SQL statements that make up the query.</p>
        pub fn set_query_string(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.query_string = input;
            self
        }
        /// <p>The unique identifier of the query.</p>
        pub fn named_query_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.named_query_id = Some(input.into());
            self
        }
        /// <p>The unique identifier of the query.</p>
        pub fn set_named_query_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.named_query_id = input;
            self
        }
        /// <p>The name of the workgroup that contains the named query.</p>
        pub fn work_group(mut self, input: impl Into<std::string::String>) -> Self {
            self.work_group = Some(input.into());
            self
        }
        /// <p>The name of the workgroup that contains the named query.</p>
        pub fn set_work_group(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.work_group = input;
            self
        }
        /// Consumes the builder and constructs a [`NamedQuery`](crate::model::NamedQuery)
        pub fn build(self) -> crate::model::NamedQuery {
            crate::model::NamedQuery {
                name: self.name,
                description: self.description,
                database: self.database,
                query_string: self.query_string,
                named_query_id: self.named_query_id,
                work_group: self.work_group,
            }
        }
    }
}
impl NamedQuery {
    /// Creates a new builder-style object to manufacture [`NamedQuery`](crate::model::NamedQuery)
    pub fn builder() -> crate::model::named_query::Builder {
        crate::model::named_query::Builder::default()
    }
}

/// <p>Contains information about a data catalog in an Amazon Web Services account.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DataCatalog {
    /// <p>The name of the data catalog. The catalog name must be unique for the Amazon Web Services account and can use a maximum of 127 alphanumeric, underscore, at sign, or hyphen characters. The remainder of the length constraint of 256 is reserved for use by Athena.</p>
    pub name: std::option::Option<std::string::String>,
    /// <p>An optional description of the data catalog.</p>
    pub description: std::option::Option<std::string::String>,
    /// <p>The type of data catalog to create: <code>LAMBDA</code> for a federated catalog, <code>HIVE</code> for an external hive metastore, or <code>GLUE</code> for an Glue Data Catalog.</p>
    pub r#type: std::option::Option<crate::model::DataCatalogType>,
    /// <p>Specifies the Lambda function or functions to use for the data catalog. This is a mapping whose values depend on the catalog type. </p>
    /// <ul>
    /// <li> <p>For the <code>HIVE</code> data catalog type, use the following syntax. The <code>metadata-function</code> parameter is required. <code>The sdk-version</code> parameter is optional and defaults to the currently supported version.</p> <p> <code>metadata-function=<i>lambda_arn</i>, sdk-version=<i>version_number</i> </code> </p> </li>
    /// <li> <p>For the <code>LAMBDA</code> data catalog type, use one of the following sets of required parameters, but not both.</p>
    /// <ul>
    /// <li> <p>If you have one Lambda function that processes metadata and another for reading the actual data, use the following syntax. Both parameters are required.</p> <p> <code>metadata-function=<i>lambda_arn</i>, record-function=<i>lambda_arn</i> </code> </p> </li>
    /// <li> <p> If you have a composite Lambda function that processes both metadata and data, use the following syntax to specify your Lambda function.</p> <p> <code>function=<i>lambda_arn</i> </code> </p> </li>
    /// </ul> </li>
    /// <li> <p>The <code>GLUE</code> type takes a catalog ID parameter and is required. The <code> <i>catalog_id</i> </code> is the account ID of the Amazon Web Services account to which the Glue catalog belongs.</p> <p> <code>catalog-id=<i>catalog_id</i> </code> </p>
    /// <ul>
    /// <li> <p>The <code>GLUE</code> data catalog type also applies to the default <code>AwsDataCatalog</code> that already exists in your account, of which you can have only one and cannot modify.</p> </li>
    /// <li> <p>Queries that specify a Glue Data Catalog other than the default <code>AwsDataCatalog</code> must be run on Athena engine version 2.</p> </li>
    /// </ul> </li>
    /// </ul>
    pub parameters:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
}
impl DataCatalog {
    /// <p>The name of the data catalog. The catalog name must be unique for the Amazon Web Services account and can use a maximum of 127 alphanumeric, underscore, at sign, or hyphen characters. The remainder of the length constraint of 256 is reserved for use by Athena.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>An optional description of the data catalog.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>The type of data catalog to create: <code>LAMBDA</code> for a federated catalog, <code>HIVE</code> for an external hive metastore, or <code>GLUE</code> for an Glue Data Catalog.</p>
    pub fn r#type(&self) -> std::option::Option<&crate::model::DataCatalogType> {
        self.r#type.as_ref()
    }
    /// <p>Specifies the Lambda function or functions to use for the data catalog. This is a mapping whose values depend on the catalog type. </p>
    /// <ul>
    /// <li> <p>For the <code>HIVE</code> data catalog type, use the following syntax. The <code>metadata-function</code> parameter is required. <code>The sdk-version</code> parameter is optional and defaults to the currently supported version.</p> <p> <code>metadata-function=<i>lambda_arn</i>, sdk-version=<i>version_number</i> </code> </p> </li>
    /// <li> <p>For the <code>LAMBDA</code> data catalog type, use one of the following sets of required parameters, but not both.</p>
    /// <ul>
    /// <li> <p>If you have one Lambda function that processes metadata and another for reading the actual data, use the following syntax. Both parameters are required.</p> <p> <code>metadata-function=<i>lambda_arn</i>, record-function=<i>lambda_arn</i> </code> </p> </li>
    /// <li> <p> If you have a composite Lambda function that processes both metadata and data, use the following syntax to specify your Lambda function.</p> <p> <code>function=<i>lambda_arn</i> </code> </p> </li>
    /// </ul> </li>
    /// <li> <p>The <code>GLUE</code> type takes a catalog ID parameter and is required. The <code> <i>catalog_id</i> </code> is the account ID of the Amazon Web Services account to which the Glue catalog belongs.</p> <p> <code>catalog-id=<i>catalog_id</i> </code> </p>
    /// <ul>
    /// <li> <p>The <code>GLUE</code> data catalog type also applies to the default <code>AwsDataCatalog</code> that already exists in your account, of which you can have only one and cannot modify.</p> </li>
    /// <li> <p>Queries that specify a Glue Data Catalog other than the default <code>AwsDataCatalog</code> must be run on Athena engine version 2.</p> </li>
    /// </ul> </li>
    /// </ul>
    pub fn parameters(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.parameters.as_ref()
    }
}
impl std::fmt::Debug for DataCatalog {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DataCatalog");
        formatter.field("name", &self.name);
        formatter.field("description", &self.description);
        formatter.field("r#type", &self.r#type);
        formatter.field("parameters", &self.parameters);
        formatter.finish()
    }
}
/// See [`DataCatalog`](crate::model::DataCatalog)
pub mod data_catalog {

    /// A builder for [`DataCatalog`](crate::model::DataCatalog)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) r#type: std::option::Option<crate::model::DataCatalogType>,
        pub(crate) parameters: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
    }
    impl Builder {
        /// <p>The name of the data catalog. The catalog name must be unique for the Amazon Web Services account and can use a maximum of 127 alphanumeric, underscore, at sign, or hyphen characters. The remainder of the length constraint of 256 is reserved for use by Athena.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the data catalog. The catalog name must be unique for the Amazon Web Services account and can use a maximum of 127 alphanumeric, underscore, at sign, or hyphen characters. The remainder of the length constraint of 256 is reserved for use by Athena.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>An optional description of the data catalog.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>An optional description of the data catalog.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>The type of data catalog to create: <code>LAMBDA</code> for a federated catalog, <code>HIVE</code> for an external hive metastore, or <code>GLUE</code> for an Glue Data Catalog.</p>
        pub fn r#type(mut self, input: crate::model::DataCatalogType) -> Self {
            self.r#type = Some(input);
            self
        }
        /// <p>The type of data catalog to create: <code>LAMBDA</code> for a federated catalog, <code>HIVE</code> for an external hive metastore, or <code>GLUE</code> for an Glue Data Catalog.</p>
        pub fn set_type(
            mut self,
            input: std::option::Option<crate::model::DataCatalogType>,
        ) -> Self {
            self.r#type = input;
            self
        }
        /// Adds a key-value pair to `parameters`.
        ///
        /// To override the contents of this collection use [`set_parameters`](Self::set_parameters).
        ///
        /// <p>Specifies the Lambda function or functions to use for the data catalog. This is a mapping whose values depend on the catalog type. </p>
        /// <ul>
        /// <li> <p>For the <code>HIVE</code> data catalog type, use the following syntax. The <code>metadata-function</code> parameter is required. <code>The sdk-version</code> parameter is optional and defaults to the currently supported version.</p> <p> <code>metadata-function=<i>lambda_arn</i>, sdk-version=<i>version_number</i> </code> </p> </li>
        /// <li> <p>For the <code>LAMBDA</code> data catalog type, use one of the following sets of required parameters, but not both.</p>
        /// <ul>
        /// <li> <p>If you have one Lambda function that processes metadata and another for reading the actual data, use the following syntax. Both parameters are required.</p> <p> <code>metadata-function=<i>lambda_arn</i>, record-function=<i>lambda_arn</i> </code> </p> </li>
        /// <li> <p> If you have a composite Lambda function that processes both metadata and data, use the following syntax to specify your Lambda function.</p> <p> <code>function=<i>lambda_arn</i> </code> </p> </li>
        /// </ul> </li>
        /// <li> <p>The <code>GLUE</code> type takes a catalog ID parameter and is required. The <code> <i>catalog_id</i> </code> is the account ID of the Amazon Web Services account to which the Glue catalog belongs.</p> <p> <code>catalog-id=<i>catalog_id</i> </code> </p>
        /// <ul>
        /// <li> <p>The <code>GLUE</code> data catalog type also applies to the default <code>AwsDataCatalog</code> that already exists in your account, of which you can have only one and cannot modify.</p> </li>
        /// <li> <p>Queries that specify a Glue Data Catalog other than the default <code>AwsDataCatalog</code> must be run on Athena engine version 2.</p> </li>
        /// </ul> </li>
        /// </ul>
        pub fn parameters(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.parameters.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.parameters = Some(hash_map);
            self
        }
        /// <p>Specifies the Lambda function or functions to use for the data catalog. This is a mapping whose values depend on the catalog type. </p>
        /// <ul>
        /// <li> <p>For the <code>HIVE</code> data catalog type, use the following syntax. The <code>metadata-function</code> parameter is required. <code>The sdk-version</code> parameter is optional and defaults to the currently supported version.</p> <p> <code>metadata-function=<i>lambda_arn</i>, sdk-version=<i>version_number</i> </code> </p> </li>
        /// <li> <p>For the <code>LAMBDA</code> data catalog type, use one of the following sets of required parameters, but not both.</p>
        /// <ul>
        /// <li> <p>If you have one Lambda function that processes metadata and another for reading the actual data, use the following syntax. Both parameters are required.</p> <p> <code>metadata-function=<i>lambda_arn</i>, record-function=<i>lambda_arn</i> </code> </p> </li>
        /// <li> <p> If you have a composite Lambda function that processes both metadata and data, use the following syntax to specify your Lambda function.</p> <p> <code>function=<i>lambda_arn</i> </code> </p> </li>
        /// </ul> </li>
        /// <li> <p>The <code>GLUE</code> type takes a catalog ID parameter and is required. The <code> <i>catalog_id</i> </code> is the account ID of the Amazon Web Services account to which the Glue catalog belongs.</p> <p> <code>catalog-id=<i>catalog_id</i> </code> </p>
        /// <ul>
        /// <li> <p>The <code>GLUE</code> data catalog type also applies to the default <code>AwsDataCatalog</code> that already exists in your account, of which you can have only one and cannot modify.</p> </li>
        /// <li> <p>Queries that specify a Glue Data Catalog other than the default <code>AwsDataCatalog</code> must be run on Athena engine version 2.</p> </li>
        /// </ul> </li>
        /// </ul>
        pub fn set_parameters(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.parameters = input;
            self
        }
        /// Consumes the builder and constructs a [`DataCatalog`](crate::model::DataCatalog)
        pub fn build(self) -> crate::model::DataCatalog {
            crate::model::DataCatalog {
                name: self.name,
                description: self.description,
                r#type: self.r#type,
                parameters: self.parameters,
            }
        }
    }
}
impl DataCatalog {
    /// Creates a new builder-style object to manufacture [`DataCatalog`](crate::model::DataCatalog)
    pub fn builder() -> crate::model::data_catalog::Builder {
        crate::model::data_catalog::Builder::default()
    }
}

/// <p>Describes a query execution that failed to process.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UnprocessedQueryExecutionId {
    /// <p>The unique identifier of the query execution.</p>
    pub query_execution_id: std::option::Option<std::string::String>,
    /// <p>The error code returned when the query execution failed to process, if applicable.</p>
    pub error_code: std::option::Option<std::string::String>,
    /// <p>The error message returned when the query execution failed to process, if applicable.</p>
    pub error_message: std::option::Option<std::string::String>,
}
impl UnprocessedQueryExecutionId {
    /// <p>The unique identifier of the query execution.</p>
    pub fn query_execution_id(&self) -> std::option::Option<&str> {
        self.query_execution_id.as_deref()
    }
    /// <p>The error code returned when the query execution failed to process, if applicable.</p>
    pub fn error_code(&self) -> std::option::Option<&str> {
        self.error_code.as_deref()
    }
    /// <p>The error message returned when the query execution failed to process, if applicable.</p>
    pub fn error_message(&self) -> std::option::Option<&str> {
        self.error_message.as_deref()
    }
}
impl std::fmt::Debug for UnprocessedQueryExecutionId {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UnprocessedQueryExecutionId");
        formatter.field("query_execution_id", &self.query_execution_id);
        formatter.field("error_code", &self.error_code);
        formatter.field("error_message", &self.error_message);
        formatter.finish()
    }
}
/// See [`UnprocessedQueryExecutionId`](crate::model::UnprocessedQueryExecutionId)
pub mod unprocessed_query_execution_id {

    /// A builder for [`UnprocessedQueryExecutionId`](crate::model::UnprocessedQueryExecutionId)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) query_execution_id: std::option::Option<std::string::String>,
        pub(crate) error_code: std::option::Option<std::string::String>,
        pub(crate) error_message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The unique identifier of the query execution.</p>
        pub fn query_execution_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.query_execution_id = Some(input.into());
            self
        }
        /// <p>The unique identifier of the query execution.</p>
        pub fn set_query_execution_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.query_execution_id = input;
            self
        }
        /// <p>The error code returned when the query execution failed to process, if applicable.</p>
        pub fn error_code(mut self, input: impl Into<std::string::String>) -> Self {
            self.error_code = Some(input.into());
            self
        }
        /// <p>The error code returned when the query execution failed to process, if applicable.</p>
        pub fn set_error_code(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.error_code = input;
            self
        }
        /// <p>The error message returned when the query execution failed to process, if applicable.</p>
        pub fn error_message(mut self, input: impl Into<std::string::String>) -> Self {
            self.error_message = Some(input.into());
            self
        }
        /// <p>The error message returned when the query execution failed to process, if applicable.</p>
        pub fn set_error_message(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.error_message = input;
            self
        }
        /// Consumes the builder and constructs a [`UnprocessedQueryExecutionId`](crate::model::UnprocessedQueryExecutionId)
        pub fn build(self) -> crate::model::UnprocessedQueryExecutionId {
            crate::model::UnprocessedQueryExecutionId {
                query_execution_id: self.query_execution_id,
                error_code: self.error_code,
                error_message: self.error_message,
            }
        }
    }
}
impl UnprocessedQueryExecutionId {
    /// Creates a new builder-style object to manufacture [`UnprocessedQueryExecutionId`](crate::model::UnprocessedQueryExecutionId)
    pub fn builder() -> crate::model::unprocessed_query_execution_id::Builder {
        crate::model::unprocessed_query_execution_id::Builder::default()
    }
}

/// <p>Information about a named query ID that could not be processed.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UnprocessedNamedQueryId {
    /// <p>The unique identifier of the named query.</p>
    pub named_query_id: std::option::Option<std::string::String>,
    /// <p>The error code returned when the processing request for the named query failed, if applicable.</p>
    pub error_code: std::option::Option<std::string::String>,
    /// <p>The error message returned when the processing request for the named query failed, if applicable.</p>
    pub error_message: std::option::Option<std::string::String>,
}
impl UnprocessedNamedQueryId {
    /// <p>The unique identifier of the named query.</p>
    pub fn named_query_id(&self) -> std::option::Option<&str> {
        self.named_query_id.as_deref()
    }
    /// <p>The error code returned when the processing request for the named query failed, if applicable.</p>
    pub fn error_code(&self) -> std::option::Option<&str> {
        self.error_code.as_deref()
    }
    /// <p>The error message returned when the processing request for the named query failed, if applicable.</p>
    pub fn error_message(&self) -> std::option::Option<&str> {
        self.error_message.as_deref()
    }
}
impl std::fmt::Debug for UnprocessedNamedQueryId {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UnprocessedNamedQueryId");
        formatter.field("named_query_id", &self.named_query_id);
        formatter.field("error_code", &self.error_code);
        formatter.field("error_message", &self.error_message);
        formatter.finish()
    }
}
/// See [`UnprocessedNamedQueryId`](crate::model::UnprocessedNamedQueryId)
pub mod unprocessed_named_query_id {

    /// A builder for [`UnprocessedNamedQueryId`](crate::model::UnprocessedNamedQueryId)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) named_query_id: std::option::Option<std::string::String>,
        pub(crate) error_code: std::option::Option<std::string::String>,
        pub(crate) error_message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The unique identifier of the named query.</p>
        pub fn named_query_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.named_query_id = Some(input.into());
            self
        }
        /// <p>The unique identifier of the named query.</p>
        pub fn set_named_query_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.named_query_id = input;
            self
        }
        /// <p>The error code returned when the processing request for the named query failed, if applicable.</p>
        pub fn error_code(mut self, input: impl Into<std::string::String>) -> Self {
            self.error_code = Some(input.into());
            self
        }
        /// <p>The error code returned when the processing request for the named query failed, if applicable.</p>
        pub fn set_error_code(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.error_code = input;
            self
        }
        /// <p>The error message returned when the processing request for the named query failed, if applicable.</p>
        pub fn error_message(mut self, input: impl Into<std::string::String>) -> Self {
            self.error_message = Some(input.into());
            self
        }
        /// <p>The error message returned when the processing request for the named query failed, if applicable.</p>
        pub fn set_error_message(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.error_message = input;
            self
        }
        /// Consumes the builder and constructs a [`UnprocessedNamedQueryId`](crate::model::UnprocessedNamedQueryId)
        pub fn build(self) -> crate::model::UnprocessedNamedQueryId {
            crate::model::UnprocessedNamedQueryId {
                named_query_id: self.named_query_id,
                error_code: self.error_code,
                error_message: self.error_message,
            }
        }
    }
}
impl UnprocessedNamedQueryId {
    /// Creates a new builder-style object to manufacture [`UnprocessedNamedQueryId`](crate::model::UnprocessedNamedQueryId)
    pub fn builder() -> crate::model::unprocessed_named_query_id::Builder {
        crate::model::unprocessed_named_query_id::Builder::default()
    }
}
