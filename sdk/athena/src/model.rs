// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// When writing a match expression against `WorkGroupState`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let workgroupstate = unimplemented!();
/// match workgroupstate {
///     WorkGroupState::Disabled => { /* ... */ },
///     WorkGroupState::Enabled => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `workgroupstate` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `WorkGroupState::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `WorkGroupState::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `WorkGroupState::NewFeature` is defined.
/// Specifically, when `workgroupstate` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `WorkGroupState::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum WorkGroupState {
    #[allow(missing_docs)] // documentation missing in model
    Disabled,
    #[allow(missing_docs)] // documentation missing in model
    Enabled,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for WorkGroupState {
    fn from(s: &str) -> Self {
        match s {
            "DISABLED" => WorkGroupState::Disabled,
            "ENABLED" => WorkGroupState::Enabled,
            other => WorkGroupState::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for WorkGroupState {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(WorkGroupState::from(s))
    }
}
impl WorkGroupState {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            WorkGroupState::Disabled => "DISABLED",
            WorkGroupState::Enabled => "ENABLED",
            WorkGroupState::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["DISABLED", "ENABLED"]
    }
}
impl AsRef<str> for WorkGroupState {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The configuration information that will be updated for this workgroup, which includes the location in Amazon S3 where query results are stored, the encryption option, if any, used for query results, whether the Amazon CloudWatch Metrics are enabled for the workgroup, whether the workgroup settings override the client-side settings, and the data usage limit for the amount of bytes scanned per query, if it is specified.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct WorkGroupConfigurationUpdates {
    /// <p>If set to "true", the settings for the workgroup override client-side settings. If set to "false" client-side settings are used. For more information, see <a href="https://docs.aws.amazon.com/athena/latest/ug/workgroups-settings-override.html">Workgroup Settings Override Client-Side Settings</a>.</p>
    #[doc(hidden)]
    pub enforce_work_group_configuration: std::option::Option<bool>,
    /// <p>The result configuration information about the queries in this workgroup that will be updated. Includes the updated results location and an updated option for encrypting query results.</p>
    #[doc(hidden)]
    pub result_configuration_updates: std::option::Option<crate::model::ResultConfigurationUpdates>,
    /// <p>Indicates whether this workgroup enables publishing metrics to Amazon CloudWatch.</p>
    #[doc(hidden)]
    pub publish_cloud_watch_metrics_enabled: std::option::Option<bool>,
    /// <p>The upper limit (cutoff) for the amount of bytes a single query in a workgroup is allowed to scan.</p>
    #[doc(hidden)]
    pub bytes_scanned_cutoff_per_query: std::option::Option<i64>,
    /// <p>Indicates that the data usage control limit per query is removed. <code>WorkGroupConfiguration$BytesScannedCutoffPerQuery</code> </p>
    #[doc(hidden)]
    pub remove_bytes_scanned_cutoff_per_query: std::option::Option<bool>,
    /// <p>If set to <code>true</code>, allows members assigned to a workgroup to specify Amazon S3 Requester Pays buckets in queries. If set to <code>false</code>, workgroup members cannot query data from Requester Pays buckets, and queries that retrieve data from Requester Pays buckets cause an error. The default is <code>false</code>. For more information about Requester Pays buckets, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/RequesterPaysBuckets.html">Requester Pays Buckets</a> in the <i>Amazon Simple Storage Service Developer Guide</i>.</p>
    #[doc(hidden)]
    pub requester_pays_enabled: std::option::Option<bool>,
    /// <p>The engine version requested when a workgroup is updated. After the update, all queries on the workgroup run on the requested engine version. If no value was previously set, the default is Auto. Queries on the <code>AmazonAthenaPreviewFunctionality</code> workgroup run on the preview engine regardless of this setting.</p>
    #[doc(hidden)]
    pub engine_version: std::option::Option<crate::model::EngineVersion>,
    /// <p>Removes content encryption configuration for a workgroup.</p>
    #[doc(hidden)]
    pub remove_customer_content_encryption_configuration: std::option::Option<bool>,
    /// <p>Contains a user defined string in JSON format for a Spark-enabled workgroup.</p>
    #[doc(hidden)]
    pub additional_configuration: std::option::Option<std::string::String>,
    /// <p>Contains the ARN of the execution role for the workgroup</p>
    #[doc(hidden)]
    pub execution_role: std::option::Option<std::string::String>,
    /// <p>Specifies the KMS key that is used to encrypt the user's data stores in Athena.</p>
    #[doc(hidden)]
    pub customer_content_encryption_configuration:
        std::option::Option<crate::model::CustomerContentEncryptionConfiguration>,
}
impl WorkGroupConfigurationUpdates {
    /// <p>If set to "true", the settings for the workgroup override client-side settings. If set to "false" client-side settings are used. For more information, see <a href="https://docs.aws.amazon.com/athena/latest/ug/workgroups-settings-override.html">Workgroup Settings Override Client-Side Settings</a>.</p>
    pub fn enforce_work_group_configuration(&self) -> std::option::Option<bool> {
        self.enforce_work_group_configuration
    }
    /// <p>The result configuration information about the queries in this workgroup that will be updated. Includes the updated results location and an updated option for encrypting query results.</p>
    pub fn result_configuration_updates(
        &self,
    ) -> std::option::Option<&crate::model::ResultConfigurationUpdates> {
        self.result_configuration_updates.as_ref()
    }
    /// <p>Indicates whether this workgroup enables publishing metrics to Amazon CloudWatch.</p>
    pub fn publish_cloud_watch_metrics_enabled(&self) -> std::option::Option<bool> {
        self.publish_cloud_watch_metrics_enabled
    }
    /// <p>The upper limit (cutoff) for the amount of bytes a single query in a workgroup is allowed to scan.</p>
    pub fn bytes_scanned_cutoff_per_query(&self) -> std::option::Option<i64> {
        self.bytes_scanned_cutoff_per_query
    }
    /// <p>Indicates that the data usage control limit per query is removed. <code>WorkGroupConfiguration$BytesScannedCutoffPerQuery</code> </p>
    pub fn remove_bytes_scanned_cutoff_per_query(&self) -> std::option::Option<bool> {
        self.remove_bytes_scanned_cutoff_per_query
    }
    /// <p>If set to <code>true</code>, allows members assigned to a workgroup to specify Amazon S3 Requester Pays buckets in queries. If set to <code>false</code>, workgroup members cannot query data from Requester Pays buckets, and queries that retrieve data from Requester Pays buckets cause an error. The default is <code>false</code>. For more information about Requester Pays buckets, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/RequesterPaysBuckets.html">Requester Pays Buckets</a> in the <i>Amazon Simple Storage Service Developer Guide</i>.</p>
    pub fn requester_pays_enabled(&self) -> std::option::Option<bool> {
        self.requester_pays_enabled
    }
    /// <p>The engine version requested when a workgroup is updated. After the update, all queries on the workgroup run on the requested engine version. If no value was previously set, the default is Auto. Queries on the <code>AmazonAthenaPreviewFunctionality</code> workgroup run on the preview engine regardless of this setting.</p>
    pub fn engine_version(&self) -> std::option::Option<&crate::model::EngineVersion> {
        self.engine_version.as_ref()
    }
    /// <p>Removes content encryption configuration for a workgroup.</p>
    pub fn remove_customer_content_encryption_configuration(&self) -> std::option::Option<bool> {
        self.remove_customer_content_encryption_configuration
    }
    /// <p>Contains a user defined string in JSON format for a Spark-enabled workgroup.</p>
    pub fn additional_configuration(&self) -> std::option::Option<&str> {
        self.additional_configuration.as_deref()
    }
    /// <p>Contains the ARN of the execution role for the workgroup</p>
    pub fn execution_role(&self) -> std::option::Option<&str> {
        self.execution_role.as_deref()
    }
    /// <p>Specifies the KMS key that is used to encrypt the user's data stores in Athena.</p>
    pub fn customer_content_encryption_configuration(
        &self,
    ) -> std::option::Option<&crate::model::CustomerContentEncryptionConfiguration> {
        self.customer_content_encryption_configuration.as_ref()
    }
}
/// See [`WorkGroupConfigurationUpdates`](crate::model::WorkGroupConfigurationUpdates).
pub mod work_group_configuration_updates {

    /// A builder for [`WorkGroupConfigurationUpdates`](crate::model::WorkGroupConfigurationUpdates).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) enforce_work_group_configuration: std::option::Option<bool>,
        pub(crate) result_configuration_updates:
            std::option::Option<crate::model::ResultConfigurationUpdates>,
        pub(crate) publish_cloud_watch_metrics_enabled: std::option::Option<bool>,
        pub(crate) bytes_scanned_cutoff_per_query: std::option::Option<i64>,
        pub(crate) remove_bytes_scanned_cutoff_per_query: std::option::Option<bool>,
        pub(crate) requester_pays_enabled: std::option::Option<bool>,
        pub(crate) engine_version: std::option::Option<crate::model::EngineVersion>,
        pub(crate) remove_customer_content_encryption_configuration: std::option::Option<bool>,
        pub(crate) additional_configuration: std::option::Option<std::string::String>,
        pub(crate) execution_role: std::option::Option<std::string::String>,
        pub(crate) customer_content_encryption_configuration:
            std::option::Option<crate::model::CustomerContentEncryptionConfiguration>,
    }
    impl Builder {
        /// <p>If set to "true", the settings for the workgroup override client-side settings. If set to "false" client-side settings are used. For more information, see <a href="https://docs.aws.amazon.com/athena/latest/ug/workgroups-settings-override.html">Workgroup Settings Override Client-Side Settings</a>.</p>
        pub fn enforce_work_group_configuration(mut self, input: bool) -> Self {
            self.enforce_work_group_configuration = Some(input);
            self
        }
        /// <p>If set to "true", the settings for the workgroup override client-side settings. If set to "false" client-side settings are used. For more information, see <a href="https://docs.aws.amazon.com/athena/latest/ug/workgroups-settings-override.html">Workgroup Settings Override Client-Side Settings</a>.</p>
        pub fn set_enforce_work_group_configuration(
            mut self,
            input: std::option::Option<bool>,
        ) -> Self {
            self.enforce_work_group_configuration = input;
            self
        }
        /// <p>The result configuration information about the queries in this workgroup that will be updated. Includes the updated results location and an updated option for encrypting query results.</p>
        pub fn result_configuration_updates(
            mut self,
            input: crate::model::ResultConfigurationUpdates,
        ) -> Self {
            self.result_configuration_updates = Some(input);
            self
        }
        /// <p>The result configuration information about the queries in this workgroup that will be updated. Includes the updated results location and an updated option for encrypting query results.</p>
        pub fn set_result_configuration_updates(
            mut self,
            input: std::option::Option<crate::model::ResultConfigurationUpdates>,
        ) -> Self {
            self.result_configuration_updates = input;
            self
        }
        /// <p>Indicates whether this workgroup enables publishing metrics to Amazon CloudWatch.</p>
        pub fn publish_cloud_watch_metrics_enabled(mut self, input: bool) -> Self {
            self.publish_cloud_watch_metrics_enabled = Some(input);
            self
        }
        /// <p>Indicates whether this workgroup enables publishing metrics to Amazon CloudWatch.</p>
        pub fn set_publish_cloud_watch_metrics_enabled(
            mut self,
            input: std::option::Option<bool>,
        ) -> Self {
            self.publish_cloud_watch_metrics_enabled = input;
            self
        }
        /// <p>The upper limit (cutoff) for the amount of bytes a single query in a workgroup is allowed to scan.</p>
        pub fn bytes_scanned_cutoff_per_query(mut self, input: i64) -> Self {
            self.bytes_scanned_cutoff_per_query = Some(input);
            self
        }
        /// <p>The upper limit (cutoff) for the amount of bytes a single query in a workgroup is allowed to scan.</p>
        pub fn set_bytes_scanned_cutoff_per_query(
            mut self,
            input: std::option::Option<i64>,
        ) -> Self {
            self.bytes_scanned_cutoff_per_query = input;
            self
        }
        /// <p>Indicates that the data usage control limit per query is removed. <code>WorkGroupConfiguration$BytesScannedCutoffPerQuery</code> </p>
        pub fn remove_bytes_scanned_cutoff_per_query(mut self, input: bool) -> Self {
            self.remove_bytes_scanned_cutoff_per_query = Some(input);
            self
        }
        /// <p>Indicates that the data usage control limit per query is removed. <code>WorkGroupConfiguration$BytesScannedCutoffPerQuery</code> </p>
        pub fn set_remove_bytes_scanned_cutoff_per_query(
            mut self,
            input: std::option::Option<bool>,
        ) -> Self {
            self.remove_bytes_scanned_cutoff_per_query = input;
            self
        }
        /// <p>If set to <code>true</code>, allows members assigned to a workgroup to specify Amazon S3 Requester Pays buckets in queries. If set to <code>false</code>, workgroup members cannot query data from Requester Pays buckets, and queries that retrieve data from Requester Pays buckets cause an error. The default is <code>false</code>. For more information about Requester Pays buckets, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/RequesterPaysBuckets.html">Requester Pays Buckets</a> in the <i>Amazon Simple Storage Service Developer Guide</i>.</p>
        pub fn requester_pays_enabled(mut self, input: bool) -> Self {
            self.requester_pays_enabled = Some(input);
            self
        }
        /// <p>If set to <code>true</code>, allows members assigned to a workgroup to specify Amazon S3 Requester Pays buckets in queries. If set to <code>false</code>, workgroup members cannot query data from Requester Pays buckets, and queries that retrieve data from Requester Pays buckets cause an error. The default is <code>false</code>. For more information about Requester Pays buckets, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/RequesterPaysBuckets.html">Requester Pays Buckets</a> in the <i>Amazon Simple Storage Service Developer Guide</i>.</p>
        pub fn set_requester_pays_enabled(mut self, input: std::option::Option<bool>) -> Self {
            self.requester_pays_enabled = input;
            self
        }
        /// <p>The engine version requested when a workgroup is updated. After the update, all queries on the workgroup run on the requested engine version. If no value was previously set, the default is Auto. Queries on the <code>AmazonAthenaPreviewFunctionality</code> workgroup run on the preview engine regardless of this setting.</p>
        pub fn engine_version(mut self, input: crate::model::EngineVersion) -> Self {
            self.engine_version = Some(input);
            self
        }
        /// <p>The engine version requested when a workgroup is updated. After the update, all queries on the workgroup run on the requested engine version. If no value was previously set, the default is Auto. Queries on the <code>AmazonAthenaPreviewFunctionality</code> workgroup run on the preview engine regardless of this setting.</p>
        pub fn set_engine_version(
            mut self,
            input: std::option::Option<crate::model::EngineVersion>,
        ) -> Self {
            self.engine_version = input;
            self
        }
        /// <p>Removes content encryption configuration for a workgroup.</p>
        pub fn remove_customer_content_encryption_configuration(mut self, input: bool) -> Self {
            self.remove_customer_content_encryption_configuration = Some(input);
            self
        }
        /// <p>Removes content encryption configuration for a workgroup.</p>
        pub fn set_remove_customer_content_encryption_configuration(
            mut self,
            input: std::option::Option<bool>,
        ) -> Self {
            self.remove_customer_content_encryption_configuration = input;
            self
        }
        /// <p>Contains a user defined string in JSON format for a Spark-enabled workgroup.</p>
        pub fn additional_configuration(mut self, input: impl Into<std::string::String>) -> Self {
            self.additional_configuration = Some(input.into());
            self
        }
        /// <p>Contains a user defined string in JSON format for a Spark-enabled workgroup.</p>
        pub fn set_additional_configuration(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.additional_configuration = input;
            self
        }
        /// <p>Contains the ARN of the execution role for the workgroup</p>
        pub fn execution_role(mut self, input: impl Into<std::string::String>) -> Self {
            self.execution_role = Some(input.into());
            self
        }
        /// <p>Contains the ARN of the execution role for the workgroup</p>
        pub fn set_execution_role(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.execution_role = input;
            self
        }
        /// <p>Specifies the KMS key that is used to encrypt the user's data stores in Athena.</p>
        pub fn customer_content_encryption_configuration(
            mut self,
            input: crate::model::CustomerContentEncryptionConfiguration,
        ) -> Self {
            self.customer_content_encryption_configuration = Some(input);
            self
        }
        /// <p>Specifies the KMS key that is used to encrypt the user's data stores in Athena.</p>
        pub fn set_customer_content_encryption_configuration(
            mut self,
            input: std::option::Option<crate::model::CustomerContentEncryptionConfiguration>,
        ) -> Self {
            self.customer_content_encryption_configuration = input;
            self
        }
        /// Consumes the builder and constructs a [`WorkGroupConfigurationUpdates`](crate::model::WorkGroupConfigurationUpdates).
        pub fn build(self) -> crate::model::WorkGroupConfigurationUpdates {
            crate::model::WorkGroupConfigurationUpdates {
                enforce_work_group_configuration: self.enforce_work_group_configuration,
                result_configuration_updates: self.result_configuration_updates,
                publish_cloud_watch_metrics_enabled: self.publish_cloud_watch_metrics_enabled,
                bytes_scanned_cutoff_per_query: self.bytes_scanned_cutoff_per_query,
                remove_bytes_scanned_cutoff_per_query: self.remove_bytes_scanned_cutoff_per_query,
                requester_pays_enabled: self.requester_pays_enabled,
                engine_version: self.engine_version,
                remove_customer_content_encryption_configuration: self
                    .remove_customer_content_encryption_configuration,
                additional_configuration: self.additional_configuration,
                execution_role: self.execution_role,
                customer_content_encryption_configuration: self
                    .customer_content_encryption_configuration,
            }
        }
    }
}
impl WorkGroupConfigurationUpdates {
    /// Creates a new builder-style object to manufacture [`WorkGroupConfigurationUpdates`](crate::model::WorkGroupConfigurationUpdates).
    pub fn builder() -> crate::model::work_group_configuration_updates::Builder {
        crate::model::work_group_configuration_updates::Builder::default()
    }
}

/// <p>Specifies the KMS key that is used to encrypt the user's data stores in Athena.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CustomerContentEncryptionConfiguration {
    /// <p>The KMS key that is used to encrypt the user's data stores in Athena.</p>
    #[doc(hidden)]
    pub kms_key: std::option::Option<std::string::String>,
}
impl CustomerContentEncryptionConfiguration {
    /// <p>The KMS key that is used to encrypt the user's data stores in Athena.</p>
    pub fn kms_key(&self) -> std::option::Option<&str> {
        self.kms_key.as_deref()
    }
}
/// See [`CustomerContentEncryptionConfiguration`](crate::model::CustomerContentEncryptionConfiguration).
pub mod customer_content_encryption_configuration {

    /// A builder for [`CustomerContentEncryptionConfiguration`](crate::model::CustomerContentEncryptionConfiguration).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) kms_key: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The KMS key that is used to encrypt the user's data stores in Athena.</p>
        pub fn kms_key(mut self, input: impl Into<std::string::String>) -> Self {
            self.kms_key = Some(input.into());
            self
        }
        /// <p>The KMS key that is used to encrypt the user's data stores in Athena.</p>
        pub fn set_kms_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.kms_key = input;
            self
        }
        /// Consumes the builder and constructs a [`CustomerContentEncryptionConfiguration`](crate::model::CustomerContentEncryptionConfiguration).
        pub fn build(self) -> crate::model::CustomerContentEncryptionConfiguration {
            crate::model::CustomerContentEncryptionConfiguration {
                kms_key: self.kms_key,
            }
        }
    }
}
impl CustomerContentEncryptionConfiguration {
    /// Creates a new builder-style object to manufacture [`CustomerContentEncryptionConfiguration`](crate::model::CustomerContentEncryptionConfiguration).
    pub fn builder() -> crate::model::customer_content_encryption_configuration::Builder {
        crate::model::customer_content_encryption_configuration::Builder::default()
    }
}

/// <p>The Athena engine version for running queries, or the PySpark engine version for running sessions.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct EngineVersion {
    /// <p>The engine version requested by the user. Possible values are determined by the output of <code>ListEngineVersions</code>, including Auto. The default is Auto.</p>
    #[doc(hidden)]
    pub selected_engine_version: std::option::Option<std::string::String>,
    /// <p>Read only. The engine version on which the query runs. If the user requests a valid engine version other than Auto, the effective engine version is the same as the engine version that the user requested. If the user requests Auto, the effective engine version is chosen by Athena. When a request to update the engine version is made by a <code>CreateWorkGroup</code> or <code>UpdateWorkGroup</code> operation, the <code>EffectiveEngineVersion</code> field is ignored.</p>
    #[doc(hidden)]
    pub effective_engine_version: std::option::Option<std::string::String>,
}
impl EngineVersion {
    /// <p>The engine version requested by the user. Possible values are determined by the output of <code>ListEngineVersions</code>, including Auto. The default is Auto.</p>
    pub fn selected_engine_version(&self) -> std::option::Option<&str> {
        self.selected_engine_version.as_deref()
    }
    /// <p>Read only. The engine version on which the query runs. If the user requests a valid engine version other than Auto, the effective engine version is the same as the engine version that the user requested. If the user requests Auto, the effective engine version is chosen by Athena. When a request to update the engine version is made by a <code>CreateWorkGroup</code> or <code>UpdateWorkGroup</code> operation, the <code>EffectiveEngineVersion</code> field is ignored.</p>
    pub fn effective_engine_version(&self) -> std::option::Option<&str> {
        self.effective_engine_version.as_deref()
    }
}
/// See [`EngineVersion`](crate::model::EngineVersion).
pub mod engine_version {

    /// A builder for [`EngineVersion`](crate::model::EngineVersion).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) selected_engine_version: std::option::Option<std::string::String>,
        pub(crate) effective_engine_version: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The engine version requested by the user. Possible values are determined by the output of <code>ListEngineVersions</code>, including Auto. The default is Auto.</p>
        pub fn selected_engine_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.selected_engine_version = Some(input.into());
            self
        }
        /// <p>The engine version requested by the user. Possible values are determined by the output of <code>ListEngineVersions</code>, including Auto. The default is Auto.</p>
        pub fn set_selected_engine_version(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.selected_engine_version = input;
            self
        }
        /// <p>Read only. The engine version on which the query runs. If the user requests a valid engine version other than Auto, the effective engine version is the same as the engine version that the user requested. If the user requests Auto, the effective engine version is chosen by Athena. When a request to update the engine version is made by a <code>CreateWorkGroup</code> or <code>UpdateWorkGroup</code> operation, the <code>EffectiveEngineVersion</code> field is ignored.</p>
        pub fn effective_engine_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.effective_engine_version = Some(input.into());
            self
        }
        /// <p>Read only. The engine version on which the query runs. If the user requests a valid engine version other than Auto, the effective engine version is the same as the engine version that the user requested. If the user requests Auto, the effective engine version is chosen by Athena. When a request to update the engine version is made by a <code>CreateWorkGroup</code> or <code>UpdateWorkGroup</code> operation, the <code>EffectiveEngineVersion</code> field is ignored.</p>
        pub fn set_effective_engine_version(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.effective_engine_version = input;
            self
        }
        /// Consumes the builder and constructs a [`EngineVersion`](crate::model::EngineVersion).
        pub fn build(self) -> crate::model::EngineVersion {
            crate::model::EngineVersion {
                selected_engine_version: self.selected_engine_version,
                effective_engine_version: self.effective_engine_version,
            }
        }
    }
}
impl EngineVersion {
    /// Creates a new builder-style object to manufacture [`EngineVersion`](crate::model::EngineVersion).
    pub fn builder() -> crate::model::engine_version::Builder {
        crate::model::engine_version::Builder::default()
    }
}

/// <p>The information about the updates in the query results, such as output location and encryption configuration for the query results.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ResultConfigurationUpdates {
    /// <p>The location in Amazon S3 where your query results are stored, such as <code>s3://path/to/query/bucket/</code>. For more information, see <a href="https://docs.aws.amazon.com/athena/latest/ug/querying.html">Query Results</a> If workgroup settings override client-side settings, then the query uses the location for the query results and the encryption configuration that are specified for the workgroup. The "workgroup settings override" is specified in <code>EnforceWorkGroupConfiguration</code> (true/false) in the <code>WorkGroupConfiguration</code>. See <code>WorkGroupConfiguration$EnforceWorkGroupConfiguration</code>.</p>
    #[doc(hidden)]
    pub output_location: std::option::Option<std::string::String>,
    /// <p>If set to "true", indicates that the previously-specified query results location (also known as a client-side setting) for queries in this workgroup should be ignored and set to null. If set to "false" or not set, and a value is present in the <code>OutputLocation</code> in <code>ResultConfigurationUpdates</code> (the client-side setting), the <code>OutputLocation</code> in the workgroup's <code>ResultConfiguration</code> will be updated with the new value. For more information, see <a href="https://docs.aws.amazon.com/athena/latest/ug/workgroups-settings-override.html">Workgroup Settings Override Client-Side Settings</a>.</p>
    #[doc(hidden)]
    pub remove_output_location: std::option::Option<bool>,
    /// <p>The encryption configuration for the query results.</p>
    #[doc(hidden)]
    pub encryption_configuration: std::option::Option<crate::model::EncryptionConfiguration>,
    /// <p>If set to "true", indicates that the previously-specified encryption configuration (also known as the client-side setting) for queries in this workgroup should be ignored and set to null. If set to "false" or not set, and a value is present in the <code>EncryptionConfiguration</code> in <code>ResultConfigurationUpdates</code> (the client-side setting), the <code>EncryptionConfiguration</code> in the workgroup's <code>ResultConfiguration</code> will be updated with the new value. For more information, see <a href="https://docs.aws.amazon.com/athena/latest/ug/workgroups-settings-override.html">Workgroup Settings Override Client-Side Settings</a>.</p>
    #[doc(hidden)]
    pub remove_encryption_configuration: std::option::Option<bool>,
    /// <p>The Amazon Web Services account ID that you expect to be the owner of the Amazon S3 bucket specified by <code>ResultConfiguration$OutputLocation</code>. If set, Athena uses the value for <code>ExpectedBucketOwner</code> when it makes Amazon S3 calls to your specified output location. If the <code>ExpectedBucketOwner</code> Amazon Web Services account ID does not match the actual owner of the Amazon S3 bucket, the call fails with a permissions error.</p>
    /// <p>If workgroup settings override client-side settings, then the query uses the <code>ExpectedBucketOwner</code> setting that is specified for the workgroup, and also uses the location for storing query results specified in the workgroup. See <code>WorkGroupConfiguration$EnforceWorkGroupConfiguration</code> and <a href="https://docs.aws.amazon.com/athena/latest/ug/workgroups-settings-override.html">Workgroup Settings Override Client-Side Settings</a>.</p>
    #[doc(hidden)]
    pub expected_bucket_owner: std::option::Option<std::string::String>,
    /// <p>If set to "true", removes the Amazon Web Services account ID previously specified for <code>ResultConfiguration$ExpectedBucketOwner</code>. If set to "false" or not set, and a value is present in the <code>ExpectedBucketOwner</code> in <code>ResultConfigurationUpdates</code> (the client-side setting), the <code>ExpectedBucketOwner</code> in the workgroup's <code>ResultConfiguration</code> is updated with the new value. For more information, see <a href="https://docs.aws.amazon.com/athena/latest/ug/workgroups-settings-override.html">Workgroup Settings Override Client-Side Settings</a>.</p>
    #[doc(hidden)]
    pub remove_expected_bucket_owner: std::option::Option<bool>,
    /// <p>The ACL configuration for the query results.</p>
    #[doc(hidden)]
    pub acl_configuration: std::option::Option<crate::model::AclConfiguration>,
    /// <p>If set to <code>true</code>, indicates that the previously-specified ACL configuration for queries in this workgroup should be ignored and set to null. If set to <code>false</code> or not set, and a value is present in the <code>AclConfiguration</code> of <code>ResultConfigurationUpdates</code>, the <code>AclConfiguration</code> in the workgroup's <code>ResultConfiguration</code> is updated with the new value. For more information, see <a href="https://docs.aws.amazon.com/athena/latest/ug/workgroups-settings-override.html">Workgroup Settings Override Client-Side Settings</a>.</p>
    #[doc(hidden)]
    pub remove_acl_configuration: std::option::Option<bool>,
}
impl ResultConfigurationUpdates {
    /// <p>The location in Amazon S3 where your query results are stored, such as <code>s3://path/to/query/bucket/</code>. For more information, see <a href="https://docs.aws.amazon.com/athena/latest/ug/querying.html">Query Results</a> If workgroup settings override client-side settings, then the query uses the location for the query results and the encryption configuration that are specified for the workgroup. The "workgroup settings override" is specified in <code>EnforceWorkGroupConfiguration</code> (true/false) in the <code>WorkGroupConfiguration</code>. See <code>WorkGroupConfiguration$EnforceWorkGroupConfiguration</code>.</p>
    pub fn output_location(&self) -> std::option::Option<&str> {
        self.output_location.as_deref()
    }
    /// <p>If set to "true", indicates that the previously-specified query results location (also known as a client-side setting) for queries in this workgroup should be ignored and set to null. If set to "false" or not set, and a value is present in the <code>OutputLocation</code> in <code>ResultConfigurationUpdates</code> (the client-side setting), the <code>OutputLocation</code> in the workgroup's <code>ResultConfiguration</code> will be updated with the new value. For more information, see <a href="https://docs.aws.amazon.com/athena/latest/ug/workgroups-settings-override.html">Workgroup Settings Override Client-Side Settings</a>.</p>
    pub fn remove_output_location(&self) -> std::option::Option<bool> {
        self.remove_output_location
    }
    /// <p>The encryption configuration for the query results.</p>
    pub fn encryption_configuration(
        &self,
    ) -> std::option::Option<&crate::model::EncryptionConfiguration> {
        self.encryption_configuration.as_ref()
    }
    /// <p>If set to "true", indicates that the previously-specified encryption configuration (also known as the client-side setting) for queries in this workgroup should be ignored and set to null. If set to "false" or not set, and a value is present in the <code>EncryptionConfiguration</code> in <code>ResultConfigurationUpdates</code> (the client-side setting), the <code>EncryptionConfiguration</code> in the workgroup's <code>ResultConfiguration</code> will be updated with the new value. For more information, see <a href="https://docs.aws.amazon.com/athena/latest/ug/workgroups-settings-override.html">Workgroup Settings Override Client-Side Settings</a>.</p>
    pub fn remove_encryption_configuration(&self) -> std::option::Option<bool> {
        self.remove_encryption_configuration
    }
    /// <p>The Amazon Web Services account ID that you expect to be the owner of the Amazon S3 bucket specified by <code>ResultConfiguration$OutputLocation</code>. If set, Athena uses the value for <code>ExpectedBucketOwner</code> when it makes Amazon S3 calls to your specified output location. If the <code>ExpectedBucketOwner</code> Amazon Web Services account ID does not match the actual owner of the Amazon S3 bucket, the call fails with a permissions error.</p>
    /// <p>If workgroup settings override client-side settings, then the query uses the <code>ExpectedBucketOwner</code> setting that is specified for the workgroup, and also uses the location for storing query results specified in the workgroup. See <code>WorkGroupConfiguration$EnforceWorkGroupConfiguration</code> and <a href="https://docs.aws.amazon.com/athena/latest/ug/workgroups-settings-override.html">Workgroup Settings Override Client-Side Settings</a>.</p>
    pub fn expected_bucket_owner(&self) -> std::option::Option<&str> {
        self.expected_bucket_owner.as_deref()
    }
    /// <p>If set to "true", removes the Amazon Web Services account ID previously specified for <code>ResultConfiguration$ExpectedBucketOwner</code>. If set to "false" or not set, and a value is present in the <code>ExpectedBucketOwner</code> in <code>ResultConfigurationUpdates</code> (the client-side setting), the <code>ExpectedBucketOwner</code> in the workgroup's <code>ResultConfiguration</code> is updated with the new value. For more information, see <a href="https://docs.aws.amazon.com/athena/latest/ug/workgroups-settings-override.html">Workgroup Settings Override Client-Side Settings</a>.</p>
    pub fn remove_expected_bucket_owner(&self) -> std::option::Option<bool> {
        self.remove_expected_bucket_owner
    }
    /// <p>The ACL configuration for the query results.</p>
    pub fn acl_configuration(&self) -> std::option::Option<&crate::model::AclConfiguration> {
        self.acl_configuration.as_ref()
    }
    /// <p>If set to <code>true</code>, indicates that the previously-specified ACL configuration for queries in this workgroup should be ignored and set to null. If set to <code>false</code> or not set, and a value is present in the <code>AclConfiguration</code> of <code>ResultConfigurationUpdates</code>, the <code>AclConfiguration</code> in the workgroup's <code>ResultConfiguration</code> is updated with the new value. For more information, see <a href="https://docs.aws.amazon.com/athena/latest/ug/workgroups-settings-override.html">Workgroup Settings Override Client-Side Settings</a>.</p>
    pub fn remove_acl_configuration(&self) -> std::option::Option<bool> {
        self.remove_acl_configuration
    }
}
/// See [`ResultConfigurationUpdates`](crate::model::ResultConfigurationUpdates).
pub mod result_configuration_updates {

    /// A builder for [`ResultConfigurationUpdates`](crate::model::ResultConfigurationUpdates).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) output_location: std::option::Option<std::string::String>,
        pub(crate) remove_output_location: std::option::Option<bool>,
        pub(crate) encryption_configuration:
            std::option::Option<crate::model::EncryptionConfiguration>,
        pub(crate) remove_encryption_configuration: std::option::Option<bool>,
        pub(crate) expected_bucket_owner: std::option::Option<std::string::String>,
        pub(crate) remove_expected_bucket_owner: std::option::Option<bool>,
        pub(crate) acl_configuration: std::option::Option<crate::model::AclConfiguration>,
        pub(crate) remove_acl_configuration: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>The location in Amazon S3 where your query results are stored, such as <code>s3://path/to/query/bucket/</code>. For more information, see <a href="https://docs.aws.amazon.com/athena/latest/ug/querying.html">Query Results</a> If workgroup settings override client-side settings, then the query uses the location for the query results and the encryption configuration that are specified for the workgroup. The "workgroup settings override" is specified in <code>EnforceWorkGroupConfiguration</code> (true/false) in the <code>WorkGroupConfiguration</code>. See <code>WorkGroupConfiguration$EnforceWorkGroupConfiguration</code>.</p>
        pub fn output_location(mut self, input: impl Into<std::string::String>) -> Self {
            self.output_location = Some(input.into());
            self
        }
        /// <p>The location in Amazon S3 where your query results are stored, such as <code>s3://path/to/query/bucket/</code>. For more information, see <a href="https://docs.aws.amazon.com/athena/latest/ug/querying.html">Query Results</a> If workgroup settings override client-side settings, then the query uses the location for the query results and the encryption configuration that are specified for the workgroup. The "workgroup settings override" is specified in <code>EnforceWorkGroupConfiguration</code> (true/false) in the <code>WorkGroupConfiguration</code>. See <code>WorkGroupConfiguration$EnforceWorkGroupConfiguration</code>.</p>
        pub fn set_output_location(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.output_location = input;
            self
        }
        /// <p>If set to "true", indicates that the previously-specified query results location (also known as a client-side setting) for queries in this workgroup should be ignored and set to null. If set to "false" or not set, and a value is present in the <code>OutputLocation</code> in <code>ResultConfigurationUpdates</code> (the client-side setting), the <code>OutputLocation</code> in the workgroup's <code>ResultConfiguration</code> will be updated with the new value. For more information, see <a href="https://docs.aws.amazon.com/athena/latest/ug/workgroups-settings-override.html">Workgroup Settings Override Client-Side Settings</a>.</p>
        pub fn remove_output_location(mut self, input: bool) -> Self {
            self.remove_output_location = Some(input);
            self
        }
        /// <p>If set to "true", indicates that the previously-specified query results location (also known as a client-side setting) for queries in this workgroup should be ignored and set to null. If set to "false" or not set, and a value is present in the <code>OutputLocation</code> in <code>ResultConfigurationUpdates</code> (the client-side setting), the <code>OutputLocation</code> in the workgroup's <code>ResultConfiguration</code> will be updated with the new value. For more information, see <a href="https://docs.aws.amazon.com/athena/latest/ug/workgroups-settings-override.html">Workgroup Settings Override Client-Side Settings</a>.</p>
        pub fn set_remove_output_location(mut self, input: std::option::Option<bool>) -> Self {
            self.remove_output_location = input;
            self
        }
        /// <p>The encryption configuration for the query results.</p>
        pub fn encryption_configuration(
            mut self,
            input: crate::model::EncryptionConfiguration,
        ) -> Self {
            self.encryption_configuration = Some(input);
            self
        }
        /// <p>The encryption configuration for the query results.</p>
        pub fn set_encryption_configuration(
            mut self,
            input: std::option::Option<crate::model::EncryptionConfiguration>,
        ) -> Self {
            self.encryption_configuration = input;
            self
        }
        /// <p>If set to "true", indicates that the previously-specified encryption configuration (also known as the client-side setting) for queries in this workgroup should be ignored and set to null. If set to "false" or not set, and a value is present in the <code>EncryptionConfiguration</code> in <code>ResultConfigurationUpdates</code> (the client-side setting), the <code>EncryptionConfiguration</code> in the workgroup's <code>ResultConfiguration</code> will be updated with the new value. For more information, see <a href="https://docs.aws.amazon.com/athena/latest/ug/workgroups-settings-override.html">Workgroup Settings Override Client-Side Settings</a>.</p>
        pub fn remove_encryption_configuration(mut self, input: bool) -> Self {
            self.remove_encryption_configuration = Some(input);
            self
        }
        /// <p>If set to "true", indicates that the previously-specified encryption configuration (also known as the client-side setting) for queries in this workgroup should be ignored and set to null. If set to "false" or not set, and a value is present in the <code>EncryptionConfiguration</code> in <code>ResultConfigurationUpdates</code> (the client-side setting), the <code>EncryptionConfiguration</code> in the workgroup's <code>ResultConfiguration</code> will be updated with the new value. For more information, see <a href="https://docs.aws.amazon.com/athena/latest/ug/workgroups-settings-override.html">Workgroup Settings Override Client-Side Settings</a>.</p>
        pub fn set_remove_encryption_configuration(
            mut self,
            input: std::option::Option<bool>,
        ) -> Self {
            self.remove_encryption_configuration = input;
            self
        }
        /// <p>The Amazon Web Services account ID that you expect to be the owner of the Amazon S3 bucket specified by <code>ResultConfiguration$OutputLocation</code>. If set, Athena uses the value for <code>ExpectedBucketOwner</code> when it makes Amazon S3 calls to your specified output location. If the <code>ExpectedBucketOwner</code> Amazon Web Services account ID does not match the actual owner of the Amazon S3 bucket, the call fails with a permissions error.</p>
        /// <p>If workgroup settings override client-side settings, then the query uses the <code>ExpectedBucketOwner</code> setting that is specified for the workgroup, and also uses the location for storing query results specified in the workgroup. See <code>WorkGroupConfiguration$EnforceWorkGroupConfiguration</code> and <a href="https://docs.aws.amazon.com/athena/latest/ug/workgroups-settings-override.html">Workgroup Settings Override Client-Side Settings</a>.</p>
        pub fn expected_bucket_owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.expected_bucket_owner = Some(input.into());
            self
        }
        /// <p>The Amazon Web Services account ID that you expect to be the owner of the Amazon S3 bucket specified by <code>ResultConfiguration$OutputLocation</code>. If set, Athena uses the value for <code>ExpectedBucketOwner</code> when it makes Amazon S3 calls to your specified output location. If the <code>ExpectedBucketOwner</code> Amazon Web Services account ID does not match the actual owner of the Amazon S3 bucket, the call fails with a permissions error.</p>
        /// <p>If workgroup settings override client-side settings, then the query uses the <code>ExpectedBucketOwner</code> setting that is specified for the workgroup, and also uses the location for storing query results specified in the workgroup. See <code>WorkGroupConfiguration$EnforceWorkGroupConfiguration</code> and <a href="https://docs.aws.amazon.com/athena/latest/ug/workgroups-settings-override.html">Workgroup Settings Override Client-Side Settings</a>.</p>
        pub fn set_expected_bucket_owner(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.expected_bucket_owner = input;
            self
        }
        /// <p>If set to "true", removes the Amazon Web Services account ID previously specified for <code>ResultConfiguration$ExpectedBucketOwner</code>. If set to "false" or not set, and a value is present in the <code>ExpectedBucketOwner</code> in <code>ResultConfigurationUpdates</code> (the client-side setting), the <code>ExpectedBucketOwner</code> in the workgroup's <code>ResultConfiguration</code> is updated with the new value. For more information, see <a href="https://docs.aws.amazon.com/athena/latest/ug/workgroups-settings-override.html">Workgroup Settings Override Client-Side Settings</a>.</p>
        pub fn remove_expected_bucket_owner(mut self, input: bool) -> Self {
            self.remove_expected_bucket_owner = Some(input);
            self
        }
        /// <p>If set to "true", removes the Amazon Web Services account ID previously specified for <code>ResultConfiguration$ExpectedBucketOwner</code>. If set to "false" or not set, and a value is present in the <code>ExpectedBucketOwner</code> in <code>ResultConfigurationUpdates</code> (the client-side setting), the <code>ExpectedBucketOwner</code> in the workgroup's <code>ResultConfiguration</code> is updated with the new value. For more information, see <a href="https://docs.aws.amazon.com/athena/latest/ug/workgroups-settings-override.html">Workgroup Settings Override Client-Side Settings</a>.</p>
        pub fn set_remove_expected_bucket_owner(
            mut self,
            input: std::option::Option<bool>,
        ) -> Self {
            self.remove_expected_bucket_owner = input;
            self
        }
        /// <p>The ACL configuration for the query results.</p>
        pub fn acl_configuration(mut self, input: crate::model::AclConfiguration) -> Self {
            self.acl_configuration = Some(input);
            self
        }
        /// <p>The ACL configuration for the query results.</p>
        pub fn set_acl_configuration(
            mut self,
            input: std::option::Option<crate::model::AclConfiguration>,
        ) -> Self {
            self.acl_configuration = input;
            self
        }
        /// <p>If set to <code>true</code>, indicates that the previously-specified ACL configuration for queries in this workgroup should be ignored and set to null. If set to <code>false</code> or not set, and a value is present in the <code>AclConfiguration</code> of <code>ResultConfigurationUpdates</code>, the <code>AclConfiguration</code> in the workgroup's <code>ResultConfiguration</code> is updated with the new value. For more information, see <a href="https://docs.aws.amazon.com/athena/latest/ug/workgroups-settings-override.html">Workgroup Settings Override Client-Side Settings</a>.</p>
        pub fn remove_acl_configuration(mut self, input: bool) -> Self {
            self.remove_acl_configuration = Some(input);
            self
        }
        /// <p>If set to <code>true</code>, indicates that the previously-specified ACL configuration for queries in this workgroup should be ignored and set to null. If set to <code>false</code> or not set, and a value is present in the <code>AclConfiguration</code> of <code>ResultConfigurationUpdates</code>, the <code>AclConfiguration</code> in the workgroup's <code>ResultConfiguration</code> is updated with the new value. For more information, see <a href="https://docs.aws.amazon.com/athena/latest/ug/workgroups-settings-override.html">Workgroup Settings Override Client-Side Settings</a>.</p>
        pub fn set_remove_acl_configuration(mut self, input: std::option::Option<bool>) -> Self {
            self.remove_acl_configuration = input;
            self
        }
        /// Consumes the builder and constructs a [`ResultConfigurationUpdates`](crate::model::ResultConfigurationUpdates).
        pub fn build(self) -> crate::model::ResultConfigurationUpdates {
            crate::model::ResultConfigurationUpdates {
                output_location: self.output_location,
                remove_output_location: self.remove_output_location,
                encryption_configuration: self.encryption_configuration,
                remove_encryption_configuration: self.remove_encryption_configuration,
                expected_bucket_owner: self.expected_bucket_owner,
                remove_expected_bucket_owner: self.remove_expected_bucket_owner,
                acl_configuration: self.acl_configuration,
                remove_acl_configuration: self.remove_acl_configuration,
            }
        }
    }
}
impl ResultConfigurationUpdates {
    /// Creates a new builder-style object to manufacture [`ResultConfigurationUpdates`](crate::model::ResultConfigurationUpdates).
    pub fn builder() -> crate::model::result_configuration_updates::Builder {
        crate::model::result_configuration_updates::Builder::default()
    }
}

/// <p>Indicates that an Amazon S3 canned ACL should be set to control ownership of stored query results. When Athena stores query results in Amazon S3, the canned ACL is set with the <code>x-amz-acl</code> request header. For more information about S3 Object Ownership, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/about-object-ownership.html#object-ownership-overview">Object Ownership settings</a> in the <i>Amazon S3 User Guide</i>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AclConfiguration {
    /// <p>The Amazon S3 canned ACL that Athena should specify when storing query results. Currently the only supported canned ACL is <code>BUCKET_OWNER_FULL_CONTROL</code>. If a query runs in a workgroup and the workgroup overrides client-side settings, then the Amazon S3 canned ACL specified in the workgroup's settings is used for all queries that run in the workgroup. For more information about Amazon S3 canned ACLs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/acl-overview.html#canned-acl">Canned ACL</a> in the <i>Amazon S3 User Guide</i>.</p>
    #[doc(hidden)]
    pub s3_acl_option: std::option::Option<crate::model::S3AclOption>,
}
impl AclConfiguration {
    /// <p>The Amazon S3 canned ACL that Athena should specify when storing query results. Currently the only supported canned ACL is <code>BUCKET_OWNER_FULL_CONTROL</code>. If a query runs in a workgroup and the workgroup overrides client-side settings, then the Amazon S3 canned ACL specified in the workgroup's settings is used for all queries that run in the workgroup. For more information about Amazon S3 canned ACLs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/acl-overview.html#canned-acl">Canned ACL</a> in the <i>Amazon S3 User Guide</i>.</p>
    pub fn s3_acl_option(&self) -> std::option::Option<&crate::model::S3AclOption> {
        self.s3_acl_option.as_ref()
    }
}
/// See [`AclConfiguration`](crate::model::AclConfiguration).
pub mod acl_configuration {

    /// A builder for [`AclConfiguration`](crate::model::AclConfiguration).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) s3_acl_option: std::option::Option<crate::model::S3AclOption>,
    }
    impl Builder {
        /// <p>The Amazon S3 canned ACL that Athena should specify when storing query results. Currently the only supported canned ACL is <code>BUCKET_OWNER_FULL_CONTROL</code>. If a query runs in a workgroup and the workgroup overrides client-side settings, then the Amazon S3 canned ACL specified in the workgroup's settings is used for all queries that run in the workgroup. For more information about Amazon S3 canned ACLs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/acl-overview.html#canned-acl">Canned ACL</a> in the <i>Amazon S3 User Guide</i>.</p>
        pub fn s3_acl_option(mut self, input: crate::model::S3AclOption) -> Self {
            self.s3_acl_option = Some(input);
            self
        }
        /// <p>The Amazon S3 canned ACL that Athena should specify when storing query results. Currently the only supported canned ACL is <code>BUCKET_OWNER_FULL_CONTROL</code>. If a query runs in a workgroup and the workgroup overrides client-side settings, then the Amazon S3 canned ACL specified in the workgroup's settings is used for all queries that run in the workgroup. For more information about Amazon S3 canned ACLs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/acl-overview.html#canned-acl">Canned ACL</a> in the <i>Amazon S3 User Guide</i>.</p>
        pub fn set_s3_acl_option(
            mut self,
            input: std::option::Option<crate::model::S3AclOption>,
        ) -> Self {
            self.s3_acl_option = input;
            self
        }
        /// Consumes the builder and constructs a [`AclConfiguration`](crate::model::AclConfiguration).
        pub fn build(self) -> crate::model::AclConfiguration {
            crate::model::AclConfiguration {
                s3_acl_option: self.s3_acl_option,
            }
        }
    }
}
impl AclConfiguration {
    /// Creates a new builder-style object to manufacture [`AclConfiguration`](crate::model::AclConfiguration).
    pub fn builder() -> crate::model::acl_configuration::Builder {
        crate::model::acl_configuration::Builder::default()
    }
}

/// When writing a match expression against `S3AclOption`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let s3acloption = unimplemented!();
/// match s3acloption {
///     S3AclOption::BucketOwnerFullControl => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `s3acloption` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `S3AclOption::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `S3AclOption::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `S3AclOption::NewFeature` is defined.
/// Specifically, when `s3acloption` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `S3AclOption::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum S3AclOption {
    #[allow(missing_docs)] // documentation missing in model
    BucketOwnerFullControl,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for S3AclOption {
    fn from(s: &str) -> Self {
        match s {
            "BUCKET_OWNER_FULL_CONTROL" => S3AclOption::BucketOwnerFullControl,
            other => S3AclOption::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for S3AclOption {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(S3AclOption::from(s))
    }
}
impl S3AclOption {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            S3AclOption::BucketOwnerFullControl => "BUCKET_OWNER_FULL_CONTROL",
            S3AclOption::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["BUCKET_OWNER_FULL_CONTROL"]
    }
}
impl AsRef<str> for S3AclOption {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>If query results are encrypted in Amazon S3, indicates the encryption option used (for example, <code>SSE_KMS</code> or <code>CSE_KMS</code>) and key information.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct EncryptionConfiguration {
    /// <p>Indicates whether Amazon S3 server-side encryption with Amazon S3-managed keys (<code>SSE_S3</code>), server-side encryption with KMS-managed keys (<code>SSE_KMS</code>), or client-side encryption with KMS-managed keys (<code>CSE_KMS</code>) is used.</p>
    /// <p>If a query runs in a workgroup and the workgroup overrides client-side settings, then the workgroup's setting for encryption is used. It specifies whether query results must be encrypted, for all queries that run in this workgroup. </p>
    #[doc(hidden)]
    pub encryption_option: std::option::Option<crate::model::EncryptionOption>,
    /// <p>For <code>SSE_KMS</code> and <code>CSE_KMS</code>, this is the KMS key ARN or ID.</p>
    #[doc(hidden)]
    pub kms_key: std::option::Option<std::string::String>,
}
impl EncryptionConfiguration {
    /// <p>Indicates whether Amazon S3 server-side encryption with Amazon S3-managed keys (<code>SSE_S3</code>), server-side encryption with KMS-managed keys (<code>SSE_KMS</code>), or client-side encryption with KMS-managed keys (<code>CSE_KMS</code>) is used.</p>
    /// <p>If a query runs in a workgroup and the workgroup overrides client-side settings, then the workgroup's setting for encryption is used. It specifies whether query results must be encrypted, for all queries that run in this workgroup. </p>
    pub fn encryption_option(&self) -> std::option::Option<&crate::model::EncryptionOption> {
        self.encryption_option.as_ref()
    }
    /// <p>For <code>SSE_KMS</code> and <code>CSE_KMS</code>, this is the KMS key ARN or ID.</p>
    pub fn kms_key(&self) -> std::option::Option<&str> {
        self.kms_key.as_deref()
    }
}
/// See [`EncryptionConfiguration`](crate::model::EncryptionConfiguration).
pub mod encryption_configuration {

    /// A builder for [`EncryptionConfiguration`](crate::model::EncryptionConfiguration).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) encryption_option: std::option::Option<crate::model::EncryptionOption>,
        pub(crate) kms_key: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Indicates whether Amazon S3 server-side encryption with Amazon S3-managed keys (<code>SSE_S3</code>), server-side encryption with KMS-managed keys (<code>SSE_KMS</code>), or client-side encryption with KMS-managed keys (<code>CSE_KMS</code>) is used.</p>
        /// <p>If a query runs in a workgroup and the workgroup overrides client-side settings, then the workgroup's setting for encryption is used. It specifies whether query results must be encrypted, for all queries that run in this workgroup. </p>
        pub fn encryption_option(mut self, input: crate::model::EncryptionOption) -> Self {
            self.encryption_option = Some(input);
            self
        }
        /// <p>Indicates whether Amazon S3 server-side encryption with Amazon S3-managed keys (<code>SSE_S3</code>), server-side encryption with KMS-managed keys (<code>SSE_KMS</code>), or client-side encryption with KMS-managed keys (<code>CSE_KMS</code>) is used.</p>
        /// <p>If a query runs in a workgroup and the workgroup overrides client-side settings, then the workgroup's setting for encryption is used. It specifies whether query results must be encrypted, for all queries that run in this workgroup. </p>
        pub fn set_encryption_option(
            mut self,
            input: std::option::Option<crate::model::EncryptionOption>,
        ) -> Self {
            self.encryption_option = input;
            self
        }
        /// <p>For <code>SSE_KMS</code> and <code>CSE_KMS</code>, this is the KMS key ARN or ID.</p>
        pub fn kms_key(mut self, input: impl Into<std::string::String>) -> Self {
            self.kms_key = Some(input.into());
            self
        }
        /// <p>For <code>SSE_KMS</code> and <code>CSE_KMS</code>, this is the KMS key ARN or ID.</p>
        pub fn set_kms_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.kms_key = input;
            self
        }
        /// Consumes the builder and constructs a [`EncryptionConfiguration`](crate::model::EncryptionConfiguration).
        pub fn build(self) -> crate::model::EncryptionConfiguration {
            crate::model::EncryptionConfiguration {
                encryption_option: self.encryption_option,
                kms_key: self.kms_key,
            }
        }
    }
}
impl EncryptionConfiguration {
    /// Creates a new builder-style object to manufacture [`EncryptionConfiguration`](crate::model::EncryptionConfiguration).
    pub fn builder() -> crate::model::encryption_configuration::Builder {
        crate::model::encryption_configuration::Builder::default()
    }
}

/// When writing a match expression against `EncryptionOption`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let encryptionoption = unimplemented!();
/// match encryptionoption {
///     EncryptionOption::CseKms => { /* ... */ },
///     EncryptionOption::SseKms => { /* ... */ },
///     EncryptionOption::SseS3 => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `encryptionoption` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `EncryptionOption::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `EncryptionOption::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `EncryptionOption::NewFeature` is defined.
/// Specifically, when `encryptionoption` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `EncryptionOption::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum EncryptionOption {
    #[allow(missing_docs)] // documentation missing in model
    CseKms,
    #[allow(missing_docs)] // documentation missing in model
    SseKms,
    #[allow(missing_docs)] // documentation missing in model
    SseS3,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for EncryptionOption {
    fn from(s: &str) -> Self {
        match s {
            "CSE_KMS" => EncryptionOption::CseKms,
            "SSE_KMS" => EncryptionOption::SseKms,
            "SSE_S3" => EncryptionOption::SseS3,
            other => EncryptionOption::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for EncryptionOption {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(EncryptionOption::from(s))
    }
}
impl EncryptionOption {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            EncryptionOption::CseKms => "CSE_KMS",
            EncryptionOption::SseKms => "SSE_KMS",
            EncryptionOption::SseS3 => "SSE_S3",
            EncryptionOption::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["CSE_KMS", "SSE_KMS", "SSE_S3"]
    }
}
impl AsRef<str> for EncryptionOption {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `ThrottleReason`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let throttlereason = unimplemented!();
/// match throttlereason {
///     ThrottleReason::ConcurrentQueryLimitExceeded => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `throttlereason` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ThrottleReason::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ThrottleReason::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ThrottleReason::NewFeature` is defined.
/// Specifically, when `throttlereason` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ThrottleReason::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
/// <p>The reason for the query throttling, for example, when it exceeds the concurrent query
/// limit.</p>
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ThrottleReason {
    #[allow(missing_docs)] // documentation missing in model
    ConcurrentQueryLimitExceeded,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ThrottleReason {
    fn from(s: &str) -> Self {
        match s {
            "CONCURRENT_QUERY_LIMIT_EXCEEDED" => ThrottleReason::ConcurrentQueryLimitExceeded,
            other => ThrottleReason::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for ThrottleReason {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ThrottleReason::from(s))
    }
}
impl ThrottleReason {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ThrottleReason::ConcurrentQueryLimitExceeded => "CONCURRENT_QUERY_LIMIT_EXCEEDED",
            ThrottleReason::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["CONCURRENT_QUERY_LIMIT_EXCEEDED"]
    }
}
impl AsRef<str> for ThrottleReason {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `NotebookType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let notebooktype = unimplemented!();
/// match notebooktype {
///     NotebookType::Ipynb => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `notebooktype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `NotebookType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `NotebookType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `NotebookType::NewFeature` is defined.
/// Specifically, when `notebooktype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `NotebookType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum NotebookType {
    #[allow(missing_docs)] // documentation missing in model
    Ipynb,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for NotebookType {
    fn from(s: &str) -> Self {
        match s {
            "IPYNB" => NotebookType::Ipynb,
            other => NotebookType::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for NotebookType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(NotebookType::from(s))
    }
}
impl NotebookType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            NotebookType::Ipynb => "IPYNB",
            NotebookType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["IPYNB"]
    }
}
impl AsRef<str> for NotebookType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `DataCatalogType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let datacatalogtype = unimplemented!();
/// match datacatalogtype {
///     DataCatalogType::Glue => { /* ... */ },
///     DataCatalogType::Hive => { /* ... */ },
///     DataCatalogType::Lambda => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `datacatalogtype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `DataCatalogType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `DataCatalogType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `DataCatalogType::NewFeature` is defined.
/// Specifically, when `datacatalogtype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `DataCatalogType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum DataCatalogType {
    #[allow(missing_docs)] // documentation missing in model
    Glue,
    #[allow(missing_docs)] // documentation missing in model
    Hive,
    #[allow(missing_docs)] // documentation missing in model
    Lambda,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for DataCatalogType {
    fn from(s: &str) -> Self {
        match s {
            "GLUE" => DataCatalogType::Glue,
            "HIVE" => DataCatalogType::Hive,
            "LAMBDA" => DataCatalogType::Lambda,
            other => DataCatalogType::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for DataCatalogType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(DataCatalogType::from(s))
    }
}
impl DataCatalogType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            DataCatalogType::Glue => "GLUE",
            DataCatalogType::Hive => "HIVE",
            DataCatalogType::Lambda => "LAMBDA",
            DataCatalogType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["GLUE", "HIVE", "LAMBDA"]
    }
}
impl AsRef<str> for DataCatalogType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `SessionState`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let sessionstate = unimplemented!();
/// match sessionstate {
///     SessionState::Busy => { /* ... */ },
///     SessionState::Created => { /* ... */ },
///     SessionState::Creating => { /* ... */ },
///     SessionState::Degraded => { /* ... */ },
///     SessionState::Failed => { /* ... */ },
///     SessionState::Idle => { /* ... */ },
///     SessionState::Terminated => { /* ... */ },
///     SessionState::Terminating => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `sessionstate` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `SessionState::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `SessionState::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `SessionState::NewFeature` is defined.
/// Specifically, when `sessionstate` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `SessionState::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum SessionState {
    #[allow(missing_docs)] // documentation missing in model
    Busy,
    #[allow(missing_docs)] // documentation missing in model
    Created,
    #[allow(missing_docs)] // documentation missing in model
    Creating,
    #[allow(missing_docs)] // documentation missing in model
    Degraded,
    #[allow(missing_docs)] // documentation missing in model
    Failed,
    #[allow(missing_docs)] // documentation missing in model
    Idle,
    #[allow(missing_docs)] // documentation missing in model
    Terminated,
    #[allow(missing_docs)] // documentation missing in model
    Terminating,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for SessionState {
    fn from(s: &str) -> Self {
        match s {
            "BUSY" => SessionState::Busy,
            "CREATED" => SessionState::Created,
            "CREATING" => SessionState::Creating,
            "DEGRADED" => SessionState::Degraded,
            "FAILED" => SessionState::Failed,
            "IDLE" => SessionState::Idle,
            "TERMINATED" => SessionState::Terminated,
            "TERMINATING" => SessionState::Terminating,
            other => SessionState::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for SessionState {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(SessionState::from(s))
    }
}
impl SessionState {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            SessionState::Busy => "BUSY",
            SessionState::Created => "CREATED",
            SessionState::Creating => "CREATING",
            SessionState::Degraded => "DEGRADED",
            SessionState::Failed => "FAILED",
            SessionState::Idle => "IDLE",
            SessionState::Terminated => "TERMINATED",
            SessionState::Terminating => "TERMINATING",
            SessionState::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "BUSY",
            "CREATED",
            "CREATING",
            "DEGRADED",
            "FAILED",
            "IDLE",
            "TERMINATED",
            "TERMINATING",
        ]
    }
}
impl AsRef<str> for SessionState {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>A label that you assign to a resource. In Athena, a resource can be a workgroup or data catalog. Each tag consists of a key and an optional value, both of which you define. For example, you can use tags to categorize Athena workgroups or data catalogs by purpose, owner, or environment. Use a consistent set of tag keys to make it easier to search and filter workgroups or data catalogs in your account. For best practices, see <a href="https://aws.amazon.com/answers/account-management/aws-tagging-strategies/">Tagging Best Practices</a>. Tag keys can be from 1 to 128 UTF-8 Unicode characters, and tag values can be from 0 to 256 UTF-8 Unicode characters. Tags can use letters and numbers representable in UTF-8, and the following characters: + - = . _ : / @. Tag keys and values are case-sensitive. Tag keys must be unique per resource. If you specify more than one tag, separate them by commas. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Tag {
    /// <p>A tag key. The tag key length is from 1 to 128 Unicode characters in UTF-8. You can use letters and numbers representable in UTF-8, and the following characters: + - = . _ : / @. Tag keys are case-sensitive and must be unique per resource. </p>
    #[doc(hidden)]
    pub key: std::option::Option<std::string::String>,
    /// <p>A tag value. The tag value length is from 0 to 256 Unicode characters in UTF-8. You can use letters and numbers representable in UTF-8, and the following characters: + - = . _ : / @. Tag values are case-sensitive. </p>
    #[doc(hidden)]
    pub value: std::option::Option<std::string::String>,
}
impl Tag {
    /// <p>A tag key. The tag key length is from 1 to 128 Unicode characters in UTF-8. You can use letters and numbers representable in UTF-8, and the following characters: + - = . _ : / @. Tag keys are case-sensitive and must be unique per resource. </p>
    pub fn key(&self) -> std::option::Option<&str> {
        self.key.as_deref()
    }
    /// <p>A tag value. The tag value length is from 0 to 256 Unicode characters in UTF-8. You can use letters and numbers representable in UTF-8, and the following characters: + - = . _ : / @. Tag values are case-sensitive. </p>
    pub fn value(&self) -> std::option::Option<&str> {
        self.value.as_deref()
    }
}
/// See [`Tag`](crate::model::Tag).
pub mod tag {

    /// A builder for [`Tag`](crate::model::Tag).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) key: std::option::Option<std::string::String>,
        pub(crate) value: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>A tag key. The tag key length is from 1 to 128 Unicode characters in UTF-8. You can use letters and numbers representable in UTF-8, and the following characters: + - = . _ : / @. Tag keys are case-sensitive and must be unique per resource. </p>
        pub fn key(mut self, input: impl Into<std::string::String>) -> Self {
            self.key = Some(input.into());
            self
        }
        /// <p>A tag key. The tag key length is from 1 to 128 Unicode characters in UTF-8. You can use letters and numbers representable in UTF-8, and the following characters: + - = . _ : / @. Tag keys are case-sensitive and must be unique per resource. </p>
        pub fn set_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.key = input;
            self
        }
        /// <p>A tag value. The tag value length is from 0 to 256 Unicode characters in UTF-8. You can use letters and numbers representable in UTF-8, and the following characters: + - = . _ : / @. Tag values are case-sensitive. </p>
        pub fn value(mut self, input: impl Into<std::string::String>) -> Self {
            self.value = Some(input.into());
            self
        }
        /// <p>A tag value. The tag value length is from 0 to 256 Unicode characters in UTF-8. You can use letters and numbers representable in UTF-8, and the following characters: + - = . _ : / @. Tag values are case-sensitive. </p>
        pub fn set_value(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.value = input;
            self
        }
        /// Consumes the builder and constructs a [`Tag`](crate::model::Tag).
        pub fn build(self) -> crate::model::Tag {
            crate::model::Tag {
                key: self.key,
                value: self.value,
            }
        }
    }
}
impl Tag {
    /// Creates a new builder-style object to manufacture [`Tag`](crate::model::Tag).
    pub fn builder() -> crate::model::tag::Builder {
        crate::model::tag::Builder::default()
    }
}

/// When writing a match expression against `CalculationExecutionState`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let calculationexecutionstate = unimplemented!();
/// match calculationexecutionstate {
///     CalculationExecutionState::Canceled => { /* ... */ },
///     CalculationExecutionState::Canceling => { /* ... */ },
///     CalculationExecutionState::Completed => { /* ... */ },
///     CalculationExecutionState::Created => { /* ... */ },
///     CalculationExecutionState::Creating => { /* ... */ },
///     CalculationExecutionState::Failed => { /* ... */ },
///     CalculationExecutionState::Queued => { /* ... */ },
///     CalculationExecutionState::Running => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `calculationexecutionstate` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `CalculationExecutionState::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `CalculationExecutionState::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `CalculationExecutionState::NewFeature` is defined.
/// Specifically, when `calculationexecutionstate` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `CalculationExecutionState::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum CalculationExecutionState {
    #[allow(missing_docs)] // documentation missing in model
    Canceled,
    #[allow(missing_docs)] // documentation missing in model
    Canceling,
    #[allow(missing_docs)] // documentation missing in model
    Completed,
    #[allow(missing_docs)] // documentation missing in model
    Created,
    #[allow(missing_docs)] // documentation missing in model
    Creating,
    #[allow(missing_docs)] // documentation missing in model
    Failed,
    #[allow(missing_docs)] // documentation missing in model
    Queued,
    #[allow(missing_docs)] // documentation missing in model
    Running,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for CalculationExecutionState {
    fn from(s: &str) -> Self {
        match s {
            "CANCELED" => CalculationExecutionState::Canceled,
            "CANCELING" => CalculationExecutionState::Canceling,
            "COMPLETED" => CalculationExecutionState::Completed,
            "CREATED" => CalculationExecutionState::Created,
            "CREATING" => CalculationExecutionState::Creating,
            "FAILED" => CalculationExecutionState::Failed,
            "QUEUED" => CalculationExecutionState::Queued,
            "RUNNING" => CalculationExecutionState::Running,
            other => CalculationExecutionState::Unknown(crate::types::UnknownVariantValue(
                other.to_owned(),
            )),
        }
    }
}
impl std::str::FromStr for CalculationExecutionState {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(CalculationExecutionState::from(s))
    }
}
impl CalculationExecutionState {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            CalculationExecutionState::Canceled => "CANCELED",
            CalculationExecutionState::Canceling => "CANCELING",
            CalculationExecutionState::Completed => "COMPLETED",
            CalculationExecutionState::Created => "CREATED",
            CalculationExecutionState::Creating => "CREATING",
            CalculationExecutionState::Failed => "FAILED",
            CalculationExecutionState::Queued => "QUEUED",
            CalculationExecutionState::Running => "RUNNING",
            CalculationExecutionState::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "CANCELED",
            "CANCELING",
            "COMPLETED",
            "CREATED",
            "CREATING",
            "FAILED",
            "QUEUED",
            "RUNNING",
        ]
    }
}
impl AsRef<str> for CalculationExecutionState {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Contains data processing unit (DPU) configuration settings and parameter mappings for a notebook engine.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct EngineConfiguration {
    /// <p>The number of DPUs to use for the coordinator. A coordinator is a special executor that orchestrates processing work and manages other executors in a notebook session.</p>
    #[doc(hidden)]
    pub coordinator_dpu_size: i32,
    /// <p>The maximum number of DPUs that can run concurrently.</p>
    #[doc(hidden)]
    pub max_concurrent_dpus: i32,
    /// <p>The default number of DPUs to use for executors. An executor is the smallest unit of compute that a notebook session can request from Athena.</p>
    #[doc(hidden)]
    pub default_executor_dpu_size: i32,
    /// <p>Contains additional notebook engine <code>MAP
    /// <string, string></string,></code> parameter mappings in the form of key-value pairs. To specify an Amazon S3 URI that the Jupyter server will download and serve, specify a value for the <code>StartSessionRequest$NotebookVersion</code> field, and then add a key named <code>NotebookFileURI</code> to <code>AdditionalConfigs</code> that has value of the Amazon S3 URI.</p>
    #[doc(hidden)]
    pub additional_configs:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
}
impl EngineConfiguration {
    /// <p>The number of DPUs to use for the coordinator. A coordinator is a special executor that orchestrates processing work and manages other executors in a notebook session.</p>
    pub fn coordinator_dpu_size(&self) -> i32 {
        self.coordinator_dpu_size
    }
    /// <p>The maximum number of DPUs that can run concurrently.</p>
    pub fn max_concurrent_dpus(&self) -> i32 {
        self.max_concurrent_dpus
    }
    /// <p>The default number of DPUs to use for executors. An executor is the smallest unit of compute that a notebook session can request from Athena.</p>
    pub fn default_executor_dpu_size(&self) -> i32 {
        self.default_executor_dpu_size
    }
    /// <p>Contains additional notebook engine <code>MAP
    /// <string, string></string,></code> parameter mappings in the form of key-value pairs. To specify an Amazon S3 URI that the Jupyter server will download and serve, specify a value for the <code>StartSessionRequest$NotebookVersion</code> field, and then add a key named <code>NotebookFileURI</code> to <code>AdditionalConfigs</code> that has value of the Amazon S3 URI.</p>
    pub fn additional_configs(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.additional_configs.as_ref()
    }
}
/// See [`EngineConfiguration`](crate::model::EngineConfiguration).
pub mod engine_configuration {

    /// A builder for [`EngineConfiguration`](crate::model::EngineConfiguration).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) coordinator_dpu_size: std::option::Option<i32>,
        pub(crate) max_concurrent_dpus: std::option::Option<i32>,
        pub(crate) default_executor_dpu_size: std::option::Option<i32>,
        pub(crate) additional_configs: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
    }
    impl Builder {
        /// <p>The number of DPUs to use for the coordinator. A coordinator is a special executor that orchestrates processing work and manages other executors in a notebook session.</p>
        pub fn coordinator_dpu_size(mut self, input: i32) -> Self {
            self.coordinator_dpu_size = Some(input);
            self
        }
        /// <p>The number of DPUs to use for the coordinator. A coordinator is a special executor that orchestrates processing work and manages other executors in a notebook session.</p>
        pub fn set_coordinator_dpu_size(mut self, input: std::option::Option<i32>) -> Self {
            self.coordinator_dpu_size = input;
            self
        }
        /// <p>The maximum number of DPUs that can run concurrently.</p>
        pub fn max_concurrent_dpus(mut self, input: i32) -> Self {
            self.max_concurrent_dpus = Some(input);
            self
        }
        /// <p>The maximum number of DPUs that can run concurrently.</p>
        pub fn set_max_concurrent_dpus(mut self, input: std::option::Option<i32>) -> Self {
            self.max_concurrent_dpus = input;
            self
        }
        /// <p>The default number of DPUs to use for executors. An executor is the smallest unit of compute that a notebook session can request from Athena.</p>
        pub fn default_executor_dpu_size(mut self, input: i32) -> Self {
            self.default_executor_dpu_size = Some(input);
            self
        }
        /// <p>The default number of DPUs to use for executors. An executor is the smallest unit of compute that a notebook session can request from Athena.</p>
        pub fn set_default_executor_dpu_size(mut self, input: std::option::Option<i32>) -> Self {
            self.default_executor_dpu_size = input;
            self
        }
        /// Adds a key-value pair to `additional_configs`.
        ///
        /// To override the contents of this collection use [`set_additional_configs`](Self::set_additional_configs).
        ///
        /// <p>Contains additional notebook engine <code>MAP
        /// <string, string></string,></code> parameter mappings in the form of key-value pairs. To specify an Amazon S3 URI that the Jupyter server will download and serve, specify a value for the <code>StartSessionRequest$NotebookVersion</code> field, and then add a key named <code>NotebookFileURI</code> to <code>AdditionalConfigs</code> that has value of the Amazon S3 URI.</p>
        pub fn additional_configs(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.additional_configs.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.additional_configs = Some(hash_map);
            self
        }
        /// <p>Contains additional notebook engine <code>MAP
        /// <string, string></string,></code> parameter mappings in the form of key-value pairs. To specify an Amazon S3 URI that the Jupyter server will download and serve, specify a value for the <code>StartSessionRequest$NotebookVersion</code> field, and then add a key named <code>NotebookFileURI</code> to <code>AdditionalConfigs</code> that has value of the Amazon S3 URI.</p>
        pub fn set_additional_configs(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.additional_configs = input;
            self
        }
        /// Consumes the builder and constructs a [`EngineConfiguration`](crate::model::EngineConfiguration).
        pub fn build(self) -> crate::model::EngineConfiguration {
            crate::model::EngineConfiguration {
                coordinator_dpu_size: self.coordinator_dpu_size.unwrap_or_default(),
                max_concurrent_dpus: self.max_concurrent_dpus.unwrap_or_default(),
                default_executor_dpu_size: self.default_executor_dpu_size.unwrap_or_default(),
                additional_configs: self.additional_configs,
            }
        }
    }
}
impl EngineConfiguration {
    /// Creates a new builder-style object to manufacture [`EngineConfiguration`](crate::model::EngineConfiguration).
    pub fn builder() -> crate::model::engine_configuration::Builder {
        crate::model::engine_configuration::Builder::default()
    }
}

/// <p>Specifies the query result reuse behavior for the query.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ResultReuseConfiguration {
    /// <p>Specifies whether previous query results are reused, and if so, their maximum age.</p>
    #[doc(hidden)]
    pub result_reuse_by_age_configuration:
        std::option::Option<crate::model::ResultReuseByAgeConfiguration>,
}
impl ResultReuseConfiguration {
    /// <p>Specifies whether previous query results are reused, and if so, their maximum age.</p>
    pub fn result_reuse_by_age_configuration(
        &self,
    ) -> std::option::Option<&crate::model::ResultReuseByAgeConfiguration> {
        self.result_reuse_by_age_configuration.as_ref()
    }
}
/// See [`ResultReuseConfiguration`](crate::model::ResultReuseConfiguration).
pub mod result_reuse_configuration {

    /// A builder for [`ResultReuseConfiguration`](crate::model::ResultReuseConfiguration).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) result_reuse_by_age_configuration:
            std::option::Option<crate::model::ResultReuseByAgeConfiguration>,
    }
    impl Builder {
        /// <p>Specifies whether previous query results are reused, and if so, their maximum age.</p>
        pub fn result_reuse_by_age_configuration(
            mut self,
            input: crate::model::ResultReuseByAgeConfiguration,
        ) -> Self {
            self.result_reuse_by_age_configuration = Some(input);
            self
        }
        /// <p>Specifies whether previous query results are reused, and if so, their maximum age.</p>
        pub fn set_result_reuse_by_age_configuration(
            mut self,
            input: std::option::Option<crate::model::ResultReuseByAgeConfiguration>,
        ) -> Self {
            self.result_reuse_by_age_configuration = input;
            self
        }
        /// Consumes the builder and constructs a [`ResultReuseConfiguration`](crate::model::ResultReuseConfiguration).
        pub fn build(self) -> crate::model::ResultReuseConfiguration {
            crate::model::ResultReuseConfiguration {
                result_reuse_by_age_configuration: self.result_reuse_by_age_configuration,
            }
        }
    }
}
impl ResultReuseConfiguration {
    /// Creates a new builder-style object to manufacture [`ResultReuseConfiguration`](crate::model::ResultReuseConfiguration).
    pub fn builder() -> crate::model::result_reuse_configuration::Builder {
        crate::model::result_reuse_configuration::Builder::default()
    }
}

/// <p>Specifies whether previous query results are reused, and if so, their maximum age.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ResultReuseByAgeConfiguration {
    /// <p>True if previous query results can be reused when the query is run; otherwise, false. The default is false.</p>
    #[doc(hidden)]
    pub enabled: bool,
    /// <p>Specifies, in minutes, the maximum age of a previous query result that Athena should consider for reuse. The default is 60.</p>
    #[doc(hidden)]
    pub max_age_in_minutes: std::option::Option<i32>,
}
impl ResultReuseByAgeConfiguration {
    /// <p>True if previous query results can be reused when the query is run; otherwise, false. The default is false.</p>
    pub fn enabled(&self) -> bool {
        self.enabled
    }
    /// <p>Specifies, in minutes, the maximum age of a previous query result that Athena should consider for reuse. The default is 60.</p>
    pub fn max_age_in_minutes(&self) -> std::option::Option<i32> {
        self.max_age_in_minutes
    }
}
/// See [`ResultReuseByAgeConfiguration`](crate::model::ResultReuseByAgeConfiguration).
pub mod result_reuse_by_age_configuration {

    /// A builder for [`ResultReuseByAgeConfiguration`](crate::model::ResultReuseByAgeConfiguration).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) enabled: std::option::Option<bool>,
        pub(crate) max_age_in_minutes: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>True if previous query results can be reused when the query is run; otherwise, false. The default is false.</p>
        pub fn enabled(mut self, input: bool) -> Self {
            self.enabled = Some(input);
            self
        }
        /// <p>True if previous query results can be reused when the query is run; otherwise, false. The default is false.</p>
        pub fn set_enabled(mut self, input: std::option::Option<bool>) -> Self {
            self.enabled = input;
            self
        }
        /// <p>Specifies, in minutes, the maximum age of a previous query result that Athena should consider for reuse. The default is 60.</p>
        pub fn max_age_in_minutes(mut self, input: i32) -> Self {
            self.max_age_in_minutes = Some(input);
            self
        }
        /// <p>Specifies, in minutes, the maximum age of a previous query result that Athena should consider for reuse. The default is 60.</p>
        pub fn set_max_age_in_minutes(mut self, input: std::option::Option<i32>) -> Self {
            self.max_age_in_minutes = input;
            self
        }
        /// Consumes the builder and constructs a [`ResultReuseByAgeConfiguration`](crate::model::ResultReuseByAgeConfiguration).
        pub fn build(self) -> crate::model::ResultReuseByAgeConfiguration {
            crate::model::ResultReuseByAgeConfiguration {
                enabled: self.enabled.unwrap_or_default(),
                max_age_in_minutes: self.max_age_in_minutes,
            }
        }
    }
}
impl ResultReuseByAgeConfiguration {
    /// Creates a new builder-style object to manufacture [`ResultReuseByAgeConfiguration`](crate::model::ResultReuseByAgeConfiguration).
    pub fn builder() -> crate::model::result_reuse_by_age_configuration::Builder {
        crate::model::result_reuse_by_age_configuration::Builder::default()
    }
}

/// <p>The location in Amazon S3 where query results are stored and the encryption option, if any, used for query results. These are known as "client-side settings". If workgroup settings override client-side settings, then the query uses the workgroup settings.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ResultConfiguration {
    /// <p>The location in Amazon S3 where your query results are stored, such as <code>s3://path/to/query/bucket/</code>. To run the query, you must specify the query results location using one of the ways: either for individual queries using either this setting (client-side), or in the workgroup, using <code>WorkGroupConfiguration</code>. If none of them is set, Athena issues an error that no output location is provided. For more information, see <a href="https://docs.aws.amazon.com/athena/latest/ug/querying.html">Query Results</a>. If workgroup settings override client-side settings, then the query uses the settings specified for the workgroup. See <code>WorkGroupConfiguration$EnforceWorkGroupConfiguration</code>.</p>
    #[doc(hidden)]
    pub output_location: std::option::Option<std::string::String>,
    /// <p>If query results are encrypted in Amazon S3, indicates the encryption option used (for example, <code>SSE_KMS</code> or <code>CSE_KMS</code>) and key information. This is a client-side setting. If workgroup settings override client-side settings, then the query uses the encryption configuration that is specified for the workgroup, and also uses the location for storing query results specified in the workgroup. See <code>WorkGroupConfiguration$EnforceWorkGroupConfiguration</code> and <a href="https://docs.aws.amazon.com/athena/latest/ug/workgroups-settings-override.html">Workgroup Settings Override Client-Side Settings</a>.</p>
    #[doc(hidden)]
    pub encryption_configuration: std::option::Option<crate::model::EncryptionConfiguration>,
    /// <p>The Amazon Web Services account ID that you expect to be the owner of the Amazon S3 bucket specified by <code>ResultConfiguration$OutputLocation</code>. If set, Athena uses the value for <code>ExpectedBucketOwner</code> when it makes Amazon S3 calls to your specified output location. If the <code>ExpectedBucketOwner</code> Amazon Web Services account ID does not match the actual owner of the Amazon S3 bucket, the call fails with a permissions error.</p>
    /// <p>This is a client-side setting. If workgroup settings override client-side settings, then the query uses the <code>ExpectedBucketOwner</code> setting that is specified for the workgroup, and also uses the location for storing query results specified in the workgroup. See <code>WorkGroupConfiguration$EnforceWorkGroupConfiguration</code> and <a href="https://docs.aws.amazon.com/athena/latest/ug/workgroups-settings-override.html">Workgroup Settings Override Client-Side Settings</a>.</p>
    #[doc(hidden)]
    pub expected_bucket_owner: std::option::Option<std::string::String>,
    /// <p>Indicates that an Amazon S3 canned ACL should be set to control ownership of stored query results. Currently the only supported canned ACL is <code>BUCKET_OWNER_FULL_CONTROL</code>. This is a client-side setting. If workgroup settings override client-side settings, then the query uses the ACL configuration that is specified for the workgroup, and also uses the location for storing query results specified in the workgroup. For more information, see <code>WorkGroupConfiguration$EnforceWorkGroupConfiguration</code> and <a href="https://docs.aws.amazon.com/athena/latest/ug/workgroups-settings-override.html">Workgroup Settings Override Client-Side Settings</a>.</p>
    #[doc(hidden)]
    pub acl_configuration: std::option::Option<crate::model::AclConfiguration>,
}
impl ResultConfiguration {
    /// <p>The location in Amazon S3 where your query results are stored, such as <code>s3://path/to/query/bucket/</code>. To run the query, you must specify the query results location using one of the ways: either for individual queries using either this setting (client-side), or in the workgroup, using <code>WorkGroupConfiguration</code>. If none of them is set, Athena issues an error that no output location is provided. For more information, see <a href="https://docs.aws.amazon.com/athena/latest/ug/querying.html">Query Results</a>. If workgroup settings override client-side settings, then the query uses the settings specified for the workgroup. See <code>WorkGroupConfiguration$EnforceWorkGroupConfiguration</code>.</p>
    pub fn output_location(&self) -> std::option::Option<&str> {
        self.output_location.as_deref()
    }
    /// <p>If query results are encrypted in Amazon S3, indicates the encryption option used (for example, <code>SSE_KMS</code> or <code>CSE_KMS</code>) and key information. This is a client-side setting. If workgroup settings override client-side settings, then the query uses the encryption configuration that is specified for the workgroup, and also uses the location for storing query results specified in the workgroup. See <code>WorkGroupConfiguration$EnforceWorkGroupConfiguration</code> and <a href="https://docs.aws.amazon.com/athena/latest/ug/workgroups-settings-override.html">Workgroup Settings Override Client-Side Settings</a>.</p>
    pub fn encryption_configuration(
        &self,
    ) -> std::option::Option<&crate::model::EncryptionConfiguration> {
        self.encryption_configuration.as_ref()
    }
    /// <p>The Amazon Web Services account ID that you expect to be the owner of the Amazon S3 bucket specified by <code>ResultConfiguration$OutputLocation</code>. If set, Athena uses the value for <code>ExpectedBucketOwner</code> when it makes Amazon S3 calls to your specified output location. If the <code>ExpectedBucketOwner</code> Amazon Web Services account ID does not match the actual owner of the Amazon S3 bucket, the call fails with a permissions error.</p>
    /// <p>This is a client-side setting. If workgroup settings override client-side settings, then the query uses the <code>ExpectedBucketOwner</code> setting that is specified for the workgroup, and also uses the location for storing query results specified in the workgroup. See <code>WorkGroupConfiguration$EnforceWorkGroupConfiguration</code> and <a href="https://docs.aws.amazon.com/athena/latest/ug/workgroups-settings-override.html">Workgroup Settings Override Client-Side Settings</a>.</p>
    pub fn expected_bucket_owner(&self) -> std::option::Option<&str> {
        self.expected_bucket_owner.as_deref()
    }
    /// <p>Indicates that an Amazon S3 canned ACL should be set to control ownership of stored query results. Currently the only supported canned ACL is <code>BUCKET_OWNER_FULL_CONTROL</code>. This is a client-side setting. If workgroup settings override client-side settings, then the query uses the ACL configuration that is specified for the workgroup, and also uses the location for storing query results specified in the workgroup. For more information, see <code>WorkGroupConfiguration$EnforceWorkGroupConfiguration</code> and <a href="https://docs.aws.amazon.com/athena/latest/ug/workgroups-settings-override.html">Workgroup Settings Override Client-Side Settings</a>.</p>
    pub fn acl_configuration(&self) -> std::option::Option<&crate::model::AclConfiguration> {
        self.acl_configuration.as_ref()
    }
}
/// See [`ResultConfiguration`](crate::model::ResultConfiguration).
pub mod result_configuration {

    /// A builder for [`ResultConfiguration`](crate::model::ResultConfiguration).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) output_location: std::option::Option<std::string::String>,
        pub(crate) encryption_configuration:
            std::option::Option<crate::model::EncryptionConfiguration>,
        pub(crate) expected_bucket_owner: std::option::Option<std::string::String>,
        pub(crate) acl_configuration: std::option::Option<crate::model::AclConfiguration>,
    }
    impl Builder {
        /// <p>The location in Amazon S3 where your query results are stored, such as <code>s3://path/to/query/bucket/</code>. To run the query, you must specify the query results location using one of the ways: either for individual queries using either this setting (client-side), or in the workgroup, using <code>WorkGroupConfiguration</code>. If none of them is set, Athena issues an error that no output location is provided. For more information, see <a href="https://docs.aws.amazon.com/athena/latest/ug/querying.html">Query Results</a>. If workgroup settings override client-side settings, then the query uses the settings specified for the workgroup. See <code>WorkGroupConfiguration$EnforceWorkGroupConfiguration</code>.</p>
        pub fn output_location(mut self, input: impl Into<std::string::String>) -> Self {
            self.output_location = Some(input.into());
            self
        }
        /// <p>The location in Amazon S3 where your query results are stored, such as <code>s3://path/to/query/bucket/</code>. To run the query, you must specify the query results location using one of the ways: either for individual queries using either this setting (client-side), or in the workgroup, using <code>WorkGroupConfiguration</code>. If none of them is set, Athena issues an error that no output location is provided. For more information, see <a href="https://docs.aws.amazon.com/athena/latest/ug/querying.html">Query Results</a>. If workgroup settings override client-side settings, then the query uses the settings specified for the workgroup. See <code>WorkGroupConfiguration$EnforceWorkGroupConfiguration</code>.</p>
        pub fn set_output_location(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.output_location = input;
            self
        }
        /// <p>If query results are encrypted in Amazon S3, indicates the encryption option used (for example, <code>SSE_KMS</code> or <code>CSE_KMS</code>) and key information. This is a client-side setting. If workgroup settings override client-side settings, then the query uses the encryption configuration that is specified for the workgroup, and also uses the location for storing query results specified in the workgroup. See <code>WorkGroupConfiguration$EnforceWorkGroupConfiguration</code> and <a href="https://docs.aws.amazon.com/athena/latest/ug/workgroups-settings-override.html">Workgroup Settings Override Client-Side Settings</a>.</p>
        pub fn encryption_configuration(
            mut self,
            input: crate::model::EncryptionConfiguration,
        ) -> Self {
            self.encryption_configuration = Some(input);
            self
        }
        /// <p>If query results are encrypted in Amazon S3, indicates the encryption option used (for example, <code>SSE_KMS</code> or <code>CSE_KMS</code>) and key information. This is a client-side setting. If workgroup settings override client-side settings, then the query uses the encryption configuration that is specified for the workgroup, and also uses the location for storing query results specified in the workgroup. See <code>WorkGroupConfiguration$EnforceWorkGroupConfiguration</code> and <a href="https://docs.aws.amazon.com/athena/latest/ug/workgroups-settings-override.html">Workgroup Settings Override Client-Side Settings</a>.</p>
        pub fn set_encryption_configuration(
            mut self,
            input: std::option::Option<crate::model::EncryptionConfiguration>,
        ) -> Self {
            self.encryption_configuration = input;
            self
        }
        /// <p>The Amazon Web Services account ID that you expect to be the owner of the Amazon S3 bucket specified by <code>ResultConfiguration$OutputLocation</code>. If set, Athena uses the value for <code>ExpectedBucketOwner</code> when it makes Amazon S3 calls to your specified output location. If the <code>ExpectedBucketOwner</code> Amazon Web Services account ID does not match the actual owner of the Amazon S3 bucket, the call fails with a permissions error.</p>
        /// <p>This is a client-side setting. If workgroup settings override client-side settings, then the query uses the <code>ExpectedBucketOwner</code> setting that is specified for the workgroup, and also uses the location for storing query results specified in the workgroup. See <code>WorkGroupConfiguration$EnforceWorkGroupConfiguration</code> and <a href="https://docs.aws.amazon.com/athena/latest/ug/workgroups-settings-override.html">Workgroup Settings Override Client-Side Settings</a>.</p>
        pub fn expected_bucket_owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.expected_bucket_owner = Some(input.into());
            self
        }
        /// <p>The Amazon Web Services account ID that you expect to be the owner of the Amazon S3 bucket specified by <code>ResultConfiguration$OutputLocation</code>. If set, Athena uses the value for <code>ExpectedBucketOwner</code> when it makes Amazon S3 calls to your specified output location. If the <code>ExpectedBucketOwner</code> Amazon Web Services account ID does not match the actual owner of the Amazon S3 bucket, the call fails with a permissions error.</p>
        /// <p>This is a client-side setting. If workgroup settings override client-side settings, then the query uses the <code>ExpectedBucketOwner</code> setting that is specified for the workgroup, and also uses the location for storing query results specified in the workgroup. See <code>WorkGroupConfiguration$EnforceWorkGroupConfiguration</code> and <a href="https://docs.aws.amazon.com/athena/latest/ug/workgroups-settings-override.html">Workgroup Settings Override Client-Side Settings</a>.</p>
        pub fn set_expected_bucket_owner(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.expected_bucket_owner = input;
            self
        }
        /// <p>Indicates that an Amazon S3 canned ACL should be set to control ownership of stored query results. Currently the only supported canned ACL is <code>BUCKET_OWNER_FULL_CONTROL</code>. This is a client-side setting. If workgroup settings override client-side settings, then the query uses the ACL configuration that is specified for the workgroup, and also uses the location for storing query results specified in the workgroup. For more information, see <code>WorkGroupConfiguration$EnforceWorkGroupConfiguration</code> and <a href="https://docs.aws.amazon.com/athena/latest/ug/workgroups-settings-override.html">Workgroup Settings Override Client-Side Settings</a>.</p>
        pub fn acl_configuration(mut self, input: crate::model::AclConfiguration) -> Self {
            self.acl_configuration = Some(input);
            self
        }
        /// <p>Indicates that an Amazon S3 canned ACL should be set to control ownership of stored query results. Currently the only supported canned ACL is <code>BUCKET_OWNER_FULL_CONTROL</code>. This is a client-side setting. If workgroup settings override client-side settings, then the query uses the ACL configuration that is specified for the workgroup, and also uses the location for storing query results specified in the workgroup. For more information, see <code>WorkGroupConfiguration$EnforceWorkGroupConfiguration</code> and <a href="https://docs.aws.amazon.com/athena/latest/ug/workgroups-settings-override.html">Workgroup Settings Override Client-Side Settings</a>.</p>
        pub fn set_acl_configuration(
            mut self,
            input: std::option::Option<crate::model::AclConfiguration>,
        ) -> Self {
            self.acl_configuration = input;
            self
        }
        /// Consumes the builder and constructs a [`ResultConfiguration`](crate::model::ResultConfiguration).
        pub fn build(self) -> crate::model::ResultConfiguration {
            crate::model::ResultConfiguration {
                output_location: self.output_location,
                encryption_configuration: self.encryption_configuration,
                expected_bucket_owner: self.expected_bucket_owner,
                acl_configuration: self.acl_configuration,
            }
        }
    }
}
impl ResultConfiguration {
    /// Creates a new builder-style object to manufacture [`ResultConfiguration`](crate::model::ResultConfiguration).
    pub fn builder() -> crate::model::result_configuration::Builder {
        crate::model::result_configuration::Builder::default()
    }
}

/// <p>The database and data catalog context in which the query execution occurs.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct QueryExecutionContext {
    /// <p>The name of the database used in the query execution. The database must exist in the catalog.</p>
    #[doc(hidden)]
    pub database: std::option::Option<std::string::String>,
    /// <p>The name of the data catalog used in the query execution.</p>
    #[doc(hidden)]
    pub catalog: std::option::Option<std::string::String>,
}
impl QueryExecutionContext {
    /// <p>The name of the database used in the query execution. The database must exist in the catalog.</p>
    pub fn database(&self) -> std::option::Option<&str> {
        self.database.as_deref()
    }
    /// <p>The name of the data catalog used in the query execution.</p>
    pub fn catalog(&self) -> std::option::Option<&str> {
        self.catalog.as_deref()
    }
}
/// See [`QueryExecutionContext`](crate::model::QueryExecutionContext).
pub mod query_execution_context {

    /// A builder for [`QueryExecutionContext`](crate::model::QueryExecutionContext).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) database: std::option::Option<std::string::String>,
        pub(crate) catalog: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the database used in the query execution. The database must exist in the catalog.</p>
        pub fn database(mut self, input: impl Into<std::string::String>) -> Self {
            self.database = Some(input.into());
            self
        }
        /// <p>The name of the database used in the query execution. The database must exist in the catalog.</p>
        pub fn set_database(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.database = input;
            self
        }
        /// <p>The name of the data catalog used in the query execution.</p>
        pub fn catalog(mut self, input: impl Into<std::string::String>) -> Self {
            self.catalog = Some(input.into());
            self
        }
        /// <p>The name of the data catalog used in the query execution.</p>
        pub fn set_catalog(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.catalog = input;
            self
        }
        /// Consumes the builder and constructs a [`QueryExecutionContext`](crate::model::QueryExecutionContext).
        pub fn build(self) -> crate::model::QueryExecutionContext {
            crate::model::QueryExecutionContext {
                database: self.database,
                catalog: self.catalog,
            }
        }
    }
}
impl QueryExecutionContext {
    /// Creates a new builder-style object to manufacture [`QueryExecutionContext`](crate::model::QueryExecutionContext).
    pub fn builder() -> crate::model::query_execution_context::Builder {
        crate::model::query_execution_context::Builder::default()
    }
}

/// <p>Contains configuration information for the calculation.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CalculationConfiguration {
    /// <p>A string that contains the code for the calculation.</p>
    #[doc(hidden)]
    pub code_block: std::option::Option<std::string::String>,
}
impl CalculationConfiguration {
    /// <p>A string that contains the code for the calculation.</p>
    pub fn code_block(&self) -> std::option::Option<&str> {
        self.code_block.as_deref()
    }
}
/// See [`CalculationConfiguration`](crate::model::CalculationConfiguration).
pub mod calculation_configuration {

    /// A builder for [`CalculationConfiguration`](crate::model::CalculationConfiguration).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) code_block: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>A string that contains the code for the calculation.</p>
        pub fn code_block(mut self, input: impl Into<std::string::String>) -> Self {
            self.code_block = Some(input.into());
            self
        }
        /// <p>A string that contains the code for the calculation.</p>
        pub fn set_code_block(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.code_block = input;
            self
        }
        /// Consumes the builder and constructs a [`CalculationConfiguration`](crate::model::CalculationConfiguration).
        pub fn build(self) -> crate::model::CalculationConfiguration {
            crate::model::CalculationConfiguration {
                code_block: self.code_block,
            }
        }
    }
}
impl CalculationConfiguration {
    /// Creates a new builder-style object to manufacture [`CalculationConfiguration`](crate::model::CalculationConfiguration).
    pub fn builder() -> crate::model::calculation_configuration::Builder {
        crate::model::calculation_configuration::Builder::default()
    }
}

/// <p>The summary information for the workgroup, which includes its name, state, description, and the date and time it was created.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct WorkGroupSummary {
    /// <p>The name of the workgroup.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The state of the workgroup.</p>
    #[doc(hidden)]
    pub state: std::option::Option<crate::model::WorkGroupState>,
    /// <p>The workgroup description.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p>The workgroup creation date and time.</p>
    #[doc(hidden)]
    pub creation_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The engine version setting for all queries on the workgroup. Queries on the <code>AmazonAthenaPreviewFunctionality</code> workgroup run on the preview engine regardless of this setting.</p>
    #[doc(hidden)]
    pub engine_version: std::option::Option<crate::model::EngineVersion>,
}
impl WorkGroupSummary {
    /// <p>The name of the workgroup.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The state of the workgroup.</p>
    pub fn state(&self) -> std::option::Option<&crate::model::WorkGroupState> {
        self.state.as_ref()
    }
    /// <p>The workgroup description.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>The workgroup creation date and time.</p>
    pub fn creation_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.creation_time.as_ref()
    }
    /// <p>The engine version setting for all queries on the workgroup. Queries on the <code>AmazonAthenaPreviewFunctionality</code> workgroup run on the preview engine regardless of this setting.</p>
    pub fn engine_version(&self) -> std::option::Option<&crate::model::EngineVersion> {
        self.engine_version.as_ref()
    }
}
/// See [`WorkGroupSummary`](crate::model::WorkGroupSummary).
pub mod work_group_summary {

    /// A builder for [`WorkGroupSummary`](crate::model::WorkGroupSummary).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) state: std::option::Option<crate::model::WorkGroupState>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) creation_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) engine_version: std::option::Option<crate::model::EngineVersion>,
    }
    impl Builder {
        /// <p>The name of the workgroup.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the workgroup.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The state of the workgroup.</p>
        pub fn state(mut self, input: crate::model::WorkGroupState) -> Self {
            self.state = Some(input);
            self
        }
        /// <p>The state of the workgroup.</p>
        pub fn set_state(
            mut self,
            input: std::option::Option<crate::model::WorkGroupState>,
        ) -> Self {
            self.state = input;
            self
        }
        /// <p>The workgroup description.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>The workgroup description.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>The workgroup creation date and time.</p>
        pub fn creation_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.creation_time = Some(input);
            self
        }
        /// <p>The workgroup creation date and time.</p>
        pub fn set_creation_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.creation_time = input;
            self
        }
        /// <p>The engine version setting for all queries on the workgroup. Queries on the <code>AmazonAthenaPreviewFunctionality</code> workgroup run on the preview engine regardless of this setting.</p>
        pub fn engine_version(mut self, input: crate::model::EngineVersion) -> Self {
            self.engine_version = Some(input);
            self
        }
        /// <p>The engine version setting for all queries on the workgroup. Queries on the <code>AmazonAthenaPreviewFunctionality</code> workgroup run on the preview engine regardless of this setting.</p>
        pub fn set_engine_version(
            mut self,
            input: std::option::Option<crate::model::EngineVersion>,
        ) -> Self {
            self.engine_version = input;
            self
        }
        /// Consumes the builder and constructs a [`WorkGroupSummary`](crate::model::WorkGroupSummary).
        pub fn build(self) -> crate::model::WorkGroupSummary {
            crate::model::WorkGroupSummary {
                name: self.name,
                state: self.state,
                description: self.description,
                creation_time: self.creation_time,
                engine_version: self.engine_version,
            }
        }
    }
}
impl WorkGroupSummary {
    /// Creates a new builder-style object to manufacture [`WorkGroupSummary`](crate::model::WorkGroupSummary).
    pub fn builder() -> crate::model::work_group_summary::Builder {
        crate::model::work_group_summary::Builder::default()
    }
}

/// <p>Contains metadata for a table.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TableMetadata {
    /// <p>The name of the table.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The time that the table was created.</p>
    #[doc(hidden)]
    pub create_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The last time the table was accessed.</p>
    #[doc(hidden)]
    pub last_access_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The type of table. In Athena, only <code>EXTERNAL_TABLE</code> is supported.</p>
    #[doc(hidden)]
    pub table_type: std::option::Option<std::string::String>,
    /// <p>A list of the columns in the table.</p>
    #[doc(hidden)]
    pub columns: std::option::Option<std::vec::Vec<crate::model::Column>>,
    /// <p>A list of the partition keys in the table.</p>
    #[doc(hidden)]
    pub partition_keys: std::option::Option<std::vec::Vec<crate::model::Column>>,
    /// <p>A set of custom key/value pairs for table properties.</p>
    #[doc(hidden)]
    pub parameters:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
}
impl TableMetadata {
    /// <p>The name of the table.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The time that the table was created.</p>
    pub fn create_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.create_time.as_ref()
    }
    /// <p>The last time the table was accessed.</p>
    pub fn last_access_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.last_access_time.as_ref()
    }
    /// <p>The type of table. In Athena, only <code>EXTERNAL_TABLE</code> is supported.</p>
    pub fn table_type(&self) -> std::option::Option<&str> {
        self.table_type.as_deref()
    }
    /// <p>A list of the columns in the table.</p>
    pub fn columns(&self) -> std::option::Option<&[crate::model::Column]> {
        self.columns.as_deref()
    }
    /// <p>A list of the partition keys in the table.</p>
    pub fn partition_keys(&self) -> std::option::Option<&[crate::model::Column]> {
        self.partition_keys.as_deref()
    }
    /// <p>A set of custom key/value pairs for table properties.</p>
    pub fn parameters(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.parameters.as_ref()
    }
}
/// See [`TableMetadata`](crate::model::TableMetadata).
pub mod table_metadata {

    /// A builder for [`TableMetadata`](crate::model::TableMetadata).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) create_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) last_access_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) table_type: std::option::Option<std::string::String>,
        pub(crate) columns: std::option::Option<std::vec::Vec<crate::model::Column>>,
        pub(crate) partition_keys: std::option::Option<std::vec::Vec<crate::model::Column>>,
        pub(crate) parameters: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
    }
    impl Builder {
        /// <p>The name of the table.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the table.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The time that the table was created.</p>
        pub fn create_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.create_time = Some(input);
            self
        }
        /// <p>The time that the table was created.</p>
        pub fn set_create_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.create_time = input;
            self
        }
        /// <p>The last time the table was accessed.</p>
        pub fn last_access_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.last_access_time = Some(input);
            self
        }
        /// <p>The last time the table was accessed.</p>
        pub fn set_last_access_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.last_access_time = input;
            self
        }
        /// <p>The type of table. In Athena, only <code>EXTERNAL_TABLE</code> is supported.</p>
        pub fn table_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.table_type = Some(input.into());
            self
        }
        /// <p>The type of table. In Athena, only <code>EXTERNAL_TABLE</code> is supported.</p>
        pub fn set_table_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.table_type = input;
            self
        }
        /// Appends an item to `columns`.
        ///
        /// To override the contents of this collection use [`set_columns`](Self::set_columns).
        ///
        /// <p>A list of the columns in the table.</p>
        pub fn columns(mut self, input: crate::model::Column) -> Self {
            let mut v = self.columns.unwrap_or_default();
            v.push(input);
            self.columns = Some(v);
            self
        }
        /// <p>A list of the columns in the table.</p>
        pub fn set_columns(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Column>>,
        ) -> Self {
            self.columns = input;
            self
        }
        /// Appends an item to `partition_keys`.
        ///
        /// To override the contents of this collection use [`set_partition_keys`](Self::set_partition_keys).
        ///
        /// <p>A list of the partition keys in the table.</p>
        pub fn partition_keys(mut self, input: crate::model::Column) -> Self {
            let mut v = self.partition_keys.unwrap_or_default();
            v.push(input);
            self.partition_keys = Some(v);
            self
        }
        /// <p>A list of the partition keys in the table.</p>
        pub fn set_partition_keys(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Column>>,
        ) -> Self {
            self.partition_keys = input;
            self
        }
        /// Adds a key-value pair to `parameters`.
        ///
        /// To override the contents of this collection use [`set_parameters`](Self::set_parameters).
        ///
        /// <p>A set of custom key/value pairs for table properties.</p>
        pub fn parameters(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.parameters.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.parameters = Some(hash_map);
            self
        }
        /// <p>A set of custom key/value pairs for table properties.</p>
        pub fn set_parameters(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.parameters = input;
            self
        }
        /// Consumes the builder and constructs a [`TableMetadata`](crate::model::TableMetadata).
        pub fn build(self) -> crate::model::TableMetadata {
            crate::model::TableMetadata {
                name: self.name,
                create_time: self.create_time,
                last_access_time: self.last_access_time,
                table_type: self.table_type,
                columns: self.columns,
                partition_keys: self.partition_keys,
                parameters: self.parameters,
            }
        }
    }
}
impl TableMetadata {
    /// Creates a new builder-style object to manufacture [`TableMetadata`](crate::model::TableMetadata).
    pub fn builder() -> crate::model::table_metadata::Builder {
        crate::model::table_metadata::Builder::default()
    }
}

/// <p>Contains metadata for a column in a table.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Column {
    /// <p>The name of the column.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The data type of the column.</p>
    #[doc(hidden)]
    pub r#type: std::option::Option<std::string::String>,
    /// <p>Optional information about the column.</p>
    #[doc(hidden)]
    pub comment: std::option::Option<std::string::String>,
}
impl Column {
    /// <p>The name of the column.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The data type of the column.</p>
    pub fn r#type(&self) -> std::option::Option<&str> {
        self.r#type.as_deref()
    }
    /// <p>Optional information about the column.</p>
    pub fn comment(&self) -> std::option::Option<&str> {
        self.comment.as_deref()
    }
}
/// See [`Column`](crate::model::Column).
pub mod column {

    /// A builder for [`Column`](crate::model::Column).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) r#type: std::option::Option<std::string::String>,
        pub(crate) comment: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the column.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the column.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The data type of the column.</p>
        pub fn r#type(mut self, input: impl Into<std::string::String>) -> Self {
            self.r#type = Some(input.into());
            self
        }
        /// <p>The data type of the column.</p>
        pub fn set_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.r#type = input;
            self
        }
        /// <p>Optional information about the column.</p>
        pub fn comment(mut self, input: impl Into<std::string::String>) -> Self {
            self.comment = Some(input.into());
            self
        }
        /// <p>Optional information about the column.</p>
        pub fn set_comment(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.comment = input;
            self
        }
        /// Consumes the builder and constructs a [`Column`](crate::model::Column).
        pub fn build(self) -> crate::model::Column {
            crate::model::Column {
                name: self.name,
                r#type: self.r#type,
                comment: self.comment,
            }
        }
    }
}
impl Column {
    /// Creates a new builder-style object to manufacture [`Column`](crate::model::Column).
    pub fn builder() -> crate::model::column::Builder {
        crate::model::column::Builder::default()
    }
}

/// <p>Contains summary information about a notebook session.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct SessionSummary {
    /// <p>The session ID.</p>
    #[doc(hidden)]
    pub session_id: std::option::Option<std::string::String>,
    /// <p>The session description.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p>The engine version used by the session (for example, <code>PySpark engine version 3</code>).</p>
    #[doc(hidden)]
    pub engine_version: std::option::Option<crate::model::EngineVersion>,
    /// <p>The notebook version.</p>
    #[doc(hidden)]
    pub notebook_version: std::option::Option<std::string::String>,
    /// <p>Contains information about the session status.</p>
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::SessionStatus>,
}
impl SessionSummary {
    /// <p>The session ID.</p>
    pub fn session_id(&self) -> std::option::Option<&str> {
        self.session_id.as_deref()
    }
    /// <p>The session description.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>The engine version used by the session (for example, <code>PySpark engine version 3</code>).</p>
    pub fn engine_version(&self) -> std::option::Option<&crate::model::EngineVersion> {
        self.engine_version.as_ref()
    }
    /// <p>The notebook version.</p>
    pub fn notebook_version(&self) -> std::option::Option<&str> {
        self.notebook_version.as_deref()
    }
    /// <p>Contains information about the session status.</p>
    pub fn status(&self) -> std::option::Option<&crate::model::SessionStatus> {
        self.status.as_ref()
    }
}
/// See [`SessionSummary`](crate::model::SessionSummary).
pub mod session_summary {

    /// A builder for [`SessionSummary`](crate::model::SessionSummary).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) session_id: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) engine_version: std::option::Option<crate::model::EngineVersion>,
        pub(crate) notebook_version: std::option::Option<std::string::String>,
        pub(crate) status: std::option::Option<crate::model::SessionStatus>,
    }
    impl Builder {
        /// <p>The session ID.</p>
        pub fn session_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.session_id = Some(input.into());
            self
        }
        /// <p>The session ID.</p>
        pub fn set_session_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.session_id = input;
            self
        }
        /// <p>The session description.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>The session description.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>The engine version used by the session (for example, <code>PySpark engine version 3</code>).</p>
        pub fn engine_version(mut self, input: crate::model::EngineVersion) -> Self {
            self.engine_version = Some(input);
            self
        }
        /// <p>The engine version used by the session (for example, <code>PySpark engine version 3</code>).</p>
        pub fn set_engine_version(
            mut self,
            input: std::option::Option<crate::model::EngineVersion>,
        ) -> Self {
            self.engine_version = input;
            self
        }
        /// <p>The notebook version.</p>
        pub fn notebook_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.notebook_version = Some(input.into());
            self
        }
        /// <p>The notebook version.</p>
        pub fn set_notebook_version(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.notebook_version = input;
            self
        }
        /// <p>Contains information about the session status.</p>
        pub fn status(mut self, input: crate::model::SessionStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>Contains information about the session status.</p>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::SessionStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// Consumes the builder and constructs a [`SessionSummary`](crate::model::SessionSummary).
        pub fn build(self) -> crate::model::SessionSummary {
            crate::model::SessionSummary {
                session_id: self.session_id,
                description: self.description,
                engine_version: self.engine_version,
                notebook_version: self.notebook_version,
                status: self.status,
            }
        }
    }
}
impl SessionSummary {
    /// Creates a new builder-style object to manufacture [`SessionSummary`](crate::model::SessionSummary).
    pub fn builder() -> crate::model::session_summary::Builder {
        crate::model::session_summary::Builder::default()
    }
}

/// <p>Contains information about the status of a notebook session.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct SessionStatus {
    /// <p>The date and time that the session started.</p>
    #[doc(hidden)]
    pub start_date_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The most recent date and time that the session was modified.</p>
    #[doc(hidden)]
    pub last_modified_date_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The date and time that the session ended.</p>
    #[doc(hidden)]
    pub end_date_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The date and time starting at which the session became idle. Can be empty if the session is not currently idle.</p>
    #[doc(hidden)]
    pub idle_since_date_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The state of the session. A description of each state follows.</p>
    /// <p> <code>CREATING</code> - The session is being started, including acquiring resources.</p>
    /// <p> <code>CREATED</code> - The session has been started.</p>
    /// <p> <code>IDLE</code> - The session is able to accept a calculation.</p>
    /// <p> <code>BUSY</code> - The session is processing another task and is unable to accept a calculation.</p>
    /// <p> <code>TERMINATING</code> - The session is in the process of shutting down.</p>
    /// <p> <code>TERMINATED</code> - The session and its resources are no longer running.</p>
    /// <p> <code>DEGRADED</code> - The session has no healthy coordinators.</p>
    /// <p> <code>FAILED</code> - Due to a failure, the session and its resources are no longer running.</p>
    #[doc(hidden)]
    pub state: std::option::Option<crate::model::SessionState>,
    /// <p>The reason for the session state change (for example, canceled because the session was terminated).</p>
    #[doc(hidden)]
    pub state_change_reason: std::option::Option<std::string::String>,
}
impl SessionStatus {
    /// <p>The date and time that the session started.</p>
    pub fn start_date_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.start_date_time.as_ref()
    }
    /// <p>The most recent date and time that the session was modified.</p>
    pub fn last_modified_date_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.last_modified_date_time.as_ref()
    }
    /// <p>The date and time that the session ended.</p>
    pub fn end_date_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.end_date_time.as_ref()
    }
    /// <p>The date and time starting at which the session became idle. Can be empty if the session is not currently idle.</p>
    pub fn idle_since_date_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.idle_since_date_time.as_ref()
    }
    /// <p>The state of the session. A description of each state follows.</p>
    /// <p> <code>CREATING</code> - The session is being started, including acquiring resources.</p>
    /// <p> <code>CREATED</code> - The session has been started.</p>
    /// <p> <code>IDLE</code> - The session is able to accept a calculation.</p>
    /// <p> <code>BUSY</code> - The session is processing another task and is unable to accept a calculation.</p>
    /// <p> <code>TERMINATING</code> - The session is in the process of shutting down.</p>
    /// <p> <code>TERMINATED</code> - The session and its resources are no longer running.</p>
    /// <p> <code>DEGRADED</code> - The session has no healthy coordinators.</p>
    /// <p> <code>FAILED</code> - Due to a failure, the session and its resources are no longer running.</p>
    pub fn state(&self) -> std::option::Option<&crate::model::SessionState> {
        self.state.as_ref()
    }
    /// <p>The reason for the session state change (for example, canceled because the session was terminated).</p>
    pub fn state_change_reason(&self) -> std::option::Option<&str> {
        self.state_change_reason.as_deref()
    }
}
/// See [`SessionStatus`](crate::model::SessionStatus).
pub mod session_status {

    /// A builder for [`SessionStatus`](crate::model::SessionStatus).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) start_date_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) last_modified_date_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) end_date_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) idle_since_date_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) state: std::option::Option<crate::model::SessionState>,
        pub(crate) state_change_reason: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The date and time that the session started.</p>
        pub fn start_date_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.start_date_time = Some(input);
            self
        }
        /// <p>The date and time that the session started.</p>
        pub fn set_start_date_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.start_date_time = input;
            self
        }
        /// <p>The most recent date and time that the session was modified.</p>
        pub fn last_modified_date_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.last_modified_date_time = Some(input);
            self
        }
        /// <p>The most recent date and time that the session was modified.</p>
        pub fn set_last_modified_date_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.last_modified_date_time = input;
            self
        }
        /// <p>The date and time that the session ended.</p>
        pub fn end_date_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.end_date_time = Some(input);
            self
        }
        /// <p>The date and time that the session ended.</p>
        pub fn set_end_date_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.end_date_time = input;
            self
        }
        /// <p>The date and time starting at which the session became idle. Can be empty if the session is not currently idle.</p>
        pub fn idle_since_date_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.idle_since_date_time = Some(input);
            self
        }
        /// <p>The date and time starting at which the session became idle. Can be empty if the session is not currently idle.</p>
        pub fn set_idle_since_date_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.idle_since_date_time = input;
            self
        }
        /// <p>The state of the session. A description of each state follows.</p>
        /// <p> <code>CREATING</code> - The session is being started, including acquiring resources.</p>
        /// <p> <code>CREATED</code> - The session has been started.</p>
        /// <p> <code>IDLE</code> - The session is able to accept a calculation.</p>
        /// <p> <code>BUSY</code> - The session is processing another task and is unable to accept a calculation.</p>
        /// <p> <code>TERMINATING</code> - The session is in the process of shutting down.</p>
        /// <p> <code>TERMINATED</code> - The session and its resources are no longer running.</p>
        /// <p> <code>DEGRADED</code> - The session has no healthy coordinators.</p>
        /// <p> <code>FAILED</code> - Due to a failure, the session and its resources are no longer running.</p>
        pub fn state(mut self, input: crate::model::SessionState) -> Self {
            self.state = Some(input);
            self
        }
        /// <p>The state of the session. A description of each state follows.</p>
        /// <p> <code>CREATING</code> - The session is being started, including acquiring resources.</p>
        /// <p> <code>CREATED</code> - The session has been started.</p>
        /// <p> <code>IDLE</code> - The session is able to accept a calculation.</p>
        /// <p> <code>BUSY</code> - The session is processing another task and is unable to accept a calculation.</p>
        /// <p> <code>TERMINATING</code> - The session is in the process of shutting down.</p>
        /// <p> <code>TERMINATED</code> - The session and its resources are no longer running.</p>
        /// <p> <code>DEGRADED</code> - The session has no healthy coordinators.</p>
        /// <p> <code>FAILED</code> - Due to a failure, the session and its resources are no longer running.</p>
        pub fn set_state(mut self, input: std::option::Option<crate::model::SessionState>) -> Self {
            self.state = input;
            self
        }
        /// <p>The reason for the session state change (for example, canceled because the session was terminated).</p>
        pub fn state_change_reason(mut self, input: impl Into<std::string::String>) -> Self {
            self.state_change_reason = Some(input.into());
            self
        }
        /// <p>The reason for the session state change (for example, canceled because the session was terminated).</p>
        pub fn set_state_change_reason(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.state_change_reason = input;
            self
        }
        /// Consumes the builder and constructs a [`SessionStatus`](crate::model::SessionStatus).
        pub fn build(self) -> crate::model::SessionStatus {
            crate::model::SessionStatus {
                start_date_time: self.start_date_time,
                last_modified_date_time: self.last_modified_date_time,
                end_date_time: self.end_date_time,
                idle_since_date_time: self.idle_since_date_time,
                state: self.state,
                state_change_reason: self.state_change_reason,
            }
        }
    }
}
impl SessionStatus {
    /// Creates a new builder-style object to manufacture [`SessionStatus`](crate::model::SessionStatus).
    pub fn builder() -> crate::model::session_status::Builder {
        crate::model::session_status::Builder::default()
    }
}

/// <p>The name and last modified time of the prepared statement.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct PreparedStatementSummary {
    /// <p>The name of the prepared statement.</p>
    #[doc(hidden)]
    pub statement_name: std::option::Option<std::string::String>,
    /// <p>The last modified time of the prepared statement.</p>
    #[doc(hidden)]
    pub last_modified_time: std::option::Option<aws_smithy_types::DateTime>,
}
impl PreparedStatementSummary {
    /// <p>The name of the prepared statement.</p>
    pub fn statement_name(&self) -> std::option::Option<&str> {
        self.statement_name.as_deref()
    }
    /// <p>The last modified time of the prepared statement.</p>
    pub fn last_modified_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.last_modified_time.as_ref()
    }
}
/// See [`PreparedStatementSummary`](crate::model::PreparedStatementSummary).
pub mod prepared_statement_summary {

    /// A builder for [`PreparedStatementSummary`](crate::model::PreparedStatementSummary).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) statement_name: std::option::Option<std::string::String>,
        pub(crate) last_modified_time: std::option::Option<aws_smithy_types::DateTime>,
    }
    impl Builder {
        /// <p>The name of the prepared statement.</p>
        pub fn statement_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.statement_name = Some(input.into());
            self
        }
        /// <p>The name of the prepared statement.</p>
        pub fn set_statement_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.statement_name = input;
            self
        }
        /// <p>The last modified time of the prepared statement.</p>
        pub fn last_modified_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.last_modified_time = Some(input);
            self
        }
        /// <p>The last modified time of the prepared statement.</p>
        pub fn set_last_modified_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.last_modified_time = input;
            self
        }
        /// Consumes the builder and constructs a [`PreparedStatementSummary`](crate::model::PreparedStatementSummary).
        pub fn build(self) -> crate::model::PreparedStatementSummary {
            crate::model::PreparedStatementSummary {
                statement_name: self.statement_name,
                last_modified_time: self.last_modified_time,
            }
        }
    }
}
impl PreparedStatementSummary {
    /// Creates a new builder-style object to manufacture [`PreparedStatementSummary`](crate::model::PreparedStatementSummary).
    pub fn builder() -> crate::model::prepared_statement_summary::Builder {
        crate::model::prepared_statement_summary::Builder::default()
    }
}

/// <p>Contains the notebook session ID and notebook session creation time.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct NotebookSessionSummary {
    /// <p>The notebook session ID.</p>
    #[doc(hidden)]
    pub session_id: std::option::Option<std::string::String>,
    /// <p>The time when the notebook session was created.</p>
    #[doc(hidden)]
    pub creation_time: std::option::Option<aws_smithy_types::DateTime>,
}
impl NotebookSessionSummary {
    /// <p>The notebook session ID.</p>
    pub fn session_id(&self) -> std::option::Option<&str> {
        self.session_id.as_deref()
    }
    /// <p>The time when the notebook session was created.</p>
    pub fn creation_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.creation_time.as_ref()
    }
}
/// See [`NotebookSessionSummary`](crate::model::NotebookSessionSummary).
pub mod notebook_session_summary {

    /// A builder for [`NotebookSessionSummary`](crate::model::NotebookSessionSummary).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) session_id: std::option::Option<std::string::String>,
        pub(crate) creation_time: std::option::Option<aws_smithy_types::DateTime>,
    }
    impl Builder {
        /// <p>The notebook session ID.</p>
        pub fn session_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.session_id = Some(input.into());
            self
        }
        /// <p>The notebook session ID.</p>
        pub fn set_session_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.session_id = input;
            self
        }
        /// <p>The time when the notebook session was created.</p>
        pub fn creation_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.creation_time = Some(input);
            self
        }
        /// <p>The time when the notebook session was created.</p>
        pub fn set_creation_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.creation_time = input;
            self
        }
        /// Consumes the builder and constructs a [`NotebookSessionSummary`](crate::model::NotebookSessionSummary).
        pub fn build(self) -> crate::model::NotebookSessionSummary {
            crate::model::NotebookSessionSummary {
                session_id: self.session_id,
                creation_time: self.creation_time,
            }
        }
    }
}
impl NotebookSessionSummary {
    /// Creates a new builder-style object to manufacture [`NotebookSessionSummary`](crate::model::NotebookSessionSummary).
    pub fn builder() -> crate::model::notebook_session_summary::Builder {
        crate::model::notebook_session_summary::Builder::default()
    }
}

/// <p>Contains metadata for notebook, including the notebook name, ID, workgroup, and time created.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct NotebookMetadata {
    /// <p>The notebook ID.</p>
    #[doc(hidden)]
    pub notebook_id: std::option::Option<std::string::String>,
    /// <p>The name of the notebook.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The name of the Spark enabled workgroup to which the notebook belongs.</p>
    #[doc(hidden)]
    pub work_group: std::option::Option<std::string::String>,
    /// <p>The time when the notebook was created.</p>
    #[doc(hidden)]
    pub creation_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The type of notebook. Currently, the only valid type is <code>IPYNB</code>.</p>
    #[doc(hidden)]
    pub r#type: std::option::Option<crate::model::NotebookType>,
    /// <p>The time when the notebook was last modified.</p>
    #[doc(hidden)]
    pub last_modified_time: std::option::Option<aws_smithy_types::DateTime>,
}
impl NotebookMetadata {
    /// <p>The notebook ID.</p>
    pub fn notebook_id(&self) -> std::option::Option<&str> {
        self.notebook_id.as_deref()
    }
    /// <p>The name of the notebook.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The name of the Spark enabled workgroup to which the notebook belongs.</p>
    pub fn work_group(&self) -> std::option::Option<&str> {
        self.work_group.as_deref()
    }
    /// <p>The time when the notebook was created.</p>
    pub fn creation_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.creation_time.as_ref()
    }
    /// <p>The type of notebook. Currently, the only valid type is <code>IPYNB</code>.</p>
    pub fn r#type(&self) -> std::option::Option<&crate::model::NotebookType> {
        self.r#type.as_ref()
    }
    /// <p>The time when the notebook was last modified.</p>
    pub fn last_modified_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.last_modified_time.as_ref()
    }
}
/// See [`NotebookMetadata`](crate::model::NotebookMetadata).
pub mod notebook_metadata {

    /// A builder for [`NotebookMetadata`](crate::model::NotebookMetadata).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) notebook_id: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) work_group: std::option::Option<std::string::String>,
        pub(crate) creation_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) r#type: std::option::Option<crate::model::NotebookType>,
        pub(crate) last_modified_time: std::option::Option<aws_smithy_types::DateTime>,
    }
    impl Builder {
        /// <p>The notebook ID.</p>
        pub fn notebook_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.notebook_id = Some(input.into());
            self
        }
        /// <p>The notebook ID.</p>
        pub fn set_notebook_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.notebook_id = input;
            self
        }
        /// <p>The name of the notebook.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the notebook.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The name of the Spark enabled workgroup to which the notebook belongs.</p>
        pub fn work_group(mut self, input: impl Into<std::string::String>) -> Self {
            self.work_group = Some(input.into());
            self
        }
        /// <p>The name of the Spark enabled workgroup to which the notebook belongs.</p>
        pub fn set_work_group(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.work_group = input;
            self
        }
        /// <p>The time when the notebook was created.</p>
        pub fn creation_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.creation_time = Some(input);
            self
        }
        /// <p>The time when the notebook was created.</p>
        pub fn set_creation_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.creation_time = input;
            self
        }
        /// <p>The type of notebook. Currently, the only valid type is <code>IPYNB</code>.</p>
        pub fn r#type(mut self, input: crate::model::NotebookType) -> Self {
            self.r#type = Some(input);
            self
        }
        /// <p>The type of notebook. Currently, the only valid type is <code>IPYNB</code>.</p>
        pub fn set_type(mut self, input: std::option::Option<crate::model::NotebookType>) -> Self {
            self.r#type = input;
            self
        }
        /// <p>The time when the notebook was last modified.</p>
        pub fn last_modified_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.last_modified_time = Some(input);
            self
        }
        /// <p>The time when the notebook was last modified.</p>
        pub fn set_last_modified_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.last_modified_time = input;
            self
        }
        /// Consumes the builder and constructs a [`NotebookMetadata`](crate::model::NotebookMetadata).
        pub fn build(self) -> crate::model::NotebookMetadata {
            crate::model::NotebookMetadata {
                notebook_id: self.notebook_id,
                name: self.name,
                work_group: self.work_group,
                creation_time: self.creation_time,
                r#type: self.r#type,
                last_modified_time: self.last_modified_time,
            }
        }
    }
}
impl NotebookMetadata {
    /// Creates a new builder-style object to manufacture [`NotebookMetadata`](crate::model::NotebookMetadata).
    pub fn builder() -> crate::model::notebook_metadata::Builder {
        crate::model::notebook_metadata::Builder::default()
    }
}

/// <p>A string for searching notebook names.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct FilterDefinition {
    /// <p>The name of the notebook to search for.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
}
impl FilterDefinition {
    /// <p>The name of the notebook to search for.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
}
/// See [`FilterDefinition`](crate::model::FilterDefinition).
pub mod filter_definition {

    /// A builder for [`FilterDefinition`](crate::model::FilterDefinition).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the notebook to search for.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the notebook to search for.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// Consumes the builder and constructs a [`FilterDefinition`](crate::model::FilterDefinition).
        pub fn build(self) -> crate::model::FilterDefinition {
            crate::model::FilterDefinition { name: self.name }
        }
    }
}
impl FilterDefinition {
    /// Creates a new builder-style object to manufacture [`FilterDefinition`](crate::model::FilterDefinition).
    pub fn builder() -> crate::model::filter_definition::Builder {
        crate::model::filter_definition::Builder::default()
    }
}

/// <p>Contains summary information about an executor.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ExecutorsSummary {
    /// <p>The UUID of the executor.</p>
    #[doc(hidden)]
    pub executor_id: std::option::Option<std::string::String>,
    /// <p>The type of executor used for the application (<code>COORDINATOR</code>, <code>GATEWAY</code>, or <code>WORKER</code>).</p>
    #[doc(hidden)]
    pub executor_type: std::option::Option<crate::model::ExecutorType>,
    /// <p>The date and time that the executor started.</p>
    #[doc(hidden)]
    pub start_date_time: std::option::Option<i64>,
    /// <p>The date and time that the executor was terminated.</p>
    #[doc(hidden)]
    pub termination_date_time: std::option::Option<i64>,
    /// <p>The processing state of the executor. A description of each state follows.</p>
    /// <p> <code>CREATING</code> - The executor is being started, including acquiring resources.</p>
    /// <p> <code>CREATED</code> - The executor has been started.</p>
    /// <p> <code>REGISTERED</code> - The executor has been registered.</p>
    /// <p> <code>TERMINATING</code> - The executor is in the process of shutting down.</p>
    /// <p> <code>TERMINATED</code> - The executor is no longer running.</p>
    /// <p> <code>FAILED</code> - Due to a failure, the executor is no longer running.</p>
    #[doc(hidden)]
    pub executor_state: std::option::Option<crate::model::ExecutorState>,
    /// <p>The smallest unit of compute that a session can request from Athena. Size is measured in data processing unit (DPU) values, a relative measure of processing power.</p>
    #[doc(hidden)]
    pub executor_size: std::option::Option<i64>,
}
impl ExecutorsSummary {
    /// <p>The UUID of the executor.</p>
    pub fn executor_id(&self) -> std::option::Option<&str> {
        self.executor_id.as_deref()
    }
    /// <p>The type of executor used for the application (<code>COORDINATOR</code>, <code>GATEWAY</code>, or <code>WORKER</code>).</p>
    pub fn executor_type(&self) -> std::option::Option<&crate::model::ExecutorType> {
        self.executor_type.as_ref()
    }
    /// <p>The date and time that the executor started.</p>
    pub fn start_date_time(&self) -> std::option::Option<i64> {
        self.start_date_time
    }
    /// <p>The date and time that the executor was terminated.</p>
    pub fn termination_date_time(&self) -> std::option::Option<i64> {
        self.termination_date_time
    }
    /// <p>The processing state of the executor. A description of each state follows.</p>
    /// <p> <code>CREATING</code> - The executor is being started, including acquiring resources.</p>
    /// <p> <code>CREATED</code> - The executor has been started.</p>
    /// <p> <code>REGISTERED</code> - The executor has been registered.</p>
    /// <p> <code>TERMINATING</code> - The executor is in the process of shutting down.</p>
    /// <p> <code>TERMINATED</code> - The executor is no longer running.</p>
    /// <p> <code>FAILED</code> - Due to a failure, the executor is no longer running.</p>
    pub fn executor_state(&self) -> std::option::Option<&crate::model::ExecutorState> {
        self.executor_state.as_ref()
    }
    /// <p>The smallest unit of compute that a session can request from Athena. Size is measured in data processing unit (DPU) values, a relative measure of processing power.</p>
    pub fn executor_size(&self) -> std::option::Option<i64> {
        self.executor_size
    }
}
/// See [`ExecutorsSummary`](crate::model::ExecutorsSummary).
pub mod executors_summary {

    /// A builder for [`ExecutorsSummary`](crate::model::ExecutorsSummary).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) executor_id: std::option::Option<std::string::String>,
        pub(crate) executor_type: std::option::Option<crate::model::ExecutorType>,
        pub(crate) start_date_time: std::option::Option<i64>,
        pub(crate) termination_date_time: std::option::Option<i64>,
        pub(crate) executor_state: std::option::Option<crate::model::ExecutorState>,
        pub(crate) executor_size: std::option::Option<i64>,
    }
    impl Builder {
        /// <p>The UUID of the executor.</p>
        pub fn executor_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.executor_id = Some(input.into());
            self
        }
        /// <p>The UUID of the executor.</p>
        pub fn set_executor_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.executor_id = input;
            self
        }
        /// <p>The type of executor used for the application (<code>COORDINATOR</code>, <code>GATEWAY</code>, or <code>WORKER</code>).</p>
        pub fn executor_type(mut self, input: crate::model::ExecutorType) -> Self {
            self.executor_type = Some(input);
            self
        }
        /// <p>The type of executor used for the application (<code>COORDINATOR</code>, <code>GATEWAY</code>, or <code>WORKER</code>).</p>
        pub fn set_executor_type(
            mut self,
            input: std::option::Option<crate::model::ExecutorType>,
        ) -> Self {
            self.executor_type = input;
            self
        }
        /// <p>The date and time that the executor started.</p>
        pub fn start_date_time(mut self, input: i64) -> Self {
            self.start_date_time = Some(input);
            self
        }
        /// <p>The date and time that the executor started.</p>
        pub fn set_start_date_time(mut self, input: std::option::Option<i64>) -> Self {
            self.start_date_time = input;
            self
        }
        /// <p>The date and time that the executor was terminated.</p>
        pub fn termination_date_time(mut self, input: i64) -> Self {
            self.termination_date_time = Some(input);
            self
        }
        /// <p>The date and time that the executor was terminated.</p>
        pub fn set_termination_date_time(mut self, input: std::option::Option<i64>) -> Self {
            self.termination_date_time = input;
            self
        }
        /// <p>The processing state of the executor. A description of each state follows.</p>
        /// <p> <code>CREATING</code> - The executor is being started, including acquiring resources.</p>
        /// <p> <code>CREATED</code> - The executor has been started.</p>
        /// <p> <code>REGISTERED</code> - The executor has been registered.</p>
        /// <p> <code>TERMINATING</code> - The executor is in the process of shutting down.</p>
        /// <p> <code>TERMINATED</code> - The executor is no longer running.</p>
        /// <p> <code>FAILED</code> - Due to a failure, the executor is no longer running.</p>
        pub fn executor_state(mut self, input: crate::model::ExecutorState) -> Self {
            self.executor_state = Some(input);
            self
        }
        /// <p>The processing state of the executor. A description of each state follows.</p>
        /// <p> <code>CREATING</code> - The executor is being started, including acquiring resources.</p>
        /// <p> <code>CREATED</code> - The executor has been started.</p>
        /// <p> <code>REGISTERED</code> - The executor has been registered.</p>
        /// <p> <code>TERMINATING</code> - The executor is in the process of shutting down.</p>
        /// <p> <code>TERMINATED</code> - The executor is no longer running.</p>
        /// <p> <code>FAILED</code> - Due to a failure, the executor is no longer running.</p>
        pub fn set_executor_state(
            mut self,
            input: std::option::Option<crate::model::ExecutorState>,
        ) -> Self {
            self.executor_state = input;
            self
        }
        /// <p>The smallest unit of compute that a session can request from Athena. Size is measured in data processing unit (DPU) values, a relative measure of processing power.</p>
        pub fn executor_size(mut self, input: i64) -> Self {
            self.executor_size = Some(input);
            self
        }
        /// <p>The smallest unit of compute that a session can request from Athena. Size is measured in data processing unit (DPU) values, a relative measure of processing power.</p>
        pub fn set_executor_size(mut self, input: std::option::Option<i64>) -> Self {
            self.executor_size = input;
            self
        }
        /// Consumes the builder and constructs a [`ExecutorsSummary`](crate::model::ExecutorsSummary).
        pub fn build(self) -> crate::model::ExecutorsSummary {
            crate::model::ExecutorsSummary {
                executor_id: self.executor_id,
                executor_type: self.executor_type,
                start_date_time: self.start_date_time,
                termination_date_time: self.termination_date_time,
                executor_state: self.executor_state,
                executor_size: self.executor_size,
            }
        }
    }
}
impl ExecutorsSummary {
    /// Creates a new builder-style object to manufacture [`ExecutorsSummary`](crate::model::ExecutorsSummary).
    pub fn builder() -> crate::model::executors_summary::Builder {
        crate::model::executors_summary::Builder::default()
    }
}

/// When writing a match expression against `ExecutorState`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let executorstate = unimplemented!();
/// match executorstate {
///     ExecutorState::Created => { /* ... */ },
///     ExecutorState::Creating => { /* ... */ },
///     ExecutorState::Failed => { /* ... */ },
///     ExecutorState::Registered => { /* ... */ },
///     ExecutorState::Terminated => { /* ... */ },
///     ExecutorState::Terminating => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `executorstate` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ExecutorState::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ExecutorState::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ExecutorState::NewFeature` is defined.
/// Specifically, when `executorstate` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ExecutorState::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ExecutorState {
    #[allow(missing_docs)] // documentation missing in model
    Created,
    #[allow(missing_docs)] // documentation missing in model
    Creating,
    #[allow(missing_docs)] // documentation missing in model
    Failed,
    #[allow(missing_docs)] // documentation missing in model
    Registered,
    #[allow(missing_docs)] // documentation missing in model
    Terminated,
    #[allow(missing_docs)] // documentation missing in model
    Terminating,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ExecutorState {
    fn from(s: &str) -> Self {
        match s {
            "CREATED" => ExecutorState::Created,
            "CREATING" => ExecutorState::Creating,
            "FAILED" => ExecutorState::Failed,
            "REGISTERED" => ExecutorState::Registered,
            "TERMINATED" => ExecutorState::Terminated,
            "TERMINATING" => ExecutorState::Terminating,
            other => ExecutorState::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for ExecutorState {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ExecutorState::from(s))
    }
}
impl ExecutorState {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ExecutorState::Created => "CREATED",
            ExecutorState::Creating => "CREATING",
            ExecutorState::Failed => "FAILED",
            ExecutorState::Registered => "REGISTERED",
            ExecutorState::Terminated => "TERMINATED",
            ExecutorState::Terminating => "TERMINATING",
            ExecutorState::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "CREATED",
            "CREATING",
            "FAILED",
            "REGISTERED",
            "TERMINATED",
            "TERMINATING",
        ]
    }
}
impl AsRef<str> for ExecutorState {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `ExecutorType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let executortype = unimplemented!();
/// match executortype {
///     ExecutorType::Coordinator => { /* ... */ },
///     ExecutorType::Gateway => { /* ... */ },
///     ExecutorType::Worker => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `executortype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ExecutorType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ExecutorType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ExecutorType::NewFeature` is defined.
/// Specifically, when `executortype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ExecutorType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ExecutorType {
    #[allow(missing_docs)] // documentation missing in model
    Coordinator,
    #[allow(missing_docs)] // documentation missing in model
    Gateway,
    #[allow(missing_docs)] // documentation missing in model
    Worker,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ExecutorType {
    fn from(s: &str) -> Self {
        match s {
            "COORDINATOR" => ExecutorType::Coordinator,
            "GATEWAY" => ExecutorType::Gateway,
            "WORKER" => ExecutorType::Worker,
            other => ExecutorType::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for ExecutorType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ExecutorType::from(s))
    }
}
impl ExecutorType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ExecutorType::Coordinator => "COORDINATOR",
            ExecutorType::Gateway => "GATEWAY",
            ExecutorType::Worker => "WORKER",
            ExecutorType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["COORDINATOR", "GATEWAY", "WORKER"]
    }
}
impl AsRef<str> for ExecutorType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The summary information for the data catalog, which includes its name and type.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DataCatalogSummary {
    /// <p>The name of the data catalog. The catalog name is unique for the Amazon Web Services account and can use a maximum of 127 alphanumeric, underscore, at sign, or hyphen characters. The remainder of the length constraint of 256 is reserved for use by Athena.</p>
    #[doc(hidden)]
    pub catalog_name: std::option::Option<std::string::String>,
    /// <p>The data catalog type.</p>
    #[doc(hidden)]
    pub r#type: std::option::Option<crate::model::DataCatalogType>,
}
impl DataCatalogSummary {
    /// <p>The name of the data catalog. The catalog name is unique for the Amazon Web Services account and can use a maximum of 127 alphanumeric, underscore, at sign, or hyphen characters. The remainder of the length constraint of 256 is reserved for use by Athena.</p>
    pub fn catalog_name(&self) -> std::option::Option<&str> {
        self.catalog_name.as_deref()
    }
    /// <p>The data catalog type.</p>
    pub fn r#type(&self) -> std::option::Option<&crate::model::DataCatalogType> {
        self.r#type.as_ref()
    }
}
/// See [`DataCatalogSummary`](crate::model::DataCatalogSummary).
pub mod data_catalog_summary {

    /// A builder for [`DataCatalogSummary`](crate::model::DataCatalogSummary).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) catalog_name: std::option::Option<std::string::String>,
        pub(crate) r#type: std::option::Option<crate::model::DataCatalogType>,
    }
    impl Builder {
        /// <p>The name of the data catalog. The catalog name is unique for the Amazon Web Services account and can use a maximum of 127 alphanumeric, underscore, at sign, or hyphen characters. The remainder of the length constraint of 256 is reserved for use by Athena.</p>
        pub fn catalog_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.catalog_name = Some(input.into());
            self
        }
        /// <p>The name of the data catalog. The catalog name is unique for the Amazon Web Services account and can use a maximum of 127 alphanumeric, underscore, at sign, or hyphen characters. The remainder of the length constraint of 256 is reserved for use by Athena.</p>
        pub fn set_catalog_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.catalog_name = input;
            self
        }
        /// <p>The data catalog type.</p>
        pub fn r#type(mut self, input: crate::model::DataCatalogType) -> Self {
            self.r#type = Some(input);
            self
        }
        /// <p>The data catalog type.</p>
        pub fn set_type(
            mut self,
            input: std::option::Option<crate::model::DataCatalogType>,
        ) -> Self {
            self.r#type = input;
            self
        }
        /// Consumes the builder and constructs a [`DataCatalogSummary`](crate::model::DataCatalogSummary).
        pub fn build(self) -> crate::model::DataCatalogSummary {
            crate::model::DataCatalogSummary {
                catalog_name: self.catalog_name,
                r#type: self.r#type,
            }
        }
    }
}
impl DataCatalogSummary {
    /// Creates a new builder-style object to manufacture [`DataCatalogSummary`](crate::model::DataCatalogSummary).
    pub fn builder() -> crate::model::data_catalog_summary::Builder {
        crate::model::data_catalog_summary::Builder::default()
    }
}

/// <p>Contains metadata information for a database in a data catalog.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Database {
    /// <p>The name of the database.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>An optional description of the database.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p>A set of custom key/value pairs.</p>
    #[doc(hidden)]
    pub parameters:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
}
impl Database {
    /// <p>The name of the database.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>An optional description of the database.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>A set of custom key/value pairs.</p>
    pub fn parameters(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.parameters.as_ref()
    }
}
/// See [`Database`](crate::model::Database).
pub mod database {

    /// A builder for [`Database`](crate::model::Database).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) parameters: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
    }
    impl Builder {
        /// <p>The name of the database.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the database.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>An optional description of the database.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>An optional description of the database.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// Adds a key-value pair to `parameters`.
        ///
        /// To override the contents of this collection use [`set_parameters`](Self::set_parameters).
        ///
        /// <p>A set of custom key/value pairs.</p>
        pub fn parameters(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.parameters.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.parameters = Some(hash_map);
            self
        }
        /// <p>A set of custom key/value pairs.</p>
        pub fn set_parameters(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.parameters = input;
            self
        }
        /// Consumes the builder and constructs a [`Database`](crate::model::Database).
        pub fn build(self) -> crate::model::Database {
            crate::model::Database {
                name: self.name,
                description: self.description,
                parameters: self.parameters,
            }
        }
    }
}
impl Database {
    /// Creates a new builder-style object to manufacture [`Database`](crate::model::Database).
    pub fn builder() -> crate::model::database::Builder {
        crate::model::database::Builder::default()
    }
}

/// <p>Summary information for a notebook calculation.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CalculationSummary {
    /// <p>The calculation execution UUID.</p>
    #[doc(hidden)]
    pub calculation_execution_id: std::option::Option<std::string::String>,
    /// <p>A description of the calculation.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p>Contains information about the status of the calculation.</p>
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::CalculationStatus>,
}
impl CalculationSummary {
    /// <p>The calculation execution UUID.</p>
    pub fn calculation_execution_id(&self) -> std::option::Option<&str> {
        self.calculation_execution_id.as_deref()
    }
    /// <p>A description of the calculation.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>Contains information about the status of the calculation.</p>
    pub fn status(&self) -> std::option::Option<&crate::model::CalculationStatus> {
        self.status.as_ref()
    }
}
/// See [`CalculationSummary`](crate::model::CalculationSummary).
pub mod calculation_summary {

    /// A builder for [`CalculationSummary`](crate::model::CalculationSummary).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) calculation_execution_id: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) status: std::option::Option<crate::model::CalculationStatus>,
    }
    impl Builder {
        /// <p>The calculation execution UUID.</p>
        pub fn calculation_execution_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.calculation_execution_id = Some(input.into());
            self
        }
        /// <p>The calculation execution UUID.</p>
        pub fn set_calculation_execution_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.calculation_execution_id = input;
            self
        }
        /// <p>A description of the calculation.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>A description of the calculation.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>Contains information about the status of the calculation.</p>
        pub fn status(mut self, input: crate::model::CalculationStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>Contains information about the status of the calculation.</p>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::CalculationStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// Consumes the builder and constructs a [`CalculationSummary`](crate::model::CalculationSummary).
        pub fn build(self) -> crate::model::CalculationSummary {
            crate::model::CalculationSummary {
                calculation_execution_id: self.calculation_execution_id,
                description: self.description,
                status: self.status,
            }
        }
    }
}
impl CalculationSummary {
    /// Creates a new builder-style object to manufacture [`CalculationSummary`](crate::model::CalculationSummary).
    pub fn builder() -> crate::model::calculation_summary::Builder {
        crate::model::calculation_summary::Builder::default()
    }
}

/// <p>Contains information about the status of a notebook calculation.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CalculationStatus {
    /// <p>The date and time the calculation was submitted for processing.</p>
    #[doc(hidden)]
    pub submission_date_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The date and time the calculation completed processing.</p>
    #[doc(hidden)]
    pub completion_date_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The state of the calculation execution. A description of each state follows.</p>
    /// <p> <code>CREATING</code> - The calculation is in the process of being created.</p>
    /// <p> <code>CREATED</code> - The calculation has been created and is ready to run.</p>
    /// <p> <code>QUEUED</code> - The calculation has been queued for processing.</p>
    /// <p> <code>RUNNING</code> - The calculation is running.</p>
    /// <p> <code>CANCELING</code> - A request to cancel the calculation has been received and the system is working to stop it.</p>
    /// <p> <code>CANCELED</code> - The calculation is no longer running as the result of a cancel request.</p>
    /// <p> <code>COMPLETED</code> - The calculation has completed without error.</p>
    /// <p> <code>FAILED</code> - The calculation failed and is no longer running.</p>
    #[doc(hidden)]
    pub state: std::option::Option<crate::model::CalculationExecutionState>,
    /// <p>The reason for the calculation state change (for example, the calculation was canceled because the session was terminated).</p>
    #[doc(hidden)]
    pub state_change_reason: std::option::Option<std::string::String>,
}
impl CalculationStatus {
    /// <p>The date and time the calculation was submitted for processing.</p>
    pub fn submission_date_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.submission_date_time.as_ref()
    }
    /// <p>The date and time the calculation completed processing.</p>
    pub fn completion_date_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.completion_date_time.as_ref()
    }
    /// <p>The state of the calculation execution. A description of each state follows.</p>
    /// <p> <code>CREATING</code> - The calculation is in the process of being created.</p>
    /// <p> <code>CREATED</code> - The calculation has been created and is ready to run.</p>
    /// <p> <code>QUEUED</code> - The calculation has been queued for processing.</p>
    /// <p> <code>RUNNING</code> - The calculation is running.</p>
    /// <p> <code>CANCELING</code> - A request to cancel the calculation has been received and the system is working to stop it.</p>
    /// <p> <code>CANCELED</code> - The calculation is no longer running as the result of a cancel request.</p>
    /// <p> <code>COMPLETED</code> - The calculation has completed without error.</p>
    /// <p> <code>FAILED</code> - The calculation failed and is no longer running.</p>
    pub fn state(&self) -> std::option::Option<&crate::model::CalculationExecutionState> {
        self.state.as_ref()
    }
    /// <p>The reason for the calculation state change (for example, the calculation was canceled because the session was terminated).</p>
    pub fn state_change_reason(&self) -> std::option::Option<&str> {
        self.state_change_reason.as_deref()
    }
}
/// See [`CalculationStatus`](crate::model::CalculationStatus).
pub mod calculation_status {

    /// A builder for [`CalculationStatus`](crate::model::CalculationStatus).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) submission_date_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) completion_date_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) state: std::option::Option<crate::model::CalculationExecutionState>,
        pub(crate) state_change_reason: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The date and time the calculation was submitted for processing.</p>
        pub fn submission_date_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.submission_date_time = Some(input);
            self
        }
        /// <p>The date and time the calculation was submitted for processing.</p>
        pub fn set_submission_date_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.submission_date_time = input;
            self
        }
        /// <p>The date and time the calculation completed processing.</p>
        pub fn completion_date_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.completion_date_time = Some(input);
            self
        }
        /// <p>The date and time the calculation completed processing.</p>
        pub fn set_completion_date_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.completion_date_time = input;
            self
        }
        /// <p>The state of the calculation execution. A description of each state follows.</p>
        /// <p> <code>CREATING</code> - The calculation is in the process of being created.</p>
        /// <p> <code>CREATED</code> - The calculation has been created and is ready to run.</p>
        /// <p> <code>QUEUED</code> - The calculation has been queued for processing.</p>
        /// <p> <code>RUNNING</code> - The calculation is running.</p>
        /// <p> <code>CANCELING</code> - A request to cancel the calculation has been received and the system is working to stop it.</p>
        /// <p> <code>CANCELED</code> - The calculation is no longer running as the result of a cancel request.</p>
        /// <p> <code>COMPLETED</code> - The calculation has completed without error.</p>
        /// <p> <code>FAILED</code> - The calculation failed and is no longer running.</p>
        pub fn state(mut self, input: crate::model::CalculationExecutionState) -> Self {
            self.state = Some(input);
            self
        }
        /// <p>The state of the calculation execution. A description of each state follows.</p>
        /// <p> <code>CREATING</code> - The calculation is in the process of being created.</p>
        /// <p> <code>CREATED</code> - The calculation has been created and is ready to run.</p>
        /// <p> <code>QUEUED</code> - The calculation has been queued for processing.</p>
        /// <p> <code>RUNNING</code> - The calculation is running.</p>
        /// <p> <code>CANCELING</code> - A request to cancel the calculation has been received and the system is working to stop it.</p>
        /// <p> <code>CANCELED</code> - The calculation is no longer running as the result of a cancel request.</p>
        /// <p> <code>COMPLETED</code> - The calculation has completed without error.</p>
        /// <p> <code>FAILED</code> - The calculation failed and is no longer running.</p>
        pub fn set_state(
            mut self,
            input: std::option::Option<crate::model::CalculationExecutionState>,
        ) -> Self {
            self.state = input;
            self
        }
        /// <p>The reason for the calculation state change (for example, the calculation was canceled because the session was terminated).</p>
        pub fn state_change_reason(mut self, input: impl Into<std::string::String>) -> Self {
            self.state_change_reason = Some(input.into());
            self
        }
        /// <p>The reason for the calculation state change (for example, the calculation was canceled because the session was terminated).</p>
        pub fn set_state_change_reason(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.state_change_reason = input;
            self
        }
        /// Consumes the builder and constructs a [`CalculationStatus`](crate::model::CalculationStatus).
        pub fn build(self) -> crate::model::CalculationStatus {
            crate::model::CalculationStatus {
                submission_date_time: self.submission_date_time,
                completion_date_time: self.completion_date_time,
                state: self.state,
                state_change_reason: self.state_change_reason,
            }
        }
    }
}
impl CalculationStatus {
    /// Creates a new builder-style object to manufacture [`CalculationStatus`](crate::model::CalculationStatus).
    pub fn builder() -> crate::model::calculation_status::Builder {
        crate::model::calculation_status::Builder::default()
    }
}

/// <p>Contains the application runtime IDs and their supported DPU sizes.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ApplicationDpuSizes {
    /// <p>The name of the supported application runtime (for example, <code>Jupyter 1.0</code>).</p>
    #[doc(hidden)]
    pub application_runtime_id: std::option::Option<std::string::String>,
    /// <p>A list of the supported DPU sizes that the application runtime supports.</p>
    #[doc(hidden)]
    pub supported_dpu_sizes: std::option::Option<std::vec::Vec<i32>>,
}
impl ApplicationDpuSizes {
    /// <p>The name of the supported application runtime (for example, <code>Jupyter 1.0</code>).</p>
    pub fn application_runtime_id(&self) -> std::option::Option<&str> {
        self.application_runtime_id.as_deref()
    }
    /// <p>A list of the supported DPU sizes that the application runtime supports.</p>
    pub fn supported_dpu_sizes(&self) -> std::option::Option<&[i32]> {
        self.supported_dpu_sizes.as_deref()
    }
}
/// See [`ApplicationDpuSizes`](crate::model::ApplicationDpuSizes).
pub mod application_dpu_sizes {

    /// A builder for [`ApplicationDpuSizes`](crate::model::ApplicationDpuSizes).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) application_runtime_id: std::option::Option<std::string::String>,
        pub(crate) supported_dpu_sizes: std::option::Option<std::vec::Vec<i32>>,
    }
    impl Builder {
        /// <p>The name of the supported application runtime (for example, <code>Jupyter 1.0</code>).</p>
        pub fn application_runtime_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.application_runtime_id = Some(input.into());
            self
        }
        /// <p>The name of the supported application runtime (for example, <code>Jupyter 1.0</code>).</p>
        pub fn set_application_runtime_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.application_runtime_id = input;
            self
        }
        /// Appends an item to `supported_dpu_sizes`.
        ///
        /// To override the contents of this collection use [`set_supported_dpu_sizes`](Self::set_supported_dpu_sizes).
        ///
        /// <p>A list of the supported DPU sizes that the application runtime supports.</p>
        pub fn supported_dpu_sizes(mut self, input: i32) -> Self {
            let mut v = self.supported_dpu_sizes.unwrap_or_default();
            v.push(input);
            self.supported_dpu_sizes = Some(v);
            self
        }
        /// <p>A list of the supported DPU sizes that the application runtime supports.</p>
        pub fn set_supported_dpu_sizes(
            mut self,
            input: std::option::Option<std::vec::Vec<i32>>,
        ) -> Self {
            self.supported_dpu_sizes = input;
            self
        }
        /// Consumes the builder and constructs a [`ApplicationDpuSizes`](crate::model::ApplicationDpuSizes).
        pub fn build(self) -> crate::model::ApplicationDpuSizes {
            crate::model::ApplicationDpuSizes {
                application_runtime_id: self.application_runtime_id,
                supported_dpu_sizes: self.supported_dpu_sizes,
            }
        }
    }
}
impl ApplicationDpuSizes {
    /// Creates a new builder-style object to manufacture [`ApplicationDpuSizes`](crate::model::ApplicationDpuSizes).
    pub fn builder() -> crate::model::application_dpu_sizes::Builder {
        crate::model::application_dpu_sizes::Builder::default()
    }
}

/// <p>A workgroup, which contains a name, description, creation time, state, and other configuration, listed under <code>WorkGroup$Configuration</code>. Each workgroup enables you to isolate queries for you or your group of users from other queries in the same account, to configure the query results location and the encryption configuration (known as workgroup settings), to enable sending query metrics to Amazon CloudWatch, and to establish per-query data usage control limits for all queries in a workgroup. The workgroup settings override is specified in <code>EnforceWorkGroupConfiguration</code> (true/false) in the <code>WorkGroupConfiguration</code>. See <code>WorkGroupConfiguration$EnforceWorkGroupConfiguration</code>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct WorkGroup {
    /// <p>The workgroup name.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The state of the workgroup: ENABLED or DISABLED.</p>
    #[doc(hidden)]
    pub state: std::option::Option<crate::model::WorkGroupState>,
    /// <p>The configuration of the workgroup, which includes the location in Amazon S3 where query results are stored, the encryption configuration, if any, used for query results; whether the Amazon CloudWatch Metrics are enabled for the workgroup; whether workgroup settings override client-side settings; and the data usage limits for the amount of data scanned per query or per workgroup. The workgroup settings override is specified in <code>EnforceWorkGroupConfiguration</code> (true/false) in the <code>WorkGroupConfiguration</code>. See <code>WorkGroupConfiguration$EnforceWorkGroupConfiguration</code>.</p>
    #[doc(hidden)]
    pub configuration: std::option::Option<crate::model::WorkGroupConfiguration>,
    /// <p>The workgroup description.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p>The date and time the workgroup was created.</p>
    #[doc(hidden)]
    pub creation_time: std::option::Option<aws_smithy_types::DateTime>,
}
impl WorkGroup {
    /// <p>The workgroup name.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The state of the workgroup: ENABLED or DISABLED.</p>
    pub fn state(&self) -> std::option::Option<&crate::model::WorkGroupState> {
        self.state.as_ref()
    }
    /// <p>The configuration of the workgroup, which includes the location in Amazon S3 where query results are stored, the encryption configuration, if any, used for query results; whether the Amazon CloudWatch Metrics are enabled for the workgroup; whether workgroup settings override client-side settings; and the data usage limits for the amount of data scanned per query or per workgroup. The workgroup settings override is specified in <code>EnforceWorkGroupConfiguration</code> (true/false) in the <code>WorkGroupConfiguration</code>. See <code>WorkGroupConfiguration$EnforceWorkGroupConfiguration</code>.</p>
    pub fn configuration(&self) -> std::option::Option<&crate::model::WorkGroupConfiguration> {
        self.configuration.as_ref()
    }
    /// <p>The workgroup description.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>The date and time the workgroup was created.</p>
    pub fn creation_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.creation_time.as_ref()
    }
}
/// See [`WorkGroup`](crate::model::WorkGroup).
pub mod work_group {

    /// A builder for [`WorkGroup`](crate::model::WorkGroup).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) state: std::option::Option<crate::model::WorkGroupState>,
        pub(crate) configuration: std::option::Option<crate::model::WorkGroupConfiguration>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) creation_time: std::option::Option<aws_smithy_types::DateTime>,
    }
    impl Builder {
        /// <p>The workgroup name.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The workgroup name.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The state of the workgroup: ENABLED or DISABLED.</p>
        pub fn state(mut self, input: crate::model::WorkGroupState) -> Self {
            self.state = Some(input);
            self
        }
        /// <p>The state of the workgroup: ENABLED or DISABLED.</p>
        pub fn set_state(
            mut self,
            input: std::option::Option<crate::model::WorkGroupState>,
        ) -> Self {
            self.state = input;
            self
        }
        /// <p>The configuration of the workgroup, which includes the location in Amazon S3 where query results are stored, the encryption configuration, if any, used for query results; whether the Amazon CloudWatch Metrics are enabled for the workgroup; whether workgroup settings override client-side settings; and the data usage limits for the amount of data scanned per query or per workgroup. The workgroup settings override is specified in <code>EnforceWorkGroupConfiguration</code> (true/false) in the <code>WorkGroupConfiguration</code>. See <code>WorkGroupConfiguration$EnforceWorkGroupConfiguration</code>.</p>
        pub fn configuration(mut self, input: crate::model::WorkGroupConfiguration) -> Self {
            self.configuration = Some(input);
            self
        }
        /// <p>The configuration of the workgroup, which includes the location in Amazon S3 where query results are stored, the encryption configuration, if any, used for query results; whether the Amazon CloudWatch Metrics are enabled for the workgroup; whether workgroup settings override client-side settings; and the data usage limits for the amount of data scanned per query or per workgroup. The workgroup settings override is specified in <code>EnforceWorkGroupConfiguration</code> (true/false) in the <code>WorkGroupConfiguration</code>. See <code>WorkGroupConfiguration$EnforceWorkGroupConfiguration</code>.</p>
        pub fn set_configuration(
            mut self,
            input: std::option::Option<crate::model::WorkGroupConfiguration>,
        ) -> Self {
            self.configuration = input;
            self
        }
        /// <p>The workgroup description.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>The workgroup description.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>The date and time the workgroup was created.</p>
        pub fn creation_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.creation_time = Some(input);
            self
        }
        /// <p>The date and time the workgroup was created.</p>
        pub fn set_creation_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.creation_time = input;
            self
        }
        /// Consumes the builder and constructs a [`WorkGroup`](crate::model::WorkGroup).
        pub fn build(self) -> crate::model::WorkGroup {
            crate::model::WorkGroup {
                name: self.name,
                state: self.state,
                configuration: self.configuration,
                description: self.description,
                creation_time: self.creation_time,
            }
        }
    }
}
impl WorkGroup {
    /// Creates a new builder-style object to manufacture [`WorkGroup`](crate::model::WorkGroup).
    pub fn builder() -> crate::model::work_group::Builder {
        crate::model::work_group::Builder::default()
    }
}

/// <p>The configuration of the workgroup, which includes the location in Amazon S3 where query results are stored, the encryption option, if any, used for query results, whether the Amazon CloudWatch Metrics are enabled for the workgroup and whether workgroup settings override query settings, and the data usage limits for the amount of data scanned per query or per workgroup. The workgroup settings override is specified in <code>EnforceWorkGroupConfiguration</code> (true/false) in the <code>WorkGroupConfiguration</code>. See <code>WorkGroupConfiguration$EnforceWorkGroupConfiguration</code>. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct WorkGroupConfiguration {
    /// <p>The configuration for the workgroup, which includes the location in Amazon S3 where query results are stored and the encryption option, if any, used for query results. To run the query, you must specify the query results location using one of the ways: either in the workgroup using this setting, or for individual queries (client-side), using <code>ResultConfiguration$OutputLocation</code>. If none of them is set, Athena issues an error that no output location is provided. For more information, see <a href="https://docs.aws.amazon.com/athena/latest/ug/querying.html">Query Results</a>.</p>
    #[doc(hidden)]
    pub result_configuration: std::option::Option<crate::model::ResultConfiguration>,
    /// <p>If set to "true", the settings for the workgroup override client-side settings. If set to "false", client-side settings are used. For more information, see <a href="https://docs.aws.amazon.com/athena/latest/ug/workgroups-settings-override.html">Workgroup Settings Override Client-Side Settings</a>.</p>
    #[doc(hidden)]
    pub enforce_work_group_configuration: std::option::Option<bool>,
    /// <p>Indicates that the Amazon CloudWatch metrics are enabled for the workgroup.</p>
    #[doc(hidden)]
    pub publish_cloud_watch_metrics_enabled: std::option::Option<bool>,
    /// <p>The upper data usage limit (cutoff) for the amount of bytes a single query in a workgroup is allowed to scan.</p>
    #[doc(hidden)]
    pub bytes_scanned_cutoff_per_query: std::option::Option<i64>,
    /// <p>If set to <code>true</code>, allows members assigned to a workgroup to reference Amazon S3 Requester Pays buckets in queries. If set to <code>false</code>, workgroup members cannot query data from Requester Pays buckets, and queries that retrieve data from Requester Pays buckets cause an error. The default is <code>false</code>. For more information about Requester Pays buckets, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/RequesterPaysBuckets.html">Requester Pays Buckets</a> in the <i>Amazon Simple Storage Service Developer Guide</i>.</p>
    #[doc(hidden)]
    pub requester_pays_enabled: std::option::Option<bool>,
    /// <p>The engine version that all queries running on the workgroup use. Queries on the <code>AmazonAthenaPreviewFunctionality</code> workgroup run on the preview engine regardless of this setting.</p>
    #[doc(hidden)]
    pub engine_version: std::option::Option<crate::model::EngineVersion>,
    /// <p>Specifies a user defined JSON string that is passed to the notebook engine.</p>
    #[doc(hidden)]
    pub additional_configuration: std::option::Option<std::string::String>,
    /// <p>Role used in a notebook session for accessing the user's resources.</p>
    #[doc(hidden)]
    pub execution_role: std::option::Option<std::string::String>,
    /// <p>Specifies the KMS key that is used to encrypt the user's data stores in Athena.</p>
    #[doc(hidden)]
    pub customer_content_encryption_configuration:
        std::option::Option<crate::model::CustomerContentEncryptionConfiguration>,
}
impl WorkGroupConfiguration {
    /// <p>The configuration for the workgroup, which includes the location in Amazon S3 where query results are stored and the encryption option, if any, used for query results. To run the query, you must specify the query results location using one of the ways: either in the workgroup using this setting, or for individual queries (client-side), using <code>ResultConfiguration$OutputLocation</code>. If none of them is set, Athena issues an error that no output location is provided. For more information, see <a href="https://docs.aws.amazon.com/athena/latest/ug/querying.html">Query Results</a>.</p>
    pub fn result_configuration(&self) -> std::option::Option<&crate::model::ResultConfiguration> {
        self.result_configuration.as_ref()
    }
    /// <p>If set to "true", the settings for the workgroup override client-side settings. If set to "false", client-side settings are used. For more information, see <a href="https://docs.aws.amazon.com/athena/latest/ug/workgroups-settings-override.html">Workgroup Settings Override Client-Side Settings</a>.</p>
    pub fn enforce_work_group_configuration(&self) -> std::option::Option<bool> {
        self.enforce_work_group_configuration
    }
    /// <p>Indicates that the Amazon CloudWatch metrics are enabled for the workgroup.</p>
    pub fn publish_cloud_watch_metrics_enabled(&self) -> std::option::Option<bool> {
        self.publish_cloud_watch_metrics_enabled
    }
    /// <p>The upper data usage limit (cutoff) for the amount of bytes a single query in a workgroup is allowed to scan.</p>
    pub fn bytes_scanned_cutoff_per_query(&self) -> std::option::Option<i64> {
        self.bytes_scanned_cutoff_per_query
    }
    /// <p>If set to <code>true</code>, allows members assigned to a workgroup to reference Amazon S3 Requester Pays buckets in queries. If set to <code>false</code>, workgroup members cannot query data from Requester Pays buckets, and queries that retrieve data from Requester Pays buckets cause an error. The default is <code>false</code>. For more information about Requester Pays buckets, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/RequesterPaysBuckets.html">Requester Pays Buckets</a> in the <i>Amazon Simple Storage Service Developer Guide</i>.</p>
    pub fn requester_pays_enabled(&self) -> std::option::Option<bool> {
        self.requester_pays_enabled
    }
    /// <p>The engine version that all queries running on the workgroup use. Queries on the <code>AmazonAthenaPreviewFunctionality</code> workgroup run on the preview engine regardless of this setting.</p>
    pub fn engine_version(&self) -> std::option::Option<&crate::model::EngineVersion> {
        self.engine_version.as_ref()
    }
    /// <p>Specifies a user defined JSON string that is passed to the notebook engine.</p>
    pub fn additional_configuration(&self) -> std::option::Option<&str> {
        self.additional_configuration.as_deref()
    }
    /// <p>Role used in a notebook session for accessing the user's resources.</p>
    pub fn execution_role(&self) -> std::option::Option<&str> {
        self.execution_role.as_deref()
    }
    /// <p>Specifies the KMS key that is used to encrypt the user's data stores in Athena.</p>
    pub fn customer_content_encryption_configuration(
        &self,
    ) -> std::option::Option<&crate::model::CustomerContentEncryptionConfiguration> {
        self.customer_content_encryption_configuration.as_ref()
    }
}
/// See [`WorkGroupConfiguration`](crate::model::WorkGroupConfiguration).
pub mod work_group_configuration {

    /// A builder for [`WorkGroupConfiguration`](crate::model::WorkGroupConfiguration).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) result_configuration: std::option::Option<crate::model::ResultConfiguration>,
        pub(crate) enforce_work_group_configuration: std::option::Option<bool>,
        pub(crate) publish_cloud_watch_metrics_enabled: std::option::Option<bool>,
        pub(crate) bytes_scanned_cutoff_per_query: std::option::Option<i64>,
        pub(crate) requester_pays_enabled: std::option::Option<bool>,
        pub(crate) engine_version: std::option::Option<crate::model::EngineVersion>,
        pub(crate) additional_configuration: std::option::Option<std::string::String>,
        pub(crate) execution_role: std::option::Option<std::string::String>,
        pub(crate) customer_content_encryption_configuration:
            std::option::Option<crate::model::CustomerContentEncryptionConfiguration>,
    }
    impl Builder {
        /// <p>The configuration for the workgroup, which includes the location in Amazon S3 where query results are stored and the encryption option, if any, used for query results. To run the query, you must specify the query results location using one of the ways: either in the workgroup using this setting, or for individual queries (client-side), using <code>ResultConfiguration$OutputLocation</code>. If none of them is set, Athena issues an error that no output location is provided. For more information, see <a href="https://docs.aws.amazon.com/athena/latest/ug/querying.html">Query Results</a>.</p>
        pub fn result_configuration(mut self, input: crate::model::ResultConfiguration) -> Self {
            self.result_configuration = Some(input);
            self
        }
        /// <p>The configuration for the workgroup, which includes the location in Amazon S3 where query results are stored and the encryption option, if any, used for query results. To run the query, you must specify the query results location using one of the ways: either in the workgroup using this setting, or for individual queries (client-side), using <code>ResultConfiguration$OutputLocation</code>. If none of them is set, Athena issues an error that no output location is provided. For more information, see <a href="https://docs.aws.amazon.com/athena/latest/ug/querying.html">Query Results</a>.</p>
        pub fn set_result_configuration(
            mut self,
            input: std::option::Option<crate::model::ResultConfiguration>,
        ) -> Self {
            self.result_configuration = input;
            self
        }
        /// <p>If set to "true", the settings for the workgroup override client-side settings. If set to "false", client-side settings are used. For more information, see <a href="https://docs.aws.amazon.com/athena/latest/ug/workgroups-settings-override.html">Workgroup Settings Override Client-Side Settings</a>.</p>
        pub fn enforce_work_group_configuration(mut self, input: bool) -> Self {
            self.enforce_work_group_configuration = Some(input);
            self
        }
        /// <p>If set to "true", the settings for the workgroup override client-side settings. If set to "false", client-side settings are used. For more information, see <a href="https://docs.aws.amazon.com/athena/latest/ug/workgroups-settings-override.html">Workgroup Settings Override Client-Side Settings</a>.</p>
        pub fn set_enforce_work_group_configuration(
            mut self,
            input: std::option::Option<bool>,
        ) -> Self {
            self.enforce_work_group_configuration = input;
            self
        }
        /// <p>Indicates that the Amazon CloudWatch metrics are enabled for the workgroup.</p>
        pub fn publish_cloud_watch_metrics_enabled(mut self, input: bool) -> Self {
            self.publish_cloud_watch_metrics_enabled = Some(input);
            self
        }
        /// <p>Indicates that the Amazon CloudWatch metrics are enabled for the workgroup.</p>
        pub fn set_publish_cloud_watch_metrics_enabled(
            mut self,
            input: std::option::Option<bool>,
        ) -> Self {
            self.publish_cloud_watch_metrics_enabled = input;
            self
        }
        /// <p>The upper data usage limit (cutoff) for the amount of bytes a single query in a workgroup is allowed to scan.</p>
        pub fn bytes_scanned_cutoff_per_query(mut self, input: i64) -> Self {
            self.bytes_scanned_cutoff_per_query = Some(input);
            self
        }
        /// <p>The upper data usage limit (cutoff) for the amount of bytes a single query in a workgroup is allowed to scan.</p>
        pub fn set_bytes_scanned_cutoff_per_query(
            mut self,
            input: std::option::Option<i64>,
        ) -> Self {
            self.bytes_scanned_cutoff_per_query = input;
            self
        }
        /// <p>If set to <code>true</code>, allows members assigned to a workgroup to reference Amazon S3 Requester Pays buckets in queries. If set to <code>false</code>, workgroup members cannot query data from Requester Pays buckets, and queries that retrieve data from Requester Pays buckets cause an error. The default is <code>false</code>. For more information about Requester Pays buckets, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/RequesterPaysBuckets.html">Requester Pays Buckets</a> in the <i>Amazon Simple Storage Service Developer Guide</i>.</p>
        pub fn requester_pays_enabled(mut self, input: bool) -> Self {
            self.requester_pays_enabled = Some(input);
            self
        }
        /// <p>If set to <code>true</code>, allows members assigned to a workgroup to reference Amazon S3 Requester Pays buckets in queries. If set to <code>false</code>, workgroup members cannot query data from Requester Pays buckets, and queries that retrieve data from Requester Pays buckets cause an error. The default is <code>false</code>. For more information about Requester Pays buckets, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/RequesterPaysBuckets.html">Requester Pays Buckets</a> in the <i>Amazon Simple Storage Service Developer Guide</i>.</p>
        pub fn set_requester_pays_enabled(mut self, input: std::option::Option<bool>) -> Self {
            self.requester_pays_enabled = input;
            self
        }
        /// <p>The engine version that all queries running on the workgroup use. Queries on the <code>AmazonAthenaPreviewFunctionality</code> workgroup run on the preview engine regardless of this setting.</p>
        pub fn engine_version(mut self, input: crate::model::EngineVersion) -> Self {
            self.engine_version = Some(input);
            self
        }
        /// <p>The engine version that all queries running on the workgroup use. Queries on the <code>AmazonAthenaPreviewFunctionality</code> workgroup run on the preview engine regardless of this setting.</p>
        pub fn set_engine_version(
            mut self,
            input: std::option::Option<crate::model::EngineVersion>,
        ) -> Self {
            self.engine_version = input;
            self
        }
        /// <p>Specifies a user defined JSON string that is passed to the notebook engine.</p>
        pub fn additional_configuration(mut self, input: impl Into<std::string::String>) -> Self {
            self.additional_configuration = Some(input.into());
            self
        }
        /// <p>Specifies a user defined JSON string that is passed to the notebook engine.</p>
        pub fn set_additional_configuration(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.additional_configuration = input;
            self
        }
        /// <p>Role used in a notebook session for accessing the user's resources.</p>
        pub fn execution_role(mut self, input: impl Into<std::string::String>) -> Self {
            self.execution_role = Some(input.into());
            self
        }
        /// <p>Role used in a notebook session for accessing the user's resources.</p>
        pub fn set_execution_role(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.execution_role = input;
            self
        }
        /// <p>Specifies the KMS key that is used to encrypt the user's data stores in Athena.</p>
        pub fn customer_content_encryption_configuration(
            mut self,
            input: crate::model::CustomerContentEncryptionConfiguration,
        ) -> Self {
            self.customer_content_encryption_configuration = Some(input);
            self
        }
        /// <p>Specifies the KMS key that is used to encrypt the user's data stores in Athena.</p>
        pub fn set_customer_content_encryption_configuration(
            mut self,
            input: std::option::Option<crate::model::CustomerContentEncryptionConfiguration>,
        ) -> Self {
            self.customer_content_encryption_configuration = input;
            self
        }
        /// Consumes the builder and constructs a [`WorkGroupConfiguration`](crate::model::WorkGroupConfiguration).
        pub fn build(self) -> crate::model::WorkGroupConfiguration {
            crate::model::WorkGroupConfiguration {
                result_configuration: self.result_configuration,
                enforce_work_group_configuration: self.enforce_work_group_configuration,
                publish_cloud_watch_metrics_enabled: self.publish_cloud_watch_metrics_enabled,
                bytes_scanned_cutoff_per_query: self.bytes_scanned_cutoff_per_query,
                requester_pays_enabled: self.requester_pays_enabled,
                engine_version: self.engine_version,
                additional_configuration: self.additional_configuration,
                execution_role: self.execution_role,
                customer_content_encryption_configuration: self
                    .customer_content_encryption_configuration,
            }
        }
    }
}
impl WorkGroupConfiguration {
    /// Creates a new builder-style object to manufacture [`WorkGroupConfiguration`](crate::model::WorkGroupConfiguration).
    pub fn builder() -> crate::model::work_group_configuration::Builder {
        crate::model::work_group_configuration::Builder::default()
    }
}

/// <p>Contains statistics for a notebook session.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct SessionStatistics {
    /// <p>The data processing unit execution time for a session in milliseconds.</p>
    #[doc(hidden)]
    pub dpu_execution_in_millis: std::option::Option<i64>,
}
impl SessionStatistics {
    /// <p>The data processing unit execution time for a session in milliseconds.</p>
    pub fn dpu_execution_in_millis(&self) -> std::option::Option<i64> {
        self.dpu_execution_in_millis
    }
}
/// See [`SessionStatistics`](crate::model::SessionStatistics).
pub mod session_statistics {

    /// A builder for [`SessionStatistics`](crate::model::SessionStatistics).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) dpu_execution_in_millis: std::option::Option<i64>,
    }
    impl Builder {
        /// <p>The data processing unit execution time for a session in milliseconds.</p>
        pub fn dpu_execution_in_millis(mut self, input: i64) -> Self {
            self.dpu_execution_in_millis = Some(input);
            self
        }
        /// <p>The data processing unit execution time for a session in milliseconds.</p>
        pub fn set_dpu_execution_in_millis(mut self, input: std::option::Option<i64>) -> Self {
            self.dpu_execution_in_millis = input;
            self
        }
        /// Consumes the builder and constructs a [`SessionStatistics`](crate::model::SessionStatistics).
        pub fn build(self) -> crate::model::SessionStatistics {
            crate::model::SessionStatistics {
                dpu_execution_in_millis: self.dpu_execution_in_millis,
            }
        }
    }
}
impl SessionStatistics {
    /// Creates a new builder-style object to manufacture [`SessionStatistics`](crate::model::SessionStatistics).
    pub fn builder() -> crate::model::session_statistics::Builder {
        crate::model::session_statistics::Builder::default()
    }
}

/// <p>Contains session configuration information.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct SessionConfiguration {
    /// <p>The ARN of the execution role used for the session.</p>
    #[doc(hidden)]
    pub execution_role: std::option::Option<std::string::String>,
    /// <p>The Amazon S3 location that stores information for the notebook.</p>
    #[doc(hidden)]
    pub working_directory: std::option::Option<std::string::String>,
    /// <p>The idle timeout in seconds for the session.</p>
    #[doc(hidden)]
    pub idle_timeout_seconds: std::option::Option<i64>,
    /// <p>If query results are encrypted in Amazon S3, indicates the encryption option used (for example, <code>SSE_KMS</code> or <code>CSE_KMS</code>) and key information.</p>
    #[doc(hidden)]
    pub encryption_configuration: std::option::Option<crate::model::EncryptionConfiguration>,
}
impl SessionConfiguration {
    /// <p>The ARN of the execution role used for the session.</p>
    pub fn execution_role(&self) -> std::option::Option<&str> {
        self.execution_role.as_deref()
    }
    /// <p>The Amazon S3 location that stores information for the notebook.</p>
    pub fn working_directory(&self) -> std::option::Option<&str> {
        self.working_directory.as_deref()
    }
    /// <p>The idle timeout in seconds for the session.</p>
    pub fn idle_timeout_seconds(&self) -> std::option::Option<i64> {
        self.idle_timeout_seconds
    }
    /// <p>If query results are encrypted in Amazon S3, indicates the encryption option used (for example, <code>SSE_KMS</code> or <code>CSE_KMS</code>) and key information.</p>
    pub fn encryption_configuration(
        &self,
    ) -> std::option::Option<&crate::model::EncryptionConfiguration> {
        self.encryption_configuration.as_ref()
    }
}
/// See [`SessionConfiguration`](crate::model::SessionConfiguration).
pub mod session_configuration {

    /// A builder for [`SessionConfiguration`](crate::model::SessionConfiguration).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) execution_role: std::option::Option<std::string::String>,
        pub(crate) working_directory: std::option::Option<std::string::String>,
        pub(crate) idle_timeout_seconds: std::option::Option<i64>,
        pub(crate) encryption_configuration:
            std::option::Option<crate::model::EncryptionConfiguration>,
    }
    impl Builder {
        /// <p>The ARN of the execution role used for the session.</p>
        pub fn execution_role(mut self, input: impl Into<std::string::String>) -> Self {
            self.execution_role = Some(input.into());
            self
        }
        /// <p>The ARN of the execution role used for the session.</p>
        pub fn set_execution_role(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.execution_role = input;
            self
        }
        /// <p>The Amazon S3 location that stores information for the notebook.</p>
        pub fn working_directory(mut self, input: impl Into<std::string::String>) -> Self {
            self.working_directory = Some(input.into());
            self
        }
        /// <p>The Amazon S3 location that stores information for the notebook.</p>
        pub fn set_working_directory(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.working_directory = input;
            self
        }
        /// <p>The idle timeout in seconds for the session.</p>
        pub fn idle_timeout_seconds(mut self, input: i64) -> Self {
            self.idle_timeout_seconds = Some(input);
            self
        }
        /// <p>The idle timeout in seconds for the session.</p>
        pub fn set_idle_timeout_seconds(mut self, input: std::option::Option<i64>) -> Self {
            self.idle_timeout_seconds = input;
            self
        }
        /// <p>If query results are encrypted in Amazon S3, indicates the encryption option used (for example, <code>SSE_KMS</code> or <code>CSE_KMS</code>) and key information.</p>
        pub fn encryption_configuration(
            mut self,
            input: crate::model::EncryptionConfiguration,
        ) -> Self {
            self.encryption_configuration = Some(input);
            self
        }
        /// <p>If query results are encrypted in Amazon S3, indicates the encryption option used (for example, <code>SSE_KMS</code> or <code>CSE_KMS</code>) and key information.</p>
        pub fn set_encryption_configuration(
            mut self,
            input: std::option::Option<crate::model::EncryptionConfiguration>,
        ) -> Self {
            self.encryption_configuration = input;
            self
        }
        /// Consumes the builder and constructs a [`SessionConfiguration`](crate::model::SessionConfiguration).
        pub fn build(self) -> crate::model::SessionConfiguration {
            crate::model::SessionConfiguration {
                execution_role: self.execution_role,
                working_directory: self.working_directory,
                idle_timeout_seconds: self.idle_timeout_seconds,
                encryption_configuration: self.encryption_configuration,
            }
        }
    }
}
impl SessionConfiguration {
    /// Creates a new builder-style object to manufacture [`SessionConfiguration`](crate::model::SessionConfiguration).
    pub fn builder() -> crate::model::session_configuration::Builder {
        crate::model::session_configuration::Builder::default()
    }
}

/// <p>The query execution timeline, statistics on input and output rows and bytes, and the different query stages that form the query execution plan.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct QueryRuntimeStatistics {
    /// <p>Timeline statistics such as query queue time, planning time, execution time, service processing time, and total execution time.</p>
    #[doc(hidden)]
    pub timeline: std::option::Option<crate::model::QueryRuntimeStatisticsTimeline>,
    /// <p>Statistics such as input rows and bytes read by the query, rows and bytes output by the query, and the number of rows written by the query.</p>
    #[doc(hidden)]
    pub rows: std::option::Option<crate::model::QueryRuntimeStatisticsRows>,
    /// <p>Stage statistics such as input and output rows and bytes, execution time, and stage state. This information also includes substages and the query stage plan.</p>
    #[doc(hidden)]
    pub output_stage: std::option::Option<crate::model::QueryStage>,
}
impl QueryRuntimeStatistics {
    /// <p>Timeline statistics such as query queue time, planning time, execution time, service processing time, and total execution time.</p>
    pub fn timeline(&self) -> std::option::Option<&crate::model::QueryRuntimeStatisticsTimeline> {
        self.timeline.as_ref()
    }
    /// <p>Statistics such as input rows and bytes read by the query, rows and bytes output by the query, and the number of rows written by the query.</p>
    pub fn rows(&self) -> std::option::Option<&crate::model::QueryRuntimeStatisticsRows> {
        self.rows.as_ref()
    }
    /// <p>Stage statistics such as input and output rows and bytes, execution time, and stage state. This information also includes substages and the query stage plan.</p>
    pub fn output_stage(&self) -> std::option::Option<&crate::model::QueryStage> {
        self.output_stage.as_ref()
    }
}
/// See [`QueryRuntimeStatistics`](crate::model::QueryRuntimeStatistics).
pub mod query_runtime_statistics {

    /// A builder for [`QueryRuntimeStatistics`](crate::model::QueryRuntimeStatistics).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) timeline: std::option::Option<crate::model::QueryRuntimeStatisticsTimeline>,
        pub(crate) rows: std::option::Option<crate::model::QueryRuntimeStatisticsRows>,
        pub(crate) output_stage: std::option::Option<crate::model::QueryStage>,
    }
    impl Builder {
        /// <p>Timeline statistics such as query queue time, planning time, execution time, service processing time, and total execution time.</p>
        pub fn timeline(mut self, input: crate::model::QueryRuntimeStatisticsTimeline) -> Self {
            self.timeline = Some(input);
            self
        }
        /// <p>Timeline statistics such as query queue time, planning time, execution time, service processing time, and total execution time.</p>
        pub fn set_timeline(
            mut self,
            input: std::option::Option<crate::model::QueryRuntimeStatisticsTimeline>,
        ) -> Self {
            self.timeline = input;
            self
        }
        /// <p>Statistics such as input rows and bytes read by the query, rows and bytes output by the query, and the number of rows written by the query.</p>
        pub fn rows(mut self, input: crate::model::QueryRuntimeStatisticsRows) -> Self {
            self.rows = Some(input);
            self
        }
        /// <p>Statistics such as input rows and bytes read by the query, rows and bytes output by the query, and the number of rows written by the query.</p>
        pub fn set_rows(
            mut self,
            input: std::option::Option<crate::model::QueryRuntimeStatisticsRows>,
        ) -> Self {
            self.rows = input;
            self
        }
        /// <p>Stage statistics such as input and output rows and bytes, execution time, and stage state. This information also includes substages and the query stage plan.</p>
        pub fn output_stage(mut self, input: crate::model::QueryStage) -> Self {
            self.output_stage = Some(input);
            self
        }
        /// <p>Stage statistics such as input and output rows and bytes, execution time, and stage state. This information also includes substages and the query stage plan.</p>
        pub fn set_output_stage(
            mut self,
            input: std::option::Option<crate::model::QueryStage>,
        ) -> Self {
            self.output_stage = input;
            self
        }
        /// Consumes the builder and constructs a [`QueryRuntimeStatistics`](crate::model::QueryRuntimeStatistics).
        pub fn build(self) -> crate::model::QueryRuntimeStatistics {
            crate::model::QueryRuntimeStatistics {
                timeline: self.timeline,
                rows: self.rows,
                output_stage: self.output_stage,
            }
        }
    }
}
impl QueryRuntimeStatistics {
    /// Creates a new builder-style object to manufacture [`QueryRuntimeStatistics`](crate::model::QueryRuntimeStatistics).
    pub fn builder() -> crate::model::query_runtime_statistics::Builder {
        crate::model::query_runtime_statistics::Builder::default()
    }
}

/// <p>Stage statistics such as input and output rows and bytes, execution time and stage state. This information also includes substages and the query stage plan.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct QueryStage {
    /// <p>The identifier for a stage.</p>
    #[doc(hidden)]
    pub stage_id: std::option::Option<i64>,
    /// <p>State of the stage after query execution.</p>
    #[doc(hidden)]
    pub state: std::option::Option<std::string::String>,
    /// <p>The number of bytes output from the stage after execution.</p>
    #[doc(hidden)]
    pub output_bytes: std::option::Option<i64>,
    /// <p>The number of rows output from the stage after execution.</p>
    #[doc(hidden)]
    pub output_rows: std::option::Option<i64>,
    /// <p>The number of bytes input into the stage for execution.</p>
    #[doc(hidden)]
    pub input_bytes: std::option::Option<i64>,
    /// <p>The number of rows input into the stage for execution.</p>
    #[doc(hidden)]
    pub input_rows: std::option::Option<i64>,
    /// <p>Time taken to execute this stage.</p>
    #[doc(hidden)]
    pub execution_time: std::option::Option<i64>,
    /// <p>Stage plan information such as name, identifier, sub plans, and source stages.</p>
    #[doc(hidden)]
    pub query_stage_plan: std::option::Option<crate::model::QueryStagePlanNode>,
    /// <p>List of sub query stages that form this stage execution plan.</p>
    #[doc(hidden)]
    pub sub_stages: std::option::Option<std::vec::Vec<crate::model::QueryStage>>,
}
impl QueryStage {
    /// <p>The identifier for a stage.</p>
    pub fn stage_id(&self) -> std::option::Option<i64> {
        self.stage_id
    }
    /// <p>State of the stage after query execution.</p>
    pub fn state(&self) -> std::option::Option<&str> {
        self.state.as_deref()
    }
    /// <p>The number of bytes output from the stage after execution.</p>
    pub fn output_bytes(&self) -> std::option::Option<i64> {
        self.output_bytes
    }
    /// <p>The number of rows output from the stage after execution.</p>
    pub fn output_rows(&self) -> std::option::Option<i64> {
        self.output_rows
    }
    /// <p>The number of bytes input into the stage for execution.</p>
    pub fn input_bytes(&self) -> std::option::Option<i64> {
        self.input_bytes
    }
    /// <p>The number of rows input into the stage for execution.</p>
    pub fn input_rows(&self) -> std::option::Option<i64> {
        self.input_rows
    }
    /// <p>Time taken to execute this stage.</p>
    pub fn execution_time(&self) -> std::option::Option<i64> {
        self.execution_time
    }
    /// <p>Stage plan information such as name, identifier, sub plans, and source stages.</p>
    pub fn query_stage_plan(&self) -> std::option::Option<&crate::model::QueryStagePlanNode> {
        self.query_stage_plan.as_ref()
    }
    /// <p>List of sub query stages that form this stage execution plan.</p>
    pub fn sub_stages(&self) -> std::option::Option<&[crate::model::QueryStage]> {
        self.sub_stages.as_deref()
    }
}
/// See [`QueryStage`](crate::model::QueryStage).
pub mod query_stage {

    /// A builder for [`QueryStage`](crate::model::QueryStage).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) stage_id: std::option::Option<i64>,
        pub(crate) state: std::option::Option<std::string::String>,
        pub(crate) output_bytes: std::option::Option<i64>,
        pub(crate) output_rows: std::option::Option<i64>,
        pub(crate) input_bytes: std::option::Option<i64>,
        pub(crate) input_rows: std::option::Option<i64>,
        pub(crate) execution_time: std::option::Option<i64>,
        pub(crate) query_stage_plan: std::option::Option<crate::model::QueryStagePlanNode>,
        pub(crate) sub_stages: std::option::Option<std::vec::Vec<crate::model::QueryStage>>,
    }
    impl Builder {
        /// <p>The identifier for a stage.</p>
        pub fn stage_id(mut self, input: i64) -> Self {
            self.stage_id = Some(input);
            self
        }
        /// <p>The identifier for a stage.</p>
        pub fn set_stage_id(mut self, input: std::option::Option<i64>) -> Self {
            self.stage_id = input;
            self
        }
        /// <p>State of the stage after query execution.</p>
        pub fn state(mut self, input: impl Into<std::string::String>) -> Self {
            self.state = Some(input.into());
            self
        }
        /// <p>State of the stage after query execution.</p>
        pub fn set_state(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.state = input;
            self
        }
        /// <p>The number of bytes output from the stage after execution.</p>
        pub fn output_bytes(mut self, input: i64) -> Self {
            self.output_bytes = Some(input);
            self
        }
        /// <p>The number of bytes output from the stage after execution.</p>
        pub fn set_output_bytes(mut self, input: std::option::Option<i64>) -> Self {
            self.output_bytes = input;
            self
        }
        /// <p>The number of rows output from the stage after execution.</p>
        pub fn output_rows(mut self, input: i64) -> Self {
            self.output_rows = Some(input);
            self
        }
        /// <p>The number of rows output from the stage after execution.</p>
        pub fn set_output_rows(mut self, input: std::option::Option<i64>) -> Self {
            self.output_rows = input;
            self
        }
        /// <p>The number of bytes input into the stage for execution.</p>
        pub fn input_bytes(mut self, input: i64) -> Self {
            self.input_bytes = Some(input);
            self
        }
        /// <p>The number of bytes input into the stage for execution.</p>
        pub fn set_input_bytes(mut self, input: std::option::Option<i64>) -> Self {
            self.input_bytes = input;
            self
        }
        /// <p>The number of rows input into the stage for execution.</p>
        pub fn input_rows(mut self, input: i64) -> Self {
            self.input_rows = Some(input);
            self
        }
        /// <p>The number of rows input into the stage for execution.</p>
        pub fn set_input_rows(mut self, input: std::option::Option<i64>) -> Self {
            self.input_rows = input;
            self
        }
        /// <p>Time taken to execute this stage.</p>
        pub fn execution_time(mut self, input: i64) -> Self {
            self.execution_time = Some(input);
            self
        }
        /// <p>Time taken to execute this stage.</p>
        pub fn set_execution_time(mut self, input: std::option::Option<i64>) -> Self {
            self.execution_time = input;
            self
        }
        /// <p>Stage plan information such as name, identifier, sub plans, and source stages.</p>
        pub fn query_stage_plan(mut self, input: crate::model::QueryStagePlanNode) -> Self {
            self.query_stage_plan = Some(input);
            self
        }
        /// <p>Stage plan information such as name, identifier, sub plans, and source stages.</p>
        pub fn set_query_stage_plan(
            mut self,
            input: std::option::Option<crate::model::QueryStagePlanNode>,
        ) -> Self {
            self.query_stage_plan = input;
            self
        }
        /// Appends an item to `sub_stages`.
        ///
        /// To override the contents of this collection use [`set_sub_stages`](Self::set_sub_stages).
        ///
        /// <p>List of sub query stages that form this stage execution plan.</p>
        pub fn sub_stages(mut self, input: crate::model::QueryStage) -> Self {
            let mut v = self.sub_stages.unwrap_or_default();
            v.push(input);
            self.sub_stages = Some(v);
            self
        }
        /// <p>List of sub query stages that form this stage execution plan.</p>
        pub fn set_sub_stages(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::QueryStage>>,
        ) -> Self {
            self.sub_stages = input;
            self
        }
        /// Consumes the builder and constructs a [`QueryStage`](crate::model::QueryStage).
        pub fn build(self) -> crate::model::QueryStage {
            crate::model::QueryStage {
                stage_id: self.stage_id,
                state: self.state,
                output_bytes: self.output_bytes,
                output_rows: self.output_rows,
                input_bytes: self.input_bytes,
                input_rows: self.input_rows,
                execution_time: self.execution_time,
                query_stage_plan: self.query_stage_plan,
                sub_stages: self.sub_stages,
            }
        }
    }
}
impl QueryStage {
    /// Creates a new builder-style object to manufacture [`QueryStage`](crate::model::QueryStage).
    pub fn builder() -> crate::model::query_stage::Builder {
        crate::model::query_stage::Builder::default()
    }
}

/// <p>Stage plan information such as name, identifier, sub plans, and remote sources.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct QueryStagePlanNode {
    /// <p>Name of the query stage plan that describes the operation this stage is performing as part of query execution.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>Information about the operation this query stage plan node is performing.</p>
    #[doc(hidden)]
    pub identifier: std::option::Option<std::string::String>,
    /// <p>Stage plan information such as name, identifier, sub plans, and remote sources of child plan nodes/</p>
    #[doc(hidden)]
    pub children: std::option::Option<std::vec::Vec<crate::model::QueryStagePlanNode>>,
    /// <p>Source plan node IDs.</p>
    #[doc(hidden)]
    pub remote_sources: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl QueryStagePlanNode {
    /// <p>Name of the query stage plan that describes the operation this stage is performing as part of query execution.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>Information about the operation this query stage plan node is performing.</p>
    pub fn identifier(&self) -> std::option::Option<&str> {
        self.identifier.as_deref()
    }
    /// <p>Stage plan information such as name, identifier, sub plans, and remote sources of child plan nodes/</p>
    pub fn children(&self) -> std::option::Option<&[crate::model::QueryStagePlanNode]> {
        self.children.as_deref()
    }
    /// <p>Source plan node IDs.</p>
    pub fn remote_sources(&self) -> std::option::Option<&[std::string::String]> {
        self.remote_sources.as_deref()
    }
}
/// See [`QueryStagePlanNode`](crate::model::QueryStagePlanNode).
pub mod query_stage_plan_node {

    /// A builder for [`QueryStagePlanNode`](crate::model::QueryStagePlanNode).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) identifier: std::option::Option<std::string::String>,
        pub(crate) children: std::option::Option<std::vec::Vec<crate::model::QueryStagePlanNode>>,
        pub(crate) remote_sources: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// <p>Name of the query stage plan that describes the operation this stage is performing as part of query execution.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>Name of the query stage plan that describes the operation this stage is performing as part of query execution.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>Information about the operation this query stage plan node is performing.</p>
        pub fn identifier(mut self, input: impl Into<std::string::String>) -> Self {
            self.identifier = Some(input.into());
            self
        }
        /// <p>Information about the operation this query stage plan node is performing.</p>
        pub fn set_identifier(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.identifier = input;
            self
        }
        /// Appends an item to `children`.
        ///
        /// To override the contents of this collection use [`set_children`](Self::set_children).
        ///
        /// <p>Stage plan information such as name, identifier, sub plans, and remote sources of child plan nodes/</p>
        pub fn children(mut self, input: crate::model::QueryStagePlanNode) -> Self {
            let mut v = self.children.unwrap_or_default();
            v.push(input);
            self.children = Some(v);
            self
        }
        /// <p>Stage plan information such as name, identifier, sub plans, and remote sources of child plan nodes/</p>
        pub fn set_children(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::QueryStagePlanNode>>,
        ) -> Self {
            self.children = input;
            self
        }
        /// Appends an item to `remote_sources`.
        ///
        /// To override the contents of this collection use [`set_remote_sources`](Self::set_remote_sources).
        ///
        /// <p>Source plan node IDs.</p>
        pub fn remote_sources(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.remote_sources.unwrap_or_default();
            v.push(input.into());
            self.remote_sources = Some(v);
            self
        }
        /// <p>Source plan node IDs.</p>
        pub fn set_remote_sources(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.remote_sources = input;
            self
        }
        /// Consumes the builder and constructs a [`QueryStagePlanNode`](crate::model::QueryStagePlanNode).
        pub fn build(self) -> crate::model::QueryStagePlanNode {
            crate::model::QueryStagePlanNode {
                name: self.name,
                identifier: self.identifier,
                children: self.children,
                remote_sources: self.remote_sources,
            }
        }
    }
}
impl QueryStagePlanNode {
    /// Creates a new builder-style object to manufacture [`QueryStagePlanNode`](crate::model::QueryStagePlanNode).
    pub fn builder() -> crate::model::query_stage_plan_node::Builder {
        crate::model::query_stage_plan_node::Builder::default()
    }
}

/// <p>Statistics such as input rows and bytes read by the query, rows and bytes output by the query, and the number of rows written by the query.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct QueryRuntimeStatisticsRows {
    /// <p>The number of rows read to execute the query.</p>
    #[doc(hidden)]
    pub input_rows: std::option::Option<i64>,
    /// <p>The number of bytes read to execute the query.</p>
    #[doc(hidden)]
    pub input_bytes: std::option::Option<i64>,
    /// <p>The number of bytes returned by the query.</p>
    #[doc(hidden)]
    pub output_bytes: std::option::Option<i64>,
    /// <p>The number of rows returned by the query.</p>
    #[doc(hidden)]
    pub output_rows: std::option::Option<i64>,
}
impl QueryRuntimeStatisticsRows {
    /// <p>The number of rows read to execute the query.</p>
    pub fn input_rows(&self) -> std::option::Option<i64> {
        self.input_rows
    }
    /// <p>The number of bytes read to execute the query.</p>
    pub fn input_bytes(&self) -> std::option::Option<i64> {
        self.input_bytes
    }
    /// <p>The number of bytes returned by the query.</p>
    pub fn output_bytes(&self) -> std::option::Option<i64> {
        self.output_bytes
    }
    /// <p>The number of rows returned by the query.</p>
    pub fn output_rows(&self) -> std::option::Option<i64> {
        self.output_rows
    }
}
/// See [`QueryRuntimeStatisticsRows`](crate::model::QueryRuntimeStatisticsRows).
pub mod query_runtime_statistics_rows {

    /// A builder for [`QueryRuntimeStatisticsRows`](crate::model::QueryRuntimeStatisticsRows).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) input_rows: std::option::Option<i64>,
        pub(crate) input_bytes: std::option::Option<i64>,
        pub(crate) output_bytes: std::option::Option<i64>,
        pub(crate) output_rows: std::option::Option<i64>,
    }
    impl Builder {
        /// <p>The number of rows read to execute the query.</p>
        pub fn input_rows(mut self, input: i64) -> Self {
            self.input_rows = Some(input);
            self
        }
        /// <p>The number of rows read to execute the query.</p>
        pub fn set_input_rows(mut self, input: std::option::Option<i64>) -> Self {
            self.input_rows = input;
            self
        }
        /// <p>The number of bytes read to execute the query.</p>
        pub fn input_bytes(mut self, input: i64) -> Self {
            self.input_bytes = Some(input);
            self
        }
        /// <p>The number of bytes read to execute the query.</p>
        pub fn set_input_bytes(mut self, input: std::option::Option<i64>) -> Self {
            self.input_bytes = input;
            self
        }
        /// <p>The number of bytes returned by the query.</p>
        pub fn output_bytes(mut self, input: i64) -> Self {
            self.output_bytes = Some(input);
            self
        }
        /// <p>The number of bytes returned by the query.</p>
        pub fn set_output_bytes(mut self, input: std::option::Option<i64>) -> Self {
            self.output_bytes = input;
            self
        }
        /// <p>The number of rows returned by the query.</p>
        pub fn output_rows(mut self, input: i64) -> Self {
            self.output_rows = Some(input);
            self
        }
        /// <p>The number of rows returned by the query.</p>
        pub fn set_output_rows(mut self, input: std::option::Option<i64>) -> Self {
            self.output_rows = input;
            self
        }
        /// Consumes the builder and constructs a [`QueryRuntimeStatisticsRows`](crate::model::QueryRuntimeStatisticsRows).
        pub fn build(self) -> crate::model::QueryRuntimeStatisticsRows {
            crate::model::QueryRuntimeStatisticsRows {
                input_rows: self.input_rows,
                input_bytes: self.input_bytes,
                output_bytes: self.output_bytes,
                output_rows: self.output_rows,
            }
        }
    }
}
impl QueryRuntimeStatisticsRows {
    /// Creates a new builder-style object to manufacture [`QueryRuntimeStatisticsRows`](crate::model::QueryRuntimeStatisticsRows).
    pub fn builder() -> crate::model::query_runtime_statistics_rows::Builder {
        crate::model::query_runtime_statistics_rows::Builder::default()
    }
}

/// <p>Timeline statistics such as query queue time, planning time, execution time, service processing time, and total execution time.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct QueryRuntimeStatisticsTimeline {
    /// <p>The number of milliseconds that the query was in your query queue waiting for resources. Note that if transient errors occur, Athena might automatically add the query back to the queue.</p>
    #[doc(hidden)]
    pub query_queue_time_in_millis: std::option::Option<i64>,
    /// <p>The number of milliseconds that Athena took to plan the query processing flow. This includes the time spent retrieving table partitions from the data source. Note that because the query engine performs the query planning, query planning time is a subset of engine processing time.</p>
    #[doc(hidden)]
    pub query_planning_time_in_millis: std::option::Option<i64>,
    /// <p>The number of milliseconds that the query took to execute.</p>
    #[doc(hidden)]
    pub engine_execution_time_in_millis: std::option::Option<i64>,
    /// <p>The number of milliseconds that Athena took to finalize and publish the query results after the query engine finished running the query.</p>
    #[doc(hidden)]
    pub service_processing_time_in_millis: std::option::Option<i64>,
    /// <p>The number of milliseconds that Athena took to run the query.</p>
    #[doc(hidden)]
    pub total_execution_time_in_millis: std::option::Option<i64>,
}
impl QueryRuntimeStatisticsTimeline {
    /// <p>The number of milliseconds that the query was in your query queue waiting for resources. Note that if transient errors occur, Athena might automatically add the query back to the queue.</p>
    pub fn query_queue_time_in_millis(&self) -> std::option::Option<i64> {
        self.query_queue_time_in_millis
    }
    /// <p>The number of milliseconds that Athena took to plan the query processing flow. This includes the time spent retrieving table partitions from the data source. Note that because the query engine performs the query planning, query planning time is a subset of engine processing time.</p>
    pub fn query_planning_time_in_millis(&self) -> std::option::Option<i64> {
        self.query_planning_time_in_millis
    }
    /// <p>The number of milliseconds that the query took to execute.</p>
    pub fn engine_execution_time_in_millis(&self) -> std::option::Option<i64> {
        self.engine_execution_time_in_millis
    }
    /// <p>The number of milliseconds that Athena took to finalize and publish the query results after the query engine finished running the query.</p>
    pub fn service_processing_time_in_millis(&self) -> std::option::Option<i64> {
        self.service_processing_time_in_millis
    }
    /// <p>The number of milliseconds that Athena took to run the query.</p>
    pub fn total_execution_time_in_millis(&self) -> std::option::Option<i64> {
        self.total_execution_time_in_millis
    }
}
/// See [`QueryRuntimeStatisticsTimeline`](crate::model::QueryRuntimeStatisticsTimeline).
pub mod query_runtime_statistics_timeline {

    /// A builder for [`QueryRuntimeStatisticsTimeline`](crate::model::QueryRuntimeStatisticsTimeline).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) query_queue_time_in_millis: std::option::Option<i64>,
        pub(crate) query_planning_time_in_millis: std::option::Option<i64>,
        pub(crate) engine_execution_time_in_millis: std::option::Option<i64>,
        pub(crate) service_processing_time_in_millis: std::option::Option<i64>,
        pub(crate) total_execution_time_in_millis: std::option::Option<i64>,
    }
    impl Builder {
        /// <p>The number of milliseconds that the query was in your query queue waiting for resources. Note that if transient errors occur, Athena might automatically add the query back to the queue.</p>
        pub fn query_queue_time_in_millis(mut self, input: i64) -> Self {
            self.query_queue_time_in_millis = Some(input);
            self
        }
        /// <p>The number of milliseconds that the query was in your query queue waiting for resources. Note that if transient errors occur, Athena might automatically add the query back to the queue.</p>
        pub fn set_query_queue_time_in_millis(mut self, input: std::option::Option<i64>) -> Self {
            self.query_queue_time_in_millis = input;
            self
        }
        /// <p>The number of milliseconds that Athena took to plan the query processing flow. This includes the time spent retrieving table partitions from the data source. Note that because the query engine performs the query planning, query planning time is a subset of engine processing time.</p>
        pub fn query_planning_time_in_millis(mut self, input: i64) -> Self {
            self.query_planning_time_in_millis = Some(input);
            self
        }
        /// <p>The number of milliseconds that Athena took to plan the query processing flow. This includes the time spent retrieving table partitions from the data source. Note that because the query engine performs the query planning, query planning time is a subset of engine processing time.</p>
        pub fn set_query_planning_time_in_millis(
            mut self,
            input: std::option::Option<i64>,
        ) -> Self {
            self.query_planning_time_in_millis = input;
            self
        }
        /// <p>The number of milliseconds that the query took to execute.</p>
        pub fn engine_execution_time_in_millis(mut self, input: i64) -> Self {
            self.engine_execution_time_in_millis = Some(input);
            self
        }
        /// <p>The number of milliseconds that the query took to execute.</p>
        pub fn set_engine_execution_time_in_millis(
            mut self,
            input: std::option::Option<i64>,
        ) -> Self {
            self.engine_execution_time_in_millis = input;
            self
        }
        /// <p>The number of milliseconds that Athena took to finalize and publish the query results after the query engine finished running the query.</p>
        pub fn service_processing_time_in_millis(mut self, input: i64) -> Self {
            self.service_processing_time_in_millis = Some(input);
            self
        }
        /// <p>The number of milliseconds that Athena took to finalize and publish the query results after the query engine finished running the query.</p>
        pub fn set_service_processing_time_in_millis(
            mut self,
            input: std::option::Option<i64>,
        ) -> Self {
            self.service_processing_time_in_millis = input;
            self
        }
        /// <p>The number of milliseconds that Athena took to run the query.</p>
        pub fn total_execution_time_in_millis(mut self, input: i64) -> Self {
            self.total_execution_time_in_millis = Some(input);
            self
        }
        /// <p>The number of milliseconds that Athena took to run the query.</p>
        pub fn set_total_execution_time_in_millis(
            mut self,
            input: std::option::Option<i64>,
        ) -> Self {
            self.total_execution_time_in_millis = input;
            self
        }
        /// Consumes the builder and constructs a [`QueryRuntimeStatisticsTimeline`](crate::model::QueryRuntimeStatisticsTimeline).
        pub fn build(self) -> crate::model::QueryRuntimeStatisticsTimeline {
            crate::model::QueryRuntimeStatisticsTimeline {
                query_queue_time_in_millis: self.query_queue_time_in_millis,
                query_planning_time_in_millis: self.query_planning_time_in_millis,
                engine_execution_time_in_millis: self.engine_execution_time_in_millis,
                service_processing_time_in_millis: self.service_processing_time_in_millis,
                total_execution_time_in_millis: self.total_execution_time_in_millis,
            }
        }
    }
}
impl QueryRuntimeStatisticsTimeline {
    /// Creates a new builder-style object to manufacture [`QueryRuntimeStatisticsTimeline`](crate::model::QueryRuntimeStatisticsTimeline).
    pub fn builder() -> crate::model::query_runtime_statistics_timeline::Builder {
        crate::model::query_runtime_statistics_timeline::Builder::default()
    }
}

/// <p>The metadata and rows that make up a query result set. The metadata describes the column structure and data types. To return a <code>ResultSet</code> object, use <code>GetQueryResults</code>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ResultSet {
    /// <p>The rows in the table.</p>
    #[doc(hidden)]
    pub rows: std::option::Option<std::vec::Vec<crate::model::Row>>,
    /// <p>The metadata that describes the column structure and data types of a table of query results.</p>
    #[doc(hidden)]
    pub result_set_metadata: std::option::Option<crate::model::ResultSetMetadata>,
}
impl ResultSet {
    /// <p>The rows in the table.</p>
    pub fn rows(&self) -> std::option::Option<&[crate::model::Row]> {
        self.rows.as_deref()
    }
    /// <p>The metadata that describes the column structure and data types of a table of query results.</p>
    pub fn result_set_metadata(&self) -> std::option::Option<&crate::model::ResultSetMetadata> {
        self.result_set_metadata.as_ref()
    }
}
/// See [`ResultSet`](crate::model::ResultSet).
pub mod result_set {

    /// A builder for [`ResultSet`](crate::model::ResultSet).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) rows: std::option::Option<std::vec::Vec<crate::model::Row>>,
        pub(crate) result_set_metadata: std::option::Option<crate::model::ResultSetMetadata>,
    }
    impl Builder {
        /// Appends an item to `rows`.
        ///
        /// To override the contents of this collection use [`set_rows`](Self::set_rows).
        ///
        /// <p>The rows in the table.</p>
        pub fn rows(mut self, input: crate::model::Row) -> Self {
            let mut v = self.rows.unwrap_or_default();
            v.push(input);
            self.rows = Some(v);
            self
        }
        /// <p>The rows in the table.</p>
        pub fn set_rows(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Row>>,
        ) -> Self {
            self.rows = input;
            self
        }
        /// <p>The metadata that describes the column structure and data types of a table of query results.</p>
        pub fn result_set_metadata(mut self, input: crate::model::ResultSetMetadata) -> Self {
            self.result_set_metadata = Some(input);
            self
        }
        /// <p>The metadata that describes the column structure and data types of a table of query results.</p>
        pub fn set_result_set_metadata(
            mut self,
            input: std::option::Option<crate::model::ResultSetMetadata>,
        ) -> Self {
            self.result_set_metadata = input;
            self
        }
        /// Consumes the builder and constructs a [`ResultSet`](crate::model::ResultSet).
        pub fn build(self) -> crate::model::ResultSet {
            crate::model::ResultSet {
                rows: self.rows,
                result_set_metadata: self.result_set_metadata,
            }
        }
    }
}
impl ResultSet {
    /// Creates a new builder-style object to manufacture [`ResultSet`](crate::model::ResultSet).
    pub fn builder() -> crate::model::result_set::Builder {
        crate::model::result_set::Builder::default()
    }
}

/// <p>The metadata that describes the column structure and data types of a table of query results. To return a <code>ResultSetMetadata</code> object, use <code>GetQueryResults</code>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ResultSetMetadata {
    /// <p>Information about the columns returned in a query result metadata.</p>
    #[doc(hidden)]
    pub column_info: std::option::Option<std::vec::Vec<crate::model::ColumnInfo>>,
}
impl ResultSetMetadata {
    /// <p>Information about the columns returned in a query result metadata.</p>
    pub fn column_info(&self) -> std::option::Option<&[crate::model::ColumnInfo]> {
        self.column_info.as_deref()
    }
}
/// See [`ResultSetMetadata`](crate::model::ResultSetMetadata).
pub mod result_set_metadata {

    /// A builder for [`ResultSetMetadata`](crate::model::ResultSetMetadata).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) column_info: std::option::Option<std::vec::Vec<crate::model::ColumnInfo>>,
    }
    impl Builder {
        /// Appends an item to `column_info`.
        ///
        /// To override the contents of this collection use [`set_column_info`](Self::set_column_info).
        ///
        /// <p>Information about the columns returned in a query result metadata.</p>
        pub fn column_info(mut self, input: crate::model::ColumnInfo) -> Self {
            let mut v = self.column_info.unwrap_or_default();
            v.push(input);
            self.column_info = Some(v);
            self
        }
        /// <p>Information about the columns returned in a query result metadata.</p>
        pub fn set_column_info(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ColumnInfo>>,
        ) -> Self {
            self.column_info = input;
            self
        }
        /// Consumes the builder and constructs a [`ResultSetMetadata`](crate::model::ResultSetMetadata).
        pub fn build(self) -> crate::model::ResultSetMetadata {
            crate::model::ResultSetMetadata {
                column_info: self.column_info,
            }
        }
    }
}
impl ResultSetMetadata {
    /// Creates a new builder-style object to manufacture [`ResultSetMetadata`](crate::model::ResultSetMetadata).
    pub fn builder() -> crate::model::result_set_metadata::Builder {
        crate::model::result_set_metadata::Builder::default()
    }
}

/// <p>Information about the columns in a query execution result.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ColumnInfo {
    /// <p>The catalog to which the query results belong.</p>
    #[doc(hidden)]
    pub catalog_name: std::option::Option<std::string::String>,
    /// <p>The schema name (database name) to which the query results belong.</p>
    #[doc(hidden)]
    pub schema_name: std::option::Option<std::string::String>,
    /// <p>The table name for the query results.</p>
    #[doc(hidden)]
    pub table_name: std::option::Option<std::string::String>,
    /// <p>The name of the column.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>A column label.</p>
    #[doc(hidden)]
    pub label: std::option::Option<std::string::String>,
    /// <p>The data type of the column.</p>
    #[doc(hidden)]
    pub r#type: std::option::Option<std::string::String>,
    /// <p>For <code>DECIMAL</code> data types, specifies the total number of digits, up to 38. For performance reasons, we recommend up to 18 digits.</p>
    #[doc(hidden)]
    pub precision: i32,
    /// <p>For <code>DECIMAL</code> data types, specifies the total number of digits in the fractional part of the value. Defaults to 0.</p>
    #[doc(hidden)]
    pub scale: i32,
    /// <p>Indicates the column's nullable status.</p>
    #[doc(hidden)]
    pub nullable: std::option::Option<crate::model::ColumnNullable>,
    /// <p>Indicates whether values in the column are case-sensitive.</p>
    #[doc(hidden)]
    pub case_sensitive: bool,
}
impl ColumnInfo {
    /// <p>The catalog to which the query results belong.</p>
    pub fn catalog_name(&self) -> std::option::Option<&str> {
        self.catalog_name.as_deref()
    }
    /// <p>The schema name (database name) to which the query results belong.</p>
    pub fn schema_name(&self) -> std::option::Option<&str> {
        self.schema_name.as_deref()
    }
    /// <p>The table name for the query results.</p>
    pub fn table_name(&self) -> std::option::Option<&str> {
        self.table_name.as_deref()
    }
    /// <p>The name of the column.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>A column label.</p>
    pub fn label(&self) -> std::option::Option<&str> {
        self.label.as_deref()
    }
    /// <p>The data type of the column.</p>
    pub fn r#type(&self) -> std::option::Option<&str> {
        self.r#type.as_deref()
    }
    /// <p>For <code>DECIMAL</code> data types, specifies the total number of digits, up to 38. For performance reasons, we recommend up to 18 digits.</p>
    pub fn precision(&self) -> i32 {
        self.precision
    }
    /// <p>For <code>DECIMAL</code> data types, specifies the total number of digits in the fractional part of the value. Defaults to 0.</p>
    pub fn scale(&self) -> i32 {
        self.scale
    }
    /// <p>Indicates the column's nullable status.</p>
    pub fn nullable(&self) -> std::option::Option<&crate::model::ColumnNullable> {
        self.nullable.as_ref()
    }
    /// <p>Indicates whether values in the column are case-sensitive.</p>
    pub fn case_sensitive(&self) -> bool {
        self.case_sensitive
    }
}
/// See [`ColumnInfo`](crate::model::ColumnInfo).
pub mod column_info {

    /// A builder for [`ColumnInfo`](crate::model::ColumnInfo).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) catalog_name: std::option::Option<std::string::String>,
        pub(crate) schema_name: std::option::Option<std::string::String>,
        pub(crate) table_name: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) label: std::option::Option<std::string::String>,
        pub(crate) r#type: std::option::Option<std::string::String>,
        pub(crate) precision: std::option::Option<i32>,
        pub(crate) scale: std::option::Option<i32>,
        pub(crate) nullable: std::option::Option<crate::model::ColumnNullable>,
        pub(crate) case_sensitive: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>The catalog to which the query results belong.</p>
        pub fn catalog_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.catalog_name = Some(input.into());
            self
        }
        /// <p>The catalog to which the query results belong.</p>
        pub fn set_catalog_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.catalog_name = input;
            self
        }
        /// <p>The schema name (database name) to which the query results belong.</p>
        pub fn schema_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.schema_name = Some(input.into());
            self
        }
        /// <p>The schema name (database name) to which the query results belong.</p>
        pub fn set_schema_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.schema_name = input;
            self
        }
        /// <p>The table name for the query results.</p>
        pub fn table_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.table_name = Some(input.into());
            self
        }
        /// <p>The table name for the query results.</p>
        pub fn set_table_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.table_name = input;
            self
        }
        /// <p>The name of the column.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the column.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>A column label.</p>
        pub fn label(mut self, input: impl Into<std::string::String>) -> Self {
            self.label = Some(input.into());
            self
        }
        /// <p>A column label.</p>
        pub fn set_label(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.label = input;
            self
        }
        /// <p>The data type of the column.</p>
        pub fn r#type(mut self, input: impl Into<std::string::String>) -> Self {
            self.r#type = Some(input.into());
            self
        }
        /// <p>The data type of the column.</p>
        pub fn set_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.r#type = input;
            self
        }
        /// <p>For <code>DECIMAL</code> data types, specifies the total number of digits, up to 38. For performance reasons, we recommend up to 18 digits.</p>
        pub fn precision(mut self, input: i32) -> Self {
            self.precision = Some(input);
            self
        }
        /// <p>For <code>DECIMAL</code> data types, specifies the total number of digits, up to 38. For performance reasons, we recommend up to 18 digits.</p>
        pub fn set_precision(mut self, input: std::option::Option<i32>) -> Self {
            self.precision = input;
            self
        }
        /// <p>For <code>DECIMAL</code> data types, specifies the total number of digits in the fractional part of the value. Defaults to 0.</p>
        pub fn scale(mut self, input: i32) -> Self {
            self.scale = Some(input);
            self
        }
        /// <p>For <code>DECIMAL</code> data types, specifies the total number of digits in the fractional part of the value. Defaults to 0.</p>
        pub fn set_scale(mut self, input: std::option::Option<i32>) -> Self {
            self.scale = input;
            self
        }
        /// <p>Indicates the column's nullable status.</p>
        pub fn nullable(mut self, input: crate::model::ColumnNullable) -> Self {
            self.nullable = Some(input);
            self
        }
        /// <p>Indicates the column's nullable status.</p>
        pub fn set_nullable(
            mut self,
            input: std::option::Option<crate::model::ColumnNullable>,
        ) -> Self {
            self.nullable = input;
            self
        }
        /// <p>Indicates whether values in the column are case-sensitive.</p>
        pub fn case_sensitive(mut self, input: bool) -> Self {
            self.case_sensitive = Some(input);
            self
        }
        /// <p>Indicates whether values in the column are case-sensitive.</p>
        pub fn set_case_sensitive(mut self, input: std::option::Option<bool>) -> Self {
            self.case_sensitive = input;
            self
        }
        /// Consumes the builder and constructs a [`ColumnInfo`](crate::model::ColumnInfo).
        pub fn build(self) -> crate::model::ColumnInfo {
            crate::model::ColumnInfo {
                catalog_name: self.catalog_name,
                schema_name: self.schema_name,
                table_name: self.table_name,
                name: self.name,
                label: self.label,
                r#type: self.r#type,
                precision: self.precision.unwrap_or_default(),
                scale: self.scale.unwrap_or_default(),
                nullable: self.nullable,
                case_sensitive: self.case_sensitive.unwrap_or_default(),
            }
        }
    }
}
impl ColumnInfo {
    /// Creates a new builder-style object to manufacture [`ColumnInfo`](crate::model::ColumnInfo).
    pub fn builder() -> crate::model::column_info::Builder {
        crate::model::column_info::Builder::default()
    }
}

/// When writing a match expression against `ColumnNullable`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let columnnullable = unimplemented!();
/// match columnnullable {
///     ColumnNullable::NotNull => { /* ... */ },
///     ColumnNullable::Nullable => { /* ... */ },
///     ColumnNullable::UnknownValue => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `columnnullable` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ColumnNullable::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ColumnNullable::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ColumnNullable::NewFeature` is defined.
/// Specifically, when `columnnullable` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ColumnNullable::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
/// _Note: `ColumnNullable::Unknown` has been renamed to `::UnknownValue`._
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ColumnNullable {
    #[allow(missing_docs)] // documentation missing in model
    NotNull,
    #[allow(missing_docs)] // documentation missing in model
    Nullable,
    /// _Note: `::Unknown` has been renamed to `::UnknownValue`._
    UnknownValue,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ColumnNullable {
    fn from(s: &str) -> Self {
        match s {
            "NOT_NULL" => ColumnNullable::NotNull,
            "NULLABLE" => ColumnNullable::Nullable,
            "UNKNOWN" => ColumnNullable::UnknownValue,
            other => ColumnNullable::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for ColumnNullable {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ColumnNullable::from(s))
    }
}
impl ColumnNullable {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ColumnNullable::NotNull => "NOT_NULL",
            ColumnNullable::Nullable => "NULLABLE",
            ColumnNullable::UnknownValue => "UNKNOWN",
            ColumnNullable::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["NOT_NULL", "NULLABLE", "UNKNOWN"]
    }
}
impl AsRef<str> for ColumnNullable {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The rows that make up a query result table.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Row {
    /// <p>The data that populates a row in a query result table.</p>
    #[doc(hidden)]
    pub data: std::option::Option<std::vec::Vec<crate::model::Datum>>,
}
impl Row {
    /// <p>The data that populates a row in a query result table.</p>
    pub fn data(&self) -> std::option::Option<&[crate::model::Datum]> {
        self.data.as_deref()
    }
}
/// See [`Row`](crate::model::Row).
pub mod row {

    /// A builder for [`Row`](crate::model::Row).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) data: std::option::Option<std::vec::Vec<crate::model::Datum>>,
    }
    impl Builder {
        /// Appends an item to `data`.
        ///
        /// To override the contents of this collection use [`set_data`](Self::set_data).
        ///
        /// <p>The data that populates a row in a query result table.</p>
        pub fn data(mut self, input: crate::model::Datum) -> Self {
            let mut v = self.data.unwrap_or_default();
            v.push(input);
            self.data = Some(v);
            self
        }
        /// <p>The data that populates a row in a query result table.</p>
        pub fn set_data(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Datum>>,
        ) -> Self {
            self.data = input;
            self
        }
        /// Consumes the builder and constructs a [`Row`](crate::model::Row).
        pub fn build(self) -> crate::model::Row {
            crate::model::Row { data: self.data }
        }
    }
}
impl Row {
    /// Creates a new builder-style object to manufacture [`Row`](crate::model::Row).
    pub fn builder() -> crate::model::row::Builder {
        crate::model::row::Builder::default()
    }
}

/// <p>A piece of data (a field in the table).</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Datum {
    /// <p>The value of the datum.</p>
    #[doc(hidden)]
    pub var_char_value: std::option::Option<std::string::String>,
}
impl Datum {
    /// <p>The value of the datum.</p>
    pub fn var_char_value(&self) -> std::option::Option<&str> {
        self.var_char_value.as_deref()
    }
}
/// See [`Datum`](crate::model::Datum).
pub mod datum {

    /// A builder for [`Datum`](crate::model::Datum).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) var_char_value: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The value of the datum.</p>
        pub fn var_char_value(mut self, input: impl Into<std::string::String>) -> Self {
            self.var_char_value = Some(input.into());
            self
        }
        /// <p>The value of the datum.</p>
        pub fn set_var_char_value(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.var_char_value = input;
            self
        }
        /// Consumes the builder and constructs a [`Datum`](crate::model::Datum).
        pub fn build(self) -> crate::model::Datum {
            crate::model::Datum {
                var_char_value: self.var_char_value,
            }
        }
    }
}
impl Datum {
    /// Creates a new builder-style object to manufacture [`Datum`](crate::model::Datum).
    pub fn builder() -> crate::model::datum::Builder {
        crate::model::datum::Builder::default()
    }
}

/// <p>Information about a single instance of a query execution.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct QueryExecution {
    /// <p>The unique identifier for each query execution.</p>
    #[doc(hidden)]
    pub query_execution_id: std::option::Option<std::string::String>,
    /// <p>The SQL query statements which the query execution ran.</p>
    #[doc(hidden)]
    pub query: std::option::Option<std::string::String>,
    /// <p>The type of query statement that was run. <code>DDL</code> indicates DDL query statements. <code>DML</code> indicates DML (Data Manipulation Language) query statements, such as <code>CREATE TABLE AS SELECT</code>. <code>UTILITY</code> indicates query statements other than DDL and DML, such as <code>SHOW CREATE TABLE</code>, or <code>DESCRIBE TABLE</code>.</p>
    #[doc(hidden)]
    pub statement_type: std::option::Option<crate::model::StatementType>,
    /// <p>The location in Amazon S3 where query results were stored and the encryption option, if any, used for query results. These are known as "client-side settings". If workgroup settings override client-side settings, then the query uses the location for the query results and the encryption configuration that are specified for the workgroup.</p>
    #[doc(hidden)]
    pub result_configuration: std::option::Option<crate::model::ResultConfiguration>,
    /// <p>Specifies the query result reuse behavior that was used for the query.</p>
    #[doc(hidden)]
    pub result_reuse_configuration: std::option::Option<crate::model::ResultReuseConfiguration>,
    /// <p>The database in which the query execution occurred.</p>
    #[doc(hidden)]
    pub query_execution_context: std::option::Option<crate::model::QueryExecutionContext>,
    /// <p>The completion date, current state, submission time, and state change reason (if applicable) for the query execution.</p>
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::QueryExecutionStatus>,
    /// <p>Query execution statistics, such as the amount of data scanned, the amount of time that the query took to process, and the type of statement that was run.</p>
    #[doc(hidden)]
    pub statistics: std::option::Option<crate::model::QueryExecutionStatistics>,
    /// <p>The name of the workgroup in which the query ran.</p>
    #[doc(hidden)]
    pub work_group: std::option::Option<std::string::String>,
    /// <p>The engine version that executed the query.</p>
    #[doc(hidden)]
    pub engine_version: std::option::Option<crate::model::EngineVersion>,
    /// <p>A list of values for the parameters in a query. The values are applied sequentially to the parameters in the query in the order in which the parameters occur.</p>
    #[doc(hidden)]
    pub execution_parameters: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl QueryExecution {
    /// <p>The unique identifier for each query execution.</p>
    pub fn query_execution_id(&self) -> std::option::Option<&str> {
        self.query_execution_id.as_deref()
    }
    /// <p>The SQL query statements which the query execution ran.</p>
    pub fn query(&self) -> std::option::Option<&str> {
        self.query.as_deref()
    }
    /// <p>The type of query statement that was run. <code>DDL</code> indicates DDL query statements. <code>DML</code> indicates DML (Data Manipulation Language) query statements, such as <code>CREATE TABLE AS SELECT</code>. <code>UTILITY</code> indicates query statements other than DDL and DML, such as <code>SHOW CREATE TABLE</code>, or <code>DESCRIBE TABLE</code>.</p>
    pub fn statement_type(&self) -> std::option::Option<&crate::model::StatementType> {
        self.statement_type.as_ref()
    }
    /// <p>The location in Amazon S3 where query results were stored and the encryption option, if any, used for query results. These are known as "client-side settings". If workgroup settings override client-side settings, then the query uses the location for the query results and the encryption configuration that are specified for the workgroup.</p>
    pub fn result_configuration(&self) -> std::option::Option<&crate::model::ResultConfiguration> {
        self.result_configuration.as_ref()
    }
    /// <p>Specifies the query result reuse behavior that was used for the query.</p>
    pub fn result_reuse_configuration(
        &self,
    ) -> std::option::Option<&crate::model::ResultReuseConfiguration> {
        self.result_reuse_configuration.as_ref()
    }
    /// <p>The database in which the query execution occurred.</p>
    pub fn query_execution_context(
        &self,
    ) -> std::option::Option<&crate::model::QueryExecutionContext> {
        self.query_execution_context.as_ref()
    }
    /// <p>The completion date, current state, submission time, and state change reason (if applicable) for the query execution.</p>
    pub fn status(&self) -> std::option::Option<&crate::model::QueryExecutionStatus> {
        self.status.as_ref()
    }
    /// <p>Query execution statistics, such as the amount of data scanned, the amount of time that the query took to process, and the type of statement that was run.</p>
    pub fn statistics(&self) -> std::option::Option<&crate::model::QueryExecutionStatistics> {
        self.statistics.as_ref()
    }
    /// <p>The name of the workgroup in which the query ran.</p>
    pub fn work_group(&self) -> std::option::Option<&str> {
        self.work_group.as_deref()
    }
    /// <p>The engine version that executed the query.</p>
    pub fn engine_version(&self) -> std::option::Option<&crate::model::EngineVersion> {
        self.engine_version.as_ref()
    }
    /// <p>A list of values for the parameters in a query. The values are applied sequentially to the parameters in the query in the order in which the parameters occur.</p>
    pub fn execution_parameters(&self) -> std::option::Option<&[std::string::String]> {
        self.execution_parameters.as_deref()
    }
}
/// See [`QueryExecution`](crate::model::QueryExecution).
pub mod query_execution {

    /// A builder for [`QueryExecution`](crate::model::QueryExecution).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) query_execution_id: std::option::Option<std::string::String>,
        pub(crate) query: std::option::Option<std::string::String>,
        pub(crate) statement_type: std::option::Option<crate::model::StatementType>,
        pub(crate) result_configuration: std::option::Option<crate::model::ResultConfiguration>,
        pub(crate) result_reuse_configuration:
            std::option::Option<crate::model::ResultReuseConfiguration>,
        pub(crate) query_execution_context:
            std::option::Option<crate::model::QueryExecutionContext>,
        pub(crate) status: std::option::Option<crate::model::QueryExecutionStatus>,
        pub(crate) statistics: std::option::Option<crate::model::QueryExecutionStatistics>,
        pub(crate) work_group: std::option::Option<std::string::String>,
        pub(crate) engine_version: std::option::Option<crate::model::EngineVersion>,
        pub(crate) execution_parameters: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// <p>The unique identifier for each query execution.</p>
        pub fn query_execution_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.query_execution_id = Some(input.into());
            self
        }
        /// <p>The unique identifier for each query execution.</p>
        pub fn set_query_execution_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.query_execution_id = input;
            self
        }
        /// <p>The SQL query statements which the query execution ran.</p>
        pub fn query(mut self, input: impl Into<std::string::String>) -> Self {
            self.query = Some(input.into());
            self
        }
        /// <p>The SQL query statements which the query execution ran.</p>
        pub fn set_query(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.query = input;
            self
        }
        /// <p>The type of query statement that was run. <code>DDL</code> indicates DDL query statements. <code>DML</code> indicates DML (Data Manipulation Language) query statements, such as <code>CREATE TABLE AS SELECT</code>. <code>UTILITY</code> indicates query statements other than DDL and DML, such as <code>SHOW CREATE TABLE</code>, or <code>DESCRIBE TABLE</code>.</p>
        pub fn statement_type(mut self, input: crate::model::StatementType) -> Self {
            self.statement_type = Some(input);
            self
        }
        /// <p>The type of query statement that was run. <code>DDL</code> indicates DDL query statements. <code>DML</code> indicates DML (Data Manipulation Language) query statements, such as <code>CREATE TABLE AS SELECT</code>. <code>UTILITY</code> indicates query statements other than DDL and DML, such as <code>SHOW CREATE TABLE</code>, or <code>DESCRIBE TABLE</code>.</p>
        pub fn set_statement_type(
            mut self,
            input: std::option::Option<crate::model::StatementType>,
        ) -> Self {
            self.statement_type = input;
            self
        }
        /// <p>The location in Amazon S3 where query results were stored and the encryption option, if any, used for query results. These are known as "client-side settings". If workgroup settings override client-side settings, then the query uses the location for the query results and the encryption configuration that are specified for the workgroup.</p>
        pub fn result_configuration(mut self, input: crate::model::ResultConfiguration) -> Self {
            self.result_configuration = Some(input);
            self
        }
        /// <p>The location in Amazon S3 where query results were stored and the encryption option, if any, used for query results. These are known as "client-side settings". If workgroup settings override client-side settings, then the query uses the location for the query results and the encryption configuration that are specified for the workgroup.</p>
        pub fn set_result_configuration(
            mut self,
            input: std::option::Option<crate::model::ResultConfiguration>,
        ) -> Self {
            self.result_configuration = input;
            self
        }
        /// <p>Specifies the query result reuse behavior that was used for the query.</p>
        pub fn result_reuse_configuration(
            mut self,
            input: crate::model::ResultReuseConfiguration,
        ) -> Self {
            self.result_reuse_configuration = Some(input);
            self
        }
        /// <p>Specifies the query result reuse behavior that was used for the query.</p>
        pub fn set_result_reuse_configuration(
            mut self,
            input: std::option::Option<crate::model::ResultReuseConfiguration>,
        ) -> Self {
            self.result_reuse_configuration = input;
            self
        }
        /// <p>The database in which the query execution occurred.</p>
        pub fn query_execution_context(
            mut self,
            input: crate::model::QueryExecutionContext,
        ) -> Self {
            self.query_execution_context = Some(input);
            self
        }
        /// <p>The database in which the query execution occurred.</p>
        pub fn set_query_execution_context(
            mut self,
            input: std::option::Option<crate::model::QueryExecutionContext>,
        ) -> Self {
            self.query_execution_context = input;
            self
        }
        /// <p>The completion date, current state, submission time, and state change reason (if applicable) for the query execution.</p>
        pub fn status(mut self, input: crate::model::QueryExecutionStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The completion date, current state, submission time, and state change reason (if applicable) for the query execution.</p>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::QueryExecutionStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// <p>Query execution statistics, such as the amount of data scanned, the amount of time that the query took to process, and the type of statement that was run.</p>
        pub fn statistics(mut self, input: crate::model::QueryExecutionStatistics) -> Self {
            self.statistics = Some(input);
            self
        }
        /// <p>Query execution statistics, such as the amount of data scanned, the amount of time that the query took to process, and the type of statement that was run.</p>
        pub fn set_statistics(
            mut self,
            input: std::option::Option<crate::model::QueryExecutionStatistics>,
        ) -> Self {
            self.statistics = input;
            self
        }
        /// <p>The name of the workgroup in which the query ran.</p>
        pub fn work_group(mut self, input: impl Into<std::string::String>) -> Self {
            self.work_group = Some(input.into());
            self
        }
        /// <p>The name of the workgroup in which the query ran.</p>
        pub fn set_work_group(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.work_group = input;
            self
        }
        /// <p>The engine version that executed the query.</p>
        pub fn engine_version(mut self, input: crate::model::EngineVersion) -> Self {
            self.engine_version = Some(input);
            self
        }
        /// <p>The engine version that executed the query.</p>
        pub fn set_engine_version(
            mut self,
            input: std::option::Option<crate::model::EngineVersion>,
        ) -> Self {
            self.engine_version = input;
            self
        }
        /// Appends an item to `execution_parameters`.
        ///
        /// To override the contents of this collection use [`set_execution_parameters`](Self::set_execution_parameters).
        ///
        /// <p>A list of values for the parameters in a query. The values are applied sequentially to the parameters in the query in the order in which the parameters occur.</p>
        pub fn execution_parameters(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.execution_parameters.unwrap_or_default();
            v.push(input.into());
            self.execution_parameters = Some(v);
            self
        }
        /// <p>A list of values for the parameters in a query. The values are applied sequentially to the parameters in the query in the order in which the parameters occur.</p>
        pub fn set_execution_parameters(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.execution_parameters = input;
            self
        }
        /// Consumes the builder and constructs a [`QueryExecution`](crate::model::QueryExecution).
        pub fn build(self) -> crate::model::QueryExecution {
            crate::model::QueryExecution {
                query_execution_id: self.query_execution_id,
                query: self.query,
                statement_type: self.statement_type,
                result_configuration: self.result_configuration,
                result_reuse_configuration: self.result_reuse_configuration,
                query_execution_context: self.query_execution_context,
                status: self.status,
                statistics: self.statistics,
                work_group: self.work_group,
                engine_version: self.engine_version,
                execution_parameters: self.execution_parameters,
            }
        }
    }
}
impl QueryExecution {
    /// Creates a new builder-style object to manufacture [`QueryExecution`](crate::model::QueryExecution).
    pub fn builder() -> crate::model::query_execution::Builder {
        crate::model::query_execution::Builder::default()
    }
}

/// <p>The amount of data scanned during the query execution and the amount of time that it took to execute, and the type of statement that was run.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct QueryExecutionStatistics {
    /// <p>The number of milliseconds that the query took to execute.</p>
    #[doc(hidden)]
    pub engine_execution_time_in_millis: std::option::Option<i64>,
    /// <p>The number of bytes in the data that was queried.</p>
    #[doc(hidden)]
    pub data_scanned_in_bytes: std::option::Option<i64>,
    /// <p>The location and file name of a data manifest file. The manifest file is saved to the Athena query results location in Amazon S3. The manifest file tracks files that the query wrote to Amazon S3. If the query fails, the manifest file also tracks files that the query intended to write. The manifest is useful for identifying orphaned files resulting from a failed query. For more information, see <a href="https://docs.aws.amazon.com/athena/latest/ug/querying.html">Working with Query Results, Output Files, and Query History</a> in the <i>Amazon Athena User Guide</i>.</p>
    #[doc(hidden)]
    pub data_manifest_location: std::option::Option<std::string::String>,
    /// <p>The number of milliseconds that Athena took to run the query.</p>
    #[doc(hidden)]
    pub total_execution_time_in_millis: std::option::Option<i64>,
    /// <p>The number of milliseconds that the query was in your query queue waiting for resources. Note that if transient errors occur, Athena might automatically add the query back to the queue.</p>
    #[doc(hidden)]
    pub query_queue_time_in_millis: std::option::Option<i64>,
    /// <p>The number of milliseconds that Athena took to plan the query processing flow. This includes the time spent retrieving table partitions from the data source. Note that because the query engine performs the query planning, query planning time is a subset of engine processing time.</p>
    #[doc(hidden)]
    pub query_planning_time_in_millis: std::option::Option<i64>,
    /// <p>The number of milliseconds that Athena took to finalize and publish the query results after the query engine finished running the query.</p>
    #[doc(hidden)]
    pub service_processing_time_in_millis: std::option::Option<i64>,
    /// <p>Contains information about whether previous query results were reused for the query.</p>
    #[doc(hidden)]
    pub result_reuse_information: std::option::Option<crate::model::ResultReuseInformation>,
}
impl QueryExecutionStatistics {
    /// <p>The number of milliseconds that the query took to execute.</p>
    pub fn engine_execution_time_in_millis(&self) -> std::option::Option<i64> {
        self.engine_execution_time_in_millis
    }
    /// <p>The number of bytes in the data that was queried.</p>
    pub fn data_scanned_in_bytes(&self) -> std::option::Option<i64> {
        self.data_scanned_in_bytes
    }
    /// <p>The location and file name of a data manifest file. The manifest file is saved to the Athena query results location in Amazon S3. The manifest file tracks files that the query wrote to Amazon S3. If the query fails, the manifest file also tracks files that the query intended to write. The manifest is useful for identifying orphaned files resulting from a failed query. For more information, see <a href="https://docs.aws.amazon.com/athena/latest/ug/querying.html">Working with Query Results, Output Files, and Query History</a> in the <i>Amazon Athena User Guide</i>.</p>
    pub fn data_manifest_location(&self) -> std::option::Option<&str> {
        self.data_manifest_location.as_deref()
    }
    /// <p>The number of milliseconds that Athena took to run the query.</p>
    pub fn total_execution_time_in_millis(&self) -> std::option::Option<i64> {
        self.total_execution_time_in_millis
    }
    /// <p>The number of milliseconds that the query was in your query queue waiting for resources. Note that if transient errors occur, Athena might automatically add the query back to the queue.</p>
    pub fn query_queue_time_in_millis(&self) -> std::option::Option<i64> {
        self.query_queue_time_in_millis
    }
    /// <p>The number of milliseconds that Athena took to plan the query processing flow. This includes the time spent retrieving table partitions from the data source. Note that because the query engine performs the query planning, query planning time is a subset of engine processing time.</p>
    pub fn query_planning_time_in_millis(&self) -> std::option::Option<i64> {
        self.query_planning_time_in_millis
    }
    /// <p>The number of milliseconds that Athena took to finalize and publish the query results after the query engine finished running the query.</p>
    pub fn service_processing_time_in_millis(&self) -> std::option::Option<i64> {
        self.service_processing_time_in_millis
    }
    /// <p>Contains information about whether previous query results were reused for the query.</p>
    pub fn result_reuse_information(
        &self,
    ) -> std::option::Option<&crate::model::ResultReuseInformation> {
        self.result_reuse_information.as_ref()
    }
}
/// See [`QueryExecutionStatistics`](crate::model::QueryExecutionStatistics).
pub mod query_execution_statistics {

    /// A builder for [`QueryExecutionStatistics`](crate::model::QueryExecutionStatistics).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) engine_execution_time_in_millis: std::option::Option<i64>,
        pub(crate) data_scanned_in_bytes: std::option::Option<i64>,
        pub(crate) data_manifest_location: std::option::Option<std::string::String>,
        pub(crate) total_execution_time_in_millis: std::option::Option<i64>,
        pub(crate) query_queue_time_in_millis: std::option::Option<i64>,
        pub(crate) query_planning_time_in_millis: std::option::Option<i64>,
        pub(crate) service_processing_time_in_millis: std::option::Option<i64>,
        pub(crate) result_reuse_information:
            std::option::Option<crate::model::ResultReuseInformation>,
    }
    impl Builder {
        /// <p>The number of milliseconds that the query took to execute.</p>
        pub fn engine_execution_time_in_millis(mut self, input: i64) -> Self {
            self.engine_execution_time_in_millis = Some(input);
            self
        }
        /// <p>The number of milliseconds that the query took to execute.</p>
        pub fn set_engine_execution_time_in_millis(
            mut self,
            input: std::option::Option<i64>,
        ) -> Self {
            self.engine_execution_time_in_millis = input;
            self
        }
        /// <p>The number of bytes in the data that was queried.</p>
        pub fn data_scanned_in_bytes(mut self, input: i64) -> Self {
            self.data_scanned_in_bytes = Some(input);
            self
        }
        /// <p>The number of bytes in the data that was queried.</p>
        pub fn set_data_scanned_in_bytes(mut self, input: std::option::Option<i64>) -> Self {
            self.data_scanned_in_bytes = input;
            self
        }
        /// <p>The location and file name of a data manifest file. The manifest file is saved to the Athena query results location in Amazon S3. The manifest file tracks files that the query wrote to Amazon S3. If the query fails, the manifest file also tracks files that the query intended to write. The manifest is useful for identifying orphaned files resulting from a failed query. For more information, see <a href="https://docs.aws.amazon.com/athena/latest/ug/querying.html">Working with Query Results, Output Files, and Query History</a> in the <i>Amazon Athena User Guide</i>.</p>
        pub fn data_manifest_location(mut self, input: impl Into<std::string::String>) -> Self {
            self.data_manifest_location = Some(input.into());
            self
        }
        /// <p>The location and file name of a data manifest file. The manifest file is saved to the Athena query results location in Amazon S3. The manifest file tracks files that the query wrote to Amazon S3. If the query fails, the manifest file also tracks files that the query intended to write. The manifest is useful for identifying orphaned files resulting from a failed query. For more information, see <a href="https://docs.aws.amazon.com/athena/latest/ug/querying.html">Working with Query Results, Output Files, and Query History</a> in the <i>Amazon Athena User Guide</i>.</p>
        pub fn set_data_manifest_location(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.data_manifest_location = input;
            self
        }
        /// <p>The number of milliseconds that Athena took to run the query.</p>
        pub fn total_execution_time_in_millis(mut self, input: i64) -> Self {
            self.total_execution_time_in_millis = Some(input);
            self
        }
        /// <p>The number of milliseconds that Athena took to run the query.</p>
        pub fn set_total_execution_time_in_millis(
            mut self,
            input: std::option::Option<i64>,
        ) -> Self {
            self.total_execution_time_in_millis = input;
            self
        }
        /// <p>The number of milliseconds that the query was in your query queue waiting for resources. Note that if transient errors occur, Athena might automatically add the query back to the queue.</p>
        pub fn query_queue_time_in_millis(mut self, input: i64) -> Self {
            self.query_queue_time_in_millis = Some(input);
            self
        }
        /// <p>The number of milliseconds that the query was in your query queue waiting for resources. Note that if transient errors occur, Athena might automatically add the query back to the queue.</p>
        pub fn set_query_queue_time_in_millis(mut self, input: std::option::Option<i64>) -> Self {
            self.query_queue_time_in_millis = input;
            self
        }
        /// <p>The number of milliseconds that Athena took to plan the query processing flow. This includes the time spent retrieving table partitions from the data source. Note that because the query engine performs the query planning, query planning time is a subset of engine processing time.</p>
        pub fn query_planning_time_in_millis(mut self, input: i64) -> Self {
            self.query_planning_time_in_millis = Some(input);
            self
        }
        /// <p>The number of milliseconds that Athena took to plan the query processing flow. This includes the time spent retrieving table partitions from the data source. Note that because the query engine performs the query planning, query planning time is a subset of engine processing time.</p>
        pub fn set_query_planning_time_in_millis(
            mut self,
            input: std::option::Option<i64>,
        ) -> Self {
            self.query_planning_time_in_millis = input;
            self
        }
        /// <p>The number of milliseconds that Athena took to finalize and publish the query results after the query engine finished running the query.</p>
        pub fn service_processing_time_in_millis(mut self, input: i64) -> Self {
            self.service_processing_time_in_millis = Some(input);
            self
        }
        /// <p>The number of milliseconds that Athena took to finalize and publish the query results after the query engine finished running the query.</p>
        pub fn set_service_processing_time_in_millis(
            mut self,
            input: std::option::Option<i64>,
        ) -> Self {
            self.service_processing_time_in_millis = input;
            self
        }
        /// <p>Contains information about whether previous query results were reused for the query.</p>
        pub fn result_reuse_information(
            mut self,
            input: crate::model::ResultReuseInformation,
        ) -> Self {
            self.result_reuse_information = Some(input);
            self
        }
        /// <p>Contains information about whether previous query results were reused for the query.</p>
        pub fn set_result_reuse_information(
            mut self,
            input: std::option::Option<crate::model::ResultReuseInformation>,
        ) -> Self {
            self.result_reuse_information = input;
            self
        }
        /// Consumes the builder and constructs a [`QueryExecutionStatistics`](crate::model::QueryExecutionStatistics).
        pub fn build(self) -> crate::model::QueryExecutionStatistics {
            crate::model::QueryExecutionStatistics {
                engine_execution_time_in_millis: self.engine_execution_time_in_millis,
                data_scanned_in_bytes: self.data_scanned_in_bytes,
                data_manifest_location: self.data_manifest_location,
                total_execution_time_in_millis: self.total_execution_time_in_millis,
                query_queue_time_in_millis: self.query_queue_time_in_millis,
                query_planning_time_in_millis: self.query_planning_time_in_millis,
                service_processing_time_in_millis: self.service_processing_time_in_millis,
                result_reuse_information: self.result_reuse_information,
            }
        }
    }
}
impl QueryExecutionStatistics {
    /// Creates a new builder-style object to manufacture [`QueryExecutionStatistics`](crate::model::QueryExecutionStatistics).
    pub fn builder() -> crate::model::query_execution_statistics::Builder {
        crate::model::query_execution_statistics::Builder::default()
    }
}

/// <p>Contains information about whether the result of a previous query was reused.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ResultReuseInformation {
    /// <p>True if a previous query result was reused; false if the result was generated from a new run of the query.</p>
    #[doc(hidden)]
    pub reused_previous_result: bool,
}
impl ResultReuseInformation {
    /// <p>True if a previous query result was reused; false if the result was generated from a new run of the query.</p>
    pub fn reused_previous_result(&self) -> bool {
        self.reused_previous_result
    }
}
/// See [`ResultReuseInformation`](crate::model::ResultReuseInformation).
pub mod result_reuse_information {

    /// A builder for [`ResultReuseInformation`](crate::model::ResultReuseInformation).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) reused_previous_result: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>True if a previous query result was reused; false if the result was generated from a new run of the query.</p>
        pub fn reused_previous_result(mut self, input: bool) -> Self {
            self.reused_previous_result = Some(input);
            self
        }
        /// <p>True if a previous query result was reused; false if the result was generated from a new run of the query.</p>
        pub fn set_reused_previous_result(mut self, input: std::option::Option<bool>) -> Self {
            self.reused_previous_result = input;
            self
        }
        /// Consumes the builder and constructs a [`ResultReuseInformation`](crate::model::ResultReuseInformation).
        pub fn build(self) -> crate::model::ResultReuseInformation {
            crate::model::ResultReuseInformation {
                reused_previous_result: self.reused_previous_result.unwrap_or_default(),
            }
        }
    }
}
impl ResultReuseInformation {
    /// Creates a new builder-style object to manufacture [`ResultReuseInformation`](crate::model::ResultReuseInformation).
    pub fn builder() -> crate::model::result_reuse_information::Builder {
        crate::model::result_reuse_information::Builder::default()
    }
}

/// <p>The completion date, current state, submission time, and state change reason (if applicable) for the query execution.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct QueryExecutionStatus {
    /// <p>The state of query execution. <code>QUEUED</code> indicates that the query has been submitted to the service, and Athena will execute the query as soon as resources are available. <code>RUNNING</code> indicates that the query is in execution phase. <code>SUCCEEDED</code> indicates that the query completed without errors. <code>FAILED</code> indicates that the query experienced an error and did not complete processing. <code>CANCELLED</code> indicates that a user input interrupted query execution.</p> <note>
    /// <p>Athena automatically retries your queries in cases of certain transient errors. As a result, you may see the query state transition from <code>RUNNING</code> or <code>FAILED</code> to <code>QUEUED</code>. </p>
    /// </note>
    #[doc(hidden)]
    pub state: std::option::Option<crate::model::QueryExecutionState>,
    /// <p>Further detail about the status of the query.</p>
    #[doc(hidden)]
    pub state_change_reason: std::option::Option<std::string::String>,
    /// <p>The date and time that the query was submitted.</p>
    #[doc(hidden)]
    pub submission_date_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The date and time that the query completed.</p>
    #[doc(hidden)]
    pub completion_date_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>Provides information about an Athena query error.</p>
    #[doc(hidden)]
    pub athena_error: std::option::Option<crate::model::AthenaError>,
}
impl QueryExecutionStatus {
    /// <p>The state of query execution. <code>QUEUED</code> indicates that the query has been submitted to the service, and Athena will execute the query as soon as resources are available. <code>RUNNING</code> indicates that the query is in execution phase. <code>SUCCEEDED</code> indicates that the query completed without errors. <code>FAILED</code> indicates that the query experienced an error and did not complete processing. <code>CANCELLED</code> indicates that a user input interrupted query execution.</p> <note>
    /// <p>Athena automatically retries your queries in cases of certain transient errors. As a result, you may see the query state transition from <code>RUNNING</code> or <code>FAILED</code> to <code>QUEUED</code>. </p>
    /// </note>
    pub fn state(&self) -> std::option::Option<&crate::model::QueryExecutionState> {
        self.state.as_ref()
    }
    /// <p>Further detail about the status of the query.</p>
    pub fn state_change_reason(&self) -> std::option::Option<&str> {
        self.state_change_reason.as_deref()
    }
    /// <p>The date and time that the query was submitted.</p>
    pub fn submission_date_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.submission_date_time.as_ref()
    }
    /// <p>The date and time that the query completed.</p>
    pub fn completion_date_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.completion_date_time.as_ref()
    }
    /// <p>Provides information about an Athena query error.</p>
    pub fn athena_error(&self) -> std::option::Option<&crate::model::AthenaError> {
        self.athena_error.as_ref()
    }
}
/// See [`QueryExecutionStatus`](crate::model::QueryExecutionStatus).
pub mod query_execution_status {

    /// A builder for [`QueryExecutionStatus`](crate::model::QueryExecutionStatus).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) state: std::option::Option<crate::model::QueryExecutionState>,
        pub(crate) state_change_reason: std::option::Option<std::string::String>,
        pub(crate) submission_date_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) completion_date_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) athena_error: std::option::Option<crate::model::AthenaError>,
    }
    impl Builder {
        /// <p>The state of query execution. <code>QUEUED</code> indicates that the query has been submitted to the service, and Athena will execute the query as soon as resources are available. <code>RUNNING</code> indicates that the query is in execution phase. <code>SUCCEEDED</code> indicates that the query completed without errors. <code>FAILED</code> indicates that the query experienced an error and did not complete processing. <code>CANCELLED</code> indicates that a user input interrupted query execution.</p> <note>
        /// <p>Athena automatically retries your queries in cases of certain transient errors. As a result, you may see the query state transition from <code>RUNNING</code> or <code>FAILED</code> to <code>QUEUED</code>. </p>
        /// </note>
        pub fn state(mut self, input: crate::model::QueryExecutionState) -> Self {
            self.state = Some(input);
            self
        }
        /// <p>The state of query execution. <code>QUEUED</code> indicates that the query has been submitted to the service, and Athena will execute the query as soon as resources are available. <code>RUNNING</code> indicates that the query is in execution phase. <code>SUCCEEDED</code> indicates that the query completed without errors. <code>FAILED</code> indicates that the query experienced an error and did not complete processing. <code>CANCELLED</code> indicates that a user input interrupted query execution.</p> <note>
        /// <p>Athena automatically retries your queries in cases of certain transient errors. As a result, you may see the query state transition from <code>RUNNING</code> or <code>FAILED</code> to <code>QUEUED</code>. </p>
        /// </note>
        pub fn set_state(
            mut self,
            input: std::option::Option<crate::model::QueryExecutionState>,
        ) -> Self {
            self.state = input;
            self
        }
        /// <p>Further detail about the status of the query.</p>
        pub fn state_change_reason(mut self, input: impl Into<std::string::String>) -> Self {
            self.state_change_reason = Some(input.into());
            self
        }
        /// <p>Further detail about the status of the query.</p>
        pub fn set_state_change_reason(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.state_change_reason = input;
            self
        }
        /// <p>The date and time that the query was submitted.</p>
        pub fn submission_date_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.submission_date_time = Some(input);
            self
        }
        /// <p>The date and time that the query was submitted.</p>
        pub fn set_submission_date_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.submission_date_time = input;
            self
        }
        /// <p>The date and time that the query completed.</p>
        pub fn completion_date_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.completion_date_time = Some(input);
            self
        }
        /// <p>The date and time that the query completed.</p>
        pub fn set_completion_date_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.completion_date_time = input;
            self
        }
        /// <p>Provides information about an Athena query error.</p>
        pub fn athena_error(mut self, input: crate::model::AthenaError) -> Self {
            self.athena_error = Some(input);
            self
        }
        /// <p>Provides information about an Athena query error.</p>
        pub fn set_athena_error(
            mut self,
            input: std::option::Option<crate::model::AthenaError>,
        ) -> Self {
            self.athena_error = input;
            self
        }
        /// Consumes the builder and constructs a [`QueryExecutionStatus`](crate::model::QueryExecutionStatus).
        pub fn build(self) -> crate::model::QueryExecutionStatus {
            crate::model::QueryExecutionStatus {
                state: self.state,
                state_change_reason: self.state_change_reason,
                submission_date_time: self.submission_date_time,
                completion_date_time: self.completion_date_time,
                athena_error: self.athena_error,
            }
        }
    }
}
impl QueryExecutionStatus {
    /// Creates a new builder-style object to manufacture [`QueryExecutionStatus`](crate::model::QueryExecutionStatus).
    pub fn builder() -> crate::model::query_execution_status::Builder {
        crate::model::query_execution_status::Builder::default()
    }
}

/// <p>Provides information about an Athena query error. The <code>AthenaError</code> feature provides standardized error information to help you understand failed queries and take steps after a query failure occurs. <code>AthenaError</code> includes an <code>ErrorCategory</code> field that specifies whether the cause of the failed query is due to system error, user error, or other error.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AthenaError {
    /// <p>An integer value that specifies the category of a query failure error. The following list shows the category for each integer value.</p>
    /// <p> <b>1</b> - System</p>
    /// <p> <b>2</b> - User</p>
    /// <p> <b>3</b> - Other</p>
    #[doc(hidden)]
    pub error_category: std::option::Option<i32>,
    /// <p>An integer value that provides specific information about an Athena query error. For the meaning of specific values, see the <a href="https://docs.aws.amazon.com/athena/latest/ug/error-reference.html#error-reference-error-type-reference">Error Type Reference</a> in the <i>Amazon Athena User Guide</i>.</p>
    #[doc(hidden)]
    pub error_type: std::option::Option<i32>,
    /// <p>True if the query might succeed if resubmitted.</p>
    #[doc(hidden)]
    pub retryable: bool,
    /// <p>Contains a short description of the error that occurred.</p>
    #[doc(hidden)]
    pub error_message: std::option::Option<std::string::String>,
}
impl AthenaError {
    /// <p>An integer value that specifies the category of a query failure error. The following list shows the category for each integer value.</p>
    /// <p> <b>1</b> - System</p>
    /// <p> <b>2</b> - User</p>
    /// <p> <b>3</b> - Other</p>
    pub fn error_category(&self) -> std::option::Option<i32> {
        self.error_category
    }
    /// <p>An integer value that provides specific information about an Athena query error. For the meaning of specific values, see the <a href="https://docs.aws.amazon.com/athena/latest/ug/error-reference.html#error-reference-error-type-reference">Error Type Reference</a> in the <i>Amazon Athena User Guide</i>.</p>
    pub fn error_type(&self) -> std::option::Option<i32> {
        self.error_type
    }
    /// <p>True if the query might succeed if resubmitted.</p>
    pub fn retryable(&self) -> bool {
        self.retryable
    }
    /// <p>Contains a short description of the error that occurred.</p>
    pub fn error_message(&self) -> std::option::Option<&str> {
        self.error_message.as_deref()
    }
}
/// See [`AthenaError`](crate::model::AthenaError).
pub mod athena_error {

    /// A builder for [`AthenaError`](crate::model::AthenaError).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) error_category: std::option::Option<i32>,
        pub(crate) error_type: std::option::Option<i32>,
        pub(crate) retryable: std::option::Option<bool>,
        pub(crate) error_message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>An integer value that specifies the category of a query failure error. The following list shows the category for each integer value.</p>
        /// <p> <b>1</b> - System</p>
        /// <p> <b>2</b> - User</p>
        /// <p> <b>3</b> - Other</p>
        pub fn error_category(mut self, input: i32) -> Self {
            self.error_category = Some(input);
            self
        }
        /// <p>An integer value that specifies the category of a query failure error. The following list shows the category for each integer value.</p>
        /// <p> <b>1</b> - System</p>
        /// <p> <b>2</b> - User</p>
        /// <p> <b>3</b> - Other</p>
        pub fn set_error_category(mut self, input: std::option::Option<i32>) -> Self {
            self.error_category = input;
            self
        }
        /// <p>An integer value that provides specific information about an Athena query error. For the meaning of specific values, see the <a href="https://docs.aws.amazon.com/athena/latest/ug/error-reference.html#error-reference-error-type-reference">Error Type Reference</a> in the <i>Amazon Athena User Guide</i>.</p>
        pub fn error_type(mut self, input: i32) -> Self {
            self.error_type = Some(input);
            self
        }
        /// <p>An integer value that provides specific information about an Athena query error. For the meaning of specific values, see the <a href="https://docs.aws.amazon.com/athena/latest/ug/error-reference.html#error-reference-error-type-reference">Error Type Reference</a> in the <i>Amazon Athena User Guide</i>.</p>
        pub fn set_error_type(mut self, input: std::option::Option<i32>) -> Self {
            self.error_type = input;
            self
        }
        /// <p>True if the query might succeed if resubmitted.</p>
        pub fn retryable(mut self, input: bool) -> Self {
            self.retryable = Some(input);
            self
        }
        /// <p>True if the query might succeed if resubmitted.</p>
        pub fn set_retryable(mut self, input: std::option::Option<bool>) -> Self {
            self.retryable = input;
            self
        }
        /// <p>Contains a short description of the error that occurred.</p>
        pub fn error_message(mut self, input: impl Into<std::string::String>) -> Self {
            self.error_message = Some(input.into());
            self
        }
        /// <p>Contains a short description of the error that occurred.</p>
        pub fn set_error_message(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.error_message = input;
            self
        }
        /// Consumes the builder and constructs a [`AthenaError`](crate::model::AthenaError).
        pub fn build(self) -> crate::model::AthenaError {
            crate::model::AthenaError {
                error_category: self.error_category,
                error_type: self.error_type,
                retryable: self.retryable.unwrap_or_default(),
                error_message: self.error_message,
            }
        }
    }
}
impl AthenaError {
    /// Creates a new builder-style object to manufacture [`AthenaError`](crate::model::AthenaError).
    pub fn builder() -> crate::model::athena_error::Builder {
        crate::model::athena_error::Builder::default()
    }
}

/// When writing a match expression against `QueryExecutionState`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let queryexecutionstate = unimplemented!();
/// match queryexecutionstate {
///     QueryExecutionState::Cancelled => { /* ... */ },
///     QueryExecutionState::Failed => { /* ... */ },
///     QueryExecutionState::Queued => { /* ... */ },
///     QueryExecutionState::Running => { /* ... */ },
///     QueryExecutionState::Succeeded => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `queryexecutionstate` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `QueryExecutionState::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `QueryExecutionState::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `QueryExecutionState::NewFeature` is defined.
/// Specifically, when `queryexecutionstate` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `QueryExecutionState::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum QueryExecutionState {
    #[allow(missing_docs)] // documentation missing in model
    Cancelled,
    #[allow(missing_docs)] // documentation missing in model
    Failed,
    #[allow(missing_docs)] // documentation missing in model
    Queued,
    #[allow(missing_docs)] // documentation missing in model
    Running,
    #[allow(missing_docs)] // documentation missing in model
    Succeeded,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for QueryExecutionState {
    fn from(s: &str) -> Self {
        match s {
            "CANCELLED" => QueryExecutionState::Cancelled,
            "FAILED" => QueryExecutionState::Failed,
            "QUEUED" => QueryExecutionState::Queued,
            "RUNNING" => QueryExecutionState::Running,
            "SUCCEEDED" => QueryExecutionState::Succeeded,
            other => {
                QueryExecutionState::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for QueryExecutionState {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(QueryExecutionState::from(s))
    }
}
impl QueryExecutionState {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            QueryExecutionState::Cancelled => "CANCELLED",
            QueryExecutionState::Failed => "FAILED",
            QueryExecutionState::Queued => "QUEUED",
            QueryExecutionState::Running => "RUNNING",
            QueryExecutionState::Succeeded => "SUCCEEDED",
            QueryExecutionState::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["CANCELLED", "FAILED", "QUEUED", "RUNNING", "SUCCEEDED"]
    }
}
impl AsRef<str> for QueryExecutionState {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `StatementType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let statementtype = unimplemented!();
/// match statementtype {
///     StatementType::Ddl => { /* ... */ },
///     StatementType::Dml => { /* ... */ },
///     StatementType::Utility => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `statementtype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `StatementType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `StatementType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `StatementType::NewFeature` is defined.
/// Specifically, when `statementtype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `StatementType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum StatementType {
    #[allow(missing_docs)] // documentation missing in model
    Ddl,
    #[allow(missing_docs)] // documentation missing in model
    Dml,
    #[allow(missing_docs)] // documentation missing in model
    Utility,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for StatementType {
    fn from(s: &str) -> Self {
        match s {
            "DDL" => StatementType::Ddl,
            "DML" => StatementType::Dml,
            "UTILITY" => StatementType::Utility,
            other => StatementType::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for StatementType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(StatementType::from(s))
    }
}
impl StatementType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            StatementType::Ddl => "DDL",
            StatementType::Dml => "DML",
            StatementType::Utility => "UTILITY",
            StatementType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["DDL", "DML", "UTILITY"]
    }
}
impl AsRef<str> for StatementType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>A prepared SQL statement for use with Athena.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct PreparedStatement {
    /// <p>The name of the prepared statement.</p>
    #[doc(hidden)]
    pub statement_name: std::option::Option<std::string::String>,
    /// <p>The query string for the prepared statement.</p>
    #[doc(hidden)]
    pub query_statement: std::option::Option<std::string::String>,
    /// <p>The name of the workgroup to which the prepared statement belongs.</p>
    #[doc(hidden)]
    pub work_group_name: std::option::Option<std::string::String>,
    /// <p>The description of the prepared statement.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p>The last modified time of the prepared statement.</p>
    #[doc(hidden)]
    pub last_modified_time: std::option::Option<aws_smithy_types::DateTime>,
}
impl PreparedStatement {
    /// <p>The name of the prepared statement.</p>
    pub fn statement_name(&self) -> std::option::Option<&str> {
        self.statement_name.as_deref()
    }
    /// <p>The query string for the prepared statement.</p>
    pub fn query_statement(&self) -> std::option::Option<&str> {
        self.query_statement.as_deref()
    }
    /// <p>The name of the workgroup to which the prepared statement belongs.</p>
    pub fn work_group_name(&self) -> std::option::Option<&str> {
        self.work_group_name.as_deref()
    }
    /// <p>The description of the prepared statement.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>The last modified time of the prepared statement.</p>
    pub fn last_modified_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.last_modified_time.as_ref()
    }
}
/// See [`PreparedStatement`](crate::model::PreparedStatement).
pub mod prepared_statement {

    /// A builder for [`PreparedStatement`](crate::model::PreparedStatement).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) statement_name: std::option::Option<std::string::String>,
        pub(crate) query_statement: std::option::Option<std::string::String>,
        pub(crate) work_group_name: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) last_modified_time: std::option::Option<aws_smithy_types::DateTime>,
    }
    impl Builder {
        /// <p>The name of the prepared statement.</p>
        pub fn statement_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.statement_name = Some(input.into());
            self
        }
        /// <p>The name of the prepared statement.</p>
        pub fn set_statement_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.statement_name = input;
            self
        }
        /// <p>The query string for the prepared statement.</p>
        pub fn query_statement(mut self, input: impl Into<std::string::String>) -> Self {
            self.query_statement = Some(input.into());
            self
        }
        /// <p>The query string for the prepared statement.</p>
        pub fn set_query_statement(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.query_statement = input;
            self
        }
        /// <p>The name of the workgroup to which the prepared statement belongs.</p>
        pub fn work_group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.work_group_name = Some(input.into());
            self
        }
        /// <p>The name of the workgroup to which the prepared statement belongs.</p>
        pub fn set_work_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.work_group_name = input;
            self
        }
        /// <p>The description of the prepared statement.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>The description of the prepared statement.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>The last modified time of the prepared statement.</p>
        pub fn last_modified_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.last_modified_time = Some(input);
            self
        }
        /// <p>The last modified time of the prepared statement.</p>
        pub fn set_last_modified_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.last_modified_time = input;
            self
        }
        /// Consumes the builder and constructs a [`PreparedStatement`](crate::model::PreparedStatement).
        pub fn build(self) -> crate::model::PreparedStatement {
            crate::model::PreparedStatement {
                statement_name: self.statement_name,
                query_statement: self.query_statement,
                work_group_name: self.work_group_name,
                description: self.description,
                last_modified_time: self.last_modified_time,
            }
        }
    }
}
impl PreparedStatement {
    /// Creates a new builder-style object to manufacture [`PreparedStatement`](crate::model::PreparedStatement).
    pub fn builder() -> crate::model::prepared_statement::Builder {
        crate::model::prepared_statement::Builder::default()
    }
}

/// <p>A query, where <code>QueryString</code> contains the SQL statements that make up the query.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct NamedQuery {
    /// <p>The query name.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The query description.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p>The database to which the query belongs.</p>
    #[doc(hidden)]
    pub database: std::option::Option<std::string::String>,
    /// <p>The SQL statements that make up the query.</p>
    #[doc(hidden)]
    pub query_string: std::option::Option<std::string::String>,
    /// <p>The unique identifier of the query.</p>
    #[doc(hidden)]
    pub named_query_id: std::option::Option<std::string::String>,
    /// <p>The name of the workgroup that contains the named query.</p>
    #[doc(hidden)]
    pub work_group: std::option::Option<std::string::String>,
}
impl NamedQuery {
    /// <p>The query name.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The query description.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>The database to which the query belongs.</p>
    pub fn database(&self) -> std::option::Option<&str> {
        self.database.as_deref()
    }
    /// <p>The SQL statements that make up the query.</p>
    pub fn query_string(&self) -> std::option::Option<&str> {
        self.query_string.as_deref()
    }
    /// <p>The unique identifier of the query.</p>
    pub fn named_query_id(&self) -> std::option::Option<&str> {
        self.named_query_id.as_deref()
    }
    /// <p>The name of the workgroup that contains the named query.</p>
    pub fn work_group(&self) -> std::option::Option<&str> {
        self.work_group.as_deref()
    }
}
/// See [`NamedQuery`](crate::model::NamedQuery).
pub mod named_query {

    /// A builder for [`NamedQuery`](crate::model::NamedQuery).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) database: std::option::Option<std::string::String>,
        pub(crate) query_string: std::option::Option<std::string::String>,
        pub(crate) named_query_id: std::option::Option<std::string::String>,
        pub(crate) work_group: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The query name.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The query name.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The query description.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>The query description.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>The database to which the query belongs.</p>
        pub fn database(mut self, input: impl Into<std::string::String>) -> Self {
            self.database = Some(input.into());
            self
        }
        /// <p>The database to which the query belongs.</p>
        pub fn set_database(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.database = input;
            self
        }
        /// <p>The SQL statements that make up the query.</p>
        pub fn query_string(mut self, input: impl Into<std::string::String>) -> Self {
            self.query_string = Some(input.into());
            self
        }
        /// <p>The SQL statements that make up the query.</p>
        pub fn set_query_string(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.query_string = input;
            self
        }
        /// <p>The unique identifier of the query.</p>
        pub fn named_query_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.named_query_id = Some(input.into());
            self
        }
        /// <p>The unique identifier of the query.</p>
        pub fn set_named_query_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.named_query_id = input;
            self
        }
        /// <p>The name of the workgroup that contains the named query.</p>
        pub fn work_group(mut self, input: impl Into<std::string::String>) -> Self {
            self.work_group = Some(input.into());
            self
        }
        /// <p>The name of the workgroup that contains the named query.</p>
        pub fn set_work_group(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.work_group = input;
            self
        }
        /// Consumes the builder and constructs a [`NamedQuery`](crate::model::NamedQuery).
        pub fn build(self) -> crate::model::NamedQuery {
            crate::model::NamedQuery {
                name: self.name,
                description: self.description,
                database: self.database,
                query_string: self.query_string,
                named_query_id: self.named_query_id,
                work_group: self.work_group,
            }
        }
    }
}
impl NamedQuery {
    /// Creates a new builder-style object to manufacture [`NamedQuery`](crate::model::NamedQuery).
    pub fn builder() -> crate::model::named_query::Builder {
        crate::model::named_query::Builder::default()
    }
}

/// <p>Contains information about a data catalog in an Amazon Web Services account.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DataCatalog {
    /// <p>The name of the data catalog. The catalog name must be unique for the Amazon Web Services account and can use a maximum of 127 alphanumeric, underscore, at sign, or hyphen characters. The remainder of the length constraint of 256 is reserved for use by Athena.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>An optional description of the data catalog.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p>The type of data catalog to create: <code>LAMBDA</code> for a federated catalog, <code>HIVE</code> for an external hive metastore, or <code>GLUE</code> for an Glue Data Catalog.</p>
    #[doc(hidden)]
    pub r#type: std::option::Option<crate::model::DataCatalogType>,
    /// <p>Specifies the Lambda function or functions to use for the data catalog. This is a mapping whose values depend on the catalog type. </p>
    /// <ul>
    /// <li> <p>For the <code>HIVE</code> data catalog type, use the following syntax. The <code>metadata-function</code> parameter is required. <code>The sdk-version</code> parameter is optional and defaults to the currently supported version.</p> <p> <code>metadata-function=<i>lambda_arn</i>, sdk-version=<i>version_number</i> </code> </p> </li>
    /// <li> <p>For the <code>LAMBDA</code> data catalog type, use one of the following sets of required parameters, but not both.</p>
    /// <ul>
    /// <li> <p>If you have one Lambda function that processes metadata and another for reading the actual data, use the following syntax. Both parameters are required.</p> <p> <code>metadata-function=<i>lambda_arn</i>, record-function=<i>lambda_arn</i> </code> </p> </li>
    /// <li> <p> If you have a composite Lambda function that processes both metadata and data, use the following syntax to specify your Lambda function.</p> <p> <code>function=<i>lambda_arn</i> </code> </p> </li>
    /// </ul> </li>
    /// <li> <p>The <code>GLUE</code> type takes a catalog ID parameter and is required. The <code> <i>catalog_id</i> </code> is the account ID of the Amazon Web Services account to which the Glue catalog belongs.</p> <p> <code>catalog-id=<i>catalog_id</i> </code> </p>
    /// <ul>
    /// <li> <p>The <code>GLUE</code> data catalog type also applies to the default <code>AwsDataCatalog</code> that already exists in your account, of which you can have only one and cannot modify.</p> </li>
    /// <li> <p>Queries that specify a Glue Data Catalog other than the default <code>AwsDataCatalog</code> must be run on Athena engine version 2.</p> </li>
    /// </ul> </li>
    /// </ul>
    #[doc(hidden)]
    pub parameters:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
}
impl DataCatalog {
    /// <p>The name of the data catalog. The catalog name must be unique for the Amazon Web Services account and can use a maximum of 127 alphanumeric, underscore, at sign, or hyphen characters. The remainder of the length constraint of 256 is reserved for use by Athena.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>An optional description of the data catalog.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>The type of data catalog to create: <code>LAMBDA</code> for a federated catalog, <code>HIVE</code> for an external hive metastore, or <code>GLUE</code> for an Glue Data Catalog.</p>
    pub fn r#type(&self) -> std::option::Option<&crate::model::DataCatalogType> {
        self.r#type.as_ref()
    }
    /// <p>Specifies the Lambda function or functions to use for the data catalog. This is a mapping whose values depend on the catalog type. </p>
    /// <ul>
    /// <li> <p>For the <code>HIVE</code> data catalog type, use the following syntax. The <code>metadata-function</code> parameter is required. <code>The sdk-version</code> parameter is optional and defaults to the currently supported version.</p> <p> <code>metadata-function=<i>lambda_arn</i>, sdk-version=<i>version_number</i> </code> </p> </li>
    /// <li> <p>For the <code>LAMBDA</code> data catalog type, use one of the following sets of required parameters, but not both.</p>
    /// <ul>
    /// <li> <p>If you have one Lambda function that processes metadata and another for reading the actual data, use the following syntax. Both parameters are required.</p> <p> <code>metadata-function=<i>lambda_arn</i>, record-function=<i>lambda_arn</i> </code> </p> </li>
    /// <li> <p> If you have a composite Lambda function that processes both metadata and data, use the following syntax to specify your Lambda function.</p> <p> <code>function=<i>lambda_arn</i> </code> </p> </li>
    /// </ul> </li>
    /// <li> <p>The <code>GLUE</code> type takes a catalog ID parameter and is required. The <code> <i>catalog_id</i> </code> is the account ID of the Amazon Web Services account to which the Glue catalog belongs.</p> <p> <code>catalog-id=<i>catalog_id</i> </code> </p>
    /// <ul>
    /// <li> <p>The <code>GLUE</code> data catalog type also applies to the default <code>AwsDataCatalog</code> that already exists in your account, of which you can have only one and cannot modify.</p> </li>
    /// <li> <p>Queries that specify a Glue Data Catalog other than the default <code>AwsDataCatalog</code> must be run on Athena engine version 2.</p> </li>
    /// </ul> </li>
    /// </ul>
    pub fn parameters(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.parameters.as_ref()
    }
}
/// See [`DataCatalog`](crate::model::DataCatalog).
pub mod data_catalog {

    /// A builder for [`DataCatalog`](crate::model::DataCatalog).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) r#type: std::option::Option<crate::model::DataCatalogType>,
        pub(crate) parameters: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
    }
    impl Builder {
        /// <p>The name of the data catalog. The catalog name must be unique for the Amazon Web Services account and can use a maximum of 127 alphanumeric, underscore, at sign, or hyphen characters. The remainder of the length constraint of 256 is reserved for use by Athena.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the data catalog. The catalog name must be unique for the Amazon Web Services account and can use a maximum of 127 alphanumeric, underscore, at sign, or hyphen characters. The remainder of the length constraint of 256 is reserved for use by Athena.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>An optional description of the data catalog.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>An optional description of the data catalog.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>The type of data catalog to create: <code>LAMBDA</code> for a federated catalog, <code>HIVE</code> for an external hive metastore, or <code>GLUE</code> for an Glue Data Catalog.</p>
        pub fn r#type(mut self, input: crate::model::DataCatalogType) -> Self {
            self.r#type = Some(input);
            self
        }
        /// <p>The type of data catalog to create: <code>LAMBDA</code> for a federated catalog, <code>HIVE</code> for an external hive metastore, or <code>GLUE</code> for an Glue Data Catalog.</p>
        pub fn set_type(
            mut self,
            input: std::option::Option<crate::model::DataCatalogType>,
        ) -> Self {
            self.r#type = input;
            self
        }
        /// Adds a key-value pair to `parameters`.
        ///
        /// To override the contents of this collection use [`set_parameters`](Self::set_parameters).
        ///
        /// <p>Specifies the Lambda function or functions to use for the data catalog. This is a mapping whose values depend on the catalog type. </p>
        /// <ul>
        /// <li> <p>For the <code>HIVE</code> data catalog type, use the following syntax. The <code>metadata-function</code> parameter is required. <code>The sdk-version</code> parameter is optional and defaults to the currently supported version.</p> <p> <code>metadata-function=<i>lambda_arn</i>, sdk-version=<i>version_number</i> </code> </p> </li>
        /// <li> <p>For the <code>LAMBDA</code> data catalog type, use one of the following sets of required parameters, but not both.</p>
        /// <ul>
        /// <li> <p>If you have one Lambda function that processes metadata and another for reading the actual data, use the following syntax. Both parameters are required.</p> <p> <code>metadata-function=<i>lambda_arn</i>, record-function=<i>lambda_arn</i> </code> </p> </li>
        /// <li> <p> If you have a composite Lambda function that processes both metadata and data, use the following syntax to specify your Lambda function.</p> <p> <code>function=<i>lambda_arn</i> </code> </p> </li>
        /// </ul> </li>
        /// <li> <p>The <code>GLUE</code> type takes a catalog ID parameter and is required. The <code> <i>catalog_id</i> </code> is the account ID of the Amazon Web Services account to which the Glue catalog belongs.</p> <p> <code>catalog-id=<i>catalog_id</i> </code> </p>
        /// <ul>
        /// <li> <p>The <code>GLUE</code> data catalog type also applies to the default <code>AwsDataCatalog</code> that already exists in your account, of which you can have only one and cannot modify.</p> </li>
        /// <li> <p>Queries that specify a Glue Data Catalog other than the default <code>AwsDataCatalog</code> must be run on Athena engine version 2.</p> </li>
        /// </ul> </li>
        /// </ul>
        pub fn parameters(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.parameters.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.parameters = Some(hash_map);
            self
        }
        /// <p>Specifies the Lambda function or functions to use for the data catalog. This is a mapping whose values depend on the catalog type. </p>
        /// <ul>
        /// <li> <p>For the <code>HIVE</code> data catalog type, use the following syntax. The <code>metadata-function</code> parameter is required. <code>The sdk-version</code> parameter is optional and defaults to the currently supported version.</p> <p> <code>metadata-function=<i>lambda_arn</i>, sdk-version=<i>version_number</i> </code> </p> </li>
        /// <li> <p>For the <code>LAMBDA</code> data catalog type, use one of the following sets of required parameters, but not both.</p>
        /// <ul>
        /// <li> <p>If you have one Lambda function that processes metadata and another for reading the actual data, use the following syntax. Both parameters are required.</p> <p> <code>metadata-function=<i>lambda_arn</i>, record-function=<i>lambda_arn</i> </code> </p> </li>
        /// <li> <p> If you have a composite Lambda function that processes both metadata and data, use the following syntax to specify your Lambda function.</p> <p> <code>function=<i>lambda_arn</i> </code> </p> </li>
        /// </ul> </li>
        /// <li> <p>The <code>GLUE</code> type takes a catalog ID parameter and is required. The <code> <i>catalog_id</i> </code> is the account ID of the Amazon Web Services account to which the Glue catalog belongs.</p> <p> <code>catalog-id=<i>catalog_id</i> </code> </p>
        /// <ul>
        /// <li> <p>The <code>GLUE</code> data catalog type also applies to the default <code>AwsDataCatalog</code> that already exists in your account, of which you can have only one and cannot modify.</p> </li>
        /// <li> <p>Queries that specify a Glue Data Catalog other than the default <code>AwsDataCatalog</code> must be run on Athena engine version 2.</p> </li>
        /// </ul> </li>
        /// </ul>
        pub fn set_parameters(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.parameters = input;
            self
        }
        /// Consumes the builder and constructs a [`DataCatalog`](crate::model::DataCatalog).
        pub fn build(self) -> crate::model::DataCatalog {
            crate::model::DataCatalog {
                name: self.name,
                description: self.description,
                r#type: self.r#type,
                parameters: self.parameters,
            }
        }
    }
}
impl DataCatalog {
    /// Creates a new builder-style object to manufacture [`DataCatalog`](crate::model::DataCatalog).
    pub fn builder() -> crate::model::data_catalog::Builder {
        crate::model::data_catalog::Builder::default()
    }
}

/// <p>Contains statistics for a notebook calculation.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CalculationStatistics {
    /// <p>The data processing unit execution time in milliseconds for the calculation.</p>
    #[doc(hidden)]
    pub dpu_execution_in_millis: std::option::Option<i64>,
    /// <p>The progress of the calculation.</p>
    #[doc(hidden)]
    pub progress: std::option::Option<std::string::String>,
}
impl CalculationStatistics {
    /// <p>The data processing unit execution time in milliseconds for the calculation.</p>
    pub fn dpu_execution_in_millis(&self) -> std::option::Option<i64> {
        self.dpu_execution_in_millis
    }
    /// <p>The progress of the calculation.</p>
    pub fn progress(&self) -> std::option::Option<&str> {
        self.progress.as_deref()
    }
}
/// See [`CalculationStatistics`](crate::model::CalculationStatistics).
pub mod calculation_statistics {

    /// A builder for [`CalculationStatistics`](crate::model::CalculationStatistics).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) dpu_execution_in_millis: std::option::Option<i64>,
        pub(crate) progress: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The data processing unit execution time in milliseconds for the calculation.</p>
        pub fn dpu_execution_in_millis(mut self, input: i64) -> Self {
            self.dpu_execution_in_millis = Some(input);
            self
        }
        /// <p>The data processing unit execution time in milliseconds for the calculation.</p>
        pub fn set_dpu_execution_in_millis(mut self, input: std::option::Option<i64>) -> Self {
            self.dpu_execution_in_millis = input;
            self
        }
        /// <p>The progress of the calculation.</p>
        pub fn progress(mut self, input: impl Into<std::string::String>) -> Self {
            self.progress = Some(input.into());
            self
        }
        /// <p>The progress of the calculation.</p>
        pub fn set_progress(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.progress = input;
            self
        }
        /// Consumes the builder and constructs a [`CalculationStatistics`](crate::model::CalculationStatistics).
        pub fn build(self) -> crate::model::CalculationStatistics {
            crate::model::CalculationStatistics {
                dpu_execution_in_millis: self.dpu_execution_in_millis,
                progress: self.progress,
            }
        }
    }
}
impl CalculationStatistics {
    /// Creates a new builder-style object to manufacture [`CalculationStatistics`](crate::model::CalculationStatistics).
    pub fn builder() -> crate::model::calculation_statistics::Builder {
        crate::model::calculation_statistics::Builder::default()
    }
}

/// <p>Contains information about an application-specific calculation result.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CalculationResult {
    /// <p>The Amazon S3 location of the <code>stdout</code> file for the calculation.</p>
    #[doc(hidden)]
    pub std_out_s3_uri: std::option::Option<std::string::String>,
    /// <p>The Amazon S3 location of the <code>stderr</code> error messages file for the calculation.</p>
    #[doc(hidden)]
    pub std_error_s3_uri: std::option::Option<std::string::String>,
    /// <p>The Amazon S3 location of the folder for the calculation results.</p>
    #[doc(hidden)]
    pub result_s3_uri: std::option::Option<std::string::String>,
    /// <p>The data format of the calculation result.</p>
    #[doc(hidden)]
    pub result_type: std::option::Option<std::string::String>,
}
impl CalculationResult {
    /// <p>The Amazon S3 location of the <code>stdout</code> file for the calculation.</p>
    pub fn std_out_s3_uri(&self) -> std::option::Option<&str> {
        self.std_out_s3_uri.as_deref()
    }
    /// <p>The Amazon S3 location of the <code>stderr</code> error messages file for the calculation.</p>
    pub fn std_error_s3_uri(&self) -> std::option::Option<&str> {
        self.std_error_s3_uri.as_deref()
    }
    /// <p>The Amazon S3 location of the folder for the calculation results.</p>
    pub fn result_s3_uri(&self) -> std::option::Option<&str> {
        self.result_s3_uri.as_deref()
    }
    /// <p>The data format of the calculation result.</p>
    pub fn result_type(&self) -> std::option::Option<&str> {
        self.result_type.as_deref()
    }
}
/// See [`CalculationResult`](crate::model::CalculationResult).
pub mod calculation_result {

    /// A builder for [`CalculationResult`](crate::model::CalculationResult).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) std_out_s3_uri: std::option::Option<std::string::String>,
        pub(crate) std_error_s3_uri: std::option::Option<std::string::String>,
        pub(crate) result_s3_uri: std::option::Option<std::string::String>,
        pub(crate) result_type: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon S3 location of the <code>stdout</code> file for the calculation.</p>
        pub fn std_out_s3_uri(mut self, input: impl Into<std::string::String>) -> Self {
            self.std_out_s3_uri = Some(input.into());
            self
        }
        /// <p>The Amazon S3 location of the <code>stdout</code> file for the calculation.</p>
        pub fn set_std_out_s3_uri(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.std_out_s3_uri = input;
            self
        }
        /// <p>The Amazon S3 location of the <code>stderr</code> error messages file for the calculation.</p>
        pub fn std_error_s3_uri(mut self, input: impl Into<std::string::String>) -> Self {
            self.std_error_s3_uri = Some(input.into());
            self
        }
        /// <p>The Amazon S3 location of the <code>stderr</code> error messages file for the calculation.</p>
        pub fn set_std_error_s3_uri(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.std_error_s3_uri = input;
            self
        }
        /// <p>The Amazon S3 location of the folder for the calculation results.</p>
        pub fn result_s3_uri(mut self, input: impl Into<std::string::String>) -> Self {
            self.result_s3_uri = Some(input.into());
            self
        }
        /// <p>The Amazon S3 location of the folder for the calculation results.</p>
        pub fn set_result_s3_uri(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.result_s3_uri = input;
            self
        }
        /// <p>The data format of the calculation result.</p>
        pub fn result_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.result_type = Some(input.into());
            self
        }
        /// <p>The data format of the calculation result.</p>
        pub fn set_result_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.result_type = input;
            self
        }
        /// Consumes the builder and constructs a [`CalculationResult`](crate::model::CalculationResult).
        pub fn build(self) -> crate::model::CalculationResult {
            crate::model::CalculationResult {
                std_out_s3_uri: self.std_out_s3_uri,
                std_error_s3_uri: self.std_error_s3_uri,
                result_s3_uri: self.result_s3_uri,
                result_type: self.result_type,
            }
        }
    }
}
impl CalculationResult {
    /// Creates a new builder-style object to manufacture [`CalculationResult`](crate::model::CalculationResult).
    pub fn builder() -> crate::model::calculation_result::Builder {
        crate::model::calculation_result::Builder::default()
    }
}

/// <p>Describes a query execution that failed to process.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct UnprocessedQueryExecutionId {
    /// <p>The unique identifier of the query execution.</p>
    #[doc(hidden)]
    pub query_execution_id: std::option::Option<std::string::String>,
    /// <p>The error code returned when the query execution failed to process, if applicable.</p>
    #[doc(hidden)]
    pub error_code: std::option::Option<std::string::String>,
    /// <p>The error message returned when the query execution failed to process, if applicable.</p>
    #[doc(hidden)]
    pub error_message: std::option::Option<std::string::String>,
}
impl UnprocessedQueryExecutionId {
    /// <p>The unique identifier of the query execution.</p>
    pub fn query_execution_id(&self) -> std::option::Option<&str> {
        self.query_execution_id.as_deref()
    }
    /// <p>The error code returned when the query execution failed to process, if applicable.</p>
    pub fn error_code(&self) -> std::option::Option<&str> {
        self.error_code.as_deref()
    }
    /// <p>The error message returned when the query execution failed to process, if applicable.</p>
    pub fn error_message(&self) -> std::option::Option<&str> {
        self.error_message.as_deref()
    }
}
/// See [`UnprocessedQueryExecutionId`](crate::model::UnprocessedQueryExecutionId).
pub mod unprocessed_query_execution_id {

    /// A builder for [`UnprocessedQueryExecutionId`](crate::model::UnprocessedQueryExecutionId).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) query_execution_id: std::option::Option<std::string::String>,
        pub(crate) error_code: std::option::Option<std::string::String>,
        pub(crate) error_message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The unique identifier of the query execution.</p>
        pub fn query_execution_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.query_execution_id = Some(input.into());
            self
        }
        /// <p>The unique identifier of the query execution.</p>
        pub fn set_query_execution_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.query_execution_id = input;
            self
        }
        /// <p>The error code returned when the query execution failed to process, if applicable.</p>
        pub fn error_code(mut self, input: impl Into<std::string::String>) -> Self {
            self.error_code = Some(input.into());
            self
        }
        /// <p>The error code returned when the query execution failed to process, if applicable.</p>
        pub fn set_error_code(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.error_code = input;
            self
        }
        /// <p>The error message returned when the query execution failed to process, if applicable.</p>
        pub fn error_message(mut self, input: impl Into<std::string::String>) -> Self {
            self.error_message = Some(input.into());
            self
        }
        /// <p>The error message returned when the query execution failed to process, if applicable.</p>
        pub fn set_error_message(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.error_message = input;
            self
        }
        /// Consumes the builder and constructs a [`UnprocessedQueryExecutionId`](crate::model::UnprocessedQueryExecutionId).
        pub fn build(self) -> crate::model::UnprocessedQueryExecutionId {
            crate::model::UnprocessedQueryExecutionId {
                query_execution_id: self.query_execution_id,
                error_code: self.error_code,
                error_message: self.error_message,
            }
        }
    }
}
impl UnprocessedQueryExecutionId {
    /// Creates a new builder-style object to manufacture [`UnprocessedQueryExecutionId`](crate::model::UnprocessedQueryExecutionId).
    pub fn builder() -> crate::model::unprocessed_query_execution_id::Builder {
        crate::model::unprocessed_query_execution_id::Builder::default()
    }
}

/// <p>The name of a prepared statement that could not be returned.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct UnprocessedPreparedStatementName {
    /// <p>The name of a prepared statement that could not be returned due to an error.</p>
    #[doc(hidden)]
    pub statement_name: std::option::Option<std::string::String>,
    /// <p>The error code returned when the request for the prepared statement failed.</p>
    #[doc(hidden)]
    pub error_code: std::option::Option<std::string::String>,
    /// <p>The error message containing the reason why the prepared statement could not be returned. The following error messages are possible:</p>
    /// <ul>
    /// <li> <p> <code>INVALID_INPUT</code> - The name of the prepared statement that was provided is not valid (for example, the name is too long).</p> </li>
    /// <li> <p> <code>STATEMENT_NOT_FOUND</code> - A prepared statement with the name provided could not be found.</p> </li>
    /// <li> <p> <code>UNAUTHORIZED</code> - The requester does not have permission to access the workgroup that contains the prepared statement.</p> </li>
    /// </ul>
    #[doc(hidden)]
    pub error_message: std::option::Option<std::string::String>,
}
impl UnprocessedPreparedStatementName {
    /// <p>The name of a prepared statement that could not be returned due to an error.</p>
    pub fn statement_name(&self) -> std::option::Option<&str> {
        self.statement_name.as_deref()
    }
    /// <p>The error code returned when the request for the prepared statement failed.</p>
    pub fn error_code(&self) -> std::option::Option<&str> {
        self.error_code.as_deref()
    }
    /// <p>The error message containing the reason why the prepared statement could not be returned. The following error messages are possible:</p>
    /// <ul>
    /// <li> <p> <code>INVALID_INPUT</code> - The name of the prepared statement that was provided is not valid (for example, the name is too long).</p> </li>
    /// <li> <p> <code>STATEMENT_NOT_FOUND</code> - A prepared statement with the name provided could not be found.</p> </li>
    /// <li> <p> <code>UNAUTHORIZED</code> - The requester does not have permission to access the workgroup that contains the prepared statement.</p> </li>
    /// </ul>
    pub fn error_message(&self) -> std::option::Option<&str> {
        self.error_message.as_deref()
    }
}
/// See [`UnprocessedPreparedStatementName`](crate::model::UnprocessedPreparedStatementName).
pub mod unprocessed_prepared_statement_name {

    /// A builder for [`UnprocessedPreparedStatementName`](crate::model::UnprocessedPreparedStatementName).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) statement_name: std::option::Option<std::string::String>,
        pub(crate) error_code: std::option::Option<std::string::String>,
        pub(crate) error_message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of a prepared statement that could not be returned due to an error.</p>
        pub fn statement_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.statement_name = Some(input.into());
            self
        }
        /// <p>The name of a prepared statement that could not be returned due to an error.</p>
        pub fn set_statement_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.statement_name = input;
            self
        }
        /// <p>The error code returned when the request for the prepared statement failed.</p>
        pub fn error_code(mut self, input: impl Into<std::string::String>) -> Self {
            self.error_code = Some(input.into());
            self
        }
        /// <p>The error code returned when the request for the prepared statement failed.</p>
        pub fn set_error_code(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.error_code = input;
            self
        }
        /// <p>The error message containing the reason why the prepared statement could not be returned. The following error messages are possible:</p>
        /// <ul>
        /// <li> <p> <code>INVALID_INPUT</code> - The name of the prepared statement that was provided is not valid (for example, the name is too long).</p> </li>
        /// <li> <p> <code>STATEMENT_NOT_FOUND</code> - A prepared statement with the name provided could not be found.</p> </li>
        /// <li> <p> <code>UNAUTHORIZED</code> - The requester does not have permission to access the workgroup that contains the prepared statement.</p> </li>
        /// </ul>
        pub fn error_message(mut self, input: impl Into<std::string::String>) -> Self {
            self.error_message = Some(input.into());
            self
        }
        /// <p>The error message containing the reason why the prepared statement could not be returned. The following error messages are possible:</p>
        /// <ul>
        /// <li> <p> <code>INVALID_INPUT</code> - The name of the prepared statement that was provided is not valid (for example, the name is too long).</p> </li>
        /// <li> <p> <code>STATEMENT_NOT_FOUND</code> - A prepared statement with the name provided could not be found.</p> </li>
        /// <li> <p> <code>UNAUTHORIZED</code> - The requester does not have permission to access the workgroup that contains the prepared statement.</p> </li>
        /// </ul>
        pub fn set_error_message(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.error_message = input;
            self
        }
        /// Consumes the builder and constructs a [`UnprocessedPreparedStatementName`](crate::model::UnprocessedPreparedStatementName).
        pub fn build(self) -> crate::model::UnprocessedPreparedStatementName {
            crate::model::UnprocessedPreparedStatementName {
                statement_name: self.statement_name,
                error_code: self.error_code,
                error_message: self.error_message,
            }
        }
    }
}
impl UnprocessedPreparedStatementName {
    /// Creates a new builder-style object to manufacture [`UnprocessedPreparedStatementName`](crate::model::UnprocessedPreparedStatementName).
    pub fn builder() -> crate::model::unprocessed_prepared_statement_name::Builder {
        crate::model::unprocessed_prepared_statement_name::Builder::default()
    }
}

/// <p>Information about a named query ID that could not be processed.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct UnprocessedNamedQueryId {
    /// <p>The unique identifier of the named query.</p>
    #[doc(hidden)]
    pub named_query_id: std::option::Option<std::string::String>,
    /// <p>The error code returned when the processing request for the named query failed, if applicable.</p>
    #[doc(hidden)]
    pub error_code: std::option::Option<std::string::String>,
    /// <p>The error message returned when the processing request for the named query failed, if applicable.</p>
    #[doc(hidden)]
    pub error_message: std::option::Option<std::string::String>,
}
impl UnprocessedNamedQueryId {
    /// <p>The unique identifier of the named query.</p>
    pub fn named_query_id(&self) -> std::option::Option<&str> {
        self.named_query_id.as_deref()
    }
    /// <p>The error code returned when the processing request for the named query failed, if applicable.</p>
    pub fn error_code(&self) -> std::option::Option<&str> {
        self.error_code.as_deref()
    }
    /// <p>The error message returned when the processing request for the named query failed, if applicable.</p>
    pub fn error_message(&self) -> std::option::Option<&str> {
        self.error_message.as_deref()
    }
}
/// See [`UnprocessedNamedQueryId`](crate::model::UnprocessedNamedQueryId).
pub mod unprocessed_named_query_id {

    /// A builder for [`UnprocessedNamedQueryId`](crate::model::UnprocessedNamedQueryId).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) named_query_id: std::option::Option<std::string::String>,
        pub(crate) error_code: std::option::Option<std::string::String>,
        pub(crate) error_message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The unique identifier of the named query.</p>
        pub fn named_query_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.named_query_id = Some(input.into());
            self
        }
        /// <p>The unique identifier of the named query.</p>
        pub fn set_named_query_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.named_query_id = input;
            self
        }
        /// <p>The error code returned when the processing request for the named query failed, if applicable.</p>
        pub fn error_code(mut self, input: impl Into<std::string::String>) -> Self {
            self.error_code = Some(input.into());
            self
        }
        /// <p>The error code returned when the processing request for the named query failed, if applicable.</p>
        pub fn set_error_code(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.error_code = input;
            self
        }
        /// <p>The error message returned when the processing request for the named query failed, if applicable.</p>
        pub fn error_message(mut self, input: impl Into<std::string::String>) -> Self {
            self.error_message = Some(input.into());
            self
        }
        /// <p>The error message returned when the processing request for the named query failed, if applicable.</p>
        pub fn set_error_message(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.error_message = input;
            self
        }
        /// Consumes the builder and constructs a [`UnprocessedNamedQueryId`](crate::model::UnprocessedNamedQueryId).
        pub fn build(self) -> crate::model::UnprocessedNamedQueryId {
            crate::model::UnprocessedNamedQueryId {
                named_query_id: self.named_query_id,
                error_code: self.error_code,
                error_message: self.error_message,
            }
        }
    }
}
impl UnprocessedNamedQueryId {
    /// Creates a new builder-style object to manufacture [`UnprocessedNamedQueryId`](crate::model::UnprocessedNamedQueryId).
    pub fn builder() -> crate::model::unprocessed_named_query_id::Builder {
        crate::model::unprocessed_named_query_id::Builder::default()
    }
}
